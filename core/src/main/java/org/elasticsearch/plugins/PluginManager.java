begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.plugins
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|plugins
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterators
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchTimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|bootstrap
operator|.
name|JarHell
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|cli
operator|.
name|Terminal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|http
operator|.
name|client
operator|.
name|HttpDownloadHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|FileSystemUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|plugins
operator|.
name|PluginsService
operator|.
name|Bundle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URL
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|URLClassLoader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|BasicFileAttributes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|PosixFileAttributeView
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|PosixFilePermission
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipEntry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|zip
operator|.
name|ZipInputStream
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
operator|.
name|hasLength
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|cli
operator|.
name|Terminal
operator|.
name|Verbosity
operator|.
name|VERBOSE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|FileSystemUtils
operator|.
name|moveFilesWithoutOverwriting
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|PluginManager
specifier|public
class|class
name|PluginManager
block|{
DECL|enum|OutputMode
specifier|public
enum|enum
name|OutputMode
block|{
DECL|enum constant|DEFAULT
DECL|enum constant|SILENT
DECL|enum constant|VERBOSE
name|DEFAULT
block|,
name|SILENT
block|,
name|VERBOSE
block|}
DECL|field|BLACKLIST
specifier|private
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|BLACKLIST
init|=
name|ImmutableSet
operator|.
expr|<
name|String
operator|>
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"elasticsearch"
argument_list|,
literal|"elasticsearch.bat"
argument_list|,
literal|"elasticsearch.in.sh"
argument_list|,
literal|"plugin"
argument_list|,
literal|"plugin.bat"
argument_list|,
literal|"service.bat"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|field|OFFICIAL_PLUGINS
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|String
argument_list|>
name|OFFICIAL_PLUGINS
init|=
name|ImmutableSet
operator|.
expr|<
name|String
operator|>
name|builder
argument_list|()
operator|.
name|add
argument_list|(
literal|"elasticsearch-analysis-icu"
argument_list|,
literal|"elasticsearch-analysis-kuromoji"
argument_list|,
literal|"elasticsearch-analysis-phonetic"
argument_list|,
literal|"elasticsearch-analysis-smartcn"
argument_list|,
literal|"elasticsearch-analysis-stempel"
argument_list|,
literal|"elasticsearch-cloud-aws"
argument_list|,
literal|"elasticsearch-cloud-azure"
argument_list|,
literal|"elasticsearch-cloud-gce"
argument_list|,
literal|"elasticsearch-delete-by-query"
argument_list|,
literal|"elasticsearch-lang-javascript"
argument_list|,
literal|"elasticsearch-lang-python"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
DECL|field|environment
specifier|private
specifier|final
name|Environment
name|environment
decl_stmt|;
DECL|field|url
specifier|private
name|String
name|url
decl_stmt|;
DECL|field|outputMode
specifier|private
name|OutputMode
name|outputMode
decl_stmt|;
DECL|field|timeout
specifier|private
name|TimeValue
name|timeout
decl_stmt|;
DECL|method|PluginManager
specifier|public
name|PluginManager
parameter_list|(
name|Environment
name|environment
parameter_list|,
name|String
name|url
parameter_list|,
name|OutputMode
name|outputMode
parameter_list|,
name|TimeValue
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|environment
operator|=
name|environment
expr_stmt|;
name|this
operator|.
name|url
operator|=
name|url
expr_stmt|;
name|this
operator|.
name|outputMode
operator|=
name|outputMode
expr_stmt|;
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
block|}
DECL|method|downloadAndExtract
specifier|public
name|void
name|downloadAndExtract
parameter_list|(
name|String
name|name
parameter_list|,
name|Terminal
name|terminal
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"plugin name must be supplied with install [name]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|environment
operator|.
name|pluginsFile
argument_list|()
argument_list|)
condition|)
block|{
name|terminal
operator|.
name|println
argument_list|(
literal|"Plugins directory [%s] does not exist. Creating..."
argument_list|,
name|environment
operator|.
name|pluginsFile
argument_list|()
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createDirectory
argument_list|(
name|environment
operator|.
name|pluginsFile
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Files
operator|.
name|isWritable
argument_list|(
name|environment
operator|.
name|pluginsFile
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"plugin directory "
operator|+
name|environment
operator|.
name|pluginsFile
argument_list|()
operator|+
literal|" is read only"
argument_list|)
throw|;
block|}
name|PluginHandle
name|pluginHandle
init|=
name|PluginHandle
operator|.
name|parse
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|checkForForbiddenName
argument_list|(
name|pluginHandle
operator|.
name|name
argument_list|)
expr_stmt|;
name|Path
name|pluginFile
init|=
name|download
argument_list|(
name|pluginHandle
argument_list|,
name|terminal
argument_list|)
decl_stmt|;
name|extract
argument_list|(
name|pluginHandle
argument_list|,
name|terminal
argument_list|,
name|pluginFile
argument_list|)
expr_stmt|;
block|}
DECL|method|download
specifier|private
name|Path
name|download
parameter_list|(
name|PluginHandle
name|pluginHandle
parameter_list|,
name|Terminal
name|terminal
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|pluginFile
init|=
name|pluginHandle
operator|.
name|newDistroFile
argument_list|(
name|environment
argument_list|)
decl_stmt|;
name|HttpDownloadHelper
name|downloadHelper
init|=
operator|new
name|HttpDownloadHelper
argument_list|()
decl_stmt|;
name|boolean
name|downloaded
init|=
literal|false
decl_stmt|;
name|HttpDownloadHelper
operator|.
name|DownloadProgress
name|progress
decl_stmt|;
if|if
condition|(
name|outputMode
operator|==
name|OutputMode
operator|.
name|SILENT
condition|)
block|{
name|progress
operator|=
operator|new
name|HttpDownloadHelper
operator|.
name|NullProgress
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|progress
operator|=
operator|new
name|HttpDownloadHelper
operator|.
name|VerboseProgress
argument_list|(
name|terminal
operator|.
name|writer
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// first, try directly from the URL provided
if|if
condition|(
name|url
operator|!=
literal|null
condition|)
block|{
name|URL
name|pluginUrl
init|=
operator|new
name|URL
argument_list|(
name|url
argument_list|)
decl_stmt|;
name|boolean
name|isSecureProcotol
init|=
literal|"https"
operator|.
name|equalsIgnoreCase
argument_list|(
name|pluginUrl
operator|.
name|getProtocol
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|isAuthInfoSet
init|=
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|pluginUrl
operator|.
name|getUserInfo
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|isAuthInfoSet
operator|&&
operator|!
name|isSecureProcotol
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Basic auth is only supported for HTTPS!"
argument_list|)
throw|;
block|}
name|terminal
operator|.
name|println
argument_list|(
literal|"Trying %s ..."
argument_list|,
name|pluginUrl
operator|.
name|toExternalForm
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|downloadHelper
operator|.
name|download
argument_list|(
name|pluginUrl
argument_list|,
name|pluginFile
argument_list|,
name|progress
argument_list|,
name|this
operator|.
name|timeout
argument_list|)
expr_stmt|;
name|downloaded
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ElasticsearchTimeoutException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ignore
name|terminal
operator|.
name|println
argument_list|(
literal|"Failed: %s"
argument_list|,
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|PluginHandle
operator|.
name|isOfficialPlugin
argument_list|(
name|pluginHandle
operator|.
name|repo
argument_list|,
name|pluginHandle
operator|.
name|user
argument_list|,
name|pluginHandle
operator|.
name|version
argument_list|)
condition|)
block|{
name|checkForOfficialPlugins
argument_list|(
name|pluginHandle
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|downloaded
condition|)
block|{
comment|// We try all possible locations
for|for
control|(
name|URL
name|url
range|:
name|pluginHandle
operator|.
name|urls
argument_list|()
control|)
block|{
name|terminal
operator|.
name|println
argument_list|(
literal|"Trying %s ..."
argument_list|,
name|url
operator|.
name|toExternalForm
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|downloadHelper
operator|.
name|download
argument_list|(
name|url
argument_list|,
name|pluginFile
argument_list|,
name|progress
argument_list|,
name|this
operator|.
name|timeout
argument_list|)
expr_stmt|;
name|downloaded
operator|=
literal|true
expr_stmt|;
break|break;
block|}
catch|catch
parameter_list|(
name|ElasticsearchTimeoutException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Failed: %s"
argument_list|,
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|downloaded
condition|)
block|{
comment|// try to cleanup what we downloaded
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|pluginFile
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to download out of all possible locations..., use --verbose to get detailed information"
argument_list|)
throw|;
block|}
return|return
name|pluginFile
return|;
block|}
DECL|method|extract
specifier|private
name|void
name|extract
parameter_list|(
name|PluginHandle
name|pluginHandle
parameter_list|,
name|Terminal
name|terminal
parameter_list|,
name|Path
name|pluginFile
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
name|extractLocation
init|=
name|pluginHandle
operator|.
name|extractedDir
argument_list|(
name|environment
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|extractLocation
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"plugin directory "
operator|+
name|extractLocation
operator|.
name|toAbsolutePath
argument_list|()
operator|+
literal|" already exists. To update the plugin, uninstall it first using 'remove "
operator|+
name|pluginHandle
operator|.
name|name
operator|+
literal|"' command"
argument_list|)
throw|;
block|}
comment|// unzip plugin to a staging temp dir, named for the plugin
name|Path
name|tmp
init|=
name|Files
operator|.
name|createTempDirectory
argument_list|(
name|environment
operator|.
name|tmpFile
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Path
name|root
init|=
name|tmp
operator|.
name|resolve
argument_list|(
name|pluginHandle
operator|.
name|name
argument_list|)
decl_stmt|;
name|unzipPlugin
argument_list|(
name|pluginFile
argument_list|,
name|root
argument_list|)
expr_stmt|;
comment|// find the actual root (in case its unzipped with extra directory wrapping)
name|root
operator|=
name|findPluginRoot
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|// read and validate the plugin descriptor
name|PluginInfo
name|info
init|=
name|PluginInfo
operator|.
name|readFromProperties
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|terminal
operator|.
name|println
argument_list|(
literal|"%s"
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|// check for jar hell before any copying
if|if
condition|(
name|info
operator|.
name|isJvm
argument_list|()
condition|)
block|{
name|jarHellCheck
argument_list|(
name|root
argument_list|,
name|info
operator|.
name|isIsolated
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// install plugin
name|FileSystemUtils
operator|.
name|copyDirectoryRecursively
argument_list|(
name|root
argument_list|,
name|extractLocation
argument_list|)
expr_stmt|;
name|terminal
operator|.
name|println
argument_list|(
literal|"Installed %s into %s"
argument_list|,
name|pluginHandle
operator|.
name|name
argument_list|,
name|extractLocation
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// cleanup
name|IOUtils
operator|.
name|rm
argument_list|(
name|tmp
argument_list|,
name|pluginFile
argument_list|)
expr_stmt|;
comment|// take care of bin/ by moving and applying permissions if needed
name|Path
name|binFile
init|=
name|extractLocation
operator|.
name|resolve
argument_list|(
literal|"bin"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|binFile
argument_list|)
condition|)
block|{
name|Path
name|toLocation
init|=
name|pluginHandle
operator|.
name|binDir
argument_list|(
name|environment
argument_list|)
decl_stmt|;
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Found bin, moving to %s"
argument_list|,
name|toLocation
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|toLocation
argument_list|)
condition|)
block|{
name|IOUtils
operator|.
name|rm
argument_list|(
name|toLocation
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|FileSystemUtils
operator|.
name|move
argument_list|(
name|binFile
argument_list|,
name|toLocation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Could not move ["
operator|+
name|binFile
operator|+
literal|"] to ["
operator|+
name|toLocation
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|Files
operator|.
name|getFileStore
argument_list|(
name|toLocation
argument_list|)
operator|.
name|supportsFileAttributeView
argument_list|(
name|PosixFileAttributeView
operator|.
name|class
argument_list|)
condition|)
block|{
comment|// add read and execute permissions to existing perms, so execution will work.
comment|// read should generally be set already, but set it anyway: don't rely on umask...
specifier|final
name|Set
argument_list|<
name|PosixFilePermission
argument_list|>
name|executePerms
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|executePerms
operator|.
name|add
argument_list|(
name|PosixFilePermission
operator|.
name|OWNER_READ
argument_list|)
expr_stmt|;
name|executePerms
operator|.
name|add
argument_list|(
name|PosixFilePermission
operator|.
name|GROUP_READ
argument_list|)
expr_stmt|;
name|executePerms
operator|.
name|add
argument_list|(
name|PosixFilePermission
operator|.
name|OTHERS_READ
argument_list|)
expr_stmt|;
name|executePerms
operator|.
name|add
argument_list|(
name|PosixFilePermission
operator|.
name|OWNER_EXECUTE
argument_list|)
expr_stmt|;
name|executePerms
operator|.
name|add
argument_list|(
name|PosixFilePermission
operator|.
name|GROUP_EXECUTE
argument_list|)
expr_stmt|;
name|executePerms
operator|.
name|add
argument_list|(
name|PosixFilePermission
operator|.
name|OTHERS_EXECUTE
argument_list|)
expr_stmt|;
name|Files
operator|.
name|walkFileTree
argument_list|(
name|toLocation
argument_list|,
operator|new
name|SimpleFileVisitor
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileVisitResult
name|visitFile
parameter_list|(
name|Path
name|file
parameter_list|,
name|BasicFileAttributes
name|attrs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|attrs
operator|.
name|isRegularFile
argument_list|()
condition|)
block|{
name|Set
argument_list|<
name|PosixFilePermission
argument_list|>
name|perms
init|=
name|Files
operator|.
name|getPosixFilePermissions
argument_list|(
name|file
argument_list|)
decl_stmt|;
name|perms
operator|.
name|addAll
argument_list|(
name|executePerms
argument_list|)
expr_stmt|;
name|Files
operator|.
name|setPosixFilePermissions
argument_list|(
name|file
argument_list|,
name|perms
argument_list|)
expr_stmt|;
block|}
return|return
name|FileVisitResult
operator|.
name|CONTINUE
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Skipping posix permissions - filestore doesn't support posix permission"
argument_list|)
expr_stmt|;
block|}
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Installed %s into %s"
argument_list|,
name|pluginHandle
operator|.
name|name
argument_list|,
name|toLocation
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Path
name|configFile
init|=
name|extractLocation
operator|.
name|resolve
argument_list|(
literal|"config"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|configFile
argument_list|)
condition|)
block|{
name|Path
name|configDestLocation
init|=
name|pluginHandle
operator|.
name|configDir
argument_list|(
name|environment
argument_list|)
decl_stmt|;
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Found config, moving to %s"
argument_list|,
name|configDestLocation
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|moveFilesWithoutOverwriting
argument_list|(
name|configFile
argument_list|,
name|configDestLocation
argument_list|,
literal|".new"
argument_list|)
expr_stmt|;
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Installed %s into %s"
argument_list|,
name|pluginHandle
operator|.
name|name
argument_list|,
name|configDestLocation
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** we check whether we need to remove the top-level folder while extracting      *  sometimes (e.g. github) the downloaded archive contains a top-level folder which needs to be removed      */
DECL|method|findPluginRoot
specifier|private
name|Path
name|findPluginRoot
parameter_list|(
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|dir
operator|.
name|resolve
argument_list|(
name|PluginInfo
operator|.
name|ES_PLUGIN_PROPERTIES
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|dir
return|;
block|}
else|else
block|{
specifier|final
name|Path
index|[]
name|topLevelFiles
init|=
name|FileSystemUtils
operator|.
name|files
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|topLevelFiles
operator|.
name|length
operator|==
literal|1
operator|&&
name|Files
operator|.
name|isDirectory
argument_list|(
name|topLevelFiles
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|Path
name|subdir
init|=
name|topLevelFiles
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|subdir
operator|.
name|resolve
argument_list|(
name|PluginInfo
operator|.
name|ES_PLUGIN_PROPERTIES
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|subdir
return|;
block|}
block|}
block|}
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not find plugin descriptor '"
operator|+
name|PluginInfo
operator|.
name|ES_PLUGIN_PROPERTIES
operator|+
literal|"' in plugin zip"
argument_list|)
throw|;
block|}
comment|/** check a candidate plugin for jar hell before installing it */
DECL|method|jarHellCheck
specifier|private
name|void
name|jarHellCheck
parameter_list|(
name|Path
name|candidate
parameter_list|,
name|boolean
name|isolated
parameter_list|)
throws|throws
name|IOException
block|{
comment|// create list of current jars in classpath
specifier|final
name|List
argument_list|<
name|URL
argument_list|>
name|jars
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ClassLoader
name|loader
init|=
name|PluginManager
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
if|if
condition|(
name|loader
operator|instanceof
name|URLClassLoader
condition|)
block|{
name|Collections
operator|.
name|addAll
argument_list|(
name|jars
argument_list|,
operator|(
operator|(
name|URLClassLoader
operator|)
name|loader
operator|)
operator|.
name|getURLs
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// read existing bundles. this does some checks on the installation too.
name|List
argument_list|<
name|Bundle
argument_list|>
name|bundles
init|=
name|PluginsService
operator|.
name|getPluginBundles
argument_list|(
name|environment
argument_list|)
decl_stmt|;
comment|// if we aren't isolated, we need to jarhellcheck against any other non-isolated plugins
comment|// thats always the first bundle
if|if
condition|(
name|isolated
operator|==
literal|false
condition|)
block|{
name|jars
operator|.
name|addAll
argument_list|(
name|bundles
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|urls
argument_list|)
expr_stmt|;
block|}
comment|// add plugin jars to the list
name|Path
name|pluginJars
index|[]
init|=
name|FileSystemUtils
operator|.
name|files
argument_list|(
name|candidate
argument_list|,
literal|"*.jar"
argument_list|)
decl_stmt|;
for|for
control|(
name|Path
name|jar
range|:
name|pluginJars
control|)
block|{
name|jars
operator|.
name|add
argument_list|(
name|jar
operator|.
name|toUri
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// check combined (current classpath + new jars to-be-added)
try|try
block|{
name|JarHell
operator|.
name|checkJarHell
argument_list|(
name|jars
operator|.
name|toArray
argument_list|(
operator|new
name|URL
index|[
name|jars
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|unzipPlugin
specifier|private
name|void
name|unzipPlugin
parameter_list|(
name|Path
name|zip
parameter_list|,
name|Path
name|target
parameter_list|)
throws|throws
name|IOException
block|{
name|Files
operator|.
name|createDirectories
argument_list|(
name|target
argument_list|)
expr_stmt|;
try|try
init|(
name|ZipInputStream
name|zipInput
init|=
operator|new
name|ZipInputStream
argument_list|(
name|Files
operator|.
name|newInputStream
argument_list|(
name|zip
argument_list|)
argument_list|)
init|)
block|{
name|ZipEntry
name|entry
decl_stmt|;
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
literal|8192
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|entry
operator|=
name|zipInput
operator|.
name|getNextEntry
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|Path
name|targetFile
init|=
name|target
operator|.
name|resolve
argument_list|(
name|entry
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|// be on the safe side: do not rely on that directories are always extracted
comment|// before their children (although this makes sense, but is it guaranteed?)
name|Files
operator|.
name|createDirectories
argument_list|(
name|targetFile
operator|.
name|getParent
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|.
name|isDirectory
argument_list|()
operator|==
literal|false
condition|)
block|{
try|try
init|(
name|OutputStream
name|out
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|targetFile
argument_list|)
init|)
block|{
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|zipInput
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|zipInput
operator|.
name|closeEntry
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|removePlugin
specifier|public
name|void
name|removePlugin
parameter_list|(
name|String
name|name
parameter_list|,
name|Terminal
name|terminal
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|name
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"plugin name must be supplied with remove [name]."
argument_list|)
throw|;
block|}
name|PluginHandle
name|pluginHandle
init|=
name|PluginHandle
operator|.
name|parse
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
name|checkForForbiddenName
argument_list|(
name|pluginHandle
operator|.
name|name
argument_list|)
expr_stmt|;
name|Path
name|pluginToDelete
init|=
name|pluginHandle
operator|.
name|extractedDir
argument_list|(
name|environment
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|pluginToDelete
argument_list|)
condition|)
block|{
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Removing: %s"
argument_list|,
name|pluginToDelete
argument_list|)
expr_stmt|;
try|try
block|{
name|IOUtils
operator|.
name|rm
argument_list|(
name|pluginToDelete
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to remove "
operator|+
name|pluginHandle
operator|.
name|name
operator|+
literal|". Check file permissions on "
operator|+
name|pluginToDelete
operator|.
name|toString
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|removed
operator|=
literal|true
expr_stmt|;
block|}
name|Path
name|binLocation
init|=
name|pluginHandle
operator|.
name|binDir
argument_list|(
name|environment
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|binLocation
argument_list|)
condition|)
block|{
name|terminal
operator|.
name|println
argument_list|(
name|VERBOSE
argument_list|,
literal|"Removing: %s"
argument_list|,
name|binLocation
argument_list|)
expr_stmt|;
try|try
block|{
name|IOUtils
operator|.
name|rm
argument_list|(
name|binLocation
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Unable to remove "
operator|+
name|pluginHandle
operator|.
name|name
operator|+
literal|". Check file permissions on "
operator|+
name|binLocation
operator|.
name|toString
argument_list|()
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|removed
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|removed
condition|)
block|{
name|terminal
operator|.
name|println
argument_list|(
literal|"Removed %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal
operator|.
name|println
argument_list|(
literal|"Plugin %s not found. Run plugin --list to get list of installed plugins."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkForForbiddenName
specifier|private
specifier|static
name|void
name|checkForForbiddenName
parameter_list|(
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|name
argument_list|)
operator|||
name|BLACKLIST
operator|.
name|contains
argument_list|(
name|name
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal plugin name: "
operator|+
name|name
argument_list|)
throw|;
block|}
block|}
DECL|method|checkForOfficialPlugins
specifier|protected
specifier|static
name|void
name|checkForOfficialPlugins
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// We make sure that users can use only new short naming for official plugins only
if|if
condition|(
operator|!
name|OFFICIAL_PLUGINS
operator|.
name|contains
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|name
operator|+
literal|" is not an official plugin so you should install it using elasticsearch/"
operator|+
name|name
operator|+
literal|"/latest naming form."
argument_list|)
throw|;
block|}
block|}
DECL|method|getListInstalledPlugins
specifier|public
name|Path
index|[]
name|getListInstalledPlugins
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|Files
operator|.
name|exists
argument_list|(
name|environment
operator|.
name|pluginsFile
argument_list|()
argument_list|)
condition|)
block|{
return|return
operator|new
name|Path
index|[
literal|0
index|]
return|;
block|}
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|environment
operator|.
name|pluginsFile
argument_list|()
argument_list|)
init|)
block|{
return|return
name|Iterators
operator|.
name|toArray
argument_list|(
name|stream
operator|.
name|iterator
argument_list|()
argument_list|,
name|Path
operator|.
name|class
argument_list|)
return|;
block|}
block|}
DECL|method|listInstalledPlugins
specifier|public
name|void
name|listInstalledPlugins
parameter_list|(
name|Terminal
name|terminal
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
index|[]
name|plugins
init|=
name|getListInstalledPlugins
argument_list|()
decl_stmt|;
name|terminal
operator|.
name|println
argument_list|(
literal|"Installed plugins in %s:"
argument_list|,
name|environment
operator|.
name|pluginsFile
argument_list|()
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugins
operator|==
literal|null
operator|||
name|plugins
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|terminal
operator|.
name|println
argument_list|(
literal|"    - No plugin detected"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Path
name|plugin
range|:
name|plugins
control|)
block|{
name|terminal
operator|.
name|println
argument_list|(
literal|"    - "
operator|+
name|plugin
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Helper class to extract properly user name, repository name, version and plugin name      * from plugin name given by a user.      */
DECL|class|PluginHandle
specifier|static
class|class
name|PluginHandle
block|{
DECL|field|name
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|version
specifier|final
name|String
name|version
decl_stmt|;
DECL|field|user
specifier|final
name|String
name|user
decl_stmt|;
DECL|field|repo
specifier|final
name|String
name|repo
decl_stmt|;
DECL|method|PluginHandle
name|PluginHandle
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|version
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|repo
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|user
operator|=
name|user
expr_stmt|;
name|this
operator|.
name|repo
operator|=
name|repo
expr_stmt|;
block|}
DECL|method|urls
name|List
argument_list|<
name|URL
argument_list|>
name|urls
parameter_list|()
block|{
name|List
argument_list|<
name|URL
argument_list|>
name|urls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|null
condition|)
block|{
comment|// Elasticsearch new download service uses groupId org.elasticsearch.plugins from 2.0.0
if|if
condition|(
name|user
operator|==
literal|null
condition|)
block|{
comment|// TODO Update to https
if|if
condition|(
name|Version
operator|.
name|CURRENT
operator|.
name|snapshot
argument_list|()
condition|)
block|{
name|addUrl
argument_list|(
name|urls
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"http://download.elastic.co/elasticsearch/snapshot/org/elasticsearch/plugin/%s/%s-SNAPSHOT/%s-%s-SNAPSHOT.zip"
argument_list|,
name|repo
argument_list|,
name|version
argument_list|,
name|repo
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|addUrl
argument_list|(
name|urls
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"http://download.elastic.co/elasticsearch/release/org/elasticsearch/plugin/%s/%s/%s-%s.zip"
argument_list|,
name|repo
argument_list|,
name|version
argument_list|,
name|repo
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Elasticsearch old download service
comment|// TODO Update to https
name|addUrl
argument_list|(
name|urls
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"http://download.elastic.co/%1$s/%2$s/%2$s-%3$s.zip"
argument_list|,
name|user
argument_list|,
name|repo
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
comment|// Maven central repository
name|addUrl
argument_list|(
name|urls
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"http://search.maven.org/remotecontent?filepath=%1$s/%2$s/%3$s/%2$s-%3$s.zip"
argument_list|,
name|user
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|repo
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
comment|// Sonatype repository
name|addUrl
argument_list|(
name|urls
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"https://oss.sonatype.org/service/local/repositories/releases/content/%1$s/%2$s/%3$s/%2$s-%3$s.zip"
argument_list|,
name|user
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|repo
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
comment|// Github repository
name|addUrl
argument_list|(
name|urls
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"https://github.com/%1$s/%2$s/archive/%3$s.zip"
argument_list|,
name|user
argument_list|,
name|repo
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|user
operator|!=
literal|null
condition|)
block|{
comment|// Github repository for master branch (assume site)
name|addUrl
argument_list|(
name|urls
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"https://github.com/%1$s/%2$s/archive/master.zip"
argument_list|,
name|user
argument_list|,
name|repo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|urls
return|;
block|}
DECL|method|addUrl
specifier|private
specifier|static
name|void
name|addUrl
parameter_list|(
name|List
argument_list|<
name|URL
argument_list|>
name|urls
parameter_list|,
name|String
name|url
parameter_list|)
block|{
try|try
block|{
name|urls
operator|.
name|add
argument_list|(
operator|new
name|URL
argument_list|(
name|url
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
comment|// We simply ignore malformed URL
block|}
block|}
DECL|method|newDistroFile
name|Path
name|newDistroFile
parameter_list|(
name|Environment
name|env
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Files
operator|.
name|createTempFile
argument_list|(
name|env
operator|.
name|tmpFile
argument_list|()
argument_list|,
name|name
argument_list|,
literal|".zip"
argument_list|)
return|;
block|}
DECL|method|extractedDir
name|Path
name|extractedDir
parameter_list|(
name|Environment
name|env
parameter_list|)
block|{
return|return
name|env
operator|.
name|pluginsFile
argument_list|()
operator|.
name|resolve
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|binDir
name|Path
name|binDir
parameter_list|(
name|Environment
name|env
parameter_list|)
block|{
return|return
name|env
operator|.
name|binFile
argument_list|()
operator|.
name|resolve
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|configDir
name|Path
name|configDir
parameter_list|(
name|Environment
name|env
parameter_list|)
block|{
return|return
name|env
operator|.
name|configFile
argument_list|()
operator|.
name|resolve
argument_list|(
name|name
argument_list|)
return|;
block|}
DECL|method|parse
specifier|static
name|PluginHandle
name|parse
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|String
index|[]
name|elements
init|=
name|name
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
comment|// We first consider the simplest form: pluginname
name|String
name|repo
init|=
name|elements
index|[
literal|0
index|]
decl_stmt|;
name|String
name|user
init|=
literal|null
decl_stmt|;
name|String
name|version
init|=
literal|null
decl_stmt|;
comment|// We consider the form: username/pluginname
if|if
condition|(
name|elements
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|user
operator|=
name|elements
index|[
literal|0
index|]
expr_stmt|;
name|repo
operator|=
name|elements
index|[
literal|1
index|]
expr_stmt|;
comment|// We consider the form: username/pluginname/version
if|if
condition|(
name|elements
operator|.
name|length
operator|>
literal|2
condition|)
block|{
name|version
operator|=
name|elements
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
name|String
name|endname
init|=
name|repo
decl_stmt|;
if|if
condition|(
name|repo
operator|.
name|startsWith
argument_list|(
literal|"elasticsearch-"
argument_list|)
condition|)
block|{
comment|// remove elasticsearch- prefix
name|endname
operator|=
name|repo
operator|.
name|substring
argument_list|(
literal|"elasticsearch-"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|repo
operator|.
name|startsWith
argument_list|(
literal|"es-"
argument_list|)
condition|)
block|{
comment|// remove es- prefix
name|endname
operator|=
name|repo
operator|.
name|substring
argument_list|(
literal|"es-"
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isOfficialPlugin
argument_list|(
name|repo
argument_list|,
name|user
argument_list|,
name|version
argument_list|)
condition|)
block|{
return|return
operator|new
name|PluginHandle
argument_list|(
name|endname
argument_list|,
name|Version
operator|.
name|CURRENT
operator|.
name|number
argument_list|()
argument_list|,
literal|null
argument_list|,
name|repo
argument_list|)
return|;
block|}
return|return
operator|new
name|PluginHandle
argument_list|(
name|endname
argument_list|,
name|version
argument_list|,
name|user
argument_list|,
name|repo
argument_list|)
return|;
block|}
DECL|method|isOfficialPlugin
specifier|static
name|boolean
name|isOfficialPlugin
parameter_list|(
name|String
name|repo
parameter_list|,
name|String
name|user
parameter_list|,
name|String
name|version
parameter_list|)
block|{
return|return
name|version
operator|==
literal|null
operator|&&
name|user
operator|==
literal|null
operator|&&
operator|!
name|Strings
operator|.
name|isNullOrEmpty
argument_list|(
name|repo
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

