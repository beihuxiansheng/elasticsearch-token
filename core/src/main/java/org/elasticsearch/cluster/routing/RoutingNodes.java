begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.cluster.routing
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|ObjectIntHashMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectCursor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CollectionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|UnassignedInfo
operator|.
name|AllocationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Randomness
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_comment
comment|/**  * {@link RoutingNodes} represents a copy the routing information contained in the {@link ClusterState cluster state}.  * It can be either initialized as mutable or immutable (see {@link #RoutingNodes(ClusterState, boolean)}), allowing  * or disallowing changes to its elements.  *  * The main methods used to update routing entries are:  *<ul>  *<li> {@link #initializeShard} initializes an unassigned shard.  *<li> {@link #startShard} starts an initializing shard / completes relocation of a shard.  *<li> {@link #relocateShard} starts relocation of a started shard.  *<li> {@link #failShard} fails/cancels an assigned shard.  *</ul>  */
end_comment

begin_class
DECL|class|RoutingNodes
specifier|public
class|class
name|RoutingNodes
implements|implements
name|Iterable
argument_list|<
name|RoutingNode
argument_list|>
block|{
DECL|field|nodesToShards
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RoutingNode
argument_list|>
name|nodesToShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|unassignedShards
specifier|private
specifier|final
name|UnassignedShards
name|unassignedShards
init|=
operator|new
name|UnassignedShards
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|assignedShards
specifier|private
specifier|final
name|Map
argument_list|<
name|ShardId
argument_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|assignedShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|readOnly
specifier|private
specifier|final
name|boolean
name|readOnly
decl_stmt|;
DECL|field|inactivePrimaryCount
specifier|private
name|int
name|inactivePrimaryCount
init|=
literal|0
decl_stmt|;
DECL|field|inactiveShardCount
specifier|private
name|int
name|inactiveShardCount
init|=
literal|0
decl_stmt|;
DECL|field|relocatingShards
specifier|private
name|int
name|relocatingShards
init|=
literal|0
decl_stmt|;
DECL|field|nodesPerAttributeNames
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ObjectIntHashMap
argument_list|<
name|String
argument_list|>
argument_list|>
name|nodesPerAttributeNames
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|recoveriesPerNode
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Recoveries
argument_list|>
name|recoveriesPerNode
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|RoutingNodes
specifier|public
name|RoutingNodes
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|)
block|{
name|this
argument_list|(
name|clusterState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|RoutingNodes
specifier|public
name|RoutingNodes
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
block|{
name|this
operator|.
name|readOnly
operator|=
name|readOnly
expr_stmt|;
specifier|final
name|RoutingTable
name|routingTable
init|=
name|clusterState
operator|.
name|routingTable
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedHashMap
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
argument_list|>
name|nodesToShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// fill in the nodeToShards with the "live" nodes
for|for
control|(
name|ObjectCursor
argument_list|<
name|DiscoveryNode
argument_list|>
name|cursor
range|:
name|clusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getDataNodes
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|nodesToShards
operator|.
name|put
argument_list|(
name|cursor
operator|.
name|value
operator|.
name|getId
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
comment|// LinkedHashMap to preserve order
block|}
comment|// fill in the inverse of node -> shards allocated
comment|// also fill replicaSet information
for|for
control|(
name|ObjectCursor
argument_list|<
name|IndexRoutingTable
argument_list|>
name|indexRoutingTable
range|:
name|routingTable
operator|.
name|indicesRouting
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|IndexShardRoutingTable
name|indexShard
range|:
name|indexRoutingTable
operator|.
name|value
control|)
block|{
assert|assert
name|indexShard
operator|.
name|primary
operator|!=
literal|null
assert|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|indexShard
control|)
block|{
comment|// to get all the shards belonging to an index, including the replicas,
comment|// we define a replica set and keep track of it. A replica set is identified
comment|// by the ShardId, as this is common for primary and replicas.
comment|// A replica Set might have one (and not more) replicas with the state of RELOCATING.
if|if
condition|(
name|shard
operator|.
name|assignedToNode
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
name|entries
init|=
name|nodesToShards
operator|.
name|computeIfAbsent
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
comment|// LinkedHashMap to preserve order
name|ShardRouting
name|previousValue
init|=
name|entries
operator|.
name|put
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|shard
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousValue
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot have two different shards with same shard id on same node"
argument_list|)
throw|;
block|}
name|assignedShardsAdd
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|relocatingShards
operator|++
expr_stmt|;
name|entries
operator|=
name|nodesToShards
operator|.
name|computeIfAbsent
argument_list|(
name|shard
operator|.
name|relocatingNodeId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
comment|// LinkedHashMap to preserve order
comment|// add the counterpart shard with relocatingNodeId reflecting the source from which
comment|// it's relocating from.
name|ShardRouting
name|targetShardRouting
init|=
name|shard
operator|.
name|getTargetRelocatingShard
argument_list|()
decl_stmt|;
name|addInitialRecovery
argument_list|(
name|targetShardRouting
argument_list|,
name|indexShard
operator|.
name|primary
argument_list|)
expr_stmt|;
name|previousValue
operator|=
name|entries
operator|.
name|put
argument_list|(
name|targetShardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|targetShardRouting
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousValue
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot have two different shards with same shard id on same node"
argument_list|)
throw|;
block|}
name|assignedShardsAdd
argument_list|(
name|targetShardRouting
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shard
operator|.
name|initializing
argument_list|()
condition|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|++
expr_stmt|;
block|}
name|inactiveShardCount
operator|++
expr_stmt|;
name|addInitialRecovery
argument_list|(
name|shard
argument_list|,
name|indexShard
operator|.
name|primary
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unassignedShards
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LinkedHashMap
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
argument_list|>
name|entry
range|:
name|nodesToShards
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|nodeId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|this
operator|.
name|nodesToShards
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
operator|new
name|RoutingNode
argument_list|(
name|nodeId
argument_list|,
name|clusterState
operator|.
name|nodes
argument_list|()
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addRecovery
specifier|private
name|void
name|addRecovery
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
block|{
name|updateRecoveryCounts
argument_list|(
name|routing
argument_list|,
literal|true
argument_list|,
name|findAssignedPrimaryIfPeerRecovery
argument_list|(
name|routing
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|removeRecovery
specifier|private
name|void
name|removeRecovery
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
block|{
name|updateRecoveryCounts
argument_list|(
name|routing
argument_list|,
literal|false
argument_list|,
name|findAssignedPrimaryIfPeerRecovery
argument_list|(
name|routing
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addInitialRecovery
specifier|private
name|void
name|addInitialRecovery
parameter_list|(
name|ShardRouting
name|routing
parameter_list|,
name|ShardRouting
name|initialPrimaryShard
parameter_list|)
block|{
name|updateRecoveryCounts
argument_list|(
name|routing
argument_list|,
literal|true
argument_list|,
name|initialPrimaryShard
argument_list|)
expr_stmt|;
block|}
DECL|method|updateRecoveryCounts
specifier|private
name|void
name|updateRecoveryCounts
parameter_list|(
specifier|final
name|ShardRouting
name|routing
parameter_list|,
specifier|final
name|boolean
name|increment
parameter_list|,
annotation|@
name|Nullable
specifier|final
name|ShardRouting
name|primary
parameter_list|)
block|{
specifier|final
name|int
name|howMany
init|=
name|increment
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
assert|assert
name|routing
operator|.
name|initializing
argument_list|()
operator|:
literal|"routing must be initializing: "
operator|+
name|routing
assert|;
comment|// TODO: check primary == null || primary.active() after all tests properly add ReplicaAfterPrimaryActiveAllocationDecider
assert|assert
name|primary
operator|==
literal|null
operator|||
name|primary
operator|.
name|assignedToNode
argument_list|()
operator|:
literal|"shard is initializing but its primary is not assigned to a node"
assert|;
name|Recoveries
operator|.
name|getOrAdd
argument_list|(
name|recoveriesPerNode
argument_list|,
name|routing
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|addIncoming
argument_list|(
name|howMany
argument_list|)
expr_stmt|;
if|if
condition|(
name|routing
operator|.
name|isPeerRecovery
argument_list|()
condition|)
block|{
comment|// add/remove corresponding outgoing recovery on node with primary shard
if|if
condition|(
name|primary
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"shard is peer recovering but primary is unassigned"
argument_list|)
throw|;
block|}
name|Recoveries
operator|.
name|getOrAdd
argument_list|(
name|recoveriesPerNode
argument_list|,
name|primary
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|addOutgoing
argument_list|(
name|howMany
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
operator|==
literal|false
operator|&&
name|routing
operator|.
name|primary
argument_list|()
operator|&&
name|routing
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// primary is done relocating, move non-primary recoveries from old primary to new primary
name|int
name|numRecoveringReplicas
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ShardRouting
name|assigned
range|:
name|assignedShards
argument_list|(
name|routing
operator|.
name|shardId
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|assigned
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|&&
name|assigned
operator|.
name|isPeerRecovery
argument_list|()
condition|)
block|{
name|numRecoveringReplicas
operator|++
expr_stmt|;
block|}
block|}
name|recoveriesPerNode
operator|.
name|get
argument_list|(
name|routing
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
operator|.
name|addOutgoing
argument_list|(
operator|-
name|numRecoveringReplicas
argument_list|)
expr_stmt|;
name|recoveriesPerNode
operator|.
name|get
argument_list|(
name|routing
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|addOutgoing
argument_list|(
name|numRecoveringReplicas
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getIncomingRecoveries
specifier|public
name|int
name|getIncomingRecoveries
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
return|return
name|recoveriesPerNode
operator|.
name|getOrDefault
argument_list|(
name|nodeId
argument_list|,
name|Recoveries
operator|.
name|EMPTY
argument_list|)
operator|.
name|getIncoming
argument_list|()
return|;
block|}
DECL|method|getOutgoingRecoveries
specifier|public
name|int
name|getOutgoingRecoveries
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
return|return
name|recoveriesPerNode
operator|.
name|getOrDefault
argument_list|(
name|nodeId
argument_list|,
name|Recoveries
operator|.
name|EMPTY
argument_list|)
operator|.
name|getOutgoing
argument_list|()
return|;
block|}
annotation|@
name|Nullable
DECL|method|findAssignedPrimaryIfPeerRecovery
specifier|private
name|ShardRouting
name|findAssignedPrimaryIfPeerRecovery
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
block|{
name|ShardRouting
name|primary
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|routing
operator|.
name|isPeerRecovery
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardRoutings
init|=
name|assignedShards
operator|.
name|get
argument_list|(
name|routing
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardRoutings
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|shardRoutings
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
name|shardRouting
return|;
block|}
elseif|else
if|if
condition|(
name|primary
operator|==
literal|null
condition|)
block|{
name|primary
operator|=
name|shardRouting
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|primary
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|primary
operator|=
name|shardRouting
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|primary
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|RoutingNode
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|nodesToShards
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|mutableIterator
specifier|public
name|Iterator
argument_list|<
name|RoutingNode
argument_list|>
name|mutableIterator
parameter_list|()
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
return|return
name|nodesToShards
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|unassigned
specifier|public
name|UnassignedShards
name|unassigned
parameter_list|()
block|{
return|return
name|this
operator|.
name|unassignedShards
return|;
block|}
DECL|method|node
specifier|public
name|RoutingNode
name|node
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
return|return
name|nodesToShards
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
DECL|method|nodesPerAttributesCounts
specifier|public
name|ObjectIntHashMap
argument_list|<
name|String
argument_list|>
name|nodesPerAttributesCounts
parameter_list|(
name|String
name|attributeName
parameter_list|)
block|{
name|ObjectIntHashMap
argument_list|<
name|String
argument_list|>
name|nodesPerAttributesCounts
init|=
name|nodesPerAttributeNames
operator|.
name|get
argument_list|(
name|attributeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodesPerAttributesCounts
operator|!=
literal|null
condition|)
block|{
return|return
name|nodesPerAttributesCounts
return|;
block|}
name|nodesPerAttributesCounts
operator|=
operator|new
name|ObjectIntHashMap
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|String
name|attrValue
init|=
name|routingNode
operator|.
name|node
argument_list|()
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|attributeName
argument_list|)
decl_stmt|;
name|nodesPerAttributesCounts
operator|.
name|addTo
argument_list|(
name|attrValue
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|nodesPerAttributeNames
operator|.
name|put
argument_list|(
name|attributeName
argument_list|,
name|nodesPerAttributesCounts
argument_list|)
expr_stmt|;
return|return
name|nodesPerAttributesCounts
return|;
block|}
comment|/**      * Returns<code>true</code> iff this {@link RoutingNodes} instance has any unassigned primaries even if the      * primaries are marked as temporarily ignored.      */
DECL|method|hasUnassignedPrimaries
specifier|public
name|boolean
name|hasUnassignedPrimaries
parameter_list|()
block|{
return|return
name|unassignedShards
operator|.
name|getNumPrimaries
argument_list|()
operator|+
name|unassignedShards
operator|.
name|getNumIgnoredPrimaries
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**      * Returns<code>true</code> iff this {@link RoutingNodes} instance has any unassigned shards even if the      * shards are marked as temporarily ignored.      * @see UnassignedShards#isEmpty()      * @see UnassignedShards#isIgnoredEmpty()      */
DECL|method|hasUnassignedShards
specifier|public
name|boolean
name|hasUnassignedShards
parameter_list|()
block|{
return|return
name|unassignedShards
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
operator|||
name|unassignedShards
operator|.
name|isIgnoredEmpty
argument_list|()
operator|==
literal|false
return|;
block|}
DECL|method|hasInactivePrimaries
specifier|public
name|boolean
name|hasInactivePrimaries
parameter_list|()
block|{
return|return
name|inactivePrimaryCount
operator|>
literal|0
return|;
block|}
DECL|method|hasInactiveShards
specifier|public
name|boolean
name|hasInactiveShards
parameter_list|()
block|{
return|return
name|inactiveShardCount
operator|>
literal|0
return|;
block|}
DECL|method|getRelocatingShardCount
specifier|public
name|int
name|getRelocatingShardCount
parameter_list|()
block|{
return|return
name|relocatingShards
return|;
block|}
comment|/**      * Returns all shards that are not in the state UNASSIGNED with the same shard      * ID as the given shard.      */
DECL|method|assignedShards
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|assignedShards
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|replicaSet
init|=
name|assignedShards
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
return|return
name|replicaSet
operator|==
literal|null
condition|?
name|EMPTY
else|:
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|replicaSet
argument_list|)
return|;
block|}
annotation|@
name|Nullable
DECL|method|getByAllocationId
specifier|public
name|ShardRouting
name|getByAllocationId
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|String
name|allocationId
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|replicaSet
init|=
name|assignedShards
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaSet
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|replicaSet
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|allocationId
argument_list|)
condition|)
block|{
return|return
name|shardRouting
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns the active primary shard for the given shard id or<code>null</code> if      * no primary is found or the primary is not active.      */
DECL|method|activePrimary
specifier|public
name|ShardRouting
name|activePrimary
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|assignedShards
argument_list|(
name|shardId
argument_list|)
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|shardRouting
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
name|shardRouting
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns one active replica shard for the given shard id or<code>null</code> if      * no active replica is found.      */
DECL|method|activeReplica
specifier|public
name|ShardRouting
name|activeReplica
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|assignedShards
argument_list|(
name|shardId
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|shardRouting
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
name|shardRouting
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns<code>true</code> iff all replicas are active for the given shard routing. Otherwise<code>false</code>      */
DECL|method|allReplicasActive
specifier|public
name|boolean
name|allReplicasActive
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|MetaData
name|metaData
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
name|assignedShards
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|shards
operator|.
name|isEmpty
argument_list|()
operator|||
name|shards
operator|.
name|size
argument_list|()
operator|<
name|metaData
operator|.
name|getIndexSafe
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|getNumberOfReplicas
argument_list|()
operator|+
literal|1
condition|)
block|{
return|return
literal|false
return|;
comment|// if we are empty nothing is active if we have less than total at least one is unassigned
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
control|)
block|{
if|if
condition|(
operator|!
name|shard
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|shards
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|(
name|Predicate
argument_list|<
name|ShardRouting
argument_list|>
name|predicate
parameter_list|)
block|{
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
name|shards
operator|.
name|add
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|shards
return|;
block|}
DECL|method|shardsWithState
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardsWithState
parameter_list|(
name|ShardRoutingState
modifier|...
name|state
parameter_list|)
block|{
comment|// TODO these are used on tests only - move into utils class
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|shards
operator|.
name|addAll
argument_list|(
name|routingNode
operator|.
name|shardsWithState
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ShardRoutingState
name|s
range|:
name|state
control|)
block|{
if|if
condition|(
name|s
operator|==
name|ShardRoutingState
operator|.
name|UNASSIGNED
condition|)
block|{
name|unassigned
argument_list|()
operator|.
name|forEach
argument_list|(
name|shards
operator|::
name|add
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|shards
return|;
block|}
DECL|method|shardsWithState
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardsWithState
parameter_list|(
name|String
name|index
parameter_list|,
name|ShardRoutingState
modifier|...
name|state
parameter_list|)
block|{
comment|// TODO these are used on tests only - move into utils class
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|shards
operator|.
name|addAll
argument_list|(
name|routingNode
operator|.
name|shardsWithState
argument_list|(
name|index
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ShardRoutingState
name|s
range|:
name|state
control|)
block|{
if|if
condition|(
name|s
operator|==
name|ShardRoutingState
operator|.
name|UNASSIGNED
condition|)
block|{
for|for
control|(
name|ShardRouting
name|unassignedShard
range|:
name|unassignedShards
control|)
block|{
if|if
condition|(
name|unassignedShard
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|shards
operator|.
name|add
argument_list|(
name|unassignedShard
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|shards
return|;
block|}
DECL|method|prettyPrint
specifier|public
name|String
name|prettyPrint
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"routing_nodes:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|routingNode
operator|.
name|prettyPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"---- unassigned\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shardEntry
range|:
name|unassignedShards
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"--------"
argument_list|)
operator|.
name|append
argument_list|(
name|shardEntry
operator|.
name|shortSummary
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Moves a shard from unassigned to initialize state      *      * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.      * @return                     the initialized shard      */
DECL|method|initializeShard
specifier|public
name|ShardRouting
name|initializeShard
parameter_list|(
name|ShardRouting
name|unassignedShard
parameter_list|,
name|String
name|nodeId
parameter_list|,
annotation|@
name|Nullable
name|String
name|existingAllocationId
parameter_list|,
name|long
name|expectedSize
parameter_list|,
name|RoutingChangesObserver
name|routingChangesObserver
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
assert|assert
name|unassignedShard
operator|.
name|unassigned
argument_list|()
operator|:
literal|"expected an unassigned shard "
operator|+
name|unassignedShard
assert|;
name|ShardRouting
name|initializedShard
init|=
name|unassignedShard
operator|.
name|initialize
argument_list|(
name|nodeId
argument_list|,
name|existingAllocationId
argument_list|,
name|expectedSize
argument_list|)
decl_stmt|;
name|node
argument_list|(
name|nodeId
argument_list|)
operator|.
name|add
argument_list|(
name|initializedShard
argument_list|)
expr_stmt|;
name|inactiveShardCount
operator|++
expr_stmt|;
if|if
condition|(
name|initializedShard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|++
expr_stmt|;
block|}
name|addRecovery
argument_list|(
name|initializedShard
argument_list|)
expr_stmt|;
name|assignedShardsAdd
argument_list|(
name|initializedShard
argument_list|)
expr_stmt|;
name|routingChangesObserver
operator|.
name|shardInitialized
argument_list|(
name|unassignedShard
argument_list|,
name|initializedShard
argument_list|)
expr_stmt|;
return|return
name|initializedShard
return|;
block|}
comment|/**      * Relocate a shard to another node, adding the target initializing      * shard as well as assigning it.      *      * @return pair of source relocating and target initializing shards.      */
DECL|method|relocateShard
specifier|public
name|Tuple
argument_list|<
name|ShardRouting
argument_list|,
name|ShardRouting
argument_list|>
name|relocateShard
parameter_list|(
name|ShardRouting
name|startedShard
parameter_list|,
name|String
name|nodeId
parameter_list|,
name|long
name|expectedShardSize
parameter_list|,
name|RoutingChangesObserver
name|changes
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
name|relocatingShards
operator|++
expr_stmt|;
name|ShardRouting
name|source
init|=
name|startedShard
operator|.
name|relocate
argument_list|(
name|nodeId
argument_list|,
name|expectedShardSize
argument_list|)
decl_stmt|;
name|ShardRouting
name|target
init|=
name|source
operator|.
name|getTargetRelocatingShard
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|startedShard
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|node
argument_list|(
name|target
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|assignedShardsAdd
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|addRecovery
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|changes
operator|.
name|relocationStarted
argument_list|(
name|startedShard
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|Tuple
operator|.
name|tuple
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
comment|/**      * Applies the relevant logic to start an initializing shard.      *      * Moves the initializing shard to started. If the shard is a relocation target, also removes the relocation source.      *      * @return the started shard      */
DECL|method|startShard
specifier|public
name|ShardRouting
name|startShard
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|ShardRouting
name|initializingShard
parameter_list|,
name|RoutingChangesObserver
name|routingChangesObserver
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
name|ShardRouting
name|startedShard
init|=
name|started
argument_list|(
name|initializingShard
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} marked shard as started (routing: {})"
argument_list|,
name|initializingShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|initializingShard
argument_list|)
expr_stmt|;
name|routingChangesObserver
operator|.
name|shardStarted
argument_list|(
name|initializingShard
argument_list|,
name|startedShard
argument_list|)
expr_stmt|;
if|if
condition|(
name|initializingShard
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// relocation target has been started, remove relocation source
name|RoutingNode
name|relocationSourceNode
init|=
name|node
argument_list|(
name|initializingShard
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|ShardRouting
name|relocationSourceShard
init|=
name|relocationSourceNode
operator|.
name|getByShardId
argument_list|(
name|initializingShard
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|relocationSourceShard
operator|.
name|isRelocationSourceOf
argument_list|(
name|initializingShard
argument_list|)
assert|;
assert|assert
name|relocationSourceShard
operator|.
name|getTargetRelocatingShard
argument_list|()
operator|==
name|initializingShard
operator|:
literal|"relocation target mismatch, expected: "
operator|+
name|initializingShard
operator|+
literal|" but was: "
operator|+
name|relocationSourceShard
operator|.
name|getTargetRelocatingShard
argument_list|()
assert|;
name|remove
argument_list|(
name|relocationSourceShard
argument_list|)
expr_stmt|;
name|routingChangesObserver
operator|.
name|relocationCompleted
argument_list|(
name|relocationSourceShard
argument_list|)
expr_stmt|;
block|}
return|return
name|startedShard
return|;
block|}
comment|/**      * Applies the relevant logic to handle a cancelled or failed shard.      *      * Moves the shard to unassigned or completely removes the shard (if relocation target).      *      * - If shard is a primary, this also fails initializing replicas.      * - If shard is an active primary, this also promotes an active replica to primary (if such a replica exists).      * - If shard is a relocating primary, this also removes the primary relocation target shard.      * - If shard is a relocating replica, this promotes the replica relocation target to a full initializing replica, removing the      *   relocation source information. This is possible as peer recovery is always done from the primary.      * - If shard is a (primary or replica) relocation target, this also clears the relocation information on the source shard.      *      */
DECL|method|failShard
specifier|public
name|void
name|failShard
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|ShardRouting
name|failedShard
parameter_list|,
name|UnassignedInfo
name|unassignedInfo
parameter_list|,
name|IndexMetaData
name|indexMetaData
parameter_list|,
name|RoutingChangesObserver
name|routingChangesObserver
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
assert|assert
name|failedShard
operator|.
name|assignedToNode
argument_list|()
operator|:
literal|"only assigned shards can be failed"
assert|;
assert|assert
name|indexMetaData
operator|.
name|getIndex
argument_list|()
operator|.
name|equals
argument_list|(
name|failedShard
operator|.
name|index
argument_list|()
argument_list|)
operator|:
literal|"shard failed for unknown index (shard entry: "
operator|+
name|failedShard
operator|+
literal|")"
assert|;
assert|assert
name|getByAllocationId
argument_list|(
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|failedShard
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
operator|==
name|failedShard
operator|:
literal|"shard routing to fail does not exist in routing table, expected: "
operator|+
name|failedShard
operator|+
literal|" but was: "
operator|+
name|getByAllocationId
argument_list|(
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|failedShard
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
assert|;
name|logger
operator|.
name|debug
argument_list|(
literal|"{} failing shard {} with unassigned info ({})"
argument_list|,
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|failedShard
argument_list|,
name|unassignedInfo
operator|.
name|shortSummary
argument_list|()
argument_list|)
expr_stmt|;
comment|// if this is a primary, fail initializing replicas first (otherwise we move RoutingNodes into an inconsistent state)
if|if
condition|(
name|failedShard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|assignedShards
init|=
name|assignedShards
argument_list|(
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|assignedShards
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// copy list to prevent ConcurrentModificationException
for|for
control|(
name|ShardRouting
name|routing
range|:
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|assignedShards
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|routing
operator|.
name|primary
argument_list|()
operator|&&
name|routing
operator|.
name|initializing
argument_list|()
condition|)
block|{
comment|// re-resolve replica as earlier iteration could have changed source/target of replica relocation
name|ShardRouting
name|replicaShard
init|=
name|getByAllocationId
argument_list|(
name|routing
operator|.
name|shardId
argument_list|()
argument_list|,
name|routing
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|replicaShard
operator|!=
literal|null
operator|:
literal|"failed to re-resolve "
operator|+
name|routing
operator|+
literal|" when failing replicas"
assert|;
name|UnassignedInfo
name|primaryFailedUnassignedInfo
init|=
operator|new
name|UnassignedInfo
argument_list|(
name|UnassignedInfo
operator|.
name|Reason
operator|.
name|PRIMARY_FAILED
argument_list|,
literal|"primary failed while replica initializing"
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|,
name|unassignedInfo
operator|.
name|getUnassignedTimeInNanos
argument_list|()
argument_list|,
name|unassignedInfo
operator|.
name|getUnassignedTimeInMillis
argument_list|()
argument_list|,
literal|false
argument_list|,
name|AllocationStatus
operator|.
name|NO_ATTEMPT
argument_list|)
decl_stmt|;
name|failShard
argument_list|(
name|logger
argument_list|,
name|replicaShard
argument_list|,
name|primaryFailedUnassignedInfo
argument_list|,
name|indexMetaData
argument_list|,
name|routingChangesObserver
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|failedShard
operator|.
name|relocating
argument_list|()
condition|)
block|{
comment|// find the shard that is initializing on the target node
name|ShardRouting
name|targetShard
init|=
name|getByAllocationId
argument_list|(
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|failedShard
operator|.
name|allocationId
argument_list|()
operator|.
name|getRelocationId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|targetShard
operator|.
name|isRelocationTargetOf
argument_list|(
name|failedShard
argument_list|)
assert|;
if|if
condition|(
name|failedShard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"{} is removed due to the failure/cancellation of the source shard"
argument_list|,
name|targetShard
argument_list|)
expr_stmt|;
comment|// cancel and remove target shard
name|remove
argument_list|(
name|targetShard
argument_list|)
expr_stmt|;
name|routingChangesObserver
operator|.
name|shardFailed
argument_list|(
name|targetShard
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"{}, relocation source failed / cancelled, mark as initializing without relocation source"
argument_list|,
name|targetShard
argument_list|)
expr_stmt|;
comment|// promote to initializing shard without relocation source and ensure that removed relocation source
comment|// is not added back as unassigned shard
name|removeRelocationSource
argument_list|(
name|targetShard
argument_list|)
expr_stmt|;
name|routingChangesObserver
operator|.
name|relocationSourceRemoved
argument_list|(
name|targetShard
argument_list|)
expr_stmt|;
block|}
block|}
comment|// fail actual shard
if|if
condition|(
name|failedShard
operator|.
name|initializing
argument_list|()
condition|)
block|{
if|if
condition|(
name|failedShard
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// initializing shard that is not relocation target, just move to unassigned
name|moveToUnassigned
argument_list|(
name|failedShard
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The shard is a target of a relocating shard. In that case we only need to remove the target shard and cancel the source
comment|// relocation. No shard is left unassigned
name|logger
operator|.
name|trace
argument_list|(
literal|"{} is a relocation target, resolving source to cancel relocation ({})"
argument_list|,
name|failedShard
argument_list|,
name|unassignedInfo
operator|.
name|shortSummary
argument_list|()
argument_list|)
expr_stmt|;
name|ShardRouting
name|sourceShard
init|=
name|getByAllocationId
argument_list|(
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|failedShard
operator|.
name|allocationId
argument_list|()
operator|.
name|getRelocationId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|sourceShard
operator|.
name|isRelocationSourceOf
argument_list|(
name|failedShard
argument_list|)
assert|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{}, resolved source to [{}]. canceling relocation ... ({})"
argument_list|,
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|sourceShard
argument_list|,
name|unassignedInfo
operator|.
name|shortSummary
argument_list|()
argument_list|)
expr_stmt|;
name|cancelRelocation
argument_list|(
name|sourceShard
argument_list|)
expr_stmt|;
name|remove
argument_list|(
name|failedShard
argument_list|)
expr_stmt|;
block|}
name|routingChangesObserver
operator|.
name|shardFailed
argument_list|(
name|failedShard
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|failedShard
operator|.
name|active
argument_list|()
assert|;
if|if
condition|(
name|failedShard
operator|.
name|primary
argument_list|()
condition|)
block|{
comment|// promote active replica to primary if active replica exists
name|ShardRouting
name|activeReplica
init|=
name|activeReplica
argument_list|(
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|activeReplica
operator|==
literal|null
condition|)
block|{
name|moveToUnassigned
argument_list|(
name|failedShard
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the activeReplica was relocating before this call to failShard, its relocation was cancelled above when we
comment|// failed initializing replica shards (and moved replica relocation source back to started)
assert|assert
name|activeReplica
operator|.
name|started
argument_list|()
operator|:
literal|"replica relocation should have been cancelled: "
operator|+
name|activeReplica
assert|;
name|movePrimaryToUnassignedAndDemoteToReplica
argument_list|(
name|failedShard
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
name|ShardRouting
name|primarySwappedCandidate
init|=
name|promoteActiveReplicaShardToPrimary
argument_list|(
name|activeReplica
argument_list|)
decl_stmt|;
name|routingChangesObserver
operator|.
name|replicaPromoted
argument_list|(
name|activeReplica
argument_list|)
expr_stmt|;
if|if
condition|(
name|IndexMetaData
operator|.
name|isIndexUsingShadowReplicas
argument_list|(
name|indexMetaData
operator|.
name|getSettings
argument_list|()
argument_list|)
condition|)
block|{
name|ShardRouting
name|initializedShard
init|=
name|reinitShadowPrimary
argument_list|(
name|primarySwappedCandidate
argument_list|)
decl_stmt|;
name|routingChangesObserver
operator|.
name|startedPrimaryReinitialized
argument_list|(
name|primarySwappedCandidate
argument_list|,
name|initializedShard
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
assert|assert
name|failedShard
operator|.
name|primary
argument_list|()
operator|==
literal|false
assert|;
if|if
condition|(
name|failedShard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|remove
argument_list|(
name|failedShard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|moveToUnassigned
argument_list|(
name|failedShard
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|routingChangesObserver
operator|.
name|shardFailed
argument_list|(
name|failedShard
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
block|}
assert|assert
name|node
argument_list|(
name|failedShard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|getByShardId
argument_list|(
name|failedShard
operator|.
name|shardId
argument_list|()
argument_list|)
operator|==
literal|null
operator|:
literal|"failedShard "
operator|+
name|failedShard
operator|+
literal|" was matched but wasn't removed"
assert|;
block|}
comment|/**      * Mark a shard as started and adjusts internal statistics.      *      * @return the started shard      */
DECL|method|started
specifier|private
name|ShardRouting
name|started
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|initializing
argument_list|()
operator|:
literal|"expected an initializing shard "
operator|+
name|shard
assert|;
if|if
condition|(
name|shard
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// if this is not a target shard for relocation, we need to update statistics
name|inactiveShardCount
operator|--
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|--
expr_stmt|;
block|}
block|}
name|removeRecovery
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|ShardRouting
name|startedShard
init|=
name|shard
operator|.
name|moveToStarted
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|shard
argument_list|,
name|startedShard
argument_list|)
expr_stmt|;
return|return
name|startedShard
return|;
block|}
comment|/**      * Cancels a relocation of a shard that shard must relocating.      *      * @return the shard after cancelling relocation      */
DECL|method|cancelRelocation
specifier|private
name|ShardRouting
name|cancelRelocation
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|relocatingShards
operator|--
expr_stmt|;
name|ShardRouting
name|cancelledShard
init|=
name|shard
operator|.
name|cancelRelocation
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|shard
argument_list|,
name|cancelledShard
argument_list|)
expr_stmt|;
return|return
name|cancelledShard
return|;
block|}
comment|/**      * moves the assigned replica shard to primary.      *      * @param replicaShard the replica shard to be promoted to primary      * @return             the resulting primary shard      */
DECL|method|promoteActiveReplicaShardToPrimary
specifier|private
name|ShardRouting
name|promoteActiveReplicaShardToPrimary
parameter_list|(
name|ShardRouting
name|replicaShard
parameter_list|)
block|{
assert|assert
name|replicaShard
operator|.
name|active
argument_list|()
operator|:
literal|"non-active shard cannot be promoted to primary: "
operator|+
name|replicaShard
assert|;
assert|assert
name|replicaShard
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|:
literal|"primary shard cannot be promoted to primary: "
operator|+
name|replicaShard
assert|;
name|ShardRouting
name|primaryShard
init|=
name|replicaShard
operator|.
name|moveToPrimary
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|replicaShard
argument_list|,
name|primaryShard
argument_list|)
expr_stmt|;
return|return
name|primaryShard
return|;
block|}
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|EMPTY
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
comment|/**      * Cancels the give shard from the Routing nodes internal statistics and cancels      * the relocation if the shard is relocating.      */
DECL|method|remove
specifier|private
name|void
name|remove
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"only assigned shards can be removed here ("
operator|+
name|shard
operator|+
literal|")"
assert|;
name|node
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|remove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|initializing
argument_list|()
operator|&&
name|shard
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|inactiveShardCount
operator|--
expr_stmt|;
assert|assert
name|inactiveShardCount
operator|>=
literal|0
assert|;
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|shard
operator|=
name|cancelRelocation
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
name|assignedShardsRemove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|initializing
argument_list|()
condition|)
block|{
name|removeRecovery
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes relocation source of an initializing non-primary shard. This allows the replica shard to continue recovery from      * the primary even though its non-primary relocation source has failed.      */
DECL|method|removeRelocationSource
specifier|private
name|ShardRouting
name|removeRelocationSource
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|isRelocationTarget
argument_list|()
operator|:
literal|"only relocation target shards can have their relocation source removed ("
operator|+
name|shard
operator|+
literal|")"
assert|;
name|ShardRouting
name|relocationMarkerRemoved
init|=
name|shard
operator|.
name|removeRelocationSource
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|shard
argument_list|,
name|relocationMarkerRemoved
argument_list|)
expr_stmt|;
name|inactiveShardCount
operator|++
expr_stmt|;
comment|// relocation targets are not counted as inactive shards whereas initializing shards are
return|return
name|relocationMarkerRemoved
return|;
block|}
DECL|method|assignedShardsAdd
specifier|private
name|void
name|assignedShardsAdd
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"unassigned shard "
operator|+
name|shard
operator|+
literal|" cannot be added to list of assigned shards"
assert|;
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
name|assignedShards
operator|.
name|computeIfAbsent
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|assertInstanceNotInList
argument_list|(
name|shard
argument_list|,
name|shards
argument_list|)
operator|:
literal|"shard "
operator|+
name|shard
operator|+
literal|" cannot appear twice in list of assigned shards"
assert|;
name|shards
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|method|assertInstanceNotInList
specifier|private
name|boolean
name|assertInstanceNotInList
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|)
block|{
for|for
control|(
name|ShardRouting
name|s
range|:
name|shards
control|)
block|{
assert|assert
name|s
operator|!=
name|shard
assert|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|assignedShardsRemove
specifier|private
name|void
name|assignedShardsRemove
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|replicaSet
init|=
name|assignedShards
operator|.
name|get
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaSet
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
init|=
name|replicaSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// yes we check identity here
if|if
condition|(
name|shard
operator|==
name|iterator
operator|.
name|next
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
assert|assert
literal|false
operator|:
literal|"No shard found to remove"
assert|;
block|}
DECL|method|reinitShadowPrimary
specifier|private
name|ShardRouting
name|reinitShadowPrimary
parameter_list|(
name|ShardRouting
name|candidate
parameter_list|)
block|{
if|if
condition|(
name|candidate
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|cancelRelocation
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
name|ShardRouting
name|reinitializedShard
init|=
name|candidate
operator|.
name|reinitializeShard
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|candidate
argument_list|,
name|reinitializedShard
argument_list|)
expr_stmt|;
name|inactivePrimaryCount
operator|++
expr_stmt|;
name|inactiveShardCount
operator|++
expr_stmt|;
return|return
name|reinitializedShard
return|;
block|}
DECL|method|updateAssigned
specifier|private
name|void
name|updateAssigned
parameter_list|(
name|ShardRouting
name|oldShard
parameter_list|,
name|ShardRouting
name|newShard
parameter_list|)
block|{
assert|assert
name|oldShard
operator|.
name|shardId
argument_list|()
operator|.
name|equals
argument_list|(
name|newShard
operator|.
name|shardId
argument_list|()
argument_list|)
operator|:
literal|"can only update "
operator|+
name|oldShard
operator|+
literal|" by shard with same shard id but was "
operator|+
name|newShard
assert|;
assert|assert
name|oldShard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|&&
name|newShard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"only assigned shards can be updated in list of assigned shards (prev: "
operator|+
name|oldShard
operator|+
literal|", new: "
operator|+
name|newShard
operator|+
literal|")"
assert|;
assert|assert
name|oldShard
operator|.
name|currentNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|newShard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|:
literal|"shard to update "
operator|+
name|oldShard
operator|+
literal|" can only update "
operator|+
name|oldShard
operator|+
literal|" by shard assigned to same node but was "
operator|+
name|newShard
assert|;
name|node
argument_list|(
name|oldShard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|update
argument_list|(
name|oldShard
argument_list|,
name|newShard
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardsWithMatchingShardId
init|=
name|assignedShards
operator|.
name|computeIfAbsent
argument_list|(
name|oldShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|previousShardIndex
init|=
name|shardsWithMatchingShardId
operator|.
name|indexOf
argument_list|(
name|oldShard
argument_list|)
decl_stmt|;
assert|assert
name|previousShardIndex
operator|>=
literal|0
operator|:
literal|"shard to update "
operator|+
name|oldShard
operator|+
literal|" does not exist in list of assigned shards"
assert|;
name|shardsWithMatchingShardId
operator|.
name|set
argument_list|(
name|previousShardIndex
argument_list|,
name|newShard
argument_list|)
expr_stmt|;
block|}
DECL|method|moveToUnassigned
specifier|private
name|ShardRouting
name|moveToUnassigned
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|UnassignedInfo
name|unassignedInfo
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"only assigned shards can be moved to unassigned ("
operator|+
name|shard
operator|+
literal|")"
assert|;
name|remove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|ShardRouting
name|unassigned
init|=
name|shard
operator|.
name|moveToUnassigned
argument_list|(
name|unassignedInfo
argument_list|)
decl_stmt|;
name|unassignedShards
operator|.
name|add
argument_list|(
name|unassigned
argument_list|)
expr_stmt|;
return|return
name|unassigned
return|;
block|}
comment|/**      * Moves assigned primary to unassigned and demotes it to a replica.      * Used in conjunction with {@link #promoteActiveReplicaShardToPrimary} when an active replica is promoted to primary.      */
DECL|method|movePrimaryToUnassignedAndDemoteToReplica
specifier|private
name|ShardRouting
name|movePrimaryToUnassignedAndDemoteToReplica
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|UnassignedInfo
name|unassignedInfo
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"only assigned shards can be moved to unassigned ("
operator|+
name|shard
operator|+
literal|")"
assert|;
assert|assert
name|shard
operator|.
name|primary
argument_list|()
operator|:
literal|"only primary can be demoted to replica ("
operator|+
name|shard
operator|+
literal|")"
assert|;
name|remove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|ShardRouting
name|unassigned
init|=
name|shard
operator|.
name|moveToUnassigned
argument_list|(
name|unassignedInfo
argument_list|)
operator|.
name|moveFromPrimary
argument_list|()
decl_stmt|;
name|unassignedShards
operator|.
name|add
argument_list|(
name|unassigned
argument_list|)
expr_stmt|;
return|return
name|unassigned
return|;
block|}
comment|/**      * Returns the number of routing nodes      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|nodesToShards
operator|.
name|size
argument_list|()
return|;
block|}
DECL|class|UnassignedShards
specifier|public
specifier|static
specifier|final
class|class
name|UnassignedShards
implements|implements
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|nodes
specifier|private
specifier|final
name|RoutingNodes
name|nodes
decl_stmt|;
DECL|field|unassigned
specifier|private
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|unassigned
decl_stmt|;
DECL|field|ignored
specifier|private
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|ignored
decl_stmt|;
DECL|field|primaries
specifier|private
name|int
name|primaries
init|=
literal|0
decl_stmt|;
DECL|field|ignoredPrimaries
specifier|private
name|int
name|ignoredPrimaries
init|=
literal|0
decl_stmt|;
DECL|method|UnassignedShards
specifier|public
name|UnassignedShards
parameter_list|(
name|RoutingNodes
name|nodes
parameter_list|)
block|{
name|this
operator|.
name|nodes
operator|=
name|nodes
expr_stmt|;
name|unassigned
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|ignored
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|primaries
operator|++
expr_stmt|;
block|}
name|unassigned
operator|.
name|add
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|(
name|Comparator
argument_list|<
name|ShardRouting
argument_list|>
name|comparator
parameter_list|)
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
name|CollectionUtil
operator|.
name|timSort
argument_list|(
name|unassigned
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/**          * Returns the size of the non-ignored unassigned shards          */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|unassigned
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the size of the temporarily marked as ignored unassigned shards          */
DECL|method|ignoredSize
specifier|public
name|int
name|ignoredSize
parameter_list|()
block|{
return|return
name|ignored
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the number of non-ignored unassigned primaries          */
DECL|method|getNumPrimaries
specifier|public
name|int
name|getNumPrimaries
parameter_list|()
block|{
return|return
name|primaries
return|;
block|}
comment|/**          * Returns the number of temporarily marked as ignored unassigned primaries          */
DECL|method|getNumIgnoredPrimaries
specifier|public
name|int
name|getNumIgnoredPrimaries
parameter_list|()
block|{
return|return
name|ignoredPrimaries
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|UnassignedIterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|UnassignedIterator
argument_list|()
return|;
block|}
comment|/**          * The list of ignored unassigned shards (read only). The ignored unassigned shards          * are not part of the formal unassigned list, but are kept around and used to build          * back the list of unassigned shards as part of the routing table.          */
DECL|method|ignored
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|ignored
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|ignored
argument_list|)
return|;
block|}
comment|/**          * Marks a shard as temporarily ignored and adds it to the ignore unassigned list.          * Should be used with caution, typically,          * the correct usage is to removeAndIgnore from the iterator.          * @see #ignored()          * @see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver)          * @see #isIgnoredEmpty()          */
DECL|method|ignoreShard
specifier|public
name|void
name|ignoreShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|AllocationStatus
name|allocationStatus
parameter_list|,
name|RoutingChangesObserver
name|changes
parameter_list|)
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|ignoredPrimaries
operator|++
expr_stmt|;
name|UnassignedInfo
name|currInfo
init|=
name|shard
operator|.
name|unassignedInfo
argument_list|()
decl_stmt|;
assert|assert
name|currInfo
operator|!=
literal|null
assert|;
if|if
condition|(
name|allocationStatus
operator|.
name|equals
argument_list|(
name|currInfo
operator|.
name|getLastAllocationStatus
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|UnassignedInfo
name|newInfo
init|=
operator|new
name|UnassignedInfo
argument_list|(
name|currInfo
operator|.
name|getReason
argument_list|()
argument_list|,
name|currInfo
operator|.
name|getMessage
argument_list|()
argument_list|,
name|currInfo
operator|.
name|getFailure
argument_list|()
argument_list|,
name|currInfo
operator|.
name|getNumFailedAllocations
argument_list|()
argument_list|,
name|currInfo
operator|.
name|getUnassignedTimeInNanos
argument_list|()
argument_list|,
name|currInfo
operator|.
name|getUnassignedTimeInMillis
argument_list|()
argument_list|,
name|currInfo
operator|.
name|isDelayed
argument_list|()
argument_list|,
name|allocationStatus
argument_list|)
decl_stmt|;
name|ShardRouting
name|updatedShard
init|=
name|shard
operator|.
name|updateUnassignedInfo
argument_list|(
name|newInfo
argument_list|)
decl_stmt|;
name|changes
operator|.
name|unassignedInfoUpdated
argument_list|(
name|shard
argument_list|,
name|newInfo
argument_list|)
expr_stmt|;
name|shard
operator|=
name|updatedShard
expr_stmt|;
block|}
block|}
name|ignored
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|class|UnassignedIterator
specifier|public
class|class
name|UnassignedIterator
implements|implements
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|iterator
specifier|private
specifier|final
name|ListIterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
decl_stmt|;
DECL|field|current
specifier|private
name|ShardRouting
name|current
decl_stmt|;
DECL|method|UnassignedIterator
specifier|public
name|UnassignedIterator
parameter_list|()
block|{
name|this
operator|.
name|iterator
operator|=
name|unassigned
operator|.
name|listIterator
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|ShardRouting
name|next
parameter_list|()
block|{
return|return
name|current
operator|=
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**              * Initializes the current unassigned shard and moves it from the unassigned list.              *              * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.              */
DECL|method|initialize
specifier|public
name|ShardRouting
name|initialize
parameter_list|(
name|String
name|nodeId
parameter_list|,
annotation|@
name|Nullable
name|String
name|existingAllocationId
parameter_list|,
name|long
name|expectedShardSize
parameter_list|,
name|RoutingChangesObserver
name|routingChangesObserver
parameter_list|)
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
name|innerRemove
argument_list|()
expr_stmt|;
return|return
name|nodes
operator|.
name|initializeShard
argument_list|(
name|current
argument_list|,
name|nodeId
argument_list|,
name|existingAllocationId
argument_list|,
name|expectedShardSize
argument_list|,
name|routingChangesObserver
argument_list|)
return|;
block|}
comment|/**              * Removes and ignores the unassigned shard (will be ignored for this run, but              * will be added back to unassigned once the metadata is constructed again).              * Typically this is used when an allocation decision prevents a shard from being allocated such              * that subsequent consumers of this API won't try to allocate this shard again.              *              * @param attempt the result of the allocation attempt              */
DECL|method|removeAndIgnore
specifier|public
name|void
name|removeAndIgnore
parameter_list|(
name|AllocationStatus
name|attempt
parameter_list|,
name|RoutingChangesObserver
name|changes
parameter_list|)
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
name|innerRemove
argument_list|()
expr_stmt|;
name|ignoreShard
argument_list|(
name|current
argument_list|,
name|attempt
argument_list|,
name|changes
argument_list|)
expr_stmt|;
block|}
DECL|method|updateShardRouting
specifier|private
name|void
name|updateShardRouting
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
name|current
operator|=
name|shardRouting
expr_stmt|;
name|iterator
operator|.
name|set
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
comment|/**              * updates the unassigned info on the current unassigned shard              *              * @param  unassignedInfo the new unassigned info to use              * @return the shard with unassigned info updated              */
DECL|method|updateUnassignedInfo
specifier|public
name|ShardRouting
name|updateUnassignedInfo
parameter_list|(
name|UnassignedInfo
name|unassignedInfo
parameter_list|,
name|RoutingChangesObserver
name|changes
parameter_list|)
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
name|ShardRouting
name|updatedShardRouting
init|=
name|current
operator|.
name|updateUnassignedInfo
argument_list|(
name|unassignedInfo
argument_list|)
decl_stmt|;
name|changes
operator|.
name|unassignedInfoUpdated
argument_list|(
name|current
argument_list|,
name|unassignedInfo
argument_list|)
expr_stmt|;
name|updateShardRouting
argument_list|(
name|updatedShardRouting
argument_list|)
expr_stmt|;
return|return
name|updatedShardRouting
return|;
block|}
comment|/**              * Unsupported operation, just there for the interface. Use {@link #removeAndIgnore(AllocationStatus, RoutingChangesObserver)} or              * {@link #initialize(String, String, long, RoutingChangesObserver)}.              */
annotation|@
name|Override
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"remove is not supported in unassigned iterator, use removeAndIgnore or initialize"
argument_list|)
throw|;
block|}
DECL|method|innerRemove
specifier|private
name|void
name|innerRemove
parameter_list|()
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|primary
argument_list|()
condition|)
block|{
name|primaries
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Returns<code>true</code> iff this collection contains one or more non-ignored unassigned shards.          */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|unassigned
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**          * Returns<code>true</code> iff any unassigned shards are marked as temporarily ignored.          * @see UnassignedShards#ignoreShard(ShardRouting, AllocationStatus, RoutingChangesObserver)          * @see UnassignedIterator#removeAndIgnore(AllocationStatus, RoutingChangesObserver)          */
DECL|method|isIgnoredEmpty
specifier|public
name|boolean
name|isIgnoredEmpty
parameter_list|()
block|{
return|return
name|ignored
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|shuffle
specifier|public
name|void
name|shuffle
parameter_list|()
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
name|Randomness
operator|.
name|shuffle
argument_list|(
name|unassigned
argument_list|)
expr_stmt|;
block|}
comment|/**          * Drains all unassigned shards and returns it.          * This method will not drain ignored shards.          */
DECL|method|drain
specifier|public
name|ShardRouting
index|[]
name|drain
parameter_list|()
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
name|ShardRouting
index|[]
name|mutableShardRoutings
init|=
name|unassigned
operator|.
name|toArray
argument_list|(
operator|new
name|ShardRouting
index|[
name|unassigned
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|unassigned
operator|.
name|clear
argument_list|()
expr_stmt|;
name|primaries
operator|=
literal|0
expr_stmt|;
return|return
name|mutableShardRoutings
return|;
block|}
block|}
comment|/**      * Calculates RoutingNodes statistics by iterating over all {@link ShardRouting}s      * in the cluster to ensure the book-keeping is correct.      * For performance reasons, this should only be called from asserts      *      * @return this method always returns<code>true</code> or throws an assertion error. If assertion are not enabled      *         this method does nothing.      */
DECL|method|assertShardStats
specifier|public
specifier|static
name|boolean
name|assertShardStats
parameter_list|(
name|RoutingNodes
name|routingNodes
parameter_list|)
block|{
name|boolean
name|run
init|=
literal|false
decl_stmt|;
assert|assert
operator|(
name|run
operator|=
literal|true
operator|)
assert|;
comment|// only run if assertions are enabled!
if|if
condition|(
operator|!
name|run
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|unassignedPrimaryCount
init|=
literal|0
decl_stmt|;
name|int
name|unassignedIgnoredPrimaryCount
init|=
literal|0
decl_stmt|;
name|int
name|inactivePrimaryCount
init|=
literal|0
decl_stmt|;
name|int
name|inactiveShardCount
init|=
literal|0
decl_stmt|;
name|int
name|relocating
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|Index
argument_list|,
name|Integer
argument_list|>
name|indicesAndShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|node
range|:
name|routingNodes
control|)
block|{
for|for
control|(
name|ShardRouting
name|shard
range|:
name|node
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|initializing
argument_list|()
operator|&&
name|shard
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|inactiveShardCount
operator|++
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|relocating
operator|++
expr_stmt|;
block|}
name|Integer
name|i
init|=
name|indicesAndShards
operator|.
name|get
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|null
condition|)
block|{
name|i
operator|=
name|shard
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
name|indicesAndShards
operator|.
name|put
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|i
argument_list|,
name|shard
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assert that the active shard routing are identical.
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Index
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|entries
init|=
name|indicesAndShards
operator|.
name|entrySet
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Index
argument_list|,
name|Integer
argument_list|>
name|e
range|:
name|entries
control|)
block|{
name|Index
name|index
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|e
operator|.
name|getValue
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|routingNodes
control|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|index
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
operator|&&
name|shardRouting
operator|.
name|id
argument_list|()
operator|==
name|i
condition|)
block|{
name|shards
operator|.
name|add
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|mutableShardRoutings
init|=
name|routingNodes
operator|.
name|assignedShards
argument_list|(
operator|new
name|ShardId
argument_list|(
name|index
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|mutableShardRoutings
operator|.
name|size
argument_list|()
operator|==
name|shards
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|ShardRouting
name|r
range|:
name|mutableShardRoutings
control|)
block|{
assert|assert
name|shards
operator|.
name|contains
argument_list|(
name|r
argument_list|)
assert|;
name|shards
operator|.
name|remove
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
assert|assert
name|shards
operator|.
name|isEmpty
argument_list|()
assert|;
block|}
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNodes
operator|.
name|unassigned
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|unassignedPrimaryCount
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNodes
operator|.
name|unassigned
argument_list|()
operator|.
name|ignored
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|unassignedIgnoredPrimaryCount
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Recoveries
argument_list|>
name|recoveries
range|:
name|routingNodes
operator|.
name|recoveriesPerNode
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|node
init|=
name|recoveries
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|Recoveries
name|value
init|=
name|recoveries
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|incoming
init|=
literal|0
decl_stmt|;
name|int
name|outgoing
init|=
literal|0
decl_stmt|;
name|RoutingNode
name|routingNode
init|=
name|routingNodes
operator|.
name|nodesToShards
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|!=
literal|null
condition|)
block|{
comment|// node might have dropped out of the cluster
for|for
control|(
name|ShardRouting
name|routing
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|routing
operator|.
name|initializing
argument_list|()
condition|)
block|{
name|incoming
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|routing
operator|.
name|primary
argument_list|()
operator|&&
name|routing
operator|.
name|isPeerRecovery
argument_list|()
operator|==
literal|false
condition|)
block|{
for|for
control|(
name|ShardRouting
name|assigned
range|:
name|routingNodes
operator|.
name|assignedShards
operator|.
name|get
argument_list|(
name|routing
operator|.
name|shardId
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|assigned
operator|.
name|isPeerRecovery
argument_list|()
condition|)
block|{
name|outgoing
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
assert|assert
name|incoming
operator|==
name|value
operator|.
name|incoming
operator|:
name|incoming
operator|+
literal|" != "
operator|+
name|value
operator|.
name|incoming
operator|+
literal|" node: "
operator|+
name|routingNode
assert|;
assert|assert
name|outgoing
operator|==
name|value
operator|.
name|outgoing
operator|:
name|outgoing
operator|+
literal|" != "
operator|+
name|value
operator|.
name|outgoing
operator|+
literal|" node: "
operator|+
name|routingNode
assert|;
block|}
assert|assert
name|unassignedPrimaryCount
operator|==
name|routingNodes
operator|.
name|unassignedShards
operator|.
name|getNumPrimaries
argument_list|()
operator|:
literal|"Unassigned primaries is ["
operator|+
name|unassignedPrimaryCount
operator|+
literal|"] but RoutingNodes returned unassigned primaries ["
operator|+
name|routingNodes
operator|.
name|unassigned
argument_list|()
operator|.
name|getNumPrimaries
argument_list|()
operator|+
literal|"]"
assert|;
assert|assert
name|unassignedIgnoredPrimaryCount
operator|==
name|routingNodes
operator|.
name|unassignedShards
operator|.
name|getNumIgnoredPrimaries
argument_list|()
operator|:
literal|"Unassigned ignored primaries is ["
operator|+
name|unassignedIgnoredPrimaryCount
operator|+
literal|"] but RoutingNodes returned unassigned ignored primaries ["
operator|+
name|routingNodes
operator|.
name|unassigned
argument_list|()
operator|.
name|getNumIgnoredPrimaries
argument_list|()
operator|+
literal|"]"
assert|;
assert|assert
name|inactivePrimaryCount
operator|==
name|routingNodes
operator|.
name|inactivePrimaryCount
operator|:
literal|"Inactive Primary count ["
operator|+
name|inactivePrimaryCount
operator|+
literal|"] but RoutingNodes returned inactive primaries ["
operator|+
name|routingNodes
operator|.
name|inactivePrimaryCount
operator|+
literal|"]"
assert|;
assert|assert
name|inactiveShardCount
operator|==
name|routingNodes
operator|.
name|inactiveShardCount
operator|:
literal|"Inactive Shard count ["
operator|+
name|inactiveShardCount
operator|+
literal|"] but RoutingNodes returned inactive shards ["
operator|+
name|routingNodes
operator|.
name|inactiveShardCount
operator|+
literal|"]"
assert|;
assert|assert
name|routingNodes
operator|.
name|getRelocatingShardCount
argument_list|()
operator|==
name|relocating
operator|:
literal|"Relocating shards mismatch ["
operator|+
name|routingNodes
operator|.
name|getRelocatingShardCount
argument_list|()
operator|+
literal|"] but expected ["
operator|+
name|relocating
operator|+
literal|"]"
assert|;
return|return
literal|true
return|;
block|}
DECL|method|ensureMutable
specifier|private
name|void
name|ensureMutable
parameter_list|()
block|{
if|if
condition|(
name|readOnly
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"can't modify RoutingNodes - readonly"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates an iterator over shards interleaving between nodes: The iterator returns the first shard from      * the first node, then the first shard of the second node, etc. until one shard from each node has been returned.      * The iterator then resumes on the first node by returning the second shard and continues until all shards from      * all the nodes have been returned.      */
DECL|method|nodeInterleavedShardIterator
specifier|public
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|nodeInterleavedShardIterator
parameter_list|()
block|{
specifier|final
name|Queue
argument_list|<
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|queue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RoutingNode
argument_list|>
name|entry
range|:
name|nodesToShards
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|copyShards
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|queue
operator|.
name|peek
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|queue
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|ShardRouting
name|next
parameter_list|()
block|{
if|if
condition|(
name|hasNext
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iter
init|=
name|queue
operator|.
name|poll
argument_list|()
decl_stmt|;
name|ShardRouting
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|queue
operator|.
name|offer
argument_list|(
name|iter
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
DECL|class|Recoveries
specifier|private
specifier|static
specifier|final
class|class
name|Recoveries
block|{
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|Recoveries
name|EMPTY
init|=
operator|new
name|Recoveries
argument_list|()
decl_stmt|;
DECL|field|incoming
specifier|private
name|int
name|incoming
init|=
literal|0
decl_stmt|;
DECL|field|outgoing
specifier|private
name|int
name|outgoing
init|=
literal|0
decl_stmt|;
DECL|method|getTotal
name|int
name|getTotal
parameter_list|()
block|{
return|return
name|incoming
operator|+
name|outgoing
return|;
block|}
DECL|method|addOutgoing
name|void
name|addOutgoing
parameter_list|(
name|int
name|howMany
parameter_list|)
block|{
assert|assert
name|outgoing
operator|+
name|howMany
operator|>=
literal|0
operator|:
name|outgoing
operator|+
name|howMany
operator|+
literal|" must be>= 0"
assert|;
name|outgoing
operator|+=
name|howMany
expr_stmt|;
block|}
DECL|method|addIncoming
name|void
name|addIncoming
parameter_list|(
name|int
name|howMany
parameter_list|)
block|{
assert|assert
name|incoming
operator|+
name|howMany
operator|>=
literal|0
operator|:
name|incoming
operator|+
name|howMany
operator|+
literal|" must be>= 0"
assert|;
name|incoming
operator|+=
name|howMany
expr_stmt|;
block|}
DECL|method|getOutgoing
name|int
name|getOutgoing
parameter_list|()
block|{
return|return
name|outgoing
return|;
block|}
DECL|method|getIncoming
name|int
name|getIncoming
parameter_list|()
block|{
return|return
name|incoming
return|;
block|}
DECL|method|getOrAdd
specifier|public
specifier|static
name|Recoveries
name|getOrAdd
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Recoveries
argument_list|>
name|map
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|Recoveries
name|recoveries
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|recoveries
operator|==
literal|null
condition|)
block|{
name|recoveries
operator|=
operator|new
name|Recoveries
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|recoveries
argument_list|)
expr_stmt|;
block|}
return|return
name|recoveries
return|;
block|}
block|}
block|}
end_class

end_unit

