begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.cluster.routing
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|ObjectIntHashMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectCursor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CollectionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|block
operator|.
name|ClusterBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Randomness
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableOpenMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_comment
comment|/**  * {@link RoutingNodes} represents a copy the routing information contained in  * the {@link ClusterState cluster state}.  */
end_comment

begin_class
DECL|class|RoutingNodes
specifier|public
class|class
name|RoutingNodes
implements|implements
name|Iterable
argument_list|<
name|RoutingNode
argument_list|>
block|{
DECL|field|routingTable
specifier|private
specifier|final
name|RoutingTable
name|routingTable
decl_stmt|;
DECL|field|nodesToShards
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|RoutingNode
argument_list|>
name|nodesToShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|unassignedShards
specifier|private
specifier|final
name|UnassignedShards
name|unassignedShards
init|=
operator|new
name|UnassignedShards
argument_list|(
name|this
argument_list|)
decl_stmt|;
DECL|field|assignedShards
specifier|private
specifier|final
name|Map
argument_list|<
name|ShardId
argument_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|assignedShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|readOnly
specifier|private
specifier|final
name|boolean
name|readOnly
decl_stmt|;
DECL|field|inactivePrimaryCount
specifier|private
name|int
name|inactivePrimaryCount
init|=
literal|0
decl_stmt|;
DECL|field|inactiveShardCount
specifier|private
name|int
name|inactiveShardCount
init|=
literal|0
decl_stmt|;
DECL|field|relocatingShards
specifier|private
name|int
name|relocatingShards
init|=
literal|0
decl_stmt|;
DECL|field|nodesPerAttributeNames
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ObjectIntHashMap
argument_list|<
name|String
argument_list|>
argument_list|>
name|nodesPerAttributeNames
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|recoveriesPerNode
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Recoveries
argument_list|>
name|recoveriesPerNode
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|RoutingNodes
specifier|public
name|RoutingNodes
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|)
block|{
name|this
argument_list|(
name|clusterState
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|RoutingNodes
specifier|public
name|RoutingNodes
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|boolean
name|readOnly
parameter_list|)
block|{
name|this
operator|.
name|readOnly
operator|=
name|readOnly
expr_stmt|;
name|this
operator|.
name|routingTable
operator|=
name|clusterState
operator|.
name|routingTable
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|LinkedHashMap
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
argument_list|>
name|nodesToShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// fill in the nodeToShards with the "live" nodes
for|for
control|(
name|ObjectCursor
argument_list|<
name|DiscoveryNode
argument_list|>
name|cursor
range|:
name|clusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getDataNodes
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|nodesToShards
operator|.
name|put
argument_list|(
name|cursor
operator|.
name|value
operator|.
name|getId
argument_list|()
argument_list|,
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
comment|// LinkedHashMap to preserve order
block|}
comment|// fill in the inverse of node -> shards allocated
comment|// also fill replicaSet information
for|for
control|(
name|ObjectCursor
argument_list|<
name|IndexRoutingTable
argument_list|>
name|indexRoutingTable
range|:
name|routingTable
operator|.
name|indicesRouting
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|IndexShardRoutingTable
name|indexShard
range|:
name|indexRoutingTable
operator|.
name|value
control|)
block|{
assert|assert
name|indexShard
operator|.
name|primary
operator|!=
literal|null
assert|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|indexShard
control|)
block|{
comment|// to get all the shards belonging to an index, including the replicas,
comment|// we define a replica set and keep track of it. A replica set is identified
comment|// by the ShardId, as this is common for primary and replicas.
comment|// A replica Set might have one (and not more) replicas with the state of RELOCATING.
if|if
condition|(
name|shard
operator|.
name|assignedToNode
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
name|entries
init|=
name|nodesToShards
operator|.
name|computeIfAbsent
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
comment|// LinkedHashMap to preserve order
name|ShardRouting
name|previousValue
init|=
name|entries
operator|.
name|put
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|shard
argument_list|)
decl_stmt|;
if|if
condition|(
name|previousValue
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot have two different shards with same shard id on same node"
argument_list|)
throw|;
block|}
name|assignedShardsAdd
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|relocatingShards
operator|++
expr_stmt|;
name|entries
operator|=
name|nodesToShards
operator|.
name|computeIfAbsent
argument_list|(
name|shard
operator|.
name|relocatingNodeId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
comment|// LinkedHashMap to preserve order
comment|// add the counterpart shard with relocatingNodeId reflecting the source from which
comment|// it's relocating from.
name|ShardRouting
name|targetShardRouting
init|=
name|shard
operator|.
name|buildTargetRelocatingShard
argument_list|()
decl_stmt|;
name|addInitialRecovery
argument_list|(
name|targetShardRouting
argument_list|)
expr_stmt|;
name|previousValue
operator|=
name|entries
operator|.
name|put
argument_list|(
name|targetShardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|targetShardRouting
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousValue
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot have two different shards with same shard id on same node"
argument_list|)
throw|;
block|}
name|assignedShardsAdd
argument_list|(
name|targetShardRouting
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shard
operator|.
name|active
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// shards that are initializing without being relocated
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|++
expr_stmt|;
block|}
name|inactiveShardCount
operator|++
expr_stmt|;
name|addInitialRecovery
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unassignedShards
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|LinkedHashMap
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
argument_list|>
name|entry
range|:
name|nodesToShards
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|nodeId
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|this
operator|.
name|nodesToShards
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
operator|new
name|RoutingNode
argument_list|(
name|nodeId
argument_list|,
name|clusterState
operator|.
name|nodes
argument_list|()
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addRecovery
specifier|private
name|void
name|addRecovery
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
block|{
name|addRecovery
argument_list|(
name|routing
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|removeRecovery
specifier|private
name|void
name|removeRecovery
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
block|{
name|addRecovery
argument_list|(
name|routing
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|addInitialRecovery
specifier|public
name|void
name|addInitialRecovery
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
block|{
name|addRecovery
argument_list|(
name|routing
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|addRecovery
specifier|private
name|void
name|addRecovery
parameter_list|(
specifier|final
name|ShardRouting
name|routing
parameter_list|,
specifier|final
name|boolean
name|increment
parameter_list|,
specifier|final
name|boolean
name|initializing
parameter_list|)
block|{
specifier|final
name|int
name|howMany
init|=
name|increment
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
assert|assert
name|routing
operator|.
name|initializing
argument_list|()
operator|:
literal|"routing must be initializing: "
operator|+
name|routing
assert|;
name|Recoveries
operator|.
name|getOrAdd
argument_list|(
name|recoveriesPerNode
argument_list|,
name|routing
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|addIncoming
argument_list|(
name|howMany
argument_list|)
expr_stmt|;
specifier|final
name|String
name|sourceNodeId
decl_stmt|;
if|if
condition|(
name|routing
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// this is a relocation-target
name|sourceNodeId
operator|=
name|routing
operator|.
name|relocatingNodeId
argument_list|()
expr_stmt|;
if|if
condition|(
name|routing
operator|.
name|primary
argument_list|()
operator|&&
name|increment
operator|==
literal|false
condition|)
block|{
comment|// primary is done relocating
name|int
name|numRecoveringReplicas
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ShardRouting
name|assigned
range|:
name|assignedShards
argument_list|(
name|routing
argument_list|)
control|)
block|{
if|if
condition|(
name|assigned
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|&&
name|assigned
operator|.
name|initializing
argument_list|()
operator|&&
name|assigned
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|numRecoveringReplicas
operator|++
expr_stmt|;
block|}
block|}
comment|// we transfer the recoveries to the relocated primary
name|recoveriesPerNode
operator|.
name|get
argument_list|(
name|sourceNodeId
argument_list|)
operator|.
name|addOutgoing
argument_list|(
operator|-
name|numRecoveringReplicas
argument_list|)
expr_stmt|;
name|recoveriesPerNode
operator|.
name|get
argument_list|(
name|routing
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|addOutgoing
argument_list|(
name|numRecoveringReplicas
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|routing
operator|.
name|primary
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// primary without relocationID is initial recovery
name|ShardRouting
name|primary
init|=
name|findPrimary
argument_list|(
name|routing
argument_list|)
decl_stmt|;
if|if
condition|(
name|primary
operator|==
literal|null
operator|&&
name|initializing
condition|)
block|{
name|primary
operator|=
name|routingTable
operator|.
name|index
argument_list|(
name|routing
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|shard
argument_list|(
name|routing
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|primary
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|primary
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"replica is initializing but primary is unassigned"
argument_list|)
throw|;
block|}
name|sourceNodeId
operator|=
name|primary
operator|.
name|currentNodeId
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sourceNodeId
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|sourceNodeId
operator|!=
literal|null
condition|)
block|{
name|Recoveries
operator|.
name|getOrAdd
argument_list|(
name|recoveriesPerNode
argument_list|,
name|sourceNodeId
argument_list|)
operator|.
name|addOutgoing
argument_list|(
name|howMany
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getIncomingRecoveries
specifier|public
name|int
name|getIncomingRecoveries
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
return|return
name|recoveriesPerNode
operator|.
name|getOrDefault
argument_list|(
name|nodeId
argument_list|,
name|Recoveries
operator|.
name|EMPTY
argument_list|)
operator|.
name|getIncoming
argument_list|()
return|;
block|}
DECL|method|getOutgoingRecoveries
specifier|public
name|int
name|getOutgoingRecoveries
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
return|return
name|recoveriesPerNode
operator|.
name|getOrDefault
argument_list|(
name|nodeId
argument_list|,
name|Recoveries
operator|.
name|EMPTY
argument_list|)
operator|.
name|getOutgoing
argument_list|()
return|;
block|}
DECL|method|findPrimary
specifier|private
name|ShardRouting
name|findPrimary
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
block|{
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardRoutings
init|=
name|assignedShards
operator|.
name|get
argument_list|(
name|routing
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
name|ShardRouting
name|primary
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|shardRoutings
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|shardRoutings
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
name|shardRouting
return|;
block|}
elseif|else
if|if
condition|(
name|primary
operator|==
literal|null
condition|)
block|{
name|primary
operator|=
name|shardRouting
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|primary
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|primary
operator|=
name|shardRouting
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|primary
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|RoutingNode
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableCollection
argument_list|(
name|nodesToShards
operator|.
name|values
argument_list|()
argument_list|)
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|routingTable
specifier|public
name|RoutingTable
name|routingTable
parameter_list|()
block|{
return|return
name|routingTable
return|;
block|}
DECL|method|getRoutingTable
specifier|public
name|RoutingTable
name|getRoutingTable
parameter_list|()
block|{
return|return
name|routingTable
argument_list|()
return|;
block|}
DECL|method|unassigned
specifier|public
name|UnassignedShards
name|unassigned
parameter_list|()
block|{
return|return
name|this
operator|.
name|unassignedShards
return|;
block|}
DECL|method|nodes
specifier|public
name|RoutingNodesIterator
name|nodes
parameter_list|()
block|{
return|return
operator|new
name|RoutingNodesIterator
argument_list|(
name|nodesToShards
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
return|;
block|}
DECL|method|node
specifier|public
name|RoutingNode
name|node
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
return|return
name|nodesToShards
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
return|;
block|}
DECL|method|nodesPerAttributesCounts
specifier|public
name|ObjectIntHashMap
argument_list|<
name|String
argument_list|>
name|nodesPerAttributesCounts
parameter_list|(
name|String
name|attributeName
parameter_list|)
block|{
name|ObjectIntHashMap
argument_list|<
name|String
argument_list|>
name|nodesPerAttributesCounts
init|=
name|nodesPerAttributeNames
operator|.
name|get
argument_list|(
name|attributeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodesPerAttributesCounts
operator|!=
literal|null
condition|)
block|{
return|return
name|nodesPerAttributesCounts
return|;
block|}
name|nodesPerAttributesCounts
operator|=
operator|new
name|ObjectIntHashMap
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|String
name|attrValue
init|=
name|routingNode
operator|.
name|node
argument_list|()
operator|.
name|getAttributes
argument_list|()
operator|.
name|get
argument_list|(
name|attributeName
argument_list|)
decl_stmt|;
name|nodesPerAttributesCounts
operator|.
name|addTo
argument_list|(
name|attrValue
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|nodesPerAttributeNames
operator|.
name|put
argument_list|(
name|attributeName
argument_list|,
name|nodesPerAttributesCounts
argument_list|)
expr_stmt|;
return|return
name|nodesPerAttributesCounts
return|;
block|}
comment|/**      * Returns<code>true</code> iff this {@link RoutingNodes} instance has any unassigned primaries even if the      * primaries are marked as temporarily ignored.      */
DECL|method|hasUnassignedPrimaries
specifier|public
name|boolean
name|hasUnassignedPrimaries
parameter_list|()
block|{
return|return
name|unassignedShards
operator|.
name|getNumPrimaries
argument_list|()
operator|+
name|unassignedShards
operator|.
name|getNumIgnoredPrimaries
argument_list|()
operator|>
literal|0
return|;
block|}
comment|/**      * Returns<code>true</code> iff this {@link RoutingNodes} instance has any unassigned shards even if the      * shards are marked as temporarily ignored.      * @see UnassignedShards#isEmpty()      * @see UnassignedShards#isIgnoredEmpty()      */
DECL|method|hasUnassignedShards
specifier|public
name|boolean
name|hasUnassignedShards
parameter_list|()
block|{
return|return
name|unassignedShards
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
operator|||
name|unassignedShards
operator|.
name|isIgnoredEmpty
argument_list|()
operator|==
literal|false
return|;
block|}
DECL|method|hasInactivePrimaries
specifier|public
name|boolean
name|hasInactivePrimaries
parameter_list|()
block|{
return|return
name|inactivePrimaryCount
operator|>
literal|0
return|;
block|}
DECL|method|hasInactiveShards
specifier|public
name|boolean
name|hasInactiveShards
parameter_list|()
block|{
return|return
name|inactiveShardCount
operator|>
literal|0
return|;
block|}
DECL|method|getRelocatingShardCount
specifier|public
name|int
name|getRelocatingShardCount
parameter_list|()
block|{
return|return
name|relocatingShards
return|;
block|}
comment|/**      * Returns the active primary shard for the given ShardRouting or<code>null</code> if      * no primary is found or the primary is not active.      */
DECL|method|activePrimary
specifier|public
name|ShardRouting
name|activePrimary
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|assignedShards
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|shardRouting
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
name|shardRouting
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns one active replica shard for the given ShardRouting shard ID or<code>null</code> if      * no active replica is found.      */
DECL|method|activeReplica
specifier|public
name|ShardRouting
name|activeReplica
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|assignedShards
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|shardRouting
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
name|shardRouting
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns all shards that are not in the state UNASSIGNED with the same shard      * ID as the given shard.      */
DECL|method|assignedShards
specifier|public
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
name|assignedShards
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
return|return
name|assignedShards
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns<code>true</code> iff all replicas are active for the given shard routing. Otherwise<code>false</code>      */
DECL|method|allReplicasActive
specifier|public
name|boolean
name|allReplicasActive
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
name|assignedShards
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shards
operator|.
name|isEmpty
argument_list|()
operator|||
name|shards
operator|.
name|size
argument_list|()
operator|<
name|this
operator|.
name|routingTable
operator|.
name|index
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|.
name|shard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
comment|// if we are empty nothing is active if we have less than total at least one is unassigned
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
control|)
block|{
if|if
condition|(
operator|!
name|shard
operator|.
name|active
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|shards
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|(
name|Predicate
argument_list|<
name|ShardRouting
argument_list|>
name|predicate
parameter_list|)
block|{
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
name|shards
operator|.
name|add
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|shards
return|;
block|}
DECL|method|shardsWithState
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardsWithState
parameter_list|(
name|ShardRoutingState
modifier|...
name|state
parameter_list|)
block|{
comment|// TODO these are used on tests only - move into utils class
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|shards
operator|.
name|addAll
argument_list|(
name|routingNode
operator|.
name|shardsWithState
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ShardRoutingState
name|s
range|:
name|state
control|)
block|{
if|if
condition|(
name|s
operator|==
name|ShardRoutingState
operator|.
name|UNASSIGNED
condition|)
block|{
name|unassigned
argument_list|()
operator|.
name|forEach
argument_list|(
name|shards
operator|::
name|add
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|shards
return|;
block|}
DECL|method|shardsWithState
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardsWithState
parameter_list|(
name|String
name|index
parameter_list|,
name|ShardRoutingState
modifier|...
name|state
parameter_list|)
block|{
comment|// TODO these are used on tests only - move into utils class
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|shards
operator|.
name|addAll
argument_list|(
name|routingNode
operator|.
name|shardsWithState
argument_list|(
name|index
argument_list|,
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ShardRoutingState
name|s
range|:
name|state
control|)
block|{
if|if
condition|(
name|s
operator|==
name|ShardRoutingState
operator|.
name|UNASSIGNED
condition|)
block|{
for|for
control|(
name|ShardRouting
name|unassignedShard
range|:
name|unassignedShards
control|)
block|{
if|if
condition|(
name|unassignedShard
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|shards
operator|.
name|add
argument_list|(
name|unassignedShard
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
return|return
name|shards
return|;
block|}
DECL|method|prettyPrint
specifier|public
name|String
name|prettyPrint
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"routing_nodes:\n"
argument_list|)
decl_stmt|;
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|this
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|routingNode
operator|.
name|prettyPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"---- unassigned\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shardEntry
range|:
name|unassignedShards
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"--------"
argument_list|)
operator|.
name|append
argument_list|(
name|shardEntry
operator|.
name|shortSummary
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Moves a shard from unassigned to initialize state      *      * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.      * @return                     the initialized shard      */
DECL|method|initialize
specifier|public
name|ShardRouting
name|initialize
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|String
name|nodeId
parameter_list|,
annotation|@
name|Nullable
name|String
name|existingAllocationId
parameter_list|,
name|long
name|expectedSize
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
assert|assert
name|shard
operator|.
name|unassigned
argument_list|()
operator|:
literal|"expected an unassigned shard "
operator|+
name|shard
assert|;
name|ShardRouting
name|initializedShard
init|=
name|shard
operator|.
name|initialize
argument_list|(
name|nodeId
argument_list|,
name|existingAllocationId
argument_list|,
name|expectedSize
argument_list|)
decl_stmt|;
name|node
argument_list|(
name|nodeId
argument_list|)
operator|.
name|add
argument_list|(
name|initializedShard
argument_list|)
expr_stmt|;
name|inactiveShardCount
operator|++
expr_stmt|;
if|if
condition|(
name|initializedShard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|++
expr_stmt|;
block|}
name|addRecovery
argument_list|(
name|initializedShard
argument_list|)
expr_stmt|;
name|assignedShardsAdd
argument_list|(
name|initializedShard
argument_list|)
expr_stmt|;
return|return
name|initializedShard
return|;
block|}
comment|/**      * Relocate a shard to another node, adding the target initializing      * shard as well as assigning it.      *      * @return pair of source relocating and target initializing shards.      */
DECL|method|relocate
specifier|public
name|Tuple
argument_list|<
name|ShardRouting
argument_list|,
name|ShardRouting
argument_list|>
name|relocate
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|String
name|nodeId
parameter_list|,
name|long
name|expectedShardSize
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
name|relocatingShards
operator|++
expr_stmt|;
name|ShardRouting
name|source
init|=
name|shard
operator|.
name|relocate
argument_list|(
name|nodeId
argument_list|,
name|expectedShardSize
argument_list|)
decl_stmt|;
name|ShardRouting
name|target
init|=
name|source
operator|.
name|buildTargetRelocatingShard
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|shard
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|node
argument_list|(
name|target
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|assignedShardsAdd
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|addRecovery
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|Tuple
operator|.
name|tuple
argument_list|(
name|source
argument_list|,
name|target
argument_list|)
return|;
block|}
comment|/**      * Mark a shard as started and adjusts internal statistics.      *      * @return the started shard      */
DECL|method|started
specifier|public
name|ShardRouting
name|started
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
assert|assert
operator|!
name|shard
operator|.
name|active
argument_list|()
operator|:
literal|"expected an initializing shard "
operator|+
name|shard
assert|;
if|if
condition|(
name|shard
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// if this is not a target shard for relocation, we need to update statistics
name|inactiveShardCount
operator|--
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|--
expr_stmt|;
block|}
block|}
name|removeRecovery
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|ShardRouting
name|startedShard
init|=
name|shard
operator|.
name|moveToStarted
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|shard
argument_list|,
name|startedShard
argument_list|)
expr_stmt|;
return|return
name|startedShard
return|;
block|}
comment|/**      * Cancels a relocation of a shard that shard must relocating.      *      * @return the shard after cancelling relocation      */
DECL|method|cancelRelocation
specifier|public
name|ShardRouting
name|cancelRelocation
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
name|relocatingShards
operator|--
expr_stmt|;
name|ShardRouting
name|cancelledShard
init|=
name|shard
operator|.
name|cancelRelocation
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|shard
argument_list|,
name|cancelledShard
argument_list|)
expr_stmt|;
return|return
name|cancelledShard
return|;
block|}
comment|/**      * moves the assigned replica shard to primary.      *      * @param replicaShard the replica shard to be promoted to primary      * @return             the resulting primary shard      */
DECL|method|promoteAssignedReplicaShardToPrimary
specifier|public
name|ShardRouting
name|promoteAssignedReplicaShardToPrimary
parameter_list|(
name|ShardRouting
name|replicaShard
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
assert|assert
name|replicaShard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"unassigned shard cannot be promoted to primary: "
operator|+
name|replicaShard
assert|;
assert|assert
name|replicaShard
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|:
literal|"primary shard cannot be promoted to primary: "
operator|+
name|replicaShard
assert|;
name|ShardRouting
name|primaryShard
init|=
name|replicaShard
operator|.
name|moveToPrimary
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|replicaShard
argument_list|,
name|primaryShard
argument_list|)
expr_stmt|;
return|return
name|primaryShard
return|;
block|}
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|EMPTY
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
DECL|method|assignedShards
specifier|private
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|assignedShards
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|replicaSet
init|=
name|assignedShards
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
return|return
name|replicaSet
operator|==
literal|null
condition|?
name|EMPTY
else|:
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|replicaSet
argument_list|)
return|;
block|}
comment|/**      * Cancels the give shard from the Routing nodes internal statistics and cancels      * the relocation if the shard is relocating.      */
DECL|method|remove
specifier|private
name|void
name|remove
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|active
argument_list|()
operator|&&
name|shard
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|inactiveShardCount
operator|--
expr_stmt|;
assert|assert
name|inactiveShardCount
operator|>=
literal|0
assert|;
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|shard
operator|=
name|cancelRelocation
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
name|assignedShardsRemove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|initializing
argument_list|()
condition|)
block|{
name|removeRecovery
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assignedShardsAdd
specifier|private
name|void
name|assignedShardsAdd
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"unassigned shard "
operator|+
name|shard
operator|+
literal|" cannot be added to list of assigned shards"
assert|;
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
name|assignedShards
operator|.
name|computeIfAbsent
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|assertInstanceNotInList
argument_list|(
name|shard
argument_list|,
name|shards
argument_list|)
operator|:
literal|"shard "
operator|+
name|shard
operator|+
literal|" cannot appear twice in list of assigned shards"
assert|;
name|shards
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|method|assertInstanceNotInList
specifier|private
name|boolean
name|assertInstanceNotInList
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|)
block|{
for|for
control|(
name|ShardRouting
name|s
range|:
name|shards
control|)
block|{
assert|assert
name|s
operator|!=
name|shard
assert|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|assignedShardsRemove
specifier|private
name|void
name|assignedShardsRemove
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|replicaSet
init|=
name|assignedShards
operator|.
name|get
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replicaSet
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
init|=
name|replicaSet
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|// yes we check identity here
if|if
condition|(
name|shard
operator|==
name|iterator
operator|.
name|next
argument_list|()
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
assert|assert
literal|false
operator|:
literal|"No shard found to remove"
assert|;
block|}
DECL|method|isKnown
specifier|public
name|boolean
name|isKnown
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|)
block|{
return|return
name|nodesToShards
operator|.
name|containsKey
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|)
return|;
block|}
DECL|method|addNode
specifier|public
name|void
name|addNode
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
name|RoutingNode
name|routingNode
init|=
operator|new
name|RoutingNode
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|nodesToShards
operator|.
name|put
argument_list|(
name|routingNode
operator|.
name|nodeId
argument_list|()
argument_list|,
name|routingNode
argument_list|)
expr_stmt|;
block|}
DECL|method|routingNodeIter
specifier|public
name|RoutingNodeIterator
name|routingNodeIter
parameter_list|(
name|String
name|nodeId
parameter_list|)
block|{
specifier|final
name|RoutingNode
name|routingNode
init|=
name|nodesToShards
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
operator|new
name|RoutingNodeIterator
argument_list|(
name|routingNode
argument_list|)
return|;
block|}
DECL|method|toArray
specifier|public
name|RoutingNode
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|nodesToShards
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|RoutingNode
index|[
name|nodesToShards
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|reinitShadowPrimary
specifier|public
name|ShardRouting
name|reinitShadowPrimary
parameter_list|(
name|ShardRouting
name|candidate
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
if|if
condition|(
name|candidate
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|cancelRelocation
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
name|ShardRouting
name|reinitializedShard
init|=
name|candidate
operator|.
name|reinitializeShard
argument_list|()
decl_stmt|;
name|updateAssigned
argument_list|(
name|candidate
argument_list|,
name|reinitializedShard
argument_list|)
expr_stmt|;
name|inactivePrimaryCount
operator|++
expr_stmt|;
name|inactiveShardCount
operator|++
expr_stmt|;
return|return
name|reinitializedShard
return|;
block|}
DECL|method|updateAssigned
specifier|private
name|void
name|updateAssigned
parameter_list|(
name|ShardRouting
name|oldShard
parameter_list|,
name|ShardRouting
name|newShard
parameter_list|)
block|{
assert|assert
name|oldShard
operator|.
name|shardId
argument_list|()
operator|.
name|equals
argument_list|(
name|newShard
operator|.
name|shardId
argument_list|()
argument_list|)
operator|:
literal|"can only update "
operator|+
name|oldShard
operator|+
literal|" by shard with same shard id but was "
operator|+
name|newShard
assert|;
assert|assert
name|oldShard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|&&
name|newShard
operator|.
name|unassigned
argument_list|()
operator|==
literal|false
operator|:
literal|"only assigned shards can be updated in list of assigned shards (prev: "
operator|+
name|oldShard
operator|+
literal|", new: "
operator|+
name|newShard
operator|+
literal|")"
assert|;
assert|assert
name|oldShard
operator|.
name|currentNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|newShard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|:
literal|"shard to update "
operator|+
name|oldShard
operator|+
literal|" can only update "
operator|+
name|oldShard
operator|+
literal|" by shard assigned to same node but was "
operator|+
name|newShard
assert|;
name|node
argument_list|(
name|oldShard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|update
argument_list|(
name|oldShard
argument_list|,
name|newShard
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardsWithMatchingShardId
init|=
name|assignedShards
operator|.
name|computeIfAbsent
argument_list|(
name|oldShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|k
lambda|->
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|previousShardIndex
init|=
name|shardsWithMatchingShardId
operator|.
name|indexOf
argument_list|(
name|oldShard
argument_list|)
decl_stmt|;
assert|assert
name|previousShardIndex
operator|>=
literal|0
operator|:
literal|"shard to update "
operator|+
name|oldShard
operator|+
literal|" does not exist in list of assigned shards"
assert|;
name|shardsWithMatchingShardId
operator|.
name|set
argument_list|(
name|previousShardIndex
argument_list|,
name|newShard
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the number of routing nodes      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|nodesToShards
operator|.
name|size
argument_list|()
return|;
block|}
DECL|class|UnassignedShards
specifier|public
specifier|static
specifier|final
class|class
name|UnassignedShards
implements|implements
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|nodes
specifier|private
specifier|final
name|RoutingNodes
name|nodes
decl_stmt|;
DECL|field|unassigned
specifier|private
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|unassigned
decl_stmt|;
DECL|field|ignored
specifier|private
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|ignored
decl_stmt|;
DECL|field|primaries
specifier|private
name|int
name|primaries
init|=
literal|0
decl_stmt|;
DECL|field|ignoredPrimaries
specifier|private
name|int
name|ignoredPrimaries
init|=
literal|0
decl_stmt|;
DECL|method|UnassignedShards
specifier|public
name|UnassignedShards
parameter_list|(
name|RoutingNodes
name|nodes
parameter_list|)
block|{
name|this
operator|.
name|nodes
operator|=
name|nodes
expr_stmt|;
name|unassigned
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|ignored
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|primaries
operator|++
expr_stmt|;
block|}
name|unassigned
operator|.
name|add
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|(
name|Comparator
argument_list|<
name|ShardRouting
argument_list|>
name|comparator
parameter_list|)
block|{
name|CollectionUtil
operator|.
name|timSort
argument_list|(
name|unassigned
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
block|}
comment|/**          * Returns the size of the non-ignored unassigned shards          */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|unassigned
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the size of the temporarily marked as ignored unassigned shards          */
DECL|method|ignoredSize
specifier|public
name|int
name|ignoredSize
parameter_list|()
block|{
return|return
name|ignored
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the number of non-ignored unassigned primaries          */
DECL|method|getNumPrimaries
specifier|public
name|int
name|getNumPrimaries
parameter_list|()
block|{
return|return
name|primaries
return|;
block|}
comment|/**          * Returns the number of temporarily marked as ignored unassigned primaries          */
DECL|method|getNumIgnoredPrimaries
specifier|public
name|int
name|getNumIgnoredPrimaries
parameter_list|()
block|{
return|return
name|ignoredPrimaries
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|UnassignedIterator
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|UnassignedIterator
argument_list|()
return|;
block|}
comment|/**          * The list of ignored unassigned shards (read only). The ignored unassigned shards          * are not part of the formal unassigned list, but are kept around and used to build          * back the list of unassigned shards as part of the routing table.          */
DECL|method|ignored
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|ignored
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|ignored
argument_list|)
return|;
block|}
comment|/**          * Marks a shard as temporarily ignored and adds it to the ignore unassigned list.          * Should be used with caution, typically,          * the correct usage is to removeAndIgnore from the iterator.          * @see #ignored()          * @see UnassignedIterator#removeAndIgnore()          * @see #isIgnoredEmpty()          */
DECL|method|ignoreShard
specifier|public
name|void
name|ignoreShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|ignoredPrimaries
operator|++
expr_stmt|;
block|}
name|ignored
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|class|UnassignedIterator
specifier|public
class|class
name|UnassignedIterator
implements|implements
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|iterator
specifier|private
specifier|final
name|ListIterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
decl_stmt|;
DECL|field|current
specifier|private
name|ShardRouting
name|current
decl_stmt|;
DECL|method|UnassignedIterator
specifier|public
name|UnassignedIterator
parameter_list|()
block|{
name|this
operator|.
name|iterator
operator|=
name|unassigned
operator|.
name|listIterator
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|ShardRouting
name|next
parameter_list|()
block|{
return|return
name|current
operator|=
name|iterator
operator|.
name|next
argument_list|()
return|;
block|}
comment|/**              * Initializes the current unassigned shard and moves it from the unassigned list.              *              * @param existingAllocationId allocation id to use. If null, a fresh allocation id is generated.              */
DECL|method|initialize
specifier|public
name|ShardRouting
name|initialize
parameter_list|(
name|String
name|nodeId
parameter_list|,
annotation|@
name|Nullable
name|String
name|existingAllocationId
parameter_list|,
name|long
name|expectedShardSize
parameter_list|)
block|{
name|innerRemove
argument_list|()
expr_stmt|;
return|return
name|nodes
operator|.
name|initialize
argument_list|(
name|current
argument_list|,
name|nodeId
argument_list|,
name|existingAllocationId
argument_list|,
name|expectedShardSize
argument_list|)
return|;
block|}
comment|/**              * Removes and ignores the unassigned shard (will be ignored for this run, but              * will be added back to unassigned once the metadata is constructed again).              * Typically this is used when an allocation decision prevents a shard from being allocated such              * that subsequent consumers of this API won't try to allocate this shard again.              */
DECL|method|removeAndIgnore
specifier|public
name|void
name|removeAndIgnore
parameter_list|()
block|{
name|innerRemove
argument_list|()
expr_stmt|;
name|ignoreShard
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
DECL|method|updateShardRouting
specifier|private
name|void
name|updateShardRouting
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
name|current
operator|=
name|shardRouting
expr_stmt|;
name|iterator
operator|.
name|set
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
comment|/**              * updates the unassigned info on the current unassigned shard              *              * @param  unassignedInfo the new unassigned info to use              * @return the shard with unassigned info updated              */
DECL|method|updateUnassignedInfo
specifier|public
name|ShardRouting
name|updateUnassignedInfo
parameter_list|(
name|UnassignedInfo
name|unassignedInfo
parameter_list|)
block|{
name|ShardRouting
name|updatedShardRouting
init|=
name|current
operator|.
name|updateUnassignedInfo
argument_list|(
name|unassignedInfo
argument_list|)
decl_stmt|;
name|updateShardRouting
argument_list|(
name|updatedShardRouting
argument_list|)
expr_stmt|;
return|return
name|updatedShardRouting
return|;
block|}
comment|/**              * marks the current primary shard as replica              *              * @return the shard with primary status swapped              */
DECL|method|demotePrimaryToReplicaShard
specifier|public
name|ShardRouting
name|demotePrimaryToReplicaShard
parameter_list|()
block|{
assert|assert
name|current
operator|.
name|primary
argument_list|()
operator|:
literal|"non-primary shard "
operator|+
name|current
operator|+
literal|" cannot be demoted"
assert|;
name|updateShardRouting
argument_list|(
name|current
operator|.
name|moveFromPrimary
argument_list|()
argument_list|)
expr_stmt|;
name|primaries
operator|--
expr_stmt|;
return|return
name|current
return|;
block|}
comment|/**              * Unsupported operation, just there for the interface. Use {@link #removeAndIgnore()} or              * {@link #initialize(String, String, long)}.              */
annotation|@
name|Override
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"remove is not supported in unassigned iterator, use removeAndIgnore or initialize"
argument_list|)
throw|;
block|}
DECL|method|innerRemove
specifier|private
name|void
name|innerRemove
parameter_list|()
block|{
name|nodes
operator|.
name|ensureMutable
argument_list|()
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
operator|.
name|primary
argument_list|()
condition|)
block|{
name|primaries
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Returns<code>true</code> iff this collection contains one or more non-ignored unassigned shards.          */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|unassigned
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**          * Returns<code>true</code> iff any unassigned shards are marked as temporarily ignored.          * @see UnassignedShards#ignoreShard(ShardRouting)          * @see UnassignedIterator#removeAndIgnore()          */
DECL|method|isIgnoredEmpty
specifier|public
name|boolean
name|isIgnoredEmpty
parameter_list|()
block|{
return|return
name|ignored
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|shuffle
specifier|public
name|void
name|shuffle
parameter_list|()
block|{
name|Randomness
operator|.
name|shuffle
argument_list|(
name|unassigned
argument_list|)
expr_stmt|;
block|}
comment|/**          * Drains all unassigned shards and returns it.          * This method will not drain ignored shards.          */
DECL|method|drain
specifier|public
name|ShardRouting
index|[]
name|drain
parameter_list|()
block|{
name|ShardRouting
index|[]
name|mutableShardRoutings
init|=
name|unassigned
operator|.
name|toArray
argument_list|(
operator|new
name|ShardRouting
index|[
name|unassigned
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
name|unassigned
operator|.
name|clear
argument_list|()
expr_stmt|;
name|primaries
operator|=
literal|0
expr_stmt|;
return|return
name|mutableShardRoutings
return|;
block|}
block|}
comment|/**      * Calculates RoutingNodes statistics by iterating over all {@link ShardRouting}s      * in the cluster to ensure the book-keeping is correct.      * For performance reasons, this should only be called from asserts      *      * @return this method always returns<code>true</code> or throws an assertion error. If assertion are not enabled      *         this method does nothing.      */
DECL|method|assertShardStats
specifier|public
specifier|static
name|boolean
name|assertShardStats
parameter_list|(
name|RoutingNodes
name|routingNodes
parameter_list|)
block|{
name|boolean
name|run
init|=
literal|false
decl_stmt|;
assert|assert
operator|(
name|run
operator|=
literal|true
operator|)
assert|;
comment|// only run if assertions are enabled!
if|if
condition|(
operator|!
name|run
condition|)
block|{
return|return
literal|true
return|;
block|}
name|int
name|unassignedPrimaryCount
init|=
literal|0
decl_stmt|;
name|int
name|unassignedIgnoredPrimaryCount
init|=
literal|0
decl_stmt|;
name|int
name|inactivePrimaryCount
init|=
literal|0
decl_stmt|;
name|int
name|inactiveShardCount
init|=
literal|0
decl_stmt|;
name|int
name|relocating
init|=
literal|0
decl_stmt|;
name|Map
argument_list|<
name|Index
argument_list|,
name|Integer
argument_list|>
name|indicesAndShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|node
range|:
name|routingNodes
control|)
block|{
for|for
control|(
name|ShardRouting
name|shard
range|:
name|node
control|)
block|{
if|if
condition|(
operator|!
name|shard
operator|.
name|active
argument_list|()
operator|&&
name|shard
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|shard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|inactiveShardCount
operator|++
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|inactivePrimaryCount
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|shard
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|relocating
operator|++
expr_stmt|;
block|}
name|Integer
name|i
init|=
name|indicesAndShards
operator|.
name|get
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|null
condition|)
block|{
name|i
operator|=
name|shard
operator|.
name|id
argument_list|()
expr_stmt|;
block|}
name|indicesAndShards
operator|.
name|put
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|i
argument_list|,
name|shard
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Assert that the active shard routing are identical.
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Index
argument_list|,
name|Integer
argument_list|>
argument_list|>
name|entries
init|=
name|indicesAndShards
operator|.
name|entrySet
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Index
argument_list|,
name|Integer
argument_list|>
name|e
range|:
name|entries
control|)
block|{
name|Index
name|index
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|e
operator|.
name|getValue
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|RoutingNode
name|routingNode
range|:
name|routingNodes
control|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|index
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
operator|&&
name|shardRouting
operator|.
name|id
argument_list|()
operator|==
name|i
condition|)
block|{
name|shards
operator|.
name|add
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|mutableShardRoutings
init|=
name|routingNodes
operator|.
name|assignedShards
argument_list|(
operator|new
name|ShardId
argument_list|(
name|index
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|mutableShardRoutings
operator|.
name|size
argument_list|()
operator|==
name|shards
operator|.
name|size
argument_list|()
assert|;
for|for
control|(
name|ShardRouting
name|r
range|:
name|mutableShardRoutings
control|)
block|{
assert|assert
name|shards
operator|.
name|contains
argument_list|(
name|r
argument_list|)
assert|;
name|shards
operator|.
name|remove
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
assert|assert
name|shards
operator|.
name|isEmpty
argument_list|()
assert|;
block|}
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNodes
operator|.
name|unassigned
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|unassignedPrimaryCount
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNodes
operator|.
name|unassigned
argument_list|()
operator|.
name|ignored
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|unassignedIgnoredPrimaryCount
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Recoveries
argument_list|>
name|recoveries
range|:
name|routingNodes
operator|.
name|recoveriesPerNode
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|node
init|=
name|recoveries
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|Recoveries
name|value
init|=
name|recoveries
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|int
name|incoming
init|=
literal|0
decl_stmt|;
name|int
name|outgoing
init|=
literal|0
decl_stmt|;
name|RoutingNode
name|routingNode
init|=
name|routingNodes
operator|.
name|nodesToShards
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|!=
literal|null
condition|)
block|{
comment|// node might have dropped out of the cluster
for|for
control|(
name|ShardRouting
name|routing
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|routing
operator|.
name|initializing
argument_list|()
condition|)
block|{
name|incoming
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|routing
operator|.
name|relocating
argument_list|()
condition|)
block|{
name|outgoing
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|routing
operator|.
name|primary
argument_list|()
operator|&&
operator|(
name|routing
operator|.
name|initializing
argument_list|()
operator|&&
name|routing
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
operator|)
operator|==
literal|false
condition|)
block|{
comment|// we don't count the initialization end of the primary relocation
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shardRoutings
init|=
name|routingNodes
operator|.
name|assignedShards
operator|.
name|get
argument_list|(
name|routing
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ShardRouting
name|assigned
range|:
name|shardRoutings
control|)
block|{
if|if
condition|(
name|assigned
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|&&
name|assigned
operator|.
name|initializing
argument_list|()
operator|&&
name|assigned
operator|.
name|relocatingNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
name|outgoing
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
assert|assert
name|incoming
operator|==
name|value
operator|.
name|incoming
operator|:
name|incoming
operator|+
literal|" != "
operator|+
name|value
operator|.
name|incoming
assert|;
assert|assert
name|outgoing
operator|==
name|value
operator|.
name|outgoing
operator|:
name|outgoing
operator|+
literal|" != "
operator|+
name|value
operator|.
name|outgoing
operator|+
literal|" node: "
operator|+
name|routingNode
assert|;
block|}
assert|assert
name|unassignedPrimaryCount
operator|==
name|routingNodes
operator|.
name|unassignedShards
operator|.
name|getNumPrimaries
argument_list|()
operator|:
literal|"Unassigned primaries is ["
operator|+
name|unassignedPrimaryCount
operator|+
literal|"] but RoutingNodes returned unassigned primaries ["
operator|+
name|routingNodes
operator|.
name|unassigned
argument_list|()
operator|.
name|getNumPrimaries
argument_list|()
operator|+
literal|"]"
assert|;
assert|assert
name|unassignedIgnoredPrimaryCount
operator|==
name|routingNodes
operator|.
name|unassignedShards
operator|.
name|getNumIgnoredPrimaries
argument_list|()
operator|:
literal|"Unassigned ignored primaries is ["
operator|+
name|unassignedIgnoredPrimaryCount
operator|+
literal|"] but RoutingNodes returned unassigned ignored primaries ["
operator|+
name|routingNodes
operator|.
name|unassigned
argument_list|()
operator|.
name|getNumIgnoredPrimaries
argument_list|()
operator|+
literal|"]"
assert|;
assert|assert
name|inactivePrimaryCount
operator|==
name|routingNodes
operator|.
name|inactivePrimaryCount
operator|:
literal|"Inactive Primary count ["
operator|+
name|inactivePrimaryCount
operator|+
literal|"] but RoutingNodes returned inactive primaries ["
operator|+
name|routingNodes
operator|.
name|inactivePrimaryCount
operator|+
literal|"]"
assert|;
assert|assert
name|inactiveShardCount
operator|==
name|routingNodes
operator|.
name|inactiveShardCount
operator|:
literal|"Inactive Shard count ["
operator|+
name|inactiveShardCount
operator|+
literal|"] but RoutingNodes returned inactive shards ["
operator|+
name|routingNodes
operator|.
name|inactiveShardCount
operator|+
literal|"]"
assert|;
assert|assert
name|routingNodes
operator|.
name|getRelocatingShardCount
argument_list|()
operator|==
name|relocating
operator|:
literal|"Relocating shards mismatch ["
operator|+
name|routingNodes
operator|.
name|getRelocatingShardCount
argument_list|()
operator|+
literal|"] but expected ["
operator|+
name|relocating
operator|+
literal|"]"
assert|;
return|return
literal|true
return|;
block|}
DECL|class|RoutingNodesIterator
specifier|public
class|class
name|RoutingNodesIterator
implements|implements
name|Iterator
argument_list|<
name|RoutingNode
argument_list|>
implements|,
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|current
specifier|private
name|RoutingNode
name|current
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
name|Iterator
argument_list|<
name|RoutingNode
argument_list|>
name|delegate
decl_stmt|;
DECL|method|RoutingNodesIterator
specifier|public
name|RoutingNodesIterator
parameter_list|(
name|Iterator
argument_list|<
name|RoutingNode
argument_list|>
name|iterator
parameter_list|)
block|{
name|delegate
operator|=
name|iterator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|RoutingNode
name|next
parameter_list|()
block|{
return|return
name|current
operator|=
name|delegate
operator|.
name|next
argument_list|()
return|;
block|}
DECL|method|nodeShards
specifier|public
name|RoutingNodeIterator
name|nodeShards
parameter_list|()
block|{
return|return
operator|new
name|RoutingNodeIterator
argument_list|(
name|current
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|delegate
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|nodeShards
argument_list|()
return|;
block|}
block|}
DECL|class|RoutingNodeIterator
specifier|public
specifier|final
class|class
name|RoutingNodeIterator
implements|implements
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
implements|,
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|iterable
specifier|private
specifier|final
name|RoutingNode
name|iterable
decl_stmt|;
DECL|field|shard
specifier|private
name|ShardRouting
name|shard
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|delegate
decl_stmt|;
DECL|field|removed
specifier|private
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
DECL|method|RoutingNodeIterator
specifier|public
name|RoutingNodeIterator
parameter_list|(
name|RoutingNode
name|iterable
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|iterable
operator|.
name|mutableIterator
argument_list|()
expr_stmt|;
name|this
operator|.
name|iterable
operator|=
name|iterable
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|ShardRouting
name|next
parameter_list|()
block|{
name|removed
operator|=
literal|false
expr_stmt|;
return|return
name|shard
operator|=
name|delegate
operator|.
name|next
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
name|delegate
operator|.
name|remove
argument_list|()
expr_stmt|;
name|RoutingNodes
operator|.
name|this
operator|.
name|remove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
comment|/** returns true if {@link #remove()} or {@link #moveToUnassigned(UnassignedInfo)} were called on the current shard */
DECL|method|isRemoved
specifier|public
name|boolean
name|isRemoved
parameter_list|()
block|{
return|return
name|removed
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|iterable
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|moveToUnassigned
specifier|public
name|ShardRouting
name|moveToUnassigned
parameter_list|(
name|UnassignedInfo
name|unassignedInfo
parameter_list|)
block|{
name|ensureMutable
argument_list|()
expr_stmt|;
if|if
condition|(
name|isRemoved
argument_list|()
operator|==
literal|false
condition|)
block|{
name|remove
argument_list|()
expr_stmt|;
block|}
name|ShardRouting
name|unassigned
init|=
name|shard
operator|.
name|moveToUnassigned
argument_list|(
name|unassignedInfo
argument_list|)
decl_stmt|;
name|unassignedShards
operator|.
name|add
argument_list|(
name|unassigned
argument_list|)
expr_stmt|;
return|return
name|unassigned
return|;
block|}
DECL|method|current
specifier|public
name|ShardRouting
name|current
parameter_list|()
block|{
return|return
name|shard
return|;
block|}
block|}
DECL|method|ensureMutable
specifier|private
name|void
name|ensureMutable
parameter_list|()
block|{
if|if
condition|(
name|readOnly
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"can't modify RoutingNodes - readonly"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates an iterator over shards interleaving between nodes: The iterator returns the first shard from      * the first node, then the first shard of the second node, etc. until one shard from each node has been returned.      * The iterator then resumes on the first node by returning the second shard and continues until all shards from      * all the nodes have been returned.      */
DECL|method|nodeInterleavedShardIterator
specifier|public
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|nodeInterleavedShardIterator
parameter_list|()
block|{
specifier|final
name|Queue
argument_list|<
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|queue
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|RoutingNode
argument_list|>
name|entry
range|:
name|nodesToShards
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|queue
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|copyShards
argument_list|()
operator|.
name|iterator
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
argument_list|()
block|{
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
while|while
condition|(
operator|!
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|queue
operator|.
name|peek
argument_list|()
operator|.
name|hasNext
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
name|queue
operator|.
name|poll
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
specifier|public
name|ShardRouting
name|next
parameter_list|()
block|{
if|if
condition|(
name|hasNext
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iter
init|=
name|queue
operator|.
name|poll
argument_list|()
decl_stmt|;
name|ShardRouting
name|result
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|queue
operator|.
name|offer
argument_list|(
name|iter
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
return|;
block|}
DECL|class|Recoveries
specifier|private
specifier|static
specifier|final
class|class
name|Recoveries
block|{
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|Recoveries
name|EMPTY
init|=
operator|new
name|Recoveries
argument_list|()
decl_stmt|;
DECL|field|incoming
specifier|private
name|int
name|incoming
init|=
literal|0
decl_stmt|;
DECL|field|outgoing
specifier|private
name|int
name|outgoing
init|=
literal|0
decl_stmt|;
DECL|method|getTotal
name|int
name|getTotal
parameter_list|()
block|{
return|return
name|incoming
operator|+
name|outgoing
return|;
block|}
DECL|method|addOutgoing
name|void
name|addOutgoing
parameter_list|(
name|int
name|howMany
parameter_list|)
block|{
assert|assert
name|outgoing
operator|+
name|howMany
operator|>=
literal|0
operator|:
name|outgoing
operator|+
name|howMany
operator|+
literal|" must be>= 0"
assert|;
name|outgoing
operator|+=
name|howMany
expr_stmt|;
block|}
DECL|method|addIncoming
name|void
name|addIncoming
parameter_list|(
name|int
name|howMany
parameter_list|)
block|{
assert|assert
name|incoming
operator|+
name|howMany
operator|>=
literal|0
operator|:
name|incoming
operator|+
name|howMany
operator|+
literal|" must be>= 0"
assert|;
name|incoming
operator|+=
name|howMany
expr_stmt|;
block|}
DECL|method|getOutgoing
name|int
name|getOutgoing
parameter_list|()
block|{
return|return
name|outgoing
return|;
block|}
DECL|method|getIncoming
name|int
name|getIncoming
parameter_list|()
block|{
return|return
name|incoming
return|;
block|}
DECL|method|getOrAdd
specifier|public
specifier|static
name|Recoveries
name|getOrAdd
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Recoveries
argument_list|>
name|map
parameter_list|,
name|String
name|key
parameter_list|)
block|{
name|Recoveries
name|recoveries
init|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|recoveries
operator|==
literal|null
condition|)
block|{
name|recoveries
operator|=
operator|new
name|Recoveries
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|recoveries
argument_list|)
expr_stmt|;
block|}
return|return
name|recoveries
return|;
block|}
block|}
block|}
end_class

end_unit

