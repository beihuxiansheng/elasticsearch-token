begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.cluster.routing.allocation
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|UnassignedInfo
operator|.
name|AllocationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_comment
comment|/**  * Represents the allocation decision by an allocator for an unassigned shard.  */
end_comment

begin_class
DECL|class|AllocateUnassignedDecision
specifier|public
class|class
name|AllocateUnassignedDecision
extends|extends
name|AbstractAllocationDecision
block|{
comment|/** a constant representing a shard decision where no decision was taken */
DECL|field|NOT_TAKEN
specifier|public
specifier|static
specifier|final
name|AllocateUnassignedDecision
name|NOT_TAKEN
init|=
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|AllocationStatus
operator|.
name|NO_ATTEMPT
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
comment|/**      * a map of cached common no/throttle decisions that don't need explanations,      * this helps prevent unnecessary object allocations for the non-explain API case      */
DECL|field|CACHED_DECISIONS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|AllocationStatus
argument_list|,
name|AllocateUnassignedDecision
argument_list|>
name|CACHED_DECISIONS
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|AllocationStatus
argument_list|,
name|AllocateUnassignedDecision
argument_list|>
name|cachedDecisions
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|cachedDecisions
operator|.
name|put
argument_list|(
name|AllocationStatus
operator|.
name|FETCHING_SHARD_DATA
argument_list|,
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|AllocationStatus
operator|.
name|FETCHING_SHARD_DATA
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
name|cachedDecisions
operator|.
name|put
argument_list|(
name|AllocationStatus
operator|.
name|NO_VALID_SHARD_COPY
argument_list|,
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|AllocationStatus
operator|.
name|NO_VALID_SHARD_COPY
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
name|cachedDecisions
operator|.
name|put
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_NO
argument_list|,
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_NO
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
name|cachedDecisions
operator|.
name|put
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_THROTTLED
argument_list|,
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_THROTTLED
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
name|cachedDecisions
operator|.
name|put
argument_list|(
name|AllocationStatus
operator|.
name|DELAYED_ALLOCATION
argument_list|,
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|AllocationStatus
operator|.
name|DELAYED_ALLOCATION
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
name|CACHED_DECISIONS
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|cachedDecisions
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Nullable
DECL|field|allocationStatus
specifier|private
specifier|final
name|AllocationStatus
name|allocationStatus
decl_stmt|;
annotation|@
name|Nullable
DECL|field|allocationId
specifier|private
specifier|final
name|String
name|allocationId
decl_stmt|;
DECL|field|reuseStore
specifier|private
specifier|final
name|boolean
name|reuseStore
decl_stmt|;
DECL|field|remainingDelayInMillis
specifier|private
specifier|final
name|long
name|remainingDelayInMillis
decl_stmt|;
DECL|field|configuredDelayInMillis
specifier|private
specifier|final
name|long
name|configuredDelayInMillis
decl_stmt|;
DECL|method|AllocateUnassignedDecision
specifier|private
name|AllocateUnassignedDecision
parameter_list|(
name|AllocationStatus
name|allocationStatus
parameter_list|,
name|DiscoveryNode
name|assignedNode
parameter_list|,
name|String
name|allocationId
parameter_list|,
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|nodeDecisions
parameter_list|,
name|boolean
name|reuseStore
parameter_list|,
name|long
name|remainingDelayInMillis
parameter_list|,
name|long
name|configuredDelayInMillis
parameter_list|)
block|{
name|super
argument_list|(
name|assignedNode
argument_list|,
name|nodeDecisions
argument_list|)
expr_stmt|;
assert|assert
name|assignedNode
operator|!=
literal|null
operator|||
name|allocationStatus
operator|!=
literal|null
operator|:
literal|"a yes decision must have a node to assign the shard to"
assert|;
assert|assert
name|allocationId
operator|==
literal|null
operator|||
name|assignedNode
operator|!=
literal|null
operator|:
literal|"allocation id can only be null if the assigned node is null"
assert|;
name|this
operator|.
name|allocationStatus
operator|=
name|allocationStatus
expr_stmt|;
name|this
operator|.
name|allocationId
operator|=
name|allocationId
expr_stmt|;
name|this
operator|.
name|reuseStore
operator|=
name|reuseStore
expr_stmt|;
name|this
operator|.
name|remainingDelayInMillis
operator|=
name|remainingDelayInMillis
expr_stmt|;
name|this
operator|.
name|configuredDelayInMillis
operator|=
name|configuredDelayInMillis
expr_stmt|;
block|}
DECL|method|AllocateUnassignedDecision
specifier|public
name|AllocateUnassignedDecision
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|allocationStatus
operator|=
name|in
operator|.
name|readOptionalWriteable
argument_list|(
name|AllocationStatus
operator|::
name|readFrom
argument_list|)
expr_stmt|;
name|allocationId
operator|=
name|in
operator|.
name|readOptionalString
argument_list|()
expr_stmt|;
name|reuseStore
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|remainingDelayInMillis
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|configuredDelayInMillis
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level      * decisions that comprised the final NO decision if in explain mode.      */
DECL|method|no
specifier|public
specifier|static
name|AllocateUnassignedDecision
name|no
parameter_list|(
name|AllocationStatus
name|allocationStatus
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|decisions
parameter_list|)
block|{
return|return
name|no
argument_list|(
name|allocationStatus
argument_list|,
name|decisions
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Returns a NO decision for a delayed shard allocation on a replica shard, with the individual node-level      * decisions that comprised the final NO decision, if in explain mode.  Instances created with this      * method will return {@link AllocationStatus#DELAYED_ALLOCATION} for {@link #getAllocationStatus()}.      */
DECL|method|delayed
specifier|public
specifier|static
name|AllocateUnassignedDecision
name|delayed
parameter_list|(
name|long
name|remainingDelay
parameter_list|,
name|long
name|totalDelay
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|decisions
parameter_list|)
block|{
return|return
name|no
argument_list|(
name|AllocationStatus
operator|.
name|DELAYED_ALLOCATION
argument_list|,
name|decisions
argument_list|,
literal|false
argument_list|,
name|remainingDelay
argument_list|,
name|totalDelay
argument_list|)
return|;
block|}
comment|/**      * Returns a NO decision with the given {@link AllocationStatus}, and the individual node-level      * decisions that comprised the final NO decision if in explain mode.      */
DECL|method|no
specifier|public
specifier|static
name|AllocateUnassignedDecision
name|no
parameter_list|(
name|AllocationStatus
name|allocationStatus
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|decisions
parameter_list|,
name|boolean
name|reuseStore
parameter_list|)
block|{
return|return
name|no
argument_list|(
name|allocationStatus
argument_list|,
name|decisions
argument_list|,
name|reuseStore
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
return|;
block|}
DECL|method|no
specifier|private
specifier|static
name|AllocateUnassignedDecision
name|no
parameter_list|(
name|AllocationStatus
name|allocationStatus
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|decisions
parameter_list|,
name|boolean
name|reuseStore
parameter_list|,
name|long
name|remainingDelay
parameter_list|,
name|long
name|totalDelay
parameter_list|)
block|{
if|if
condition|(
name|decisions
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|allocationStatus
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|decisions
argument_list|,
name|reuseStore
argument_list|,
name|remainingDelay
argument_list|,
name|totalDelay
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getCachedDecision
argument_list|(
name|allocationStatus
argument_list|)
return|;
block|}
block|}
comment|/**      * Returns a THROTTLE decision, with the individual node-level decisions that      * comprised the final THROTTLE decision if in explain mode.      */
DECL|method|throttle
specifier|public
specifier|static
name|AllocateUnassignedDecision
name|throttle
parameter_list|(
annotation|@
name|Nullable
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|decisions
parameter_list|)
block|{
if|if
condition|(
name|decisions
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_THROTTLED
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|decisions
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|getCachedDecision
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_THROTTLED
argument_list|)
return|;
block|}
block|}
comment|/**      * Creates a YES decision with the given individual node-level decisions that      * comprised the final YES decision, along with the node id to which the shard is assigned and      * the allocation id for the shard, if available.      */
DECL|method|yes
specifier|public
specifier|static
name|AllocateUnassignedDecision
name|yes
parameter_list|(
name|DiscoveryNode
name|assignedNode
parameter_list|,
annotation|@
name|Nullable
name|String
name|allocationId
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|decisions
parameter_list|,
name|boolean
name|reuseStore
parameter_list|)
block|{
return|return
operator|new
name|AllocateUnassignedDecision
argument_list|(
literal|null
argument_list|,
name|assignedNode
argument_list|,
name|allocationId
argument_list|,
name|decisions
argument_list|,
name|reuseStore
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
return|;
block|}
comment|/**      * Creates a {@link AllocateUnassignedDecision} from the given {@link Decision} and the assigned node, if any.      */
DECL|method|fromDecision
specifier|public
specifier|static
name|AllocateUnassignedDecision
name|fromDecision
parameter_list|(
name|Decision
name|decision
parameter_list|,
annotation|@
name|Nullable
name|DiscoveryNode
name|assignedNode
parameter_list|,
annotation|@
name|Nullable
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|nodeDecisions
parameter_list|)
block|{
specifier|final
name|Type
name|decisionType
init|=
name|decision
operator|.
name|type
argument_list|()
decl_stmt|;
name|AllocationStatus
name|allocationStatus
init|=
name|decisionType
operator|!=
name|Type
operator|.
name|YES
condition|?
name|AllocationStatus
operator|.
name|fromDecision
argument_list|(
name|decisionType
argument_list|)
else|:
literal|null
decl_stmt|;
return|return
operator|new
name|AllocateUnassignedDecision
argument_list|(
name|allocationStatus
argument_list|,
name|assignedNode
argument_list|,
literal|null
argument_list|,
name|nodeDecisions
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
return|;
block|}
DECL|method|getCachedDecision
specifier|private
specifier|static
name|AllocateUnassignedDecision
name|getCachedDecision
parameter_list|(
name|AllocationStatus
name|allocationStatus
parameter_list|)
block|{
name|AllocateUnassignedDecision
name|decision
init|=
name|CACHED_DECISIONS
operator|.
name|get
argument_list|(
name|allocationStatus
argument_list|)
decl_stmt|;
return|return
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|decision
argument_list|,
literal|"precomputed decision not found for "
operator|+
name|allocationStatus
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|isDecisionTaken
specifier|public
name|boolean
name|isDecisionTaken
parameter_list|()
block|{
return|return
name|this
operator|!=
name|NOT_TAKEN
return|;
block|}
comment|/**      * Returns the {@link AllocationDecision} denoting the result of an allocation attempt.      * If {@link #isDecisionTaken()} returns {@code false}, then invoking this method will      * throw an {@code IllegalStateException}.      */
DECL|method|getAllocationDecision
specifier|public
name|AllocationDecision
name|getAllocationDecision
parameter_list|()
block|{
name|checkDecisionState
argument_list|()
expr_stmt|;
return|return
name|AllocationDecision
operator|.
name|fromAllocationStatus
argument_list|(
name|allocationStatus
argument_list|)
return|;
block|}
comment|/**      * Returns the status of an unsuccessful allocation attempt.  This value will be {@code null} if      * no decision was taken or if the decision was {@link Decision.Type#YES}.  If {@link #isDecisionTaken()}      * returns {@code false}, then invoking this method will throw an {@code IllegalStateException}.      */
annotation|@
name|Nullable
DECL|method|getAllocationStatus
specifier|public
name|AllocationStatus
name|getAllocationStatus
parameter_list|()
block|{
name|checkDecisionState
argument_list|()
expr_stmt|;
return|return
name|allocationStatus
return|;
block|}
comment|/**      * Gets the allocation id for the existing shard copy that the allocator is assigning the shard to.      * This method returns a non-null value iff {@link #getTargetNode()} returns a non-null value      * and the node on which the shard is assigned already has a shard copy with an in-sync allocation id      * that we can re-use.  If {@link #isDecisionTaken()} returns {@code false}, then invoking this method      * will throw an {@code IllegalStateException}.      */
annotation|@
name|Nullable
DECL|method|getAllocationId
specifier|public
name|String
name|getAllocationId
parameter_list|()
block|{
name|checkDecisionState
argument_list|()
expr_stmt|;
return|return
name|allocationId
return|;
block|}
comment|/**      * Gets the remaining delay for allocating the replica shard when a node holding the replica left      * the cluster and the deciders are waiting to see if the node returns before allocating the replica      * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns      * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},      * then invoking this method will throw an {@code IllegalStateException}.      */
DECL|method|getRemainingDelayInMillis
specifier|public
name|long
name|getRemainingDelayInMillis
parameter_list|()
block|{
name|checkDecisionState
argument_list|()
expr_stmt|;
return|return
name|remainingDelayInMillis
return|;
block|}
comment|/**      * Gets the total configured delay for allocating the replica shard when a node holding the replica left      * the cluster and the deciders are waiting to see if the node returns before allocating the replica      * elsewhere.  Only returns a meaningful positive value if {@link #getAllocationStatus()} returns      * {@link AllocationStatus#DELAYED_ALLOCATION}.  If {@link #isDecisionTaken()} returns {@code false},      * then invoking this method will throw an {@code IllegalStateException}.      */
DECL|method|getConfiguredDelayInMillis
specifier|public
name|long
name|getConfiguredDelayInMillis
parameter_list|()
block|{
name|checkDecisionState
argument_list|()
expr_stmt|;
return|return
name|configuredDelayInMillis
return|;
block|}
annotation|@
name|Override
DECL|method|getExplanation
specifier|public
name|String
name|getExplanation
parameter_list|()
block|{
name|checkDecisionState
argument_list|()
expr_stmt|;
name|String
name|explanation
decl_stmt|;
if|if
condition|(
name|allocationStatus
operator|==
literal|null
condition|)
block|{
name|explanation
operator|=
literal|"can allocate the shard"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allocationStatus
operator|==
name|AllocationStatus
operator|.
name|DECIDERS_THROTTLED
condition|)
block|{
name|explanation
operator|=
literal|"allocation temporarily throttled"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allocationStatus
operator|==
name|AllocationStatus
operator|.
name|FETCHING_SHARD_DATA
condition|)
block|{
name|explanation
operator|=
literal|"cannot allocate because information about existing shard data is still being retrieved from "
operator|+
literal|"some of the nodes"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|allocationStatus
operator|==
name|AllocationStatus
operator|.
name|NO_VALID_SHARD_COPY
condition|)
block|{
if|if
condition|(
name|getNodeDecisions
argument_list|()
operator|!=
literal|null
operator|&&
name|getNodeDecisions
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|explanation
operator|=
literal|"cannot allocate because all existing copies of the shard are unreadable"
expr_stmt|;
block|}
else|else
block|{
name|explanation
operator|=
literal|"cannot allocate because a previous copy of the shard existed but could not be found"
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|allocationStatus
operator|==
name|AllocationStatus
operator|.
name|DELAYED_ALLOCATION
condition|)
block|{
name|explanation
operator|=
literal|"cannot allocate because the cluster is still waiting "
operator|+
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|remainingDelayInMillis
argument_list|)
operator|+
literal|" for the departed node holding a replica to rejoin"
operator|+
operator|(
name|atLeastOneNodeWithYesDecision
argument_list|()
condition|?
literal|", despite being allowed to allocate the shard to at least one other node"
else|:
literal|""
operator|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|allocationStatus
operator|==
name|AllocationStatus
operator|.
name|DECIDERS_NO
assert|;
if|if
condition|(
name|reuseStore
condition|)
block|{
name|explanation
operator|=
literal|"cannot allocate because allocation is not permitted to any of the nodes that hold an in-sync shard copy"
expr_stmt|;
block|}
else|else
block|{
name|explanation
operator|=
literal|"cannot allocate because allocation is not permitted to any of the nodes"
expr_stmt|;
block|}
block|}
return|return
name|explanation
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|checkDecisionState
argument_list|()
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"can_allocate"
argument_list|,
name|getAllocationDecision
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"allocate_explanation"
argument_list|,
name|getExplanation
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetNode
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|startObject
argument_list|(
literal|"target_node"
argument_list|)
expr_stmt|;
name|discoveryNodeToXContent
argument_list|(
name|targetNode
argument_list|,
literal|true
argument_list|,
name|builder
argument_list|)
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|allocationId
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"allocation_id"
argument_list|,
name|allocationId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allocationStatus
operator|==
name|AllocationStatus
operator|.
name|DELAYED_ALLOCATION
condition|)
block|{
name|builder
operator|.
name|timeValueField
argument_list|(
literal|"configured_delay_in_millis"
argument_list|,
literal|"configured_delay"
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|configuredDelayInMillis
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|timeValueField
argument_list|(
literal|"remaining_delay_in_millis"
argument_list|,
literal|"remaining_delay"
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|remainingDelayInMillis
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nodeDecisionsToXContent
argument_list|(
name|nodeDecisions
argument_list|,
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
name|builder
return|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalWriteable
argument_list|(
name|allocationStatus
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalString
argument_list|(
name|allocationId
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|reuseStore
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|remainingDelayInMillis
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|configuredDelayInMillis
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

