begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.cluster.routing.allocation.allocator
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|allocator
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntroSorter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|UnassignedInfo
operator|.
name|AllocationStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|AllocateUnassignedDecision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|AllocationDecision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|MoveDecision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|NodeAllocationResult
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|RoutingAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|AllocationDeciders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|DiskThresholdDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|ClusterSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|PriorityComparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
operator|.
name|RELOCATING
import|;
end_import

begin_comment
comment|/**  * The {@link BalancedShardsAllocator} re-balances the nodes allocations  * within an cluster based on a {@link WeightFunction}. The clusters balance is defined by four parameters which can be set  * in the cluster update API that allows changes in real-time:  *<ul><li><code>cluster.routing.allocation.balance.shard</code> - The<b>shard balance</b> defines the weight factor  * for shards allocated on a {@link RoutingNode}</li>  *<li><code>cluster.routing.allocation.balance.index</code> - The<b>index balance</b> defines a factor to the number  * of {@link org.elasticsearch.cluster.routing.ShardRouting}s per index allocated on a specific node</li>  *<li><code>cluster.routing.allocation.balance.threshold</code> - A<b>threshold</b> to set the minimal optimization  * value of operations that should be performed</li>  *</ul>  *<p>  * These parameters are combined in a {@link WeightFunction} that allows calculation of node weights which  * are used to re-balance shards based on global as well as per-index factors.  */
end_comment

begin_class
DECL|class|BalancedShardsAllocator
specifier|public
class|class
name|BalancedShardsAllocator
extends|extends
name|AbstractComponent
implements|implements
name|ShardsAllocator
block|{
DECL|field|INDEX_BALANCE_FACTOR_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|INDEX_BALANCE_FACTOR_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.index"
argument_list|,
literal|0.55f
argument_list|,
literal|0.0f
argument_list|,
name|Property
operator|.
name|Dynamic
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|SHARD_BALANCE_FACTOR_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|SHARD_BALANCE_FACTOR_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.shard"
argument_list|,
literal|0.45f
argument_list|,
literal|0.0f
argument_list|,
name|Property
operator|.
name|Dynamic
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|THRESHOLD_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|THRESHOLD_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.threshold"
argument_list|,
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
name|Property
operator|.
name|Dynamic
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|weightFunction
specifier|private
specifier|volatile
name|WeightFunction
name|weightFunction
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|volatile
name|float
name|threshold
decl_stmt|;
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|this
argument_list|(
name|settings
argument_list|,
operator|new
name|ClusterSettings
argument_list|(
name|settings
argument_list|,
name|ClusterSettings
operator|.
name|BUILT_IN_CLUSTER_SETTINGS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Inject
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|ClusterSettings
name|clusterSettings
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|setWeightFunction
argument_list|(
name|INDEX_BALANCE_FACTOR_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|,
name|SHARD_BALANCE_FACTOR_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|setThreshold
argument_list|(
name|THRESHOLD_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|clusterSettings
operator|.
name|addSettingsUpdateConsumer
argument_list|(
name|INDEX_BALANCE_FACTOR_SETTING
argument_list|,
name|SHARD_BALANCE_FACTOR_SETTING
argument_list|,
name|this
operator|::
name|setWeightFunction
argument_list|)
expr_stmt|;
name|clusterSettings
operator|.
name|addSettingsUpdateConsumer
argument_list|(
name|THRESHOLD_SETTING
argument_list|,
name|this
operator|::
name|setThreshold
argument_list|)
expr_stmt|;
block|}
DECL|method|setWeightFunction
specifier|private
name|void
name|setWeightFunction
parameter_list|(
name|float
name|indexBalance
parameter_list|,
name|float
name|shardBalanceFactor
parameter_list|)
block|{
name|weightFunction
operator|=
operator|new
name|WeightFunction
argument_list|(
name|indexBalance
argument_list|,
name|shardBalanceFactor
argument_list|)
expr_stmt|;
block|}
DECL|method|setThreshold
specifier|private
name|void
name|setThreshold
parameter_list|(
name|float
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|weighShard
specifier|public
name|Map
argument_list|<
name|DiscoveryNode
argument_list|,
name|Float
argument_list|>
name|weighShard
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|,
name|ShardRouting
name|shard
parameter_list|)
block|{
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
return|return
name|balancer
operator|.
name|weighShard
argument_list|(
name|shard
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|allocate
specifier|public
name|void
name|allocate
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
if|if
condition|(
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* with no nodes this is pointless */
return|return;
block|}
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
name|balancer
operator|.
name|allocateUnassigned
argument_list|()
expr_stmt|;
name|balancer
operator|.
name|moveShards
argument_list|()
expr_stmt|;
name|balancer
operator|.
name|balance
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a decision on rebalancing a single shard to form a more optimal cluster balance.  This      * method is not used in itself for cluster rebalancing because all shards from all indices are      * taken into account when making rebalancing decisions.  This method is only intended to be used      * from the cluster allocation explain API to explain possible rebalancing decisions for a single      * shard.      */
DECL|method|decideRebalance
specifier|public
name|MoveDecision
name|decideRebalance
parameter_list|(
specifier|final
name|ShardRouting
name|shard
parameter_list|,
specifier|final
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
assert|assert
name|allocation
operator|.
name|debugDecision
argument_list|()
operator|:
literal|"debugDecision should be set in explain mode"
assert|;
return|return
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
operator|.
name|decideRebalance
argument_list|(
name|shard
argument_list|)
return|;
block|}
comment|/**      * Returns the currently configured delta threshold      */
DECL|method|getThreshold
specifier|public
name|float
name|getThreshold
parameter_list|()
block|{
return|return
name|threshold
return|;
block|}
comment|/**      * Returns the index related weight factor.      */
DECL|method|getIndexBalance
specifier|public
name|float
name|getIndexBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|indexBalance
return|;
block|}
comment|/**      * Returns the shard related weight factor.      */
DECL|method|getShardBalance
specifier|public
name|float
name|getShardBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|shardBalance
return|;
block|}
comment|/**      * This class is the primary weight function used to create balanced over nodes and shards in the cluster.      * Currently this function has 3 properties:      *<ul>      *<li><code>index balance</code> - balance property over shards per index</li>      *<li><code>shard balance</code> - balance property over shards per cluster</li>      *</ul>      *<p>      * Each of these properties are expressed as factor such that the properties factor defines the relative importance of the property for the      * weight function. For example if the weight function should calculate the weights only based on a global (shard) balance the index balance      * can be set to<tt>0.0</tt> and will in turn have no effect on the distribution.      *</p>      * The weight per index is calculated based on the following formula:      *<ul>      *<li>      *<code>weight<sub>index</sub>(node, index) = indexBalance * (node.numShards(index) - avgShardsPerNode(index))</code>      *</li>      *<li>      *<code>weight<sub>node</sub>(node, index) = shardBalance * (node.numShards() - avgShardsPerNode)</code>      *</li>      *</ul>      *<code>weight(node, index) = weight<sub>index</sub>(node, index) + weight<sub>node</sub>(node, index)</code>      */
DECL|class|WeightFunction
specifier|public
specifier|static
class|class
name|WeightFunction
block|{
DECL|field|indexBalance
specifier|private
specifier|final
name|float
name|indexBalance
decl_stmt|;
DECL|field|shardBalance
specifier|private
specifier|final
name|float
name|shardBalance
decl_stmt|;
DECL|field|theta0
specifier|private
specifier|final
name|float
name|theta0
decl_stmt|;
DECL|field|theta1
specifier|private
specifier|final
name|float
name|theta1
decl_stmt|;
DECL|method|WeightFunction
specifier|public
name|WeightFunction
parameter_list|(
name|float
name|indexBalance
parameter_list|,
name|float
name|shardBalance
parameter_list|)
block|{
name|float
name|sum
init|=
name|indexBalance
operator|+
name|shardBalance
decl_stmt|;
if|if
condition|(
name|sum
operator|<=
literal|0.0f
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Balance factors must sum to a value> 0 but was: "
operator|+
name|sum
argument_list|)
throw|;
block|}
name|theta0
operator|=
name|shardBalance
operator|/
name|sum
expr_stmt|;
name|theta1
operator|=
name|indexBalance
operator|/
name|sum
expr_stmt|;
name|this
operator|.
name|indexBalance
operator|=
name|indexBalance
expr_stmt|;
name|this
operator|.
name|shardBalance
operator|=
name|shardBalance
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
return|return
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|weightShardAdded
specifier|public
name|float
name|weightShardAdded
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
return|return
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|method|weightShardRemoved
specifier|public
name|float
name|weightShardRemoved
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
return|return
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|weight
specifier|private
name|float
name|weight
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|,
name|int
name|numAdditionalShards
parameter_list|)
block|{
specifier|final
name|float
name|weightShard
init|=
name|node
operator|.
name|numShards
argument_list|()
operator|+
name|numAdditionalShards
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|()
decl_stmt|;
specifier|final
name|float
name|weightIndex
init|=
name|node
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|+
name|numAdditionalShards
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|theta0
operator|*
name|weightShard
operator|+
name|theta1
operator|*
name|weightIndex
return|;
block|}
block|}
comment|/**      * A {@link Balancer}      */
DECL|class|Balancer
specifier|public
specifier|static
class|class
name|Balancer
block|{
DECL|field|logger
specifier|private
specifier|final
name|Logger
name|logger
decl_stmt|;
DECL|field|nodes
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelNode
argument_list|>
name|nodes
decl_stmt|;
DECL|field|allocation
specifier|private
specifier|final
name|RoutingAllocation
name|allocation
decl_stmt|;
DECL|field|routingNodes
specifier|private
specifier|final
name|RoutingNodes
name|routingNodes
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|WeightFunction
name|weight
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|float
name|threshold
decl_stmt|;
DECL|field|metaData
specifier|private
specifier|final
name|MetaData
name|metaData
decl_stmt|;
DECL|field|avgShardsPerNode
specifier|private
specifier|final
name|float
name|avgShardsPerNode
decl_stmt|;
DECL|field|sorter
specifier|private
specifier|final
name|NodeSorter
name|sorter
decl_stmt|;
DECL|method|Balancer
specifier|public
name|Balancer
parameter_list|(
name|Logger
name|logger
parameter_list|,
name|RoutingAllocation
name|allocation
parameter_list|,
name|WeightFunction
name|weight
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|allocation
operator|=
name|allocation
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
name|this
operator|.
name|routingNodes
operator|=
name|allocation
operator|.
name|routingNodes
argument_list|()
expr_stmt|;
name|this
operator|.
name|metaData
operator|=
name|allocation
operator|.
name|metaData
argument_list|()
expr_stmt|;
name|avgShardsPerNode
operator|=
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|getTotalNumberOfShards
argument_list|()
operator|)
operator|/
name|routingNodes
operator|.
name|size
argument_list|()
expr_stmt|;
name|nodes
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|buildModelFromAssigned
argument_list|()
argument_list|)
expr_stmt|;
name|sorter
operator|=
name|newNodeSorter
argument_list|()
expr_stmt|;
block|}
comment|/**          * Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.          */
DECL|method|nodesArray
specifier|private
name|ModelNode
index|[]
name|nodesArray
parameter_list|()
block|{
return|return
name|nodes
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ModelNode
index|[
name|nodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**          * Returns the average of shards per node for the given index          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|(
name|String
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|getTotalNumberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the global average of shards per node          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|()
block|{
return|return
name|avgShardsPerNode
return|;
block|}
comment|/**          * Returns a new {@link NodeSorter} that sorts the nodes based on their          * current weight with respect to the index passed to the sorter. The          * returned sorter is not sorted. Use {@link NodeSorter#reset(String)}          * to sort based on an index.          */
DECL|method|newNodeSorter
specifier|private
name|NodeSorter
name|newNodeSorter
parameter_list|()
block|{
return|return
operator|new
name|NodeSorter
argument_list|(
name|nodesArray
argument_list|()
argument_list|,
name|weight
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**          * The absolute value difference between two weights.          */
DECL|method|absDelta
specifier|private
specifier|static
name|float
name|absDelta
parameter_list|(
name|float
name|lower
parameter_list|,
name|float
name|higher
parameter_list|)
block|{
assert|assert
name|higher
operator|>=
name|lower
operator|:
name|higher
operator|+
literal|" lt "
operator|+
name|lower
operator|+
literal|" but was expected to be gte"
assert|;
return|return
name|Math
operator|.
name|abs
argument_list|(
name|higher
operator|-
name|lower
argument_list|)
return|;
block|}
comment|/**          * Returns {@code true} iff the weight delta between two nodes is under a defined threshold.          * See {@link #THRESHOLD_SETTING} for defining the threshold.          */
DECL|method|lessThan
specifier|private
specifier|static
name|boolean
name|lessThan
parameter_list|(
name|float
name|delta
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
comment|/* deltas close to the threshold are "rounded" to the threshold manually                to prevent floating point problems if the delta is very close to the                threshold ie. 1.000000002 which can trigger unnecessary balance actions*/
return|return
name|delta
operator|<=
operator|(
name|threshold
operator|+
literal|0.001f
operator|)
return|;
block|}
comment|/**          * Balances the nodes on the cluster model according to the weight function.          * The actual balancing is delegated to {@link #balanceByWeights()}          */
DECL|method|balance
specifier|private
name|void
name|balance
parameter_list|()
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start balancing cluster"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allocation
operator|.
name|hasPendingAsyncFetch
argument_list|()
condition|)
block|{
comment|/*                  * see https://github.com/elastic/elasticsearch/issues/14387                  * if we allow rebalance operations while we are still fetching shard store data                  * we might end up with unnecessary rebalance operations which can be super confusion/frustrating                  * since once the fetches come back we might just move all the shards back again.                  * Therefore we only do a rebalance if we have fetched all information.                  */
name|logger
operator|.
name|debug
argument_list|(
literal|"skipping rebalance due to in-flight shard/store fetches"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canRebalance
argument_list|(
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"skipping rebalance as it is disabled"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nodes
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|/* skip if we only have one node */
name|logger
operator|.
name|trace
argument_list|(
literal|"skipping rebalance as single node only"
argument_list|)
expr_stmt|;
return|return;
block|}
name|balanceByWeights
argument_list|()
expr_stmt|;
block|}
comment|/**          * Makes a decision about moving a single shard to a different node to form a more          * optimally balanced cluster.  This method is invoked from the cluster allocation          * explain API only.          */
DECL|method|decideRebalance
specifier|private
name|MoveDecision
name|decideRebalance
parameter_list|(
specifier|final
name|ShardRouting
name|shard
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|.
name|started
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// cannot rebalance a shard that isn't started
return|return
name|MoveDecision
operator|.
name|NOT_TAKEN
return|;
block|}
name|Decision
name|canRebalance
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canRebalance
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|sorter
operator|.
name|reset
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
name|ModelNode
index|[]
name|modelNodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
specifier|final
name|String
name|currentNodeId
init|=
name|shard
operator|.
name|currentNodeId
argument_list|()
decl_stmt|;
comment|// find currently assigned node
name|ModelNode
name|currentNode
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ModelNode
name|node
range|:
name|modelNodes
control|)
block|{
if|if
condition|(
name|node
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|currentNodeId
argument_list|)
condition|)
block|{
name|currentNode
operator|=
name|node
expr_stmt|;
break|break;
block|}
block|}
assert|assert
name|currentNode
operator|!=
literal|null
operator|:
literal|"currently assigned node could not be found"
assert|;
comment|// balance the shard, if a better node can be found
specifier|final
name|float
name|currentWeight
init|=
name|sorter
operator|.
name|weight
argument_list|(
name|currentNode
argument_list|)
decl_stmt|;
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
specifier|final
name|String
name|idxName
init|=
name|shard
operator|.
name|getIndexName
argument_list|()
decl_stmt|;
name|Type
name|rebalanceDecisionType
init|=
name|Type
operator|.
name|NO
decl_stmt|;
name|ModelNode
name|assignedNode
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|Tuple
argument_list|<
name|ModelNode
argument_list|,
name|Decision
argument_list|>
argument_list|>
name|betterBalanceNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Tuple
argument_list|<
name|ModelNode
argument_list|,
name|Decision
argument_list|>
argument_list|>
name|sameBalanceNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Tuple
argument_list|<
name|ModelNode
argument_list|,
name|Decision
argument_list|>
argument_list|>
name|worseBalanceNodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ModelNode
name|node
range|:
name|modelNodes
control|)
block|{
if|if
condition|(
name|node
operator|==
name|currentNode
condition|)
block|{
continue|continue;
comment|// skip over node we're currently allocated to
block|}
specifier|final
name|Decision
name|canAllocate
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|node
operator|.
name|getRoutingNode
argument_list|()
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
comment|// the current weight of the node in the cluster, as computed by the weight function;
comment|// this is a comparison of the number of shards on this node to the number of shards
comment|// that should be on each node on average (both taking the cluster as a whole into account
comment|// as well as shards per index)
specifier|final
name|float
name|nodeWeight
init|=
name|sorter
operator|.
name|weight
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|// if the node we are examining has a worse (higher) weight than the node the shard is
comment|// assigned to, then there is no way moving the shard to the node with the worse weight
comment|// can make the balance of the cluster better, so we check for that here
specifier|final
name|boolean
name|betterWeightThanCurrent
init|=
name|nodeWeight
operator|<=
name|currentWeight
decl_stmt|;
name|boolean
name|rebalanceConditionsMet
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|betterWeightThanCurrent
condition|)
block|{
comment|// get the delta between the weights of the node we are checking and the node that holds the shard
name|float
name|currentDelta
init|=
name|absDelta
argument_list|(
name|nodeWeight
argument_list|,
name|currentWeight
argument_list|)
decl_stmt|;
comment|// checks if the weight delta is above a certain threshold; if it is not above a certain threshold,
comment|// then even though the node we are examining has a better weight and may make the cluster balance
comment|// more even, it doesn't make sense to execute the heavyweight operation of relocating a shard unless
comment|// the gains make it worth it, as defined by the threshold
name|boolean
name|deltaAboveThreshold
init|=
name|lessThan
argument_list|(
name|currentDelta
argument_list|,
name|threshold
argument_list|)
operator|==
literal|false
decl_stmt|;
comment|// simulate the weight of the node if we were to relocate the shard to it
name|float
name|weightWithShardAdded
init|=
name|weight
operator|.
name|weightShardAdded
argument_list|(
name|this
argument_list|,
name|node
argument_list|,
name|idxName
argument_list|)
decl_stmt|;
comment|// calculate the delta of the weights of the two nodes if we were to add the shard to the
comment|// node in question and move it away from the node that currently holds it.
name|float
name|proposedDelta
init|=
name|weightWithShardAdded
operator|-
name|weight
operator|.
name|weightShardRemoved
argument_list|(
name|this
argument_list|,
name|currentNode
argument_list|,
name|idxName
argument_list|)
decl_stmt|;
name|boolean
name|betterWeightWithShardAdded
init|=
name|proposedDelta
operator|<
name|currentDelta
decl_stmt|;
name|rebalanceConditionsMet
operator|=
name|deltaAboveThreshold
operator|&&
name|betterWeightWithShardAdded
expr_stmt|;
comment|// if the simulated weight delta with the shard moved away is better than the weight delta
comment|// with the shard remaining on the current node, and we are allowed to allocate to the
comment|// node in question, then allow the rebalance
if|if
condition|(
name|rebalanceConditionsMet
operator|&&
name|canAllocate
operator|.
name|type
argument_list|()
operator|.
name|higherThan
argument_list|(
name|rebalanceDecisionType
argument_list|)
condition|)
block|{
comment|// rebalance to the node, only will get overwritten if the decision here is to
comment|// THROTTLE and we get a decision with YES on another node
name|rebalanceDecisionType
operator|=
name|canAllocate
operator|.
name|type
argument_list|()
expr_stmt|;
name|assignedNode
operator|=
name|node
expr_stmt|;
block|}
block|}
name|Tuple
argument_list|<
name|ModelNode
argument_list|,
name|Decision
argument_list|>
name|nodeResult
init|=
name|Tuple
operator|.
name|tuple
argument_list|(
name|node
argument_list|,
name|canAllocate
argument_list|)
decl_stmt|;
if|if
condition|(
name|rebalanceConditionsMet
condition|)
block|{
name|betterBalanceNodes
operator|.
name|add
argument_list|(
name|nodeResult
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|betterWeightThanCurrent
condition|)
block|{
name|sameBalanceNodes
operator|.
name|add
argument_list|(
name|nodeResult
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|worseBalanceNodes
operator|.
name|add
argument_list|(
name|nodeResult
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|weightRanking
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|nodeDecisions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|modelNodes
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|Tuple
argument_list|<
name|ModelNode
argument_list|,
name|Decision
argument_list|>
name|result
range|:
name|betterBalanceNodes
control|)
block|{
name|nodeDecisions
operator|.
name|add
argument_list|(
operator|new
name|NodeAllocationResult
argument_list|(
name|result
operator|.
name|v1
argument_list|()
operator|.
name|routingNode
operator|.
name|node
argument_list|()
argument_list|,
name|AllocationDecision
operator|.
name|fromDecisionType
argument_list|(
name|result
operator|.
name|v2
argument_list|()
operator|.
name|type
argument_list|()
argument_list|)
argument_list|,
name|result
operator|.
name|v2
argument_list|()
argument_list|,
operator|++
name|weightRanking
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|int
name|currentNodeWeightRanking
init|=
operator|++
name|weightRanking
decl_stmt|;
for|for
control|(
name|Tuple
argument_list|<
name|ModelNode
argument_list|,
name|Decision
argument_list|>
name|result
range|:
name|sameBalanceNodes
control|)
block|{
name|AllocationDecision
name|nodeDecision
init|=
name|result
operator|.
name|v2
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|NO
condition|?
name|AllocationDecision
operator|.
name|NO
else|:
name|AllocationDecision
operator|.
name|WORSE_BALANCE
decl_stmt|;
name|nodeDecisions
operator|.
name|add
argument_list|(
operator|new
name|NodeAllocationResult
argument_list|(
name|result
operator|.
name|v1
argument_list|()
operator|.
name|routingNode
operator|.
name|node
argument_list|()
argument_list|,
name|nodeDecision
argument_list|,
name|result
operator|.
name|v2
argument_list|()
argument_list|,
name|currentNodeWeightRanking
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Tuple
argument_list|<
name|ModelNode
argument_list|,
name|Decision
argument_list|>
name|result
range|:
name|worseBalanceNodes
control|)
block|{
name|AllocationDecision
name|nodeDecision
init|=
name|result
operator|.
name|v2
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|NO
condition|?
name|AllocationDecision
operator|.
name|NO
else|:
name|AllocationDecision
operator|.
name|WORSE_BALANCE
decl_stmt|;
name|nodeDecisions
operator|.
name|add
argument_list|(
operator|new
name|NodeAllocationResult
argument_list|(
name|result
operator|.
name|v1
argument_list|()
operator|.
name|routingNode
operator|.
name|node
argument_list|()
argument_list|,
name|nodeDecision
argument_list|,
name|result
operator|.
name|v2
argument_list|()
argument_list|,
operator|++
name|weightRanking
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|canRebalance
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
operator|||
name|allocation
operator|.
name|hasPendingAsyncFetch
argument_list|()
condition|)
block|{
name|AllocationDecision
name|allocationDecision
init|=
name|allocation
operator|.
name|hasPendingAsyncFetch
argument_list|()
condition|?
name|AllocationDecision
operator|.
name|FETCH_PENDING
else|:
name|AllocationDecision
operator|.
name|fromDecisionType
argument_list|(
name|canRebalance
operator|.
name|type
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|MoveDecision
operator|.
name|cannotRebalance
argument_list|(
name|canRebalance
argument_list|,
name|allocationDecision
argument_list|,
name|currentNodeWeightRanking
argument_list|,
name|nodeDecisions
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|MoveDecision
operator|.
name|rebalance
argument_list|(
name|canRebalance
argument_list|,
name|AllocationDecision
operator|.
name|fromDecisionType
argument_list|(
name|rebalanceDecisionType
argument_list|)
argument_list|,
name|assignedNode
operator|!=
literal|null
condition|?
name|assignedNode
operator|.
name|routingNode
operator|.
name|node
argument_list|()
else|:
literal|null
argument_list|,
name|currentNodeWeightRanking
argument_list|,
name|nodeDecisions
argument_list|)
return|;
block|}
block|}
DECL|method|weighShard
specifier|public
name|Map
argument_list|<
name|DiscoveryNode
argument_list|,
name|Float
argument_list|>
name|weighShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
specifier|final
name|ModelNode
index|[]
name|modelNodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
specifier|final
name|float
index|[]
name|weights
init|=
name|sorter
operator|.
name|weights
decl_stmt|;
name|buildWeightOrderedIndices
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|DiscoveryNode
argument_list|,
name|Float
argument_list|>
name|nodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|modelNodes
operator|.
name|length
argument_list|)
decl_stmt|;
name|float
name|currentNodeWeight
init|=
literal|0.0f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|modelNodes
index|[
name|i
index|]
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
condition|)
block|{
comment|// If a node was found with the shard, use that weight instead of 0.0
name|currentNodeWeight
operator|=
name|weights
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|float
name|delta
init|=
name|currentNodeWeight
operator|-
name|weights
index|[
name|i
index|]
decl_stmt|;
name|nodes
operator|.
name|put
argument_list|(
name|modelNodes
index|[
name|i
index|]
operator|.
name|getRoutingNode
argument_list|()
operator|.
name|node
argument_list|()
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
return|;
block|}
comment|/**          * Balances the nodes on the cluster model according to the weight          * function. The configured threshold is the minimum delta between the          * weight of the maximum node and the minimum node according to the          * {@link WeightFunction}. This weight is calculated per index to          * distribute shards evenly per index. The balancer tries to relocate          * shards only if the delta exceeds the threshold. In the default case          * the threshold is set to<tt>1.0</tt> to enforce gaining relocation          * only, or in other words relocations that move the weight delta closer          * to<tt>0.0</tt>          */
DECL|method|balanceByWeights
specifier|private
name|void
name|balanceByWeights
parameter_list|()
block|{
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
specifier|final
name|ModelNode
index|[]
name|modelNodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
specifier|final
name|float
index|[]
name|weights
init|=
name|sorter
operator|.
name|weights
decl_stmt|;
for|for
control|(
name|String
name|index
range|:
name|buildWeightOrderedIndices
argument_list|()
control|)
block|{
name|IndexMetaData
name|indexMetaData
init|=
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// find nodes that have a shard of this index or where shards of this index are allowed to be allocated to,
comment|// move these nodes to the front of modelNodes so that we can only balance based on these nodes
name|int
name|relevantNodes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ModelNode
name|modelNode
init|=
name|modelNodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|modelNode
operator|.
name|getIndex
argument_list|(
name|index
argument_list|)
operator|!=
literal|null
operator|||
name|deciders
operator|.
name|canAllocate
argument_list|(
name|indexMetaData
argument_list|,
name|modelNode
operator|.
name|getRoutingNode
argument_list|()
argument_list|,
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|NO
condition|)
block|{
comment|// swap nodes at position i and relevantNodes
name|modelNodes
index|[
name|i
index|]
operator|=
name|modelNodes
index|[
name|relevantNodes
index|]
expr_stmt|;
name|modelNodes
index|[
name|relevantNodes
index|]
operator|=
name|modelNode
expr_stmt|;
name|relevantNodes
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|relevantNodes
operator|<
literal|2
condition|)
block|{
continue|continue;
block|}
name|sorter
operator|.
name|reset
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|relevantNodes
argument_list|)
expr_stmt|;
name|int
name|lowIdx
init|=
literal|0
decl_stmt|;
name|int
name|highIdx
init|=
name|relevantNodes
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|ModelNode
name|minNode
init|=
name|modelNodes
index|[
name|lowIdx
index|]
decl_stmt|;
specifier|final
name|ModelNode
name|maxNode
init|=
name|modelNodes
index|[
name|highIdx
index|]
decl_stmt|;
name|advance_range
label|:
if|if
condition|(
name|maxNode
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|final
name|float
name|delta
init|=
name|absDelta
argument_list|(
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|lessThan
argument_list|(
name|delta
argument_list|,
name|threshold
argument_list|)
condition|)
block|{
if|if
condition|(
name|lowIdx
operator|>
literal|0
operator|&&
name|highIdx
operator|-
literal|1
operator|>
literal|0
comment|// is there a chance for a higher delta?
operator|&&
operator|(
name|absDelta
argument_list|(
name|weights
index|[
literal|0
index|]
argument_list|,
name|weights
index|[
name|highIdx
operator|-
literal|1
index|]
argument_list|)
operator|>
name|threshold
operator|)
comment|// check if we need to break at all
condition|)
block|{
comment|/* This is a special case if allocations from the "heaviest" to the "lighter" nodes is not possible                                  * due to some allocation decider restrictions like zone awareness. if one zone has for instance                                  * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we                                  * can't move to the "lighter" shards since otherwise the zone would go over capacity.                                  *                                  * This break jumps straight to the condition below were we start moving from the high index towards                                  * the low index to shrink the window we are considering for balance from the other direction.                                  * (check shrinking the window from MAX to MIN)                                  * See #3580                                  */
break|break
name|advance_range
break|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|index
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
comment|/* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.                          * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */
if|if
condition|(
name|tryRelocateShard
argument_list|(
name|minNode
argument_list|,
name|maxNode
argument_list|,
name|index
argument_list|,
name|delta
argument_list|)
condition|)
block|{
comment|/*                              * TODO we could be a bit smarter here, we don't need to fully sort necessarily                              * we could just find the place to insert linearly but the win might be minor                              * compared to the added complexity                              */
name|weights
index|[
name|lowIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|modelNodes
index|[
name|lowIdx
index|]
argument_list|)
expr_stmt|;
name|weights
index|[
name|highIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|modelNodes
index|[
name|highIdx
index|]
argument_list|)
expr_stmt|;
name|sorter
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|relevantNodes
argument_list|)
expr_stmt|;
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|=
name|relevantNodes
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|lowIdx
operator|<
name|highIdx
operator|-
literal|1
condition|)
block|{
comment|/* Shrinking the window from MIN to MAX                          * we can't move from any shard from the min node lets move on to the next node                          * and see if the threshold still holds. We either don't have any shard of this                          * index on this node of allocation deciders prevent any relocation.*/
name|lowIdx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowIdx
operator|>
literal|0
condition|)
block|{
comment|/* Shrinking the window from MAX to MIN                          * now we go max to min since obviously we can't move anything to the max node                          * lets pick the next highest */
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* we are done here, we either can't relocate anymore or we are balanced */
break|break;
block|}
block|}
block|}
block|}
comment|/**          * This builds a initial index ordering where the indices are returned          * in most unbalanced first. We need this in order to prevent over          * allocations on added nodes from one index when the weight parameters          * for global balance overrule the index balance at an intermediate          * state. For example this can happen if we have 3 nodes and 3 indices          * with 3 primary and 1 replica shards. At the first stage all three nodes hold          * 2 shard for each index. Now we add another node and the first index          * is balanced moving three shards from two of the nodes over to the new node since it          * has no shards yet and global balance for the node is way below          * average. To re-balance we need to move shards back eventually likely          * to the nodes we relocated them from.          */
DECL|method|buildWeightOrderedIndices
specifier|private
name|String
index|[]
name|buildWeightOrderedIndices
parameter_list|()
block|{
specifier|final
name|String
index|[]
name|indices
init|=
name|allocation
operator|.
name|routingTable
argument_list|()
operator|.
name|indicesRouting
argument_list|()
operator|.
name|keys
argument_list|()
operator|.
name|toArray
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|float
index|[]
name|deltas
init|=
operator|new
name|float
index|[
name|indices
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deltas
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sorter
operator|.
name|reset
argument_list|(
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|sorter
operator|.
name|delta
argument_list|()
expr_stmt|;
block|}
operator|new
name|IntroSorter
argument_list|()
block|{
name|float
name|pivotWeight
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|String
name|tmpIdx
init|=
name|indices
index|[
name|i
index|]
decl_stmt|;
name|indices
index|[
name|i
index|]
operator|=
name|indices
index|[
name|j
index|]
expr_stmt|;
name|indices
index|[
name|j
index|]
operator|=
name|tmpIdx
expr_stmt|;
specifier|final
name|float
name|tmpDelta
init|=
name|deltas
index|[
name|i
index|]
decl_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|deltas
index|[
name|j
index|]
expr_stmt|;
name|deltas
index|[
name|j
index|]
operator|=
name|tmpDelta
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|deltas
index|[
name|i
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|deltas
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|pivotWeight
argument_list|)
return|;
block|}
block|}
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|deltas
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|indices
return|;
block|}
comment|/**          * Move started shards that can not be allocated to a node anymore          *          * For each shard to be moved this function executes a move operation          * to the minimal eligible node with respect to the          * weight function. If a shard is moved the shard will be set to          * {@link ShardRoutingState#RELOCATING} and a shadow instance of this          * shard is created with an incremented version in the state          * {@link ShardRoutingState#INITIALIZING}.          */
DECL|method|moveShards
specifier|public
name|void
name|moveShards
parameter_list|()
block|{
comment|// Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling
comment|// shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are
comment|// offloading the shards.
for|for
control|(
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|it
init|=
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|nodeInterleavedShardIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ShardRouting
name|shardRouting
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|MoveDecision
name|moveDecision
init|=
name|makeMoveDecision
argument_list|(
name|shardRouting
argument_list|)
decl_stmt|;
if|if
condition|(
name|moveDecision
operator|.
name|isDecisionTaken
argument_list|()
operator|&&
name|moveDecision
operator|.
name|forceMove
argument_list|()
condition|)
block|{
specifier|final
name|ModelNode
name|sourceNode
init|=
name|nodes
operator|.
name|get
argument_list|(
name|shardRouting
operator|.
name|currentNodeId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ModelNode
name|targetNode
init|=
name|nodes
operator|.
name|get
argument_list|(
name|moveDecision
operator|.
name|getTargetNode
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|sourceNode
operator|.
name|removeShard
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
name|Tuple
argument_list|<
name|ShardRouting
argument_list|,
name|ShardRouting
argument_list|>
name|relocatingShards
init|=
name|routingNodes
operator|.
name|relocateShard
argument_list|(
name|shardRouting
argument_list|,
name|targetNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|shardRouting
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
argument_list|,
name|allocation
operator|.
name|changes
argument_list|()
argument_list|)
decl_stmt|;
name|targetNode
operator|.
name|addShard
argument_list|(
name|relocatingShards
operator|.
name|v2
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Moved shard [{}] to node [{}]"
argument_list|,
name|shardRouting
argument_list|,
name|targetNode
operator|.
name|getRoutingNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|moveDecision
operator|.
name|isDecisionTaken
argument_list|()
operator|&&
name|moveDecision
operator|.
name|canRemain
argument_list|()
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] can't move"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Makes a decision on whether to move a started shard to another node.  The following rules apply          * to the {@link MoveDecision} return object:          *   1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false.          *   2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and          *      {@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null.          *   3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be          *      populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then          *      {@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null.          *   4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then          *      {@link MoveDecision#nodeDecisions} will have a non-null value.          */
DECL|method|makeMoveDecision
specifier|public
name|MoveDecision
name|makeMoveDecision
parameter_list|(
specifier|final
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|started
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// we can only move started shards
return|return
name|MoveDecision
operator|.
name|NOT_TAKEN
return|;
block|}
specifier|final
name|boolean
name|explain
init|=
name|allocation
operator|.
name|debugDecision
argument_list|()
decl_stmt|;
specifier|final
name|ModelNode
name|sourceNode
init|=
name|nodes
operator|.
name|get
argument_list|(
name|shardRouting
operator|.
name|currentNodeId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|sourceNode
operator|!=
literal|null
operator|&&
name|sourceNode
operator|.
name|containsShard
argument_list|(
name|shardRouting
argument_list|)
assert|;
name|RoutingNode
name|routingNode
init|=
name|sourceNode
operator|.
name|getRoutingNode
argument_list|()
decl_stmt|;
name|Decision
name|canRemain
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canRemain
argument_list|(
name|shardRouting
argument_list|,
name|routingNode
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|canRemain
operator|.
name|type
argument_list|()
operator|!=
name|Decision
operator|.
name|Type
operator|.
name|NO
condition|)
block|{
return|return
name|MoveDecision
operator|.
name|stay
argument_list|(
name|canRemain
argument_list|)
return|;
block|}
name|sorter
operator|.
name|reset
argument_list|(
name|shardRouting
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
comment|/*              * the sorter holds the minimum weight node first for the shards index.              * We now walk through the nodes until we find a node to allocate the shard.              * This is not guaranteed to be balanced after this operation we still try best effort to              * allocate on the minimal eligible node.              */
name|Type
name|bestDecision
init|=
name|Type
operator|.
name|NO
decl_stmt|;
name|RoutingNode
name|targetNode
init|=
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|nodeExplanationMap
init|=
name|explain
condition|?
operator|new
name|ArrayList
argument_list|<>
argument_list|()
else|:
literal|null
decl_stmt|;
name|int
name|weightRanking
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ModelNode
name|currentNode
range|:
name|sorter
operator|.
name|modelNodes
control|)
block|{
if|if
condition|(
name|currentNode
operator|!=
name|sourceNode
condition|)
block|{
name|RoutingNode
name|target
init|=
name|currentNode
operator|.
name|getRoutingNode
argument_list|()
decl_stmt|;
comment|// don't use canRebalance as we want hard filtering rules to apply. See #17698
name|Decision
name|allocationDecision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canAllocate
argument_list|(
name|shardRouting
argument_list|,
name|target
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|explain
condition|)
block|{
name|nodeExplanationMap
operator|.
name|add
argument_list|(
operator|new
name|NodeAllocationResult
argument_list|(
name|currentNode
operator|.
name|getRoutingNode
argument_list|()
operator|.
name|node
argument_list|()
argument_list|,
name|allocationDecision
argument_list|,
operator|++
name|weightRanking
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// TODO maybe we can respect throttling here too?
if|if
condition|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|.
name|higherThan
argument_list|(
name|bestDecision
argument_list|)
condition|)
block|{
name|bestDecision
operator|=
name|allocationDecision
operator|.
name|type
argument_list|()
expr_stmt|;
if|if
condition|(
name|bestDecision
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
name|targetNode
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|explain
operator|==
literal|false
condition|)
block|{
comment|// we are not in explain mode and already have a YES decision on the best weighted node,
comment|// no need to continue iterating
break|break;
block|}
block|}
block|}
block|}
block|}
return|return
name|MoveDecision
operator|.
name|cannotRemain
argument_list|(
name|canRemain
argument_list|,
name|AllocationDecision
operator|.
name|fromDecisionType
argument_list|(
name|bestDecision
argument_list|)
argument_list|,
name|targetNode
operator|!=
literal|null
condition|?
name|targetNode
operator|.
name|node
argument_list|()
else|:
literal|null
argument_list|,
name|nodeExplanationMap
argument_list|)
return|;
block|}
comment|/**          * Builds the internal model from all shards in the given          * {@link Iterable}. All shards in the {@link Iterable} must be assigned          * to a node. This method will skip shards in the state          * {@link ShardRoutingState#RELOCATING} since each relocating shard has          * a shadow shard in the state {@link ShardRoutingState#INITIALIZING}          * on the target node which we respect during the allocation / balancing          * process. In short, this method recreates the status-quo in the cluster.          */
DECL|method|buildModelFromAssigned
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|ModelNode
argument_list|>
name|buildModelFromAssigned
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|ModelNode
argument_list|>
name|nodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|RoutingNode
name|rn
range|:
name|routingNodes
control|)
block|{
name|ModelNode
name|node
init|=
operator|new
name|ModelNode
argument_list|(
name|rn
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|put
argument_list|(
name|rn
operator|.
name|nodeId
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|rn
control|)
block|{
assert|assert
name|rn
operator|.
name|nodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
assert|;
comment|/* we skip relocating shards here since we expect an initializing shard with the same id coming in */
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|!=
name|RELOCATING
condition|)
block|{
name|node
operator|.
name|addShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to node [{}]"
argument_list|,
name|shard
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|nodes
return|;
block|}
comment|/**          * Allocates all given shards on the minimal eligible node for the shards index          * with respect to the weight function. All given shards must be unassigned.          */
DECL|method|allocateUnassigned
specifier|private
name|void
name|allocateUnassigned
parameter_list|()
block|{
name|RoutingNodes
operator|.
name|UnassignedShards
name|unassigned
init|=
name|routingNodes
operator|.
name|unassigned
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
assert|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start allocating unassigned shards"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unassigned
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return;
block|}
comment|/*              * TODO: We could be smarter here and group the shards by index and then              * use the sorter to save some iterations.              */
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
specifier|final
name|PriorityComparator
name|secondaryComparator
init|=
name|PriorityComparator
operator|.
name|getAllocationComparator
argument_list|(
name|allocation
argument_list|)
decl_stmt|;
specifier|final
name|Comparator
argument_list|<
name|ShardRouting
argument_list|>
name|comparator
init|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|o1
operator|.
name|primary
argument_list|()
operator|^
name|o2
operator|.
name|primary
argument_list|()
condition|)
block|{
return|return
name|o1
operator|.
name|primary
argument_list|()
condition|?
operator|-
literal|1
else|:
name|o2
operator|.
name|primary
argument_list|()
condition|?
literal|1
else|:
literal|0
return|;
block|}
specifier|final
name|int
name|indexCmp
decl_stmt|;
if|if
condition|(
operator|(
name|indexCmp
operator|=
name|o1
operator|.
name|getIndexName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getIndexName
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|o1
operator|.
name|getId
argument_list|()
operator|-
name|o2
operator|.
name|getId
argument_list|()
return|;
block|}
comment|// this comparator is more expensive than all the others up there
comment|// that's why it's added last even though it could be easier to read
comment|// if we'd apply it earlier. this comparator will only differentiate across
comment|// indices all shards of the same index is treated equally.
specifier|final
name|int
name|secondary
init|=
name|secondaryComparator
operator|.
name|compare
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
return|return
name|secondary
operator|==
literal|0
condition|?
name|indexCmp
else|:
name|secondary
return|;
block|}
decl_stmt|;
comment|/*              * we use 2 arrays and move replicas to the second array once we allocated an identical              * replica in the current iteration to make sure all indices get allocated in the same manner.              * The arrays are sorted by primaries first and then by index and shard ID so a 2 indices with 2 replica and 1 shard would look like:              * [(0,P,IDX1), (0,P,IDX2), (0,R,IDX1), (0,R,IDX1), (0,R,IDX2), (0,R,IDX2)]              * if we allocate for instance (0, R, IDX1) we move the second replica to the secondary array and proceed with              * the next replica. If we could not find a node to allocate (0,R,IDX1) we move all it's replicas to ignoreUnassigned.              */
name|ShardRouting
index|[]
name|primary
init|=
name|unassigned
operator|.
name|drain
argument_list|()
decl_stmt|;
name|ShardRouting
index|[]
name|secondary
init|=
operator|new
name|ShardRouting
index|[
name|primary
operator|.
name|length
index|]
decl_stmt|;
name|int
name|secondaryLength
init|=
literal|0
decl_stmt|;
name|int
name|primaryLength
init|=
name|primary
operator|.
name|length
decl_stmt|;
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|primary
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|ModelNode
argument_list|>
name|throttledNodes
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
do|do
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|primaryLength
condition|;
name|i
operator|++
control|)
block|{
name|ShardRouting
name|shard
init|=
name|primary
index|[
name|i
index|]
decl_stmt|;
name|AllocateUnassignedDecision
name|allocationDecision
init|=
name|decideAllocateUnassigned
argument_list|(
name|shard
argument_list|,
name|throttledNodes
argument_list|)
decl_stmt|;
specifier|final
name|String
name|assignedNodeId
init|=
name|allocationDecision
operator|.
name|getTargetNode
argument_list|()
operator|!=
literal|null
condition|?
name|allocationDecision
operator|.
name|getTargetNode
argument_list|()
operator|.
name|getId
argument_list|()
else|:
literal|null
decl_stmt|;
specifier|final
name|ModelNode
name|minNode
init|=
name|assignedNodeId
operator|!=
literal|null
condition|?
name|nodes
operator|.
name|get
argument_list|(
name|assignedNodeId
argument_list|)
else|:
literal|null
decl_stmt|;
if|if
condition|(
name|allocationDecision
operator|.
name|getAllocationDecision
argument_list|()
operator|==
name|AllocationDecision
operator|.
name|YES
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to [{}]"
argument_list|,
name|shard
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|long
name|shardSize
init|=
name|DiskThresholdDecider
operator|.
name|getExpectedShardSize
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
decl_stmt|;
name|shard
operator|=
name|routingNodes
operator|.
name|initializeShard
argument_list|(
name|shard
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|shardSize
argument_list|,
name|allocation
operator|.
name|changes
argument_list|()
argument_list|)
expr_stmt|;
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
comment|// copy over the same replica shards to the secondary array so they will get allocated
comment|// in a subsequent iteration, allowing replicas of other shards to be allocated first
while|while
condition|(
name|i
operator|<
name|primaryLength
operator|-
literal|1
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|primary
index|[
name|i
index|]
argument_list|,
name|primary
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|secondary
index|[
name|secondaryLength
operator|++
index|]
operator|=
name|primary
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// did *not* receive a YES decision
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No eligible node found to assign shard [{}] allocation_status [{}]"
argument_list|,
name|shard
argument_list|,
name|allocationDecision
operator|.
name|getAllocationStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minNode
operator|!=
literal|null
condition|)
block|{
comment|// throttle decision scenario
assert|assert
name|allocationDecision
operator|.
name|getAllocationStatus
argument_list|()
operator|==
name|AllocationStatus
operator|.
name|DECIDERS_THROTTLED
assert|;
specifier|final
name|long
name|shardSize
init|=
name|DiskThresholdDecider
operator|.
name|getExpectedShardSize
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
decl_stmt|;
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
operator|.
name|initialize
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|shardSize
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RoutingNode
name|node
init|=
name|minNode
operator|.
name|getRoutingNode
argument_list|()
decl_stmt|;
specifier|final
name|Decision
operator|.
name|Type
name|nodeLevelDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|node
argument_list|,
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeLevelDecision
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Can not allocate on node [{}] remove from round decision [{}]"
argument_list|,
name|node
argument_list|,
name|allocationDecision
operator|.
name|getAllocationStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
assert|assert
name|nodeLevelDecision
operator|==
name|Type
operator|.
name|NO
assert|;
name|throttledNodes
operator|.
name|add
argument_list|(
name|minNode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No Node found to assign shard [{}]"
argument_list|,
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|shard
argument_list|,
name|allocationDecision
operator|.
name|getAllocationStatus
argument_list|()
argument_list|,
name|allocation
operator|.
name|changes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
comment|// we could not allocate it and we are a replica - check if we can ignore the other replicas
while|while
condition|(
name|i
operator|<
name|primaryLength
operator|-
literal|1
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|primary
index|[
name|i
index|]
argument_list|,
name|primary
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|primary
index|[
operator|++
name|i
index|]
argument_list|,
name|allocationDecision
operator|.
name|getAllocationStatus
argument_list|()
argument_list|,
name|allocation
operator|.
name|changes
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|primaryLength
operator|=
name|secondaryLength
expr_stmt|;
name|ShardRouting
index|[]
name|tmp
init|=
name|primary
decl_stmt|;
name|primary
operator|=
name|secondary
expr_stmt|;
name|secondary
operator|=
name|tmp
expr_stmt|;
name|secondaryLength
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|primaryLength
operator|>
literal|0
condition|)
do|;
comment|// clear everything we have either added it or moved to ignoreUnassigned
block|}
comment|/**          * Make a decision for allocating an unassigned shard.  This method returns a two values in a tuple: the          * first value is the {@link Decision} taken to allocate the unassigned shard, the second value is the          * {@link ModelNode} representing the node that the shard should be assigned to.  If the decision returned          * is of type {@link Type#NO}, then the assigned node will be null.          */
DECL|method|decideAllocateUnassigned
specifier|private
name|AllocateUnassignedDecision
name|decideAllocateUnassigned
parameter_list|(
specifier|final
name|ShardRouting
name|shard
parameter_list|,
specifier|final
name|Set
argument_list|<
name|ModelNode
argument_list|>
name|throttledNodes
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|.
name|assignedToNode
argument_list|()
condition|)
block|{
comment|// we only make decisions for unassigned shards here
return|return
name|AllocateUnassignedDecision
operator|.
name|NOT_TAKEN
return|;
block|}
specifier|final
name|boolean
name|explain
init|=
name|allocation
operator|.
name|debugDecision
argument_list|()
decl_stmt|;
name|Decision
name|shardLevelDecision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardLevelDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|NO
operator|&&
name|explain
operator|==
literal|false
condition|)
block|{
comment|// NO decision for allocating the shard, irrespective of any particular node, so exit early
return|return
name|AllocateUnassignedDecision
operator|.
name|no
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_NO
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/* find an node with minimal weight we can allocate on*/
name|float
name|minWeight
init|=
name|Float
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|ModelNode
name|minNode
init|=
literal|null
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|throttledNodes
operator|.
name|size
argument_list|()
operator|>=
name|nodes
operator|.
name|size
argument_list|()
operator|&&
name|explain
operator|==
literal|false
condition|)
block|{
comment|// all nodes are throttled, so we know we won't be able to allocate this round,
comment|// so if we are not in explain mode, short circuit
return|return
name|AllocateUnassignedDecision
operator|.
name|no
argument_list|(
name|AllocationStatus
operator|.
name|DECIDERS_NO
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/* Don't iterate over an identity hashset here the              * iteration order is different for each run and makes testing hard */
name|Map
argument_list|<
name|String
argument_list|,
name|NodeAllocationResult
argument_list|>
name|nodeExplanationMap
init|=
name|explain
condition|?
operator|new
name|HashMap
argument_list|<>
argument_list|()
else|:
literal|null
decl_stmt|;
name|List
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
argument_list|>
name|nodeWeights
init|=
name|explain
condition|?
operator|new
name|ArrayList
argument_list|<>
argument_list|()
else|:
literal|null
decl_stmt|;
for|for
control|(
name|ModelNode
name|node
range|:
name|nodes
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
operator|(
name|throttledNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
operator|||
name|node
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
operator|)
operator|&&
name|explain
operator|==
literal|false
condition|)
block|{
comment|// decision is NO without needing to check anything further, so short circuit
continue|continue;
block|}
comment|// simulate weight if we would add shard to node
name|float
name|currentWeight
init|=
name|weight
operator|.
name|weightShardAdded
argument_list|(
name|this
argument_list|,
name|node
argument_list|,
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
comment|// moving the shard would not improve the balance, and we are not in explain mode, so short circuit
if|if
condition|(
name|currentWeight
operator|>
name|minWeight
operator|&&
name|explain
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
name|Decision
name|currentDecision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|node
operator|.
name|getRoutingNode
argument_list|()
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|explain
condition|)
block|{
name|nodeExplanationMap
operator|.
name|put
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|,
operator|new
name|NodeAllocationResult
argument_list|(
name|node
operator|.
name|getRoutingNode
argument_list|()
operator|.
name|node
argument_list|()
argument_list|,
name|currentDecision
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|nodeWeights
operator|.
name|add
argument_list|(
name|Tuple
operator|.
name|tuple
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|currentWeight
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|||
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
condition|)
block|{
specifier|final
name|boolean
name|updateMinNode
decl_stmt|;
if|if
condition|(
name|currentWeight
operator|==
name|minWeight
condition|)
block|{
comment|/*  we have an equal weight tie breaking:                          *  1. if one decision is YES prefer it                          *  2. prefer the node that holds the primary for this index with the next id in the ring ie.                          *  for the 3 shards 2 replica case we try to build up:                          *    1 2 0                          *    2 0 1                          *    0 1 2                          *  such that if we need to tie-break we try to prefer the node holding a shard with the minimal id greater                          *  than the id of the shard we need to assign. This works find when new indices are created since                          *  primaries are added first and we only add one shard set a time in this algorithm.                          */
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|decision
operator|.
name|type
argument_list|()
condition|)
block|{
specifier|final
name|int
name|repId
init|=
name|shard
operator|.
name|id
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nodeHigh
init|=
name|node
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minNodeHigh
init|=
name|minNode
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
name|updateMinNode
operator|=
operator|(
operator|(
operator|(
operator|(
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|>
name|repId
operator|)
operator|||
operator|(
name|nodeHigh
operator|<
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
operator|)
operator|&&
operator|(
name|nodeHigh
operator|<
name|minNodeHigh
operator|)
operator|)
operator|||
operator|(
name|nodeHigh
operator|>
name|minNodeHigh
operator|&&
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|updateMinNode
operator|=
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
expr_stmt|;
block|}
block|}
else|else
block|{
name|updateMinNode
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|updateMinNode
condition|)
block|{
name|minNode
operator|=
name|node
expr_stmt|;
name|minWeight
operator|=
name|currentWeight
expr_stmt|;
name|decision
operator|=
name|currentDecision
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|decision
operator|==
literal|null
condition|)
block|{
comment|// decision was not set and a node was not assigned, so treat it as a NO decision
name|decision
operator|=
name|Decision
operator|.
name|NO
expr_stmt|;
block|}
name|List
argument_list|<
name|NodeAllocationResult
argument_list|>
name|nodeDecisions
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|explain
condition|)
block|{
name|nodeDecisions
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
comment|// fill in the correct weight ranking, once we've been through all nodes
name|nodeWeights
operator|.
name|sort
argument_list|(
parameter_list|(
name|nodeWeight1
parameter_list|,
name|nodeWeight2
parameter_list|)
lambda|->
name|Float
operator|.
name|compare
argument_list|(
name|nodeWeight1
operator|.
name|v2
argument_list|()
argument_list|,
name|nodeWeight2
operator|.
name|v2
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|weightRanking
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Tuple
argument_list|<
name|String
argument_list|,
name|Float
argument_list|>
name|nodeWeight
range|:
name|nodeWeights
control|)
block|{
name|NodeAllocationResult
name|current
init|=
name|nodeExplanationMap
operator|.
name|get
argument_list|(
name|nodeWeight
operator|.
name|v1
argument_list|()
argument_list|)
decl_stmt|;
name|nodeDecisions
operator|.
name|add
argument_list|(
operator|new
name|NodeAllocationResult
argument_list|(
name|current
operator|.
name|getNode
argument_list|()
argument_list|,
name|current
operator|.
name|getCanAllocateDecision
argument_list|()
argument_list|,
operator|++
name|weightRanking
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|AllocateUnassignedDecision
operator|.
name|fromDecision
argument_list|(
name|decision
argument_list|,
name|minNode
operator|!=
literal|null
condition|?
name|minNode
operator|.
name|routingNode
operator|.
name|node
argument_list|()
else|:
literal|null
argument_list|,
name|nodeDecisions
argument_list|)
return|;
block|}
comment|/**          * Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the          * balance model. Iff this method returns a<code>true</code> the relocation has already been executed on the          * simulation model as well as on the cluster.          */
DECL|method|tryRelocateShard
specifier|private
name|boolean
name|tryRelocateShard
parameter_list|(
name|ModelNode
name|minNode
parameter_list|,
name|ModelNode
name|maxNode
parameter_list|,
name|String
name|idx
parameter_list|,
name|float
name|minCost
parameter_list|)
block|{
specifier|final
name|ModelIndex
name|index
init|=
name|maxNode
operator|.
name|getIndex
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Try relocating shard for index index [{}] from node [{}] to node [{}]"
argument_list|,
name|idx
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ShardRouting
name|candidate
init|=
literal|null
decl_stmt|;
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|index
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|started
argument_list|()
condition|)
block|{
comment|// skip initializing, unassigned and relocating shards we can't relocate them anyway
name|Decision
name|allocationDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|minNode
operator|.
name|getRoutingNode
argument_list|()
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|Decision
name|rebalanceDecision
init|=
name|deciders
operator|.
name|canRebalance
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|rebalanceDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|rebalanceDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|maxNode
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
condition|)
block|{
comment|// simulate moving shard from maxNode to minNode
specifier|final
name|float
name|delta
init|=
name|weight
operator|.
name|weightShardAdded
argument_list|(
name|this
argument_list|,
name|minNode
argument_list|,
name|idx
argument_list|)
operator|-
name|weight
operator|.
name|weightShardRemoved
argument_list|(
name|this
argument_list|,
name|maxNode
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|<
name|minCost
operator|||
operator|(
name|candidate
operator|!=
literal|null
operator|&&
name|delta
operator|==
name|minCost
operator|&&
name|candidate
operator|.
name|id
argument_list|()
operator|>
name|shard
operator|.
name|id
argument_list|()
operator|)
condition|)
block|{
comment|/* this last line is a tie-breaker to make the shard allocation alg deterministic                                      * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/
name|minCost
operator|=
name|delta
expr_stmt|;
name|candidate
operator|=
name|shard
expr_stmt|;
name|decision
operator|=
operator|new
name|Decision
operator|.
name|Multi
argument_list|()
operator|.
name|add
argument_list|(
name|allocationDecision
argument_list|)
operator|.
name|add
argument_list|(
name|rebalanceDecision
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|candidate
operator|!=
literal|null
condition|)
block|{
comment|/* allocate on the model even if not throttled */
name|maxNode
operator|.
name|removeShard
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|long
name|shardSize
init|=
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|candidate
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
comment|/* only allocate on the cluster if we are not throttled */
name|logger
operator|.
name|debug
argument_list|(
literal|"Relocate shard [{}] from node [{}] to node [{}]"
argument_list|,
name|candidate
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
comment|/* now allocate on the cluster */
name|minNode
operator|.
name|addShard
argument_list|(
name|routingNodes
operator|.
name|relocateShard
argument_list|(
name|candidate
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|shardSize
argument_list|,
name|allocation
operator|.
name|changes
argument_list|()
argument_list|)
operator|.
name|v1
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
assert|assert
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
assert|;
name|minNode
operator|.
name|addShard
argument_list|(
name|candidate
operator|.
name|relocate
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|shardSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|decision
operator|==
literal|null
condition|?
literal|"NO"
else|:
name|decision
operator|.
name|type
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|ModelNode
specifier|static
class|class
name|ModelNode
implements|implements
name|Iterable
argument_list|<
name|ModelIndex
argument_list|>
block|{
DECL|field|indices
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelIndex
argument_list|>
name|indices
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|numShards
specifier|private
name|int
name|numShards
init|=
literal|0
decl_stmt|;
DECL|field|routingNode
specifier|private
specifier|final
name|RoutingNode
name|routingNode
decl_stmt|;
DECL|method|ModelNode
specifier|public
name|ModelNode
parameter_list|(
name|RoutingNode
name|routingNode
parameter_list|)
block|{
name|this
operator|.
name|routingNode
operator|=
name|routingNode
expr_stmt|;
block|}
DECL|method|getIndex
specifier|public
name|ModelIndex
name|getIndex
parameter_list|(
name|String
name|indexId
parameter_list|)
block|{
return|return
name|indices
operator|.
name|get
argument_list|(
name|indexId
argument_list|)
return|;
block|}
DECL|method|getNodeId
specifier|public
name|String
name|getNodeId
parameter_list|()
block|{
return|return
name|routingNode
operator|.
name|nodeId
argument_list|()
return|;
block|}
DECL|method|getRoutingNode
specifier|public
name|RoutingNode
name|getRoutingNode
parameter_list|()
block|{
return|return
name|routingNode
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
return|return
name|numShards
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|(
name|String
name|idx
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|0
else|:
name|index
operator|.
name|numShards
argument_list|()
return|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|(
name|String
name|index
parameter_list|)
block|{
name|ModelIndex
name|idx
init|=
name|indices
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|null
condition|)
block|{
return|return
name|idx
operator|.
name|highestPrimary
argument_list|()
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|index
operator|=
operator|new
name|ModelIndex
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
name|indices
operator|.
name|put
argument_list|(
name|index
operator|.
name|getIndexId
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|index
operator|.
name|addShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|numShards
operator|++
expr_stmt|;
block|}
DECL|method|removeShard
specifier|public
name|void
name|removeShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|index
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|numShards
argument_list|()
operator|==
literal|0
condition|)
block|{
name|indices
operator|.
name|remove
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|numShards
operator|--
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Node("
argument_list|)
operator|.
name|append
argument_list|(
name|routingNode
operator|.
name|nodeId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ModelIndex
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|indices
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|getIndex
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|false
else|:
name|index
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|ModelIndex
specifier|static
specifier|final
class|class
name|ModelIndex
implements|implements
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|field|shards
specifier|private
specifier|final
name|Set
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
comment|// expect few shards of same index to be allocated on same node
DECL|field|highestPrimary
specifier|private
name|int
name|highestPrimary
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|ModelIndex
specifier|public
name|ModelIndex
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|()
block|{
if|if
condition|(
name|highestPrimary
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|maxId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|maxId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxId
argument_list|,
name|shard
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|highestPrimary
operator|=
name|maxId
return|;
block|}
return|return
name|highestPrimary
return|;
block|}
DECL|method|getIndexId
specifier|public
name|String
name|getIndexId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|shards
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|removeShard
specifier|public
name|void
name|removeShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|highestPrimary
operator|=
operator|-
literal|1
expr_stmt|;
assert|assert
name|shards
operator|.
name|contains
argument_list|(
name|shard
argument_list|)
operator|:
literal|"Shard not allocated on current node: "
operator|+
name|shard
assert|;
name|shards
operator|.
name|remove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|highestPrimary
operator|=
operator|-
literal|1
expr_stmt|;
assert|assert
operator|!
name|shards
operator|.
name|contains
argument_list|(
name|shard
argument_list|)
operator|:
literal|"Shard already allocated on current node: "
operator|+
name|shard
assert|;
name|shards
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
return|return
name|shards
operator|.
name|contains
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|NodeSorter
specifier|static
specifier|final
class|class
name|NodeSorter
extends|extends
name|IntroSorter
block|{
DECL|field|modelNodes
specifier|final
name|ModelNode
index|[]
name|modelNodes
decl_stmt|;
comment|/* the nodes weights with respect to the current weight function / index */
DECL|field|weights
specifier|final
name|float
index|[]
name|weights
decl_stmt|;
DECL|field|function
specifier|private
specifier|final
name|WeightFunction
name|function
decl_stmt|;
DECL|field|index
specifier|private
name|String
name|index
decl_stmt|;
DECL|field|balancer
specifier|private
specifier|final
name|Balancer
name|balancer
decl_stmt|;
DECL|field|pivotWeight
specifier|private
name|float
name|pivotWeight
decl_stmt|;
DECL|method|NodeSorter
specifier|public
name|NodeSorter
parameter_list|(
name|ModelNode
index|[]
name|modelNodes
parameter_list|,
name|WeightFunction
name|function
parameter_list|,
name|Balancer
name|balancer
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|balancer
expr_stmt|;
name|this
operator|.
name|modelNodes
operator|=
name|modelNodes
expr_stmt|;
name|weights
operator|=
operator|new
name|float
index|[
name|modelNodes
operator|.
name|length
index|]
expr_stmt|;
block|}
comment|/**          * Resets the sorter, recalculates the weights per node and sorts the          * nodes by weight, with minimal weight first.          */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|String
name|index
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
control|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|weight
argument_list|(
name|modelNodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sort
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|String
name|index
parameter_list|)
block|{
name|reset
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|modelNodes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|ModelNode
name|node
parameter_list|)
block|{
return|return
name|function
operator|.
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|swap
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|ModelNode
name|tmpNode
init|=
name|modelNodes
index|[
name|i
index|]
decl_stmt|;
name|modelNodes
index|[
name|i
index|]
operator|=
name|modelNodes
index|[
name|j
index|]
expr_stmt|;
name|modelNodes
index|[
name|j
index|]
operator|=
name|tmpNode
expr_stmt|;
specifier|final
name|float
name|tmpWeight
init|=
name|weights
index|[
name|i
index|]
decl_stmt|;
name|weights
index|[
name|i
index|]
operator|=
name|weights
index|[
name|j
index|]
expr_stmt|;
name|weights
index|[
name|j
index|]
operator|=
name|tmpWeight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|weights
index|[
name|i
index|]
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setPivot
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|weights
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparePivot
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|pivotWeight
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
DECL|method|delta
specifier|public
name|float
name|delta
parameter_list|()
block|{
return|return
name|weights
index|[
name|weights
operator|.
name|length
operator|-
literal|1
index|]
operator|-
name|weights
index|[
literal|0
index|]
return|;
block|}
block|}
block|}
end_class

end_unit

