begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.cluster.routing.allocation.allocator
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|allocator
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectCursor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntroSorter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|FailedRerouteAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|RoutingAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|StartedRerouteAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|AllocationDeciders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|ClusterSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|PriorityComparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
operator|.
name|RELOCATING
import|;
end_import

begin_comment
comment|/**  * The {@link BalancedShardsAllocator} re-balances the nodes allocations  * within an cluster based on a {@link WeightFunction}. The clusters balance is defined by four parameters which can be set  * in the cluster update API that allows changes in real-time:  *<ul><li><code>cluster.routing.allocation.balance.shard</code> - The<b>shard balance</b> defines the weight factor  * for shards allocated on a {@link RoutingNode}</li>  *<li><code>cluster.routing.allocation.balance.index</code> - The<b>index balance</b> defines a factor to the number  * of {@link org.elasticsearch.cluster.routing.ShardRouting}s per index allocated on a specific node</li>  *<li><code>cluster.routing.allocation.balance.threshold</code> - A<b>threshold</b> to set the minimal optimization  * value of operations that should be performed</li>  *</ul>  *<p>  * These parameters are combined in a {@link WeightFunction} that allows calculation of node weights which  * are used to re-balance shards based on global as well as per-index factors.  */
end_comment

begin_class
DECL|class|BalancedShardsAllocator
specifier|public
class|class
name|BalancedShardsAllocator
extends|extends
name|AbstractComponent
implements|implements
name|ShardsAllocator
block|{
DECL|field|INDEX_BALANCE_FACTOR_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|INDEX_BALANCE_FACTOR_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.index"
argument_list|,
literal|0.55f
argument_list|,
literal|true
argument_list|,
name|Setting
operator|.
name|Scope
operator|.
name|CLUSTER
argument_list|)
decl_stmt|;
DECL|field|SHARD_BALANCE_FACTOR_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|SHARD_BALANCE_FACTOR_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.shard"
argument_list|,
literal|0.45f
argument_list|,
literal|true
argument_list|,
name|Setting
operator|.
name|Scope
operator|.
name|CLUSTER
argument_list|)
decl_stmt|;
DECL|field|THRESHOLD_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|THRESHOLD_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.threshold"
argument_list|,
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
literal|true
argument_list|,
name|Setting
operator|.
name|Scope
operator|.
name|CLUSTER
argument_list|)
decl_stmt|;
DECL|field|weightFunction
specifier|private
specifier|volatile
name|WeightFunction
name|weightFunction
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|volatile
name|float
name|threshold
decl_stmt|;
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|this
argument_list|(
name|settings
argument_list|,
operator|new
name|ClusterSettings
argument_list|(
name|settings
argument_list|,
name|ClusterSettings
operator|.
name|BUILT_IN_CLUSTER_SETTINGS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Inject
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|ClusterSettings
name|clusterSettings
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|setWeightFunction
argument_list|(
name|INDEX_BALANCE_FACTOR_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|,
name|SHARD_BALANCE_FACTOR_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|setThreshold
argument_list|(
name|THRESHOLD_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|clusterSettings
operator|.
name|addSettingsUpdateConsumer
argument_list|(
name|INDEX_BALANCE_FACTOR_SETTING
argument_list|,
name|SHARD_BALANCE_FACTOR_SETTING
argument_list|,
name|this
operator|::
name|setWeightFunction
argument_list|)
expr_stmt|;
name|clusterSettings
operator|.
name|addSettingsUpdateConsumer
argument_list|(
name|THRESHOLD_SETTING
argument_list|,
name|this
operator|::
name|setThreshold
argument_list|)
expr_stmt|;
block|}
DECL|method|setWeightFunction
specifier|private
name|void
name|setWeightFunction
parameter_list|(
name|float
name|indexBalance
parameter_list|,
name|float
name|shardBalanceFactor
parameter_list|)
block|{
name|weightFunction
operator|=
operator|new
name|WeightFunction
argument_list|(
name|indexBalance
argument_list|,
name|shardBalanceFactor
argument_list|)
expr_stmt|;
block|}
DECL|method|setThreshold
specifier|private
name|void
name|setThreshold
parameter_list|(
name|float
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|applyStartedShards
specifier|public
name|void
name|applyStartedShards
parameter_list|(
name|StartedRerouteAllocation
name|allocation
parameter_list|)
block|{
comment|/* ONLY FOR GATEWAYS */
block|}
annotation|@
name|Override
DECL|method|applyFailedShards
specifier|public
name|void
name|applyFailedShards
parameter_list|(
name|FailedRerouteAllocation
name|allocation
parameter_list|)
block|{
comment|/* ONLY FOR GATEWAYS */
block|}
annotation|@
name|Override
DECL|method|allocateUnassigned
specifier|public
name|boolean
name|allocateUnassigned
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
return|return
name|balancer
operator|.
name|allocateUnassigned
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|rebalance
specifier|public
name|boolean
name|rebalance
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
return|return
name|balancer
operator|.
name|balance
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|move
specifier|public
name|boolean
name|move
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|RoutingNode
name|node
parameter_list|,
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
return|return
name|balancer
operator|.
name|move
argument_list|(
name|shardRouting
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/**      * Returns the currently configured delta threshold      */
DECL|method|getThreshold
specifier|public
name|float
name|getThreshold
parameter_list|()
block|{
return|return
name|threshold
return|;
block|}
comment|/**      * Returns the index related weight factor.      */
DECL|method|getIndexBalance
specifier|public
name|float
name|getIndexBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|indexBalance
return|;
block|}
comment|/**      * Returns the shard related weight factor.      */
DECL|method|getShardBalance
specifier|public
name|float
name|getShardBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|shardBalance
return|;
block|}
comment|/**      * This class is the primary weight function used to create balanced over nodes and shards in the cluster.      * Currently this function has 3 properties:      *<ul>      *<li><code>index balance</code> - balance property over shards per index</li>      *<li><code>shard balance</code> - balance property over shards per cluster</li>      *</ul>      *<p>      * Each of these properties are expressed as factor such that the properties factor defines the relative importance of the property for the      * weight function. For example if the weight function should calculate the weights only based on a global (shard) balance the index balance      * can be set to<tt>0.0</tt> and will in turn have no effect on the distribution.      *</p>      * The weight per index is calculated based on the following formula:      *<ul>      *<li>      *<code>weight<sub>index</sub>(node, index) = indexBalance * (node.numShards(index) - avgShardsPerNode(index))</code>      *</li>      *<li>      *<code>weight<sub>node</sub>(node, index) = shardBalance * (node.numShards() - avgShardsPerNode)</code>      *</li>      *</ul>      *<code>weight(node, index) = weight<sub>index</sub>(node, index) + weight<sub>node</sub>(node, index)</code>      */
DECL|class|WeightFunction
specifier|public
specifier|static
class|class
name|WeightFunction
block|{
DECL|field|indexBalance
specifier|private
specifier|final
name|float
name|indexBalance
decl_stmt|;
DECL|field|shardBalance
specifier|private
specifier|final
name|float
name|shardBalance
decl_stmt|;
DECL|field|theta
specifier|private
specifier|final
name|float
index|[]
name|theta
decl_stmt|;
DECL|method|WeightFunction
specifier|public
name|WeightFunction
parameter_list|(
name|float
name|indexBalance
parameter_list|,
name|float
name|shardBalance
parameter_list|)
block|{
name|float
name|sum
init|=
name|indexBalance
operator|+
name|shardBalance
decl_stmt|;
if|if
condition|(
name|sum
operator|<=
literal|0.0f
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Balance factors must sum to a value> 0 but was: "
operator|+
name|sum
argument_list|)
throw|;
block|}
name|theta
operator|=
operator|new
name|float
index|[]
block|{
name|shardBalance
operator|/
name|sum
block|,
name|indexBalance
operator|/
name|sum
block|}
expr_stmt|;
name|this
operator|.
name|indexBalance
operator|=
name|indexBalance
expr_stmt|;
name|this
operator|.
name|shardBalance
operator|=
name|shardBalance
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
specifier|final
name|float
name|weightShard
init|=
operator|(
name|node
operator|.
name|numShards
argument_list|()
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|()
operator|)
decl_stmt|;
specifier|final
name|float
name|weightIndex
init|=
operator|(
name|node
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|(
name|index
argument_list|)
operator|)
decl_stmt|;
assert|assert
name|theta
operator|!=
literal|null
assert|;
return|return
name|theta
index|[
literal|0
index|]
operator|*
name|weightShard
operator|+
name|theta
index|[
literal|1
index|]
operator|*
name|weightIndex
return|;
block|}
block|}
comment|/**      * An enum that donates the actual operation the {@link WeightFunction} is      * applied to.      */
DECL|enum|Operation
specifier|public
specifier|static
enum|enum
name|Operation
block|{
comment|/**          * Provided during balance operations.          */
DECL|enum constant|BALANCE
name|BALANCE
block|,
comment|/**          * Provided during initial allocation operation for unassigned shards.          */
DECL|enum constant|ALLOCATE
name|ALLOCATE
block|,
comment|/**          * Provided during move operation.          */
DECL|enum constant|MOVE
name|MOVE
block|}
comment|/**      * A {@link Balancer}      */
DECL|class|Balancer
specifier|public
specifier|static
class|class
name|Balancer
block|{
DECL|field|logger
specifier|private
specifier|final
name|ESLogger
name|logger
decl_stmt|;
DECL|field|nodes
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelNode
argument_list|>
name|nodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|indices
specifier|private
specifier|final
name|HashSet
argument_list|<
name|String
argument_list|>
name|indices
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|allocation
specifier|private
specifier|final
name|RoutingAllocation
name|allocation
decl_stmt|;
DECL|field|routingNodes
specifier|private
specifier|final
name|RoutingNodes
name|routingNodes
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|WeightFunction
name|weight
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|float
name|threshold
decl_stmt|;
DECL|field|metaData
specifier|private
specifier|final
name|MetaData
name|metaData
decl_stmt|;
DECL|field|assignedFilter
specifier|private
specifier|final
name|Predicate
argument_list|<
name|ShardRouting
argument_list|>
name|assignedFilter
init|=
name|shard
lambda|->
name|shard
operator|.
name|assignedToNode
argument_list|()
decl_stmt|;
DECL|method|Balancer
specifier|public
name|Balancer
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|RoutingAllocation
name|allocation
parameter_list|,
name|WeightFunction
name|weight
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|allocation
operator|=
name|allocation
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
name|this
operator|.
name|routingNodes
operator|=
name|allocation
operator|.
name|routingNodes
argument_list|()
expr_stmt|;
for|for
control|(
name|RoutingNode
name|node
range|:
name|routingNodes
control|)
block|{
name|nodes
operator|.
name|put
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|,
operator|new
name|ModelNode
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metaData
operator|=
name|routingNodes
operator|.
name|metaData
argument_list|()
expr_stmt|;
block|}
comment|/**          * Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.          */
DECL|method|nodesArray
specifier|private
name|ModelNode
index|[]
name|nodesArray
parameter_list|()
block|{
return|return
name|nodes
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ModelNode
index|[
name|nodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**          * Returns the average of shards per node for the given index          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|(
name|String
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|getTotalNumberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the global average of shards per node          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|totalNumberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the global average of primaries per node          */
DECL|method|avgPrimariesPerNode
specifier|public
name|float
name|avgPrimariesPerNode
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|numberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns a new {@link NodeSorter} that sorts the nodes based on their          * current weight with respect to the index passed to the sorter. The          * returned sorter is not sorted. Use {@link NodeSorter#reset(org.elasticsearch.cluster.routing.allocation.allocator.BalancedShardsAllocator.Operation, String)}          * to sort based on an index.          */
DECL|method|newNodeSorter
specifier|private
name|NodeSorter
name|newNodeSorter
parameter_list|()
block|{
return|return
operator|new
name|NodeSorter
argument_list|(
name|nodesArray
argument_list|()
argument_list|,
name|weight
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|initialize
specifier|private
name|boolean
name|initialize
parameter_list|(
name|RoutingNodes
name|routing
parameter_list|,
name|RoutingNodes
operator|.
name|UnassignedShards
name|unassigned
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start distributing Shards"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ObjectCursor
argument_list|<
name|String
argument_list|>
name|index
range|:
name|allocation
operator|.
name|routingTable
argument_list|()
operator|.
name|indicesRouting
argument_list|()
operator|.
name|keys
argument_list|()
control|)
block|{
name|indices
operator|.
name|add
argument_list|(
name|index
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
name|buildModelFromAssigned
argument_list|(
name|routing
operator|.
name|shards
argument_list|(
name|assignedFilter
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|allocateUnassigned
argument_list|(
name|unassigned
argument_list|)
return|;
block|}
DECL|method|absDelta
specifier|private
specifier|static
name|float
name|absDelta
parameter_list|(
name|float
name|lower
parameter_list|,
name|float
name|higher
parameter_list|)
block|{
assert|assert
name|higher
operator|>=
name|lower
operator|:
name|higher
operator|+
literal|" lt "
operator|+
name|lower
operator|+
literal|" but was expected to be gte"
assert|;
return|return
name|Math
operator|.
name|abs
argument_list|(
name|higher
operator|-
name|lower
argument_list|)
return|;
block|}
DECL|method|lessThan
specifier|private
specifier|static
name|boolean
name|lessThan
parameter_list|(
name|float
name|delta
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
comment|/* deltas close to the threshold are "rounded" to the threshold manually                to prevent floating point problems if the delta is very close to the                threshold ie. 1.000000002 which can trigger unnecessary balance actions*/
return|return
name|delta
operator|<=
operator|(
name|threshold
operator|+
literal|0.001f
operator|)
return|;
block|}
comment|/**          * Allocates all possible unassigned shards          * @return<code>true</code> if the current configuration has been          *         changed, otherwise<code>false</code>          */
DECL|method|allocateUnassigned
specifier|final
name|boolean
name|allocateUnassigned
parameter_list|()
block|{
return|return
name|balance
argument_list|(
literal|true
argument_list|)
return|;
block|}
comment|/**          * Balances the nodes on the cluster model according to the weight          * function. The configured threshold is the minimum delta between the          * weight of the maximum node and the minimum node according to the          * {@link WeightFunction}. This weight is calculated per index to          * distribute shards evenly per index. The balancer tries to relocate          * shards only if the delta exceeds the threshold. If the default case          * the threshold is set to<tt>1.0</tt> to enforce gaining relocation          * only, or in other words relocations that move the weight delta closer          * to<tt>0.0</tt>          *          * @return<code>true</code> if the current configuration has been          *         changed, otherwise<code>false</code>          */
DECL|method|balance
specifier|public
name|boolean
name|balance
parameter_list|()
block|{
return|return
name|balance
argument_list|(
literal|false
argument_list|)
return|;
block|}
DECL|method|balance
specifier|private
name|boolean
name|balance
parameter_list|(
name|boolean
name|onlyAssign
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|/* with no nodes this is pointless */
return|return
literal|false
return|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|onlyAssign
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start balancing cluster"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start assigning unassigned shards"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|RoutingNodes
operator|.
name|UnassignedShards
name|unassigned
init|=
name|routingNodes
operator|.
name|unassigned
argument_list|()
decl_stmt|;
name|boolean
name|changed
init|=
name|initialize
argument_list|(
name|routingNodes
argument_list|,
name|unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
name|onlyAssign
operator|==
literal|false
operator|&&
name|changed
operator|==
literal|false
operator|&&
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canRebalance
argument_list|(
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
name|NodeSorter
name|sorter
init|=
name|newNodeSorter
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|/* skip if we only have one node */
for|for
control|(
name|String
name|index
range|:
name|buildWeightOrderedIndidces
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|sorter
argument_list|)
control|)
block|{
name|sorter
operator|.
name|reset
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|final
name|float
index|[]
name|weights
init|=
name|sorter
operator|.
name|weights
decl_stmt|;
specifier|final
name|ModelNode
index|[]
name|modelNodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
name|int
name|lowIdx
init|=
literal|0
decl_stmt|;
name|int
name|highIdx
init|=
name|weights
operator|.
name|length
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|ModelNode
name|minNode
init|=
name|modelNodes
index|[
name|lowIdx
index|]
decl_stmt|;
specifier|final
name|ModelNode
name|maxNode
init|=
name|modelNodes
index|[
name|highIdx
index|]
decl_stmt|;
name|advance_range
label|:
if|if
condition|(
name|maxNode
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|final
name|float
name|delta
init|=
name|absDelta
argument_list|(
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|lessThan
argument_list|(
name|delta
argument_list|,
name|threshold
argument_list|)
condition|)
block|{
if|if
condition|(
name|lowIdx
operator|>
literal|0
operator|&&
name|highIdx
operator|-
literal|1
operator|>
literal|0
comment|// is there a chance for a higher delta?
operator|&&
operator|(
name|absDelta
argument_list|(
name|weights
index|[
literal|0
index|]
argument_list|,
name|weights
index|[
name|highIdx
operator|-
literal|1
index|]
argument_list|)
operator|>
name|threshold
operator|)
comment|// check if we need to break at all
condition|)
block|{
comment|/* This is a special case if allocations from the "heaviest" to the "lighter" nodes is not possible                                          * due to some allocation decider restrictions like zone awareness. if one zone has for instance                                          * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we                                          * can't move to the "lighter" shards since otherwise the zone would go over capacity.                                          *                                          * This break jumps straight to the condition below were we start moving from the high index towards                                          * the low index to shrink the window we are considering for balance from the other direction.                                          * (check shrinking the window from MAX to MIN)                                          * See #3580                                          */
break|break
name|advance_range
break|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|index
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
comment|/* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.                                  * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */
if|if
condition|(
name|tryRelocateShard
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|minNode
argument_list|,
name|maxNode
argument_list|,
name|index
argument_list|,
name|delta
argument_list|)
condition|)
block|{
comment|/*                                      * TODO we could be a bit smarter here, we don't need to fully sort necessarily                                      * we could just find the place to insert linearly but the win might be minor                                      * compared to the added complexity                                      */
name|weights
index|[
name|lowIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|modelNodes
index|[
name|lowIdx
index|]
argument_list|)
expr_stmt|;
name|weights
index|[
name|highIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|modelNodes
index|[
name|highIdx
index|]
argument_list|)
expr_stmt|;
name|sorter
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|weights
operator|.
name|length
argument_list|)
expr_stmt|;
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|=
name|weights
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|lowIdx
operator|<
name|highIdx
operator|-
literal|1
condition|)
block|{
comment|/* Shrinking the window from MIN to MAX                                  * we can't move from any shard from the min node lets move on to the next node                                  * and see if the threshold still holds. We either don't have any shard of this                                  * index on this node of allocation deciders prevent any relocation.*/
name|lowIdx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowIdx
operator|>
literal|0
condition|)
block|{
comment|/* Shrinking the window from MAX to MIN                                  * now we go max to min since obviously we can't move anything to the max node                                  * lets pick the next highest */
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* we are done here, we either can't relocate anymore or we are balanced */
break|break;
block|}
block|}
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
comment|/**          * This builds a initial index ordering where the indices are returned          * in most unbalanced first. We need this in order to prevent over          * allocations on added nodes from one index when the weight parameters          * for global balance overrule the index balance at an intermediate          * state. For example this can happen if we have 3 nodes and 3 indices          * with 3 shards and 1 shard. At the first stage all three nodes hold          * 2 shard for each index. now we add another node and the first index          * is balanced moving 3 two of the nodes over to the new node since it          * has no shards yet and global balance for the node is way below          * average. To re-balance we need to move shards back eventually likely          * to the nodes we relocated them from.          */
DECL|method|buildWeightOrderedIndidces
specifier|private
name|String
index|[]
name|buildWeightOrderedIndidces
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|NodeSorter
name|sorter
parameter_list|)
block|{
specifier|final
name|String
index|[]
name|indices
init|=
name|this
operator|.
name|indices
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|this
operator|.
name|indices
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
specifier|final
name|float
index|[]
name|deltas
init|=
operator|new
name|float
index|[
name|indices
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deltas
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sorter
operator|.
name|reset
argument_list|(
name|operation
argument_list|,
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|sorter
operator|.
name|delta
argument_list|()
expr_stmt|;
block|}
operator|new
name|IntroSorter
argument_list|()
block|{
name|float
name|pivotWeight
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|String
name|tmpIdx
init|=
name|indices
index|[
name|i
index|]
decl_stmt|;
name|indices
index|[
name|i
index|]
operator|=
name|indices
index|[
name|j
index|]
expr_stmt|;
name|indices
index|[
name|j
index|]
operator|=
name|tmpIdx
expr_stmt|;
specifier|final
name|float
name|tmpDelta
init|=
name|deltas
index|[
name|i
index|]
decl_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|deltas
index|[
name|j
index|]
expr_stmt|;
name|deltas
index|[
name|j
index|]
operator|=
name|tmpDelta
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|deltas
index|[
name|i
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|deltas
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|pivotWeight
argument_list|)
return|;
block|}
block|}
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|deltas
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|indices
return|;
block|}
comment|/**          * This function executes a move operation moving the given shard from          * the given node to the minimal eligible node with respect to the          * weight function. Iff the shard is moved the shard will be set to          * {@link ShardRoutingState#RELOCATING} and a shadow instance of this          * shard is created with an incremented version in the state          * {@link ShardRoutingState#INITIALIZING}.          *          * @return<code>true</code> iff the shard has successfully been moved.          */
DECL|method|move
specifier|public
name|boolean
name|move
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|RoutingNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|shard
operator|.
name|started
argument_list|()
condition|)
block|{
comment|/* with no nodes or a not started shard this is pointless */
return|return
literal|false
return|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Try moving shard [{}] from [{}]"
argument_list|,
name|shard
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RoutingNodes
operator|.
name|UnassignedShards
name|unassigned
init|=
name|routingNodes
operator|.
name|unassigned
argument_list|()
decl_stmt|;
name|boolean
name|changed
init|=
name|initialize
argument_list|(
name|routingNodes
argument_list|,
name|unassigned
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
block|{
specifier|final
name|ModelNode
name|sourceNode
init|=
name|nodes
operator|.
name|get
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|sourceNode
operator|!=
literal|null
assert|;
specifier|final
name|NodeSorter
name|sorter
init|=
name|newNodeSorter
argument_list|()
decl_stmt|;
name|sorter
operator|.
name|reset
argument_list|(
name|Operation
operator|.
name|MOVE
argument_list|,
name|shard
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ModelNode
index|[]
name|nodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
assert|assert
name|sourceNode
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
assert|;
comment|/*                  * the sorter holds the minimum weight node first for the shards index.                  * We now walk through the nodes until we find a node to allocate the shard.                  * This is not guaranteed to be balanced after this operation we still try best effort to                  * allocate on the minimal eligible node.                  */
for|for
control|(
name|ModelNode
name|currentNode
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|currentNode
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|RoutingNode
name|target
init|=
name|routingNodes
operator|.
name|node
argument_list|(
name|currentNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|Decision
name|allocationDecision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|target
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|Decision
name|rebalanceDecision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canRebalance
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|Decision
name|decision
init|=
operator|new
name|Decision
operator|.
name|Multi
argument_list|()
operator|.
name|add
argument_list|(
name|allocationDecision
argument_list|)
operator|.
name|add
argument_list|(
name|rebalanceDecision
argument_list|)
decl_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
comment|// TODO maybe we can respect throttling here too?
name|sourceNode
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|ShardRouting
name|targetRelocatingShard
init|=
name|routingNodes
operator|.
name|relocate
argument_list|(
name|shard
argument_list|,
name|target
operator|.
name|nodeId
argument_list|()
argument_list|,
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|shard
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
argument_list|)
decl_stmt|;
name|currentNode
operator|.
name|addShard
argument_list|(
name|targetRelocatingShard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Moved shard [{}] to node [{}]"
argument_list|,
name|shard
argument_list|,
name|currentNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
comment|/**          * Builds the internal model from all shards in the given          * {@link Iterable}. All shards in the {@link Iterable} must be assigned          * to a node. This method will skip shards in the state          * {@link ShardRoutingState#RELOCATING} since each relocating shard has          * a shadow shard in the state {@link ShardRoutingState#INITIALIZING}          * on the target node which we respect during the allocation / balancing          * process. In short, this method recreates the status-quo in the cluster.          */
DECL|method|buildModelFromAssigned
specifier|private
name|void
name|buildModelFromAssigned
parameter_list|(
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|)
block|{
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
control|)
block|{
assert|assert
name|shard
operator|.
name|assignedToNode
argument_list|()
assert|;
comment|/* we skip relocating shards here since we expect an initializing shard with the same id coming in */
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|RELOCATING
condition|)
block|{
continue|continue;
block|}
name|ModelNode
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|node
operator|!=
literal|null
assert|;
name|node
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|Decision
operator|.
name|single
argument_list|(
name|Type
operator|.
name|YES
argument_list|,
literal|"Already allocated on node"
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to node [{}]"
argument_list|,
name|shard
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Allocates all given shards on the minimal eligable node for the shards index          * with respect to the weight function. All given shards must be unassigned.          */
DECL|method|allocateUnassigned
specifier|private
name|boolean
name|allocateUnassigned
parameter_list|(
name|RoutingNodes
operator|.
name|UnassignedShards
name|unassigned
parameter_list|)
block|{
assert|assert
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
assert|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start allocating unassigned shards"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unassigned
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
comment|/*              * TODO: We could be smarter here and group the shards by index and then              * use the sorter to save some iterations.              */
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
specifier|final
name|PriorityComparator
name|secondaryComparator
init|=
name|PriorityComparator
operator|.
name|getAllocationComparator
argument_list|(
name|allocation
argument_list|)
decl_stmt|;
specifier|final
name|Comparator
argument_list|<
name|ShardRouting
argument_list|>
name|comparator
init|=
operator|new
name|Comparator
argument_list|<
name|ShardRouting
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|ShardRouting
name|o1
parameter_list|,
name|ShardRouting
name|o2
parameter_list|)
block|{
if|if
condition|(
name|o1
operator|.
name|primary
argument_list|()
operator|^
name|o2
operator|.
name|primary
argument_list|()
condition|)
block|{
return|return
name|o1
operator|.
name|primary
argument_list|()
condition|?
operator|-
literal|1
else|:
name|o2
operator|.
name|primary
argument_list|()
condition|?
literal|1
else|:
literal|0
return|;
block|}
specifier|final
name|int
name|indexCmp
decl_stmt|;
if|if
condition|(
operator|(
name|indexCmp
operator|=
name|o1
operator|.
name|index
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|index
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|o1
operator|.
name|getId
argument_list|()
operator|-
name|o2
operator|.
name|getId
argument_list|()
return|;
block|}
comment|// this comparator is more expensive than all the others up there
comment|// that's why it's added last even though it could be easier to read
comment|// if we'd apply it earlier. this comparator will only differentiate across
comment|// indices all shards of the same index is treated equally.
specifier|final
name|int
name|secondary
init|=
name|secondaryComparator
operator|.
name|compare
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
return|return
name|secondary
operator|==
literal|0
condition|?
name|indexCmp
else|:
name|secondary
return|;
block|}
block|}
decl_stmt|;
comment|/*              * we use 2 arrays and move replicas to the second array once we allocated an identical              * replica in the current iteration to make sure all indices get allocated in the same manner.              * The arrays are sorted by primaries first and then by index and shard ID so a 2 indices with 2 replica and 1 shard would look like:              * [(0,P,IDX1), (0,P,IDX2), (0,R,IDX1), (0,R,IDX1), (0,R,IDX2), (0,R,IDX2)]              * if we allocate for instance (0, R, IDX1) we move the second replica to the secondary array and proceed with              * the next replica. If we could not find a node to allocate (0,R,IDX1) we move all it's replicas to ingoreUnassigned.              */
name|ShardRouting
index|[]
name|primary
init|=
name|unassigned
operator|.
name|drain
argument_list|()
decl_stmt|;
name|ShardRouting
index|[]
name|secondary
init|=
operator|new
name|ShardRouting
index|[
name|primary
operator|.
name|length
index|]
decl_stmt|;
name|int
name|secondaryLength
init|=
literal|0
decl_stmt|;
name|int
name|primaryLength
init|=
name|primary
operator|.
name|length
decl_stmt|;
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|primary
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|ModelNode
argument_list|>
name|throttledNodes
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<
name|ModelNode
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
do|do
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|primaryLength
condition|;
name|i
operator|++
control|)
block|{
name|ShardRouting
name|shard
init|=
name|primary
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|boolean
name|drop
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|NO
decl_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|primaryLength
operator|-
literal|1
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|primary
index|[
name|i
index|]
argument_list|,
name|primary
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|primary
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
while|while
condition|(
name|i
operator|<
name|primaryLength
operator|-
literal|1
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|primary
index|[
name|i
index|]
argument_list|,
name|primary
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|secondary
index|[
name|secondaryLength
operator|++
index|]
operator|=
name|primary
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
assert|assert
operator|!
name|shard
operator|.
name|assignedToNode
argument_list|()
operator|:
name|shard
assert|;
comment|/* find an node with minimal weight we can allocate on*/
name|float
name|minWeight
init|=
name|Float
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|ModelNode
name|minNode
init|=
literal|null
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|throttledNodes
operator|.
name|size
argument_list|()
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|)
block|{
comment|/* Don't iterate over an identity hashset here the                          * iteration order is different for each run and makes testing hard */
for|for
control|(
name|ModelNode
name|node
range|:
name|nodes
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|throttledNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/*                              * The shard we add is removed below to simulate the                              * addition for weight calculation we use Decision.ALWAYS to                              * not violate the not null condition.                              */
if|if
condition|(
operator|!
name|node
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
condition|)
block|{
name|node
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|Decision
operator|.
name|ALWAYS
argument_list|)
expr_stmt|;
name|float
name|currentWeight
init|=
name|weight
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|ALLOCATE
argument_list|,
name|this
argument_list|,
name|node
argument_list|,
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
comment|/*                                  * Remove the shard from the node again this is only a                                  * simulation                                  */
name|Decision
name|removed
init|=
name|node
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
decl_stmt|;
assert|assert
name|removed
operator|!=
literal|null
assert|;
comment|/*                                  * Unless the operation is not providing any gains we                                  * don't check deciders                                  */
if|if
condition|(
name|currentWeight
operator|<=
name|minWeight
condition|)
block|{
name|Decision
name|currentDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|routingNodes
operator|.
name|node
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|NOUPDATE
label|:
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|||
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
condition|)
block|{
if|if
condition|(
name|currentWeight
operator|==
name|minWeight
condition|)
block|{
comment|/*  we have an equal weight tie breaking:                                              *  1. if one decision is YES prefer it                                              *  2. prefer the node that holds the primary for this index with the next id in the ring ie.                                              *  for the 3 shards 2 replica case we try to build up:                                              *    1 2 0                                              *    2 0 1                                              *    0 1 2                                              *  such that if we need to tie-break we try to prefer the node holding a shard with the minimal id greater                                              *  than the id of the shard we need to assign. This works find when new indices are created since                                              *  primaries are added first and we only add one shard set a time in this algorithm.                                              */
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|decision
operator|.
name|type
argument_list|()
condition|)
block|{
specifier|final
name|int
name|repId
init|=
name|shard
operator|.
name|id
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nodeHigh
init|=
name|node
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minNodeHigh
init|=
name|minNode
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|>
name|repId
operator|)
operator|||
operator|(
name|nodeHigh
operator|<
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
operator|)
operator|&&
operator|(
name|nodeHigh
operator|<
name|minNodeHigh
operator|)
operator|)
operator|||
operator|(
name|nodeHigh
operator|>
name|minNodeHigh
operator|&&
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
condition|)
block|{
name|minNode
operator|=
name|node
expr_stmt|;
name|minWeight
operator|=
name|currentWeight
expr_stmt|;
name|decision
operator|=
name|currentDecision
expr_stmt|;
block|}
else|else
block|{
break|break
name|NOUPDATE
break|;
block|}
block|}
elseif|else
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
break|break
name|NOUPDATE
break|;
block|}
block|}
name|minNode
operator|=
name|node
expr_stmt|;
name|minWeight
operator|=
name|currentWeight
expr_stmt|;
name|decision
operator|=
name|currentDecision
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
assert|assert
name|decision
operator|!=
literal|null
operator|&&
name|minNode
operator|!=
literal|null
operator|||
name|decision
operator|==
literal|null
operator|&&
name|minNode
operator|==
literal|null
assert|;
if|if
condition|(
name|minNode
operator|!=
literal|null
condition|)
block|{
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to [{}]"
argument_list|,
name|shard
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|routingNodes
operator|.
name|initialize
argument_list|(
name|shard
argument_list|,
name|routingNodes
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|.
name|nodeId
argument_list|()
argument_list|,
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|shard
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
continue|continue;
comment|// don't add to ignoreUnassigned
block|}
else|else
block|{
specifier|final
name|RoutingNode
name|node
init|=
name|routingNodes
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|deciders
operator|.
name|canAllocate
argument_list|(
name|node
argument_list|,
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Can not allocate on node [{}] remove from round decision [{}]"
argument_list|,
name|node
argument_list|,
name|decision
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|throttledNodes
operator|.
name|add
argument_list|(
name|minNode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No eligable node found to assign shard [{}] decision [{}]"
argument_list|,
name|shard
argument_list|,
name|decision
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No Node found to assign shard [{}]"
argument_list|,
name|shard
argument_list|)
expr_stmt|;
block|}
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
comment|// we could not allocate it and we are a replica - check if we can ignore the other replicas
while|while
condition|(
name|secondaryLength
operator|>
literal|0
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|shard
argument_list|,
name|secondary
index|[
name|secondaryLength
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|secondary
index|[
operator|--
name|secondaryLength
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|primaryLength
operator|=
name|secondaryLength
expr_stmt|;
name|ShardRouting
index|[]
name|tmp
init|=
name|primary
decl_stmt|;
name|primary
operator|=
name|secondary
expr_stmt|;
name|secondary
operator|=
name|tmp
expr_stmt|;
name|secondaryLength
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|primaryLength
operator|>
literal|0
condition|)
do|;
comment|// clear everything we have either added it or moved to ingoreUnassigned
return|return
name|changed
return|;
block|}
comment|/**          * Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the          * balance model. Iff this method returns a<code>true</code> the relocation has already been executed on the          * simulation model as well as on the cluster.          */
DECL|method|tryRelocateShard
specifier|private
name|boolean
name|tryRelocateShard
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|ModelNode
name|minNode
parameter_list|,
name|ModelNode
name|maxNode
parameter_list|,
name|String
name|idx
parameter_list|,
name|float
name|minCost
parameter_list|)
block|{
specifier|final
name|ModelIndex
name|index
init|=
name|maxNode
operator|.
name|getIndex
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Try relocating shard for index index [{}] from node [{}] to node [{}]"
argument_list|,
name|idx
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RoutingNode
name|node
init|=
name|routingNodes
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|ShardRouting
name|candidate
init|=
literal|null
decl_stmt|;
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
comment|/* make a copy since we modify this list in the loop */
specifier|final
name|ArrayList
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|index
operator|.
name|getAllShards
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|started
argument_list|()
condition|)
block|{
comment|// skip initializing, unassigned and relocating shards we can't relocate them anyway
name|Decision
name|allocationDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|node
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|Decision
name|rebalanceDecision
init|=
name|deciders
operator|.
name|canRebalance
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|rebalanceDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|rebalanceDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
condition|)
block|{
name|Decision
name|srcDecision
decl_stmt|;
if|if
condition|(
operator|(
name|srcDecision
operator|=
name|maxNode
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|srcDecision
argument_list|)
expr_stmt|;
specifier|final
name|float
name|delta
init|=
name|weight
operator|.
name|weight
argument_list|(
name|operation
argument_list|,
name|this
argument_list|,
name|minNode
argument_list|,
name|idx
argument_list|)
operator|-
name|weight
operator|.
name|weight
argument_list|(
name|operation
argument_list|,
name|this
argument_list|,
name|maxNode
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|<
name|minCost
operator|||
operator|(
name|candidate
operator|!=
literal|null
operator|&&
name|delta
operator|==
name|minCost
operator|&&
name|candidate
operator|.
name|id
argument_list|()
operator|>
name|shard
operator|.
name|id
argument_list|()
operator|)
condition|)
block|{
comment|/* this last line is a tie-breaker to make the shard allocation alg deterministic                                      * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/
name|minCost
operator|=
name|delta
expr_stmt|;
name|candidate
operator|=
name|shard
expr_stmt|;
name|decision
operator|=
operator|new
name|Decision
operator|.
name|Multi
argument_list|()
operator|.
name|add
argument_list|(
name|allocationDecision
argument_list|)
operator|.
name|add
argument_list|(
name|rebalanceDecision
argument_list|)
expr_stmt|;
block|}
name|minNode
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|maxNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|srcDecision
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|candidate
operator|!=
literal|null
condition|)
block|{
comment|/* allocate on the model even if not throttled */
name|maxNode
operator|.
name|removeShard
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|minNode
operator|.
name|addShard
argument_list|(
name|candidate
argument_list|,
name|decision
argument_list|)
expr_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
comment|/* only allocate on the cluster if we are not throttled */
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Relocate shard [{}] from node [{}] to node [{}]"
argument_list|,
name|candidate
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* now allocate on the cluster - if we are started we need to relocate the shard */
if|if
condition|(
name|candidate
operator|.
name|started
argument_list|()
condition|)
block|{
name|RoutingNode
name|lowRoutingNode
init|=
name|routingNodes
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|routingNodes
operator|.
name|relocate
argument_list|(
name|candidate
argument_list|,
name|lowRoutingNode
operator|.
name|nodeId
argument_list|()
argument_list|,
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|candidate
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|routingNodes
operator|.
name|initialize
argument_list|(
name|candidate
argument_list|,
name|routingNodes
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|.
name|nodeId
argument_list|()
argument_list|,
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|candidate
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|decision
operator|==
literal|null
condition|?
literal|"NO"
else|:
name|decision
operator|.
name|type
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|ModelNode
specifier|static
class|class
name|ModelNode
implements|implements
name|Iterable
argument_list|<
name|ModelIndex
argument_list|>
block|{
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|field|indices
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelIndex
argument_list|>
name|indices
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|/* cached stats - invalidated on add/remove and lazily calculated */
DECL|field|numShards
specifier|private
name|int
name|numShards
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|ModelNode
specifier|public
name|ModelNode
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|method|getIndex
specifier|public
name|ModelIndex
name|getIndex
parameter_list|(
name|String
name|indexId
parameter_list|)
block|{
return|return
name|indices
operator|.
name|get
argument_list|(
name|indexId
argument_list|)
return|;
block|}
DECL|method|getNodeId
specifier|public
name|String
name|getNodeId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
if|if
condition|(
name|numShards
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ModelIndex
name|index
range|:
name|indices
operator|.
name|values
argument_list|()
control|)
block|{
name|sum
operator|+=
name|index
operator|.
name|numShards
argument_list|()
expr_stmt|;
block|}
name|numShards
operator|=
name|sum
expr_stmt|;
block|}
return|return
name|numShards
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|(
name|String
name|idx
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|0
else|:
name|index
operator|.
name|numShards
argument_list|()
return|;
block|}
DECL|method|shards
specifier|public
name|Collection
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|()
block|{
name|Collection
argument_list|<
name|ShardRouting
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ModelIndex
name|index
range|:
name|indices
operator|.
name|values
argument_list|()
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|index
operator|.
name|getAllShards
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|(
name|String
name|index
parameter_list|)
block|{
name|ModelIndex
name|idx
init|=
name|indices
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|null
condition|)
block|{
return|return
name|idx
operator|.
name|highestPrimary
argument_list|()
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|Decision
name|decision
parameter_list|)
block|{
name|numShards
operator|=
operator|-
literal|1
expr_stmt|;
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|index
operator|=
operator|new
name|ModelIndex
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
name|indices
operator|.
name|put
argument_list|(
name|index
operator|.
name|getIndexId
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|index
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
block|}
DECL|method|removeShard
specifier|public
name|Decision
name|removeShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|numShards
operator|=
operator|-
literal|1
expr_stmt|;
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
name|Decision
name|removed
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|removed
operator|=
name|index
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|!=
literal|null
operator|&&
name|index
operator|.
name|numShards
argument_list|()
operator|==
literal|0
condition|)
block|{
name|indices
operator|.
name|remove
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|removed
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Node("
argument_list|)
operator|.
name|append
argument_list|(
name|id
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ModelIndex
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|indices
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|getIndex
argument_list|(
name|shard
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|false
else|:
name|index
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|ModelIndex
specifier|static
specifier|final
class|class
name|ModelIndex
block|{
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|field|shards
specifier|private
specifier|final
name|Map
argument_list|<
name|ShardRouting
argument_list|,
name|Decision
argument_list|>
name|shards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|numPrimaries
specifier|private
name|int
name|numPrimaries
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|highestPrimary
specifier|private
name|int
name|highestPrimary
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|ModelIndex
specifier|public
name|ModelIndex
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|()
block|{
if|if
condition|(
name|highestPrimary
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|maxId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|maxId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxId
argument_list|,
name|shard
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|highestPrimary
operator|=
name|maxId
return|;
block|}
return|return
name|highestPrimary
return|;
block|}
DECL|method|getIndexId
specifier|public
name|String
name|getIndexId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
DECL|method|getDecicion
specifier|public
name|Decision
name|getDecicion
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
return|return
name|shards
operator|.
name|get
argument_list|(
name|shard
argument_list|)
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getAllShards
specifier|public
name|Collection
argument_list|<
name|ShardRouting
argument_list|>
name|getAllShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|numPrimaries
specifier|public
name|int
name|numPrimaries
parameter_list|()
block|{
if|if
condition|(
name|numPrimaries
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|num
operator|++
expr_stmt|;
block|}
block|}
return|return
name|numPrimaries
operator|=
name|num
return|;
block|}
return|return
name|numPrimaries
return|;
block|}
DECL|method|removeShard
specifier|public
name|Decision
name|removeShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|highestPrimary
operator|=
name|numPrimaries
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|shards
operator|.
name|remove
argument_list|(
name|shard
argument_list|)
return|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|Decision
name|decision
parameter_list|)
block|{
name|highestPrimary
operator|=
name|numPrimaries
operator|=
operator|-
literal|1
expr_stmt|;
assert|assert
name|decision
operator|!=
literal|null
assert|;
assert|assert
operator|!
name|shards
operator|.
name|containsKey
argument_list|(
name|shard
argument_list|)
operator|:
literal|"Shard already allocated on current node: "
operator|+
name|shards
operator|.
name|get
argument_list|(
name|shard
argument_list|)
operator|+
literal|" "
operator|+
name|shard
assert|;
name|shards
operator|.
name|put
argument_list|(
name|shard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
return|return
name|shards
operator|.
name|containsKey
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|NodeSorter
specifier|static
specifier|final
class|class
name|NodeSorter
extends|extends
name|IntroSorter
block|{
DECL|field|modelNodes
specifier|final
name|ModelNode
index|[]
name|modelNodes
decl_stmt|;
comment|/* the nodes weights with respect to the current weight function / index */
DECL|field|weights
specifier|final
name|float
index|[]
name|weights
decl_stmt|;
DECL|field|function
specifier|private
specifier|final
name|WeightFunction
name|function
decl_stmt|;
DECL|field|index
specifier|private
name|String
name|index
decl_stmt|;
DECL|field|balancer
specifier|private
specifier|final
name|Balancer
name|balancer
decl_stmt|;
DECL|field|pivotWeight
specifier|private
name|float
name|pivotWeight
decl_stmt|;
DECL|method|NodeSorter
specifier|public
name|NodeSorter
parameter_list|(
name|ModelNode
index|[]
name|modelNodes
parameter_list|,
name|WeightFunction
name|function
parameter_list|,
name|Balancer
name|balancer
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|balancer
expr_stmt|;
name|this
operator|.
name|modelNodes
operator|=
name|modelNodes
expr_stmt|;
name|weights
operator|=
operator|new
name|float
index|[
name|modelNodes
operator|.
name|length
index|]
expr_stmt|;
block|}
comment|/**          * Resets the sorter, recalculates the weights per node and sorts the          * nodes by weight, with minimal weight first.          */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|String
name|index
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|weights
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|weight
argument_list|(
name|operation
argument_list|,
name|modelNodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sort
argument_list|(
literal|0
argument_list|,
name|modelNodes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|ModelNode
name|node
parameter_list|)
block|{
return|return
name|function
operator|.
name|weight
argument_list|(
name|operation
argument_list|,
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|swap
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|ModelNode
name|tmpNode
init|=
name|modelNodes
index|[
name|i
index|]
decl_stmt|;
name|modelNodes
index|[
name|i
index|]
operator|=
name|modelNodes
index|[
name|j
index|]
expr_stmt|;
name|modelNodes
index|[
name|j
index|]
operator|=
name|tmpNode
expr_stmt|;
specifier|final
name|float
name|tmpWeight
init|=
name|weights
index|[
name|i
index|]
decl_stmt|;
name|weights
index|[
name|i
index|]
operator|=
name|weights
index|[
name|j
index|]
expr_stmt|;
name|weights
index|[
name|j
index|]
operator|=
name|tmpWeight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|weights
index|[
name|i
index|]
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setPivot
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|weights
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparePivot
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|pivotWeight
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
DECL|method|delta
specifier|public
name|float
name|delta
parameter_list|()
block|{
return|return
name|weights
index|[
name|weights
operator|.
name|length
operator|-
literal|1
index|]
operator|-
name|weights
index|[
literal|0
index|]
return|;
block|}
block|}
block|}
end_class

end_unit

