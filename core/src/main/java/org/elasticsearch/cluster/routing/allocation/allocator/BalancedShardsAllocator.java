begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.cluster.routing.allocation.allocator
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|allocator
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IntroSorter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|RoutingAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|AllocationDeciders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|ClusterSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|PriorityComparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|IdentityHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
operator|.
name|RELOCATING
import|;
end_import

begin_comment
comment|/**  * The {@link BalancedShardsAllocator} re-balances the nodes allocations  * within an cluster based on a {@link WeightFunction}. The clusters balance is defined by four parameters which can be set  * in the cluster update API that allows changes in real-time:  *<ul><li><code>cluster.routing.allocation.balance.shard</code> - The<b>shard balance</b> defines the weight factor  * for shards allocated on a {@link RoutingNode}</li>  *<li><code>cluster.routing.allocation.balance.index</code> - The<b>index balance</b> defines a factor to the number  * of {@link org.elasticsearch.cluster.routing.ShardRouting}s per index allocated on a specific node</li>  *<li><code>cluster.routing.allocation.balance.threshold</code> - A<b>threshold</b> to set the minimal optimization  * value of operations that should be performed</li>  *</ul>  *<p>  * These parameters are combined in a {@link WeightFunction} that allows calculation of node weights which  * are used to re-balance shards based on global as well as per-index factors.  */
end_comment

begin_class
DECL|class|BalancedShardsAllocator
specifier|public
class|class
name|BalancedShardsAllocator
extends|extends
name|AbstractComponent
implements|implements
name|ShardsAllocator
block|{
DECL|field|INDEX_BALANCE_FACTOR_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|INDEX_BALANCE_FACTOR_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.index"
argument_list|,
literal|0.55f
argument_list|,
name|Property
operator|.
name|Dynamic
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|SHARD_BALANCE_FACTOR_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|SHARD_BALANCE_FACTOR_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.shard"
argument_list|,
literal|0.45f
argument_list|,
name|Property
operator|.
name|Dynamic
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|THRESHOLD_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Float
argument_list|>
name|THRESHOLD_SETTING
init|=
name|Setting
operator|.
name|floatSetting
argument_list|(
literal|"cluster.routing.allocation.balance.threshold"
argument_list|,
literal|1.0f
argument_list|,
literal|0.0f
argument_list|,
name|Property
operator|.
name|Dynamic
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|weightFunction
specifier|private
specifier|volatile
name|WeightFunction
name|weightFunction
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|volatile
name|float
name|threshold
decl_stmt|;
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|this
argument_list|(
name|settings
argument_list|,
operator|new
name|ClusterSettings
argument_list|(
name|settings
argument_list|,
name|ClusterSettings
operator|.
name|BUILT_IN_CLUSTER_SETTINGS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Inject
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|ClusterSettings
name|clusterSettings
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|setWeightFunction
argument_list|(
name|INDEX_BALANCE_FACTOR_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|,
name|SHARD_BALANCE_FACTOR_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|setThreshold
argument_list|(
name|THRESHOLD_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|clusterSettings
operator|.
name|addSettingsUpdateConsumer
argument_list|(
name|INDEX_BALANCE_FACTOR_SETTING
argument_list|,
name|SHARD_BALANCE_FACTOR_SETTING
argument_list|,
name|this
operator|::
name|setWeightFunction
argument_list|)
expr_stmt|;
name|clusterSettings
operator|.
name|addSettingsUpdateConsumer
argument_list|(
name|THRESHOLD_SETTING
argument_list|,
name|this
operator|::
name|setThreshold
argument_list|)
expr_stmt|;
block|}
DECL|method|setWeightFunction
specifier|private
name|void
name|setWeightFunction
parameter_list|(
name|float
name|indexBalance
parameter_list|,
name|float
name|shardBalanceFactor
parameter_list|)
block|{
name|weightFunction
operator|=
operator|new
name|WeightFunction
argument_list|(
name|indexBalance
argument_list|,
name|shardBalanceFactor
argument_list|)
expr_stmt|;
block|}
DECL|method|setThreshold
specifier|private
name|void
name|setThreshold
parameter_list|(
name|float
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|weighShard
specifier|public
name|Map
argument_list|<
name|DiscoveryNode
argument_list|,
name|Float
argument_list|>
name|weighShard
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|,
name|ShardRouting
name|shard
parameter_list|)
block|{
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
return|return
name|balancer
operator|.
name|weighShard
argument_list|(
name|shard
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|allocate
specifier|public
name|boolean
name|allocate
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
if|if
condition|(
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|/* with no nodes this is pointless */
return|return
literal|false
return|;
block|}
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
name|boolean
name|changed
init|=
name|balancer
operator|.
name|allocateUnassigned
argument_list|()
decl_stmt|;
name|changed
operator||=
name|balancer
operator|.
name|moveShards
argument_list|()
expr_stmt|;
name|changed
operator||=
name|balancer
operator|.
name|balance
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
comment|/**      * Returns the currently configured delta threshold      */
DECL|method|getThreshold
specifier|public
name|float
name|getThreshold
parameter_list|()
block|{
return|return
name|threshold
return|;
block|}
comment|/**      * Returns the index related weight factor.      */
DECL|method|getIndexBalance
specifier|public
name|float
name|getIndexBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|indexBalance
return|;
block|}
comment|/**      * Returns the shard related weight factor.      */
DECL|method|getShardBalance
specifier|public
name|float
name|getShardBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|shardBalance
return|;
block|}
comment|/**      * This class is the primary weight function used to create balanced over nodes and shards in the cluster.      * Currently this function has 3 properties:      *<ul>      *<li><code>index balance</code> - balance property over shards per index</li>      *<li><code>shard balance</code> - balance property over shards per cluster</li>      *</ul>      *<p>      * Each of these properties are expressed as factor such that the properties factor defines the relative importance of the property for the      * weight function. For example if the weight function should calculate the weights only based on a global (shard) balance the index balance      * can be set to<tt>0.0</tt> and will in turn have no effect on the distribution.      *</p>      * The weight per index is calculated based on the following formula:      *<ul>      *<li>      *<code>weight<sub>index</sub>(node, index) = indexBalance * (node.numShards(index) - avgShardsPerNode(index))</code>      *</li>      *<li>      *<code>weight<sub>node</sub>(node, index) = shardBalance * (node.numShards() - avgShardsPerNode)</code>      *</li>      *</ul>      *<code>weight(node, index) = weight<sub>index</sub>(node, index) + weight<sub>node</sub>(node, index)</code>      */
DECL|class|WeightFunction
specifier|public
specifier|static
class|class
name|WeightFunction
block|{
DECL|field|indexBalance
specifier|private
specifier|final
name|float
name|indexBalance
decl_stmt|;
DECL|field|shardBalance
specifier|private
specifier|final
name|float
name|shardBalance
decl_stmt|;
DECL|field|theta0
specifier|private
specifier|final
name|float
name|theta0
decl_stmt|;
DECL|field|theta1
specifier|private
specifier|final
name|float
name|theta1
decl_stmt|;
DECL|method|WeightFunction
specifier|public
name|WeightFunction
parameter_list|(
name|float
name|indexBalance
parameter_list|,
name|float
name|shardBalance
parameter_list|)
block|{
name|float
name|sum
init|=
name|indexBalance
operator|+
name|shardBalance
decl_stmt|;
if|if
condition|(
name|sum
operator|<=
literal|0.0f
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Balance factors must sum to a value> 0 but was: "
operator|+
name|sum
argument_list|)
throw|;
block|}
name|theta0
operator|=
name|shardBalance
operator|/
name|sum
expr_stmt|;
name|theta1
operator|=
name|indexBalance
operator|/
name|sum
expr_stmt|;
name|this
operator|.
name|indexBalance
operator|=
name|indexBalance
expr_stmt|;
name|this
operator|.
name|shardBalance
operator|=
name|shardBalance
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
return|return
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|weightShardAdded
specifier|public
name|float
name|weightShardAdded
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
return|return
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|method|weightShardRemoved
specifier|public
name|float
name|weightShardRemoved
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
return|return
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|weight
specifier|private
name|float
name|weight
parameter_list|(
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|,
name|int
name|numAdditionalShards
parameter_list|)
block|{
specifier|final
name|float
name|weightShard
init|=
name|node
operator|.
name|numShards
argument_list|()
operator|+
name|numAdditionalShards
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|()
decl_stmt|;
specifier|final
name|float
name|weightIndex
init|=
name|node
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|+
name|numAdditionalShards
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|theta0
operator|*
name|weightShard
operator|+
name|theta1
operator|*
name|weightIndex
return|;
block|}
block|}
comment|/**      * A {@link Balancer}      */
DECL|class|Balancer
specifier|public
specifier|static
class|class
name|Balancer
block|{
DECL|field|logger
specifier|private
specifier|final
name|ESLogger
name|logger
decl_stmt|;
DECL|field|nodes
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelNode
argument_list|>
name|nodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|allocation
specifier|private
specifier|final
name|RoutingAllocation
name|allocation
decl_stmt|;
DECL|field|routingNodes
specifier|private
specifier|final
name|RoutingNodes
name|routingNodes
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|WeightFunction
name|weight
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|float
name|threshold
decl_stmt|;
DECL|field|metaData
specifier|private
specifier|final
name|MetaData
name|metaData
decl_stmt|;
DECL|field|avgShardsPerNode
specifier|private
specifier|final
name|float
name|avgShardsPerNode
decl_stmt|;
DECL|method|Balancer
specifier|public
name|Balancer
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|RoutingAllocation
name|allocation
parameter_list|,
name|WeightFunction
name|weight
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|allocation
operator|=
name|allocation
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
name|this
operator|.
name|routingNodes
operator|=
name|allocation
operator|.
name|routingNodes
argument_list|()
expr_stmt|;
name|this
operator|.
name|metaData
operator|=
name|allocation
operator|.
name|metaData
argument_list|()
expr_stmt|;
name|avgShardsPerNode
operator|=
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|getTotalNumberOfShards
argument_list|()
operator|)
operator|/
name|routingNodes
operator|.
name|size
argument_list|()
expr_stmt|;
name|buildModelFromAssigned
argument_list|()
expr_stmt|;
block|}
comment|/**          * Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.          */
DECL|method|nodesArray
specifier|private
name|ModelNode
index|[]
name|nodesArray
parameter_list|()
block|{
return|return
name|nodes
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ModelNode
index|[
name|nodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**          * Returns the average of shards per node for the given index          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|(
name|String
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|getTotalNumberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the global average of shards per node          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|()
block|{
return|return
name|avgShardsPerNode
return|;
block|}
comment|/**          * Returns a new {@link NodeSorter} that sorts the nodes based on their          * current weight with respect to the index passed to the sorter. The          * returned sorter is not sorted. Use {@link NodeSorter#reset(String)}          * to sort based on an index.          */
DECL|method|newNodeSorter
specifier|private
name|NodeSorter
name|newNodeSorter
parameter_list|()
block|{
return|return
operator|new
name|NodeSorter
argument_list|(
name|nodesArray
argument_list|()
argument_list|,
name|weight
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|absDelta
specifier|private
specifier|static
name|float
name|absDelta
parameter_list|(
name|float
name|lower
parameter_list|,
name|float
name|higher
parameter_list|)
block|{
assert|assert
name|higher
operator|>=
name|lower
operator|:
name|higher
operator|+
literal|" lt "
operator|+
name|lower
operator|+
literal|" but was expected to be gte"
assert|;
return|return
name|Math
operator|.
name|abs
argument_list|(
name|higher
operator|-
name|lower
argument_list|)
return|;
block|}
DECL|method|lessThan
specifier|private
specifier|static
name|boolean
name|lessThan
parameter_list|(
name|float
name|delta
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
comment|/* deltas close to the threshold are "rounded" to the threshold manually                to prevent floating point problems if the delta is very close to the                threshold ie. 1.000000002 which can trigger unnecessary balance actions*/
return|return
name|delta
operator|<=
operator|(
name|threshold
operator|+
literal|0.001f
operator|)
return|;
block|}
comment|/**          * Balances the nodes on the cluster model according to the weight function.          * The actual balancing is delegated to {@link #balanceByWeights()}          *          * @return<code>true</code> if the current configuration has been          *         changed, otherwise<code>false</code>          */
DECL|method|balance
specifier|private
name|boolean
name|balance
parameter_list|()
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start balancing cluster"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allocation
operator|.
name|hasPendingAsyncFetch
argument_list|()
condition|)
block|{
comment|/*                  * see https://github.com/elastic/elasticsearch/issues/14387                  * if we allow rebalance operations while we are still fetching shard store data                  * we might end up with unnecessary rebalance operations which can be super confusion/frustrating                  * since once the fetches come back we might just move all the shards back again.                  * Therefore we only do a rebalance if we have fetched all information.                  */
name|logger
operator|.
name|debug
argument_list|(
literal|"skipping rebalance due to in-flight shard/store fetches"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canRebalance
argument_list|(
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"skipping rebalance as it is disabled"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|nodes
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
comment|/* skip if we only have one node */
name|logger
operator|.
name|trace
argument_list|(
literal|"skipping rebalance as single node only"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|balanceByWeights
argument_list|()
return|;
block|}
DECL|method|weighShard
specifier|public
name|Map
argument_list|<
name|DiscoveryNode
argument_list|,
name|Float
argument_list|>
name|weighShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
specifier|final
name|NodeSorter
name|sorter
init|=
name|newNodeSorter
argument_list|()
decl_stmt|;
specifier|final
name|ModelNode
index|[]
name|modelNodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
specifier|final
name|float
index|[]
name|weights
init|=
name|sorter
operator|.
name|weights
decl_stmt|;
name|buildWeightOrderedIndices
argument_list|(
name|sorter
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|DiscoveryNode
argument_list|,
name|Float
argument_list|>
name|nodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|modelNodes
operator|.
name|length
argument_list|)
decl_stmt|;
name|float
name|currentNodeWeight
init|=
literal|0.0f
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|modelNodes
index|[
name|i
index|]
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
condition|)
block|{
comment|// If a node was found with the shard, use that weight instead of 0.0
name|currentNodeWeight
operator|=
name|weights
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|float
name|delta
init|=
name|currentNodeWeight
operator|-
name|weights
index|[
name|i
index|]
decl_stmt|;
name|nodes
operator|.
name|put
argument_list|(
name|modelNodes
index|[
name|i
index|]
operator|.
name|getRoutingNode
argument_list|()
operator|.
name|node
argument_list|()
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
return|return
name|nodes
return|;
block|}
comment|/**          * Balances the nodes on the cluster model according to the weight          * function. The configured threshold is the minimum delta between the          * weight of the maximum node and the minimum node according to the          * {@link WeightFunction}. This weight is calculated per index to          * distribute shards evenly per index. The balancer tries to relocate          * shards only if the delta exceeds the threshold. If the default case          * the threshold is set to<tt>1.0</tt> to enforce gaining relocation          * only, or in other words relocations that move the weight delta closer          * to<tt>0.0</tt>          *          * @return<code>true</code> if the current configuration has been          *         changed, otherwise<code>false</code>          */
DECL|method|balanceByWeights
specifier|private
name|boolean
name|balanceByWeights
parameter_list|()
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
specifier|final
name|NodeSorter
name|sorter
init|=
name|newNodeSorter
argument_list|()
decl_stmt|;
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
specifier|final
name|ModelNode
index|[]
name|modelNodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
specifier|final
name|float
index|[]
name|weights
init|=
name|sorter
operator|.
name|weights
decl_stmt|;
for|for
control|(
name|String
name|index
range|:
name|buildWeightOrderedIndices
argument_list|(
name|sorter
argument_list|)
control|)
block|{
name|IndexMetaData
name|indexMetaData
init|=
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|// find nodes that have a shard of this index or where shards of this index are allowed to stay
comment|// move these nodes to the front of modelNodes so that we can only balance based on these nodes
name|int
name|relevantNodes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|modelNodes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|ModelNode
name|modelNode
init|=
name|modelNodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|modelNode
operator|.
name|getIndex
argument_list|(
name|index
argument_list|)
operator|!=
literal|null
operator|||
name|deciders
operator|.
name|canAllocate
argument_list|(
name|indexMetaData
argument_list|,
name|modelNode
operator|.
name|getRoutingNode
argument_list|()
argument_list|,
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|NO
condition|)
block|{
comment|// swap nodes at position i and relevantNodes
name|modelNodes
index|[
name|i
index|]
operator|=
name|modelNodes
index|[
name|relevantNodes
index|]
expr_stmt|;
name|modelNodes
index|[
name|relevantNodes
index|]
operator|=
name|modelNode
expr_stmt|;
name|relevantNodes
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|relevantNodes
operator|<
literal|2
condition|)
block|{
continue|continue;
block|}
name|sorter
operator|.
name|reset
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|relevantNodes
argument_list|)
expr_stmt|;
name|int
name|lowIdx
init|=
literal|0
decl_stmt|;
name|int
name|highIdx
init|=
name|relevantNodes
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|ModelNode
name|minNode
init|=
name|modelNodes
index|[
name|lowIdx
index|]
decl_stmt|;
specifier|final
name|ModelNode
name|maxNode
init|=
name|modelNodes
index|[
name|highIdx
index|]
decl_stmt|;
name|advance_range
label|:
if|if
condition|(
name|maxNode
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
specifier|final
name|float
name|delta
init|=
name|absDelta
argument_list|(
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|lessThan
argument_list|(
name|delta
argument_list|,
name|threshold
argument_list|)
condition|)
block|{
if|if
condition|(
name|lowIdx
operator|>
literal|0
operator|&&
name|highIdx
operator|-
literal|1
operator|>
literal|0
comment|// is there a chance for a higher delta?
operator|&&
operator|(
name|absDelta
argument_list|(
name|weights
index|[
literal|0
index|]
argument_list|,
name|weights
index|[
name|highIdx
operator|-
literal|1
index|]
argument_list|)
operator|>
name|threshold
operator|)
comment|// check if we need to break at all
condition|)
block|{
comment|/* This is a special case if allocations from the "heaviest" to the "lighter" nodes is not possible                                  * due to some allocation decider restrictions like zone awareness. if one zone has for instance                                  * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we                                  * can't move to the "lighter" shards since otherwise the zone would go over capacity.                                  *                                  * This break jumps straight to the condition below were we start moving from the high index towards                                  * the low index to shrink the window we are considering for balance from the other direction.                                  * (check shrinking the window from MAX to MIN)                                  * See #3580                                  */
break|break
name|advance_range
break|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|index
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
comment|/* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.                          * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */
if|if
condition|(
name|tryRelocateShard
argument_list|(
name|minNode
argument_list|,
name|maxNode
argument_list|,
name|index
argument_list|,
name|delta
argument_list|)
condition|)
block|{
comment|/*                              * TODO we could be a bit smarter here, we don't need to fully sort necessarily                              * we could just find the place to insert linearly but the win might be minor                              * compared to the added complexity                              */
name|weights
index|[
name|lowIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|modelNodes
index|[
name|lowIdx
index|]
argument_list|)
expr_stmt|;
name|weights
index|[
name|highIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|modelNodes
index|[
name|highIdx
index|]
argument_list|)
expr_stmt|;
name|sorter
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|relevantNodes
argument_list|)
expr_stmt|;
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|=
name|relevantNodes
operator|-
literal|1
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|lowIdx
operator|<
name|highIdx
operator|-
literal|1
condition|)
block|{
comment|/* Shrinking the window from MIN to MAX                          * we can't move from any shard from the min node lets move on to the next node                          * and see if the threshold still holds. We either don't have any shard of this                          * index on this node of allocation deciders prevent any relocation.*/
name|lowIdx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowIdx
operator|>
literal|0
condition|)
block|{
comment|/* Shrinking the window from MAX to MIN                          * now we go max to min since obviously we can't move anything to the max node                          * lets pick the next highest */
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* we are done here, we either can't relocate anymore or we are balanced */
break|break;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
comment|/**          * This builds a initial index ordering where the indices are returned          * in most unbalanced first. We need this in order to prevent over          * allocations on added nodes from one index when the weight parameters          * for global balance overrule the index balance at an intermediate          * state. For example this can happen if we have 3 nodes and 3 indices          * with 3 shards and 1 shard. At the first stage all three nodes hold          * 2 shard for each index. now we add another node and the first index          * is balanced moving 3 two of the nodes over to the new node since it          * has no shards yet and global balance for the node is way below          * average. To re-balance we need to move shards back eventually likely          * to the nodes we relocated them from.          */
DECL|method|buildWeightOrderedIndices
specifier|private
name|String
index|[]
name|buildWeightOrderedIndices
parameter_list|(
name|NodeSorter
name|sorter
parameter_list|)
block|{
specifier|final
name|String
index|[]
name|indices
init|=
name|allocation
operator|.
name|routingTable
argument_list|()
operator|.
name|indicesRouting
argument_list|()
operator|.
name|keys
argument_list|()
operator|.
name|toArray
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
specifier|final
name|float
index|[]
name|deltas
init|=
operator|new
name|float
index|[
name|indices
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deltas
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sorter
operator|.
name|reset
argument_list|(
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|sorter
operator|.
name|delta
argument_list|()
expr_stmt|;
block|}
operator|new
name|IntroSorter
argument_list|()
block|{
name|float
name|pivotWeight
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|String
name|tmpIdx
init|=
name|indices
index|[
name|i
index|]
decl_stmt|;
name|indices
index|[
name|i
index|]
operator|=
name|indices
index|[
name|j
index|]
expr_stmt|;
name|indices
index|[
name|j
index|]
operator|=
name|tmpIdx
expr_stmt|;
specifier|final
name|float
name|tmpDelta
init|=
name|deltas
index|[
name|i
index|]
decl_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|deltas
index|[
name|j
index|]
expr_stmt|;
name|deltas
index|[
name|j
index|]
operator|=
name|tmpDelta
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|deltas
index|[
name|i
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|deltas
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|pivotWeight
argument_list|)
return|;
block|}
block|}
operator|.
name|sort
argument_list|(
literal|0
argument_list|,
name|deltas
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|indices
return|;
block|}
comment|/**          * Move started shards that can not be allocated to a node anymore          *          * For each shard to be moved this function executes a move operation          * to the minimal eligible node with respect to the          * weight function. If a shard is moved the shard will be set to          * {@link ShardRoutingState#RELOCATING} and a shadow instance of this          * shard is created with an incremented version in the state          * {@link ShardRoutingState#INITIALIZING}.          *          * @return<code>true</code> if the allocation has changed, otherwise<code>false</code>          */
DECL|method|moveShards
specifier|public
name|boolean
name|moveShards
parameter_list|()
block|{
comment|// Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling
comment|// shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are
comment|// offloading the shards.
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
specifier|final
name|NodeSorter
name|sorter
init|=
name|newNodeSorter
argument_list|()
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|it
init|=
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|nodeInterleavedShardIterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ShardRouting
name|shardRouting
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
comment|// we can only move started shards...
if|if
condition|(
name|shardRouting
operator|.
name|started
argument_list|()
condition|)
block|{
specifier|final
name|ModelNode
name|sourceNode
init|=
name|nodes
operator|.
name|get
argument_list|(
name|shardRouting
operator|.
name|currentNodeId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|sourceNode
operator|!=
literal|null
operator|&&
name|sourceNode
operator|.
name|containsShard
argument_list|(
name|shardRouting
argument_list|)
assert|;
name|RoutingNode
name|routingNode
init|=
name|sourceNode
operator|.
name|getRoutingNode
argument_list|()
decl_stmt|;
name|Decision
name|decision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canRemain
argument_list|(
name|shardRouting
argument_list|,
name|routingNode
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Decision
operator|.
name|Type
operator|.
name|NO
condition|)
block|{
name|changed
operator||=
name|moveShard
argument_list|(
name|sorter
argument_list|,
name|shardRouting
argument_list|,
name|sourceNode
argument_list|,
name|routingNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
comment|/**          * Move started shard to the minimal eligible node with respect to the weight function          *          * @return<code>true</code> if the shard was moved successfully, otherwise<code>false</code>          */
DECL|method|moveShard
specifier|private
name|boolean
name|moveShard
parameter_list|(
name|NodeSorter
name|sorter
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|,
name|ModelNode
name|sourceNode
parameter_list|,
name|RoutingNode
name|routingNode
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] allocated on [{}], but can no longer be allocated on it, moving..."
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
name|routingNode
operator|.
name|node
argument_list|()
argument_list|)
expr_stmt|;
name|sorter
operator|.
name|reset
argument_list|(
name|shardRouting
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
comment|/*              * the sorter holds the minimum weight node first for the shards index.              * We now walk through the nodes until we find a node to allocate the shard.              * This is not guaranteed to be balanced after this operation we still try best effort to              * allocate on the minimal eligible node.              */
for|for
control|(
name|ModelNode
name|currentNode
range|:
name|sorter
operator|.
name|modelNodes
control|)
block|{
if|if
condition|(
name|currentNode
operator|!=
name|sourceNode
condition|)
block|{
name|RoutingNode
name|target
init|=
name|currentNode
operator|.
name|getRoutingNode
argument_list|()
decl_stmt|;
comment|// don't use canRebalance as we want hard filtering rules to apply. See #17698
name|Decision
name|allocationDecision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canAllocate
argument_list|(
name|shardRouting
argument_list|,
name|target
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
comment|// TODO maybe we can respect throttling here too?
name|sourceNode
operator|.
name|removeShard
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
name|Tuple
argument_list|<
name|ShardRouting
argument_list|,
name|ShardRouting
argument_list|>
name|relocatingShards
init|=
name|routingNodes
operator|.
name|relocate
argument_list|(
name|shardRouting
argument_list|,
name|target
operator|.
name|nodeId
argument_list|()
argument_list|,
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|shardRouting
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
argument_list|)
decl_stmt|;
name|currentNode
operator|.
name|addShard
argument_list|(
name|relocatingShards
operator|.
name|v2
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Moved shard [{}] to node [{}]"
argument_list|,
name|shardRouting
argument_list|,
name|routingNode
operator|.
name|node
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] can't move"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**          * Builds the internal model from all shards in the given          * {@link Iterable}. All shards in the {@link Iterable} must be assigned          * to a node. This method will skip shards in the state          * {@link ShardRoutingState#RELOCATING} since each relocating shard has          * a shadow shard in the state {@link ShardRoutingState#INITIALIZING}          * on the target node which we respect during the allocation / balancing          * process. In short, this method recreates the status-quo in the cluster.          */
DECL|method|buildModelFromAssigned
specifier|private
name|void
name|buildModelFromAssigned
parameter_list|()
block|{
for|for
control|(
name|RoutingNode
name|rn
range|:
name|routingNodes
control|)
block|{
name|ModelNode
name|node
init|=
operator|new
name|ModelNode
argument_list|(
name|rn
argument_list|)
decl_stmt|;
name|nodes
operator|.
name|put
argument_list|(
name|rn
operator|.
name|nodeId
argument_list|()
argument_list|,
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|rn
control|)
block|{
assert|assert
name|rn
operator|.
name|nodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
assert|;
comment|/* we skip relocating shards here since we expect an initializing shard with the same id coming in */
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|!=
name|RELOCATING
condition|)
block|{
name|node
operator|.
name|addShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to node [{}]"
argument_list|,
name|shard
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**          * Allocates all given shards on the minimal eligible node for the shards index          * with respect to the weight function. All given shards must be unassigned.          * @return<code>true</code> if the current configuration has been          *         changed, otherwise<code>false</code>          */
DECL|method|allocateUnassigned
specifier|private
name|boolean
name|allocateUnassigned
parameter_list|()
block|{
name|RoutingNodes
operator|.
name|UnassignedShards
name|unassigned
init|=
name|routingNodes
operator|.
name|unassigned
argument_list|()
decl_stmt|;
assert|assert
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
assert|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start allocating unassigned shards"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unassigned
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
comment|/*              * TODO: We could be smarter here and group the shards by index and then              * use the sorter to save some iterations.              */
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
specifier|final
name|PriorityComparator
name|secondaryComparator
init|=
name|PriorityComparator
operator|.
name|getAllocationComparator
argument_list|(
name|allocation
argument_list|)
decl_stmt|;
specifier|final
name|Comparator
argument_list|<
name|ShardRouting
argument_list|>
name|comparator
init|=
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|o1
operator|.
name|primary
argument_list|()
operator|^
name|o2
operator|.
name|primary
argument_list|()
condition|)
block|{
return|return
name|o1
operator|.
name|primary
argument_list|()
condition|?
operator|-
literal|1
else|:
name|o2
operator|.
name|primary
argument_list|()
condition|?
literal|1
else|:
literal|0
return|;
block|}
specifier|final
name|int
name|indexCmp
decl_stmt|;
if|if
condition|(
operator|(
name|indexCmp
operator|=
name|o1
operator|.
name|getIndexName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|getIndexName
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|o1
operator|.
name|getId
argument_list|()
operator|-
name|o2
operator|.
name|getId
argument_list|()
return|;
block|}
comment|// this comparator is more expensive than all the others up there
comment|// that's why it's added last even though it could be easier to read
comment|// if we'd apply it earlier. this comparator will only differentiate across
comment|// indices all shards of the same index is treated equally.
specifier|final
name|int
name|secondary
init|=
name|secondaryComparator
operator|.
name|compare
argument_list|(
name|o1
argument_list|,
name|o2
argument_list|)
decl_stmt|;
return|return
name|secondary
operator|==
literal|0
condition|?
name|indexCmp
else|:
name|secondary
return|;
block|}
decl_stmt|;
comment|/*              * we use 2 arrays and move replicas to the second array once we allocated an identical              * replica in the current iteration to make sure all indices get allocated in the same manner.              * The arrays are sorted by primaries first and then by index and shard ID so a 2 indices with 2 replica and 1 shard would look like:              * [(0,P,IDX1), (0,P,IDX2), (0,R,IDX1), (0,R,IDX1), (0,R,IDX2), (0,R,IDX2)]              * if we allocate for instance (0, R, IDX1) we move the second replica to the secondary array and proceed with              * the next replica. If we could not find a node to allocate (0,R,IDX1) we move all it's replicas to ignoreUnassigned.              */
name|ShardRouting
index|[]
name|primary
init|=
name|unassigned
operator|.
name|drain
argument_list|()
decl_stmt|;
name|ShardRouting
index|[]
name|secondary
init|=
operator|new
name|ShardRouting
index|[
name|primary
operator|.
name|length
index|]
decl_stmt|;
name|int
name|secondaryLength
init|=
literal|0
decl_stmt|;
name|int
name|primaryLength
init|=
name|primary
operator|.
name|length
decl_stmt|;
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|primary
argument_list|,
name|comparator
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|ModelNode
argument_list|>
name|throttledNodes
init|=
name|Collections
operator|.
name|newSetFromMap
argument_list|(
operator|new
name|IdentityHashMap
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
do|do
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|primaryLength
condition|;
name|i
operator|++
control|)
block|{
name|ShardRouting
name|shard
init|=
name|primary
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|boolean
name|drop
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|NO
decl_stmt|;
if|if
condition|(
name|drop
condition|)
block|{
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|primaryLength
operator|-
literal|1
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|primary
index|[
name|i
index|]
argument_list|,
name|primary
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|primary
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
while|while
condition|(
name|i
operator|<
name|primaryLength
operator|-
literal|1
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|primary
index|[
name|i
index|]
argument_list|,
name|primary
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|secondary
index|[
name|secondaryLength
operator|++
index|]
operator|=
name|primary
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
assert|assert
operator|!
name|shard
operator|.
name|assignedToNode
argument_list|()
operator|:
name|shard
assert|;
comment|/* find an node with minimal weight we can allocate on*/
name|float
name|minWeight
init|=
name|Float
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|ModelNode
name|minNode
init|=
literal|null
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|throttledNodes
operator|.
name|size
argument_list|()
operator|<
name|nodes
operator|.
name|size
argument_list|()
condition|)
block|{
comment|/* Don't iterate over an identity hashset here the                          * iteration order is different for each run and makes testing hard */
for|for
control|(
name|ModelNode
name|node
range|:
name|nodes
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|throttledNodes
operator|.
name|contains
argument_list|(
name|node
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|node
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
condition|)
block|{
comment|// simulate weight if we would add shard to node
name|float
name|currentWeight
init|=
name|weight
operator|.
name|weightShardAdded
argument_list|(
name|this
argument_list|,
name|node
argument_list|,
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
comment|/*                                  * Unless the operation is not providing any gains we                                  * don't check deciders                                  */
if|if
condition|(
name|currentWeight
operator|<=
name|minWeight
condition|)
block|{
name|Decision
name|currentDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|node
operator|.
name|getRoutingNode
argument_list|()
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|NOUPDATE
label|:
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|||
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
condition|)
block|{
if|if
condition|(
name|currentWeight
operator|==
name|minWeight
condition|)
block|{
comment|/*  we have an equal weight tie breaking:                                              *  1. if one decision is YES prefer it                                              *  2. prefer the node that holds the primary for this index with the next id in the ring ie.                                              *  for the 3 shards 2 replica case we try to build up:                                              *    1 2 0                                              *    2 0 1                                              *    0 1 2                                              *  such that if we need to tie-break we try to prefer the node holding a shard with the minimal id greater                                              *  than the id of the shard we need to assign. This works find when new indices are created since                                              *  primaries are added first and we only add one shard set a time in this algorithm.                                              */
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|decision
operator|.
name|type
argument_list|()
condition|)
block|{
specifier|final
name|int
name|repId
init|=
name|shard
operator|.
name|id
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nodeHigh
init|=
name|node
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minNodeHigh
init|=
name|minNode
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|>
name|repId
operator|)
operator|||
operator|(
name|nodeHigh
operator|<
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
operator|)
operator|&&
operator|(
name|nodeHigh
operator|<
name|minNodeHigh
operator|)
operator|)
operator|||
operator|(
name|nodeHigh
operator|>
name|minNodeHigh
operator|&&
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
condition|)
block|{
name|minNode
operator|=
name|node
expr_stmt|;
name|minWeight
operator|=
name|currentWeight
expr_stmt|;
name|decision
operator|=
name|currentDecision
expr_stmt|;
block|}
else|else
block|{
break|break
name|NOUPDATE
break|;
block|}
block|}
elseif|else
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
break|break
name|NOUPDATE
break|;
block|}
block|}
name|minNode
operator|=
name|node
expr_stmt|;
name|minWeight
operator|=
name|currentWeight
expr_stmt|;
name|decision
operator|=
name|currentDecision
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
assert|assert
name|decision
operator|!=
literal|null
operator|&&
name|minNode
operator|!=
literal|null
operator|||
name|decision
operator|==
literal|null
operator|&&
name|minNode
operator|==
literal|null
assert|;
if|if
condition|(
name|minNode
operator|!=
literal|null
condition|)
block|{
name|long
name|shardSize
init|=
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|shard
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to [{}]"
argument_list|,
name|shard
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|shard
operator|=
name|routingNodes
operator|.
name|initialize
argument_list|(
name|shard
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|shardSize
argument_list|)
expr_stmt|;
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
continue|continue;
comment|// don't add to ignoreUnassigned
block|}
else|else
block|{
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
operator|.
name|initialize
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
literal|null
argument_list|,
name|shardSize
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|RoutingNode
name|node
init|=
name|minNode
operator|.
name|getRoutingNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|deciders
operator|.
name|canAllocate
argument_list|(
name|node
argument_list|,
name|allocation
argument_list|)
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Can not allocate on node [{}] remove from round decision [{}]"
argument_list|,
name|node
argument_list|,
name|decision
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|throttledNodes
operator|.
name|add
argument_list|(
name|minNode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No eligible node found to assign shard [{}] decision [{}]"
argument_list|,
name|shard
argument_list|,
name|decision
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No Node found to assign shard [{}]"
argument_list|,
name|shard
argument_list|)
expr_stmt|;
block|}
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
comment|// we could not allocate it and we are a replica - check if we can ignore the other replicas
while|while
condition|(
name|secondaryLength
operator|>
literal|0
operator|&&
name|comparator
operator|.
name|compare
argument_list|(
name|shard
argument_list|,
name|secondary
index|[
name|secondaryLength
operator|-
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unassigned
operator|.
name|ignoreShard
argument_list|(
name|secondary
index|[
operator|--
name|secondaryLength
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|primaryLength
operator|=
name|secondaryLength
expr_stmt|;
name|ShardRouting
index|[]
name|tmp
init|=
name|primary
decl_stmt|;
name|primary
operator|=
name|secondary
expr_stmt|;
name|secondary
operator|=
name|tmp
expr_stmt|;
name|secondaryLength
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|primaryLength
operator|>
literal|0
condition|)
do|;
comment|// clear everything we have either added it or moved to ignoreUnassigned
return|return
name|changed
return|;
block|}
comment|/**          * Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the          * balance model. Iff this method returns a<code>true</code> the relocation has already been executed on the          * simulation model as well as on the cluster.          */
DECL|method|tryRelocateShard
specifier|private
name|boolean
name|tryRelocateShard
parameter_list|(
name|ModelNode
name|minNode
parameter_list|,
name|ModelNode
name|maxNode
parameter_list|,
name|String
name|idx
parameter_list|,
name|float
name|minCost
parameter_list|)
block|{
specifier|final
name|ModelIndex
name|index
init|=
name|maxNode
operator|.
name|getIndex
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Try relocating shard for index index [{}] from node [{}] to node [{}]"
argument_list|,
name|idx
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ShardRouting
name|candidate
init|=
literal|null
decl_stmt|;
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|index
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|started
argument_list|()
condition|)
block|{
comment|// skip initializing, unassigned and relocating shards we can't relocate them anyway
name|Decision
name|allocationDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|minNode
operator|.
name|getRoutingNode
argument_list|()
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|Decision
name|rebalanceDecision
init|=
name|deciders
operator|.
name|canRebalance
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|rebalanceDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|rebalanceDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|maxNode
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
condition|)
block|{
comment|// simulate moving shard from maxNode to minNode
specifier|final
name|float
name|delta
init|=
name|weight
operator|.
name|weightShardAdded
argument_list|(
name|this
argument_list|,
name|minNode
argument_list|,
name|idx
argument_list|)
operator|-
name|weight
operator|.
name|weightShardRemoved
argument_list|(
name|this
argument_list|,
name|maxNode
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|<
name|minCost
operator|||
operator|(
name|candidate
operator|!=
literal|null
operator|&&
name|delta
operator|==
name|minCost
operator|&&
name|candidate
operator|.
name|id
argument_list|()
operator|>
name|shard
operator|.
name|id
argument_list|()
operator|)
condition|)
block|{
comment|/* this last line is a tie-breaker to make the shard allocation alg deterministic                                      * otherwise we rely on the iteration order of the index.getAllShards() which is a set.*/
name|minCost
operator|=
name|delta
expr_stmt|;
name|candidate
operator|=
name|shard
expr_stmt|;
name|decision
operator|=
operator|new
name|Decision
operator|.
name|Multi
argument_list|()
operator|.
name|add
argument_list|(
name|allocationDecision
argument_list|)
operator|.
name|add
argument_list|(
name|rebalanceDecision
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|candidate
operator|!=
literal|null
condition|)
block|{
comment|/* allocate on the model even if not throttled */
name|maxNode
operator|.
name|removeShard
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|long
name|shardSize
init|=
name|allocation
operator|.
name|clusterInfo
argument_list|()
operator|.
name|getShardSize
argument_list|(
name|candidate
argument_list|,
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
comment|/* only allocate on the cluster if we are not throttled */
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Relocate shard [{}] from node [{}] to node [{}]"
argument_list|,
name|candidate
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* now allocate on the cluster */
name|minNode
operator|.
name|addShard
argument_list|(
name|routingNodes
operator|.
name|relocate
argument_list|(
name|candidate
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|shardSize
argument_list|)
operator|.
name|v1
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
assert|assert
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
assert|;
name|minNode
operator|.
name|addShard
argument_list|(
name|candidate
operator|.
name|relocate
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|shardSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Couldn't find shard to relocate from node [{}] to node [{}] allocation decision [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|decision
operator|==
literal|null
condition|?
literal|"NO"
else|:
name|decision
operator|.
name|type
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|ModelNode
specifier|static
class|class
name|ModelNode
implements|implements
name|Iterable
argument_list|<
name|ModelIndex
argument_list|>
block|{
DECL|field|indices
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelIndex
argument_list|>
name|indices
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|numShards
specifier|private
name|int
name|numShards
init|=
literal|0
decl_stmt|;
DECL|field|routingNode
specifier|private
specifier|final
name|RoutingNode
name|routingNode
decl_stmt|;
DECL|method|ModelNode
specifier|public
name|ModelNode
parameter_list|(
name|RoutingNode
name|routingNode
parameter_list|)
block|{
name|this
operator|.
name|routingNode
operator|=
name|routingNode
expr_stmt|;
block|}
DECL|method|getIndex
specifier|public
name|ModelIndex
name|getIndex
parameter_list|(
name|String
name|indexId
parameter_list|)
block|{
return|return
name|indices
operator|.
name|get
argument_list|(
name|indexId
argument_list|)
return|;
block|}
DECL|method|getNodeId
specifier|public
name|String
name|getNodeId
parameter_list|()
block|{
return|return
name|routingNode
operator|.
name|nodeId
argument_list|()
return|;
block|}
DECL|method|getRoutingNode
specifier|public
name|RoutingNode
name|getRoutingNode
parameter_list|()
block|{
return|return
name|routingNode
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
return|return
name|numShards
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|(
name|String
name|idx
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|0
else|:
name|index
operator|.
name|numShards
argument_list|()
return|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|(
name|String
name|index
parameter_list|)
block|{
name|ModelIndex
name|idx
init|=
name|indices
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|null
condition|)
block|{
return|return
name|idx
operator|.
name|highestPrimary
argument_list|()
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|index
operator|=
operator|new
name|ModelIndex
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
name|indices
operator|.
name|put
argument_list|(
name|index
operator|.
name|getIndexId
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|index
operator|.
name|addShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|numShards
operator|++
expr_stmt|;
block|}
DECL|method|removeShard
specifier|public
name|void
name|removeShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|index
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|.
name|numShards
argument_list|()
operator|==
literal|0
condition|)
block|{
name|indices
operator|.
name|remove
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|numShards
operator|--
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Node("
argument_list|)
operator|.
name|append
argument_list|(
name|routingNode
operator|.
name|nodeId
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ModelIndex
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|indices
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|getIndex
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|false
else|:
name|index
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|ModelIndex
specifier|static
specifier|final
class|class
name|ModelIndex
implements|implements
name|Iterable
argument_list|<
name|ShardRouting
argument_list|>
block|{
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|field|shards
specifier|private
specifier|final
name|Set
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
literal|4
argument_list|)
decl_stmt|;
comment|// expect few shards of same index to be allocated on same node
DECL|field|highestPrimary
specifier|private
name|int
name|highestPrimary
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|ModelIndex
specifier|public
name|ModelIndex
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|()
block|{
if|if
condition|(
name|highestPrimary
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|maxId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shards
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|maxId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxId
argument_list|,
name|shard
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|highestPrimary
operator|=
name|maxId
return|;
block|}
return|return
name|highestPrimary
return|;
block|}
DECL|method|getIndexId
specifier|public
name|String
name|getIndexId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ShardRouting
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|shards
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|removeShard
specifier|public
name|void
name|removeShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|highestPrimary
operator|=
operator|-
literal|1
expr_stmt|;
assert|assert
name|shards
operator|.
name|contains
argument_list|(
name|shard
argument_list|)
operator|:
literal|"Shard not allocated on current node: "
operator|+
name|shard
assert|;
name|shards
operator|.
name|remove
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
name|highestPrimary
operator|=
operator|-
literal|1
expr_stmt|;
assert|assert
operator|!
name|shards
operator|.
name|contains
argument_list|(
name|shard
argument_list|)
operator|:
literal|"Shard already allocated on current node: "
operator|+
name|shard
assert|;
name|shards
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|ShardRouting
name|shard
parameter_list|)
block|{
return|return
name|shards
operator|.
name|contains
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|NodeSorter
specifier|static
specifier|final
class|class
name|NodeSorter
extends|extends
name|IntroSorter
block|{
DECL|field|modelNodes
specifier|final
name|ModelNode
index|[]
name|modelNodes
decl_stmt|;
comment|/* the nodes weights with respect to the current weight function / index */
DECL|field|weights
specifier|final
name|float
index|[]
name|weights
decl_stmt|;
DECL|field|function
specifier|private
specifier|final
name|WeightFunction
name|function
decl_stmt|;
DECL|field|index
specifier|private
name|String
name|index
decl_stmt|;
DECL|field|balancer
specifier|private
specifier|final
name|Balancer
name|balancer
decl_stmt|;
DECL|field|pivotWeight
specifier|private
name|float
name|pivotWeight
decl_stmt|;
DECL|method|NodeSorter
specifier|public
name|NodeSorter
parameter_list|(
name|ModelNode
index|[]
name|modelNodes
parameter_list|,
name|WeightFunction
name|function
parameter_list|,
name|Balancer
name|balancer
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|balancer
expr_stmt|;
name|this
operator|.
name|modelNodes
operator|=
name|modelNodes
expr_stmt|;
name|weights
operator|=
operator|new
name|float
index|[
name|modelNodes
operator|.
name|length
index|]
expr_stmt|;
block|}
comment|/**          * Resets the sorter, recalculates the weights per node and sorts the          * nodes by weight, with minimal weight first.          */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|String
name|index
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
control|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|weight
argument_list|(
name|modelNodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sort
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|String
name|index
parameter_list|)
block|{
name|reset
argument_list|(
name|index
argument_list|,
literal|0
argument_list|,
name|modelNodes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|ModelNode
name|node
parameter_list|)
block|{
return|return
name|function
operator|.
name|weight
argument_list|(
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|swap
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|ModelNode
name|tmpNode
init|=
name|modelNodes
index|[
name|i
index|]
decl_stmt|;
name|modelNodes
index|[
name|i
index|]
operator|=
name|modelNodes
index|[
name|j
index|]
expr_stmt|;
name|modelNodes
index|[
name|j
index|]
operator|=
name|tmpNode
expr_stmt|;
specifier|final
name|float
name|tmpWeight
init|=
name|weights
index|[
name|i
index|]
decl_stmt|;
name|weights
index|[
name|i
index|]
operator|=
name|weights
index|[
name|j
index|]
expr_stmt|;
name|weights
index|[
name|j
index|]
operator|=
name|tmpWeight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|weights
index|[
name|i
index|]
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setPivot
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|weights
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparePivot
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|pivotWeight
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
DECL|method|delta
specifier|public
name|float
name|delta
parameter_list|()
block|{
return|return
name|weights
index|[
name|weights
operator|.
name|length
operator|-
literal|1
index|]
operator|-
name|weights
index|[
literal|0
index|]
return|;
block|}
block|}
block|}
end_class

end_unit

