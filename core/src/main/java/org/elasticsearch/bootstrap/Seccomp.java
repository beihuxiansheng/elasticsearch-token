begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.bootstrap
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|bootstrap
package|;
end_package

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Library
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Memory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Native
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|NativeLong
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Pointer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Structure
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|ptr
operator|.
name|PointerByReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|Loggers
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteOrder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Installs a limited form of secure computing mode,  * to filters system calls to block process execution.  *<p>  * This is supported on Linux, Solaris, FreeBSD, OpenBSD, Mac OS X, and Windows.  *<p>  * On Linux it currently supports amd64 and i386 architectures, requires Linux kernel 3.5 or above, and requires  * {@code CONFIG_SECCOMP} and {@code CONFIG_SECCOMP_FILTER} compiled into the kernel.  *<p>  * On Linux BPF Filters are installed using either {@code seccomp(2)} (3.17+) or {@code prctl(2)} (3.5+). {@code seccomp(2)}  * is preferred, as it allows filters to be applied to any existing threads in the process, and one motivation  * here is to protect against bugs in the JVM. Otherwise, code will fall back to the {@code prctl(2)} method  * which will at least protect elasticsearch application threads.  *<p>  * Linux BPF filters will return {@code EACCES} (Access Denied) for the following system calls:  *<ul>  *<li>{@code execve}</li>  *<li>{@code fork}</li>  *<li>{@code vfork}</li>  *<li>{@code execveat}</li>  *</ul>  *<p>  * On Solaris 10 or higher, the following privileges are dropped with {@code priv_set(3C)}:  *<ul>  *<li>{@code PRIV_PROC_FORK}</li>  *<li>{@code PRIV_PROC_EXEC}</li>  *</ul>  *<p>  * On BSD systems, process creation is restricted with {@code setrlimit(RLIMIT_NPROC)}.  *<p>  * On Mac OS X Leopard or above, a custom {@code sandbox(7)} ("Seatbelt") profile is installed that  * denies the following rules:  *<ul>  *<li>{@code process-fork}</li>  *<li>{@code process-exec}</li>  *</ul>  *<p>  * On Windows, process creation is restricted with {@code SetInformationJobObject/ActiveProcessLimit}.  *<p>  * This is not intended as a sandbox. It is another level of security, mostly intended to annoy  * security researchers and make their lives more difficult in achieving "remote execution" exploits.  * @see<a href="http://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt">  *      http://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt</a>  * @see<a href="https://reverse.put.as/wp-content/uploads/2011/06/The-Apple-Sandbox-BHDC2011-Paper.pdf">  *      https://reverse.put.as/wp-content/uploads/2011/06/The-Apple-Sandbox-BHDC2011-Paper.pdf</a>  * @see<a href="https://docs.oracle.com/cd/E23824_01/html/821-1456/prbac-2.html">  *      https://docs.oracle.com/cd/E23824_01/html/821-1456/prbac-2.html</a>  */
end_comment

begin_comment
comment|// not an example of how to write code!!!
end_comment

begin_class
DECL|class|Seccomp
specifier|final
class|class
name|Seccomp
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|ESLogger
name|logger
init|=
name|Loggers
operator|.
name|getLogger
argument_list|(
name|Seccomp
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// Linux implementation, based on seccomp(2) or prctl(2) with bpf filtering
comment|/** Access to non-standard Linux libc methods */
DECL|interface|LinuxLibrary
specifier|static
interface|interface
name|LinuxLibrary
extends|extends
name|Library
block|{
comment|/**          * maps to prctl(2)          */
DECL|method|prctl
name|int
name|prctl
parameter_list|(
name|int
name|option
parameter_list|,
name|NativeLong
name|arg2
parameter_list|,
name|NativeLong
name|arg3
parameter_list|,
name|NativeLong
name|arg4
parameter_list|,
name|NativeLong
name|arg5
parameter_list|)
function_decl|;
comment|/**          * used to call seccomp(2), its too new...          * this is the only way, DON'T use it on some other architecture unless you know wtf you are doing          */
DECL|method|syscall
name|NativeLong
name|syscall
parameter_list|(
name|NativeLong
name|number
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|// null if unavailable or something goes wrong.
DECL|field|linux_libc
specifier|private
specifier|static
specifier|final
name|LinuxLibrary
name|linux_libc
decl_stmt|;
static|static
block|{
name|LinuxLibrary
name|lib
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|Constants
operator|.
name|LINUX
condition|)
block|{
try|try
block|{
name|lib
operator|=
operator|(
name|LinuxLibrary
operator|)
name|Native
operator|.
name|loadLibrary
argument_list|(
literal|"c"
argument_list|,
name|LinuxLibrary
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsatisfiedLinkError
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"unable to link C library. native methods (seccomp) will be disabled."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|linux_libc
operator|=
name|lib
expr_stmt|;
block|}
comment|/** the preferred method is seccomp(2), since we can apply to all threads of the process */
DECL|field|SECCOMP_SET_MODE_FILTER
specifier|static
specifier|final
name|int
name|SECCOMP_SET_MODE_FILTER
init|=
literal|1
decl_stmt|;
comment|// since Linux 3.17
DECL|field|SECCOMP_FILTER_FLAG_TSYNC
specifier|static
specifier|final
name|int
name|SECCOMP_FILTER_FLAG_TSYNC
init|=
literal|1
decl_stmt|;
comment|// since Linux 3.17
comment|/** otherwise, we can use prctl(2), which will at least protect ES application threads */
DECL|field|PR_GET_NO_NEW_PRIVS
specifier|static
specifier|final
name|int
name|PR_GET_NO_NEW_PRIVS
init|=
literal|39
decl_stmt|;
comment|// since Linux 3.5
DECL|field|PR_SET_NO_NEW_PRIVS
specifier|static
specifier|final
name|int
name|PR_SET_NO_NEW_PRIVS
init|=
literal|38
decl_stmt|;
comment|// since Linux 3.5
DECL|field|PR_GET_SECCOMP
specifier|static
specifier|final
name|int
name|PR_GET_SECCOMP
init|=
literal|21
decl_stmt|;
comment|// since Linux 2.6.23
DECL|field|PR_SET_SECCOMP
specifier|static
specifier|final
name|int
name|PR_SET_SECCOMP
init|=
literal|22
decl_stmt|;
comment|// since Linux 2.6.23
DECL|field|SECCOMP_MODE_FILTER
specifier|static
specifier|final
name|long
name|SECCOMP_MODE_FILTER
init|=
literal|2
decl_stmt|;
comment|// since Linux Linux 3.5
comment|/** corresponds to struct sock_filter */
DECL|class|SockFilter
specifier|static
specifier|final
class|class
name|SockFilter
block|{
DECL|field|code
name|short
name|code
decl_stmt|;
comment|// insn
DECL|field|jt
name|byte
name|jt
decl_stmt|;
comment|// number of insn to jump (skip) if true
DECL|field|jf
name|byte
name|jf
decl_stmt|;
comment|// number of insn to jump (skip) if false
DECL|field|k
name|int
name|k
decl_stmt|;
comment|// additional data
DECL|method|SockFilter
name|SockFilter
parameter_list|(
name|short
name|code
parameter_list|,
name|byte
name|jt
parameter_list|,
name|byte
name|jf
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|this
operator|.
name|jt
operator|=
name|jt
expr_stmt|;
name|this
operator|.
name|jf
operator|=
name|jf
expr_stmt|;
name|this
operator|.
name|k
operator|=
name|k
expr_stmt|;
block|}
block|}
comment|/** corresponds to struct sock_fprog */
DECL|class|SockFProg
specifier|public
specifier|static
specifier|final
class|class
name|SockFProg
extends|extends
name|Structure
implements|implements
name|Structure
operator|.
name|ByReference
block|{
DECL|field|len
specifier|public
name|short
name|len
decl_stmt|;
comment|// number of filters
DECL|field|filter
specifier|public
name|Pointer
name|filter
decl_stmt|;
comment|// filters
DECL|method|SockFProg
specifier|public
name|SockFProg
parameter_list|(
name|SockFilter
name|filters
index|[]
parameter_list|)
block|{
name|len
operator|=
operator|(
name|short
operator|)
name|filters
operator|.
name|length
expr_stmt|;
comment|// serialize struct sock_filter * explicitly, its less confusing than the JNA magic we would need
name|Memory
name|filter
init|=
operator|new
name|Memory
argument_list|(
name|len
operator|*
literal|8
argument_list|)
decl_stmt|;
name|ByteBuffer
name|bbuf
init|=
name|filter
operator|.
name|getByteBuffer
argument_list|(
literal|0
argument_list|,
name|len
operator|*
literal|8
argument_list|)
decl_stmt|;
name|bbuf
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|nativeOrder
argument_list|()
argument_list|)
expr_stmt|;
comment|// little endian
for|for
control|(
name|SockFilter
name|f
range|:
name|filters
control|)
block|{
name|bbuf
operator|.
name|putShort
argument_list|(
name|f
operator|.
name|code
argument_list|)
expr_stmt|;
name|bbuf
operator|.
name|put
argument_list|(
name|f
operator|.
name|jt
argument_list|)
expr_stmt|;
name|bbuf
operator|.
name|put
argument_list|(
name|f
operator|.
name|jf
argument_list|)
expr_stmt|;
name|bbuf
operator|.
name|putInt
argument_list|(
name|f
operator|.
name|k
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFieldOrder
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getFieldOrder
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"len"
block|,
literal|"filter"
block|}
argument_list|)
return|;
block|}
block|}
comment|// BPF "macros" and constants
DECL|field|BPF_LD
specifier|static
specifier|final
name|int
name|BPF_LD
init|=
literal|0x00
decl_stmt|;
DECL|field|BPF_W
specifier|static
specifier|final
name|int
name|BPF_W
init|=
literal|0x00
decl_stmt|;
DECL|field|BPF_ABS
specifier|static
specifier|final
name|int
name|BPF_ABS
init|=
literal|0x20
decl_stmt|;
DECL|field|BPF_JMP
specifier|static
specifier|final
name|int
name|BPF_JMP
init|=
literal|0x05
decl_stmt|;
DECL|field|BPF_JEQ
specifier|static
specifier|final
name|int
name|BPF_JEQ
init|=
literal|0x10
decl_stmt|;
DECL|field|BPF_JGE
specifier|static
specifier|final
name|int
name|BPF_JGE
init|=
literal|0x30
decl_stmt|;
DECL|field|BPF_JGT
specifier|static
specifier|final
name|int
name|BPF_JGT
init|=
literal|0x20
decl_stmt|;
DECL|field|BPF_RET
specifier|static
specifier|final
name|int
name|BPF_RET
init|=
literal|0x06
decl_stmt|;
DECL|field|BPF_K
specifier|static
specifier|final
name|int
name|BPF_K
init|=
literal|0x00
decl_stmt|;
DECL|method|BPF_STMT
specifier|static
name|SockFilter
name|BPF_STMT
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|k
parameter_list|)
block|{
return|return
operator|new
name|SockFilter
argument_list|(
operator|(
name|short
operator|)
name|code
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
name|k
argument_list|)
return|;
block|}
DECL|method|BPF_JUMP
specifier|static
name|SockFilter
name|BPF_JUMP
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|k
parameter_list|,
name|int
name|jt
parameter_list|,
name|int
name|jf
parameter_list|)
block|{
return|return
operator|new
name|SockFilter
argument_list|(
operator|(
name|short
operator|)
name|code
argument_list|,
operator|(
name|byte
operator|)
name|jt
argument_list|,
operator|(
name|byte
operator|)
name|jf
argument_list|,
name|k
argument_list|)
return|;
block|}
DECL|field|SECCOMP_RET_ERRNO
specifier|static
specifier|final
name|int
name|SECCOMP_RET_ERRNO
init|=
literal|0x00050000
decl_stmt|;
DECL|field|SECCOMP_RET_DATA
specifier|static
specifier|final
name|int
name|SECCOMP_RET_DATA
init|=
literal|0x0000FFFF
decl_stmt|;
DECL|field|SECCOMP_RET_ALLOW
specifier|static
specifier|final
name|int
name|SECCOMP_RET_ALLOW
init|=
literal|0x7FFF0000
decl_stmt|;
comment|// some errno constants for error checking/handling
DECL|field|EACCES
specifier|static
specifier|final
name|int
name|EACCES
init|=
literal|0x0D
decl_stmt|;
DECL|field|EFAULT
specifier|static
specifier|final
name|int
name|EFAULT
init|=
literal|0x0E
decl_stmt|;
DECL|field|EINVAL
specifier|static
specifier|final
name|int
name|EINVAL
init|=
literal|0x16
decl_stmt|;
DECL|field|ENOSYS
specifier|static
specifier|final
name|int
name|ENOSYS
init|=
literal|0x26
decl_stmt|;
comment|// offsets that our BPF checks
comment|// check with offsetof() when adding a new arch, move to Arch if different.
DECL|field|SECCOMP_DATA_NR_OFFSET
specifier|static
specifier|final
name|int
name|SECCOMP_DATA_NR_OFFSET
init|=
literal|0x00
decl_stmt|;
DECL|field|SECCOMP_DATA_ARCH_OFFSET
specifier|static
specifier|final
name|int
name|SECCOMP_DATA_ARCH_OFFSET
init|=
literal|0x04
decl_stmt|;
DECL|class|Arch
specifier|static
class|class
name|Arch
block|{
comment|/** AUDIT_ARCH_XXX constant from linux/audit.h */
DECL|field|audit
specifier|final
name|int
name|audit
decl_stmt|;
comment|/** syscall limit (necessary for blacklisting on amd64, to ban 32-bit syscalls) */
DECL|field|limit
specifier|final
name|int
name|limit
decl_stmt|;
comment|/** __NR_fork */
DECL|field|fork
specifier|final
name|int
name|fork
decl_stmt|;
comment|/** __NR_vfork */
DECL|field|vfork
specifier|final
name|int
name|vfork
decl_stmt|;
comment|/** __NR_execve */
DECL|field|execve
specifier|final
name|int
name|execve
decl_stmt|;
comment|/**  __NR_execveat */
DECL|field|execveat
specifier|final
name|int
name|execveat
decl_stmt|;
comment|/** __NR_seccomp */
DECL|field|seccomp
specifier|final
name|int
name|seccomp
decl_stmt|;
DECL|method|Arch
name|Arch
parameter_list|(
name|int
name|audit
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
name|fork
parameter_list|,
name|int
name|vfork
parameter_list|,
name|int
name|execve
parameter_list|,
name|int
name|execveat
parameter_list|,
name|int
name|seccomp
parameter_list|)
block|{
name|this
operator|.
name|audit
operator|=
name|audit
expr_stmt|;
name|this
operator|.
name|limit
operator|=
name|limit
expr_stmt|;
name|this
operator|.
name|fork
operator|=
name|fork
expr_stmt|;
name|this
operator|.
name|vfork
operator|=
name|vfork
expr_stmt|;
name|this
operator|.
name|execve
operator|=
name|execve
expr_stmt|;
name|this
operator|.
name|execveat
operator|=
name|execveat
expr_stmt|;
name|this
operator|.
name|seccomp
operator|=
name|seccomp
expr_stmt|;
block|}
block|}
comment|/** supported architectures map keyed by os.arch */
DECL|field|ARCHITECTURES
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Arch
argument_list|>
name|ARCHITECTURES
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Arch
argument_list|>
name|m
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"amd64"
argument_list|,
operator|new
name|Arch
argument_list|(
literal|0xC000003E
argument_list|,
literal|0x3FFFFFFF
argument_list|,
literal|57
argument_list|,
literal|58
argument_list|,
literal|59
argument_list|,
literal|322
argument_list|,
literal|317
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|put
argument_list|(
literal|"i386"
argument_list|,
operator|new
name|Arch
argument_list|(
literal|0x40000003
argument_list|,
literal|0xFFFFFFFF
argument_list|,
literal|2
argument_list|,
literal|190
argument_list|,
literal|11
argument_list|,
literal|358
argument_list|,
literal|354
argument_list|)
argument_list|)
expr_stmt|;
name|ARCHITECTURES
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/** invokes prctl() from linux libc library */
DECL|method|linux_prctl
specifier|private
specifier|static
name|int
name|linux_prctl
parameter_list|(
name|int
name|option
parameter_list|,
name|long
name|arg2
parameter_list|,
name|long
name|arg3
parameter_list|,
name|long
name|arg4
parameter_list|,
name|long
name|arg5
parameter_list|)
block|{
return|return
name|linux_libc
operator|.
name|prctl
argument_list|(
name|option
argument_list|,
operator|new
name|NativeLong
argument_list|(
name|arg2
argument_list|)
argument_list|,
operator|new
name|NativeLong
argument_list|(
name|arg3
argument_list|)
argument_list|,
operator|new
name|NativeLong
argument_list|(
name|arg4
argument_list|)
argument_list|,
operator|new
name|NativeLong
argument_list|(
name|arg5
argument_list|)
argument_list|)
return|;
block|}
comment|/** invokes syscall() from linux libc library */
DECL|method|linux_syscall
specifier|private
specifier|static
name|long
name|linux_syscall
parameter_list|(
name|long
name|number
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
block|{
return|return
name|linux_libc
operator|.
name|syscall
argument_list|(
operator|new
name|NativeLong
argument_list|(
name|number
argument_list|)
argument_list|,
name|args
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
comment|/** try to install our BPF filters via seccomp() or prctl() to block execution */
DECL|method|linuxImpl
specifier|private
specifier|static
name|int
name|linuxImpl
parameter_list|()
block|{
comment|// first be defensive: we can give nice errors this way, at the very least.
comment|// also, some of these security features get backported to old versions, checking kernel version here is a big no-no!
specifier|final
name|Arch
name|arch
init|=
name|ARCHITECTURES
operator|.
name|get
argument_list|(
name|Constants
operator|.
name|OS_ARCH
argument_list|)
decl_stmt|;
name|boolean
name|supported
init|=
name|Constants
operator|.
name|LINUX
operator|&&
name|arch
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|supported
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: '"
operator|+
name|Constants
operator|.
name|OS_ARCH
operator|+
literal|"' architecture unsupported"
argument_list|)
throw|;
block|}
comment|// we couldn't link methods, could be some really ancient kernel (e.g.< 2.1.57) or some bug
if|if
condition|(
name|linux_libc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: could not link methods. requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in"
argument_list|)
throw|;
block|}
comment|// pure paranoia:
comment|// check that unimplemented syscalls actually return ENOSYS
comment|// you never know (e.g. https://code.google.com/p/chromium/issues/detail?id=439795)
if|if
condition|(
name|linux_syscall
argument_list|(
literal|999
argument_list|)
operator|>=
literal|0
operator|||
name|Native
operator|.
name|getLastError
argument_list|()
operator|!=
name|ENOSYS
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: your kernel is buggy and you should upgrade"
argument_list|)
throw|;
block|}
comment|// try to check system calls really are who they claim
comment|// you never know (e.g. https://chromium.googlesource.com/chromium/src.git/+/master/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#57)
specifier|final
name|int
name|bogusArg
init|=
literal|0xf7a46a5c
decl_stmt|;
comment|// test seccomp(BOGUS)
name|long
name|ret
init|=
name|linux_syscall
argument_list|(
name|arch
operator|.
name|seccomp
argument_list|,
name|bogusArg
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: seccomp(BOGUS_OPERATION) returned "
operator|+
name|ret
argument_list|)
throw|;
block|}
else|else
block|{
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOSYS
case|:
break|break;
comment|// ok
case|case
name|EINVAL
case|:
break|break;
comment|// ok
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp(BOGUS_OPERATION): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// test seccomp(VALID, BOGUS)
name|ret
operator|=
name|linux_syscall
argument_list|(
name|arch
operator|.
name|seccomp
argument_list|,
name|SECCOMP_SET_MODE_FILTER
argument_list|,
name|bogusArg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: seccomp(SECCOMP_SET_MODE_FILTER, BOGUS_FLAG) returned "
operator|+
name|ret
argument_list|)
throw|;
block|}
else|else
block|{
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOSYS
case|:
break|break;
comment|// ok
case|case
name|EINVAL
case|:
break|break;
comment|// ok
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp(SECCOMP_SET_MODE_FILTER, BOGUS_FLAG): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// test prctl(BOGUS)
name|ret
operator|=
name|linux_prctl
argument_list|(
name|bogusArg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: prctl(BOGUS_OPTION) returned "
operator|+
name|ret
argument_list|)
throw|;
block|}
else|else
block|{
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOSYS
case|:
break|break;
comment|// ok
case|case
name|EINVAL
case|:
break|break;
comment|// ok
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(BOGUS_OPTION): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// now just normal defensive checks
comment|// check for GET_NO_NEW_PRIVS
switch|switch
condition|(
name|linux_prctl
argument_list|(
name|PR_GET_NO_NEW_PRIVS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|// not yet set
case|case
literal|1
case|:
break|break;
comment|// already set by caller
default|default:
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
block|{
comment|// friendly error, this will be the typical case for an old kernel
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_GET_NO_NEW_PRIVS): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// check for SECCOMP
switch|switch
condition|(
name|linux_prctl
argument_list|(
name|PR_GET_SECCOMP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|// not yet set
case|case
literal|2
case|:
break|break;
comment|// already in filter mode by caller
default|default:
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: CONFIG_SECCOMP not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_GET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// check for SECCOMP_MODE_FILTER
if|if
condition|(
name|linux_prctl
argument_list|(
name|PR_SET_SECCOMP
argument_list|,
name|SECCOMP_MODE_FILTER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EFAULT
case|:
break|break;
comment|// available
case|case
name|EINVAL
case|:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: CONFIG_SECCOMP_FILTER not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_SET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// ok, now set PR_SET_NO_NEW_PRIVS, needed to be able to set a seccomp filter as ordinary user
if|if
condition|(
name|linux_prctl
argument_list|(
name|PR_SET_NO_NEW_PRIVS
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_SET_NO_NEW_PRIVS): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// check it worked
if|if
condition|(
name|linux_prctl
argument_list|(
name|PR_GET_NO_NEW_PRIVS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp filter did not really succeed: prctl(PR_GET_NO_NEW_PRIVS): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// BPF installed to check arch, limit, then syscall. See https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt for details.
name|SockFilter
name|insns
index|[]
init|=
block|{
comment|/* 1  */
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_W
operator|+
name|BPF_ABS
argument_list|,
name|SECCOMP_DATA_ARCH_OFFSET
argument_list|)
block|,
comment|//
comment|/* 2  */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|arch
operator|.
name|audit
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
block|,
comment|// if (arch != audit) goto fail;
comment|/* 3  */
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_W
operator|+
name|BPF_ABS
argument_list|,
name|SECCOMP_DATA_NR_OFFSET
argument_list|)
block|,
comment|//
comment|/* 4  */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JGT
operator|+
name|BPF_K
argument_list|,
name|arch
operator|.
name|limit
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
block|,
comment|// if (syscall> LIMIT) goto fail;
comment|/* 5  */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|arch
operator|.
name|fork
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
block|,
comment|// if (syscall == FORK) goto fail;
comment|/* 6  */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|arch
operator|.
name|vfork
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
block|,
comment|// if (syscall == VFORK) goto fail;
comment|/* 7  */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|arch
operator|.
name|execve
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
comment|// if (syscall == EXECVE) goto fail;
comment|/* 8  */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|arch
operator|.
name|execveat
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|// if (syscall == EXECVEAT) goto fail;
comment|/* 9  */
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
name|SECCOMP_RET_ALLOW
argument_list|)
block|,
comment|// pass: return OK;
comment|/* 10 */
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
name|SECCOMP_RET_ERRNO
operator||
operator|(
name|EACCES
operator|&
name|SECCOMP_RET_DATA
operator|)
argument_list|)
block|,
comment|// fail: return EACCES;
block|}
decl_stmt|;
comment|// seccomp takes a long, so we pass it one explicitly to keep the JNA simple
name|SockFProg
name|prog
init|=
operator|new
name|SockFProg
argument_list|(
name|insns
argument_list|)
decl_stmt|;
name|prog
operator|.
name|write
argument_list|()
expr_stmt|;
name|long
name|pointer
init|=
name|Pointer
operator|.
name|nativeValue
argument_list|(
name|prog
operator|.
name|getPointer
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|method
init|=
literal|1
decl_stmt|;
comment|// install filter, if this works, after this there is no going back!
comment|// first try it with seccomp(SECCOMP_SET_MODE_FILTER), falling back to prctl()
if|if
condition|(
name|linux_syscall
argument_list|(
name|arch
operator|.
name|seccomp
argument_list|,
name|SECCOMP_SET_MODE_FILTER
argument_list|,
name|SECCOMP_FILTER_FLAG_TSYNC
argument_list|,
operator|new
name|NativeLong
argument_list|(
name|pointer
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|method
operator|=
literal|0
expr_stmt|;
name|int
name|errno1
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"seccomp(SECCOMP_SET_MODE_FILTER): {}, falling back to prctl(PR_SET_SECCOMP)..."
argument_list|,
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linux_prctl
argument_list|(
name|PR_SET_SECCOMP
argument_list|,
name|SECCOMP_MODE_FILTER
argument_list|,
name|pointer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|errno2
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp(SECCOMP_SET_MODE_FILTER): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno1
argument_list|)
operator|+
literal|", prctl(PR_SET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno2
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// now check that the filter was really installed, we should be in filter mode.
if|if
condition|(
name|linux_prctl
argument_list|(
name|PR_GET_SECCOMP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp filter installation did not really succeed. seccomp(PR_GET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"Linux seccomp filter installation successful, threads: [{}]"
argument_list|,
name|method
operator|==
literal|1
condition|?
literal|"all"
else|:
literal|"app"
argument_list|)
expr_stmt|;
return|return
name|method
return|;
block|}
comment|// OS X implementation via sandbox(7)
comment|/** Access to non-standard OS X libc methods */
DECL|interface|MacLibrary
specifier|static
interface|interface
name|MacLibrary
extends|extends
name|Library
block|{
comment|/**          * maps to sandbox_init(3), since Leopard          */
DECL|method|sandbox_init
name|int
name|sandbox_init
parameter_list|(
name|String
name|profile
parameter_list|,
name|long
name|flags
parameter_list|,
name|PointerByReference
name|errorbuf
parameter_list|)
function_decl|;
comment|/**          * releases memory when an error occurs during initialization (e.g. syntax bug)          */
DECL|method|sandbox_free_error
name|void
name|sandbox_free_error
parameter_list|(
name|Pointer
name|errorbuf
parameter_list|)
function_decl|;
block|}
comment|// null if unavailable, or something goes wrong.
DECL|field|libc_mac
specifier|private
specifier|static
specifier|final
name|MacLibrary
name|libc_mac
decl_stmt|;
static|static
block|{
name|MacLibrary
name|lib
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|Constants
operator|.
name|MAC_OS_X
condition|)
block|{
try|try
block|{
name|lib
operator|=
operator|(
name|MacLibrary
operator|)
name|Native
operator|.
name|loadLibrary
argument_list|(
literal|"c"
argument_list|,
name|MacLibrary
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsatisfiedLinkError
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"unable to link C library. native methods (seatbelt) will be disabled."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|libc_mac
operator|=
name|lib
expr_stmt|;
block|}
comment|/** The only supported flag... */
DECL|field|SANDBOX_NAMED
specifier|static
specifier|final
name|int
name|SANDBOX_NAMED
init|=
literal|1
decl_stmt|;
comment|/** Allow everything except process fork and execution */
DECL|field|SANDBOX_RULES
specifier|static
specifier|final
name|String
name|SANDBOX_RULES
init|=
literal|"(version 1) (allow default) (deny process-fork) (deny process-exec)"
decl_stmt|;
comment|/** try to install our custom rule profile into sandbox_init() to block execution */
DECL|method|macImpl
specifier|private
specifier|static
name|void
name|macImpl
parameter_list|(
name|Path
name|tmpFile
parameter_list|)
throws|throws
name|IOException
block|{
comment|// first be defensive: we can give nice errors this way, at the very least.
name|boolean
name|supported
init|=
name|Constants
operator|.
name|MAC_OS_X
decl_stmt|;
if|if
condition|(
name|supported
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"bug: should not be trying to initialize seatbelt for an unsupported OS"
argument_list|)
throw|;
block|}
comment|// we couldn't link methods, could be some really ancient OS X (< Leopard) or some bug
if|if
condition|(
name|libc_mac
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seatbelt unavailable: could not link methods. requires Leopard or above."
argument_list|)
throw|;
block|}
comment|// write rules to a temporary file, which will be passed to sandbox_init()
name|Path
name|rules
init|=
name|Files
operator|.
name|createTempFile
argument_list|(
name|tmpFile
argument_list|,
literal|"es"
argument_list|,
literal|"sb"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|write
argument_list|(
name|rules
argument_list|,
name|Collections
operator|.
name|singleton
argument_list|(
name|SANDBOX_RULES
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|PointerByReference
name|errorRef
init|=
operator|new
name|PointerByReference
argument_list|()
decl_stmt|;
name|int
name|ret
init|=
name|libc_mac
operator|.
name|sandbox_init
argument_list|(
name|rules
operator|.
name|toAbsolutePath
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|SANDBOX_NAMED
argument_list|,
name|errorRef
argument_list|)
decl_stmt|;
comment|// if sandbox_init() fails, add the message from the OS (e.g. syntax error) and free the buffer
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|Pointer
name|errorBuf
init|=
name|errorRef
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|RuntimeException
name|e
init|=
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"sandbox_init(): "
operator|+
name|errorBuf
operator|.
name|getString
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|libc_mac
operator|.
name|sandbox_free_error
argument_list|(
name|errorBuf
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"OS X seatbelt initialization successful"
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|Files
operator|.
name|delete
argument_list|(
name|rules
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|deleteFilesIgnoringExceptions
argument_list|(
name|rules
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Solaris implementation via priv_set(3C)
comment|/** Access to non-standard Solaris libc methods */
DECL|interface|SolarisLibrary
specifier|static
interface|interface
name|SolarisLibrary
extends|extends
name|Library
block|{
comment|/**          * see priv_set(3C), a convenience method for setppriv(2).          */
DECL|method|priv_set
name|int
name|priv_set
parameter_list|(
name|int
name|op
parameter_list|,
name|String
name|which
parameter_list|,
name|String
modifier|...
name|privs
parameter_list|)
function_decl|;
block|}
comment|// null if unavailable, or something goes wrong.
DECL|field|libc_solaris
specifier|private
specifier|static
specifier|final
name|SolarisLibrary
name|libc_solaris
decl_stmt|;
static|static
block|{
name|SolarisLibrary
name|lib
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|Constants
operator|.
name|SUN_OS
condition|)
block|{
try|try
block|{
name|lib
operator|=
operator|(
name|SolarisLibrary
operator|)
name|Native
operator|.
name|loadLibrary
argument_list|(
literal|"c"
argument_list|,
name|SolarisLibrary
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsatisfiedLinkError
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"unable to link C library. native methods (priv_set) will be disabled."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|libc_solaris
operator|=
name|lib
expr_stmt|;
block|}
comment|// constants for priv_set(2)
DECL|field|PRIV_OFF
specifier|static
specifier|final
name|int
name|PRIV_OFF
init|=
literal|1
decl_stmt|;
DECL|field|PRIV_ALLSETS
specifier|static
specifier|final
name|String
name|PRIV_ALLSETS
init|=
literal|null
decl_stmt|;
comment|// see privileges(5) for complete list of these
DECL|field|PRIV_PROC_FORK
specifier|static
specifier|final
name|String
name|PRIV_PROC_FORK
init|=
literal|"proc_fork"
decl_stmt|;
DECL|field|PRIV_PROC_EXEC
specifier|static
specifier|final
name|String
name|PRIV_PROC_EXEC
init|=
literal|"proc_exec"
decl_stmt|;
DECL|method|solarisImpl
specifier|static
name|void
name|solarisImpl
parameter_list|()
block|{
comment|// first be defensive: we can give nice errors this way, at the very least.
name|boolean
name|supported
init|=
name|Constants
operator|.
name|SUN_OS
decl_stmt|;
if|if
condition|(
name|supported
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"bug: should not be trying to initialize priv_set for an unsupported OS"
argument_list|)
throw|;
block|}
comment|// we couldn't link methods, could be some really ancient Solaris or some bug
if|if
condition|(
name|libc_solaris
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"priv_set unavailable: could not link methods. requires Solaris 10+"
argument_list|)
throw|;
block|}
comment|// drop a null-terminated list of privileges
if|if
condition|(
name|libc_solaris
operator|.
name|priv_set
argument_list|(
name|PRIV_OFF
argument_list|,
name|PRIV_ALLSETS
argument_list|,
name|PRIV_PROC_FORK
argument_list|,
name|PRIV_PROC_EXEC
argument_list|,
literal|null
argument_list|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"priv_set unavailable: priv_set(): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"Solaris priv_set initialization successful"
argument_list|)
expr_stmt|;
block|}
comment|// BSD implementation via setrlimit(2)
comment|// TODO: add OpenBSD to Lucene Constants
comment|// TODO: JNA doesn't have netbsd support, but this mechanism should work there too.
DECL|field|OPENBSD
specifier|static
specifier|final
name|boolean
name|OPENBSD
init|=
name|Constants
operator|.
name|OS_NAME
operator|.
name|startsWith
argument_list|(
literal|"OpenBSD"
argument_list|)
decl_stmt|;
comment|// not a standard limit, means something different on linux, etc!
DECL|field|RLIMIT_NPROC
specifier|static
specifier|final
name|int
name|RLIMIT_NPROC
init|=
literal|7
decl_stmt|;
DECL|method|bsdImpl
specifier|static
name|void
name|bsdImpl
parameter_list|()
block|{
name|boolean
name|supported
init|=
name|Constants
operator|.
name|FREE_BSD
operator|||
name|OPENBSD
operator|||
name|Constants
operator|.
name|MAC_OS_X
decl_stmt|;
if|if
condition|(
name|supported
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"bug: should not be trying to initialize RLIMIT_NPROC for an unsupported OS"
argument_list|)
throw|;
block|}
name|JNACLibrary
operator|.
name|Rlimit
name|limit
init|=
operator|new
name|JNACLibrary
operator|.
name|Rlimit
argument_list|()
decl_stmt|;
name|limit
operator|.
name|rlim_cur
operator|.
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|.
name|rlim_max
operator|.
name|setValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|JNACLibrary
operator|.
name|setrlimit
argument_list|(
name|RLIMIT_NPROC
argument_list|,
name|limit
argument_list|)
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"RLIMIT_NPROC unavailable: "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"BSD RLIMIT_NPROC initialization successful"
argument_list|)
expr_stmt|;
block|}
comment|// windows impl via job ActiveProcessLimit
DECL|method|windowsImpl
specifier|static
name|void
name|windowsImpl
parameter_list|()
block|{
if|if
condition|(
operator|!
name|Constants
operator|.
name|WINDOWS
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"bug: should not be trying to initialize ActiveProcessLimit for an unsupported OS"
argument_list|)
throw|;
block|}
name|JNAKernel32Library
name|lib
init|=
name|JNAKernel32Library
operator|.
name|getInstance
argument_list|()
decl_stmt|;
comment|// create a new Job
name|Pointer
name|job
init|=
name|lib
operator|.
name|CreateJobObjectW
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|job
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"CreateJobObject: "
operator|+
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
throw|;
block|}
try|try
block|{
comment|// retrieve the current basic limits of the job
name|int
name|clazz
init|=
name|JNAKernel32Library
operator|.
name|JOBOBJECT_BASIC_LIMIT_INFORMATION_CLASS
decl_stmt|;
name|JNAKernel32Library
operator|.
name|JOBOBJECT_BASIC_LIMIT_INFORMATION
name|limits
init|=
operator|new
name|JNAKernel32Library
operator|.
name|JOBOBJECT_BASIC_LIMIT_INFORMATION
argument_list|()
decl_stmt|;
name|limits
operator|.
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lib
operator|.
name|QueryInformationJobObject
argument_list|(
name|job
argument_list|,
name|clazz
argument_list|,
name|limits
operator|.
name|getPointer
argument_list|()
argument_list|,
name|limits
operator|.
name|size
argument_list|()
argument_list|,
literal|null
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"QueryInformationJobObject: "
operator|+
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
throw|;
block|}
name|limits
operator|.
name|read
argument_list|()
expr_stmt|;
comment|// modify the number of active processes to be 1 (exactly the one process we will add to the job).
name|limits
operator|.
name|ActiveProcessLimit
operator|=
literal|1
expr_stmt|;
name|limits
operator|.
name|LimitFlags
operator|=
name|JNAKernel32Library
operator|.
name|JOB_OBJECT_LIMIT_ACTIVE_PROCESS
expr_stmt|;
name|limits
operator|.
name|write
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|lib
operator|.
name|SetInformationJobObject
argument_list|(
name|job
argument_list|,
name|clazz
argument_list|,
name|limits
operator|.
name|getPointer
argument_list|()
argument_list|,
name|limits
operator|.
name|size
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"SetInformationJobObject: "
operator|+
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
throw|;
block|}
comment|// assign ourselves to the job
if|if
condition|(
operator|!
name|lib
operator|.
name|AssignProcessToJobObject
argument_list|(
name|job
argument_list|,
name|lib
operator|.
name|GetCurrentProcess
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"AssignProcessToJobObject: "
operator|+
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
throw|;
block|}
block|}
finally|finally
block|{
name|lib
operator|.
name|CloseHandle
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"Windows ActiveProcessLimit initialization successful"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Attempt to drop the capability to execute for the process.      *<p>      * This is best effort and OS and architecture dependent. It may throw any Throwable.      * @return 0 if we can do this for application threads, 1 for the entire process      */
DECL|method|init
specifier|static
name|int
name|init
parameter_list|(
name|Path
name|tmpFile
parameter_list|)
throws|throws
name|Throwable
block|{
if|if
condition|(
name|Constants
operator|.
name|LINUX
condition|)
block|{
return|return
name|linuxImpl
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|MAC_OS_X
condition|)
block|{
comment|// try to enable both mechanisms if possible
name|bsdImpl
argument_list|()
expr_stmt|;
name|macImpl
argument_list|(
name|tmpFile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|SUN_OS
condition|)
block|{
name|solarisImpl
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|FREE_BSD
operator|||
name|OPENBSD
condition|)
block|{
name|bsdImpl
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|WINDOWS
condition|)
block|{
name|windowsImpl
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"syscall filtering not supported for OS: '"
operator|+
name|Constants
operator|.
name|OS_NAME
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

