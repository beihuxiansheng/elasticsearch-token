begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.bootstrap
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|bootstrap
package|;
end_package

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Library
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Memory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Native
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Pointer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|sun
operator|.
name|jna
operator|.
name|Structure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|Loggers
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteBuffer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|ByteOrder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**   * Installs a limited form of Linux secure computing mode (filter mode).  * This filters system calls to block process execution.  *<p>  * This is only supported on the amd64 architecture, on Linux kernels 3.5 or above, and requires  * {@code CONFIG_SECCOMP} and {@code CONFIG_SECCOMP_FILTER} compiled into the kernel.  *<p>  * Filters are installed using either {@code seccomp(2)} (3.17+) or {@code prctl(2)} (3.5+). {@code seccomp(2)}  * is preferred, as it allows filters to be applied to any existing threads in the process, and one motivation  * here is to protect against bugs in the JVM. Otherwise, code will fall back to the {@code prctl(2)} method   * which will at least protect elasticsearch application threads.  *<p>  * The filters will return {@code EACCES} (Access Denied) for the following system calls:  *<ul>  *<li>{@code execve}</li>  *<li>{@code fork}</li>  *<li>{@code vfork}</li>  *</ul>  *<p>  * This is not intended as a sandbox. It is another level of security, mostly intended to annoy  * security researchers and make their lives more difficult in achieving "remote execution" exploits.  * @see<a href="http://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt">  *      http://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt</a>  */
end_comment

begin_comment
comment|// only supported on linux/amd64
end_comment

begin_comment
comment|// not an example of how to write code!!!
end_comment

begin_class
DECL|class|Seccomp
specifier|final
class|class
name|Seccomp
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|ESLogger
name|logger
init|=
name|Loggers
operator|.
name|getLogger
argument_list|(
name|Seccomp
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/** we use an explicit interface for native methods, for varargs support */
DECL|interface|LinuxLibrary
specifier|static
interface|interface
name|LinuxLibrary
extends|extends
name|Library
block|{
comment|/**           * maps to prctl(2)           */
DECL|method|prctl
name|int
name|prctl
parameter_list|(
name|int
name|option
parameter_list|,
name|long
name|arg2
parameter_list|,
name|long
name|arg3
parameter_list|,
name|long
name|arg4
parameter_list|,
name|long
name|arg5
parameter_list|)
function_decl|;
comment|/**           * used to call seccomp(2), its too new...           * this is the only way, DONT use it on some other architecture unless you know wtf you are doing           */
DECL|method|syscall
name|long
name|syscall
parameter_list|(
name|long
name|number
parameter_list|,
name|Object
modifier|...
name|args
parameter_list|)
function_decl|;
block|}
empty_stmt|;
comment|// null if something goes wrong.
DECL|field|libc
specifier|static
specifier|final
name|LinuxLibrary
name|libc
decl_stmt|;
static|static
block|{
name|LinuxLibrary
name|lib
init|=
literal|null
decl_stmt|;
try|try
block|{
name|lib
operator|=
operator|(
name|LinuxLibrary
operator|)
name|Native
operator|.
name|loadLibrary
argument_list|(
literal|"c"
argument_list|,
name|LinuxLibrary
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|UnsatisfiedLinkError
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"unable to link C library. native methods (seccomp) will be disabled."
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|libc
operator|=
name|lib
expr_stmt|;
block|}
comment|/** the preferred method is seccomp(2), since we can apply to all threads of the process */
DECL|field|SECCOMP_SYSCALL_NR
specifier|static
specifier|final
name|int
name|SECCOMP_SYSCALL_NR
init|=
literal|317
decl_stmt|;
comment|// since Linux 3.17
DECL|field|SECCOMP_SET_MODE_FILTER
specifier|static
specifier|final
name|int
name|SECCOMP_SET_MODE_FILTER
init|=
literal|1
decl_stmt|;
comment|// since Linux 3.17
DECL|field|SECCOMP_FILTER_FLAG_TSYNC
specifier|static
specifier|final
name|int
name|SECCOMP_FILTER_FLAG_TSYNC
init|=
literal|1
decl_stmt|;
comment|// since Linux 3.17
comment|/** otherwise, we can use prctl(2), which will at least protect ES application threads */
DECL|field|PR_GET_NO_NEW_PRIVS
specifier|static
specifier|final
name|int
name|PR_GET_NO_NEW_PRIVS
init|=
literal|39
decl_stmt|;
comment|// since Linux 3.5
DECL|field|PR_SET_NO_NEW_PRIVS
specifier|static
specifier|final
name|int
name|PR_SET_NO_NEW_PRIVS
init|=
literal|38
decl_stmt|;
comment|// since Linux 3.5
DECL|field|PR_GET_SECCOMP
specifier|static
specifier|final
name|int
name|PR_GET_SECCOMP
init|=
literal|21
decl_stmt|;
comment|// since Linux 2.6.23
DECL|field|PR_SET_SECCOMP
specifier|static
specifier|final
name|int
name|PR_SET_SECCOMP
init|=
literal|22
decl_stmt|;
comment|// since Linux 2.6.23
DECL|field|SECCOMP_MODE_FILTER
specifier|static
specifier|final
name|int
name|SECCOMP_MODE_FILTER
init|=
literal|2
decl_stmt|;
comment|// since Linux Linux 3.5
comment|/** corresponds to struct sock_filter */
DECL|class|SockFilter
specifier|static
specifier|final
class|class
name|SockFilter
block|{
DECL|field|code
name|short
name|code
decl_stmt|;
comment|// insn
DECL|field|jt
name|byte
name|jt
decl_stmt|;
comment|// number of insn to jump (skip) if true
DECL|field|jf
name|byte
name|jf
decl_stmt|;
comment|// number of insn to jump (skip) if false
DECL|field|k
name|int
name|k
decl_stmt|;
comment|// additional data
DECL|method|SockFilter
name|SockFilter
parameter_list|(
name|short
name|code
parameter_list|,
name|byte
name|jt
parameter_list|,
name|byte
name|jf
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|this
operator|.
name|code
operator|=
name|code
expr_stmt|;
name|this
operator|.
name|jt
operator|=
name|jt
expr_stmt|;
name|this
operator|.
name|jf
operator|=
name|jf
expr_stmt|;
name|this
operator|.
name|k
operator|=
name|k
expr_stmt|;
block|}
block|}
comment|/** corresponds to struct sock_fprog */
DECL|class|SockFProg
specifier|public
specifier|static
specifier|final
class|class
name|SockFProg
extends|extends
name|Structure
implements|implements
name|Structure
operator|.
name|ByReference
block|{
DECL|field|len
specifier|public
name|short
name|len
decl_stmt|;
comment|// number of filters
DECL|field|filter
specifier|public
name|Pointer
name|filter
decl_stmt|;
comment|// filters
DECL|method|SockFProg
specifier|public
name|SockFProg
parameter_list|(
name|SockFilter
name|filters
index|[]
parameter_list|)
block|{
name|len
operator|=
operator|(
name|short
operator|)
name|filters
operator|.
name|length
expr_stmt|;
comment|// serialize struct sock_filter * explicitly, its less confusing than the JNA magic we would need
name|Memory
name|filter
init|=
operator|new
name|Memory
argument_list|(
name|len
operator|*
literal|8
argument_list|)
decl_stmt|;
name|ByteBuffer
name|bbuf
init|=
name|filter
operator|.
name|getByteBuffer
argument_list|(
literal|0
argument_list|,
name|len
operator|*
literal|8
argument_list|)
decl_stmt|;
name|bbuf
operator|.
name|order
argument_list|(
name|ByteOrder
operator|.
name|nativeOrder
argument_list|()
argument_list|)
expr_stmt|;
comment|// little endian
for|for
control|(
name|SockFilter
name|f
range|:
name|filters
control|)
block|{
name|bbuf
operator|.
name|putShort
argument_list|(
name|f
operator|.
name|code
argument_list|)
expr_stmt|;
name|bbuf
operator|.
name|put
argument_list|(
name|f
operator|.
name|jt
argument_list|)
expr_stmt|;
name|bbuf
operator|.
name|put
argument_list|(
name|f
operator|.
name|jf
argument_list|)
expr_stmt|;
name|bbuf
operator|.
name|putInt
argument_list|(
name|f
operator|.
name|k
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getFieldOrder
specifier|protected
name|List
argument_list|<
name|String
argument_list|>
name|getFieldOrder
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"len"
block|,
literal|"filter"
block|}
argument_list|)
return|;
block|}
block|}
comment|// BPF "macros" and constants
DECL|field|BPF_LD
specifier|static
specifier|final
name|int
name|BPF_LD
init|=
literal|0x00
decl_stmt|;
DECL|field|BPF_W
specifier|static
specifier|final
name|int
name|BPF_W
init|=
literal|0x00
decl_stmt|;
DECL|field|BPF_ABS
specifier|static
specifier|final
name|int
name|BPF_ABS
init|=
literal|0x20
decl_stmt|;
DECL|field|BPF_JMP
specifier|static
specifier|final
name|int
name|BPF_JMP
init|=
literal|0x05
decl_stmt|;
DECL|field|BPF_JEQ
specifier|static
specifier|final
name|int
name|BPF_JEQ
init|=
literal|0x10
decl_stmt|;
DECL|field|BPF_JGE
specifier|static
specifier|final
name|int
name|BPF_JGE
init|=
literal|0x30
decl_stmt|;
DECL|field|BPF_JGT
specifier|static
specifier|final
name|int
name|BPF_JGT
init|=
literal|0x20
decl_stmt|;
DECL|field|BPF_RET
specifier|static
specifier|final
name|int
name|BPF_RET
init|=
literal|0x06
decl_stmt|;
DECL|field|BPF_K
specifier|static
specifier|final
name|int
name|BPF_K
init|=
literal|0x00
decl_stmt|;
DECL|method|BPF_STMT
specifier|static
name|SockFilter
name|BPF_STMT
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|k
parameter_list|)
block|{
return|return
operator|new
name|SockFilter
argument_list|(
operator|(
name|short
operator|)
name|code
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|,
name|k
argument_list|)
return|;
block|}
DECL|method|BPF_JUMP
specifier|static
name|SockFilter
name|BPF_JUMP
parameter_list|(
name|int
name|code
parameter_list|,
name|int
name|k
parameter_list|,
name|int
name|jt
parameter_list|,
name|int
name|jf
parameter_list|)
block|{
return|return
operator|new
name|SockFilter
argument_list|(
operator|(
name|short
operator|)
name|code
argument_list|,
operator|(
name|byte
operator|)
name|jt
argument_list|,
operator|(
name|byte
operator|)
name|jf
argument_list|,
name|k
argument_list|)
return|;
block|}
DECL|field|AUDIT_ARCH_X86_64
specifier|static
specifier|final
name|int
name|AUDIT_ARCH_X86_64
init|=
literal|0xC000003E
decl_stmt|;
DECL|field|SECCOMP_RET_ERRNO
specifier|static
specifier|final
name|int
name|SECCOMP_RET_ERRNO
init|=
literal|0x00050000
decl_stmt|;
DECL|field|SECCOMP_RET_DATA
specifier|static
specifier|final
name|int
name|SECCOMP_RET_DATA
init|=
literal|0x0000FFFF
decl_stmt|;
DECL|field|SECCOMP_RET_ALLOW
specifier|static
specifier|final
name|int
name|SECCOMP_RET_ALLOW
init|=
literal|0x7FFF0000
decl_stmt|;
comment|// some errno constants for error checking/handling
DECL|field|EACCES
specifier|static
specifier|final
name|int
name|EACCES
init|=
literal|0x0D
decl_stmt|;
DECL|field|EFAULT
specifier|static
specifier|final
name|int
name|EFAULT
init|=
literal|0x0E
decl_stmt|;
DECL|field|EINVAL
specifier|static
specifier|final
name|int
name|EINVAL
init|=
literal|0x16
decl_stmt|;
DECL|field|ENOSYS
specifier|static
specifier|final
name|int
name|ENOSYS
init|=
literal|0x26
decl_stmt|;
comment|// offsets (arch dependent) that our BPF checks
DECL|field|SECCOMP_DATA_NR_OFFSET
specifier|static
specifier|final
name|int
name|SECCOMP_DATA_NR_OFFSET
init|=
literal|0x00
decl_stmt|;
DECL|field|SECCOMP_DATA_ARCH_OFFSET
specifier|static
specifier|final
name|int
name|SECCOMP_DATA_ARCH_OFFSET
init|=
literal|0x04
decl_stmt|;
comment|// currently this range is blocked (inclusive):
comment|// execve is really the only one needed but why let someone fork a 30G heap? (not really what happens)
comment|// ...
comment|// 57: fork
comment|// 58: vfork
comment|// 59: execve
comment|// ...
DECL|field|BLACKLIST_START
specifier|static
specifier|final
name|int
name|BLACKLIST_START
init|=
literal|57
decl_stmt|;
DECL|field|BLACKLIST_END
specifier|static
specifier|final
name|int
name|BLACKLIST_END
init|=
literal|59
decl_stmt|;
comment|// TODO: execveat()? its less of a risk since the jvm does not use it...
comment|/** try to install our filters */
DECL|method|installFilter
specifier|static
name|void
name|installFilter
parameter_list|()
block|{
comment|// first be defensive: we can give nice errors this way, at the very least.
comment|// also, some of these security features get backported to old versions, checking kernel version here is a big no-no!
name|boolean
name|supported
init|=
name|Constants
operator|.
name|LINUX
operator|&&
literal|"amd64"
operator|.
name|equals
argument_list|(
name|Constants
operator|.
name|OS_ARCH
argument_list|)
decl_stmt|;
if|if
condition|(
name|supported
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"bug: should not be trying to initialize seccomp for an unsupported architecture"
argument_list|)
throw|;
block|}
comment|// we couldn't link methods, could be some really ancient kernel (e.g.< 2.1.57) or some bug
if|if
condition|(
name|libc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: could not link methods. requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in"
argument_list|)
throw|;
block|}
comment|// check for kernel version
if|if
condition|(
name|libc
operator|.
name|prctl
argument_list|(
name|PR_GET_NO_NEW_PRIVS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOSYS
case|:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: requires kernel 3.5+ with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_GET_NO_NEW_PRIVS): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// check for SECCOMP
if|if
condition|(
name|libc
operator|.
name|prctl
argument_list|(
name|PR_GET_SECCOMP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EINVAL
case|:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: CONFIG_SECCOMP not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_GET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// check for SECCOMP_MODE_FILTER
if|if
condition|(
name|libc
operator|.
name|prctl
argument_list|(
name|PR_SET_SECCOMP
argument_list|,
name|SECCOMP_MODE_FILTER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|errno
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EFAULT
case|:
break|break;
comment|// available
case|case
name|EINVAL
case|:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp unavailable: CONFIG_SECCOMP_FILTER not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed"
argument_list|)
throw|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_SET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// ok, now set PR_SET_NO_NEW_PRIVS, needed to be able to set a seccomp filter as ordinary user
if|if
condition|(
name|libc
operator|.
name|prctl
argument_list|(
name|PR_SET_NO_NEW_PRIVS
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"prctl(PR_SET_NO_NEW_PRIVS): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
comment|// BPF installed to check arch, then syscall range. See https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt for details.
name|SockFilter
name|insns
index|[]
init|=
block|{
comment|/* 1 */
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_W
operator|+
name|BPF_ABS
argument_list|,
name|SECCOMP_DATA_ARCH_OFFSET
argument_list|)
block|,
comment|// if (arch != amd64) goto fail;
comment|/* 2 */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|AUDIT_ARCH_X86_64
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
block|,
comment|//
comment|/* 3 */
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_W
operator|+
name|BPF_ABS
argument_list|,
name|SECCOMP_DATA_NR_OFFSET
argument_list|)
block|,
comment|// if (syscall< BLACKLIST_START) goto pass;
comment|/* 4 */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JGE
operator|+
name|BPF_K
argument_list|,
name|BLACKLIST_START
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
block|,
comment|//
comment|/* 5 */
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JGT
operator|+
name|BPF_K
argument_list|,
name|BLACKLIST_END
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
comment|// if (syscall> BLACKLIST_END) goto pass;
comment|/* 6 */
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
name|SECCOMP_RET_ERRNO
operator||
operator|(
name|EACCES
operator|&
name|SECCOMP_RET_DATA
operator|)
argument_list|)
block|,
comment|// fail: return EACCES;
comment|/* 7 */
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
name|SECCOMP_RET_ALLOW
argument_list|)
comment|// pass: return OK;
block|}
decl_stmt|;
comment|// seccomp takes a long, so we pass it one explicitly to keep the JNA simple
name|SockFProg
name|prog
init|=
operator|new
name|SockFProg
argument_list|(
name|insns
argument_list|)
decl_stmt|;
name|prog
operator|.
name|write
argument_list|()
expr_stmt|;
name|long
name|pointer
init|=
name|Pointer
operator|.
name|nativeValue
argument_list|(
name|prog
operator|.
name|getPointer
argument_list|()
argument_list|)
decl_stmt|;
comment|// install filter, if this works, after this there is no going back!
comment|// first try it with seccomp(SECCOMP_SET_MODE_FILTER), falling back to prctl()
if|if
condition|(
name|libc
operator|.
name|syscall
argument_list|(
name|SECCOMP_SYSCALL_NR
argument_list|,
name|SECCOMP_SET_MODE_FILTER
argument_list|,
name|SECCOMP_FILTER_FLAG_TSYNC
argument_list|,
name|pointer
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|errno1
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"seccomp(SECCOMP_SET_MODE_FILTER): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno1
argument_list|)
operator|+
literal|", falling back to prctl(PR_SET_SECCOMP)..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|libc
operator|.
name|prctl
argument_list|(
name|PR_SET_SECCOMP
argument_list|,
name|SECCOMP_MODE_FILTER
argument_list|,
name|pointer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|errno2
init|=
name|Native
operator|.
name|getLastError
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp(SECCOMP_SET_MODE_FILTER): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno1
argument_list|)
operator|+
literal|", prctl(PR_SET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|errno2
argument_list|)
argument_list|)
throw|;
block|}
block|}
comment|// now check that the filter was really installed, we should be in filter mode.
if|if
condition|(
name|libc
operator|.
name|prctl
argument_list|(
name|PR_GET_SECCOMP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"seccomp filter installation did not really succeed. seccomp(PR_GET_SECCOMP): "
operator|+
name|JNACLibrary
operator|.
name|strerror
argument_list|(
name|Native
operator|.
name|getLastError
argument_list|()
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

