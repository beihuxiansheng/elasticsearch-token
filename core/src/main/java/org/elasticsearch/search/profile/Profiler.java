begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.search.profile
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|profile
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * This class acts as a thread-local storage for profiling a query.  It also  * builds a representation of the query tree which is built constructed  * "online" as the weights are wrapped by ContextIndexSearcher.  This allows us  * to know the relationship between nodes in tree without explicitly  * walking the tree or pre-wrapping everything  *  * A Profiler is associated with every Search, not per Search-Request. E.g. a  * request may execute two searches (query + global agg).  A Profiler just  * represents one of those  */
end_comment

begin_class
DECL|class|Profiler
specifier|public
specifier|final
class|class
name|Profiler
block|{
DECL|field|queryTree
specifier|private
specifier|final
name|InternalProfileTree
name|queryTree
init|=
operator|new
name|InternalProfileTree
argument_list|()
decl_stmt|;
comment|/**      * The root Collector used in the search      */
DECL|field|collector
specifier|private
name|InternalProfileCollector
name|collector
decl_stmt|;
DECL|method|Profiler
specifier|public
name|Profiler
parameter_list|()
block|{}
comment|/** Set the collector that is associated with this profiler. */
DECL|method|setCollector
specifier|public
name|void
name|setCollector
parameter_list|(
name|InternalProfileCollector
name|collector
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|collector
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"The collector can only be set once."
argument_list|)
throw|;
block|}
name|this
operator|.
name|collector
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|collector
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the {@link ProfileBreakdown} for the given query, potentially creating it if it did not exist.      * This should only be used for queries that will be undergoing scoring. Do not use it to profile the      * rewriting phase      */
DECL|method|getQueryBreakdown
specifier|public
name|ProfileBreakdown
name|getQueryBreakdown
parameter_list|(
name|Query
name|query
parameter_list|)
block|{
return|return
name|queryTree
operator|.
name|getQueryBreakdown
argument_list|(
name|query
argument_list|)
return|;
block|}
comment|/**      * Begin timing the rewrite phase of a request.  All rewrites are accumulated together into a      * single metric      */
DECL|method|startRewriteTime
specifier|public
name|void
name|startRewriteTime
parameter_list|()
block|{
name|queryTree
operator|.
name|startRewriteTime
argument_list|()
expr_stmt|;
block|}
comment|/**      * Stop recording the current rewrite and add it's time to the total tally, returning the      * cumulative time so far.      *      * @return cumulative rewrite time      */
DECL|method|stopAndAddRewriteTime
specifier|public
name|long
name|stopAndAddRewriteTime
parameter_list|()
block|{
return|return
name|queryTree
operator|.
name|stopAndAddRewriteTime
argument_list|()
return|;
block|}
comment|/**      * Removes the last (e.g. most recent) query on the stack.  This should only be called for scoring      * queries, not rewritten queries      */
DECL|method|pollLastQuery
specifier|public
name|void
name|pollLastQuery
parameter_list|()
block|{
name|queryTree
operator|.
name|pollLast
argument_list|()
expr_stmt|;
block|}
comment|/**      * @return a hierarchical representation of the profiled query tree      */
DECL|method|getQueryTree
specifier|public
name|List
argument_list|<
name|ProfileResult
argument_list|>
name|getQueryTree
parameter_list|()
block|{
return|return
name|queryTree
operator|.
name|getQueryTree
argument_list|()
return|;
block|}
comment|/**      * @return total time taken to rewrite all queries in this profile      */
DECL|method|getRewriteTime
specifier|public
name|long
name|getRewriteTime
parameter_list|()
block|{
return|return
name|queryTree
operator|.
name|getRewriteTime
argument_list|()
return|;
block|}
comment|/**      * Return the current root Collector for this search      */
DECL|method|getCollector
specifier|public
name|CollectorResult
name|getCollector
parameter_list|()
block|{
return|return
name|collector
operator|.
name|getCollectorTree
argument_list|()
return|;
block|}
comment|/**      * Helper method to convert Profiler into  InternalProfileShardResults, which can be      * serialized to other nodes, emitted as JSON, etc.      *      * @param profilers A list of Profilers to convert into InternalProfileShardResults      * @return          A list of corresponding InternalProfileShardResults      */
DECL|method|buildShardResults
specifier|public
specifier|static
name|List
argument_list|<
name|ProfileShardResult
argument_list|>
name|buildShardResults
parameter_list|(
name|List
argument_list|<
name|Profiler
argument_list|>
name|profilers
parameter_list|)
block|{
name|List
argument_list|<
name|ProfileShardResult
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|profilers
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Profiler
name|profiler
range|:
name|profilers
control|)
block|{
name|ProfileShardResult
name|result
init|=
operator|new
name|ProfileShardResult
argument_list|(
name|profiler
operator|.
name|getQueryTree
argument_list|()
argument_list|,
name|profiler
operator|.
name|getRewriteTime
argument_list|()
argument_list|,
name|profiler
operator|.
name|getCollector
argument_list|()
argument_list|)
decl_stmt|;
name|results
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|results
return|;
block|}
block|}
end_class

end_unit

