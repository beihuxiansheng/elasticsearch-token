begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.search.aggregations
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParsingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|DeprecationLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|Loggers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|Comparators
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryParseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|bucket
operator|.
name|MultiBucketsAggregation
operator|.
name|Bucket
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|bucket
operator|.
name|terms
operator|.
name|TermsAggregator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|support
operator|.
name|AggregationPath
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_comment
comment|/**  * Implementations for {@link Bucket} ordering strategies.  */
end_comment

begin_class
DECL|class|InternalOrder
specifier|public
class|class
name|InternalOrder
extends|extends
name|BucketOrder
block|{
DECL|field|id
specifier|private
specifier|final
name|byte
name|id
decl_stmt|;
DECL|field|key
specifier|private
specifier|final
name|String
name|key
decl_stmt|;
DECL|field|asc
specifier|protected
specifier|final
name|boolean
name|asc
decl_stmt|;
DECL|field|comparator
specifier|protected
specifier|final
name|Comparator
argument_list|<
name|Bucket
argument_list|>
name|comparator
decl_stmt|;
comment|/**      * Creates an ordering strategy that sorts {@link Bucket}s by some property.      *      * @param id         unique ID for this ordering strategy.      * @param key        key of the property to sort on.      * @param asc        direction to sort by: {@code true} for ascending, {@code false} for descending.      * @param comparator determines how buckets will be ordered.      */
DECL|method|InternalOrder
specifier|public
name|InternalOrder
parameter_list|(
name|byte
name|id
parameter_list|,
name|String
name|key
parameter_list|,
name|boolean
name|asc
parameter_list|,
name|Comparator
argument_list|<
name|Bucket
argument_list|>
name|comparator
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|asc
operator|=
name|asc
expr_stmt|;
name|this
operator|.
name|comparator
operator|=
name|comparator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|id
name|byte
name|id
parameter_list|()
block|{
return|return
name|id
return|;
block|}
annotation|@
name|Override
DECL|method|comparator
specifier|public
name|Comparator
argument_list|<
name|Bucket
argument_list|>
name|comparator
parameter_list|(
name|Aggregator
name|aggregator
parameter_list|)
block|{
return|return
name|comparator
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|builder
operator|.
name|startObject
argument_list|()
operator|.
name|field
argument_list|(
name|key
argument_list|,
name|asc
condition|?
literal|"asc"
else|:
literal|"desc"
argument_list|)
operator|.
name|endObject
argument_list|()
return|;
block|}
comment|/**      * Validate a bucket ordering strategy for an {@link Aggregator}.      *      * @param order      bucket ordering strategy to sort on.      * @param aggregator aggregator to sort.      * @return unmodified bucket ordering strategy.      * @throws AggregationExecutionException if validation fails      */
DECL|method|validate
specifier|public
specifier|static
name|BucketOrder
name|validate
parameter_list|(
name|BucketOrder
name|order
parameter_list|,
name|Aggregator
name|aggregator
parameter_list|)
throws|throws
name|AggregationExecutionException
block|{
if|if
condition|(
name|order
operator|instanceof
name|CompoundOrder
condition|)
block|{
for|for
control|(
name|BucketOrder
name|innerOrder
range|:
operator|(
operator|(
name|CompoundOrder
operator|)
name|order
operator|)
operator|.
name|orderElements
control|)
block|{
name|validate
argument_list|(
name|innerOrder
argument_list|,
name|aggregator
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|order
operator|instanceof
name|Aggregation
condition|)
block|{
operator|(
operator|(
name|Aggregation
operator|)
name|order
operator|)
operator|.
name|path
argument_list|()
operator|.
name|validate
argument_list|(
name|aggregator
argument_list|)
expr_stmt|;
block|}
return|return
name|order
return|;
block|}
comment|/**      * {@link Bucket} ordering strategy to sort by a sub-aggregation.      */
DECL|class|Aggregation
specifier|public
specifier|static
class|class
name|Aggregation
extends|extends
name|InternalOrder
block|{
DECL|field|ID
specifier|static
specifier|final
name|byte
name|ID
init|=
literal|0
decl_stmt|;
comment|/**          * Create a new ordering strategy to sort by a sub-aggregation.          *          * @param path path to the sub-aggregation to sort on.          * @param asc  direction to sort by: {@code true} for ascending, {@code false} for descending.          * @see AggregationPath          */
DECL|method|Aggregation
name|Aggregation
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|asc
parameter_list|)
block|{
name|super
argument_list|(
name|ID
argument_list|,
name|path
argument_list|,
name|asc
argument_list|,
operator|new
name|AggregationComparator
argument_list|(
name|path
argument_list|,
name|asc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**          * @return parsed path to the sub-aggregation to sort on.          */
DECL|method|path
specifier|public
name|AggregationPath
name|path
parameter_list|()
block|{
return|return
operator|(
operator|(
name|AggregationComparator
operator|)
name|comparator
operator|)
operator|.
name|path
return|;
block|}
annotation|@
name|Override
DECL|method|comparator
specifier|public
name|Comparator
argument_list|<
name|Bucket
argument_list|>
name|comparator
parameter_list|(
name|Aggregator
name|aggregator
parameter_list|)
block|{
if|if
condition|(
name|aggregator
operator|instanceof
name|TermsAggregator
condition|)
block|{
comment|// Internal Optimization for terms aggregation to avoid constructing buckets for ordering purposes
return|return
operator|(
operator|(
name|TermsAggregator
operator|)
name|aggregator
operator|)
operator|.
name|bucketComparator
argument_list|(
name|path
argument_list|()
argument_list|,
name|asc
argument_list|)
return|;
block|}
return|return
name|comparator
return|;
block|}
comment|/**          * {@link Bucket} ordering strategy to sort by a sub-aggregation.          */
DECL|class|AggregationComparator
specifier|static
class|class
name|AggregationComparator
implements|implements
name|Comparator
argument_list|<
name|Bucket
argument_list|>
block|{
DECL|field|path
specifier|private
specifier|final
name|AggregationPath
name|path
decl_stmt|;
DECL|field|asc
specifier|private
specifier|final
name|boolean
name|asc
decl_stmt|;
comment|/**              * Create a new {@link Bucket} ordering strategy to sort by a sub-aggregation.              *              * @param path path to the sub-aggregation to sort on.              * @param asc  direction to sort by: {@code true} for ascending, {@code false} for descending.              * @see AggregationPath              */
DECL|method|AggregationComparator
name|AggregationComparator
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|asc
parameter_list|)
block|{
name|this
operator|.
name|asc
operator|=
name|asc
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|AggregationPath
operator|.
name|parse
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|Bucket
name|b1
parameter_list|,
name|Bucket
name|b2
parameter_list|)
block|{
name|double
name|v1
init|=
name|path
operator|.
name|resolveValue
argument_list|(
name|b1
argument_list|)
decl_stmt|;
name|double
name|v2
init|=
name|path
operator|.
name|resolveValue
argument_list|(
name|b2
argument_list|)
decl_stmt|;
return|return
name|Comparators
operator|.
name|compareDiscardNaN
argument_list|(
name|v1
argument_list|,
name|v2
argument_list|,
name|asc
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * {@link Bucket} ordering strategy to sort by multiple criteria.      */
DECL|class|CompoundOrder
specifier|public
specifier|static
class|class
name|CompoundOrder
extends|extends
name|BucketOrder
block|{
DECL|field|ID
specifier|static
specifier|final
name|byte
name|ID
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|orderElements
specifier|final
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|orderElements
decl_stmt|;
comment|/**          * Create a new ordering strategy to sort by multiple criteria. A tie-breaker may be added to avoid          * non-deterministic ordering.          *          * @param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.          */
DECL|method|CompoundOrder
name|CompoundOrder
parameter_list|(
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|compoundOrder
parameter_list|)
block|{
name|this
argument_list|(
name|compoundOrder
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**          * Create a new ordering strategy to sort by multiple criteria.          *          * @param compoundOrder    a list of {@link BucketOrder}s to sort on, in order of priority.          * @param absoluteOrdering {@code true} to add a tie-breaker to avoid non-deterministic ordering if needed,          *                         {@code false} otherwise.          */
DECL|method|CompoundOrder
name|CompoundOrder
parameter_list|(
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|compoundOrder
parameter_list|,
name|boolean
name|absoluteOrdering
parameter_list|)
block|{
name|this
operator|.
name|orderElements
operator|=
operator|new
name|LinkedList
argument_list|<>
argument_list|(
name|compoundOrder
argument_list|)
expr_stmt|;
name|BucketOrder
name|lastElement
init|=
literal|null
decl_stmt|;
for|for
control|(
name|BucketOrder
name|order
range|:
name|orderElements
control|)
block|{
if|if
condition|(
name|order
operator|instanceof
name|CompoundOrder
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"nested compound order not supported"
argument_list|)
throw|;
block|}
name|lastElement
operator|=
name|order
expr_stmt|;
block|}
if|if
condition|(
name|absoluteOrdering
operator|&&
name|isKeyOrder
argument_list|(
name|lastElement
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// add key order ascending as a tie-breaker to avoid non-deterministic ordering
comment|// if all user provided comparators return 0.
name|this
operator|.
name|orderElements
operator|.
name|add
argument_list|(
name|KEY_ASC
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|id
name|byte
name|id
parameter_list|()
block|{
return|return
name|ID
return|;
block|}
comment|/**          * @return unmodifiable list of {@link BucketOrder}s to sort on.          */
DECL|method|orderElements
specifier|public
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|orderElements
parameter_list|()
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|orderElements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|builder
operator|.
name|startArray
argument_list|()
expr_stmt|;
for|for
control|(
name|BucketOrder
name|order
range|:
name|orderElements
control|)
block|{
name|order
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|endArray
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|comparator
specifier|public
name|Comparator
argument_list|<
name|Bucket
argument_list|>
name|comparator
parameter_list|(
name|Aggregator
name|aggregator
parameter_list|)
block|{
return|return
operator|new
name|CompoundOrderComparator
argument_list|(
name|orderElements
argument_list|,
name|aggregator
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|orderElements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|CompoundOrder
name|other
init|=
operator|(
name|CompoundOrder
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|orderElements
argument_list|,
name|other
operator|.
name|orderElements
argument_list|)
return|;
block|}
comment|/**          * {@code Comparator} for sorting buckets by multiple criteria.          */
DECL|class|CompoundOrderComparator
specifier|static
class|class
name|CompoundOrderComparator
implements|implements
name|Comparator
argument_list|<
name|Bucket
argument_list|>
block|{
DECL|field|compoundOrder
specifier|private
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|compoundOrder
decl_stmt|;
DECL|field|aggregator
specifier|private
name|Aggregator
name|aggregator
decl_stmt|;
comment|/**              * Create a new {@code Comparator} for sorting buckets by multiple criteria.              *              * @param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.              * @param aggregator    {@link BucketOrder#comparator(Aggregator)}              */
DECL|method|CompoundOrderComparator
name|CompoundOrderComparator
parameter_list|(
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|compoundOrder
parameter_list|,
name|Aggregator
name|aggregator
parameter_list|)
block|{
name|this
operator|.
name|compoundOrder
operator|=
name|compoundOrder
expr_stmt|;
name|this
operator|.
name|aggregator
operator|=
name|aggregator
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|Bucket
name|b1
parameter_list|,
name|Bucket
name|b2
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|BucketOrder
argument_list|>
name|itr
init|=
name|compoundOrder
operator|.
name|iterator
argument_list|()
init|;
name|itr
operator|.
name|hasNext
argument_list|()
operator|&&
name|result
operator|==
literal|0
condition|;
control|)
block|{
name|result
operator|=
name|itr
operator|.
name|next
argument_list|()
operator|.
name|comparator
argument_list|(
name|aggregator
argument_list|)
operator|.
name|compare
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
block|}
DECL|field|COUNT_DESC_ID
specifier|private
specifier|static
specifier|final
name|byte
name|COUNT_DESC_ID
init|=
literal|1
decl_stmt|;
DECL|field|COUNT_ASC_ID
specifier|private
specifier|static
specifier|final
name|byte
name|COUNT_ASC_ID
init|=
literal|2
decl_stmt|;
DECL|field|KEY_DESC_ID
specifier|private
specifier|static
specifier|final
name|byte
name|KEY_DESC_ID
init|=
literal|3
decl_stmt|;
DECL|field|KEY_ASC_ID
specifier|private
specifier|static
specifier|final
name|byte
name|KEY_ASC_ID
init|=
literal|4
decl_stmt|;
comment|/**      * Order by the (higher) count of each bucket.      */
DECL|field|COUNT_DESC
specifier|static
specifier|final
name|InternalOrder
name|COUNT_DESC
init|=
operator|new
name|InternalOrder
argument_list|(
name|COUNT_DESC_ID
argument_list|,
literal|"_count"
argument_list|,
literal|false
argument_list|,
name|comparingCounts
argument_list|()
operator|.
name|reversed
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Order by the (lower) count of each bucket.      */
DECL|field|COUNT_ASC
specifier|static
specifier|final
name|InternalOrder
name|COUNT_ASC
init|=
operator|new
name|InternalOrder
argument_list|(
name|COUNT_ASC_ID
argument_list|,
literal|"_count"
argument_list|,
literal|true
argument_list|,
name|comparingCounts
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Order by the key of each bucket descending.      */
DECL|field|KEY_DESC
specifier|static
specifier|final
name|InternalOrder
name|KEY_DESC
init|=
operator|new
name|InternalOrder
argument_list|(
name|KEY_DESC_ID
argument_list|,
literal|"_key"
argument_list|,
literal|false
argument_list|,
name|comparingKeys
argument_list|()
operator|.
name|reversed
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Order by the key of each bucket ascending.      */
DECL|field|KEY_ASC
specifier|static
specifier|final
name|InternalOrder
name|KEY_ASC
init|=
operator|new
name|InternalOrder
argument_list|(
name|KEY_ASC_ID
argument_list|,
literal|"_key"
argument_list|,
literal|true
argument_list|,
name|comparingKeys
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * @return compare by {@link Bucket#getDocCount()}.      */
DECL|method|comparingCounts
specifier|private
specifier|static
name|Comparator
argument_list|<
name|Bucket
argument_list|>
name|comparingCounts
parameter_list|()
block|{
return|return
name|Comparator
operator|.
name|comparingLong
argument_list|(
name|Bucket
operator|::
name|getDocCount
argument_list|)
return|;
block|}
comment|/**      * @return compare by {@link Bucket#getKey()} from the appropriate implementation.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|comparingKeys
specifier|private
specifier|static
name|Comparator
argument_list|<
name|Bucket
argument_list|>
name|comparingKeys
parameter_list|()
block|{
return|return
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|b1
operator|instanceof
name|KeyComparable
condition|)
block|{
return|return
operator|(
operator|(
name|KeyComparable
operator|)
name|b1
operator|)
operator|.
name|compareKey
argument_list|(
name|b2
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected order bucket class ["
operator|+
name|b1
operator|.
name|getClass
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|;
block|}
comment|/**      * Determine if the ordering strategy is sorting on bucket count descending.      *      * @param order bucket ordering strategy to check.      * @return {@code true} if the ordering strategy is sorting on bucket count descending, {@code false} otherwise.      */
DECL|method|isCountDesc
specifier|public
specifier|static
name|boolean
name|isCountDesc
parameter_list|(
name|BucketOrder
name|order
parameter_list|)
block|{
return|return
name|isOrder
argument_list|(
name|order
argument_list|,
name|COUNT_DESC
argument_list|)
return|;
block|}
comment|/**      * Determine if the ordering strategy is sorting on bucket key (ascending or descending).      *      * @param order bucket ordering strategy to check.      * @return {@code true} if the ordering strategy is sorting on bucket key, {@code false} otherwise.      */
DECL|method|isKeyOrder
specifier|public
specifier|static
name|boolean
name|isKeyOrder
parameter_list|(
name|BucketOrder
name|order
parameter_list|)
block|{
return|return
name|isOrder
argument_list|(
name|order
argument_list|,
name|KEY_ASC
argument_list|)
operator|||
name|isOrder
argument_list|(
name|order
argument_list|,
name|KEY_DESC
argument_list|)
return|;
block|}
comment|/**      * Determine if the ordering strategy is sorting on bucket key ascending.      *      * @param order bucket ordering strategy to check.      * @return {@code true} if the ordering strategy is sorting on bucket key ascending, {@code false} otherwise.      */
DECL|method|isKeyAsc
specifier|public
specifier|static
name|boolean
name|isKeyAsc
parameter_list|(
name|BucketOrder
name|order
parameter_list|)
block|{
return|return
name|isOrder
argument_list|(
name|order
argument_list|,
name|KEY_ASC
argument_list|)
return|;
block|}
comment|/**      * Determine if the ordering strategy is sorting on bucket key descending.      *      * @param order bucket ordering strategy to check.      * @return {@code true} if the ordering strategy is sorting on bucket key descending, {@code false} otherwise.      */
DECL|method|isKeyDesc
specifier|public
specifier|static
name|boolean
name|isKeyDesc
parameter_list|(
name|BucketOrder
name|order
parameter_list|)
block|{
return|return
name|isOrder
argument_list|(
name|order
argument_list|,
name|KEY_DESC
argument_list|)
return|;
block|}
comment|/**      * Determine if the ordering strategy matches the expected one.      *      * @param order    bucket ordering strategy to check. If this is a {@link CompoundOrder} the first element will be      *                 check instead.      * @param expected expected  bucket ordering strategy.      * @return {@code true} if the order matches, {@code false} otherwise.      */
DECL|method|isOrder
specifier|private
specifier|static
name|boolean
name|isOrder
parameter_list|(
name|BucketOrder
name|order
parameter_list|,
name|BucketOrder
name|expected
parameter_list|)
block|{
if|if
condition|(
name|order
operator|==
name|expected
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|order
operator|instanceof
name|CompoundOrder
condition|)
block|{
comment|// check if its a compound order with the first element that matches
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|orders
init|=
operator|(
operator|(
name|CompoundOrder
operator|)
name|order
operator|)
operator|.
name|orderElements
decl_stmt|;
if|if
condition|(
name|orders
operator|.
name|size
argument_list|()
operator|>=
literal|1
condition|)
block|{
return|return
name|isOrder
argument_list|(
name|orders
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|expected
argument_list|)
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Contains logic for reading/writing {@link BucketOrder} from/to streams.      */
DECL|class|Streams
specifier|public
specifier|static
class|class
name|Streams
block|{
comment|/**          * Read a {@link BucketOrder} from a {@link StreamInput}.          *          * @param in stream with order data to read.          * @return order read from the stream          * @throws IOException on error reading from the stream.          */
DECL|method|readOrder
specifier|public
specifier|static
name|BucketOrder
name|readOrder
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|byte
name|id
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|COUNT_DESC_ID
case|:
return|return
name|COUNT_DESC
return|;
case|case
name|COUNT_ASC_ID
case|:
return|return
name|COUNT_ASC
return|;
case|case
name|KEY_DESC_ID
case|:
return|return
name|KEY_DESC
return|;
case|case
name|KEY_ASC_ID
case|:
return|return
name|KEY_ASC
return|;
case|case
name|Aggregation
operator|.
name|ID
case|:
name|boolean
name|asc
init|=
name|in
operator|.
name|readBoolean
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|in
operator|.
name|readString
argument_list|()
decl_stmt|;
return|return
operator|new
name|Aggregation
argument_list|(
name|key
argument_list|,
name|asc
argument_list|)
return|;
case|case
name|CompoundOrder
operator|.
name|ID
case|:
name|int
name|size
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|BucketOrder
argument_list|>
name|compoundOrder
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|compoundOrder
operator|.
name|add
argument_list|(
name|Streams
operator|.
name|readOrder
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|CompoundOrder
argument_list|(
name|compoundOrder
argument_list|,
literal|false
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown order id ["
operator|+
name|id
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
comment|/**          * ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to read a {@link BucketOrder} from a {@link StreamInput}.          *          * @param in           stream with order data to read.          * @param bwcOrderFlag {@code true} to check {@code in.readBoolean()} in the backwards compat logic before reading          *                     the order. {@code false} to skip this flag (order always present).          * @return order read from the stream          * @throws IOException on error reading from the stream.          */
DECL|method|readHistogramOrder
specifier|public
specifier|static
name|BucketOrder
name|readHistogramOrder
parameter_list|(
name|StreamInput
name|in
parameter_list|,
name|boolean
name|bwcOrderFlag
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_6_0_0_alpha2
argument_list|)
condition|)
block|{
return|return
name|Streams
operator|.
name|readOrder
argument_list|(
name|in
argument_list|)
return|;
block|}
else|else
block|{
comment|// backwards compat logic
if|if
condition|(
name|bwcOrderFlag
operator|==
literal|false
operator|||
name|in
operator|.
name|readBoolean
argument_list|()
condition|)
block|{
comment|// translate the old histogram order IDs to the new order objects
name|byte
name|id
init|=
name|in
operator|.
name|readByte
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
literal|1
case|:
return|return
name|KEY_ASC
return|;
case|case
literal|2
case|:
return|return
name|KEY_DESC
return|;
case|case
literal|3
case|:
return|return
name|COUNT_ASC
return|;
case|case
literal|4
case|:
return|return
name|COUNT_DESC
return|;
case|case
literal|0
case|:
comment|// aggregation order stream logic is backwards compatible
name|boolean
name|asc
init|=
name|in
operator|.
name|readBoolean
argument_list|()
decl_stmt|;
name|String
name|key
init|=
name|in
operator|.
name|readString
argument_list|()
decl_stmt|;
return|return
operator|new
name|Aggregation
argument_list|(
name|key
argument_list|,
name|asc
argument_list|)
return|;
default|default:
comment|// not expecting compound order ID
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown histogram order id ["
operator|+
name|id
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// default to _key asc if no order specified
return|return
name|KEY_ASC
return|;
block|}
block|}
block|}
comment|/**          * Write a {@link BucketOrder} to a {@link StreamOutput}.          *          * @param order order to write to the stream.          * @param out   stream to write the order to.          * @throws IOException on error writing to the stream.          */
DECL|method|writeOrder
specifier|public
specifier|static
name|void
name|writeOrder
parameter_list|(
name|BucketOrder
name|order
parameter_list|,
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|order
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|order
operator|instanceof
name|Aggregation
condition|)
block|{
name|Aggregation
name|aggregationOrder
init|=
operator|(
name|Aggregation
operator|)
name|order
decl_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|aggregationOrder
operator|.
name|asc
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeString
argument_list|(
name|aggregationOrder
operator|.
name|path
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|order
operator|instanceof
name|CompoundOrder
condition|)
block|{
name|CompoundOrder
name|compoundOrder
init|=
operator|(
name|CompoundOrder
operator|)
name|order
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|compoundOrder
operator|.
name|orderElements
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|BucketOrder
name|innerOrder
range|:
name|compoundOrder
operator|.
name|orderElements
control|)
block|{
name|innerOrder
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to write a {@link BucketOrder} to a stream.          *          * @param order        order to write to the stream.          * @param out          stream to write the order to.          * @param bwcOrderFlag {@code true} to always {@code out.writeBoolean(true)} for the backwards compat logic before          *                     writing the order. {@code false} to skip this flag.          * @throws IOException on error writing to the stream.          */
DECL|method|writeHistogramOrder
specifier|public
specifier|static
name|void
name|writeHistogramOrder
parameter_list|(
name|BucketOrder
name|order
parameter_list|,
name|StreamOutput
name|out
parameter_list|,
name|boolean
name|bwcOrderFlag
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_6_0_0_alpha2
argument_list|)
condition|)
block|{
name|order
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// backwards compat logic
if|if
condition|(
name|bwcOrderFlag
condition|)
block|{
comment|// need to add flag that determines if order exists
name|out
operator|.
name|writeBoolean
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// order always exists
block|}
if|if
condition|(
name|order
operator|instanceof
name|CompoundOrder
condition|)
block|{
comment|// older versions do not support histogram compound order; the best we can do here is use the first order.
name|order
operator|=
operator|(
operator|(
name|CompoundOrder
operator|)
name|order
operator|)
operator|.
name|orderElements
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|order
operator|instanceof
name|Aggregation
condition|)
block|{
comment|// aggregation order stream logic is backwards compatible
name|order
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// convert the new order IDs to the old histogram order IDs.
name|byte
name|id
decl_stmt|;
switch|switch
condition|(
name|order
operator|.
name|id
argument_list|()
condition|)
block|{
case|case
name|COUNT_DESC_ID
case|:
name|id
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|COUNT_ASC_ID
case|:
name|id
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|KEY_DESC_ID
case|:
name|id
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|KEY_ASC_ID
case|:
name|id
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"unknown order id ["
operator|+
name|order
operator|.
name|id
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|out
operator|.
name|writeByte
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Contains logic for parsing a {@link BucketOrder} from a {@link XContentParser}.      */
DECL|class|Parser
specifier|public
specifier|static
class|class
name|Parser
block|{
DECL|field|DEPRECATION_LOGGER
specifier|private
specifier|static
specifier|final
name|DeprecationLogger
name|DEPRECATION_LOGGER
init|=
operator|new
name|DeprecationLogger
argument_list|(
name|Loggers
operator|.
name|getLogger
argument_list|(
name|Parser
operator|.
name|class
argument_list|)
argument_list|)
decl_stmt|;
comment|/**          * Parse a {@link BucketOrder} from {@link XContent}.          *          * @param parser  for parsing {@link XContent} that contains the order.          * @param context parsing context.          * @return bucket ordering strategy          * @throws IOException on error a {@link XContent} parsing error.          */
DECL|method|parseOrderParam
specifier|public
specifier|static
name|BucketOrder
name|parseOrderParam
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|QueryParseContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
name|String
name|orderKey
init|=
literal|null
decl_stmt|;
name|boolean
name|orderAsc
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|orderKey
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_STRING
condition|)
block|{
name|String
name|dir
init|=
name|parser
operator|.
name|text
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"asc"
operator|.
name|equalsIgnoreCase
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|orderAsc
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"desc"
operator|.
name|equalsIgnoreCase
argument_list|(
name|dir
argument_list|)
condition|)
block|{
name|orderAsc
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ParsingException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
literal|"Unknown order direction ["
operator|+
name|dir
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|ParsingException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
literal|"Unexpected token ["
operator|+
name|token
operator|+
literal|"] for [order]"
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|orderKey
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ParsingException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
literal|"Must specify at least one field for [order]"
argument_list|)
throw|;
block|}
comment|// _term and _time order deprecated in 6.0; replaced by _key
if|if
condition|(
literal|"_term"
operator|.
name|equals
argument_list|(
name|orderKey
argument_list|)
operator|||
literal|"_time"
operator|.
name|equals
argument_list|(
name|orderKey
argument_list|)
condition|)
block|{
name|DEPRECATION_LOGGER
operator|.
name|deprecated
argument_list|(
literal|"Deprecated aggregation order key [{}] used, replaced by [_key]"
argument_list|,
name|orderKey
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|orderKey
condition|)
block|{
case|case
literal|"_term"
case|:
case|case
literal|"_time"
case|:
case|case
literal|"_key"
case|:
return|return
name|orderAsc
condition|?
name|KEY_ASC
else|:
name|KEY_DESC
return|;
case|case
literal|"_count"
case|:
return|return
name|orderAsc
condition|?
name|COUNT_ASC
else|:
name|COUNT_DESC
return|;
default|default:
comment|// assume all other orders are sorting on a sub-aggregation. Validation occurs later.
return|return
name|aggregation
argument_list|(
name|orderKey
argument_list|,
name|orderAsc
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|id
argument_list|,
name|key
argument_list|,
name|asc
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|InternalOrder
name|other
init|=
operator|(
name|InternalOrder
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|id
argument_list|,
name|other
operator|.
name|id
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|key
argument_list|,
name|other
operator|.
name|key
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|asc
argument_list|,
name|other
operator|.
name|asc
argument_list|)
return|;
block|}
block|}
end_class

end_unit

