begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.gateway
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|util
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|CodecUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|OutputStreamIndexOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|SimpleFSDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutputOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|NamedXContentRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardCopyOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/**  * MetaDataStateFormat is a base class to write checksummed  * XContent based files to one or more directories in a standardized directory structure.  * @param<T> the type of the XContent base data-structure  */
end_comment

begin_class
DECL|class|MetaDataStateFormat
specifier|public
specifier|abstract
class|class
name|MetaDataStateFormat
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|STATE_DIR_NAME
specifier|public
specifier|static
specifier|final
name|String
name|STATE_DIR_NAME
init|=
literal|"_state"
decl_stmt|;
DECL|field|STATE_FILE_EXTENSION
specifier|public
specifier|static
specifier|final
name|String
name|STATE_FILE_EXTENSION
init|=
literal|".st"
decl_stmt|;
DECL|field|STATE_FILE_CODEC
specifier|private
specifier|static
specifier|final
name|String
name|STATE_FILE_CODEC
init|=
literal|"state"
decl_stmt|;
DECL|field|MIN_COMPATIBLE_STATE_FILE_VERSION
specifier|private
specifier|static
specifier|final
name|int
name|MIN_COMPATIBLE_STATE_FILE_VERSION
init|=
literal|0
decl_stmt|;
DECL|field|STATE_FILE_VERSION
specifier|private
specifier|static
specifier|final
name|int
name|STATE_FILE_VERSION
init|=
literal|1
decl_stmt|;
DECL|field|STATE_FILE_VERSION_ES_2X_AND_BELOW
specifier|private
specifier|static
specifier|final
name|int
name|STATE_FILE_VERSION_ES_2X_AND_BELOW
init|=
literal|0
decl_stmt|;
DECL|field|BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
DECL|field|format
specifier|private
specifier|final
name|XContentType
name|format
decl_stmt|;
DECL|field|prefix
specifier|private
specifier|final
name|String
name|prefix
decl_stmt|;
DECL|field|stateFilePattern
specifier|private
specifier|final
name|Pattern
name|stateFilePattern
decl_stmt|;
comment|/**      * Creates a new {@link MetaDataStateFormat} instance      * @param format the format of the x-content      */
DECL|method|MetaDataStateFormat
specifier|protected
name|MetaDataStateFormat
parameter_list|(
name|XContentType
name|format
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
name|this
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|this
operator|.
name|prefix
operator|=
name|prefix
expr_stmt|;
name|this
operator|.
name|stateFilePattern
operator|=
name|Pattern
operator|.
name|compile
argument_list|(
name|Pattern
operator|.
name|quote
argument_list|(
name|prefix
argument_list|)
operator|+
literal|"(\\d+)("
operator|+
name|MetaDataStateFormat
operator|.
name|STATE_FILE_EXTENSION
operator|+
literal|")?"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the {@link XContentType} used to serialize xcontent on write.      */
DECL|method|format
specifier|public
name|XContentType
name|format
parameter_list|()
block|{
return|return
name|format
return|;
block|}
comment|/**      * Writes the given state to the given directories. The state is written to a      * state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it      * doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to      * it's target filename of the pattern<tt>{prefix}{version}.st</tt>.      *      * @param state the state object to write      * @param locations the locations where the state should be written to.      * @throws IOException if an IOException occurs      */
DECL|method|write
specifier|public
specifier|final
name|void
name|write
parameter_list|(
specifier|final
name|T
name|state
parameter_list|,
specifier|final
name|Path
modifier|...
name|locations
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|locations
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Locations must not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|locations
operator|.
name|length
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"One or more locations required"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|maxStateId
init|=
name|findMaxStateId
argument_list|(
name|prefix
argument_list|,
name|locations
argument_list|)
operator|+
literal|1
decl_stmt|;
assert|assert
name|maxStateId
operator|>=
literal|0
operator|:
literal|"maxStateId must be positive but was: ["
operator|+
name|maxStateId
operator|+
literal|"]"
assert|;
specifier|final
name|String
name|fileName
init|=
name|prefix
operator|+
name|maxStateId
operator|+
name|STATE_FILE_EXTENSION
decl_stmt|;
name|Path
name|stateLocation
init|=
name|locations
index|[
literal|0
index|]
operator|.
name|resolve
argument_list|(
name|STATE_DIR_NAME
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|stateLocation
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|tmpStatePath
init|=
name|stateLocation
operator|.
name|resolve
argument_list|(
name|fileName
operator|+
literal|".tmp"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|finalStatePath
init|=
name|stateLocation
operator|.
name|resolve
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
try|try
block|{
specifier|final
name|String
name|resourceDesc
init|=
literal|"MetaDataStateFormat.write(path=\""
operator|+
name|tmpStatePath
operator|+
literal|"\")"
decl_stmt|;
try|try
init|(
name|OutputStreamIndexOutput
name|out
init|=
operator|new
name|OutputStreamIndexOutput
argument_list|(
name|resourceDesc
argument_list|,
name|fileName
argument_list|,
name|Files
operator|.
name|newOutputStream
argument_list|(
name|tmpStatePath
argument_list|)
argument_list|,
name|BUFFER_SIZE
argument_list|)
init|)
block|{
name|CodecUtil
operator|.
name|writeHeader
argument_list|(
name|out
argument_list|,
name|STATE_FILE_CODEC
argument_list|,
name|STATE_FILE_VERSION
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|format
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
name|XContentBuilder
name|builder
init|=
name|newXContentBuilder
argument_list|(
name|format
argument_list|,
operator|new
name|IndexOutputOutputStream
argument_list|(
name|out
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
comment|// this is important since some of the XContentBuilders write bytes on close.
comment|// in order to write the footer we need to prevent closing the actual index input.
block|}
block|}
argument_list|)
init|)
block|{
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
block|{
name|toXContent
argument_list|(
name|builder
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
block|}
name|CodecUtil
operator|.
name|writeFooter
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|fsync
argument_list|(
name|tmpStatePath
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// fsync the state file
name|Files
operator|.
name|move
argument_list|(
name|tmpStatePath
argument_list|,
name|finalStatePath
argument_list|,
name|StandardCopyOption
operator|.
name|ATOMIC_MOVE
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|fsync
argument_list|(
name|stateLocation
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|locations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|stateLocation
operator|=
name|locations
index|[
name|i
index|]
operator|.
name|resolve
argument_list|(
name|STATE_DIR_NAME
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|stateLocation
argument_list|)
expr_stmt|;
name|Path
name|tmpPath
init|=
name|stateLocation
operator|.
name|resolve
argument_list|(
name|fileName
operator|+
literal|".tmp"
argument_list|)
decl_stmt|;
name|Path
name|finalPath
init|=
name|stateLocation
operator|.
name|resolve
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|copy
argument_list|(
name|finalStatePath
argument_list|,
name|tmpPath
argument_list|)
expr_stmt|;
comment|// we are on the same FileSystem / Partition here we can do an atomic move
name|Files
operator|.
name|move
argument_list|(
name|tmpPath
argument_list|,
name|finalPath
argument_list|,
name|StandardCopyOption
operator|.
name|ATOMIC_MOVE
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|fsync
argument_list|(
name|stateLocation
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|// we just fsync the dir here..
block|}
finally|finally
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|tmpPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|tmpStatePath
argument_list|)
expr_stmt|;
block|}
name|cleanupOldFiles
argument_list|(
name|prefix
argument_list|,
name|fileName
argument_list|,
name|locations
argument_list|)
expr_stmt|;
block|}
DECL|method|newXContentBuilder
specifier|protected
name|XContentBuilder
name|newXContentBuilder
parameter_list|(
name|XContentType
name|type
parameter_list|,
name|OutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
return|;
block|}
comment|/**      * Writes the given state to the given XContentBuilder      * Subclasses need to implement this class for theirs specific state.      */
DECL|method|toXContent
specifier|public
specifier|abstract
name|void
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|T
name|state
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Reads a new instance of the state from the given XContentParser      * Subclasses need to implement this class for theirs specific state.      */
DECL|method|fromXContent
specifier|public
specifier|abstract
name|T
name|fromXContent
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Reads the state from a given file and compares the expected version against the actual version of      * the state.      */
DECL|method|read
specifier|public
specifier|final
name|T
name|read
parameter_list|(
name|Path
name|file
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|Directory
name|dir
init|=
name|newDirectory
argument_list|(
name|file
operator|.
name|getParent
argument_list|()
argument_list|)
init|)
block|{
try|try
init|(
specifier|final
name|IndexInput
name|indexInput
init|=
name|dir
operator|.
name|openInput
argument_list|(
name|file
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
init|)
block|{
comment|// We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.
name|CodecUtil
operator|.
name|checksumEntireFile
argument_list|(
name|indexInput
argument_list|)
expr_stmt|;
specifier|final
name|int
name|fileVersion
init|=
name|CodecUtil
operator|.
name|checkHeader
argument_list|(
name|indexInput
argument_list|,
name|STATE_FILE_CODEC
argument_list|,
name|MIN_COMPATIBLE_STATE_FILE_VERSION
argument_list|,
name|STATE_FILE_VERSION
argument_list|)
decl_stmt|;
specifier|final
name|XContentType
name|xContentType
init|=
name|XContentType
operator|.
name|values
argument_list|()
index|[
name|indexInput
operator|.
name|readInt
argument_list|()
index|]
decl_stmt|;
if|if
condition|(
name|fileVersion
operator|==
name|STATE_FILE_VERSION_ES_2X_AND_BELOW
condition|)
block|{
comment|// format version 0, wrote a version that always came from the content state file and was never used
name|indexInput
operator|.
name|readLong
argument_list|()
expr_stmt|;
comment|// version currently unused
block|}
name|long
name|filePointer
init|=
name|indexInput
operator|.
name|getFilePointer
argument_list|()
decl_stmt|;
name|long
name|contentSize
init|=
name|indexInput
operator|.
name|length
argument_list|()
operator|-
name|CodecUtil
operator|.
name|footerLength
argument_list|()
operator|-
name|filePointer
decl_stmt|;
try|try
init|(
name|IndexInput
name|slice
init|=
name|indexInput
operator|.
name|slice
argument_list|(
literal|"state_xcontent"
argument_list|,
name|filePointer
argument_list|,
name|contentSize
argument_list|)
init|)
block|{
comment|// It is safe to use EMPTY here because this never uses namedObject
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|xContentType
argument_list|)
operator|.
name|createParser
argument_list|(
name|NamedXContentRegistry
operator|.
name|EMPTY
argument_list|,
operator|new
name|InputStreamIndexInput
argument_list|(
name|slice
argument_list|,
name|contentSize
argument_list|)
argument_list|)
init|)
block|{
return|return
name|fromXContent
argument_list|(
name|parser
argument_list|)
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|ex
parameter_list|)
block|{
comment|// we trick this into a dedicated exception with the original stacktrace
throw|throw
operator|new
name|CorruptStateException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|newDirectory
specifier|protected
name|Directory
name|newDirectory
parameter_list|(
name|Path
name|dir
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|SimpleFSDirectory
argument_list|(
name|dir
argument_list|)
return|;
block|}
DECL|method|cleanupOldFiles
specifier|private
name|void
name|cleanupOldFiles
parameter_list|(
specifier|final
name|String
name|prefix
parameter_list|,
specifier|final
name|String
name|currentStateFile
parameter_list|,
name|Path
index|[]
name|locations
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|DirectoryStream
operator|.
name|Filter
argument_list|<
name|Path
argument_list|>
name|filter
init|=
operator|new
name|DirectoryStream
operator|.
name|Filter
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|accept
parameter_list|(
name|Path
name|entry
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|entryFileName
init|=
name|entry
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
return|return
name|Files
operator|.
name|isRegularFile
argument_list|(
name|entry
argument_list|)
operator|&&
name|entryFileName
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
comment|// only state files
operator|&&
name|currentStateFile
operator|.
name|equals
argument_list|(
name|entryFileName
argument_list|)
operator|==
literal|false
return|;
comment|// keep the current state file around
block|}
block|}
decl_stmt|;
comment|// now clean up the old files
for|for
control|(
name|Path
name|dataLocation
range|:
name|locations
control|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|dataLocation
operator|.
name|resolve
argument_list|(
name|STATE_DIR_NAME
argument_list|)
argument_list|,
name|filter
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|stateFile
range|:
name|stream
control|)
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|stateFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|findMaxStateId
name|long
name|findMaxStateId
parameter_list|(
specifier|final
name|String
name|prefix
parameter_list|,
name|Path
modifier|...
name|locations
parameter_list|)
throws|throws
name|IOException
block|{
name|long
name|maxId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Path
name|dataLocation
range|:
name|locations
control|)
block|{
specifier|final
name|Path
name|resolve
init|=
name|dataLocation
operator|.
name|resolve
argument_list|(
name|STATE_DIR_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|resolve
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|resolve
argument_list|,
name|prefix
operator|+
literal|"*"
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|stateFile
range|:
name|stream
control|)
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|stateFilePattern
operator|.
name|matcher
argument_list|(
name|stateFile
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
specifier|final
name|long
name|id
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|maxId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxId
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|maxId
return|;
block|}
comment|/**      * Tries to load the latest state from the given data-locations. It tries to load the latest state determined by      * the states version from one or more data directories and if none of the latest states can be loaded an exception      * is thrown to prevent accidentally loading a previous state and silently omitting the latest state.      *      * @param logger a logger instance      * @param dataLocations the data-locations to try.      * @return the latest state or<code>null</code> if no state was found.      */
DECL|method|loadLatestState
specifier|public
name|T
name|loadLatestState
parameter_list|(
name|Logger
name|logger
parameter_list|,
name|Path
modifier|...
name|dataLocations
parameter_list|)
throws|throws
name|IOException
block|{
name|List
argument_list|<
name|PathAndStateId
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|long
name|maxStateId
init|=
operator|-
literal|1
decl_stmt|;
name|boolean
name|maxStateIdIsLegacy
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|dataLocations
operator|!=
literal|null
condition|)
block|{
comment|// select all eligible files first
for|for
control|(
name|Path
name|dataLocation
range|:
name|dataLocations
control|)
block|{
specifier|final
name|Path
name|stateDir
init|=
name|dataLocation
operator|.
name|resolve
argument_list|(
name|STATE_DIR_NAME
argument_list|)
decl_stmt|;
comment|// now, iterate over the current versions, and find latest one
comment|// we don't check if the stateDir is present since it could be deleted
comment|// after the check. Also if there is a _state file and it's not a dir something is really wrong
comment|// we don't pass a glob since we need the group part for parsing
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|paths
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|stateDir
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|stateFile
range|:
name|paths
control|)
block|{
specifier|final
name|Matcher
name|matcher
init|=
name|stateFilePattern
operator|.
name|matcher
argument_list|(
name|stateFile
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
specifier|final
name|long
name|stateId
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|maxStateId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxStateId
argument_list|,
name|stateId
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|legacy
init|=
name|MetaDataStateFormat
operator|.
name|STATE_FILE_EXTENSION
operator|.
name|equals
argument_list|(
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
argument_list|)
operator|==
literal|false
decl_stmt|;
name|maxStateIdIsLegacy
operator|&=
name|legacy
expr_stmt|;
comment|// on purpose, see NOTE below
name|PathAndStateId
name|pav
init|=
operator|new
name|PathAndStateId
argument_list|(
name|stateFile
argument_list|,
name|stateId
argument_list|,
name|legacy
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"found state file: {}"
argument_list|,
name|pav
argument_list|)
expr_stmt|;
name|files
operator|.
name|add
argument_list|(
name|pav
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
decl||
name|FileNotFoundException
name|ex
parameter_list|)
block|{
comment|// no _state directory -- move on
block|}
block|}
block|}
specifier|final
name|List
argument_list|<
name|Throwable
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|T
name|state
init|=
literal|null
decl_stmt|;
comment|// NOTE: we might have multiple version of the latest state if there are multiple data dirs.. for this case
comment|//       we iterate only over the ones with the max version. If we have at least one state file that uses the
comment|//       new format (ie. legacy == false) then we know that the latest version state ought to use this new format.
comment|//       In case the state file with the latest version does not use the new format while older state files do,
comment|//       the list below will be empty and loading the state will fail
name|Collection
argument_list|<
name|PathAndStateId
argument_list|>
name|pathAndStateIds
init|=
name|files
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
operator|new
name|StateIdAndLegacyPredicate
argument_list|(
name|maxStateId
argument_list|,
name|maxStateIdIsLegacy
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toCollection
argument_list|(
name|ArrayList
operator|::
operator|new
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|PathAndStateId
name|pathAndStateId
range|:
name|pathAndStateIds
control|)
block|{
try|try
block|{
specifier|final
name|Path
name|stateFile
init|=
name|pathAndStateId
operator|.
name|file
decl_stmt|;
specifier|final
name|long
name|id
init|=
name|pathAndStateId
operator|.
name|id
decl_stmt|;
if|if
condition|(
name|pathAndStateId
operator|.
name|legacy
condition|)
block|{
comment|// read the legacy format -- plain XContent
specifier|final
name|byte
index|[]
name|data
init|=
name|Files
operator|.
name|readAllBytes
argument_list|(
name|stateFile
argument_list|)
decl_stmt|;
if|if
condition|(
name|data
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{}: no data for [{}], ignoring..."
argument_list|,
name|prefix
argument_list|,
name|stateFile
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// EMPTY is safe here because no parser uses namedObject
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentHelper
operator|.
name|createParser
argument_list|(
name|NamedXContentRegistry
operator|.
name|EMPTY
argument_list|,
operator|new
name|BytesArray
argument_list|(
name|data
argument_list|)
argument_list|)
init|)
block|{
name|state
operator|=
name|fromXContent
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{}: no data for [{}], ignoring..."
argument_list|,
name|prefix
argument_list|,
name|stateFile
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|=
name|read
argument_list|(
name|stateFile
argument_list|)
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"state id [{}] read from [{}]"
argument_list|,
name|id
argument_list|,
name|stateFile
operator|.
name|getFileName
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|state
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
operator|new
name|IOException
argument_list|(
literal|"failed to read "
operator|+
name|pathAndStateId
operator|.
name|toString
argument_list|()
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"{}: failed to read [{}], ignoring..."
argument_list|,
name|pathAndStateId
operator|.
name|file
operator|.
name|toAbsolutePath
argument_list|()
argument_list|,
name|prefix
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// if we reach this something went wrong
name|ExceptionsHelper
operator|.
name|maybeThrowRuntimeAndSuppress
argument_list|(
name|exceptions
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// We have some state files but none of them gave us a usable state
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Could not find a state file to recover from among "
operator|+
name|files
argument_list|)
throw|;
block|}
return|return
name|state
return|;
block|}
comment|/**      * Filters out all {@link org.elasticsearch.gateway.MetaDataStateFormat.PathAndStateId} instances with a different id than      * the given one.      */
DECL|class|StateIdAndLegacyPredicate
specifier|private
specifier|static
specifier|final
class|class
name|StateIdAndLegacyPredicate
implements|implements
name|Predicate
argument_list|<
name|PathAndStateId
argument_list|>
block|{
DECL|field|id
specifier|private
specifier|final
name|long
name|id
decl_stmt|;
DECL|field|legacy
specifier|private
specifier|final
name|boolean
name|legacy
decl_stmt|;
DECL|method|StateIdAndLegacyPredicate
name|StateIdAndLegacyPredicate
parameter_list|(
name|long
name|id
parameter_list|,
name|boolean
name|legacy
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|legacy
operator|=
name|legacy
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|test
specifier|public
name|boolean
name|test
parameter_list|(
name|PathAndStateId
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|id
operator|==
name|id
operator|&&
name|input
operator|.
name|legacy
operator|==
name|legacy
return|;
block|}
block|}
comment|/**      * Internal struct-like class that holds the parsed state id, the file      * and a flag if the file is a legacy state ie. pre 1.5      */
DECL|class|PathAndStateId
specifier|private
specifier|static
class|class
name|PathAndStateId
block|{
DECL|field|file
specifier|final
name|Path
name|file
decl_stmt|;
DECL|field|id
specifier|final
name|long
name|id
decl_stmt|;
DECL|field|legacy
specifier|final
name|boolean
name|legacy
decl_stmt|;
DECL|method|PathAndStateId
specifier|private
name|PathAndStateId
parameter_list|(
name|Path
name|file
parameter_list|,
name|long
name|id
parameter_list|,
name|boolean
name|legacy
parameter_list|)
block|{
name|this
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|this
operator|.
name|legacy
operator|=
name|legacy
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"[id:"
operator|+
name|id
operator|+
literal|", legacy:"
operator|+
name|legacy
operator|+
literal|", file:"
operator|+
name|file
operator|.
name|toAbsolutePath
argument_list|()
operator|+
literal|"]"
return|;
block|}
block|}
comment|/**      * Deletes all meta state directories recursively for the given data locations      * @param dataLocations the data location to delete      */
DECL|method|deleteMetaState
specifier|public
specifier|static
name|void
name|deleteMetaState
parameter_list|(
name|Path
modifier|...
name|dataLocations
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
index|[]
name|stateDirectories
init|=
operator|new
name|Path
index|[
name|dataLocations
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dataLocations
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|stateDirectories
index|[
name|i
index|]
operator|=
name|dataLocations
index|[
name|i
index|]
operator|.
name|resolve
argument_list|(
name|STATE_DIR_NAME
argument_list|)
expr_stmt|;
block|}
name|IOUtils
operator|.
name|rm
argument_list|(
name|stateDirectories
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

