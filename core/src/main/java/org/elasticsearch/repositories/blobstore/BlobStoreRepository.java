begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.repositories.blobstore
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|blobstore
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|util
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimiter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|SnapshotsInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|RepositoryMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Numbers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|UUIDs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|NotXContentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|Streams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|OutputStreamStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|metrics
operator|.
name|CounterMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|iterable
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|set
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|NamedXContentRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ToXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardRestoreFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|BlobStoreIndexShardSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|BlobStoreIndexShardSnapshots
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|RateLimitingInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|SlicedInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|SnapshotFiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|IndexId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryVerificationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|InvalidSnapshotNameException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotMissingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotShardFailure
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryNotEmptyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_comment
comment|/**  * BlobStore - based implementation of Snapshot Repository  *<p>  * This repository works with any {@link BlobStore} implementation. The blobStore should be initialized in the derived  * class before {@link #doStart()} is called.  *<p>  * BlobStoreRepository maintains the following structure in the blob store  *<pre>  * {@code  *   STORE_ROOT  *   |- index-N           - list of all snapshot ids and the indices belonging to each snapshot, N is the generation of the file  *   |- index.latest      - contains the numeric value of the latest generation of the index file (i.e. N from above)  *   |- incompatible-snapshots - list of all snapshot ids that are no longer compatible with the current version of the cluster  *   |- snap-20131010 - JSON serialized Snapshot for snapshot "20131010"  *   |- meta-20131010.dat - JSON serialized MetaData for snapshot "20131010" (includes only global metadata)  *   |- snap-20131011 - JSON serialized Snapshot for snapshot "20131011"  *   |- meta-20131011.dat - JSON serialized MetaData for snapshot "20131011"  *   .....  *   |- indices/ - data for all indices  *      |- Ac1342-B_x/ - data for index "foo" which was assigned the unique id of Ac1342-B_x in the repository  *      |  |- meta-20131010.dat - JSON Serialized IndexMetaData for index "foo"  *      |  |- 0/ - data for shard "0" of index "foo"  *      |  |  |- __1 \  *      |  |  |- __2 |  *      |  |  |- __3 |- files from different segments see snapshot-* for their mappings to real segment files  *      |  |  |- __4 |  *      |  |  |- __5 /  *      |  |  .....  *      |  |  |- snap-20131010.dat - JSON serialized BlobStoreIndexShardSnapshot for snapshot "20131010"  *      |  |  |- snap-20131011.dat - JSON serialized BlobStoreIndexShardSnapshot for snapshot "20131011"  *      |  |  |- list-123 - JSON serialized BlobStoreIndexShardSnapshot for snapshot "20131011"  *      |  |  *      |  |- 1/ - data for shard "1" of index "foo"  *      |  |  |- __1  *      |  |  .....  *      |  |  *      |  |-2/  *      |  ......  *      |  *      |- 1xB0D8_B3y/ - data for index "bar" which was assigned the unique id of 1xB0D8_B3y in the repository  *      ......  * }  *</pre>  */
end_comment

begin_class
DECL|class|BlobStoreRepository
specifier|public
specifier|abstract
class|class
name|BlobStoreRepository
extends|extends
name|AbstractLifecycleComponent
implements|implements
name|Repository
block|{
DECL|field|snapshotsBlobContainer
specifier|private
name|BlobContainer
name|snapshotsBlobContainer
decl_stmt|;
DECL|field|metadata
specifier|protected
specifier|final
name|RepositoryMetaData
name|metadata
decl_stmt|;
DECL|field|namedXContentRegistry
specifier|protected
specifier|final
name|NamedXContentRegistry
name|namedXContentRegistry
decl_stmt|;
DECL|field|BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
DECL|field|SNAPSHOT_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_PREFIX
init|=
literal|"snap-"
decl_stmt|;
DECL|field|SNAPSHOT_CODEC
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_CODEC
init|=
literal|"snapshot"
decl_stmt|;
DECL|field|INDEX_FILE_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|INDEX_FILE_PREFIX
init|=
literal|"index-"
decl_stmt|;
DECL|field|INDEX_LATEST_BLOB
specifier|private
specifier|static
specifier|final
name|String
name|INDEX_LATEST_BLOB
init|=
literal|"index.latest"
decl_stmt|;
DECL|field|INCOMPATIBLE_SNAPSHOTS_BLOB
specifier|private
specifier|static
specifier|final
name|String
name|INCOMPATIBLE_SNAPSHOTS_BLOB
init|=
literal|"incompatible-snapshots"
decl_stmt|;
DECL|field|TESTS_FILE
specifier|private
specifier|static
specifier|final
name|String
name|TESTS_FILE
init|=
literal|"tests-"
decl_stmt|;
DECL|field|METADATA_NAME_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|METADATA_NAME_FORMAT
init|=
literal|"meta-%s.dat"
decl_stmt|;
DECL|field|METADATA_CODEC
specifier|private
specifier|static
specifier|final
name|String
name|METADATA_CODEC
init|=
literal|"metadata"
decl_stmt|;
DECL|field|INDEX_METADATA_CODEC
specifier|private
specifier|static
specifier|final
name|String
name|INDEX_METADATA_CODEC
init|=
literal|"index-metadata"
decl_stmt|;
DECL|field|SNAPSHOT_NAME_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_NAME_FORMAT
init|=
name|SNAPSHOT_PREFIX
operator|+
literal|"%s.dat"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_PREFIX
init|=
literal|"index-"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_NAME_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_NAME_FORMAT
init|=
name|SNAPSHOT_INDEX_PREFIX
operator|+
literal|"%s"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_CODEC
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_CODEC
init|=
literal|"snapshots"
decl_stmt|;
DECL|field|DATA_BLOB_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|DATA_BLOB_PREFIX
init|=
literal|"__"
decl_stmt|;
DECL|field|snapshotRateLimiter
specifier|private
specifier|final
name|RateLimiter
name|snapshotRateLimiter
decl_stmt|;
DECL|field|restoreRateLimiter
specifier|private
specifier|final
name|RateLimiter
name|restoreRateLimiter
decl_stmt|;
DECL|field|snapshotRateLimitingTimeInNanos
specifier|private
specifier|final
name|CounterMetric
name|snapshotRateLimitingTimeInNanos
init|=
operator|new
name|CounterMetric
argument_list|()
decl_stmt|;
DECL|field|restoreRateLimitingTimeInNanos
specifier|private
specifier|final
name|CounterMetric
name|restoreRateLimitingTimeInNanos
init|=
operator|new
name|CounterMetric
argument_list|()
decl_stmt|;
DECL|field|globalMetaDataFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|MetaData
argument_list|>
name|globalMetaDataFormat
decl_stmt|;
DECL|field|indexMetaDataFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|IndexMetaData
argument_list|>
name|indexMetaDataFormat
decl_stmt|;
DECL|field|snapshotFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|SnapshotInfo
argument_list|>
name|snapshotFormat
decl_stmt|;
DECL|field|readOnly
specifier|private
specifier|final
name|boolean
name|readOnly
decl_stmt|;
DECL|field|indexShardSnapshotFormat
specifier|private
specifier|final
name|ChecksumBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotFormat
decl_stmt|;
DECL|field|indexShardSnapshotsFormat
specifier|private
specifier|final
name|ChecksumBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|>
name|indexShardSnapshotsFormat
decl_stmt|;
comment|/**      * Constructs new BlobStoreRepository      *      * @param metadata       The metadata for this repository including name and settings      * @param globalSettings Settings for the node this repository object is created on      */
DECL|method|BlobStoreRepository
specifier|protected
name|BlobStoreRepository
parameter_list|(
name|RepositoryMetaData
name|metadata
parameter_list|,
name|Settings
name|globalSettings
parameter_list|,
name|NamedXContentRegistry
name|namedXContentRegistry
parameter_list|)
block|{
name|super
argument_list|(
name|globalSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|this
operator|.
name|namedXContentRegistry
operator|=
name|namedXContentRegistry
expr_stmt|;
name|snapshotRateLimiter
operator|=
name|getRateLimiter
argument_list|(
name|metadata
operator|.
name|settings
argument_list|()
argument_list|,
literal|"max_snapshot_bytes_per_sec"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|40
argument_list|,
name|ByteSizeUnit
operator|.
name|MB
argument_list|)
argument_list|)
expr_stmt|;
name|restoreRateLimiter
operator|=
name|getRateLimiter
argument_list|(
name|metadata
operator|.
name|settings
argument_list|()
argument_list|,
literal|"max_restore_bytes_per_sec"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|40
argument_list|,
name|ByteSizeUnit
operator|.
name|MB
argument_list|)
argument_list|)
expr_stmt|;
name|readOnly
operator|=
name|metadata
operator|.
name|settings
argument_list|()
operator|.
name|getAsBoolean
argument_list|(
literal|"readonly"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|indexShardSnapshotFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_CODEC
argument_list|,
name|SNAPSHOT_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshot
operator|::
name|fromXContent
argument_list|,
name|namedXContentRegistry
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|indexShardSnapshotsFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_INDEX_CODEC
argument_list|,
name|SNAPSHOT_INDEX_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshots
operator|::
name|fromXContent
argument_list|,
name|namedXContentRegistry
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|this
operator|.
name|snapshotsBlobContainer
operator|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
argument_list|)
expr_stmt|;
name|globalMetaDataFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|METADATA_CODEC
argument_list|,
name|METADATA_NAME_FORMAT
argument_list|,
name|MetaData
operator|::
name|fromXContent
argument_list|,
name|namedXContentRegistry
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|indexMetaDataFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|INDEX_METADATA_CODEC
argument_list|,
name|METADATA_NAME_FORMAT
argument_list|,
name|IndexMetaData
operator|::
name|fromXContent
argument_list|,
name|namedXContentRegistry
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_CODEC
argument_list|,
name|SNAPSHOT_NAME_FORMAT
argument_list|,
name|SnapshotInfo
operator|::
name|fromXContent
argument_list|,
name|namedXContentRegistry
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
block|{}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{
try|try
block|{
name|blobStore
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|t
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"cannot close blob store"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the BlobStore to read and write data.      */
DECL|method|blobStore
specifier|protected
specifier|abstract
name|BlobStore
name|blobStore
parameter_list|()
function_decl|;
comment|/**      * Returns base path of the repository      */
DECL|method|basePath
specifier|protected
specifier|abstract
name|BlobPath
name|basePath
parameter_list|()
function_decl|;
comment|/**      * Returns true if metadata and snapshot files should be compressed      *      * @return true if compression is needed      */
DECL|method|isCompress
specifier|protected
name|boolean
name|isCompress
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Returns data file chunk size.      *<p>      * This method should return null if no chunking is needed.      *      * @return chunk size      */
DECL|method|chunkSize
specifier|protected
name|ByteSizeValue
name|chunkSize
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getMetadata
specifier|public
name|RepositoryMetaData
name|getMetadata
parameter_list|()
block|{
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
DECL|method|initializeSnapshot
specifier|public
name|void
name|initializeSnapshot
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|List
argument_list|<
name|IndexId
argument_list|>
name|indices
parameter_list|,
name|MetaData
name|clusterMetaData
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"cannot create snapshot in a readonly repository"
argument_list|)
throw|;
block|}
try|try
block|{
specifier|final
name|String
name|snapshotName
init|=
name|snapshotId
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// check if the snapshot name already exists in the repository
specifier|final
name|RepositoryData
name|repositoryData
init|=
name|getRepositoryData
argument_list|()
decl_stmt|;
if|if
condition|(
name|repositoryData
operator|.
name|getAllSnapshotIds
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|s
lambda|->
name|s
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
argument_list|new
name|InvalidSnapshotNameException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|,
literal|"snapshot with the same name already exists"
argument_list|)
block|;             }
if|if
condition|(
name|snapshotFormat
operator|.
name|exists
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidSnapshotNameException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|,
literal|"snapshot with the same name already exists"
argument_list|)
throw|;
block|}
comment|// Write Global MetaData
name|globalMetaDataFormat
operator|.
name|write
argument_list|(
name|clusterMetaData
argument_list|,
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
comment|// write the index metadata for each index in the snapshot
for|for
control|(
name|IndexId
name|index
range|:
name|indices
control|)
block|{
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|clusterMetaData
operator|.
name|index
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|BlobPath
name|indexPath
init|=
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|index
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|BlobContainer
name|indexMetaDataBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|indexPath
argument_list|)
decl_stmt|;
name|indexMetaDataFormat
operator|.
name|write
argument_list|(
name|indexMetaData
argument_list|,
name|indexMetaDataBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotCreationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|deleteSnapshot
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|long
name|repositoryStateId
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"cannot delete snapshot from a readonly repository"
argument_list|)
throw|;
block|}
specifier|final
name|RepositoryData
name|repositoryData
init|=
name|getRepositoryData
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|indices
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|SnapshotInfo
name|snapshot
init|=
literal|null
decl_stmt|;
try|try
block|{
name|snapshot
operator|=
name|getSnapshotInfo
argument_list|(
name|snapshotId
argument_list|)
expr_stmt|;
name|indices
operator|=
name|snapshot
operator|.
name|indices
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SnapshotMissingException
name|ex
parameter_list|)
block|{
throw|throw
name|ex
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
decl||
name|SnapshotException
decl||
name|ElasticsearchParseException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"cannot read snapshot file [{}]"
argument_list|,
name|snapshotId
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|MetaData
name|metaData
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|snapshot
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|=
name|readSnapshotMetaData
argument_list|(
name|snapshotId
argument_list|,
name|snapshot
operator|.
name|version
argument_list|()
argument_list|,
name|repositoryData
operator|.
name|resolveIndices
argument_list|(
name|indices
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metaData
operator|=
name|readSnapshotMetaData
argument_list|(
name|snapshotId
argument_list|,
literal|null
argument_list|,
name|repositoryData
operator|.
name|resolveIndices
argument_list|(
name|indices
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|SnapshotException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"cannot read metadata for snapshot [{}]"
argument_list|,
name|snapshotId
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// Delete snapshot from the index file, since it is the maintainer of truth of active snapshots
specifier|final
name|RepositoryData
name|updatedRepositoryData
init|=
name|repositoryData
operator|.
name|removeSnapshot
argument_list|(
name|snapshotId
argument_list|)
decl_stmt|;
name|writeIndexGen
argument_list|(
name|updatedRepositoryData
argument_list|,
name|repositoryStateId
argument_list|)
expr_stmt|;
comment|// delete the snapshot file
name|safeSnapshotBlobDelete
argument_list|(
name|snapshot
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
comment|// delete the global metadata file
name|safeGlobalMetaDataBlobDelete
argument_list|(
name|snapshot
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
comment|// Now delete all indices
for|for
control|(
name|String
name|index
range|:
name|indices
control|)
block|{
specifier|final
name|IndexId
name|indexId
init|=
name|repositoryData
operator|.
name|resolveIndexId
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|BlobPath
name|indexPath
init|=
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|indexId
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|BlobContainer
name|indexMetaDataBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|indexPath
argument_list|)
decl_stmt|;
try|try
block|{
name|indexMetaDataFormat
operator|.
name|delete
argument_list|(
name|indexMetaDataBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] failed to delete metadata for index [{}]"
argument_list|,
name|snapshotId
argument_list|,
name|index
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|IndexMetaData
name|indexMetaData
init|=
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|shardId
init|=
literal|0
init|;
name|shardId
operator|<
name|indexMetaData
operator|.
name|getNumberOfShards
argument_list|()
condition|;
name|shardId
operator|++
control|)
block|{
try|try
block|{
name|delete
argument_list|(
name|snapshotId
argument_list|,
name|snapshot
operator|.
name|version
argument_list|()
argument_list|,
name|indexId
argument_list|,
operator|new
name|ShardId
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SnapshotException
name|ex
parameter_list|)
block|{
specifier|final
name|int
name|finalShardId
init|=
name|shardId
decl_stmt|;
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] failed to delete shard data for shard [{}][{}]"
argument_list|,
name|snapshotId
argument_list|,
name|index
argument_list|,
name|finalShardId
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// cleanup indices that are no longer part of the repository
specifier|final
name|Collection
argument_list|<
name|IndexId
argument_list|>
name|indicesToCleanUp
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|repositoryData
operator|.
name|getIndices
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
decl_stmt|;
name|indicesToCleanUp
operator|.
name|removeAll
argument_list|(
name|updatedRepositoryData
operator|.
name|getIndices
argument_list|()
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|BlobContainer
name|indicesBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|IndexId
name|indexId
range|:
name|indicesToCleanUp
control|)
block|{
try|try
block|{
name|indicesBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|indexId
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|DirectoryNotEmptyException
name|dnee
parameter_list|)
block|{
comment|// if the directory isn't empty for some reason, it will fail to clean up;
comment|// we'll ignore that and accept that cleanup didn't fully succeed.
comment|// since we are using UUIDs for path names, this won't be an issue for
comment|// snapshotting indices of the same name
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] index [{}] no longer part of any snapshots in the repository, but failed to clean up "
operator|+
literal|"its index folder due to the directory not being empty."
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|indexId
argument_list|)
argument_list|,
name|dnee
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// a different IOException occurred while trying to delete - will just log the issue for now
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] index [{}] no longer part of any snapshots in the repository, but failed to clean up "
operator|+
literal|"its index folder."
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|indexId
argument_list|)
argument_list|,
name|ioe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"failed to update snapshot in repository"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|safeSnapshotBlobDelete
specifier|private
name|void
name|safeSnapshotBlobDelete
parameter_list|(
specifier|final
name|SnapshotInfo
name|snapshotInfo
parameter_list|,
specifier|final
name|String
name|blobId
parameter_list|)
block|{
if|if
condition|(
name|snapshotInfo
operator|!=
literal|null
condition|)
block|{
comment|// we know the version the snapshot was created with
try|try
block|{
name|snapshotFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] Unable to delete snapshot file [{}]"
argument_list|,
name|snapshotInfo
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|blobId
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|snapshotFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// snapshot file could not be deleted, log the error
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"Unable to delete snapshot file [{}]"
argument_list|,
name|blobId
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|safeGlobalMetaDataBlobDelete
specifier|private
name|void
name|safeGlobalMetaDataBlobDelete
parameter_list|(
specifier|final
name|SnapshotInfo
name|snapshotInfo
parameter_list|,
specifier|final
name|String
name|blobId
parameter_list|)
block|{
if|if
condition|(
name|snapshotInfo
operator|!=
literal|null
condition|)
block|{
comment|// we know the version the snapshot was created with
try|try
block|{
name|globalMetaDataFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] Unable to delete global metadata file [{}]"
argument_list|,
name|snapshotInfo
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|blobId
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
try|try
block|{
name|globalMetaDataFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// global metadata file could not be deleted, log the error
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"Unable to delete global metadata file [{}]"
argument_list|,
name|blobId
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|finalizeSnapshot
specifier|public
name|SnapshotInfo
name|finalizeSnapshot
parameter_list|(
specifier|final
name|SnapshotId
name|snapshotId
parameter_list|,
specifier|final
name|List
argument_list|<
name|IndexId
argument_list|>
name|indices
parameter_list|,
specifier|final
name|long
name|startTime
parameter_list|,
specifier|final
name|String
name|failure
parameter_list|,
specifier|final
name|int
name|totalShards
parameter_list|,
specifier|final
name|List
argument_list|<
name|SnapshotShardFailure
argument_list|>
name|shardFailures
parameter_list|,
specifier|final
name|long
name|repositoryStateId
parameter_list|)
block|{
try|try
block|{
name|SnapshotInfo
name|blobStoreSnapshot
init|=
operator|new
name|SnapshotInfo
argument_list|(
name|snapshotId
argument_list|,
name|indices
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|IndexId
operator|::
name|getName
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|,
name|startTime
argument_list|,
name|failure
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|totalShards
argument_list|,
name|shardFailures
argument_list|)
decl_stmt|;
name|snapshotFormat
operator|.
name|write
argument_list|(
name|blobStoreSnapshot
argument_list|,
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|RepositoryData
name|repositoryData
init|=
name|getRepositoryData
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SnapshotId
argument_list|>
name|snapshotIds
init|=
name|repositoryData
operator|.
name|getSnapshotIds
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|snapshotIds
operator|.
name|contains
argument_list|(
name|snapshotId
argument_list|)
condition|)
block|{
name|writeIndexGen
argument_list|(
name|repositoryData
operator|.
name|addSnapshot
argument_list|(
name|snapshotId
argument_list|,
name|indices
argument_list|)
argument_list|,
name|repositoryStateId
argument_list|)
expr_stmt|;
block|}
return|return
name|blobStoreSnapshot
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"failed to update snapshot in repository"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getSnapshotMetaData
specifier|public
name|MetaData
name|getSnapshotMetaData
parameter_list|(
name|SnapshotInfo
name|snapshot
parameter_list|,
name|List
argument_list|<
name|IndexId
argument_list|>
name|indices
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readSnapshotMetaData
argument_list|(
name|snapshot
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|snapshot
operator|.
name|version
argument_list|()
argument_list|,
name|indices
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getSnapshotInfo
specifier|public
name|SnapshotInfo
name|getSnapshotInfo
parameter_list|(
specifier|final
name|SnapshotId
name|snapshotId
parameter_list|)
block|{
try|try
block|{
return|return
name|snapshotFormat
operator|.
name|read
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotMissingException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|NotXContentException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"failed to get snapshots"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|readSnapshotMetaData
specifier|private
name|MetaData
name|readSnapshotMetaData
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|snapshotVersion
parameter_list|,
name|List
argument_list|<
name|IndexId
argument_list|>
name|indices
parameter_list|,
name|boolean
name|ignoreIndexErrors
parameter_list|)
throws|throws
name|IOException
block|{
name|MetaData
name|metaData
decl_stmt|;
if|if
condition|(
name|snapshotVersion
operator|==
literal|null
condition|)
block|{
comment|// When we delete corrupted snapshots we might not know which version we are dealing with
comment|// We can try detecting the version based on the metadata file format
assert|assert
name|ignoreIndexErrors
assert|;
if|if
condition|(
name|globalMetaDataFormat
operator|.
name|exists
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
condition|)
block|{
name|snapshotVersion
operator|=
name|Version
operator|.
name|CURRENT
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|SnapshotMissingException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|metaData
operator|=
name|globalMetaDataFormat
operator|.
name|read
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotMissingException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"failed to get snapshots"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|MetaData
operator|.
name|Builder
name|metaDataBuilder
init|=
name|MetaData
operator|.
name|builder
argument_list|(
name|metaData
argument_list|)
decl_stmt|;
for|for
control|(
name|IndexId
name|index
range|:
name|indices
control|)
block|{
name|BlobPath
name|indexPath
init|=
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|index
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
name|BlobContainer
name|indexMetaDataBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|indexPath
argument_list|)
decl_stmt|;
try|try
block|{
name|metaDataBuilder
operator|.
name|put
argument_list|(
name|indexMetaDataFormat
operator|.
name|read
argument_list|(
name|indexMetaDataBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ElasticsearchParseException
decl||
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ignoreIndexErrors
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] [{}] failed to read metadata for index"
argument_list|,
name|snapshotId
argument_list|,
name|index
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
return|return
name|metaDataBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Configures RateLimiter based on repository and global settings      *      * @param repositorySettings repository settings      * @param setting            setting to use to configure rate limiter      * @param defaultRate        default limiting rate      * @return rate limiter or null of no throttling is needed      */
DECL|method|getRateLimiter
specifier|private
name|RateLimiter
name|getRateLimiter
parameter_list|(
name|Settings
name|repositorySettings
parameter_list|,
name|String
name|setting
parameter_list|,
name|ByteSizeValue
name|defaultRate
parameter_list|)
block|{
name|ByteSizeValue
name|maxSnapshotBytesPerSec
init|=
name|repositorySettings
operator|.
name|getAsBytesSize
argument_list|(
name|setting
argument_list|,
name|settings
operator|.
name|getAsBytesSize
argument_list|(
name|setting
argument_list|,
name|defaultRate
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxSnapshotBytesPerSec
operator|.
name|getBytes
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|RateLimiter
operator|.
name|SimpleRateLimiter
argument_list|(
name|maxSnapshotBytesPerSec
operator|.
name|getMbFrac
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getSnapshotThrottleTimeInNanos
specifier|public
name|long
name|getSnapshotThrottleTimeInNanos
parameter_list|()
block|{
return|return
name|snapshotRateLimitingTimeInNanos
operator|.
name|count
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getRestoreThrottleTimeInNanos
specifier|public
name|long
name|getRestoreThrottleTimeInNanos
parameter_list|()
block|{
return|return
name|restoreRateLimitingTimeInNanos
operator|.
name|count
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|startVerification
specifier|public
name|String
name|startVerification
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
comment|// It's readonly - so there is not much we can do here to verify it
return|return
literal|null
return|;
block|}
else|else
block|{
name|String
name|seed
init|=
name|UUIDs
operator|.
name|randomBase64UUID
argument_list|()
decl_stmt|;
name|byte
index|[]
name|testBytes
init|=
name|Strings
operator|.
name|toUTF8Bytes
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|BlobContainer
name|testContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|blobName
init|=
literal|"master.dat"
decl_stmt|;
name|BytesArray
name|bytes
init|=
operator|new
name|BytesArray
argument_list|(
name|testBytes
argument_list|)
decl_stmt|;
try|try
init|(
name|InputStream
name|stream
init|=
name|bytes
operator|.
name|streamInput
argument_list|()
init|)
block|{
name|testContainer
operator|.
name|writeBlob
argument_list|(
name|blobName
operator|+
literal|"-temp"
argument_list|,
name|stream
argument_list|,
name|bytes
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Make sure that move is supported
name|testContainer
operator|.
name|move
argument_list|(
name|blobName
operator|+
literal|"-temp"
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
return|return
name|seed
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"path "
operator|+
name|basePath
argument_list|()
operator|+
literal|" is not accessible on master node"
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|endVerification
specifier|public
name|void
name|endVerification
parameter_list|(
name|String
name|seed
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"shouldn't be called"
argument_list|)
throw|;
block|}
try|try
block|{
name|blobStore
argument_list|()
operator|.
name|delete
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"cannot delete test data at "
operator|+
name|basePath
argument_list|()
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getRepositoryData
specifier|public
name|RepositoryData
name|getRepositoryData
parameter_list|()
block|{
try|try
block|{
specifier|final
name|long
name|indexGen
init|=
name|latestIndexBlobId
argument_list|()
decl_stmt|;
specifier|final
name|String
name|snapshotsIndexBlobName
init|=
name|INDEX_FILE_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|indexGen
argument_list|)
decl_stmt|;
name|RepositoryData
name|repositoryData
decl_stmt|;
try|try
init|(
name|InputStream
name|blob
init|=
name|snapshotsBlobContainer
operator|.
name|readBlob
argument_list|(
name|snapshotsIndexBlobName
argument_list|)
init|)
block|{
name|BytesStreamOutput
name|out
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|Streams
operator|.
name|copy
argument_list|(
name|blob
argument_list|,
name|out
argument_list|)
expr_stmt|;
comment|// EMPTY is safe here because RepositoryData#fromXContent calls namedObject
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentHelper
operator|.
name|createParser
argument_list|(
name|NamedXContentRegistry
operator|.
name|EMPTY
argument_list|,
name|out
operator|.
name|bytes
argument_list|()
argument_list|)
init|)
block|{
name|repositoryData
operator|=
name|RepositoryData
operator|.
name|snapshotsFromXContent
argument_list|(
name|parser
argument_list|,
name|indexGen
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotXContentException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] index blob is not valid x-content [{} bytes]"
argument_list|,
name|snapshotsIndexBlobName
argument_list|,
name|out
operator|.
name|bytes
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
comment|// now load the incompatible snapshot ids, if they exist
try|try
init|(
name|InputStream
name|blob
init|=
name|snapshotsBlobContainer
operator|.
name|readBlob
argument_list|(
name|INCOMPATIBLE_SNAPSHOTS_BLOB
argument_list|)
init|)
block|{
name|BytesStreamOutput
name|out
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|Streams
operator|.
name|copy
argument_list|(
name|blob
argument_list|,
name|out
argument_list|)
expr_stmt|;
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentHelper
operator|.
name|createParser
argument_list|(
name|NamedXContentRegistry
operator|.
name|EMPTY
argument_list|,
name|out
operator|.
name|bytes
argument_list|()
argument_list|)
init|)
block|{
name|repositoryData
operator|=
name|repositoryData
operator|.
name|incompatibleSnapshotsFromXContent
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
name|e
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] Incompatible snapshots blob [{}] does not exist, the likely "
operator|+
literal|"reason is that there are no incompatible snapshots in the repository"
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|INCOMPATIBLE_SNAPSHOTS_BLOB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// write an empty incompatible-snapshots blob - we do this so that there
comment|// is a blob present, which helps speed up some cloud-based repositories
comment|// (e.g. S3), which retry if a blob is missing with exponential backoff,
comment|// delaying the read of repository data and sometimes causing a timeout
name|writeIncompatibleSnapshots
argument_list|(
name|RepositoryData
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|repositoryData
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
name|ex
parameter_list|)
block|{
comment|// repository doesn't have an index blob, its a new blank repo
return|return
name|RepositoryData
operator|.
name|EMPTY
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"could not read repository data from index blob"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
DECL|method|testBlobPrefix
specifier|public
specifier|static
name|String
name|testBlobPrefix
parameter_list|(
name|String
name|seed
parameter_list|)
block|{
return|return
name|TESTS_FILE
operator|+
name|seed
return|;
block|}
annotation|@
name|Override
DECL|method|isReadOnly
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
comment|// package private, only use for testing
DECL|method|blobContainer
name|BlobContainer
name|blobContainer
parameter_list|()
block|{
return|return
name|snapshotsBlobContainer
return|;
block|}
DECL|method|writeIndexGen
specifier|protected
name|void
name|writeIndexGen
parameter_list|(
specifier|final
name|RepositoryData
name|repositoryData
parameter_list|,
specifier|final
name|long
name|repositoryStateId
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|isReadOnly
argument_list|()
operator|==
literal|false
assert|;
comment|// can not write to a read only repository
specifier|final
name|long
name|currentGen
init|=
name|latestIndexBlobId
argument_list|()
decl_stmt|;
if|if
condition|(
name|repositoryStateId
operator|!=
name|SnapshotsInProgress
operator|.
name|UNDEFINED_REPOSITORY_STATE_ID
operator|&&
name|currentGen
operator|!=
name|repositoryStateId
condition|)
block|{
comment|// the index file was updated by a concurrent operation, so we were operating on stale
comment|// repository data
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"concurrent modification of the index-N file, expected current generation ["
operator|+
name|repositoryStateId
operator|+
literal|"], actual current generation ["
operator|+
name|currentGen
operator|+
literal|"] - possibly due to simultaneous snapshot deletion requests"
argument_list|)
throw|;
block|}
specifier|final
name|long
name|newGen
init|=
name|currentGen
operator|+
literal|1
decl_stmt|;
specifier|final
name|BytesReference
name|snapshotsBytes
decl_stmt|;
try|try
init|(
name|BytesStreamOutput
name|bStream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
init|)
block|{
try|try
init|(
name|StreamOutput
name|stream
init|=
operator|new
name|OutputStreamStreamOutput
argument_list|(
name|bStream
argument_list|)
init|)
block|{
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|XContentType
operator|.
name|JSON
argument_list|,
name|stream
argument_list|)
decl_stmt|;
name|repositoryData
operator|.
name|snapshotsToXContent
argument_list|(
name|builder
argument_list|,
name|ToXContent
operator|.
name|EMPTY_PARAMS
argument_list|)
expr_stmt|;
name|builder
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|snapshotsBytes
operator|=
name|bStream
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
comment|// write the index file
name|writeAtomic
argument_list|(
name|INDEX_FILE_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|newGen
argument_list|)
argument_list|,
name|snapshotsBytes
argument_list|)
expr_stmt|;
comment|// delete the N-2 index file if it exists, keep the previous one around as a backup
if|if
condition|(
name|isReadOnly
argument_list|()
operator|==
literal|false
operator|&&
name|newGen
operator|-
literal|2
operator|>=
literal|0
condition|)
block|{
specifier|final
name|String
name|oldSnapshotIndexFile
init|=
name|INDEX_FILE_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|newGen
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotsBlobContainer
operator|.
name|blobExists
argument_list|(
name|oldSnapshotIndexFile
argument_list|)
condition|)
block|{
name|snapshotsBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|oldSnapshotIndexFile
argument_list|)
expr_stmt|;
block|}
block|}
comment|// write the current generation to the index-latest file
specifier|final
name|BytesReference
name|genBytes
decl_stmt|;
try|try
init|(
name|BytesStreamOutput
name|bStream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
init|)
block|{
name|bStream
operator|.
name|writeLong
argument_list|(
name|newGen
argument_list|)
expr_stmt|;
name|genBytes
operator|=
name|bStream
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|snapshotsBlobContainer
operator|.
name|blobExists
argument_list|(
name|INDEX_LATEST_BLOB
argument_list|)
condition|)
block|{
name|snapshotsBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|INDEX_LATEST_BLOB
argument_list|)
expr_stmt|;
block|}
name|writeAtomic
argument_list|(
name|INDEX_LATEST_BLOB
argument_list|,
name|genBytes
argument_list|)
expr_stmt|;
block|}
comment|/**      * Writes the incompatible snapshot ids list to the `incompatible-snapshots` blob in the repository.      *      * Package private for testing.      */
DECL|method|writeIncompatibleSnapshots
name|void
name|writeIncompatibleSnapshots
parameter_list|(
name|RepositoryData
name|repositoryData
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|isReadOnly
argument_list|()
operator|==
literal|false
assert|;
comment|// can not write to a read only repository
specifier|final
name|BytesReference
name|bytes
decl_stmt|;
try|try
init|(
name|BytesStreamOutput
name|bStream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
init|)
block|{
try|try
init|(
name|StreamOutput
name|stream
init|=
operator|new
name|OutputStreamStreamOutput
argument_list|(
name|bStream
argument_list|)
init|)
block|{
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|XContentType
operator|.
name|JSON
argument_list|,
name|stream
argument_list|)
decl_stmt|;
name|repositoryData
operator|.
name|incompatibleSnapshotsToXContent
argument_list|(
name|builder
argument_list|,
name|ToXContent
operator|.
name|EMPTY_PARAMS
argument_list|)
expr_stmt|;
name|builder
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|bytes
operator|=
name|bStream
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|snapshotsBlobContainer
operator|.
name|blobExists
argument_list|(
name|INCOMPATIBLE_SNAPSHOTS_BLOB
argument_list|)
condition|)
block|{
name|snapshotsBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|INCOMPATIBLE_SNAPSHOTS_BLOB
argument_list|)
expr_stmt|;
block|}
comment|// write the incompatible snapshots blob
name|writeAtomic
argument_list|(
name|INCOMPATIBLE_SNAPSHOTS_BLOB
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is      * the next version number from when the index blob was written.  Each individual index-N blob is      * only written once and never overwritten.  The highest numbered index-N blob is the latest one      * that contains the current snapshots in the repository.      *      * Package private for testing      */
DECL|method|latestIndexBlobId
name|long
name|latestIndexBlobId
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
comment|// First, try listing all index-N blobs (there should only be two index-N blobs at any given
comment|// time in a repository if cleanup is happening properly) and pick the index-N blob with the
comment|// highest N value - this will be the latest index blob for the repository.  Note, we do this
comment|// instead of directly reading the index.latest blob to get the current index-N blob because
comment|// index.latest is not written atomically and is not immutable - on every index-N change,
comment|// we first delete the old index.latest and then write the new one.  If the repository is not
comment|// read-only, it is possible that we try deleting the index.latest blob while it is being read
comment|// by some other operation (such as the get snapshots operation).  In some file systems, it is
comment|// illegal to delete a file while it is being read elsewhere (e.g. Windows).  For read-only
comment|// repositories, we read for index.latest, both because listing blob prefixes is often unsupported
comment|// and because the index.latest blob will never be deleted and re-written.
return|return
name|listBlobsToGetLatestIndexId
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// If its a read-only repository, listing blobs by prefix may not be supported (e.g. a URL repository),
comment|// in this case, try reading the latest index generation from the index.latest blob
try|try
block|{
return|return
name|readSnapshotIndexLatestBlob
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
name|nsfe
parameter_list|)
block|{
return|return
name|RepositoryData
operator|.
name|EMPTY_REPO_GEN
return|;
block|}
block|}
block|}
comment|// package private for testing
DECL|method|readSnapshotIndexLatestBlob
name|long
name|readSnapshotIndexLatestBlob
parameter_list|()
throws|throws
name|IOException
block|{
try|try
init|(
name|InputStream
name|blob
init|=
name|snapshotsBlobContainer
operator|.
name|readBlob
argument_list|(
name|INDEX_LATEST_BLOB
argument_list|)
init|)
block|{
name|BytesStreamOutput
name|out
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|Streams
operator|.
name|copy
argument_list|(
name|blob
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|Numbers
operator|.
name|bytesToLong
argument_list|(
name|out
operator|.
name|bytes
argument_list|()
operator|.
name|toBytesRef
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|listBlobsToGetLatestIndexId
specifier|private
name|long
name|listBlobsToGetLatestIndexId
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
init|=
name|snapshotsBlobContainer
operator|.
name|listBlobsByPrefix
argument_list|(
name|INDEX_FILE_PREFIX
argument_list|)
decl_stmt|;
name|long
name|latest
init|=
name|RepositoryData
operator|.
name|EMPTY_REPO_GEN
decl_stmt|;
if|if
condition|(
name|blobs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no snapshot index blobs have been written yet
return|return
name|latest
return|;
block|}
for|for
control|(
specifier|final
name|BlobMetaData
name|blobMetaData
range|:
name|blobs
operator|.
name|values
argument_list|()
control|)
block|{
specifier|final
name|String
name|blobName
init|=
name|blobMetaData
operator|.
name|name
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|long
name|curr
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|blobName
operator|.
name|substring
argument_list|(
name|INDEX_FILE_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|latest
operator|=
name|Math
operator|.
name|max
argument_list|(
name|latest
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// the index- blob wasn't of the format index-N where N is a number,
comment|// no idea what this blob is but it doesn't belong in the repository!
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] Unknown blob in the repository: {}"
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|latest
return|;
block|}
DECL|method|writeAtomic
specifier|private
name|void
name|writeAtomic
parameter_list|(
specifier|final
name|String
name|blobName
parameter_list|,
specifier|final
name|BytesReference
name|bytesRef
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|tempBlobName
init|=
literal|"pending-"
operator|+
name|blobName
operator|+
literal|"-"
operator|+
name|UUIDs
operator|.
name|randomBase64UUID
argument_list|()
decl_stmt|;
try|try
init|(
name|InputStream
name|stream
init|=
name|bytesRef
operator|.
name|streamInput
argument_list|()
init|)
block|{
name|snapshotsBlobContainer
operator|.
name|writeBlob
argument_list|(
name|tempBlobName
argument_list|,
name|stream
argument_list|,
name|bytesRef
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotsBlobContainer
operator|.
name|move
argument_list|(
name|tempBlobName
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// temporary blob creation or move failed - try cleaning up
try|try
block|{
name|snapshotsBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|tempBlobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|ex
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ex
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|snapshotShard
specifier|public
name|void
name|snapshotShard
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|IndexCommit
name|snapshotIndexCommit
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|SnapshotContext
name|snapshotContext
init|=
operator|new
name|SnapshotContext
argument_list|(
name|shard
argument_list|,
name|snapshotId
argument_list|,
name|indexId
argument_list|,
name|snapshotStatus
argument_list|)
decl_stmt|;
name|snapshotStatus
operator|.
name|startTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|snapshotContext
operator|.
name|snapshot
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|failure
argument_list|(
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|IndexShardSnapshotFailedException
condition|)
block|{
throw|throw
operator|(
name|IndexShardSnapshotFailedException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|restoreShard
specifier|public
name|void
name|restoreShard
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
block|{
specifier|final
name|RestoreContext
name|snapshotContext
init|=
operator|new
name|RestoreContext
argument_list|(
name|shard
argument_list|,
name|snapshotId
argument_list|,
name|version
argument_list|,
name|indexId
argument_list|,
name|snapshotShardId
argument_list|,
name|recoveryState
argument_list|)
decl_stmt|;
try|try
block|{
name|snapshotContext
operator|.
name|restore
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"failed to restore snapshot ["
operator|+
name|snapshotId
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getShardSnapshotStatus
specifier|public
name|IndexShardSnapshotStatus
name|getShardSnapshotStatus
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|indexId
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|context
operator|.
name|loadSnapshot
argument_list|()
decl_stmt|;
name|IndexShardSnapshotStatus
name|status
init|=
operator|new
name|IndexShardSnapshotStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
name|status
operator|.
name|startTime
argument_list|(
name|snapshot
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|files
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// The snapshot is done which means the number of processed files is the same as total
name|status
operator|.
name|processedFiles
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|time
argument_list|(
name|snapshot
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
annotation|@
name|Override
DECL|method|verify
specifier|public
name|void
name|verify
parameter_list|(
name|String
name|seed
parameter_list|,
name|DiscoveryNode
name|localNode
parameter_list|)
block|{
name|BlobContainer
name|testBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|testBlobContainer
operator|.
name|blobExists
argument_list|(
literal|"master.dat"
argument_list|)
condition|)
block|{
try|try
block|{
name|BytesArray
name|bytes
init|=
operator|new
name|BytesArray
argument_list|(
name|seed
argument_list|)
decl_stmt|;
try|try
init|(
name|InputStream
name|stream
init|=
name|bytes
operator|.
name|streamInput
argument_list|()
init|)
block|{
name|testBlobContainer
operator|.
name|writeBlob
argument_list|(
literal|"data-"
operator|+
name|localNode
operator|.
name|getId
argument_list|()
operator|+
literal|".dat"
argument_list|,
name|stream
argument_list|,
name|bytes
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"store location ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|"] is not accessible on the node ["
operator|+
name|localNode
operator|+
literal|"]"
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"a file written by master to the store ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|"] cannot be accessed on the node ["
operator|+
name|localNode
operator|+
literal|"]. "
operator|+
literal|"This might indicate that the store ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|"] is not shared between this node and the master node or "
operator|+
literal|"that permissions on the store don't allow reading files written by the master node"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Delete shard snapshot      *      * @param snapshotId snapshot id      * @param shardId    shard id      */
DECL|method|delete
specifier|private
name|void
name|delete
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|indexId
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|context
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BlobStoreRepository["
operator|+
literal|"["
operator|+
name|metadata
operator|.
name|name
argument_list|()
operator|+
literal|"], ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|']'
operator|+
literal|']'
return|;
block|}
DECL|method|indexShardSnapshotFormat
name|BlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotFormat
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
return|return
name|indexShardSnapshotFormat
return|;
block|}
comment|/**      * Context for snapshot/restore operations      */
DECL|class|Context
specifier|private
class|class
name|Context
block|{
DECL|field|snapshotId
specifier|protected
specifier|final
name|SnapshotId
name|snapshotId
decl_stmt|;
DECL|field|shardId
specifier|protected
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|field|blobContainer
specifier|protected
specifier|final
name|BlobContainer
name|blobContainer
decl_stmt|;
DECL|field|version
specifier|protected
specifier|final
name|Version
name|version
decl_stmt|;
DECL|method|Context
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|this
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|indexId
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
DECL|method|Context
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|)
block|{
name|this
operator|.
name|snapshotId
operator|=
name|snapshotId
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|blobContainer
operator|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|indexId
operator|.
name|getId
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|snapshotShardId
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**          * Delete shard snapshot          */
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to list content of gateway"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|tuple
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|tuple
operator|.
name|v1
argument_list|()
decl_stmt|;
name|int
name|fileListGeneration
init|=
name|tuple
operator|.
name|v2
argument_list|()
decl_stmt|;
try|try
block|{
name|indexShardSnapshotFormat
argument_list|(
name|version
argument_list|)
operator|.
name|delete
argument_list|(
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] failed to delete shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
comment|// Build a list of snapshots that should be preserved
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|newSnapshotsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SnapshotFiles
name|point
range|:
name|snapshots
control|)
block|{
if|if
condition|(
operator|!
name|point
operator|.
name|snapshot
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
comment|// finalize the snapshot and rewrite the snapshot index with the next sequential snapshot index
name|finalize
argument_list|(
name|newSnapshotsList
argument_list|,
name|fileListGeneration
operator|+
literal|1
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
block|}
comment|/**          * Loads information about shard snapshot          */
DECL|method|loadSnapshot
specifier|public
name|BlobStoreIndexShardSnapshot
name|loadSnapshot
parameter_list|()
block|{
try|try
block|{
return|return
name|indexShardSnapshotFormat
argument_list|(
name|version
argument_list|)
operator|.
name|read
argument_list|(
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"failed to read shard snapshot file for "
operator|+
name|shardId
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**          * Removes all unreferenced files from the repository and writes new index file          *          * We need to be really careful in handling index files in case of failures to make sure we have index file that          * points to files that were deleted.          *          *          * @param snapshots list of active snapshots in the container          * @param fileListGeneration the generation number of the snapshot index file          * @param blobs     list of blobs in the container          */
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|(
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|snapshots
parameter_list|,
name|int
name|fileListGeneration
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobStoreIndexShardSnapshots
name|newSnapshots
init|=
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
decl_stmt|;
comment|// delete old index files first
for|for
control|(
name|String
name|blobName
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|indexShardSnapshotsFormat
operator|.
name|isTempBlobName
argument_list|(
name|blobName
argument_list|)
operator|||
name|blobName
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// We cannot delete index file - this is fatal, we cannot continue, otherwise we might end up
comment|// with references to non-existing files
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"error deleting index file ["
operator|+
name|blobName
operator|+
literal|"] during cleanup"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// now go over all the blobs, and if they don't exist in a snapshot, delete them
for|for
control|(
name|String
name|blobName
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// delete unused files
if|if
condition|(
name|blobName
operator|.
name|startsWith
argument_list|(
name|DATA_BLOB_PREFIX
argument_list|)
condition|)
block|{
if|if
condition|(
name|newSnapshots
operator|.
name|findNameFile
argument_list|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|blobName
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// TODO: don't catch and let the user handle it?
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] [{}] error deleting blob [{}] during cleanup"
argument_list|,
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|blobName
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// If we deleted all snapshots - we don't need to create the index file
if|if
condition|(
name|snapshots
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|indexShardSnapshotsFormat
operator|.
name|writeAtomic
argument_list|(
name|newSnapshots
argument_list|,
name|blobContainer
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|fileListGeneration
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to write file list"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**          * Generates blob name          *          * @param generation the blob number          * @return the blob name          */
DECL|method|fileNameFromGeneration
specifier|protected
name|String
name|fileNameFromGeneration
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
return|return
name|DATA_BLOB_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|generation
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
comment|/**          * Finds the next available blob number          *          * @param blobs list of blobs in the repository          * @return next available blob number          */
DECL|method|findLatestFileNameGeneration
specifier|protected
name|long
name|findLatestFileNameGeneration
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|long
name|generation
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|DATA_BLOB_PREFIX
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|currentGen
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|DATA_BLOB_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentGen
operator|>
name|generation
condition|)
block|{
name|generation
operator|=
name|currentGen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"file [{}] does not conform to the '{}' schema"
argument_list|,
name|name
argument_list|,
name|DATA_BLOB_PREFIX
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|generation
return|;
block|}
comment|/**          * Loads all available snapshots in the repository          *          * @param blobs list of blobs in repository          * @return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation          */
DECL|method|buildBlobStoreIndexShardSnapshots
specifier|protected
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|buildBlobStoreIndexShardSnapshots
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|int
name|latest
init|=
operator|-
literal|1
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|blobKeys
init|=
name|blobs
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobKeys
control|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|int
name|gen
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|>
name|latest
condition|)
block|{
name|latest
operator|=
name|gen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to parse index file name [{}]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|latest
operator|>=
literal|0
condition|)
block|{
try|try
block|{
specifier|final
name|BlobStoreIndexShardSnapshots
name|shardSnapshots
init|=
name|indexShardSnapshotsFormat
operator|.
name|read
argument_list|(
name|blobContainer
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|latest
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|shardSnapshots
argument_list|,
name|latest
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
specifier|final
name|String
name|file
init|=
name|SNAPSHOT_INDEX_PREFIX
operator|+
name|latest
decl_stmt|;
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to read index file [{}]"
argument_list|,
name|file
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|blobKeys
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Could not find a readable index-N file in a non-empty shard snapshot directory [{}]"
argument_list|,
name|blobContainer
operator|.
name|path
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// We couldn't load the index file - falling back to loading individual snapshots
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|snapshots
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobKeys
control|)
block|{
try|try
block|{
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_PREFIX
argument_list|)
condition|)
block|{
name|snapshot
operator|=
name|indexShardSnapshotFormat
operator|.
name|readBlob
argument_list|(
name|blobContainer
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snapshot
operator|!=
literal|null
condition|)
block|{
name|snapshots
operator|.
name|add
argument_list|(
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to read commit point [{}]"
argument_list|,
name|name
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**      * Context for snapshot operations      */
DECL|class|SnapshotContext
specifier|private
class|class
name|SnapshotContext
extends|extends
name|Context
block|{
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|snapshotStatus
specifier|private
specifier|final
name|IndexShardSnapshotStatus
name|snapshotStatus
decl_stmt|;
comment|/**          * Constructs new context          *          * @param shard          shard to be snapshotted          * @param snapshotId     snapshot id          * @param indexId        the id of the index being snapshotted          * @param snapshotStatus snapshot status to report progress          */
DECL|method|SnapshotContext
name|SnapshotContext
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|Version
operator|.
name|CURRENT
argument_list|,
name|indexId
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotStatus
operator|=
name|snapshotStatus
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|shard
operator|.
name|store
argument_list|()
expr_stmt|;
block|}
comment|/**          * Create snapshot from index commit point          *          * @param snapshotIndexCommit snapshot commit point          */
DECL|method|snapshot
specifier|public
name|void
name|snapshot
parameter_list|(
name|IndexCommit
name|snapshotIndexCommit
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] snapshot to [{}] ..."
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to list blobs"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|generation
init|=
name|findLatestFileNameGeneration
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|tuple
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|tuple
operator|.
name|v1
argument_list|()
decl_stmt|;
name|int
name|fileListGeneration
init|=
name|tuple
operator|.
name|v2
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|indexCommitPointFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|indexNumberOfFiles
init|=
literal|0
decl_stmt|;
name|long
name|indexTotalFilesSize
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|filesToSnapshot
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|metadata
decl_stmt|;
comment|// TODO apparently we don't use the MetadataSnapshot#.recoveryDiff(...) here but we should
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|fileNames
decl_stmt|;
try|try
block|{
name|metadata
operator|=
name|store
operator|.
name|getMetadata
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
name|fileNames
operator|=
name|snapshotIndexCommit
operator|.
name|getFileNames
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to get store file metadata"
argument_list|,
name|e
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|fileName
range|:
name|fileNames
control|)
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] Processing [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
specifier|final
name|StoreFileMetaData
name|md
init|=
name|metadata
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|existingFileInfo
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|filesInfo
init|=
name|snapshots
operator|.
name|findPhysicalIndexFiles
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|filesInfo
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
range|:
name|filesInfo
control|)
block|{
try|try
block|{
comment|// in 1.3.3 we added additional hashes for .si / segments_N files
comment|// to ensure we don't double the space in the repo since old snapshots
comment|// don't have this hash we try to read that hash from the blob store
comment|// in a bwc compatible way.
name|maybeRecalculateMetadataHash
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"{} Can't calculate hash from blob for file [{}] [{}]"
argument_list|,
name|shardId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fileInfo
operator|.
name|isSame
argument_list|(
name|md
argument_list|)
operator|&&
name|snapshotFileExistsInBlobs
argument_list|(
name|fileInfo
argument_list|,
name|blobs
argument_list|)
condition|)
block|{
comment|// a commit point file with the same name, size and checksum was already copied to repository
comment|// we will reuse it for this snapshot
name|existingFileInfo
operator|=
name|fileInfo
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|existingFileInfo
operator|==
literal|null
condition|)
block|{
name|indexNumberOfFiles
operator|++
expr_stmt|;
name|indexTotalFilesSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// create a new FileInfo
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|snapshotFileInfo
init|=
operator|new
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|(
name|fileNameFromGeneration
argument_list|(
operator|++
name|generation
argument_list|)
argument_list|,
name|md
argument_list|,
name|chunkSize
argument_list|()
argument_list|)
decl_stmt|;
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
name|filesToSnapshot
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|existingFileInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|snapshotStatus
operator|.
name|files
argument_list|(
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted during initialization"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|STARTED
argument_list|)
expr_stmt|;
for|for
control|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|snapshotFileInfo
range|:
name|filesToSnapshot
control|)
block|{
try|try
block|{
name|snapshotFile
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to perform snapshot (index files)"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|snapshotStatus
operator|.
name|indexVersion
argument_list|(
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
comment|// now create and write the commit point
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FINALIZE
argument_list|)
expr_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
operator|new
name|BlobStoreIndexShardSnapshot
argument_list|(
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|,
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|indexCommitPointFiles
argument_list|,
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
comment|// snapshotStatus.startTime() is assigned on the same machine, so it's safe to use with VLong
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
decl_stmt|;
comment|//TODO: The time stored in snapshot doesn't include cleanup time.
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] writing shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexShardSnapshotFormat
operator|.
name|write
argument_list|(
name|snapshot
argument_list|,
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to write commit point"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// delete all files that are not referenced by any commit point
comment|// build a new BlobStoreIndexShardSnapshot, that includes this one and all the saved ones
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|newSnapshotsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|newSnapshotsList
operator|.
name|add
argument_list|(
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SnapshotFiles
name|point
range|:
name|snapshots
control|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
comment|// finalize the snapshot and rewrite the snapshot index with the next sequential snapshot index
name|finalize
argument_list|(
name|newSnapshotsList
argument_list|,
name|fileListGeneration
operator|+
literal|1
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Snapshot individual file          *<p>          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be snapshotted          */
DECL|method|snapshotFile
specifier|private
name|void
name|snapshotFile
parameter_list|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|file
init|=
name|fileInfo
operator|.
name|physicalName
argument_list|()
decl_stmt|;
try|try
init|(
name|IndexInput
name|indexInput
init|=
name|store
operator|.
name|openVerifyingInput
argument_list|(
name|file
argument_list|,
name|IOContext
operator|.
name|READONCE
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileInfo
operator|.
name|numberOfParts
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|partBytes
init|=
name|fileInfo
operator|.
name|partBytes
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|InputStreamIndexInput
name|inputStreamIndexInput
init|=
operator|new
name|InputStreamIndexInput
argument_list|(
name|indexInput
argument_list|,
name|partBytes
argument_list|)
decl_stmt|;
name|InputStream
name|inputStream
init|=
name|inputStreamIndexInput
decl_stmt|;
if|if
condition|(
name|snapshotRateLimiter
operator|!=
literal|null
condition|)
block|{
name|inputStream
operator|=
operator|new
name|RateLimitingInputStream
argument_list|(
name|inputStreamIndexInput
argument_list|,
name|snapshotRateLimiter
argument_list|,
name|snapshotRateLimitingTimeInNanos
operator|::
name|inc
argument_list|)
expr_stmt|;
block|}
name|inputStream
operator|=
operator|new
name|AbortableInputStream
argument_list|(
name|inputStream
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
name|blobContainer
operator|.
name|writeBlob
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|i
argument_list|)
argument_list|,
name|inputStream
argument_list|,
name|partBytes
argument_list|)
expr_stmt|;
block|}
name|Store
operator|.
name|verify
argument_list|(
name|indexInput
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|t
parameter_list|)
block|{
name|failStoreIfCorrupted
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
DECL|method|failStoreIfCorrupted
specifier|private
name|void
name|failStoreIfCorrupted
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|CorruptIndexException
operator|||
name|e
operator|instanceof
name|IndexFormatTooOldException
operator|||
name|e
operator|instanceof
name|IndexFormatTooNewException
condition|)
block|{
try|try
block|{
name|store
operator|.
name|markStoreCorrupted
argument_list|(
operator|(
name|IOException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|inner
parameter_list|)
block|{
name|inner
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"store cannot be marked as corrupted"
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Checks if snapshot file already exists in the list of blobs          *          * @param fileInfo file to check          * @param blobs    list of blobs          * @return true if file exists in the list of blobs          */
DECL|method|snapshotFileExistsInBlobs
specifier|private
name|boolean
name|snapshotFileExistsInBlobs
parameter_list|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobMetaData
name|blobMetaData
init|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blobMetaData
operator|!=
literal|null
condition|)
block|{
return|return
name|blobMetaData
operator|.
name|length
argument_list|()
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|blobs
operator|.
name|containsKey
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|// multi part file sum up the size and check
name|int
name|part
init|=
literal|0
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|blobMetaData
operator|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|part
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobMetaData
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|totalSize
operator|+=
name|blobMetaData
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|totalSize
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
comment|// no file, not exact and not multipart
return|return
literal|false
return|;
block|}
DECL|class|AbortableInputStream
specifier|private
class|class
name|AbortableInputStream
extends|extends
name|FilterInputStream
block|{
DECL|field|fileName
specifier|private
specifier|final
name|String
name|fileName
decl_stmt|;
DECL|method|AbortableInputStream
name|AbortableInputStream
parameter_list|(
name|InputStream
name|delegate
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
DECL|method|checkAborted
specifier|private
name|void
name|checkAborted
parameter_list|()
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them.      * The new logic for StoreFileMetaData reads the entire<tt>.si</tt> and<tt>segments.n</tt> files to strengthen the      * comparison of the files on a per-segment / per-commit level.      */
DECL|method|maybeRecalculateMetadataHash
specifier|private
specifier|static
name|void
name|maybeRecalculateMetadataHash
parameter_list|(
specifier|final
name|BlobContainer
name|blobContainer
parameter_list|,
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
name|Store
operator|.
name|MetadataSnapshot
name|snapshot
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|StoreFileMetaData
name|metadata
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|!=
literal|null
operator|&&
operator|(
name|metadata
operator|=
name|snapshot
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|metadata
operator|.
name|hash
argument_list|()
operator|.
name|length
operator|>
literal|0
operator|&&
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|hash
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// we have a hash - check if our repo has a hash too otherwise we have
comment|// to calculate it.
comment|// we might have multiple parts even though the file is small... make sure we read all of it.
try|try
init|(
name|InputStream
name|stream
init|=
operator|new
name|PartSliceStream
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|)
init|)
block|{
name|BytesRefBuilder
name|builder
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|Store
operator|.
name|MetadataSnapshot
operator|.
name|hashFile
argument_list|(
name|builder
argument_list|,
name|stream
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|BytesRef
name|hash
init|=
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|hash
argument_list|()
decl_stmt|;
comment|// reset the file infos metadata hash
assert|assert
name|hash
operator|.
name|length
operator|==
literal|0
assert|;
name|hash
operator|.
name|bytes
operator|=
name|builder
operator|.
name|bytes
argument_list|()
expr_stmt|;
name|hash
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|hash
operator|.
name|length
operator|=
name|builder
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|PartSliceStream
specifier|private
specifier|static
specifier|final
class|class
name|PartSliceStream
extends|extends
name|SlicedInputStream
block|{
DECL|field|container
specifier|private
specifier|final
name|BlobContainer
name|container
decl_stmt|;
DECL|field|info
specifier|private
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|info
decl_stmt|;
DECL|method|PartSliceStream
name|PartSliceStream
parameter_list|(
name|BlobContainer
name|container
parameter_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|info
parameter_list|)
block|{
name|super
argument_list|(
name|info
operator|.
name|numberOfParts
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|this
operator|.
name|container
operator|=
name|container
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|openSlice
specifier|protected
name|InputStream
name|openSlice
parameter_list|(
name|long
name|slice
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|container
operator|.
name|readBlob
argument_list|(
name|info
operator|.
name|partName
argument_list|(
name|slice
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Context for restore operations      */
DECL|class|RestoreContext
specifier|private
class|class
name|RestoreContext
extends|extends
name|Context
block|{
DECL|field|targetShard
specifier|private
specifier|final
name|IndexShard
name|targetShard
decl_stmt|;
DECL|field|recoveryState
specifier|private
specifier|final
name|RecoveryState
name|recoveryState
decl_stmt|;
comment|/**          * Constructs new restore context          *          * @param shard           shard to restore into          * @param snapshotId      snapshot id          * @param indexId         id of the index being restored          * @param snapshotShardId shard in the snapshot that data should be restored from          * @param recoveryState   recovery state to report progress          */
DECL|method|RestoreContext
name|RestoreContext
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|IndexId
name|indexId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|indexId
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|snapshotShardId
argument_list|)
expr_stmt|;
name|this
operator|.
name|recoveryState
operator|=
name|recoveryState
expr_stmt|;
name|this
operator|.
name|targetShard
operator|=
name|shard
expr_stmt|;
block|}
comment|/**          * Performs restore operation          */
DECL|method|restore
specifier|public
name|void
name|restore
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|Store
name|store
init|=
name|targetShard
operator|.
name|store
argument_list|()
decl_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] restoring to [{}] ..."
argument_list|,
name|snapshotId
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|loadSnapshot
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshot
operator|.
name|indexFiles
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|snapshot
operator|.
name|indexFiles
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|physicalName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"segments_"
argument_list|)
operator|&&
name|snapshot
operator|.
name|indexFiles
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|hasUnknownChecksum
argument_list|()
condition|)
block|{
comment|// If the shard has no documents, it will only contain a single segments_N file for the
comment|// shard's snapshot.  If we are restoring a snapshot created by a previous supported version,
comment|// it is still possible that in that version, an empty shard has a segments_N file with an unsupported
comment|// version (and no checksum), because we don't know the Lucene version to assign segments_N until we
comment|// have written some data.  Since the segments_N for an empty shard could have an incompatible Lucene
comment|// version number and no checksum, even though the index itself is perfectly fine to restore, this
comment|// empty shard would cause exceptions to be thrown.  Since there is no data to restore from an empty
comment|// shard anyway, we just create the empty shard here and then exit.
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|,
operator|new
name|IndexWriterConfig
argument_list|(
literal|null
argument_list|)
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
operator|.
name|setCommitOnClose
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
return|return;
block|}
name|SnapshotFiles
name|snapshotFiles
init|=
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
decl_stmt|;
name|Store
operator|.
name|MetadataSnapshot
name|recoveryTargetMetadata
decl_stmt|;
try|try
block|{
name|recoveryTargetMetadata
operator|=
name|targetShard
operator|.
name|snapshotStoreMetadata
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexNotFoundException
name|e
parameter_list|)
block|{
comment|// happens when restore to an empty shard, not a big deal
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] restoring from to an empty shard"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
name|recoveryTargetMetadata
operator|=
name|Store
operator|.
name|MetadataSnapshot
operator|.
name|EMPTY
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"{} Can't read metadata from store, will not reuse any local file while restoring"
argument_list|,
name|shardId
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recoveryTargetMetadata
operator|=
name|Store
operator|.
name|MetadataSnapshot
operator|.
name|EMPTY
expr_stmt|;
block|}
specifier|final
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|filesToRecover
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|StoreFileMetaData
argument_list|>
name|snapshotMetaData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|fileInfos
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
range|:
name|snapshot
operator|.
name|indexFiles
argument_list|()
control|)
block|{
try|try
block|{
comment|// in 1.3.3 we added additional hashes for .si / segments_N files
comment|// to ensure we don't double the space in the repo since old snapshots
comment|// don't have this hash we try to read that hash from the blob store
comment|// in a bwc compatible way.
name|maybeRecalculateMetadataHash
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|,
name|recoveryTargetMetadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// if the index is broken we might not be able to read it
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"{} Can't calculate hash from blog for file [{}] [{}]"
argument_list|,
name|shardId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|snapshotMetaData
operator|.
name|put
argument_list|(
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
name|fileInfos
operator|.
name|put
argument_list|(
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|sourceMetaData
init|=
operator|new
name|Store
operator|.
name|MetadataSnapshot
argument_list|(
name|unmodifiableMap
argument_list|(
name|snapshotMetaData
argument_list|)
argument_list|,
name|emptyMap
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Store
operator|.
name|RecoveryDiff
name|diff
init|=
name|sourceMetaData
operator|.
name|recoveryDiff
argument_list|(
name|recoveryTargetMetadata
argument_list|)
decl_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|diff
operator|.
name|identical
control|)
block|{
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
init|=
name|fileInfos
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addFileDetail
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|Iterables
operator|.
name|concat
argument_list|(
name|diff
operator|.
name|different
argument_list|,
name|diff
operator|.
name|missing
argument_list|)
control|)
block|{
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
init|=
name|fileInfos
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|filesToRecover
operator|.
name|add
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addFileDetail
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering [{}] from [{}], does not exists in local store"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering [{}] from [{}], exists in local store but is different"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|RecoveryState
operator|.
name|Index
name|index
init|=
name|recoveryState
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|filesToRecover
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"no files to recover, all exists within the local store"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering_files [{}] with total_size [{}], reusing_files [{}] with reused_size [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|index
operator|.
name|totalRecoverFiles
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|index
operator|.
name|totalRecoverBytes
argument_list|()
argument_list|)
argument_list|,
name|index
operator|.
name|reusedFileCount
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|index
operator|.
name|reusedFileCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
comment|// first, delete pre-existing files in the store that have the same name but are
comment|// different (i.e. different length/checksum) from those being restored in the snapshot
for|for
control|(
specifier|final
name|StoreFileMetaData
name|storeFileMetaData
range|:
name|diff
operator|.
name|different
control|)
block|{
name|IOUtils
operator|.
name|deleteFiles
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|,
name|storeFileMetaData
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// restore the files from the snapshot to the Lucene store
for|for
control|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileToRecover
range|:
name|filesToRecover
control|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] restoring file [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileToRecover
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|restoreFile
argument_list|(
name|fileToRecover
argument_list|,
name|store
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to recover index"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
specifier|final
name|StoreFileMetaData
name|restoredSegmentsFile
init|=
name|sourceMetaData
operator|.
name|getSegmentsFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|recoveryTargetMetadata
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Snapshot has no segments file"
argument_list|)
throw|;
block|}
assert|assert
name|restoredSegmentsFile
operator|!=
literal|null
assert|;
comment|// read the snapshot data persisted
specifier|final
name|SegmentInfos
name|segmentCommitInfos
decl_stmt|;
try|try
block|{
name|segmentCommitInfos
operator|=
name|Lucene
operator|.
name|pruneUnreferencedFiles
argument_list|(
name|restoredSegmentsFile
operator|.
name|name
argument_list|()
argument_list|,
name|store
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to fetch index version after copying it over"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|updateVersion
argument_list|(
name|segmentCommitInfos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|/// now, go over and clean files that are in the store, but were not in the snapshot
try|try
block|{
for|for
control|(
name|String
name|storeFile
range|:
name|store
operator|.
name|directory
argument_list|()
operator|.
name|listAll
argument_list|()
control|)
block|{
if|if
condition|(
name|Store
operator|.
name|isAutogenerated
argument_list|(
name|storeFile
argument_list|)
operator|||
name|snapshotFiles
operator|.
name|containPhysicalIndexFile
argument_list|(
name|storeFile
argument_list|)
condition|)
block|{
continue|continue;
comment|//skip write.lock, checksum files and files that exist in the snapshot
block|}
try|try
block|{
name|store
operator|.
name|deleteQuiet
argument_list|(
literal|"restore"
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
name|store
operator|.
name|directory
argument_list|()
operator|.
name|deleteFile
argument_list|(
name|storeFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to delete file [{}] during snapshot cleanup"
argument_list|,
name|snapshotId
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to list directory - some of files might not be deleted"
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Restores a file          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be restored          */
DECL|method|restoreFile
specifier|private
name|void
name|restoreFile
parameter_list|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
specifier|final
name|Store
name|store
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
init|(
name|InputStream
name|partSliceStream
init|=
operator|new
name|PartSliceStream
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|)
init|)
block|{
specifier|final
name|InputStream
name|stream
decl_stmt|;
if|if
condition|(
name|restoreRateLimiter
operator|==
literal|null
condition|)
block|{
name|stream
operator|=
name|partSliceStream
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|=
operator|new
name|RateLimitingInputStream
argument_list|(
name|partSliceStream
argument_list|,
name|restoreRateLimiter
argument_list|,
name|restoreRateLimitingTimeInNanos
operator|::
name|inc
argument_list|)
expr_stmt|;
block|}
try|try
init|(
name|IndexOutput
name|indexOutput
init|=
name|store
operator|.
name|createVerifyingOutput
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
init|)
block|{
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
while|while
condition|(
operator|(
name|length
operator|=
name|stream
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|indexOutput
operator|.
name|writeBytes
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addRecoveredBytesToFile
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|Store
operator|.
name|verify
argument_list|(
name|indexOutput
argument_list|)
expr_stmt|;
name|indexOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|store
operator|.
name|directory
argument_list|()
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|ex
parameter_list|)
block|{
try|try
block|{
name|store
operator|.
name|markStoreCorrupted
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"store cannot be marked as corrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ex
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|store
operator|.
name|deleteQuiet
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

