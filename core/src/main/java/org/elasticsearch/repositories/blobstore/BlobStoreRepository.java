begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.repositories.blobstore
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|blobstore
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriterConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimiter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|RepositoryMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Numbers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|iterable
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardRestoreFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|BlobStoreIndexShardSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|BlobStoreIndexShardSnapshots
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|RateLimitingInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|SlicedInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|SnapshotFiles
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseFieldMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|UUIDs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|NotXContentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|Streams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|OutputStreamStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|metrics
operator|.
name|CounterMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryVerificationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotCreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotMissingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotShardFailure
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_comment
comment|/**  * BlobStore - based implementation of Snapshot Repository  *<p>  * This repository works with any {@link BlobStore} implementation. The blobStore should be initialized in the derived  * class before {@link #doStart()} is called.  *<p>  * BlobStoreRepository maintains the following structure in the blob store  *<pre>  * {@code  *   STORE_ROOT  *   |- index-N           - list of all snapshot name as JSON array, N is the generation of the file  *   |- index-latest      - contains the numeric value of the latest generation of the index file (i.e. N from above)  *   |- snapshot-20131010 - JSON serialized Snapshot for snapshot "20131010"  *   |- meta-20131010.dat - JSON serialized MetaData for snapshot "20131010" (includes only global metadata)  *   |- snapshot-20131011 - JSON serialized Snapshot for snapshot "20131011"  *   |- meta-20131011.dat - JSON serialized MetaData for snapshot "20131011"  *   .....  *   |- indices/ - data for all indices  *      |- foo/ - data for index "foo"  *      |  |- meta-20131010.dat - JSON Serialized IndexMetaData for index "foo"  *      |  |- 0/ - data for shard "0" of index "foo"  *      |  |  |- __1 \  *      |  |  |- __2 |  *      |  |  |- __3 |- files from different segments see snapshot-* for their mappings to real segment files  *      |  |  |- __4 |  *      |  |  |- __5 /  *      |  |  .....  *      |  |  |- snap-20131010.dat - JSON serialized BlobStoreIndexShardSnapshot for snapshot "20131010"  *      |  |  |- snap-20131011.dat - JSON serialized BlobStoreIndexShardSnapshot for snapshot "20131011"  *      |  |  |- list-123 - JSON serialized BlobStoreIndexShardSnapshot for snapshot "20131011"  *      |  |  *      |  |- 1/ - data for shard "1" of index "foo"  *      |  |  |- __1  *      |  |  .....  *      |  |  *      |  |-2/  *      |  ......  *      |  *      |- bar/ - data for index bar  *      ......  * }  *</pre>  */
end_comment

begin_class
DECL|class|BlobStoreRepository
specifier|public
specifier|abstract
class|class
name|BlobStoreRepository
extends|extends
name|AbstractLifecycleComponent
implements|implements
name|Repository
block|{
DECL|field|snapshotsBlobContainer
specifier|private
name|BlobContainer
name|snapshotsBlobContainer
decl_stmt|;
DECL|field|metadata
specifier|protected
specifier|final
name|RepositoryMetaData
name|metadata
decl_stmt|;
DECL|field|BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
DECL|field|LEGACY_SNAPSHOT_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|LEGACY_SNAPSHOT_PREFIX
init|=
literal|"snapshot-"
decl_stmt|;
DECL|field|SNAPSHOT_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_PREFIX
init|=
literal|"snap-"
decl_stmt|;
DECL|field|SNAPSHOT_CODEC
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_CODEC
init|=
literal|"snapshot"
decl_stmt|;
DECL|field|SNAPSHOTS_FILE
specifier|static
specifier|final
name|String
name|SNAPSHOTS_FILE
init|=
literal|"index"
decl_stmt|;
comment|// package private for unit testing
DECL|field|SNAPSHOTS_FILE_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOTS_FILE_PREFIX
init|=
literal|"index-"
decl_stmt|;
DECL|field|SNAPSHOTS_INDEX_LATEST_BLOB
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOTS_INDEX_LATEST_BLOB
init|=
literal|"index.latest"
decl_stmt|;
DECL|field|TESTS_FILE
specifier|private
specifier|static
specifier|final
name|String
name|TESTS_FILE
init|=
literal|"tests-"
decl_stmt|;
DECL|field|METADATA_NAME_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|METADATA_NAME_FORMAT
init|=
literal|"meta-%s.dat"
decl_stmt|;
DECL|field|LEGACY_METADATA_NAME_FORMAT
specifier|private
specifier|static
specifier|final
name|String
name|LEGACY_METADATA_NAME_FORMAT
init|=
literal|"metadata-%s"
decl_stmt|;
DECL|field|METADATA_CODEC
specifier|private
specifier|static
specifier|final
name|String
name|METADATA_CODEC
init|=
literal|"metadata"
decl_stmt|;
DECL|field|INDEX_METADATA_CODEC
specifier|private
specifier|static
specifier|final
name|String
name|INDEX_METADATA_CODEC
init|=
literal|"index-metadata"
decl_stmt|;
DECL|field|LEGACY_SNAPSHOT_NAME_FORMAT
specifier|protected
specifier|static
specifier|final
name|String
name|LEGACY_SNAPSHOT_NAME_FORMAT
init|=
name|LEGACY_SNAPSHOT_PREFIX
operator|+
literal|"%s"
decl_stmt|;
DECL|field|SNAPSHOT_NAME_FORMAT
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_NAME_FORMAT
init|=
name|SNAPSHOT_PREFIX
operator|+
literal|"%s.dat"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_PREFIX
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_PREFIX
init|=
literal|"index-"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_NAME_FORMAT
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_NAME_FORMAT
init|=
name|SNAPSHOT_INDEX_PREFIX
operator|+
literal|"%s"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_CODEC
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_CODEC
init|=
literal|"snapshots"
decl_stmt|;
DECL|field|DATA_BLOB_PREFIX
specifier|protected
specifier|static
specifier|final
name|String
name|DATA_BLOB_PREFIX
init|=
literal|"__"
decl_stmt|;
DECL|field|snapshotRateLimiter
specifier|private
specifier|final
name|RateLimiter
name|snapshotRateLimiter
decl_stmt|;
DECL|field|restoreRateLimiter
specifier|private
specifier|final
name|RateLimiter
name|restoreRateLimiter
decl_stmt|;
DECL|field|snapshotRateLimitingTimeInNanos
specifier|private
specifier|final
name|CounterMetric
name|snapshotRateLimitingTimeInNanos
init|=
operator|new
name|CounterMetric
argument_list|()
decl_stmt|;
DECL|field|restoreRateLimitingTimeInNanos
specifier|private
specifier|final
name|CounterMetric
name|restoreRateLimitingTimeInNanos
init|=
operator|new
name|CounterMetric
argument_list|()
decl_stmt|;
DECL|field|globalMetaDataFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|MetaData
argument_list|>
name|globalMetaDataFormat
decl_stmt|;
DECL|field|globalMetaDataLegacyFormat
specifier|private
name|LegacyBlobStoreFormat
argument_list|<
name|MetaData
argument_list|>
name|globalMetaDataLegacyFormat
decl_stmt|;
DECL|field|indexMetaDataFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|IndexMetaData
argument_list|>
name|indexMetaDataFormat
decl_stmt|;
DECL|field|indexMetaDataLegacyFormat
specifier|private
name|LegacyBlobStoreFormat
argument_list|<
name|IndexMetaData
argument_list|>
name|indexMetaDataLegacyFormat
decl_stmt|;
DECL|field|snapshotFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|SnapshotInfo
argument_list|>
name|snapshotFormat
decl_stmt|;
DECL|field|snapshotLegacyFormat
specifier|private
name|LegacyBlobStoreFormat
argument_list|<
name|SnapshotInfo
argument_list|>
name|snapshotLegacyFormat
decl_stmt|;
DECL|field|readOnly
specifier|private
specifier|final
name|boolean
name|readOnly
decl_stmt|;
DECL|field|parseFieldMatcher
specifier|private
specifier|final
name|ParseFieldMatcher
name|parseFieldMatcher
decl_stmt|;
DECL|field|indexShardSnapshotFormat
specifier|private
specifier|final
name|ChecksumBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotFormat
decl_stmt|;
DECL|field|indexShardSnapshotLegacyFormat
specifier|private
specifier|final
name|LegacyBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotLegacyFormat
decl_stmt|;
DECL|field|indexShardSnapshotsFormat
specifier|private
specifier|final
name|ChecksumBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|>
name|indexShardSnapshotsFormat
decl_stmt|;
comment|/**      * Constructs new BlobStoreRepository      *      * @param metadata       The metadata for this repository including name and settings      * @param globalSettings Settings for the node this repository object is created on      */
DECL|method|BlobStoreRepository
specifier|protected
name|BlobStoreRepository
parameter_list|(
name|RepositoryMetaData
name|metadata
parameter_list|,
name|Settings
name|globalSettings
parameter_list|)
block|{
name|super
argument_list|(
name|globalSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|parseFieldMatcher
operator|=
operator|new
name|ParseFieldMatcher
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|snapshotRateLimiter
operator|=
name|getRateLimiter
argument_list|(
name|metadata
operator|.
name|settings
argument_list|()
argument_list|,
literal|"max_snapshot_bytes_per_sec"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|40
argument_list|,
name|ByteSizeUnit
operator|.
name|MB
argument_list|)
argument_list|)
expr_stmt|;
name|restoreRateLimiter
operator|=
name|getRateLimiter
argument_list|(
name|metadata
operator|.
name|settings
argument_list|()
argument_list|,
literal|"max_restore_bytes_per_sec"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|40
argument_list|,
name|ByteSizeUnit
operator|.
name|MB
argument_list|)
argument_list|)
expr_stmt|;
name|readOnly
operator|=
name|metadata
operator|.
name|settings
argument_list|()
operator|.
name|getAsBoolean
argument_list|(
literal|"readonly"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|indexShardSnapshotFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_CODEC
argument_list|,
name|SNAPSHOT_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|indexShardSnapshotLegacyFormat
operator|=
operator|new
name|LegacyBlobStoreFormat
argument_list|<>
argument_list|(
name|LEGACY_SNAPSHOT_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|)
expr_stmt|;
name|indexShardSnapshotsFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_INDEX_CODEC
argument_list|,
name|SNAPSHOT_INDEX_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshots
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|this
operator|.
name|snapshotsBlobContainer
operator|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
argument_list|)
expr_stmt|;
name|ParseFieldMatcher
name|parseFieldMatcher
init|=
operator|new
name|ParseFieldMatcher
argument_list|(
name|settings
argument_list|)
decl_stmt|;
name|globalMetaDataFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|METADATA_CODEC
argument_list|,
name|METADATA_NAME_FORMAT
argument_list|,
name|MetaData
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|globalMetaDataLegacyFormat
operator|=
operator|new
name|LegacyBlobStoreFormat
argument_list|<>
argument_list|(
name|LEGACY_METADATA_NAME_FORMAT
argument_list|,
name|MetaData
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|)
expr_stmt|;
name|indexMetaDataFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|INDEX_METADATA_CODEC
argument_list|,
name|METADATA_NAME_FORMAT
argument_list|,
name|IndexMetaData
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|indexMetaDataLegacyFormat
operator|=
operator|new
name|LegacyBlobStoreFormat
argument_list|<>
argument_list|(
name|LEGACY_SNAPSHOT_NAME_FORMAT
argument_list|,
name|IndexMetaData
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|)
expr_stmt|;
name|snapshotFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_CODEC
argument_list|,
name|SNAPSHOT_NAME_FORMAT
argument_list|,
name|SnapshotInfo
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotLegacyFormat
operator|=
operator|new
name|LegacyBlobStoreFormat
argument_list|<>
argument_list|(
name|LEGACY_SNAPSHOT_NAME_FORMAT
argument_list|,
name|SnapshotInfo
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
block|{}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{
try|try
block|{
name|blobStore
argument_list|()
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|t
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"cannot close blob store"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the BlobStore to read and write data.      */
DECL|method|blobStore
specifier|protected
specifier|abstract
name|BlobStore
name|blobStore
parameter_list|()
function_decl|;
comment|/**      * Returns base path of the repository      */
DECL|method|basePath
specifier|protected
specifier|abstract
name|BlobPath
name|basePath
parameter_list|()
function_decl|;
comment|/**      * Returns true if metadata and snapshot files should be compressed      *      * @return true if compression is needed      */
DECL|method|isCompress
specifier|protected
name|boolean
name|isCompress
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
comment|/**      * Returns data file chunk size.      *<p>      * This method should return null if no chunking is needed.      *      * @return chunk size      */
DECL|method|chunkSize
specifier|protected
name|ByteSizeValue
name|chunkSize
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|getMetadata
specifier|public
name|RepositoryMetaData
name|getMetadata
parameter_list|()
block|{
return|return
name|metadata
return|;
block|}
annotation|@
name|Override
DECL|method|initializeSnapshot
specifier|public
name|void
name|initializeSnapshot
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|indices
parameter_list|,
name|MetaData
name|clusterMetadata
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"cannot create snapshot in a readonly repository"
argument_list|)
throw|;
block|}
try|try
block|{
specifier|final
name|String
name|snapshotName
init|=
name|snapshotId
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// check if the snapshot name already exists in the repository
if|if
condition|(
name|getSnapshots
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|anyMatch
argument_list|(
name|s
lambda|->
name|s
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotName
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
argument_list|new
name|SnapshotCreationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"snapshot with the same name already exists"
argument_list|)
block|;             }
if|if
condition|(
name|snapshotFormat
operator|.
name|exists
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|(
name|snapshotId
argument_list|)
argument_list|)
operator|||
name|snapshotLegacyFormat
operator|.
name|exists
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SnapshotCreationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"snapshot with such name already exists"
argument_list|)
throw|;
block|}
comment|// Write Global MetaData
name|globalMetaDataFormat
operator|.
name|write
argument_list|(
name|clusterMetadata
argument_list|,
name|snapshotsBlobContainer
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|index
range|:
name|indices
control|)
block|{
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|clusterMetadata
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|BlobPath
name|indexPath
init|=
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|BlobContainer
name|indexMetaDataBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|indexPath
argument_list|)
decl_stmt|;
name|indexMetaDataFormat
operator|.
name|write
argument_list|(
name|indexMetaData
argument_list|,
name|indexMetaDataBlobContainer
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotCreationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|deleteSnapshot
specifier|public
name|void
name|deleteSnapshot
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"cannot delete snapshot from a readonly repository"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|indices
init|=
name|Collections
operator|.
name|emptyList
argument_list|()
decl_stmt|;
name|SnapshotInfo
name|snapshot
init|=
literal|null
decl_stmt|;
try|try
block|{
name|snapshot
operator|=
name|getSnapshotInfo
argument_list|(
name|snapshotId
argument_list|)
expr_stmt|;
name|indices
operator|=
name|snapshot
operator|.
name|indices
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SnapshotMissingException
name|ex
parameter_list|)
block|{
throw|throw
name|ex
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
decl||
name|SnapshotException
decl||
name|ElasticsearchParseException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"cannot read snapshot file [{}]"
argument_list|,
name|ex
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
name|MetaData
name|metaData
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|snapshot
operator|!=
literal|null
condition|)
block|{
name|metaData
operator|=
name|readSnapshotMetaData
argument_list|(
name|snapshotId
argument_list|,
name|snapshot
operator|.
name|version
argument_list|()
argument_list|,
name|indices
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metaData
operator|=
name|readSnapshotMetaData
argument_list|(
name|snapshotId
argument_list|,
literal|null
argument_list|,
name|indices
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|SnapshotException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"cannot read metadata for snapshot [{}]"
argument_list|,
name|ex
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
try|try
block|{
specifier|final
name|String
name|snapshotName
init|=
name|snapshotId
operator|.
name|getName
argument_list|()
decl_stmt|;
comment|// Delete snapshot file first so we wouldn't end up with partially deleted snapshot that looks OK
if|if
condition|(
name|snapshot
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|snapshotFormat
argument_list|(
name|snapshot
operator|.
name|version
argument_list|()
argument_list|)
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|(
name|snapshotId
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"snapshotFormat failed to delete snapshot [{}]"
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|globalMetaDataFormat
argument_list|(
name|snapshot
operator|.
name|version
argument_list|()
argument_list|)
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"gloalMetaDataFormat failed to delete snapshot [{}]"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// We don't know which version was the snapshot created with - try deleting both current and legacy formats
try|try
block|{
name|snapshotFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|(
name|snapshotId
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"snapshotFormat failed to delete snapshot [{}]"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|snapshotLegacyFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"snapshotLegacyFormat failed to delete snapshot [{}]"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|globalMetaDataLegacyFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"globalMetaDataLegacyFormat failed to delete snapshot [{}]"
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|globalMetaDataFormat
operator|.
name|delete
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"globalMetaDataFormat failed to delete snapshot [{}]"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Delete snapshot from the snapshot list
name|List
argument_list|<
name|SnapshotId
argument_list|>
name|snapshotIds
init|=
name|getSnapshots
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|id
lambda|->
name|snapshotId
operator|.
name|equals
argument_list|(
name|id
argument_list|)
operator|==
literal|false
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
name|writeSnapshotsToIndexGen
argument_list|(
name|snapshotIds
argument_list|)
expr_stmt|;
comment|// Now delete all indices
for|for
control|(
name|String
name|index
range|:
name|indices
control|)
block|{
name|BlobPath
name|indexPath
init|=
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|BlobContainer
name|indexMetaDataBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|indexPath
argument_list|)
decl_stmt|;
try|try
block|{
name|indexMetaDataFormat
argument_list|(
name|snapshot
operator|.
name|version
argument_list|()
argument_list|)
operator|.
name|delete
argument_list|(
name|indexMetaDataBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to delete metadata for index [{}]"
argument_list|,
name|ex
argument_list|,
name|snapshotId
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|IndexMetaData
name|indexMetaData
init|=
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|shardId
init|=
literal|0
init|;
name|shardId
operator|<
name|indexMetaData
operator|.
name|getNumberOfShards
argument_list|()
condition|;
name|shardId
operator|++
control|)
block|{
try|try
block|{
name|delete
argument_list|(
name|snapshotId
argument_list|,
name|snapshot
operator|.
name|version
argument_list|()
argument_list|,
operator|new
name|ShardId
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|,
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SnapshotException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to delete shard data for shard [{}][{}]"
argument_list|,
name|ex
argument_list|,
name|snapshotId
argument_list|,
name|index
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"failed to update snapshot in repository"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|finalizeSnapshot
specifier|public
name|SnapshotInfo
name|finalizeSnapshot
parameter_list|(
specifier|final
name|SnapshotId
name|snapshotId
parameter_list|,
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|indices
parameter_list|,
specifier|final
name|long
name|startTime
parameter_list|,
specifier|final
name|String
name|failure
parameter_list|,
specifier|final
name|int
name|totalShards
parameter_list|,
specifier|final
name|List
argument_list|<
name|SnapshotShardFailure
argument_list|>
name|shardFailures
parameter_list|)
block|{
try|try
block|{
name|SnapshotInfo
name|blobStoreSnapshot
init|=
operator|new
name|SnapshotInfo
argument_list|(
name|snapshotId
argument_list|,
name|indices
argument_list|,
name|startTime
argument_list|,
name|failure
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|,
name|totalShards
argument_list|,
name|shardFailures
argument_list|)
decl_stmt|;
name|snapshotFormat
operator|.
name|write
argument_list|(
name|blobStoreSnapshot
argument_list|,
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|(
name|snapshotId
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SnapshotId
argument_list|>
name|snapshotIds
init|=
name|getSnapshots
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|snapshotIds
operator|.
name|contains
argument_list|(
name|snapshotId
argument_list|)
condition|)
block|{
name|snapshotIds
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|snapshotIds
argument_list|)
expr_stmt|;
name|snapshotIds
operator|.
name|add
argument_list|(
name|snapshotId
argument_list|)
expr_stmt|;
name|snapshotIds
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|snapshotIds
argument_list|)
expr_stmt|;
name|writeSnapshotsToIndexGen
argument_list|(
name|snapshotIds
argument_list|)
expr_stmt|;
block|}
return|return
name|blobStoreSnapshot
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"failed to update snapshot in repository"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getSnapshots
specifier|public
name|List
argument_list|<
name|SnapshotId
argument_list|>
name|getSnapshots
parameter_list|()
block|{
try|try
block|{
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|readSnapshotsFromIndex
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFileException
decl||
name|FileNotFoundException
name|e
parameter_list|)
block|{
comment|// its a fresh repository, no index file exists, so return an empty list
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"failed to list snapshots in repository"
argument_list|,
name|ioe
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getSnapshotMetaData
specifier|public
name|MetaData
name|getSnapshotMetaData
parameter_list|(
name|SnapshotInfo
name|snapshot
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|indices
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|readSnapshotMetaData
argument_list|(
name|snapshot
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|snapshot
operator|.
name|version
argument_list|()
argument_list|,
name|indices
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getSnapshotInfo
specifier|public
name|SnapshotInfo
name|getSnapshotInfo
parameter_list|(
specifier|final
name|SnapshotId
name|snapshotId
parameter_list|)
block|{
try|try
block|{
return|return
name|snapshotFormat
operator|.
name|read
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|blobId
argument_list|(
name|snapshotId
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|NoSuchFileException
name|ex
parameter_list|)
block|{
comment|// File is missing - let's try legacy format instead
try|try
block|{
return|return
name|snapshotLegacyFormat
operator|.
name|read
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|NoSuchFileException
name|ex1
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotMissingException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|NotXContentException
name|ex1
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"failed to get snapshots"
argument_list|,
name|ex1
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
decl||
name|NotXContentException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"failed to get snapshots"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|readSnapshotMetaData
specifier|private
name|MetaData
name|readSnapshotMetaData
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|snapshotVersion
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|indices
parameter_list|,
name|boolean
name|ignoreIndexErrors
parameter_list|)
throws|throws
name|IOException
block|{
name|MetaData
name|metaData
decl_stmt|;
if|if
condition|(
name|snapshotVersion
operator|==
literal|null
condition|)
block|{
comment|// When we delete corrupted snapshots we might not know which version we are dealing with
comment|// We can try detecting the version based on the metadata file format
assert|assert
name|ignoreIndexErrors
assert|;
if|if
condition|(
name|globalMetaDataFormat
operator|.
name|exists
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|snapshotVersion
operator|=
name|Version
operator|.
name|CURRENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|globalMetaDataLegacyFormat
operator|.
name|exists
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"snapshot is too old"
argument_list|)
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|SnapshotMissingException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|metaData
operator|=
name|globalMetaDataFormat
argument_list|(
name|snapshotVersion
argument_list|)
operator|.
name|read
argument_list|(
name|snapshotsBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FileNotFoundException
decl||
name|NoSuchFileException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotMissingException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
name|ex
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|SnapshotException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|snapshotId
argument_list|,
literal|"failed to get snapshots"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
name|MetaData
operator|.
name|Builder
name|metaDataBuilder
init|=
name|MetaData
operator|.
name|builder
argument_list|(
name|metaData
argument_list|)
decl_stmt|;
for|for
control|(
name|String
name|index
range|:
name|indices
control|)
block|{
name|BlobPath
name|indexPath
init|=
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|BlobContainer
name|indexMetaDataBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|indexPath
argument_list|)
decl_stmt|;
try|try
block|{
name|metaDataBuilder
operator|.
name|put
argument_list|(
name|indexMetaDataFormat
argument_list|(
name|snapshotVersion
argument_list|)
operator|.
name|read
argument_list|(
name|indexMetaDataBlobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ElasticsearchParseException
decl||
name|IOException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ignoreIndexErrors
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] [{}] failed to read metadata for index"
argument_list|,
name|ex
argument_list|,
name|snapshotId
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
return|return
name|metaDataBuilder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Configures RateLimiter based on repository and global settings      *      * @param repositorySettings repository settings      * @param setting            setting to use to configure rate limiter      * @param defaultRate        default limiting rate      * @return rate limiter or null of no throttling is needed      */
DECL|method|getRateLimiter
specifier|private
name|RateLimiter
name|getRateLimiter
parameter_list|(
name|Settings
name|repositorySettings
parameter_list|,
name|String
name|setting
parameter_list|,
name|ByteSizeValue
name|defaultRate
parameter_list|)
block|{
name|ByteSizeValue
name|maxSnapshotBytesPerSec
init|=
name|repositorySettings
operator|.
name|getAsBytesSize
argument_list|(
name|setting
argument_list|,
name|settings
operator|.
name|getAsBytesSize
argument_list|(
name|setting
argument_list|,
name|defaultRate
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxSnapshotBytesPerSec
operator|.
name|bytes
argument_list|()
operator|<=
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
operator|new
name|RateLimiter
operator|.
name|SimpleRateLimiter
argument_list|(
name|maxSnapshotBytesPerSec
operator|.
name|mbFrac
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      * Returns appropriate global metadata format based on the provided version of the snapshot      */
DECL|method|globalMetaDataFormat
specifier|private
name|BlobStoreFormat
argument_list|<
name|MetaData
argument_list|>
name|globalMetaDataFormat
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
if|if
condition|(
name|legacyMetaData
argument_list|(
name|version
argument_list|)
condition|)
block|{
return|return
name|globalMetaDataLegacyFormat
return|;
block|}
else|else
block|{
return|return
name|globalMetaDataFormat
return|;
block|}
block|}
comment|/**      * Returns appropriate snapshot format based on the provided version of the snapshot      */
DECL|method|snapshotFormat
specifier|private
name|BlobStoreFormat
argument_list|<
name|SnapshotInfo
argument_list|>
name|snapshotFormat
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
if|if
condition|(
name|legacyMetaData
argument_list|(
name|version
argument_list|)
condition|)
block|{
return|return
name|snapshotLegacyFormat
return|;
block|}
else|else
block|{
return|return
name|snapshotFormat
return|;
block|}
block|}
comment|/**      * In v2.0.0 we changed the metadata file format      * @return true if legacy version should be used false otherwise      */
DECL|method|legacyMetaData
specifier|public
specifier|static
name|boolean
name|legacyMetaData
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
return|return
name|version
operator|.
name|before
argument_list|(
name|Version
operator|.
name|V_2_0_0_beta1
argument_list|)
return|;
block|}
comment|/**      * Returns appropriate index metadata format based on the provided version of the snapshot      */
DECL|method|indexMetaDataFormat
specifier|private
name|BlobStoreFormat
argument_list|<
name|IndexMetaData
argument_list|>
name|indexMetaDataFormat
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
if|if
condition|(
name|legacyMetaData
argument_list|(
name|version
argument_list|)
condition|)
block|{
return|return
name|indexMetaDataLegacyFormat
return|;
block|}
else|else
block|{
return|return
name|indexMetaDataFormat
return|;
block|}
block|}
DECL|field|SNAPSHOTS
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOTS
init|=
literal|"snapshots"
decl_stmt|;
DECL|field|NAME
specifier|private
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"name"
decl_stmt|;
DECL|field|UUID
specifier|private
specifier|static
specifier|final
name|String
name|UUID
init|=
literal|"uuid"
decl_stmt|;
annotation|@
name|Override
DECL|method|getSnapshotThrottleTimeInNanos
specifier|public
name|long
name|getSnapshotThrottleTimeInNanos
parameter_list|()
block|{
return|return
name|snapshotRateLimitingTimeInNanos
operator|.
name|count
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getRestoreThrottleTimeInNanos
specifier|public
name|long
name|getRestoreThrottleTimeInNanos
parameter_list|()
block|{
return|return
name|restoreRateLimitingTimeInNanos
operator|.
name|count
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|startVerification
specifier|public
name|String
name|startVerification
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
comment|// It's readonly - so there is not much we can do here to verify it
return|return
literal|null
return|;
block|}
else|else
block|{
name|String
name|seed
init|=
name|UUIDs
operator|.
name|randomBase64UUID
argument_list|()
decl_stmt|;
name|byte
index|[]
name|testBytes
init|=
name|Strings
operator|.
name|toUTF8Bytes
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|BlobContainer
name|testContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|blobName
init|=
literal|"master.dat"
decl_stmt|;
name|testContainer
operator|.
name|writeBlob
argument_list|(
name|blobName
operator|+
literal|"-temp"
argument_list|,
operator|new
name|BytesArray
argument_list|(
name|testBytes
argument_list|)
argument_list|)
expr_stmt|;
comment|// Make sure that move is supported
name|testContainer
operator|.
name|move
argument_list|(
name|blobName
operator|+
literal|"-temp"
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
return|return
name|seed
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"path "
operator|+
name|basePath
argument_list|()
operator|+
literal|" is not accessible on master node"
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|endVerification
specifier|public
name|void
name|endVerification
parameter_list|(
name|String
name|seed
parameter_list|)
block|{
if|if
condition|(
name|isReadOnly
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"shouldn't be called"
argument_list|)
throw|;
block|}
try|try
block|{
name|blobStore
argument_list|()
operator|.
name|delete
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"cannot delete test data at "
operator|+
name|basePath
argument_list|()
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
DECL|method|testBlobPrefix
specifier|public
specifier|static
name|String
name|testBlobPrefix
parameter_list|(
name|String
name|seed
parameter_list|)
block|{
return|return
name|TESTS_FILE
operator|+
name|seed
return|;
block|}
annotation|@
name|Override
DECL|method|isReadOnly
specifier|public
name|boolean
name|isReadOnly
parameter_list|()
block|{
return|return
name|readOnly
return|;
block|}
comment|// package private, only use for testing
DECL|method|blobContainer
name|BlobContainer
name|blobContainer
parameter_list|()
block|{
return|return
name|snapshotsBlobContainer
return|;
block|}
DECL|method|writeSnapshotsToIndexGen
specifier|protected
name|void
name|writeSnapshotsToIndexGen
parameter_list|(
specifier|final
name|List
argument_list|<
name|SnapshotId
argument_list|>
name|snapshots
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|isReadOnly
argument_list|()
operator|==
literal|false
assert|;
comment|// can not write to a read only repository
specifier|final
name|BytesReference
name|snapshotsBytes
decl_stmt|;
try|try
init|(
name|BytesStreamOutput
name|bStream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
init|)
block|{
try|try
init|(
name|StreamOutput
name|stream
init|=
operator|new
name|OutputStreamStreamOutput
argument_list|(
name|bStream
argument_list|)
init|)
block|{
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|XContentType
operator|.
name|JSON
argument_list|,
name|stream
argument_list|)
decl_stmt|;
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
name|builder
operator|.
name|startArray
argument_list|(
name|SNAPSHOTS
argument_list|)
expr_stmt|;
for|for
control|(
name|SnapshotId
name|snapshot
range|:
name|snapshots
control|)
block|{
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
name|NAME
argument_list|,
name|snapshot
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
name|UUID
argument_list|,
name|snapshot
operator|.
name|getUUID
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
block|}
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
name|builder
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|snapshotsBytes
operator|=
name|bStream
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
specifier|final
name|long
name|gen
init|=
name|latestIndexBlobId
argument_list|()
operator|+
literal|1
decl_stmt|;
comment|// write the index file
name|writeAtomic
argument_list|(
name|SNAPSHOTS_FILE_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|gen
argument_list|)
argument_list|,
name|snapshotsBytes
argument_list|)
expr_stmt|;
comment|// delete the N-2 index file if it exists, keep the previous one around as a backup
if|if
condition|(
name|isReadOnly
argument_list|()
operator|==
literal|false
operator|&&
name|gen
operator|-
literal|2
operator|>=
literal|0
condition|)
block|{
specifier|final
name|String
name|oldSnapshotIndexFile
init|=
name|SNAPSHOTS_FILE_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|gen
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotsBlobContainer
operator|.
name|blobExists
argument_list|(
name|oldSnapshotIndexFile
argument_list|)
condition|)
block|{
name|snapshotsBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|oldSnapshotIndexFile
argument_list|)
expr_stmt|;
block|}
block|}
comment|// write the current generation to the index-latest file
specifier|final
name|BytesReference
name|genBytes
decl_stmt|;
try|try
init|(
name|BytesStreamOutput
name|bStream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
init|)
block|{
name|bStream
operator|.
name|writeLong
argument_list|(
name|gen
argument_list|)
expr_stmt|;
name|genBytes
operator|=
name|bStream
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|snapshotsBlobContainer
operator|.
name|blobExists
argument_list|(
name|SNAPSHOTS_INDEX_LATEST_BLOB
argument_list|)
condition|)
block|{
name|snapshotsBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|SNAPSHOTS_INDEX_LATEST_BLOB
argument_list|)
expr_stmt|;
block|}
name|writeAtomic
argument_list|(
name|SNAPSHOTS_INDEX_LATEST_BLOB
argument_list|,
name|genBytes
argument_list|)
expr_stmt|;
block|}
DECL|method|readSnapshotsFromIndex
specifier|protected
name|List
argument_list|<
name|SnapshotId
argument_list|>
name|readSnapshotsFromIndex
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|long
name|indexGen
init|=
name|latestIndexBlobId
argument_list|()
decl_stmt|;
specifier|final
name|String
name|snapshotsIndexBlobName
decl_stmt|;
if|if
condition|(
name|indexGen
operator|==
operator|-
literal|1
condition|)
block|{
comment|// index-N file doesn't exist, either its a fresh repository, or its in the
comment|// old format, so look for the older index file before returning an empty list
name|snapshotsIndexBlobName
operator|=
name|SNAPSHOTS_FILE
expr_stmt|;
block|}
else|else
block|{
name|snapshotsIndexBlobName
operator|=
name|SNAPSHOTS_FILE_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|indexGen
argument_list|)
expr_stmt|;
block|}
try|try
init|(
name|InputStream
name|blob
init|=
name|snapshotsBlobContainer
operator|.
name|readBlob
argument_list|(
name|snapshotsIndexBlobName
argument_list|)
init|)
block|{
name|BytesStreamOutput
name|out
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|Streams
operator|.
name|copy
argument_list|(
name|blob
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|ArrayList
argument_list|<
name|SnapshotId
argument_list|>
name|snapshots
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentHelper
operator|.
name|createParser
argument_list|(
name|out
operator|.
name|bytes
argument_list|()
argument_list|)
init|)
block|{
if|if
condition|(
name|parser
operator|.
name|nextToken
argument_list|()
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
if|if
condition|(
name|parser
operator|.
name|nextToken
argument_list|()
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|String
name|currentFieldName
init|=
name|parser
operator|.
name|currentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|SNAPSHOTS
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
if|if
condition|(
name|parser
operator|.
name|nextToken
argument_list|()
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
while|while
condition|(
name|parser
operator|.
name|nextToken
argument_list|()
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
condition|)
block|{
comment|// the new format from 5.0 which contains the snapshot name and uuid
name|String
name|name
init|=
literal|null
decl_stmt|;
name|String
name|uuid
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|parser
operator|.
name|currentToken
argument_list|()
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
while|while
condition|(
name|parser
operator|.
name|nextToken
argument_list|()
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|NAME
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|name
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UUID
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|uuid
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
block|}
name|snapshots
operator|.
name|add
argument_list|(
operator|new
name|SnapshotId
argument_list|(
name|name
argument_list|,
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// the old format pre 5.0 that only contains the snapshot name, use the name as the uuid too
else|else
block|{
name|name
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
name|snapshots
operator|.
name|add
argument_list|(
operator|new
name|SnapshotId
argument_list|(
name|name
argument_list|,
name|SnapshotId
operator|.
name|UNASSIGNED_UUID
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|snapshots
argument_list|)
return|;
block|}
block|}
comment|// Package private for testing
DECL|method|blobId
specifier|static
name|String
name|blobId
parameter_list|(
specifier|final
name|SnapshotId
name|snapshotId
parameter_list|)
block|{
specifier|final
name|String
name|uuid
init|=
name|snapshotId
operator|.
name|getUUID
argument_list|()
decl_stmt|;
if|if
condition|(
name|uuid
operator|.
name|equals
argument_list|(
name|SnapshotId
operator|.
name|UNASSIGNED_UUID
argument_list|)
condition|)
block|{
comment|// the old snapshot blob naming
return|return
name|snapshotId
operator|.
name|getName
argument_list|()
return|;
block|}
return|return
name|snapshotId
operator|.
name|getName
argument_list|()
operator|+
literal|"-"
operator|+
name|uuid
return|;
block|}
comment|/**      * Get the latest snapshot index blob id.  Snapshot index blobs are named index-N, where N is      * the next version number from when the index blob was written.  Each individual index-N blob is      * only written once and never overwritten.  The highest numbered index-N blob is the latest one      * that contains the current snapshots in the repository.      *      * Package private for testing      */
DECL|method|latestIndexBlobId
name|long
name|latestIndexBlobId
parameter_list|()
throws|throws
name|IOException
block|{
try|try
block|{
comment|// first, try listing the blobs and determining which index blob is the latest
return|return
name|listBlobsToGetLatestIndexId
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|UnsupportedOperationException
name|e
parameter_list|)
block|{
comment|// could not list the blobs because the repository does not support the operation,
comment|// try reading from the index-latest file
try|try
block|{
return|return
name|readSnapshotIndexLatestBlob
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ioe
parameter_list|)
block|{
comment|// we likely could not find the blob, this can happen in two scenarios:
comment|//  (1) its an empty repository
comment|//  (2) when writing the index-latest blob, if the blob already exists,
comment|//      we first delete it, then atomically write the new blob.  there is
comment|//      a small window in time when the blob is deleted and the new one
comment|//      written - if the node crashes during that time, we won't have an
comment|//      index-latest blob
comment|// in a read-only repository, we can't know which of the two scenarios it is,
comment|// but we will assume (1) because we can't do anything about (2) anyway
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|// package private for testing
DECL|method|readSnapshotIndexLatestBlob
name|long
name|readSnapshotIndexLatestBlob
parameter_list|()
throws|throws
name|IOException
block|{
try|try
init|(
name|InputStream
name|blob
init|=
name|snapshotsBlobContainer
operator|.
name|readBlob
argument_list|(
name|SNAPSHOTS_INDEX_LATEST_BLOB
argument_list|)
init|)
block|{
name|BytesStreamOutput
name|out
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|Streams
operator|.
name|copy
argument_list|(
name|blob
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return
name|Numbers
operator|.
name|bytesToLong
argument_list|(
name|out
operator|.
name|bytes
argument_list|()
operator|.
name|toBytesRef
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|method|listBlobsToGetLatestIndexId
specifier|private
name|long
name|listBlobsToGetLatestIndexId
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
init|=
name|snapshotsBlobContainer
operator|.
name|listBlobsByPrefix
argument_list|(
name|SNAPSHOTS_FILE_PREFIX
argument_list|)
decl_stmt|;
name|long
name|latest
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|blobs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// no snapshot index blobs have been written yet
return|return
name|latest
return|;
block|}
for|for
control|(
specifier|final
name|BlobMetaData
name|blobMetaData
range|:
name|blobs
operator|.
name|values
argument_list|()
control|)
block|{
specifier|final
name|String
name|blobName
init|=
name|blobMetaData
operator|.
name|name
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|long
name|curr
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|blobName
operator|.
name|substring
argument_list|(
name|SNAPSHOTS_FILE_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|latest
operator|=
name|Math
operator|.
name|max
argument_list|(
name|latest
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
comment|// the index- blob wasn't of the format index-N where N is a number,
comment|// no idea what this blob is but it doesn't belong in the repository!
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] Unknown blob in the repository: {}"
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|latest
return|;
block|}
DECL|method|writeAtomic
specifier|private
name|void
name|writeAtomic
parameter_list|(
specifier|final
name|String
name|blobName
parameter_list|,
specifier|final
name|BytesReference
name|bytesRef
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|tempBlobName
init|=
literal|"pending-"
operator|+
name|blobName
decl_stmt|;
name|snapshotsBlobContainer
operator|.
name|writeBlob
argument_list|(
name|tempBlobName
argument_list|,
name|bytesRef
argument_list|)
expr_stmt|;
try|try
block|{
name|snapshotsBlobContainer
operator|.
name|move
argument_list|(
name|tempBlobName
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// Move failed - try cleaning up
name|snapshotsBlobContainer
operator|.
name|deleteBlob
argument_list|(
name|tempBlobName
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|snapshotShard
specifier|public
name|void
name|snapshotShard
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|IndexCommit
name|snapshotIndexCommit
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|SnapshotContext
name|snapshotContext
init|=
operator|new
name|SnapshotContext
argument_list|(
name|shard
argument_list|,
name|snapshotId
argument_list|,
name|snapshotStatus
argument_list|)
decl_stmt|;
name|snapshotStatus
operator|.
name|startTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|snapshotContext
operator|.
name|snapshot
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|failure
argument_list|(
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|IndexShardSnapshotFailedException
condition|)
block|{
throw|throw
operator|(
name|IndexShardSnapshotFailedException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|restoreShard
specifier|public
name|void
name|restoreShard
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
block|{
specifier|final
name|RestoreContext
name|snapshotContext
init|=
operator|new
name|RestoreContext
argument_list|(
name|shard
argument_list|,
name|snapshotId
argument_list|,
name|version
argument_list|,
name|snapshotShardId
argument_list|,
name|recoveryState
argument_list|)
decl_stmt|;
try|try
block|{
name|snapshotContext
operator|.
name|restore
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"failed to restore snapshot ["
operator|+
name|snapshotId
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|getShardSnapshotStatus
specifier|public
name|IndexShardSnapshotStatus
name|getShardSnapshotStatus
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|context
operator|.
name|loadSnapshot
argument_list|()
decl_stmt|;
name|IndexShardSnapshotStatus
name|status
init|=
operator|new
name|IndexShardSnapshotStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
name|status
operator|.
name|startTime
argument_list|(
name|snapshot
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|files
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// The snapshot is done which means the number of processed files is the same as total
name|status
operator|.
name|processedFiles
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|time
argument_list|(
name|snapshot
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
annotation|@
name|Override
DECL|method|verify
specifier|public
name|void
name|verify
parameter_list|(
name|String
name|seed
parameter_list|,
name|DiscoveryNode
name|localNode
parameter_list|)
block|{
name|BlobContainer
name|testBlobContainer
init|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|testBlobContainer
operator|.
name|blobExists
argument_list|(
literal|"master.dat"
argument_list|)
condition|)
block|{
try|try
block|{
name|testBlobContainer
operator|.
name|writeBlob
argument_list|(
literal|"data-"
operator|+
name|localNode
operator|.
name|getId
argument_list|()
operator|+
literal|".dat"
argument_list|,
operator|new
name|BytesArray
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"store location ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|"] is not accessible on the node ["
operator|+
name|localNode
operator|+
literal|"]"
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
literal|"a file written by master to the store ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|"] cannot be accessed on the node ["
operator|+
name|localNode
operator|+
literal|"]. "
operator|+
literal|"This might indicate that the store ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|"] is not shared between this node and the master node or "
operator|+
literal|"that permissions on the store don't allow reading files written by the master node"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Delete shard snapshot      *      * @param snapshotId snapshot id      * @param shardId    shard id      */
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|context
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BlobStoreRepository["
operator|+
literal|"["
operator|+
name|metadata
operator|.
name|name
argument_list|()
operator|+
literal|"], ["
operator|+
name|blobStore
argument_list|()
operator|+
literal|']'
operator|+
literal|']'
return|;
block|}
DECL|method|indexShardSnapshotFormat
name|BlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotFormat
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
if|if
condition|(
name|BlobStoreRepository
operator|.
name|legacyMetaData
argument_list|(
name|version
argument_list|)
condition|)
block|{
return|return
name|indexShardSnapshotLegacyFormat
return|;
block|}
else|else
block|{
return|return
name|indexShardSnapshotFormat
return|;
block|}
block|}
comment|/**      * Context for snapshot/restore operations      */
DECL|class|Context
specifier|private
class|class
name|Context
block|{
DECL|field|snapshotId
specifier|protected
specifier|final
name|SnapshotId
name|snapshotId
decl_stmt|;
DECL|field|shardId
specifier|protected
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|field|blobContainer
specifier|protected
specifier|final
name|BlobContainer
name|blobContainer
decl_stmt|;
DECL|field|version
specifier|protected
specifier|final
name|Version
name|version
decl_stmt|;
DECL|method|Context
specifier|public
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|this
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
DECL|method|Context
specifier|public
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|)
block|{
name|this
operator|.
name|snapshotId
operator|=
name|snapshotId
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|blobContainer
operator|=
name|blobStore
argument_list|()
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|()
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|snapshotShardId
operator|.
name|getIndexName
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|snapshotShardId
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**          * Delete shard snapshot          */
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to list content of gateway"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|tuple
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|tuple
operator|.
name|v1
argument_list|()
decl_stmt|;
name|int
name|fileListGeneration
init|=
name|tuple
operator|.
name|v2
argument_list|()
decl_stmt|;
try|try
block|{
name|indexShardSnapshotFormat
argument_list|(
name|version
argument_list|)
operator|.
name|delete
argument_list|(
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] failed to delete shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
comment|// Build a list of snapshots that should be preserved
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|newSnapshotsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SnapshotFiles
name|point
range|:
name|snapshots
control|)
block|{
if|if
condition|(
operator|!
name|point
operator|.
name|snapshot
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
comment|// finalize the snapshot and rewrite the snapshot index with the next sequential snapshot index
name|finalize
argument_list|(
name|newSnapshotsList
argument_list|,
name|fileListGeneration
operator|+
literal|1
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
block|}
comment|/**          * Loads information about shard snapshot          */
DECL|method|loadSnapshot
specifier|public
name|BlobStoreIndexShardSnapshot
name|loadSnapshot
parameter_list|()
block|{
try|try
block|{
return|return
name|indexShardSnapshotFormat
argument_list|(
name|version
argument_list|)
operator|.
name|read
argument_list|(
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to read shard snapshot file"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**          * Removes all unreferenced files from the repository and writes new index file          *          * We need to be really careful in handling index files in case of failures to make sure we have index file that          * points to files that were deleted.          *          *          * @param snapshots list of active snapshots in the container          * @param fileListGeneration the generation number of the snapshot index file          * @param blobs     list of blobs in the container          */
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|(
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|snapshots
parameter_list|,
name|int
name|fileListGeneration
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobStoreIndexShardSnapshots
name|newSnapshots
init|=
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
decl_stmt|;
comment|// delete old index files first
for|for
control|(
name|String
name|blobName
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|indexShardSnapshotsFormat
operator|.
name|isTempBlobName
argument_list|(
name|blobName
argument_list|)
operator|||
name|blobName
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// We cannot delete index file - this is fatal, we cannot continue, otherwise we might end up
comment|// with references to non-existing files
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"error deleting index file ["
operator|+
name|blobName
operator|+
literal|"] during cleanup"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// now go over all the blobs, and if they don't exist in a snapshot, delete them
for|for
control|(
name|String
name|blobName
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// delete unused files
if|if
condition|(
name|blobName
operator|.
name|startsWith
argument_list|(
name|DATA_BLOB_PREFIX
argument_list|)
condition|)
block|{
if|if
condition|(
name|newSnapshots
operator|.
name|findNameFile
argument_list|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|blobName
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// TODO: don't catch and let the user handle it?
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] error deleting blob [{}] during cleanup"
argument_list|,
name|e
argument_list|,
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// If we deleted all snapshots - we don't need to create the index file
if|if
condition|(
name|snapshots
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|indexShardSnapshotsFormat
operator|.
name|writeAtomic
argument_list|(
name|newSnapshots
argument_list|,
name|blobContainer
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|fileListGeneration
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to write file list"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**          * Generates blob name          *          * @param generation the blob number          * @return the blob name          */
DECL|method|fileNameFromGeneration
specifier|protected
name|String
name|fileNameFromGeneration
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
return|return
name|DATA_BLOB_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|generation
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
comment|/**          * Finds the next available blob number          *          * @param blobs list of blobs in the repository          * @return next available blob number          */
DECL|method|findLatestFileNameGeneration
specifier|protected
name|long
name|findLatestFileNameGeneration
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|long
name|generation
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|DATA_BLOB_PREFIX
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|currentGen
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|DATA_BLOB_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentGen
operator|>
name|generation
condition|)
block|{
name|generation
operator|=
name|currentGen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"file [{}] does not conform to the '{}' schema"
argument_list|,
name|name
argument_list|,
name|DATA_BLOB_PREFIX
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|generation
return|;
block|}
comment|/**          * Loads all available snapshots in the repository          *          * @param blobs list of blobs in repository          * @return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation          */
DECL|method|buildBlobStoreIndexShardSnapshots
specifier|protected
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|buildBlobStoreIndexShardSnapshots
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|int
name|latest
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|int
name|gen
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|>
name|latest
condition|)
block|{
name|latest
operator|=
name|gen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to parse index file name [{}]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|latest
operator|>=
literal|0
condition|)
block|{
try|try
block|{
specifier|final
name|BlobStoreIndexShardSnapshots
name|shardSnapshots
init|=
name|indexShardSnapshotsFormat
operator|.
name|read
argument_list|(
name|blobContainer
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|latest
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|shardSnapshots
argument_list|,
name|latest
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to read index file  [{}]"
argument_list|,
name|e
argument_list|,
name|SNAPSHOT_INDEX_PREFIX
operator|+
name|latest
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We couldn't load the index file - falling back to loading individual snapshots
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|snapshots
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
try|try
block|{
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_PREFIX
argument_list|)
condition|)
block|{
name|snapshot
operator|=
name|indexShardSnapshotFormat
operator|.
name|readBlob
argument_list|(
name|blobContainer
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|LEGACY_SNAPSHOT_PREFIX
argument_list|)
condition|)
block|{
name|snapshot
operator|=
name|indexShardSnapshotLegacyFormat
operator|.
name|readBlob
argument_list|(
name|blobContainer
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snapshot
operator|!=
literal|null
condition|)
block|{
name|snapshots
operator|.
name|add
argument_list|(
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to read commit point [{}]"
argument_list|,
name|e
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**      * Context for snapshot operations      */
DECL|class|SnapshotContext
specifier|private
class|class
name|SnapshotContext
extends|extends
name|Context
block|{
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|snapshotStatus
specifier|private
specifier|final
name|IndexShardSnapshotStatus
name|snapshotStatus
decl_stmt|;
comment|/**          * Constructs new context          *          * @param shard          shard to be snapshotted          * @param snapshotId     snapshot id          * @param snapshotStatus snapshot status to report progress          */
DECL|method|SnapshotContext
specifier|public
name|SnapshotContext
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|Version
operator|.
name|CURRENT
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotStatus
operator|=
name|snapshotStatus
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|shard
operator|.
name|store
argument_list|()
expr_stmt|;
block|}
comment|/**          * Create snapshot from index commit point          *          * @param snapshotIndexCommit snapshot commit point          */
DECL|method|snapshot
specifier|public
name|void
name|snapshot
parameter_list|(
name|IndexCommit
name|snapshotIndexCommit
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] snapshot to [{}] ..."
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to list blobs"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|generation
init|=
name|findLatestFileNameGeneration
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|tuple
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|tuple
operator|.
name|v1
argument_list|()
decl_stmt|;
name|int
name|fileListGeneration
init|=
name|tuple
operator|.
name|v2
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|indexCommitPointFiles
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|indexNumberOfFiles
init|=
literal|0
decl_stmt|;
name|long
name|indexTotalFilesSize
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|filesToSnapshot
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|metadata
decl_stmt|;
comment|// TODO apparently we don't use the MetadataSnapshot#.recoveryDiff(...) here but we should
specifier|final
name|Collection
argument_list|<
name|String
argument_list|>
name|fileNames
decl_stmt|;
try|try
block|{
name|metadata
operator|=
name|store
operator|.
name|getMetadata
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
name|fileNames
operator|=
name|snapshotIndexCommit
operator|.
name|getFileNames
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to get store file metadata"
argument_list|,
name|e
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|fileName
range|:
name|fileNames
control|)
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] Processing [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
specifier|final
name|StoreFileMetaData
name|md
init|=
name|metadata
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|existingFileInfo
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|filesInfo
init|=
name|snapshots
operator|.
name|findPhysicalIndexFiles
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|filesInfo
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
range|:
name|filesInfo
control|)
block|{
try|try
block|{
comment|// in 1.3.3 we added additional hashes for .si / segments_N files
comment|// to ensure we don't double the space in the repo since old snapshots
comment|// don't have this hash we try to read that hash from the blob store
comment|// in a bwc compatible way.
name|maybeRecalculateMetadataHash
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Can't calculate hash from blob for file [{}] [{}]"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fileInfo
operator|.
name|isSame
argument_list|(
name|md
argument_list|)
operator|&&
name|snapshotFileExistsInBlobs
argument_list|(
name|fileInfo
argument_list|,
name|blobs
argument_list|)
condition|)
block|{
comment|// a commit point file with the same name, size and checksum was already copied to repository
comment|// we will reuse it for this snapshot
name|existingFileInfo
operator|=
name|fileInfo
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|existingFileInfo
operator|==
literal|null
condition|)
block|{
name|indexNumberOfFiles
operator|++
expr_stmt|;
name|indexTotalFilesSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// create a new FileInfo
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|snapshotFileInfo
init|=
operator|new
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|(
name|fileNameFromGeneration
argument_list|(
operator|++
name|generation
argument_list|)
argument_list|,
name|md
argument_list|,
name|chunkSize
argument_list|()
argument_list|)
decl_stmt|;
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
name|filesToSnapshot
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|existingFileInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|snapshotStatus
operator|.
name|files
argument_list|(
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted during initialization"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|STARTED
argument_list|)
expr_stmt|;
for|for
control|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|snapshotFileInfo
range|:
name|filesToSnapshot
control|)
block|{
try|try
block|{
name|snapshotFile
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to perform snapshot (index files)"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|snapshotStatus
operator|.
name|indexVersion
argument_list|(
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
comment|// now create and write the commit point
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FINALIZE
argument_list|)
expr_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
operator|new
name|BlobStoreIndexShardSnapshot
argument_list|(
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|,
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|indexCommitPointFiles
argument_list|,
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
comment|// snapshotStatus.startTime() is assigned on the same machine, so it's safe to use with VLong
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
decl_stmt|;
comment|//TODO: The time stored in snapshot doesn't include cleanup time.
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] writing shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexShardSnapshotFormat
operator|.
name|write
argument_list|(
name|snapshot
argument_list|,
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to write commit point"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// delete all files that are not referenced by any commit point
comment|// build a new BlobStoreIndexShardSnapshot, that includes this one and all the saved ones
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|newSnapshotsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|newSnapshotsList
operator|.
name|add
argument_list|(
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SnapshotFiles
name|point
range|:
name|snapshots
control|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
comment|// finalize the snapshot and rewrite the snapshot index with the next sequential snapshot index
name|finalize
argument_list|(
name|newSnapshotsList
argument_list|,
name|fileListGeneration
operator|+
literal|1
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Snapshot individual file          *<p>          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be snapshotted          */
DECL|method|snapshotFile
specifier|private
name|void
name|snapshotFile
parameter_list|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|file
init|=
name|fileInfo
operator|.
name|physicalName
argument_list|()
decl_stmt|;
try|try
init|(
name|IndexInput
name|indexInput
init|=
name|store
operator|.
name|openVerifyingInput
argument_list|(
name|file
argument_list|,
name|IOContext
operator|.
name|READONCE
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileInfo
operator|.
name|numberOfParts
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|long
name|partBytes
init|=
name|fileInfo
operator|.
name|partBytes
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|final
name|InputStreamIndexInput
name|inputStreamIndexInput
init|=
operator|new
name|InputStreamIndexInput
argument_list|(
name|indexInput
argument_list|,
name|partBytes
argument_list|)
decl_stmt|;
name|InputStream
name|inputStream
init|=
name|inputStreamIndexInput
decl_stmt|;
if|if
condition|(
name|snapshotRateLimiter
operator|!=
literal|null
condition|)
block|{
name|inputStream
operator|=
operator|new
name|RateLimitingInputStream
argument_list|(
name|inputStreamIndexInput
argument_list|,
name|snapshotRateLimiter
argument_list|,
name|snapshotRateLimitingTimeInNanos
operator|::
name|inc
argument_list|)
expr_stmt|;
block|}
name|inputStream
operator|=
operator|new
name|AbortableInputStream
argument_list|(
name|inputStream
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
name|blobContainer
operator|.
name|writeBlob
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|i
argument_list|)
argument_list|,
name|inputStream
argument_list|,
name|partBytes
argument_list|)
expr_stmt|;
block|}
name|Store
operator|.
name|verify
argument_list|(
name|indexInput
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|t
parameter_list|)
block|{
name|failStoreIfCorrupted
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
DECL|method|failStoreIfCorrupted
specifier|private
name|void
name|failStoreIfCorrupted
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|CorruptIndexException
operator|||
name|e
operator|instanceof
name|IndexFormatTooOldException
operator|||
name|e
operator|instanceof
name|IndexFormatTooNewException
condition|)
block|{
try|try
block|{
name|store
operator|.
name|markStoreCorrupted
argument_list|(
operator|(
name|IOException
operator|)
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|inner
parameter_list|)
block|{
name|inner
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"store cannot be marked as corrupted"
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Checks if snapshot file already exists in the list of blobs          *          * @param fileInfo file to check          * @param blobs    list of blobs          * @return true if file exists in the list of blobs          */
DECL|method|snapshotFileExistsInBlobs
specifier|private
name|boolean
name|snapshotFileExistsInBlobs
parameter_list|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobMetaData
name|blobMetaData
init|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blobMetaData
operator|!=
literal|null
condition|)
block|{
return|return
name|blobMetaData
operator|.
name|length
argument_list|()
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|blobs
operator|.
name|containsKey
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|// multi part file sum up the size and check
name|int
name|part
init|=
literal|0
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|blobMetaData
operator|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|part
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobMetaData
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|totalSize
operator|+=
name|blobMetaData
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|totalSize
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
comment|// no file, not exact and not multipart
return|return
literal|false
return|;
block|}
DECL|class|AbortableInputStream
specifier|private
class|class
name|AbortableInputStream
extends|extends
name|FilterInputStream
block|{
DECL|field|fileName
specifier|private
specifier|final
name|String
name|fileName
decl_stmt|;
DECL|method|AbortableInputStream
specifier|public
name|AbortableInputStream
parameter_list|(
name|InputStream
name|delegate
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
DECL|method|checkAborted
specifier|private
name|void
name|checkAborted
parameter_list|()
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * This is a BWC layer to ensure we update the snapshots metadata with the corresponding hashes before we compare them.      * The new logic for StoreFileMetaData reads the entire<tt>.si</tt> and<tt>segments.n</tt> files to strengthen the      * comparison of the files on a per-segment / per-commit level.      */
DECL|method|maybeRecalculateMetadataHash
specifier|private
specifier|static
name|void
name|maybeRecalculateMetadataHash
parameter_list|(
specifier|final
name|BlobContainer
name|blobContainer
parameter_list|,
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
name|Store
operator|.
name|MetadataSnapshot
name|snapshot
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|StoreFileMetaData
name|metadata
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|!=
literal|null
operator|&&
operator|(
name|metadata
operator|=
name|snapshot
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|metadata
operator|.
name|hash
argument_list|()
operator|.
name|length
operator|>
literal|0
operator|&&
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|hash
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// we have a hash - check if our repo has a hash too otherwise we have
comment|// to calculate it.
comment|// we might have multiple parts even though the file is small... make sure we read all of it.
try|try
init|(
specifier|final
name|InputStream
name|stream
init|=
operator|new
name|PartSliceStream
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|)
init|)
block|{
name|BytesRefBuilder
name|builder
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|Store
operator|.
name|MetadataSnapshot
operator|.
name|hashFile
argument_list|(
name|builder
argument_list|,
name|stream
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|BytesRef
name|hash
init|=
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|hash
argument_list|()
decl_stmt|;
comment|// reset the file infos metadata hash
assert|assert
name|hash
operator|.
name|length
operator|==
literal|0
assert|;
name|hash
operator|.
name|bytes
operator|=
name|builder
operator|.
name|bytes
argument_list|()
expr_stmt|;
name|hash
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|hash
operator|.
name|length
operator|=
name|builder
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|PartSliceStream
specifier|private
specifier|static
specifier|final
class|class
name|PartSliceStream
extends|extends
name|SlicedInputStream
block|{
DECL|field|container
specifier|private
specifier|final
name|BlobContainer
name|container
decl_stmt|;
DECL|field|info
specifier|private
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|info
decl_stmt|;
DECL|method|PartSliceStream
specifier|public
name|PartSliceStream
parameter_list|(
name|BlobContainer
name|container
parameter_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|info
parameter_list|)
block|{
name|super
argument_list|(
name|info
operator|.
name|numberOfParts
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|this
operator|.
name|container
operator|=
name|container
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|openSlice
specifier|protected
name|InputStream
name|openSlice
parameter_list|(
name|long
name|slice
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|container
operator|.
name|readBlob
argument_list|(
name|info
operator|.
name|partName
argument_list|(
name|slice
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Context for restore operations      */
DECL|class|RestoreContext
specifier|private
class|class
name|RestoreContext
extends|extends
name|Context
block|{
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|recoveryState
specifier|private
specifier|final
name|RecoveryState
name|recoveryState
decl_stmt|;
comment|/**          * Constructs new restore context          *          * @param shard           shard to restore into          * @param snapshotId      snapshot id          * @param snapshotShardId shard in the snapshot that data should be restored from          * @param recoveryState   recovery state to report progress          */
DECL|method|RestoreContext
specifier|public
name|RestoreContext
parameter_list|(
name|IndexShard
name|shard
parameter_list|,
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|snapshotShardId
argument_list|)
expr_stmt|;
name|this
operator|.
name|recoveryState
operator|=
name|recoveryState
expr_stmt|;
name|store
operator|=
name|shard
operator|.
name|store
argument_list|()
expr_stmt|;
block|}
comment|/**          * Performs restore operation          */
DECL|method|restore
specifier|public
name|void
name|restore
parameter_list|()
throws|throws
name|IOException
block|{
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] restoring to [{}] ..."
argument_list|,
name|snapshotId
argument_list|,
name|metadata
operator|.
name|name
argument_list|()
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|loadSnapshot
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshot
operator|.
name|indexFiles
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|snapshot
operator|.
name|indexFiles
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|physicalName
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"segments_"
argument_list|)
operator|&&
name|snapshot
operator|.
name|indexFiles
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|hasUnknownChecksum
argument_list|()
condition|)
block|{
comment|// If the shard has no documents, it will only contain a single segments_N file for the
comment|// shard's snapshot.  If we are restoring a snapshot created by a previous supported version,
comment|// it is still possible that in that version, an empty shard has a segments_N file with an unsupported
comment|// version (and no checksum), because we don't know the Lucene version to assign segments_N until we
comment|// have written some data.  Since the segments_N for an empty shard could have an incompatible Lucene
comment|// version number and no checksum, even though the index itself is perfectly fine to restore, this
comment|// empty shard would cause exceptions to be thrown.  Since there is no data to restore from an empty
comment|// shard anyway, we just create the empty shard here and then exit.
name|IndexWriter
name|writer
init|=
operator|new
name|IndexWriter
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|,
operator|new
name|IndexWriterConfig
argument_list|(
literal|null
argument_list|)
operator|.
name|setOpenMode
argument_list|(
name|IndexWriterConfig
operator|.
name|OpenMode
operator|.
name|CREATE
argument_list|)
operator|.
name|setCommitOnClose
argument_list|(
literal|true
argument_list|)
argument_list|)
decl_stmt|;
name|writer
operator|.
name|close
argument_list|()
expr_stmt|;
return|return;
block|}
name|SnapshotFiles
name|snapshotFiles
init|=
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|recoveryTargetMetadata
decl_stmt|;
try|try
block|{
name|recoveryTargetMetadata
operator|=
name|store
operator|.
name|getMetadataOrEmpty
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Can't read metadata from store"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Can't restore corrupted shard"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|filesToRecover
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|StoreFileMetaData
argument_list|>
name|snapshotMetaData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|fileInfos
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
range|:
name|snapshot
operator|.
name|indexFiles
argument_list|()
control|)
block|{
try|try
block|{
comment|// in 1.3.3 we added additional hashes for .si / segments_N files
comment|// to ensure we don't double the space in the repo since old snapshots
comment|// don't have this hash we try to read that hash from the blob store
comment|// in a bwc compatible way.
name|maybeRecalculateMetadataHash
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|,
name|recoveryTargetMetadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// if the index is broken we might not be able to read it
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Can't calculate hash from blog for file [{}] [{}]"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|snapshotMetaData
operator|.
name|put
argument_list|(
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
name|fileInfos
operator|.
name|put
argument_list|(
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|sourceMetaData
init|=
operator|new
name|Store
operator|.
name|MetadataSnapshot
argument_list|(
name|unmodifiableMap
argument_list|(
name|snapshotMetaData
argument_list|)
argument_list|,
name|emptyMap
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Store
operator|.
name|RecoveryDiff
name|diff
init|=
name|sourceMetaData
operator|.
name|recoveryDiff
argument_list|(
name|recoveryTargetMetadata
argument_list|)
decl_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|diff
operator|.
name|identical
control|)
block|{
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
init|=
name|fileInfos
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addFileDetail
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|Iterables
operator|.
name|concat
argument_list|(
name|diff
operator|.
name|different
argument_list|,
name|diff
operator|.
name|missing
argument_list|)
control|)
block|{
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
init|=
name|fileInfos
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|filesToRecover
operator|.
name|add
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addFileDetail
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering [{}] from [{}], does not exists in local store"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering [{}] from [{}], exists in local store but is different"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|RecoveryState
operator|.
name|Index
name|index
init|=
name|recoveryState
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|filesToRecover
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"no files to recover, all exists within the local store"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering_files [{}] with total_size [{}], reusing_files [{}] with reused_size [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|index
operator|.
name|totalRecoverFiles
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|index
operator|.
name|totalRecoverBytes
argument_list|()
argument_list|)
argument_list|,
name|index
operator|.
name|reusedFileCount
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|index
operator|.
name|reusedFileCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileToRecover
range|:
name|filesToRecover
control|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] restoring file [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileToRecover
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|restoreFile
argument_list|(
name|fileToRecover
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to recover index"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
specifier|final
name|StoreFileMetaData
name|restoredSegmentsFile
init|=
name|sourceMetaData
operator|.
name|getSegmentsFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|recoveryTargetMetadata
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Snapshot has no segments file"
argument_list|)
throw|;
block|}
assert|assert
name|restoredSegmentsFile
operator|!=
literal|null
assert|;
comment|// read the snapshot data persisted
specifier|final
name|SegmentInfos
name|segmentCommitInfos
decl_stmt|;
try|try
block|{
name|segmentCommitInfos
operator|=
name|Lucene
operator|.
name|pruneUnreferencedFiles
argument_list|(
name|restoredSegmentsFile
operator|.
name|name
argument_list|()
argument_list|,
name|store
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to fetch index version after copying it over"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|updateVersion
argument_list|(
name|segmentCommitInfos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|/// now, go over and clean files that are in the store, but were not in the snapshot
try|try
block|{
for|for
control|(
name|String
name|storeFile
range|:
name|store
operator|.
name|directory
argument_list|()
operator|.
name|listAll
argument_list|()
control|)
block|{
if|if
condition|(
name|Store
operator|.
name|isAutogenerated
argument_list|(
name|storeFile
argument_list|)
operator|||
name|snapshotFiles
operator|.
name|containPhysicalIndexFile
argument_list|(
name|storeFile
argument_list|)
condition|)
block|{
continue|continue;
comment|//skip write.lock, checksum files and files that exist in the snapshot
block|}
try|try
block|{
name|store
operator|.
name|deleteQuiet
argument_list|(
literal|"restore"
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
name|store
operator|.
name|directory
argument_list|()
operator|.
name|deleteFile
argument_list|(
name|storeFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to delete file [{}] during snapshot cleanup"
argument_list|,
name|snapshotId
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to list directory - some of files might not be deleted"
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Restores a file          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be restored          */
DECL|method|restoreFile
specifier|private
name|void
name|restoreFile
parameter_list|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
init|(
name|InputStream
name|partSliceStream
init|=
operator|new
name|PartSliceStream
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|)
init|)
block|{
specifier|final
name|InputStream
name|stream
decl_stmt|;
if|if
condition|(
name|restoreRateLimiter
operator|==
literal|null
condition|)
block|{
name|stream
operator|=
name|partSliceStream
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|=
operator|new
name|RateLimitingInputStream
argument_list|(
name|partSliceStream
argument_list|,
name|restoreRateLimiter
argument_list|,
name|restoreRateLimitingTimeInNanos
operator|::
name|inc
argument_list|)
expr_stmt|;
block|}
try|try
init|(
specifier|final
name|IndexOutput
name|indexOutput
init|=
name|store
operator|.
name|createVerifyingOutput
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
init|)
block|{
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
while|while
condition|(
operator|(
name|length
operator|=
name|stream
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|indexOutput
operator|.
name|writeBytes
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addRecoveredBytesToFile
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|Store
operator|.
name|verify
argument_list|(
name|indexOutput
argument_list|)
expr_stmt|;
name|indexOutput
operator|.
name|close
argument_list|()
expr_stmt|;
name|store
operator|.
name|directory
argument_list|()
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|ex
parameter_list|)
block|{
try|try
block|{
name|store
operator|.
name|markStoreCorrupted
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"store cannot be marked as corrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ex
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|store
operator|.
name|deleteQuiet
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

