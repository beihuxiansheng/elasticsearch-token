begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.snapshots
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectObjectCursor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateUpdateTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|SnapshotsInProgress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|service
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableOpenMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|SnapshotFailedEngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardSnapshotStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|EmptyTransportResponseHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequestHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|SnapshotsInProgress
operator|.
name|completed
import|;
end_import

begin_comment
comment|/**  * This service runs on data and master nodes and controls currently snapshotted shards on these nodes. It is responsible for  * starting and stopping shard level snapshots  */
end_comment

begin_class
DECL|class|SnapshotShardsService
specifier|public
class|class
name|SnapshotShardsService
extends|extends
name|AbstractLifecycleComponent
implements|implements
name|ClusterStateListener
block|{
DECL|field|UPDATE_SNAPSHOT_ACTION_NAME
specifier|public
specifier|static
specifier|final
name|String
name|UPDATE_SNAPSHOT_ACTION_NAME
init|=
literal|"internal:cluster/snapshot/update_snapshot"
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|indicesService
specifier|private
specifier|final
name|IndicesService
name|indicesService
decl_stmt|;
DECL|field|snapshotsService
specifier|private
specifier|final
name|SnapshotsService
name|snapshotsService
decl_stmt|;
DECL|field|transportService
specifier|private
specifier|final
name|TransportService
name|transportService
decl_stmt|;
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|shutdownLock
specifier|private
specifier|final
name|Lock
name|shutdownLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
DECL|field|shutdownCondition
specifier|private
specifier|final
name|Condition
name|shutdownCondition
init|=
name|shutdownLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
DECL|field|shardSnapshots
specifier|private
specifier|volatile
name|Map
argument_list|<
name|Snapshot
argument_list|,
name|SnapshotShards
argument_list|>
name|shardSnapshots
init|=
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|updatedSnapshotStateQueue
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|UpdateIndexShardSnapshotStatusRequest
argument_list|>
name|updatedSnapshotStateQueue
init|=
name|ConcurrentCollections
operator|.
name|newBlockingQueue
argument_list|()
decl_stmt|;
annotation|@
name|Inject
DECL|method|SnapshotShardsService
specifier|public
name|SnapshotShardsService
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|SnapshotsService
name|snapshotsService
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|TransportService
name|transportService
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
name|this
operator|.
name|snapshotsService
operator|=
name|snapshotsService
expr_stmt|;
name|this
operator|.
name|transportService
operator|=
name|transportService
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
if|if
condition|(
name|DiscoveryNode
operator|.
name|isDataNode
argument_list|(
name|settings
argument_list|)
condition|)
block|{
comment|// this is only useful on the nodes that can hold data
comment|// addLast to make sure that Repository will be created before snapshot
name|clusterService
operator|.
name|addLast
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DiscoveryNode
operator|.
name|isMasterNode
argument_list|(
name|settings
argument_list|)
condition|)
block|{
comment|// This needs to run only on nodes that can become masters
name|transportService
operator|.
name|registerRequestHandler
argument_list|(
name|UPDATE_SNAPSHOT_ACTION_NAME
argument_list|,
name|UpdateIndexShardSnapshotStatusRequest
operator|::
operator|new
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
operator|new
name|UpdateSnapshotStateRequestHandler
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{      }
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|shutdownLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
while|while
condition|(
operator|!
name|shardSnapshots
operator|.
name|isEmpty
argument_list|()
operator|&&
name|shutdownCondition
operator|.
name|await
argument_list|(
literal|5
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
condition|)
block|{
comment|// Wait for at most 5 second for locally running snapshots to finish
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|shutdownLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{
name|clusterService
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clusterChanged
specifier|public
name|void
name|clusterChanged
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
try|try
block|{
name|SnapshotsInProgress
name|prev
init|=
name|event
operator|.
name|previousState
argument_list|()
operator|.
name|custom
argument_list|(
name|SnapshotsInProgress
operator|.
name|TYPE
argument_list|)
decl_stmt|;
name|SnapshotsInProgress
name|curr
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|custom
argument_list|(
name|SnapshotsInProgress
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|curr
operator|!=
literal|null
condition|)
block|{
name|processIndexShardSnapshots
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prev
operator|.
name|equals
argument_list|(
name|curr
argument_list|)
operator|==
literal|false
condition|)
block|{
name|processIndexShardSnapshots
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
name|String
name|masterNodeId
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodeId
argument_list|()
decl_stmt|;
if|if
condition|(
name|masterNodeId
operator|!=
literal|null
operator|&&
name|masterNodeId
operator|.
name|equals
argument_list|(
name|event
operator|.
name|previousState
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodeId
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|syncShardStatsOnNewMaster
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to update snapshot state "
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns status of shards that are snapshotted on the node and belong to the given snapshot      *<p>      * This method is executed on data node      *</p>      *      * @param snapshot  snapshot      * @return map of shard id to snapshot status      */
DECL|method|currentSnapshotShards
specifier|public
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|currentSnapshotShards
parameter_list|(
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|SnapshotShards
name|snapshotShards
init|=
name|shardSnapshots
operator|.
name|get
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotShards
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
return|return
name|snapshotShards
operator|.
name|shards
return|;
block|}
block|}
comment|/**      * Checks if any new shards should be snapshotted on this node      *      * @param event cluster state changed event      */
DECL|method|processIndexShardSnapshots
specifier|private
name|void
name|processIndexShardSnapshots
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|SnapshotsInProgress
name|snapshotsInProgress
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|custom
argument_list|(
name|SnapshotsInProgress
operator|.
name|TYPE
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|Snapshot
argument_list|,
name|SnapshotShards
argument_list|>
name|survivors
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// First, remove snapshots that are no longer there
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Snapshot
argument_list|,
name|SnapshotShards
argument_list|>
name|entry
range|:
name|shardSnapshots
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Snapshot
name|snapshot
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshotsInProgress
operator|!=
literal|null
operator|&&
name|snapshotsInProgress
operator|.
name|snapshot
argument_list|(
name|snapshot
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|survivors
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// For now we will be mostly dealing with a single snapshot at a time but might have multiple simultaneously running
comment|// snapshots in the future
name|Map
argument_list|<
name|Snapshot
argument_list|,
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
argument_list|>
name|newSnapshots
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Now go through all snapshots and update existing or create missing
specifier|final
name|String
name|localNodeId
init|=
name|clusterService
operator|.
name|localNode
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|snapshotsInProgress
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|SnapshotsInProgress
operator|.
name|Entry
name|entry
range|:
name|snapshotsInProgress
operator|.
name|entries
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|state
argument_list|()
operator|==
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|STARTED
condition|)
block|{
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|startedShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|SnapshotShards
name|snapshotShards
init|=
name|shardSnapshots
operator|.
name|get
argument_list|(
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ObjectObjectCursor
argument_list|<
name|ShardId
argument_list|,
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|>
name|shard
range|:
name|entry
operator|.
name|shards
argument_list|()
control|)
block|{
comment|// Add all new shards to start processing on
if|if
condition|(
name|localNodeId
operator|.
name|equals
argument_list|(
name|shard
operator|.
name|value
operator|.
name|nodeId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|shard
operator|.
name|value
operator|.
name|state
argument_list|()
operator|==
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|INIT
operator|&&
operator|(
name|snapshotShards
operator|==
literal|null
operator|||
operator|!
name|snapshotShards
operator|.
name|shards
operator|.
name|containsKey
argument_list|(
name|shard
operator|.
name|key
argument_list|)
operator|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] - Adding shard to the queue"
argument_list|,
name|shard
operator|.
name|key
argument_list|)
expr_stmt|;
name|startedShards
operator|.
name|put
argument_list|(
name|shard
operator|.
name|key
argument_list|,
operator|new
name|IndexShardSnapshotStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|startedShards
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|newSnapshots
operator|.
name|put
argument_list|(
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
name|startedShards
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapshotShards
operator|!=
literal|null
condition|)
block|{
comment|// We already saw this snapshot but we need to add more started shards
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|shards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Put all shards that were already running on this node
name|shards
operator|.
name|putAll
argument_list|(
name|snapshotShards
operator|.
name|shards
argument_list|)
expr_stmt|;
comment|// Put all newly started shards
name|shards
operator|.
name|putAll
argument_list|(
name|startedShards
argument_list|)
expr_stmt|;
name|survivors
operator|.
name|put
argument_list|(
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
operator|new
name|SnapshotShards
argument_list|(
name|unmodifiableMap
argument_list|(
name|shards
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Brand new snapshot that we haven't seen before
name|survivors
operator|.
name|put
argument_list|(
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
operator|new
name|SnapshotShards
argument_list|(
name|unmodifiableMap
argument_list|(
name|startedShards
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|.
name|state
argument_list|()
operator|==
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|ABORTED
condition|)
block|{
comment|// Abort all running shards for this snapshot
name|SnapshotShards
name|snapshotShards
init|=
name|shardSnapshots
operator|.
name|get
argument_list|(
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotShards
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ObjectObjectCursor
argument_list|<
name|ShardId
argument_list|,
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|>
name|shard
range|:
name|entry
operator|.
name|shards
argument_list|()
control|)
block|{
name|IndexShardSnapshotStatus
name|snapshotStatus
init|=
name|snapshotShards
operator|.
name|shards
operator|.
name|get
argument_list|(
name|shard
operator|.
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotStatus
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|snapshotStatus
operator|.
name|stage
argument_list|()
condition|)
block|{
case|case
name|INIT
case|:
case|case
name|STARTED
case|:
name|snapshotStatus
operator|.
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|FINALIZE
case|:
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] trying to cancel snapshot on shard [{}] that is finalizing, letting it finish"
argument_list|,
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shard
operator|.
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONE
case|:
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] trying to cancel snapshot on the shard [{}] that is already done, updating status on the master"
argument_list|,
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shard
operator|.
name|key
argument_list|)
expr_stmt|;
name|updateIndexShardSnapshotStatus
argument_list|(
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shard
operator|.
name|key
argument_list|,
operator|new
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|SUCCESS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FAILURE
case|:
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] trying to cancel snapshot on the shard [{}] that has already failed, updating status on the master"
argument_list|,
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shard
operator|.
name|key
argument_list|)
expr_stmt|;
name|updateIndexShardSnapshotStatus
argument_list|(
name|entry
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shard
operator|.
name|key
argument_list|,
operator|new
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|snapshotStatus
operator|.
name|failure
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Unknown snapshot shard stage "
operator|+
name|snapshotStatus
operator|.
name|stage
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|// Update the list of snapshots that we saw and tried to started
comment|// If startup of these shards fails later, we don't want to try starting these shards again
name|shutdownLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|shardSnapshots
operator|=
name|unmodifiableMap
argument_list|(
name|survivors
argument_list|)
expr_stmt|;
if|if
condition|(
name|shardSnapshots
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// Notify all waiting threads that no more snapshots
name|shutdownCondition
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|shutdownLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// We have new shards to starts
if|if
condition|(
name|newSnapshots
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|Executor
name|executor
init|=
name|threadPool
operator|.
name|executor
argument_list|(
name|ThreadPool
operator|.
name|Names
operator|.
name|SNAPSHOT
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|Snapshot
argument_list|,
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
argument_list|>
name|entry
range|:
name|newSnapshots
operator|.
name|entrySet
argument_list|()
control|)
block|{
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|shardEntry
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|ShardId
name|shardId
init|=
name|shardEntry
operator|.
name|getKey
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|IndexShard
name|indexShard
init|=
name|indicesService
operator|.
name|indexServiceSafe
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|AbstractRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|doRun
parameter_list|()
block|{
name|snapshot
argument_list|(
name|indexShard
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|shardEntry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|updateIndexShardSnapshotStatus
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|shardId
argument_list|,
operator|new
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|(
name|localNodeId
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|SUCCESS
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] [{}] failed to create snapshot"
argument_list|,
name|t
argument_list|,
name|shardId
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|updateIndexShardSnapshotStatus
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|shardId
argument_list|,
operator|new
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|(
name|localNodeId
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|updateIndexShardSnapshotStatus
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|shardId
argument_list|,
operator|new
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|(
name|localNodeId
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Creates shard snapshot      *      * @param snapshot       snapshot      * @param snapshotStatus snapshot status      */
DECL|method|snapshot
specifier|private
name|void
name|snapshot
parameter_list|(
specifier|final
name|IndexShard
name|indexShard
parameter_list|,
specifier|final
name|Snapshot
name|snapshot
parameter_list|,
specifier|final
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|IndexShardRepository
name|indexShardRepository
init|=
name|snapshotsService
operator|.
name|getRepositoriesService
argument_list|()
operator|.
name|indexShardRepository
argument_list|(
name|snapshot
operator|.
name|getRepository
argument_list|()
argument_list|)
decl_stmt|;
name|ShardId
name|shardId
init|=
name|indexShard
operator|.
name|shardId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indexShard
operator|.
name|routingEntry
argument_list|()
operator|.
name|primary
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"snapshot should be performed only on primary"
argument_list|)
throw|;
block|}
if|if
condition|(
name|indexShard
operator|.
name|routingEntry
argument_list|()
operator|.
name|relocating
argument_list|()
condition|)
block|{
comment|// do not snapshot when in the process of relocation of primaries so we won't get conflicts
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"cannot snapshot while relocating"
argument_list|)
throw|;
block|}
if|if
condition|(
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CREATED
operator|||
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
comment|// shard has just been created, or still recovering
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"shard didn't fully recover yet"
argument_list|)
throw|;
block|}
try|try
block|{
comment|// we flush first to make sure we get the latest writes snapshotted
name|IndexCommit
name|snapshotIndexCommit
init|=
name|indexShard
operator|.
name|snapshotIndex
argument_list|(
literal|true
argument_list|)
decl_stmt|;
try|try
block|{
name|indexShardRepository
operator|.
name|snapshot
argument_list|(
name|snapshot
operator|.
name|getSnapshotId
argument_list|()
argument_list|,
name|shardId
argument_list|,
name|snapshotIndexCommit
argument_list|,
name|snapshotStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"    index    : version ["
argument_list|)
operator|.
name|append
argument_list|(
name|snapshotStatus
operator|.
name|indexVersion
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], number_of_files ["
argument_list|)
operator|.
name|append
argument_list|(
name|snapshotStatus
operator|.
name|numberOfFiles
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"] with total_size ["
argument_list|)
operator|.
name|append
argument_list|(
operator|new
name|ByteSizeValue
argument_list|(
name|snapshotStatus
operator|.
name|totalSize
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"snapshot ({}) completed to {}, took [{}]\n{}"
argument_list|,
name|snapshot
argument_list|,
name|indexShardRepository
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|snapshotStatus
operator|.
name|time
argument_list|()
argument_list|)
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|indexShard
operator|.
name|releaseSnapshot
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SnapshotFailedEngineException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|IndexShardSnapshotFailedException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to snapshot"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks if any shards were processed that the new master doesn't know about      */
DECL|method|syncShardStatsOnNewMaster
specifier|private
name|void
name|syncShardStatsOnNewMaster
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|SnapshotsInProgress
name|snapshotsInProgress
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|custom
argument_list|(
name|SnapshotsInProgress
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotsInProgress
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|SnapshotsInProgress
operator|.
name|Entry
name|snapshot
range|:
name|snapshotsInProgress
operator|.
name|entries
argument_list|()
control|)
block|{
if|if
condition|(
name|snapshot
operator|.
name|state
argument_list|()
operator|==
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|STARTED
operator|||
name|snapshot
operator|.
name|state
argument_list|()
operator|==
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|ABORTED
condition|)
block|{
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|localShards
init|=
name|currentSnapshotShards
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localShards
operator|!=
literal|null
condition|)
block|{
name|ImmutableOpenMap
argument_list|<
name|ShardId
argument_list|,
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|>
name|masterShards
init|=
name|snapshot
operator|.
name|shards
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|localShard
range|:
name|localShards
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|ShardId
name|shardId
init|=
name|localShard
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|IndexShardSnapshotStatus
name|localShardStatus
init|=
name|localShard
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
name|masterShard
init|=
name|masterShards
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|masterShard
operator|!=
literal|null
operator|&&
name|masterShard
operator|.
name|state
argument_list|()
operator|.
name|completed
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// Master knows about the shard and thinks it has not completed
if|if
condition|(
name|localShardStatus
operator|.
name|stage
argument_list|()
operator|==
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
condition|)
block|{
comment|// but we think the shard is done - we need to make new master know that the shard is done
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] new master thinks the shard [{}] is not completed but the shard is done locally, updating status on the master"
argument_list|,
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|updateIndexShardSnapshotStatus
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shardId
argument_list|,
operator|new
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|SUCCESS
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|localShard
operator|.
name|getValue
argument_list|()
operator|.
name|stage
argument_list|()
operator|==
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FAILURE
condition|)
block|{
comment|// but we think the shard failed - we need to make new master know that the shard failed
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] new master thinks the shard [{}] is not completed but the shard failed locally, updating status on master"
argument_list|,
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|updateIndexShardSnapshotStatus
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shardId
argument_list|,
operator|new
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|FAILED
argument_list|,
name|localShardStatus
operator|.
name|failure
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Stores the list of shards that has to be snapshotted on this node      */
DECL|class|SnapshotShards
specifier|private
specifier|static
class|class
name|SnapshotShards
block|{
DECL|field|shards
specifier|private
specifier|final
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|shards
decl_stmt|;
DECL|method|SnapshotShards
specifier|private
name|SnapshotShards
parameter_list|(
name|Map
argument_list|<
name|ShardId
argument_list|,
name|IndexShardSnapshotStatus
argument_list|>
name|shards
parameter_list|)
block|{
name|this
operator|.
name|shards
operator|=
name|shards
expr_stmt|;
block|}
block|}
comment|/**      * Internal request that is used to send changes in snapshot status to master      */
DECL|class|UpdateIndexShardSnapshotStatusRequest
specifier|public
specifier|static
class|class
name|UpdateIndexShardSnapshotStatusRequest
extends|extends
name|TransportRequest
block|{
DECL|field|snapshot
specifier|private
name|Snapshot
name|snapshot
decl_stmt|;
DECL|field|shardId
specifier|private
name|ShardId
name|shardId
decl_stmt|;
DECL|field|status
specifier|private
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
name|status
decl_stmt|;
DECL|field|processed
specifier|private
specifier|volatile
name|boolean
name|processed
decl_stmt|;
comment|// state field, no need to serialize
DECL|method|UpdateIndexShardSnapshotStatusRequest
specifier|public
name|UpdateIndexShardSnapshotStatusRequest
parameter_list|()
block|{          }
DECL|method|UpdateIndexShardSnapshotStatusRequest
specifier|public
name|UpdateIndexShardSnapshotStatusRequest
parameter_list|(
name|Snapshot
name|snapshot
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
name|status
parameter_list|)
block|{
name|this
operator|.
name|snapshot
operator|=
name|snapshot
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|snapshot
operator|=
operator|new
name|Snapshot
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|shardId
operator|=
name|ShardId
operator|.
name|readShardId
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|status
operator|=
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
operator|.
name|readShardSnapshotStatus
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|snapshot
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|shardId
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|status
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|snapshot
specifier|public
name|Snapshot
name|snapshot
parameter_list|()
block|{
return|return
name|snapshot
return|;
block|}
DECL|method|shardId
specifier|public
name|ShardId
name|shardId
parameter_list|()
block|{
return|return
name|shardId
return|;
block|}
DECL|method|status
specifier|public
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
name|status
parameter_list|()
block|{
return|return
name|status
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|""
operator|+
name|snapshot
operator|+
literal|", shardId ["
operator|+
name|shardId
operator|+
literal|"], status ["
operator|+
name|status
operator|.
name|state
argument_list|()
operator|+
literal|"]"
return|;
block|}
DECL|method|markAsProcessed
specifier|public
name|void
name|markAsProcessed
parameter_list|()
block|{
name|processed
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|isProcessed
specifier|public
name|boolean
name|isProcessed
parameter_list|()
block|{
return|return
name|processed
return|;
block|}
block|}
comment|/**      * Updates the shard status      */
DECL|method|updateIndexShardSnapshotStatus
specifier|public
name|void
name|updateIndexShardSnapshotStatus
parameter_list|(
name|Snapshot
name|snapshot
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
name|status
parameter_list|)
block|{
name|UpdateIndexShardSnapshotStatusRequest
name|request
init|=
operator|new
name|UpdateIndexShardSnapshotStatusRequest
argument_list|(
name|snapshot
argument_list|,
name|shardId
argument_list|,
name|status
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|clusterService
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|isLocalNodeElectedMaster
argument_list|()
condition|)
block|{
name|innerUpdateSnapshotState
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|transportService
operator|.
name|sendRequest
argument_list|(
name|clusterService
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|,
name|UPDATE_SNAPSHOT_ACTION_NAME
argument_list|,
name|request
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] [{}] failed to update snapshot state"
argument_list|,
name|t
argument_list|,
name|request
operator|.
name|snapshot
argument_list|()
argument_list|,
name|request
operator|.
name|status
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Updates the shard status on master node      *      * @param request update shard status request      */
DECL|method|innerUpdateSnapshotState
specifier|private
name|void
name|innerUpdateSnapshotState
parameter_list|(
specifier|final
name|UpdateIndexShardSnapshotStatusRequest
name|request
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"received updated snapshot restore state [{}]"
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|updatedSnapshotStateQueue
operator|.
name|add
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"update snapshot state"
argument_list|,
operator|new
name|ClusterStateUpdateTask
argument_list|()
block|{
specifier|private
specifier|final
name|List
argument_list|<
name|UpdateIndexShardSnapshotStatusRequest
argument_list|>
name|drainedRequests
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ClusterState
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
comment|// The request was already processed as a part of an early batch - skipping
if|if
condition|(
name|request
operator|.
name|isProcessed
argument_list|()
condition|)
block|{
return|return
name|currentState
return|;
block|}
name|updatedSnapshotStateQueue
operator|.
name|drainTo
argument_list|(
name|drainedRequests
argument_list|)
expr_stmt|;
specifier|final
name|int
name|batchSize
init|=
name|drainedRequests
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// nothing to process (a previous event has processed it already)
if|if
condition|(
name|batchSize
operator|==
literal|0
condition|)
block|{
return|return
name|currentState
return|;
block|}
specifier|final
name|SnapshotsInProgress
name|snapshots
init|=
name|currentState
operator|.
name|custom
argument_list|(
name|SnapshotsInProgress
operator|.
name|TYPE
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshots
operator|!=
literal|null
condition|)
block|{
name|int
name|changedCount
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|SnapshotsInProgress
operator|.
name|Entry
argument_list|>
name|entries
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SnapshotsInProgress
operator|.
name|Entry
name|entry
range|:
name|snapshots
operator|.
name|entries
argument_list|()
control|)
block|{
name|ImmutableOpenMap
operator|.
name|Builder
argument_list|<
name|ShardId
argument_list|,
name|SnapshotsInProgress
operator|.
name|ShardSnapshotStatus
argument_list|>
name|shards
init|=
name|ImmutableOpenMap
operator|.
name|builder
argument_list|()
decl_stmt|;
name|boolean
name|updated
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|batchSize
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|UpdateIndexShardSnapshotStatusRequest
name|updateSnapshotState
init|=
name|drainedRequests
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|updateSnapshotState
operator|.
name|markAsProcessed
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|.
name|snapshot
argument_list|()
operator|.
name|equals
argument_list|(
name|updateSnapshotState
operator|.
name|snapshot
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] Updating shard [{}] with status [{}]"
argument_list|,
name|updateSnapshotState
operator|.
name|snapshot
argument_list|()
argument_list|,
name|updateSnapshotState
operator|.
name|shardId
argument_list|()
argument_list|,
name|updateSnapshotState
operator|.
name|status
argument_list|()
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|updated
operator|==
literal|false
condition|)
block|{
name|shards
operator|.
name|putAll
argument_list|(
name|entry
operator|.
name|shards
argument_list|()
argument_list|)
expr_stmt|;
name|updated
operator|=
literal|true
expr_stmt|;
block|}
name|shards
operator|.
name|put
argument_list|(
name|updateSnapshotState
operator|.
name|shardId
argument_list|()
argument_list|,
name|updateSnapshotState
operator|.
name|status
argument_list|()
argument_list|)
expr_stmt|;
name|changedCount
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|updated
condition|)
block|{
if|if
condition|(
name|completed
argument_list|(
name|shards
operator|.
name|values
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|entries
operator|.
name|add
argument_list|(
operator|new
name|SnapshotsInProgress
operator|.
name|Entry
argument_list|(
name|entry
argument_list|,
name|shards
operator|.
name|build
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Snapshot is finished - mark it as done
comment|// TODO: Add PARTIAL_SUCCESS status?
name|SnapshotsInProgress
operator|.
name|Entry
name|updatedEntry
init|=
operator|new
name|SnapshotsInProgress
operator|.
name|Entry
argument_list|(
name|entry
argument_list|,
name|SnapshotsInProgress
operator|.
name|State
operator|.
name|SUCCESS
argument_list|,
name|shards
operator|.
name|build
argument_list|()
argument_list|)
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
name|updatedEntry
argument_list|)
expr_stmt|;
comment|// Finalize snapshot in the repository
name|snapshotsService
operator|.
name|endSnapshot
argument_list|(
name|updatedEntry
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"snapshot [{}] is done"
argument_list|,
name|updatedEntry
operator|.
name|snapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|entries
operator|.
name|add
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changedCount
operator|>
literal|0
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"changed cluster state triggered by {} snapshot state updates"
argument_list|,
name|changedCount
argument_list|)
expr_stmt|;
specifier|final
name|SnapshotsInProgress
name|updatedSnapshots
init|=
operator|new
name|SnapshotsInProgress
argument_list|(
name|entries
operator|.
name|toArray
argument_list|(
operator|new
name|SnapshotsInProgress
operator|.
name|Entry
index|[
name|entries
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|ClusterState
operator|.
name|builder
argument_list|(
name|currentState
argument_list|)
operator|.
name|putCustom
argument_list|(
name|SnapshotsInProgress
operator|.
name|TYPE
argument_list|,
name|updatedSnapshots
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
return|return
name|currentState
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
for|for
control|(
name|UpdateIndexShardSnapshotStatusRequest
name|request
range|:
name|drainedRequests
control|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] failed to update snapshot status to [{}]"
argument_list|,
name|t
argument_list|,
name|request
operator|.
name|snapshot
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|status
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Transport request handler that is used to send changes in snapshot status to master      */
DECL|class|UpdateSnapshotStateRequestHandler
class|class
name|UpdateSnapshotStateRequestHandler
implements|implements
name|TransportRequestHandler
argument_list|<
name|UpdateIndexShardSnapshotStatusRequest
argument_list|>
block|{
annotation|@
name|Override
DECL|method|messageReceived
specifier|public
name|void
name|messageReceived
parameter_list|(
name|UpdateIndexShardSnapshotStatusRequest
name|request
parameter_list|,
specifier|final
name|TransportChannel
name|channel
parameter_list|)
throws|throws
name|Exception
block|{
name|innerUpdateSnapshotState
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|channel
operator|.
name|sendResponse
argument_list|(
name|TransportResponse
operator|.
name|Empty
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

