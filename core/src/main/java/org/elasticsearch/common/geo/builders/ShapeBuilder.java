begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.geo.builders
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|builders
package|;
end_package

begin_import
import|import
name|org
operator|.
name|locationtech
operator|.
name|spatial4j
operator|.
name|context
operator|.
name|jts
operator|.
name|JtsSpatialContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|locationtech
operator|.
name|spatial4j
operator|.
name|exception
operator|.
name|InvalidShapeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|locationtech
operator|.
name|spatial4j
operator|.
name|shape
operator|.
name|Shape
import|;
end_import

begin_import
import|import
name|org
operator|.
name|locationtech
operator|.
name|spatial4j
operator|.
name|shape
operator|.
name|jts
operator|.
name|JtsGeometry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|Coordinate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|Geometry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|GeometryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|ToXContentToBytes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|NamedWriteable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|DistanceUnit
operator|.
name|Distance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ToXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|geo
operator|.
name|GeoShapeFieldMapper
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_comment
comment|/**  * Basic class for building GeoJSON shapes like Polygons, Linestrings, etc  */
end_comment

begin_class
DECL|class|ShapeBuilder
specifier|public
specifier|abstract
class|class
name|ShapeBuilder
extends|extends
name|ToXContentToBytes
implements|implements
name|NamedWriteable
block|{
DECL|field|LOGGER
specifier|protected
specifier|static
specifier|final
name|ESLogger
name|LOGGER
init|=
name|ESLoggerFactory
operator|.
name|getLogger
argument_list|(
name|ShapeBuilder
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|DEBUG
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
decl_stmt|;
static|static
block|{
comment|// if asserts are enabled we run the debug statements even if they are not logged
comment|// to prevent exceptions only present if debug enabled
name|boolean
name|debug
init|=
literal|false
decl_stmt|;
assert|assert
name|debug
operator|=
literal|true
assert|;
name|DEBUG
operator|=
name|debug
expr_stmt|;
block|}
DECL|field|DATELINE
specifier|public
specifier|static
specifier|final
name|double
name|DATELINE
init|=
literal|180
decl_stmt|;
comment|/**      * coordinate at [0.0, 0.0]      */
DECL|field|ZERO_ZERO
specifier|public
specifier|static
specifier|final
name|Coordinate
name|ZERO_ZERO
init|=
operator|new
name|Coordinate
argument_list|(
literal|0.0
argument_list|,
literal|0.0
argument_list|)
decl_stmt|;
comment|// TODO how might we use JtsSpatialContextFactory to configure the context (esp. for non-geo)?
DECL|field|SPATIAL_CONTEXT
specifier|public
specifier|static
specifier|final
name|JtsSpatialContext
name|SPATIAL_CONTEXT
init|=
name|JtsSpatialContext
operator|.
name|GEO
decl_stmt|;
DECL|field|FACTORY
specifier|public
specifier|static
specifier|final
name|GeometryFactory
name|FACTORY
init|=
name|SPATIAL_CONTEXT
operator|.
name|getGeometryFactory
argument_list|()
decl_stmt|;
comment|/** We're expecting some geometries might cross the dateline. */
DECL|field|wrapdateline
specifier|protected
specifier|final
name|boolean
name|wrapdateline
init|=
name|SPATIAL_CONTEXT
operator|.
name|isGeo
argument_list|()
decl_stmt|;
comment|/** It's possible that some geometries in a MULTI* shape might overlap. With the possible exception of GeometryCollection,      * this normally isn't allowed.      */
DECL|field|multiPolygonMayOverlap
specifier|protected
specifier|final
name|boolean
name|multiPolygonMayOverlap
init|=
literal|false
decl_stmt|;
comment|/** @see org.locationtech.spatial4j.shape.jts.JtsGeometry#validate() */
DECL|field|autoValidateJtsGeometry
specifier|protected
specifier|final
name|boolean
name|autoValidateJtsGeometry
init|=
literal|true
decl_stmt|;
comment|/** @see org.locationtech.spatial4j.shape.jts.JtsGeometry#index() */
DECL|field|autoIndexJtsGeometry
specifier|protected
specifier|final
name|boolean
name|autoIndexJtsGeometry
init|=
literal|true
decl_stmt|;
comment|//may want to turn off once SpatialStrategy impls do it.
DECL|method|ShapeBuilder
specifier|protected
name|ShapeBuilder
parameter_list|()
block|{     }
DECL|method|jtsGeometry
specifier|protected
name|JtsGeometry
name|jtsGeometry
parameter_list|(
name|Geometry
name|geom
parameter_list|)
block|{
comment|//dateline180Check is false because ElasticSearch does it's own dateline wrapping
name|JtsGeometry
name|jtsGeometry
init|=
operator|new
name|JtsGeometry
argument_list|(
name|geom
argument_list|,
name|SPATIAL_CONTEXT
argument_list|,
literal|false
argument_list|,
name|multiPolygonMayOverlap
argument_list|)
decl_stmt|;
if|if
condition|(
name|autoValidateJtsGeometry
condition|)
name|jtsGeometry
operator|.
name|validate
argument_list|()
expr_stmt|;
if|if
condition|(
name|autoIndexJtsGeometry
condition|)
name|jtsGeometry
operator|.
name|index
argument_list|()
expr_stmt|;
return|return
name|jtsGeometry
return|;
block|}
comment|/**      * Create a new Shape from this builder. Since calling this method could change the      * defined shape. (by inserting new coordinates or change the position of points)      * the builder looses its validity. So this method should only be called once on a builder      * @return new {@link Shape} defined by the builder      */
DECL|method|build
specifier|public
specifier|abstract
name|Shape
name|build
parameter_list|()
function_decl|;
comment|/**      * Recursive method which parses the arrays of coordinates used to define      * Shapes      *      * @param parser      *            Parser that will be read from      * @return CoordinateNode representing the start of the coordinate tree      * @throws IOException      *             Thrown if an error occurs while reading from the      *             XContentParser      */
DECL|method|parseCoordinates
specifier|private
specifier|static
name|CoordinateNode
name|parseCoordinates
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
comment|// Base cases
if|if
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
operator|&&
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
operator|&&
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
name|double
name|lon
init|=
name|parser
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|double
name|lat
init|=
name|parser
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
while|while
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NUMBER
condition|)
block|{
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|CoordinateNode
argument_list|(
operator|new
name|Coordinate
argument_list|(
name|lon
argument_list|,
name|lat
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"coordinates cannot contain NULL values)"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|CoordinateNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|parseCoordinates
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|CoordinateNode
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/**      * Create a new {@link ShapeBuilder} from {@link XContent}      * @param parser parser to read the GeoShape from      * @return {@link ShapeBuilder} read from the parser or null      *          if the parsers current token has been<code>null</code>      * @throws IOException if the input could not be read      */
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|GeoShapeType
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Create a new {@link ShapeBuilder} from {@link XContent}      * @param parser parser to read the GeoShape from      * @param geoDocMapper document field mapper reference required for spatial parameters relevant      *                     to the shape construction process (e.g., orientation)      *                     todo: refactor to place build specific parameters in the SpatialContext      * @return {@link ShapeBuilder} read from the parser or null      *          if the parsers current token has been<code>null</code>      * @throws IOException if the input could not be read      */
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|GeoShapeFieldMapper
name|geoDocMapper
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|GeoShapeType
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|geoDocMapper
argument_list|)
return|;
block|}
DECL|method|toXContent
specifier|protected
specifier|static
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Coordinate
name|coordinate
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|builder
operator|.
name|startArray
argument_list|()
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|x
argument_list|)
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|y
argument_list|)
operator|.
name|endArray
argument_list|()
return|;
block|}
DECL|method|writeCoordinateTo
specifier|protected
specifier|static
name|void
name|writeCoordinateTo
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|,
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeDouble
argument_list|(
name|coordinate
operator|.
name|x
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeDouble
argument_list|(
name|coordinate
operator|.
name|y
argument_list|)
expr_stmt|;
block|}
DECL|method|readFromStream
specifier|protected
specifier|static
name|Coordinate
name|readFromStream
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
operator|new
name|Coordinate
argument_list|(
name|in
operator|.
name|readDouble
argument_list|()
argument_list|,
name|in
operator|.
name|readDouble
argument_list|()
argument_list|)
return|;
block|}
DECL|method|shift
specifier|protected
specifier|static
name|Coordinate
name|shift
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|,
name|double
name|dateline
parameter_list|)
block|{
if|if
condition|(
name|dateline
operator|==
literal|0
condition|)
block|{
return|return
name|coordinate
return|;
block|}
else|else
block|{
return|return
operator|new
name|Coordinate
argument_list|(
operator|-
literal|2
operator|*
name|dateline
operator|+
name|coordinate
operator|.
name|x
argument_list|,
name|coordinate
operator|.
name|y
argument_list|)
return|;
block|}
block|}
comment|/**      * get the shapes type      * @return type of the shape      */
DECL|method|type
specifier|public
specifier|abstract
name|GeoShapeType
name|type
parameter_list|()
function_decl|;
comment|/**      * Calculate the intersection of a line segment and a vertical dateline.      *      * @param p1      *            start-point of the line segment      * @param p2      *            end-point of the line segment      * @param dateline      *            x-coordinate of the vertical dateline      * @return position of the intersection in the open range (0..1] if the line      *         segment intersects with the line segment. Otherwise this method      *         returns {@link Double#NaN}      */
DECL|method|intersection
specifier|protected
specifier|static
specifier|final
name|double
name|intersection
parameter_list|(
name|Coordinate
name|p1
parameter_list|,
name|Coordinate
name|p2
parameter_list|,
name|double
name|dateline
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|.
name|x
operator|==
name|p2
operator|.
name|x
operator|&&
name|p1
operator|.
name|x
operator|!=
name|dateline
condition|)
block|{
return|return
name|Double
operator|.
name|NaN
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|.
name|x
operator|==
name|p2
operator|.
name|x
operator|&&
name|p1
operator|.
name|x
operator|==
name|dateline
condition|)
block|{
return|return
literal|1.0
return|;
block|}
else|else
block|{
specifier|final
name|double
name|t
init|=
operator|(
name|dateline
operator|-
name|p1
operator|.
name|x
operator|)
operator|/
operator|(
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
operator|)
decl_stmt|;
if|if
condition|(
name|t
operator|>
literal|1
operator|||
name|t
operator|<=
literal|0
condition|)
block|{
return|return
name|Double
operator|.
name|NaN
return|;
block|}
else|else
block|{
return|return
name|t
return|;
block|}
block|}
block|}
comment|/**      * Calculate all intersections of line segments and a vertical line. The      * Array of edges will be ordered asc by the y-coordinate of the      * intersections of edges.      *      * @param dateline      *            x-coordinate of the dateline      * @param edges      *            set of edges that may intersect with the dateline      * @return number of intersecting edges      */
DECL|method|intersections
specifier|protected
specifier|static
name|int
name|intersections
parameter_list|(
name|double
name|dateline
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|)
block|{
name|int
name|numIntersections
init|=
literal|0
decl_stmt|;
assert|assert
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|dateline
argument_list|)
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edges
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Coordinate
name|p1
init|=
name|edges
index|[
name|i
index|]
operator|.
name|coordinate
decl_stmt|;
name|Coordinate
name|p2
init|=
name|edges
index|[
name|i
index|]
operator|.
name|next
operator|.
name|coordinate
decl_stmt|;
assert|assert
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|p2
operator|.
name|x
argument_list|)
operator|&&
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|p1
operator|.
name|x
argument_list|)
assert|;
name|edges
index|[
name|i
index|]
operator|.
name|intersect
operator|=
name|Edge
operator|.
name|MAX_COORDINATE
expr_stmt|;
name|double
name|position
init|=
name|intersection
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|dateline
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|edges
index|[
name|i
index|]
operator|.
name|intersection
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|numIntersections
operator|++
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|edges
argument_list|,
name|INTERSECTION_ORDER
argument_list|)
expr_stmt|;
return|return
name|numIntersections
return|;
block|}
comment|/**      * Node used to represent a tree of coordinates.      *<p>      * Can either be a leaf node consisting of a Coordinate, or a parent with      * children      */
DECL|class|CoordinateNode
specifier|protected
specifier|static
class|class
name|CoordinateNode
implements|implements
name|ToXContent
block|{
DECL|field|coordinate
specifier|protected
specifier|final
name|Coordinate
name|coordinate
decl_stmt|;
DECL|field|children
specifier|protected
specifier|final
name|List
argument_list|<
name|CoordinateNode
argument_list|>
name|children
decl_stmt|;
comment|/**          * Creates a new leaf CoordinateNode          *          * @param coordinate          *            Coordinate for the Node          */
DECL|method|CoordinateNode
specifier|protected
name|CoordinateNode
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|)
block|{
name|this
operator|.
name|coordinate
operator|=
name|coordinate
expr_stmt|;
name|this
operator|.
name|children
operator|=
literal|null
expr_stmt|;
block|}
comment|/**          * Creates a new parent CoordinateNode          *          * @param children          *            Children of the Node          */
DECL|method|CoordinateNode
specifier|protected
name|CoordinateNode
parameter_list|(
name|List
argument_list|<
name|CoordinateNode
argument_list|>
name|children
parameter_list|)
block|{
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
name|this
operator|.
name|coordinate
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|isEmpty
specifier|protected
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|(
name|coordinate
operator|==
literal|null
operator|&&
operator|(
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|startArray
argument_list|()
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|x
argument_list|)
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|y
argument_list|)
operator|.
name|endArray
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|startArray
argument_list|()
expr_stmt|;
for|for
control|(
name|CoordinateNode
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
block|}
comment|/**      * This helper class implements a linked list for {@link Coordinate}. It contains      * fields for a dateline intersection and component id      */
DECL|class|Edge
specifier|protected
specifier|static
specifier|final
class|class
name|Edge
block|{
DECL|field|coordinate
name|Coordinate
name|coordinate
decl_stmt|;
comment|// coordinate of the start point
DECL|field|next
name|Edge
name|next
decl_stmt|;
comment|// next segment
DECL|field|intersect
name|Coordinate
name|intersect
decl_stmt|;
comment|// potential intersection with dateline
DECL|field|component
name|int
name|component
init|=
operator|-
literal|1
decl_stmt|;
comment|// id of the component this edge belongs to
DECL|field|MAX_COORDINATE
specifier|public
specifier|static
specifier|final
name|Coordinate
name|MAX_COORDINATE
init|=
operator|new
name|Coordinate
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
decl_stmt|;
DECL|method|Edge
specifier|protected
name|Edge
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|,
name|Edge
name|next
parameter_list|,
name|Coordinate
name|intersection
parameter_list|)
block|{
name|this
operator|.
name|coordinate
operator|=
name|coordinate
expr_stmt|;
comment|// use setter to catch duplicate point cases
name|this
operator|.
name|setNext
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|this
operator|.
name|intersect
operator|=
name|intersection
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|component
operator|=
name|next
operator|.
name|component
expr_stmt|;
block|}
block|}
DECL|method|Edge
specifier|protected
name|Edge
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|,
name|Edge
name|next
parameter_list|)
block|{
name|this
argument_list|(
name|coordinate
argument_list|,
name|next
argument_list|,
name|Edge
operator|.
name|MAX_COORDINATE
argument_list|)
expr_stmt|;
block|}
DECL|method|setNext
specifier|protected
name|void
name|setNext
parameter_list|(
name|Edge
name|next
parameter_list|)
block|{
comment|// don't bother setting next if its null
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
comment|// self-loop throws an invalid shape
if|if
condition|(
name|this
operator|.
name|coordinate
operator|.
name|equals
argument_list|(
name|next
operator|.
name|coordinate
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|InvalidShapeException
argument_list|(
literal|"Provided shape has duplicate consecutive coordinates at: "
operator|+
name|this
operator|.
name|coordinate
argument_list|)
throw|;
block|}
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/**          * Set the intersection of this line segment to the given position          *          * @param position          *            position of the intersection [0..1]          * @return the {@link Coordinate} of the intersection          */
DECL|method|intersection
specifier|protected
name|Coordinate
name|intersection
parameter_list|(
name|double
name|position
parameter_list|)
block|{
return|return
name|intersect
operator|=
name|position
argument_list|(
name|coordinate
argument_list|,
name|next
operator|.
name|coordinate
argument_list|,
name|position
argument_list|)
return|;
block|}
DECL|method|position
specifier|protected
specifier|static
name|Coordinate
name|position
parameter_list|(
name|Coordinate
name|p1
parameter_list|,
name|Coordinate
name|p2
parameter_list|,
name|double
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|==
literal|0
condition|)
block|{
return|return
name|p1
return|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
literal|1
condition|)
block|{
return|return
name|p2
return|;
block|}
else|else
block|{
specifier|final
name|double
name|x
init|=
name|p1
operator|.
name|x
operator|+
name|position
operator|*
operator|(
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
operator|)
decl_stmt|;
specifier|final
name|double
name|y
init|=
name|p1
operator|.
name|y
operator|+
name|position
operator|*
operator|(
name|p2
operator|.
name|y
operator|-
name|p1
operator|.
name|y
operator|)
decl_stmt|;
return|return
operator|new
name|Coordinate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Edge[Component="
operator|+
name|component
operator|+
literal|"; start="
operator|+
name|coordinate
operator|+
literal|" "
operator|+
literal|"; intersection="
operator|+
name|intersect
operator|+
literal|"]"
return|;
block|}
block|}
DECL|field|INTERSECTION_ORDER
specifier|protected
specifier|static
specifier|final
name|IntersectionOrder
name|INTERSECTION_ORDER
init|=
operator|new
name|IntersectionOrder
argument_list|()
decl_stmt|;
DECL|class|IntersectionOrder
specifier|private
specifier|static
specifier|final
class|class
name|IntersectionOrder
implements|implements
name|Comparator
argument_list|<
name|Edge
argument_list|>
block|{
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|Edge
name|o1
parameter_list|,
name|Edge
name|o2
parameter_list|)
block|{
return|return
name|Double
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|intersect
operator|.
name|y
argument_list|,
name|o2
operator|.
name|intersect
operator|.
name|y
argument_list|)
return|;
block|}
block|}
DECL|enum|Orientation
specifier|public
specifier|static
enum|enum
name|Orientation
block|{
DECL|enum constant|LEFT
name|LEFT
block|,
DECL|enum constant|RIGHT
name|RIGHT
block|;
DECL|field|CLOCKWISE
specifier|public
specifier|static
specifier|final
name|Orientation
name|CLOCKWISE
init|=
name|Orientation
operator|.
name|LEFT
decl_stmt|;
DECL|field|COUNTER_CLOCKWISE
specifier|public
specifier|static
specifier|final
name|Orientation
name|COUNTER_CLOCKWISE
init|=
name|Orientation
operator|.
name|RIGHT
decl_stmt|;
DECL|field|CW
specifier|public
specifier|static
specifier|final
name|Orientation
name|CW
init|=
name|Orientation
operator|.
name|LEFT
decl_stmt|;
DECL|field|CCW
specifier|public
specifier|static
specifier|final
name|Orientation
name|CCW
init|=
name|Orientation
operator|.
name|RIGHT
decl_stmt|;
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeBoolean
argument_list|(
name|this
operator|==
name|Orientation
operator|.
name|RIGHT
argument_list|)
expr_stmt|;
block|}
DECL|method|readFrom
specifier|public
specifier|static
name|Orientation
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|in
operator|.
name|readBoolean
argument_list|()
condition|?
name|Orientation
operator|.
name|RIGHT
else|:
name|Orientation
operator|.
name|LEFT
return|;
block|}
DECL|method|fromString
specifier|public
specifier|static
name|Orientation
name|fromString
parameter_list|(
name|String
name|orientation
parameter_list|)
block|{
name|orientation
operator|=
name|orientation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|orientation
condition|)
block|{
case|case
literal|"right"
case|:
case|case
literal|"counterclockwise"
case|:
case|case
literal|"ccw"
case|:
return|return
name|Orientation
operator|.
name|RIGHT
return|;
case|case
literal|"left"
case|:
case|case
literal|"clockwise"
case|:
case|case
literal|"cw"
case|:
return|return
name|Orientation
operator|.
name|LEFT
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown orientation ["
operator|+
name|orientation
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|field|FIELD_TYPE
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_TYPE
init|=
literal|"type"
decl_stmt|;
DECL|field|FIELD_COORDINATES
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_COORDINATES
init|=
literal|"coordinates"
decl_stmt|;
DECL|field|FIELD_GEOMETRIES
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_GEOMETRIES
init|=
literal|"geometries"
decl_stmt|;
DECL|field|FIELD_ORIENTATION
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_ORIENTATION
init|=
literal|"orientation"
decl_stmt|;
DECL|method|debugEnabled
specifier|protected
specifier|static
specifier|final
name|boolean
name|debugEnabled
parameter_list|()
block|{
return|return
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
operator|||
name|DEBUG
return|;
block|}
comment|/**      * Enumeration that lists all {@link GeoShapeType}s that can be handled      */
DECL|enum|GeoShapeType
specifier|public
specifier|static
enum|enum
name|GeoShapeType
block|{
DECL|enum constant|POINT
name|POINT
argument_list|(
literal|"point"
argument_list|)
block|,
DECL|enum constant|MULTIPOINT
name|MULTIPOINT
argument_list|(
literal|"multipoint"
argument_list|)
block|,
DECL|enum constant|LINESTRING
name|LINESTRING
argument_list|(
literal|"linestring"
argument_list|)
block|,
DECL|enum constant|MULTILINESTRING
name|MULTILINESTRING
argument_list|(
literal|"multilinestring"
argument_list|)
block|,
DECL|enum constant|POLYGON
name|POLYGON
argument_list|(
literal|"polygon"
argument_list|)
block|,
DECL|enum constant|MULTIPOLYGON
name|MULTIPOLYGON
argument_list|(
literal|"multipolygon"
argument_list|)
block|,
DECL|enum constant|GEOMETRYCOLLECTION
name|GEOMETRYCOLLECTION
argument_list|(
literal|"geometrycollection"
argument_list|)
block|,
DECL|enum constant|ENVELOPE
name|ENVELOPE
argument_list|(
literal|"envelope"
argument_list|)
block|,
DECL|enum constant|CIRCLE
name|CIRCLE
argument_list|(
literal|"circle"
argument_list|)
block|;
DECL|field|shapename
specifier|private
specifier|final
name|String
name|shapename
decl_stmt|;
DECL|method|GeoShapeType
specifier|private
name|GeoShapeType
parameter_list|(
name|String
name|shapename
parameter_list|)
block|{
name|this
operator|.
name|shapename
operator|=
name|shapename
expr_stmt|;
block|}
DECL|method|shapeName
specifier|protected
name|String
name|shapeName
parameter_list|()
block|{
return|return
name|shapename
return|;
block|}
DECL|method|forName
specifier|public
specifier|static
name|GeoShapeType
name|forName
parameter_list|(
name|String
name|geoshapename
parameter_list|)
block|{
name|String
name|typename
init|=
name|geoshapename
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
for|for
control|(
name|GeoShapeType
name|type
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|type
operator|.
name|shapename
operator|.
name|equals
argument_list|(
name|typename
argument_list|)
condition|)
block|{
return|return
name|type
return|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unknown geo_shape ["
operator|+
name|geoshapename
operator|+
literal|"]"
argument_list|)
throw|;
block|}
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parse
argument_list|(
name|parser
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**          * Parse the geometry specified by the source document and return a ShapeBuilder instance used to          * build the actual geometry          * @param parser - parse utility object including source document          * @param shapeMapper - field mapper needed for index specific parameters          * @return ShapeBuilder - a builder instance used to create the geometry          */
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|GeoShapeFieldMapper
name|shapeMapper
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|parser
operator|.
name|currentToken
argument_list|()
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|.
name|currentToken
argument_list|()
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"shape must be an object consisting of type and coordinates"
argument_list|)
throw|;
block|}
name|GeoShapeType
name|shapeType
init|=
literal|null
decl_stmt|;
name|Distance
name|radius
init|=
literal|null
decl_stmt|;
name|CoordinateNode
name|node
init|=
literal|null
decl_stmt|;
name|GeometryCollectionBuilder
name|geometryCollections
init|=
literal|null
decl_stmt|;
name|Orientation
name|requestedOrientation
init|=
operator|(
name|shapeMapper
operator|==
literal|null
operator|)
condition|?
name|Orientation
operator|.
name|RIGHT
else|:
name|shapeMapper
operator|.
name|fieldType
argument_list|()
operator|.
name|orientation
argument_list|()
decl_stmt|;
name|boolean
name|coerce
init|=
operator|(
name|shapeMapper
operator|==
literal|null
operator|)
condition|?
name|GeoShapeFieldMapper
operator|.
name|Defaults
operator|.
name|COERCE
operator|.
name|value
argument_list|()
else|:
name|shapeMapper
operator|.
name|coerce
argument_list|()
operator|.
name|value
argument_list|()
decl_stmt|;
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|String
name|fieldName
init|=
name|parser
operator|.
name|currentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|FIELD_TYPE
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|shapeType
operator|=
name|GeoShapeType
operator|.
name|forName
argument_list|(
name|parser
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FIELD_COORDINATES
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|node
operator|=
name|parseCoordinates
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FIELD_GEOMETRIES
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|geometryCollections
operator|=
name|parseGeometries
argument_list|(
name|parser
argument_list|,
name|shapeMapper
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CircleBuilder
operator|.
name|FIELD_RADIUS
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|radius
operator|=
name|Distance
operator|.
name|parseDistance
argument_list|(
name|parser
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FIELD_ORIENTATION
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|requestedOrientation
operator|=
name|Orientation
operator|.
name|fromString
argument_list|(
name|parser
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|parser
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|shapeType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"shape type not included"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
literal|null
operator|&&
name|GeoShapeType
operator|.
name|GEOMETRYCOLLECTION
operator|!=
name|shapeType
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"coordinates not included"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|geometryCollections
operator|==
literal|null
operator|&&
name|GeoShapeType
operator|.
name|GEOMETRYCOLLECTION
operator|==
name|shapeType
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"geometries not included"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|radius
operator|!=
literal|null
operator|&&
name|GeoShapeType
operator|.
name|CIRCLE
operator|!=
name|shapeType
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"field [{}] is supported for [{}] only"
argument_list|,
name|CircleBuilder
operator|.
name|FIELD_RADIUS
argument_list|,
name|CircleBuilder
operator|.
name|TYPE
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|shapeType
condition|)
block|{
case|case
name|POINT
case|:
return|return
name|parsePoint
argument_list|(
name|node
argument_list|)
return|;
case|case
name|MULTIPOINT
case|:
return|return
name|parseMultiPoint
argument_list|(
name|node
argument_list|)
return|;
case|case
name|LINESTRING
case|:
return|return
name|parseLineString
argument_list|(
name|node
argument_list|)
return|;
case|case
name|MULTILINESTRING
case|:
return|return
name|parseMultiLine
argument_list|(
name|node
argument_list|)
return|;
case|case
name|POLYGON
case|:
return|return
name|parsePolygon
argument_list|(
name|node
argument_list|,
name|requestedOrientation
argument_list|,
name|coerce
argument_list|)
return|;
case|case
name|MULTIPOLYGON
case|:
return|return
name|parseMultiPolygon
argument_list|(
name|node
argument_list|,
name|requestedOrientation
argument_list|,
name|coerce
argument_list|)
return|;
case|case
name|CIRCLE
case|:
return|return
name|parseCircle
argument_list|(
name|node
argument_list|,
name|radius
argument_list|)
return|;
case|case
name|ENVELOPE
case|:
return|return
name|parseEnvelope
argument_list|(
name|node
argument_list|)
return|;
case|case
name|GEOMETRYCOLLECTION
case|:
return|return
name|geometryCollections
return|;
default|default:
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"shape type [{}] not included"
argument_list|,
name|shapeType
argument_list|)
throw|;
block|}
block|}
DECL|method|validatePointNode
specifier|protected
specifier|static
name|void
name|validatePointNode
parameter_list|(
name|CoordinateNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"invalid number of points (0) provided when expecting a single coordinate ([lat, lng])"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|coordinate
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"multipoint data provided when single point data expected."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|parsePoint
specifier|protected
specifier|static
name|PointBuilder
name|parsePoint
parameter_list|(
name|CoordinateNode
name|node
parameter_list|)
block|{
name|validatePointNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|ShapeBuilders
operator|.
name|newPoint
argument_list|(
name|node
operator|.
name|coordinate
argument_list|)
return|;
block|}
DECL|method|parseCircle
specifier|protected
specifier|static
name|CircleBuilder
name|parseCircle
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
name|Distance
name|radius
parameter_list|)
block|{
return|return
name|ShapeBuilders
operator|.
name|newCircleBuilder
argument_list|()
operator|.
name|center
argument_list|(
name|coordinates
operator|.
name|coordinate
argument_list|)
operator|.
name|radius
argument_list|(
name|radius
argument_list|)
return|;
block|}
DECL|method|parseEnvelope
specifier|protected
specifier|static
name|EnvelopeBuilder
name|parseEnvelope
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
comment|// validate the coordinate array for envelope type
if|if
condition|(
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"invalid number of points [{}] provided for geo_shape [{}] when expecting an array of 2 coordinates"
argument_list|,
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
argument_list|,
name|GeoShapeType
operator|.
name|ENVELOPE
operator|.
name|shapename
argument_list|)
throw|;
block|}
comment|// verify coordinate bounds, correct if necessary
name|Coordinate
name|uL
init|=
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|coordinate
decl_stmt|;
name|Coordinate
name|lR
init|=
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|coordinate
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|lR
operator|.
name|x
operator|<
name|uL
operator|.
name|x
operator|)
operator|||
operator|(
name|uL
operator|.
name|y
operator|<
name|lR
operator|.
name|y
operator|)
operator|)
condition|)
block|{
name|Coordinate
name|uLtmp
init|=
name|uL
decl_stmt|;
name|uL
operator|=
operator|new
name|Coordinate
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|uL
operator|.
name|x
argument_list|,
name|lR
operator|.
name|x
argument_list|)
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|uL
operator|.
name|y
argument_list|,
name|lR
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|lR
operator|=
operator|new
name|Coordinate
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|uLtmp
operator|.
name|x
argument_list|,
name|lR
operator|.
name|x
argument_list|)
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|uLtmp
operator|.
name|y
argument_list|,
name|lR
operator|.
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ShapeBuilders
operator|.
name|newEnvelope
argument_list|(
name|uL
argument_list|,
name|lR
argument_list|)
return|;
block|}
DECL|method|validateMultiPointNode
specifier|protected
specifier|static
name|void
name|validateMultiPointNode
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
if|if
condition|(
name|coordinates
operator|.
name|children
operator|==
literal|null
operator|||
name|coordinates
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|coordinates
operator|.
name|coordinate
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"single coordinate found when expecting an array of "
operator|+
literal|"coordinates. change type to point or change data to an array of>0 coordinates"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"no data provided for multipoint object when expecting "
operator|+
literal|">0 points (e.g., [[lat, lng]] or [[lat, lng], ...])"
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|CoordinateNode
name|point
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|validatePointNode
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseMultiPoint
specifier|protected
specifier|static
name|MultiPointBuilder
name|parseMultiPoint
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
name|validateMultiPointNode
argument_list|(
name|coordinates
argument_list|)
expr_stmt|;
name|CoordinatesBuilder
name|points
init|=
operator|new
name|CoordinatesBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|points
operator|.
name|coordinate
argument_list|(
name|node
operator|.
name|coordinate
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|MultiPointBuilder
argument_list|(
name|points
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
DECL|method|parseLineString
specifier|protected
specifier|static
name|LineStringBuilder
name|parseLineString
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
comment|/**              * Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)              * "coordinates" member must be an array of two or more positions              * LineStringBuilder should throw a graceful exception if< 2 coordinates/points are provided              */
if|if
condition|(
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"invalid number of points in LineString (found [{}] - must be>= 2)"
argument_list|,
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
name|CoordinatesBuilder
name|line
init|=
operator|new
name|CoordinatesBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|line
operator|.
name|coordinate
argument_list|(
name|node
operator|.
name|coordinate
argument_list|)
expr_stmt|;
block|}
return|return
name|ShapeBuilders
operator|.
name|newLineString
argument_list|(
name|line
argument_list|)
return|;
block|}
DECL|method|parseMultiLine
specifier|protected
specifier|static
name|MultiLineStringBuilder
name|parseMultiLine
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
name|MultiLineStringBuilder
name|multiline
init|=
name|ShapeBuilders
operator|.
name|newMultiLinestring
argument_list|()
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|multiline
operator|.
name|linestring
argument_list|(
name|parseLineString
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|multiline
return|;
block|}
DECL|method|parseLinearRing
specifier|protected
specifier|static
name|LineStringBuilder
name|parseLinearRing
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
comment|/**              * Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)              * A LinearRing is closed LineString with 4 or more positions. The first and last positions              * are equivalent (they represent equivalent points). Though a LinearRing is not explicitly              * represented as a GeoJSON geometry type, it is referred to in the Polygon geometry type definition.              */
if|if
condition|(
name|coordinates
operator|.
name|children
operator|==
literal|null
condition|)
block|{
name|String
name|error
init|=
literal|"Invalid LinearRing found."
decl_stmt|;
name|error
operator|+=
operator|(
name|coordinates
operator|.
name|coordinate
operator|==
literal|null
operator|)
condition|?
literal|" No coordinate array provided"
else|:
literal|" Found a single coordinate when expecting a coordinate array"
expr_stmt|;
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
name|error
argument_list|)
throw|;
block|}
name|int
name|numValidPts
init|=
name|coerce
condition|?
literal|3
else|:
literal|4
decl_stmt|;
if|if
condition|(
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|<
name|numValidPts
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"invalid number of points in LinearRing (found [{}] - must be>= [{}])"
argument_list|,
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
argument_list|,
name|numValidPts
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|coordinate
operator|.
name|equals
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|coordinate
argument_list|)
condition|)
block|{
if|if
condition|(
name|coerce
condition|)
block|{
name|coordinates
operator|.
name|children
operator|.
name|add
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"invalid LinearRing found (coordinates are not closed)"
argument_list|)
throw|;
block|}
block|}
return|return
name|parseLineString
argument_list|(
name|coordinates
argument_list|)
return|;
block|}
DECL|method|parsePolygon
specifier|protected
specifier|static
name|PolygonBuilder
name|parsePolygon
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
specifier|final
name|Orientation
name|orientation
parameter_list|,
specifier|final
name|boolean
name|coerce
parameter_list|)
block|{
if|if
condition|(
name|coordinates
operator|.
name|children
operator|==
literal|null
operator|||
name|coordinates
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"invalid LinearRing provided for type polygon. Linear ring must be an array of coordinates"
argument_list|)
throw|;
block|}
name|LineStringBuilder
name|shell
init|=
name|parseLinearRing
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|,
name|coerce
argument_list|)
decl_stmt|;
name|PolygonBuilder
name|polygon
init|=
operator|new
name|PolygonBuilder
argument_list|(
name|shell
argument_list|,
name|orientation
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|polygon
operator|.
name|hole
argument_list|(
name|parseLinearRing
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|coerce
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|polygon
return|;
block|}
DECL|method|parseMultiPolygon
specifier|protected
specifier|static
name|MultiPolygonBuilder
name|parseMultiPolygon
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
specifier|final
name|Orientation
name|orientation
parameter_list|,
specifier|final
name|boolean
name|coerce
parameter_list|)
block|{
name|MultiPolygonBuilder
name|polygons
init|=
name|ShapeBuilders
operator|.
name|newMultiPolygon
argument_list|(
name|orientation
argument_list|)
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|polygons
operator|.
name|polygon
argument_list|(
name|parsePolygon
argument_list|(
name|node
argument_list|,
name|orientation
argument_list|,
name|coerce
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|polygons
return|;
block|}
comment|/**          * Parse the geometries array of a GeometryCollection          *          * @param parser Parser that will be read from          * @return Geometry[] geometries of the GeometryCollection          * @throws IOException Thrown if an error occurs while reading from the XContentParser          */
DECL|method|parseGeometries
specifier|protected
specifier|static
name|GeometryCollectionBuilder
name|parseGeometries
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|GeoShapeFieldMapper
name|mapper
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|parser
operator|.
name|currentToken
argument_list|()
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"geometries must be an array of geojson objects"
argument_list|)
throw|;
block|}
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|GeometryCollectionBuilder
name|geometryCollection
init|=
name|ShapeBuilders
operator|.
name|newGeometryCollection
argument_list|()
decl_stmt|;
while|while
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
condition|)
block|{
name|ShapeBuilder
name|shapeBuilder
init|=
name|GeoShapeType
operator|.
name|parse
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|geometryCollection
operator|.
name|shape
argument_list|(
name|shapeBuilder
argument_list|)
expr_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
return|return
name|geometryCollection
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|getWriteableName
specifier|public
name|String
name|getWriteableName
parameter_list|()
block|{
return|return
name|type
argument_list|()
operator|.
name|shapeName
argument_list|()
return|;
block|}
block|}
end_class

end_unit

