begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.geo.builders
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|builders
package|;
end_package

begin_import
import|import
name|org
operator|.
name|locationtech
operator|.
name|spatial4j
operator|.
name|exception
operator|.
name|InvalidShapeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|locationtech
operator|.
name|spatial4j
operator|.
name|shape
operator|.
name|Shape
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|Coordinate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|Geometry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|GeometryFactory
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|LinearRing
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|MultiPolygon
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|Polygon
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|set
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_comment
comment|/**  * The {@link PolygonBuilder} implements the groundwork to create polygons. This contains  * Methods to wrap polygons at the dateline and building shapes from the data held by the  * builder.  */
end_comment

begin_class
DECL|class|PolygonBuilder
specifier|public
class|class
name|PolygonBuilder
extends|extends
name|ShapeBuilder
block|{
DECL|field|TYPE
specifier|public
specifier|static
specifier|final
name|GeoShapeType
name|TYPE
init|=
name|GeoShapeType
operator|.
name|POLYGON
decl_stmt|;
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|Coordinate
index|[]
index|[]
name|EMPTY
init|=
operator|new
name|Coordinate
index|[
literal|0
index|]
index|[]
decl_stmt|;
DECL|field|orientation
specifier|private
name|Orientation
name|orientation
init|=
name|Orientation
operator|.
name|RIGHT
decl_stmt|;
comment|// line string defining the shell of the polygon
DECL|field|shell
specifier|private
name|LineStringBuilder
name|shell
decl_stmt|;
comment|// List of line strings defining the holes of the polygon
DECL|field|holes
specifier|private
specifier|final
name|List
argument_list|<
name|LineStringBuilder
argument_list|>
name|holes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|PolygonBuilder
specifier|public
name|PolygonBuilder
parameter_list|(
name|LineStringBuilder
name|lineString
parameter_list|,
name|Orientation
name|orientation
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
name|this
operator|.
name|orientation
operator|=
name|orientation
expr_stmt|;
if|if
condition|(
name|coerce
condition|)
block|{
name|lineString
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|validateLinearRing
argument_list|(
name|lineString
argument_list|)
expr_stmt|;
name|this
operator|.
name|shell
operator|=
name|lineString
expr_stmt|;
block|}
DECL|method|PolygonBuilder
specifier|public
name|PolygonBuilder
parameter_list|(
name|LineStringBuilder
name|lineString
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
block|{
name|this
argument_list|(
name|lineString
argument_list|,
name|orientation
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|PolygonBuilder
specifier|public
name|PolygonBuilder
parameter_list|(
name|CoordinatesBuilder
name|coordinates
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
block|{
name|this
argument_list|(
operator|new
name|LineStringBuilder
argument_list|(
name|coordinates
argument_list|)
argument_list|,
name|orientation
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|PolygonBuilder
specifier|public
name|PolygonBuilder
parameter_list|(
name|CoordinatesBuilder
name|coordinates
parameter_list|)
block|{
name|this
argument_list|(
name|coordinates
argument_list|,
name|Orientation
operator|.
name|RIGHT
argument_list|)
expr_stmt|;
block|}
comment|/**      * Read from a stream.      */
DECL|method|PolygonBuilder
specifier|public
name|PolygonBuilder
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|shell
operator|=
operator|new
name|LineStringBuilder
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|orientation
operator|=
name|Orientation
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|int
name|holes
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|holes
condition|;
name|i
operator|++
control|)
block|{
name|hole
argument_list|(
operator|new
name|LineStringBuilder
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|shell
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|orientation
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|holes
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|LineStringBuilder
name|hole
range|:
name|holes
control|)
block|{
name|hole
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|orientation
specifier|public
name|Orientation
name|orientation
parameter_list|()
block|{
return|return
name|this
operator|.
name|orientation
return|;
block|}
comment|/**      * Add a new hole to the polygon      * @param hole linear ring defining the hole      * @return this      */
DECL|method|hole
specifier|public
name|PolygonBuilder
name|hole
parameter_list|(
name|LineStringBuilder
name|hole
parameter_list|)
block|{
return|return
name|this
operator|.
name|hole
argument_list|(
name|hole
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Add a new hole to the polygon      * @param hole linear ring defining the hole      * @param coerce if set to true, it will try to close the hole by adding starting point as end point      * @return this      */
DECL|method|hole
specifier|public
name|PolygonBuilder
name|hole
parameter_list|(
name|LineStringBuilder
name|hole
parameter_list|,
name|boolean
name|coerce
parameter_list|)
block|{
if|if
condition|(
name|coerce
condition|)
block|{
name|hole
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
name|validateLinearRing
argument_list|(
name|hole
argument_list|)
expr_stmt|;
name|holes
operator|.
name|add
argument_list|(
name|hole
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * @return the list of holes defined for this polygon      */
DECL|method|holes
specifier|public
name|List
argument_list|<
name|LineStringBuilder
argument_list|>
name|holes
parameter_list|()
block|{
return|return
name|this
operator|.
name|holes
return|;
block|}
comment|/**      * @return the list of points of the shell for this polygon      */
DECL|method|shell
specifier|public
name|LineStringBuilder
name|shell
parameter_list|()
block|{
return|return
name|this
operator|.
name|shell
return|;
block|}
comment|/**      * Close the shell of the polygon      */
DECL|method|close
specifier|public
name|PolygonBuilder
name|close
parameter_list|()
block|{
name|shell
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|validateLinearRing
specifier|private
specifier|static
name|void
name|validateLinearRing
parameter_list|(
name|LineStringBuilder
name|lineString
parameter_list|)
block|{
comment|/**          * Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)          * A LinearRing is closed LineString with 4 or more positions. The first and last positions          * are equivalent (they represent equivalent points). Though a LinearRing is not explicitly          * represented as a GeoJSON geometry type, it is referred to in the Polygon geometry type definition.          */
name|List
argument_list|<
name|Coordinate
argument_list|>
name|points
init|=
name|lineString
operator|.
name|coordinates
decl_stmt|;
if|if
condition|(
name|points
operator|.
name|size
argument_list|()
operator|<
literal|4
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid number of points in LinearRing (found ["
operator|+
name|points
operator|.
name|size
argument_list|()
operator|+
literal|"] - must be>= 4)"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|points
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|points
operator|.
name|get
argument_list|(
name|points
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"invalid LinearRing found (coordinates are not closed)"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon      */
DECL|method|validateHole
specifier|protected
name|void
name|validateHole
parameter_list|(
name|LineStringBuilder
name|shell
parameter_list|,
name|LineStringBuilder
name|hole
parameter_list|)
block|{
name|HashSet
argument_list|<
name|Coordinate
argument_list|>
name|exterior
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|shell
operator|.
name|coordinates
argument_list|)
decl_stmt|;
name|HashSet
argument_list|<
name|Coordinate
argument_list|>
name|interior
init|=
name|Sets
operator|.
name|newHashSet
argument_list|(
name|hole
operator|.
name|coordinates
argument_list|)
decl_stmt|;
name|exterior
operator|.
name|retainAll
argument_list|(
name|interior
argument_list|)
expr_stmt|;
if|if
condition|(
name|exterior
operator|.
name|size
argument_list|()
operator|>=
literal|2
condition|)
block|{
throw|throw
operator|new
name|InvalidShapeException
argument_list|(
literal|"Invalid polygon, interior cannot share more than one point with the exterior"
argument_list|)
throw|;
block|}
block|}
comment|/**      * The coordinates setup by the builder will be assembled to a polygon. The result will consist of      * a set of polygons. Each of these components holds a list of linestrings defining the polygon: the      * first set of coordinates will be used as the shell of the polygon. The others are defined to holes      * within the polygon.      * This Method also wraps the polygons at the dateline. In order to this fact the result may      * contains more polygons and less holes than defined in the builder it self.      *      * @return coordinates of the polygon      */
DECL|method|coordinates
specifier|public
name|Coordinate
index|[]
index|[]
index|[]
name|coordinates
parameter_list|()
block|{
name|int
name|numEdges
init|=
name|shell
operator|.
name|coordinates
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
comment|// Last point is repeated
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|holes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|numEdges
operator|+=
name|holes
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|coordinates
operator|.
name|size
argument_list|()
operator|-
literal|1
expr_stmt|;
name|validateHole
argument_list|(
name|shell
argument_list|,
name|this
operator|.
name|holes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Edge
index|[]
name|edges
init|=
operator|new
name|Edge
index|[
name|numEdges
index|]
decl_stmt|;
name|Edge
index|[]
name|holeComponents
init|=
operator|new
name|Edge
index|[
name|holes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
specifier|final
name|AtomicBoolean
name|translated
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|createEdges
argument_list|(
literal|0
argument_list|,
name|orientation
argument_list|,
name|shell
argument_list|,
literal|null
argument_list|,
name|edges
argument_list|,
literal|0
argument_list|,
name|translated
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|holes
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|length
init|=
name|createEdges
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|orientation
argument_list|,
name|shell
argument_list|,
name|this
operator|.
name|holes
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|,
name|edges
argument_list|,
name|offset
argument_list|,
name|translated
argument_list|)
decl_stmt|;
name|holeComponents
index|[
name|i
index|]
operator|=
name|edges
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
name|length
expr_stmt|;
block|}
name|int
name|numHoles
init|=
name|holeComponents
operator|.
name|length
decl_stmt|;
name|numHoles
operator|=
name|merge
argument_list|(
name|edges
argument_list|,
literal|0
argument_list|,
name|intersections
argument_list|(
operator|+
name|DATELINE
argument_list|,
name|edges
argument_list|)
argument_list|,
name|holeComponents
argument_list|,
name|numHoles
argument_list|)
expr_stmt|;
name|numHoles
operator|=
name|merge
argument_list|(
name|edges
argument_list|,
literal|0
argument_list|,
name|intersections
argument_list|(
operator|-
name|DATELINE
argument_list|,
name|edges
argument_list|)
argument_list|,
name|holeComponents
argument_list|,
name|numHoles
argument_list|)
expr_stmt|;
return|return
name|compose
argument_list|(
name|edges
argument_list|,
name|holeComponents
argument_list|,
name|numHoles
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|build
specifier|public
name|Shape
name|build
parameter_list|()
block|{
return|return
name|jtsGeometry
argument_list|(
name|buildGeometry
argument_list|(
name|FACTORY
argument_list|,
name|wrapdateline
argument_list|)
argument_list|)
return|;
block|}
DECL|method|coordinatesArray
specifier|protected
name|XContentBuilder
name|coordinatesArray
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|shell
operator|.
name|coordinatesToXcontent
argument_list|(
name|builder
argument_list|,
literal|true
argument_list|)
expr_stmt|;
for|for
control|(
name|LineStringBuilder
name|hole
range|:
name|holes
control|)
block|{
name|hole
operator|.
name|coordinatesToXcontent
argument_list|(
name|builder
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
name|FIELD_TYPE
argument_list|,
name|TYPE
operator|.
name|shapeName
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
name|FIELD_ORIENTATION
argument_list|,
name|orientation
operator|.
name|name
argument_list|()
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|startArray
argument_list|(
name|FIELD_COORDINATES
argument_list|)
expr_stmt|;
name|coordinatesArray
argument_list|(
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
return|return
name|builder
return|;
block|}
DECL|method|buildGeometry
specifier|public
name|Geometry
name|buildGeometry
parameter_list|(
name|GeometryFactory
name|factory
parameter_list|,
name|boolean
name|fixDateline
parameter_list|)
block|{
if|if
condition|(
name|fixDateline
condition|)
block|{
name|Coordinate
index|[]
index|[]
index|[]
name|polygons
init|=
name|coordinates
argument_list|()
decl_stmt|;
return|return
name|polygons
operator|.
name|length
operator|==
literal|1
condition|?
name|polygon
argument_list|(
name|factory
argument_list|,
name|polygons
index|[
literal|0
index|]
argument_list|)
else|:
name|multipolygon
argument_list|(
name|factory
argument_list|,
name|polygons
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|toPolygon
argument_list|(
name|factory
argument_list|)
return|;
block|}
block|}
DECL|method|toPolygon
specifier|public
name|Polygon
name|toPolygon
parameter_list|()
block|{
return|return
name|toPolygon
argument_list|(
name|FACTORY
argument_list|)
return|;
block|}
DECL|method|toPolygon
specifier|protected
name|Polygon
name|toPolygon
parameter_list|(
name|GeometryFactory
name|factory
parameter_list|)
block|{
specifier|final
name|LinearRing
name|shell
init|=
name|linearRing
argument_list|(
name|factory
argument_list|,
name|this
operator|.
name|shell
operator|.
name|coordinates
argument_list|)
decl_stmt|;
specifier|final
name|LinearRing
index|[]
name|holes
init|=
operator|new
name|LinearRing
index|[
name|this
operator|.
name|holes
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|Iterator
argument_list|<
name|LineStringBuilder
argument_list|>
name|iterator
init|=
name|this
operator|.
name|holes
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|holes
index|[
name|i
index|]
operator|=
name|linearRing
argument_list|(
name|factory
argument_list|,
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|coordinates
argument_list|)
expr_stmt|;
block|}
return|return
name|factory
operator|.
name|createPolygon
argument_list|(
name|shell
argument_list|,
name|holes
argument_list|)
return|;
block|}
DECL|method|linearRing
specifier|protected
specifier|static
name|LinearRing
name|linearRing
parameter_list|(
name|GeometryFactory
name|factory
parameter_list|,
name|List
argument_list|<
name|Coordinate
argument_list|>
name|coordinates
parameter_list|)
block|{
return|return
name|factory
operator|.
name|createLinearRing
argument_list|(
name|coordinates
operator|.
name|toArray
argument_list|(
operator|new
name|Coordinate
index|[
name|coordinates
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|type
specifier|public
name|GeoShapeType
name|type
parameter_list|()
block|{
return|return
name|TYPE
return|;
block|}
DECL|method|polygon
specifier|protected
specifier|static
name|Polygon
name|polygon
parameter_list|(
name|GeometryFactory
name|factory
parameter_list|,
name|Coordinate
index|[]
index|[]
name|polygon
parameter_list|)
block|{
name|LinearRing
name|shell
init|=
name|factory
operator|.
name|createLinearRing
argument_list|(
name|polygon
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|LinearRing
index|[]
name|holes
decl_stmt|;
if|if
condition|(
name|polygon
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|holes
operator|=
operator|new
name|LinearRing
index|[
name|polygon
operator|.
name|length
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|holes
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|holes
index|[
name|i
index|]
operator|=
name|factory
operator|.
name|createLinearRing
argument_list|(
name|polygon
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|holes
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|factory
operator|.
name|createPolygon
argument_list|(
name|shell
argument_list|,
name|holes
argument_list|)
return|;
block|}
comment|/**      * Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which      * in turn contains an array of linestrings. These line Strings are represented as an array of      * coordinates. The first linestring will be the shell of the polygon the others define holes      * within the polygon.      *      * @param factory {@link GeometryFactory} to use      * @param polygons definition of polygons      * @return a new Multipolygon      */
DECL|method|multipolygon
specifier|protected
specifier|static
name|MultiPolygon
name|multipolygon
parameter_list|(
name|GeometryFactory
name|factory
parameter_list|,
name|Coordinate
index|[]
index|[]
index|[]
name|polygons
parameter_list|)
block|{
name|Polygon
index|[]
name|polygonSet
init|=
operator|new
name|Polygon
index|[
name|polygons
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|polygonSet
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|polygonSet
index|[
name|i
index|]
operator|=
name|polygon
argument_list|(
name|factory
argument_list|,
name|polygons
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|factory
operator|.
name|createMultiPolygon
argument_list|(
name|polygonSet
argument_list|)
return|;
block|}
comment|/**      * This method sets the component id of all edges in a ring to a given id and shifts the      * coordinates of this component according to the dateline      *      * @param edge An arbitrary edge of the component      * @param id id to apply to the component      * @param edges a list of edges to which all edges of the component will be added (could be<code>null</code>)      * @return number of edges that belong to this component      */
DECL|method|component
specifier|private
specifier|static
name|int
name|component
parameter_list|(
specifier|final
name|Edge
name|edge
parameter_list|,
specifier|final
name|int
name|id
parameter_list|,
specifier|final
name|ArrayList
argument_list|<
name|Edge
argument_list|>
name|edges
parameter_list|)
block|{
comment|// find a coordinate that is not part of the dateline
name|Edge
name|any
init|=
name|edge
decl_stmt|;
while|while
condition|(
name|any
operator|.
name|coordinate
operator|.
name|x
operator|==
operator|+
name|DATELINE
operator|||
name|any
operator|.
name|coordinate
operator|.
name|x
operator|==
operator|-
name|DATELINE
condition|)
block|{
if|if
condition|(
operator|(
name|any
operator|=
name|any
operator|.
name|next
operator|)
operator|==
name|edge
condition|)
block|{
break|break;
block|}
block|}
name|double
name|shiftOffset
init|=
name|any
operator|.
name|coordinate
operator|.
name|x
operator|>
name|DATELINE
condition|?
name|DATELINE
else|:
operator|(
name|any
operator|.
name|coordinate
operator|.
name|x
operator|<
operator|-
name|DATELINE
condition|?
operator|-
name|DATELINE
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|debugEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"shift: [{}]"
argument_list|,
name|shiftOffset
argument_list|)
expr_stmt|;
block|}
comment|// run along the border of the component, collect the
comment|// edges, shift them according to the dateline and
comment|// update the component id
name|int
name|length
init|=
literal|0
decl_stmt|,
name|connectedComponents
init|=
literal|0
decl_stmt|;
comment|// if there are two connected components, splitIndex keeps track of where to split the edge array
comment|// start at 1 since the source coordinate is shared
name|int
name|splitIndex
init|=
literal|1
decl_stmt|;
name|Edge
name|current
init|=
name|edge
decl_stmt|;
name|Edge
name|prev
init|=
name|edge
decl_stmt|;
comment|// bookkeep the source and sink of each visited coordinate
name|HashMap
argument_list|<
name|Coordinate
argument_list|,
name|Tuple
argument_list|<
name|Edge
argument_list|,
name|Edge
argument_list|>
argument_list|>
name|visitedEdge
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
do|do
block|{
name|current
operator|.
name|coordinate
operator|=
name|shift
argument_list|(
name|current
operator|.
name|coordinate
argument_list|,
name|shiftOffset
argument_list|)
expr_stmt|;
name|current
operator|.
name|component
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|edges
operator|!=
literal|null
condition|)
block|{
comment|// found a closed loop - we have two connected components so we need to slice into two distinct components
if|if
condition|(
name|visitedEdge
operator|.
name|containsKey
argument_list|(
name|current
operator|.
name|coordinate
argument_list|)
condition|)
block|{
if|if
condition|(
name|connectedComponents
operator|>
literal|0
operator|&&
name|current
operator|.
name|next
operator|!=
name|edge
condition|)
block|{
throw|throw
operator|new
name|InvalidShapeException
argument_list|(
literal|"Shape contains more than one shared point"
argument_list|)
throw|;
block|}
comment|// a negative id flags the edge as visited for the edges(...) method.
comment|// since we're splitting connected components, we want the edges method to visit
comment|// the newly separated component
specifier|final
name|int
name|visitID
init|=
operator|-
name|id
decl_stmt|;
name|Edge
name|firstAppearance
init|=
name|visitedEdge
operator|.
name|get
argument_list|(
name|current
operator|.
name|coordinate
argument_list|)
operator|.
name|v2
argument_list|()
decl_stmt|;
comment|// correct the graph pointers by correcting the 'next' pointer for both the
comment|// first appearance and this appearance of the edge
name|Edge
name|temp
init|=
name|firstAppearance
operator|.
name|next
decl_stmt|;
name|firstAppearance
operator|.
name|next
operator|=
name|current
operator|.
name|next
expr_stmt|;
name|current
operator|.
name|next
operator|=
name|temp
expr_stmt|;
name|current
operator|.
name|component
operator|=
name|visitID
expr_stmt|;
comment|// backtrack until we get back to this coordinate, setting the visit id to
comment|// a non-visited value (anything positive)
do|do
block|{
name|prev
operator|.
name|component
operator|=
name|visitID
expr_stmt|;
name|prev
operator|=
name|visitedEdge
operator|.
name|get
argument_list|(
name|prev
operator|.
name|coordinate
argument_list|)
operator|.
name|v1
argument_list|()
expr_stmt|;
operator|++
name|splitIndex
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|current
operator|.
name|coordinate
operator|.
name|equals
argument_list|(
name|prev
operator|.
name|coordinate
argument_list|)
condition|)
do|;
operator|++
name|connectedComponents
expr_stmt|;
block|}
else|else
block|{
name|visitedEdge
operator|.
name|put
argument_list|(
name|current
operator|.
name|coordinate
argument_list|,
operator|new
name|Tuple
argument_list|<
name|Edge
argument_list|,
name|Edge
argument_list|>
argument_list|(
name|prev
argument_list|,
name|current
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|edges
operator|.
name|add
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|prev
operator|=
name|current
expr_stmt|;
block|}
name|length
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|connectedComponents
operator|==
literal|0
operator|&&
operator|(
name|current
operator|=
name|current
operator|.
name|next
operator|)
operator|!=
name|edge
condition|)
do|;
return|return
operator|(
name|splitIndex
operator|!=
literal|1
operator|)
condition|?
name|length
operator|-
name|splitIndex
else|:
name|length
return|;
block|}
comment|/**      * Compute all coordinates of a component      * @param component an arbitrary edge of the component      * @param coordinates Array of coordinates to write the result to      * @return the coordinates parameter      */
DECL|method|coordinates
specifier|private
specifier|static
name|Coordinate
index|[]
name|coordinates
parameter_list|(
name|Edge
name|component
parameter_list|,
name|Coordinate
index|[]
name|coordinates
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|coordinates
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|coordinates
index|[
name|i
index|]
operator|=
operator|(
name|component
operator|=
name|component
operator|.
name|next
operator|)
operator|.
name|coordinate
expr_stmt|;
block|}
return|return
name|coordinates
return|;
block|}
DECL|method|buildCoordinates
specifier|private
specifier|static
name|Coordinate
index|[]
index|[]
index|[]
name|buildCoordinates
parameter_list|(
name|List
argument_list|<
name|List
argument_list|<
name|Coordinate
index|[]
argument_list|>
argument_list|>
name|components
parameter_list|)
block|{
name|Coordinate
index|[]
index|[]
index|[]
name|result
init|=
operator|new
name|Coordinate
index|[
name|components
operator|.
name|size
argument_list|()
index|]
index|[]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|List
argument_list|<
name|Coordinate
index|[]
argument_list|>
name|component
init|=
name|components
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|result
index|[
name|i
index|]
operator|=
name|component
operator|.
name|toArray
argument_list|(
operator|new
name|Coordinate
index|[
name|component
operator|.
name|size
argument_list|()
index|]
index|[]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debugEnabled
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|result
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Component [{}]:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|result
index|[
name|i
index|]
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"\t{}"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|result
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
DECL|method|holes
specifier|private
specifier|static
name|Coordinate
index|[]
index|[]
name|holes
parameter_list|(
name|Edge
index|[]
name|holes
parameter_list|,
name|int
name|numHoles
parameter_list|)
block|{
if|if
condition|(
name|numHoles
operator|==
literal|0
condition|)
block|{
return|return
name|EMPTY
return|;
block|}
specifier|final
name|Coordinate
index|[]
index|[]
name|points
init|=
operator|new
name|Coordinate
index|[
name|numHoles
index|]
index|[]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numHoles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|length
init|=
name|component
argument_list|(
name|holes
index|[
name|i
index|]
argument_list|,
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// mark as visited by inverting the sign
name|points
index|[
name|i
index|]
operator|=
name|coordinates
argument_list|(
name|holes
index|[
name|i
index|]
argument_list|,
operator|new
name|Coordinate
index|[
name|length
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|points
return|;
block|}
DECL|method|edges
specifier|private
specifier|static
name|Edge
index|[]
name|edges
parameter_list|(
name|Edge
index|[]
name|edges
parameter_list|,
name|int
name|numHoles
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|Coordinate
index|[]
argument_list|>
argument_list|>
name|components
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|Edge
argument_list|>
name|mainEdges
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|edges
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edges
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|edges
index|[
name|i
index|]
operator|.
name|component
operator|>=
literal|0
condition|)
block|{
name|int
name|length
init|=
name|component
argument_list|(
name|edges
index|[
name|i
index|]
argument_list|,
operator|-
operator|(
name|components
operator|.
name|size
argument_list|()
operator|+
name|numHoles
operator|+
literal|1
operator|)
argument_list|,
name|mainEdges
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Coordinate
index|[]
argument_list|>
name|component
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|component
operator|.
name|add
argument_list|(
name|coordinates
argument_list|(
name|edges
index|[
name|i
index|]
argument_list|,
operator|new
name|Coordinate
index|[
name|length
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|components
operator|.
name|add
argument_list|(
name|component
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|mainEdges
operator|.
name|toArray
argument_list|(
operator|new
name|Edge
index|[
name|mainEdges
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|compose
specifier|private
specifier|static
name|Coordinate
index|[]
index|[]
index|[]
name|compose
parameter_list|(
name|Edge
index|[]
name|edges
parameter_list|,
name|Edge
index|[]
name|holes
parameter_list|,
name|int
name|numHoles
parameter_list|)
block|{
specifier|final
name|List
argument_list|<
name|List
argument_list|<
name|Coordinate
index|[]
argument_list|>
argument_list|>
name|components
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|assign
argument_list|(
name|holes
argument_list|,
name|holes
argument_list|(
name|holes
argument_list|,
name|numHoles
argument_list|)
argument_list|,
name|numHoles
argument_list|,
name|edges
argument_list|(
name|edges
argument_list|,
name|numHoles
argument_list|,
name|components
argument_list|)
argument_list|,
name|components
argument_list|)
expr_stmt|;
return|return
name|buildCoordinates
argument_list|(
name|components
argument_list|)
return|;
block|}
DECL|method|assign
specifier|private
specifier|static
name|void
name|assign
parameter_list|(
name|Edge
index|[]
name|holes
parameter_list|,
name|Coordinate
index|[]
index|[]
name|points
parameter_list|,
name|int
name|numHoles
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|,
name|List
argument_list|<
name|List
argument_list|<
name|Coordinate
index|[]
argument_list|>
argument_list|>
name|components
parameter_list|)
block|{
comment|// Assign Hole to related components
comment|// To find the new component the hole belongs to all intersections of the
comment|// polygon edges with a vertical line are calculated. This vertical line
comment|// is an arbitrary point of the hole. The polygon edge next to this point
comment|// is part of the polygon the hole belongs to.
if|if
condition|(
name|debugEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"Holes: {}"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|holes
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numHoles
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|Edge
name|current
init|=
operator|new
name|Edge
argument_list|(
name|holes
index|[
name|i
index|]
operator|.
name|coordinate
argument_list|,
name|holes
index|[
name|i
index|]
operator|.
name|next
argument_list|)
decl_stmt|;
comment|// the edge intersects with itself at its own coordinate.  We need intersect to be set this way so the binary search
comment|// will get the correct position in the edge list and therefore the correct component to add the hole
name|current
operator|.
name|intersect
operator|=
name|current
operator|.
name|coordinate
expr_stmt|;
specifier|final
name|int
name|intersections
init|=
name|intersections
argument_list|(
name|current
operator|.
name|coordinate
operator|.
name|x
argument_list|,
name|edges
argument_list|)
decl_stmt|;
comment|// if no intersection is found then the hole is not within the polygon, so
comment|// don't waste time calling a binary search
specifier|final
name|int
name|pos
decl_stmt|;
name|boolean
name|sharedVertex
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|intersections
operator|==
literal|0
operator|||
operator|(
operator|(
name|pos
operator|=
name|Arrays
operator|.
name|binarySearch
argument_list|(
name|edges
argument_list|,
literal|0
argument_list|,
name|intersections
argument_list|,
name|current
argument_list|,
name|INTERSECTION_ORDER
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|!
operator|(
name|sharedVertex
operator|=
operator|(
name|edges
index|[
name|pos
index|]
operator|.
name|intersect
operator|.
name|compareTo
argument_list|(
name|current
operator|.
name|coordinate
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|InvalidShapeException
argument_list|(
literal|"Invalid shape: Hole is not within polygon"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|index
init|=
operator|-
operator|(
operator|(
name|sharedVertex
operator|)
condition|?
literal|0
else|:
name|pos
operator|+
literal|2
operator|)
decl_stmt|;
specifier|final
name|int
name|component
init|=
operator|-
name|edges
index|[
name|index
index|]
operator|.
name|component
operator|-
name|numHoles
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|debugEnabled
argument_list|()
condition|)
block|{
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"\tposition ({}) of edge {}: {}"
argument_list|,
name|index
argument_list|,
name|current
argument_list|,
name|edges
index|[
name|index
index|]
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"\tComponent: {}"
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|LOGGER
operator|.
name|debug
argument_list|(
literal|"\tHole intersections ({}): {}"
argument_list|,
name|current
operator|.
name|coordinate
operator|.
name|x
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|edges
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|components
operator|.
name|get
argument_list|(
name|component
argument_list|)
operator|.
name|add
argument_list|(
name|points
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|merge
specifier|private
specifier|static
name|int
name|merge
parameter_list|(
name|Edge
index|[]
name|intersections
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|Edge
index|[]
name|holes
parameter_list|,
name|int
name|numHoles
parameter_list|)
block|{
comment|// Intersections appear pairwise. On the first edge the inner of
comment|// of the polygon is entered. On the second edge the outer face
comment|// is entered. Other kinds of intersections are discard by the
comment|// intersection function
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|Edge
name|e1
init|=
name|intersections
index|[
name|offset
operator|+
name|i
operator|+
literal|0
index|]
decl_stmt|;
name|Edge
name|e2
init|=
name|intersections
index|[
name|offset
operator|+
name|i
operator|+
literal|1
index|]
decl_stmt|;
comment|// If two segments are connected maybe a hole must be deleted
comment|// Since Edges of components appear pairwise we need to check
comment|// the second edge only (the first edge is either polygon or
comment|// already handled)
if|if
condition|(
name|e2
operator|.
name|component
operator|>
literal|0
condition|)
block|{
comment|//TODO: Check if we could save the set null step
name|numHoles
operator|--
expr_stmt|;
name|holes
index|[
name|e2
operator|.
name|component
operator|-
literal|1
index|]
operator|=
name|holes
index|[
name|numHoles
index|]
expr_stmt|;
name|holes
index|[
name|numHoles
index|]
operator|=
literal|null
expr_stmt|;
block|}
comment|// only connect edges if intersections are pairwise
comment|// 1. per the comment above, the edge array is sorted by y-value of the intersection
comment|// with the dateline.  Two edges have the same y intercept when they cross the
comment|// dateline thus they appear sequentially (pairwise) in the edge array. Two edges
comment|// do not have the same y intercept when we're forming a multi-poly from a poly
comment|// that wraps the dateline (but there are 2 ordered intercepts).
comment|// The connect method creates a new edge for these paired edges in the linked list.
comment|// For boundary conditions (e.g., intersect but not crossing) there is no sibling edge
comment|// to connect. Thus the first logic check enforces the pairwise rule
comment|// 2. the second logic check ensures the two candidate edges aren't already connected by an
comment|//    existing edge along the dateline - this is necessary due to a logic change in
comment|//    ShapeBuilder.intersection that computes dateline edges as valid intersect points
comment|//    in support of OGC standards
if|if
condition|(
name|e1
operator|.
name|intersect
operator|!=
name|Edge
operator|.
name|MAX_COORDINATE
operator|&&
name|e2
operator|.
name|intersect
operator|!=
name|Edge
operator|.
name|MAX_COORDINATE
operator|&&
operator|!
operator|(
name|e1
operator|.
name|next
operator|.
name|next
operator|.
name|coordinate
operator|.
name|equals3D
argument_list|(
name|e2
operator|.
name|coordinate
argument_list|)
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|e1
operator|.
name|next
operator|.
name|coordinate
operator|.
name|x
argument_list|)
operator|==
name|DATELINE
operator|&&
name|Math
operator|.
name|abs
argument_list|(
name|e2
operator|.
name|coordinate
operator|.
name|x
argument_list|)
operator|==
name|DATELINE
operator|)
condition|)
block|{
name|connect
argument_list|(
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|numHoles
return|;
block|}
DECL|method|connect
specifier|private
specifier|static
name|void
name|connect
parameter_list|(
name|Edge
name|in
parameter_list|,
name|Edge
name|out
parameter_list|)
block|{
assert|assert
name|in
operator|!=
literal|null
operator|&&
name|out
operator|!=
literal|null
assert|;
assert|assert
name|in
operator|!=
name|out
assert|;
comment|// Connecting two Edges by inserting the point at
comment|// dateline intersection and connect these by adding
comment|// two edges between this points. One per direction
if|if
condition|(
name|in
operator|.
name|intersect
operator|!=
name|in
operator|.
name|next
operator|.
name|coordinate
condition|)
block|{
comment|// NOTE: the order of the object creation is crucial here! Don't change it!
comment|// first edge has no point on dateline
name|Edge
name|e1
init|=
operator|new
name|Edge
argument_list|(
name|in
operator|.
name|intersect
argument_list|,
name|in
operator|.
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
operator|.
name|intersect
operator|!=
name|out
operator|.
name|next
operator|.
name|coordinate
condition|)
block|{
comment|// second edge has no point on dateline
name|Edge
name|e2
init|=
operator|new
name|Edge
argument_list|(
name|out
operator|.
name|intersect
argument_list|,
name|out
operator|.
name|next
argument_list|)
decl_stmt|;
name|in
operator|.
name|next
operator|=
operator|new
name|Edge
argument_list|(
name|in
operator|.
name|intersect
argument_list|,
name|e2
argument_list|,
name|in
operator|.
name|intersect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// second edge intersects with dateline
name|in
operator|.
name|next
operator|=
operator|new
name|Edge
argument_list|(
name|in
operator|.
name|intersect
argument_list|,
name|out
operator|.
name|next
argument_list|,
name|in
operator|.
name|intersect
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|next
operator|=
operator|new
name|Edge
argument_list|(
name|out
operator|.
name|intersect
argument_list|,
name|e1
argument_list|,
name|out
operator|.
name|intersect
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|in
operator|.
name|next
operator|!=
name|out
operator|&&
name|in
operator|.
name|coordinate
operator|!=
name|out
operator|.
name|intersect
condition|)
block|{
comment|// first edge intersects with dateline
name|Edge
name|e2
init|=
operator|new
name|Edge
argument_list|(
name|out
operator|.
name|intersect
argument_list|,
name|in
operator|.
name|next
argument_list|,
name|out
operator|.
name|intersect
argument_list|)
decl_stmt|;
if|if
condition|(
name|out
operator|.
name|intersect
operator|!=
name|out
operator|.
name|next
operator|.
name|coordinate
condition|)
block|{
comment|// second edge has no point on dateline
name|Edge
name|e1
init|=
operator|new
name|Edge
argument_list|(
name|out
operator|.
name|intersect
argument_list|,
name|out
operator|.
name|next
argument_list|)
decl_stmt|;
name|in
operator|.
name|next
operator|=
operator|new
name|Edge
argument_list|(
name|in
operator|.
name|intersect
argument_list|,
name|e1
argument_list|,
name|in
operator|.
name|intersect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// second edge intersects with dateline
name|in
operator|.
name|next
operator|=
operator|new
name|Edge
argument_list|(
name|in
operator|.
name|intersect
argument_list|,
name|out
operator|.
name|next
argument_list|,
name|in
operator|.
name|intersect
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|next
operator|=
name|e2
expr_stmt|;
block|}
block|}
DECL|method|createEdges
specifier|private
specifier|static
name|int
name|createEdges
parameter_list|(
name|int
name|component
parameter_list|,
name|Orientation
name|orientation
parameter_list|,
name|LineStringBuilder
name|shell
parameter_list|,
name|LineStringBuilder
name|hole
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|final
name|AtomicBoolean
name|translated
parameter_list|)
block|{
comment|// inner rings (holes) have an opposite direction than the outer rings
comment|// XOR will invert the orientation for outer ring cases (Truth Table:, T/T = F, T/F = T, F/T = T, F/F = F)
name|boolean
name|direction
init|=
operator|(
name|component
operator|==
literal|0
operator|^
name|orientation
operator|==
name|Orientation
operator|.
name|RIGHT
operator|)
decl_stmt|;
comment|// set the points array accordingly (shell or hole)
name|Coordinate
index|[]
name|points
init|=
operator|(
name|hole
operator|!=
literal|null
operator|)
condition|?
name|hole
operator|.
name|coordinates
argument_list|(
literal|false
argument_list|)
else|:
name|shell
operator|.
name|coordinates
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|ring
argument_list|(
name|component
argument_list|,
name|direction
argument_list|,
name|orientation
operator|==
name|Orientation
operator|.
name|LEFT
argument_list|,
name|shell
argument_list|,
name|points
argument_list|,
literal|0
argument_list|,
name|edges
argument_list|,
name|offset
argument_list|,
name|points
operator|.
name|length
operator|-
literal|1
argument_list|,
name|translated
argument_list|)
expr_stmt|;
return|return
name|points
operator|.
name|length
operator|-
literal|1
return|;
block|}
comment|/**      * Create a connected list of a list of coordinates      *      * @param points      *            array of point      * @param offset      *            index of the first point      * @param length      *            number of points      * @return Array of edges      */
DECL|method|ring
specifier|private
specifier|static
name|Edge
index|[]
name|ring
parameter_list|(
name|int
name|component
parameter_list|,
name|boolean
name|direction
parameter_list|,
name|boolean
name|handedness
parameter_list|,
name|LineStringBuilder
name|shell
parameter_list|,
name|Coordinate
index|[]
name|points
parameter_list|,
name|int
name|offset
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|,
name|int
name|toffset
parameter_list|,
name|int
name|length
parameter_list|,
specifier|final
name|AtomicBoolean
name|translated
parameter_list|)
block|{
comment|// calculate the direction of the points:
comment|// find the point a the top of the set and check its
comment|// neighbors orientation. So direction is equivalent
comment|// to clockwise/counterclockwise
specifier|final
name|int
name|top
init|=
name|top
argument_list|(
name|points
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
specifier|final
name|int
name|prev
init|=
operator|(
name|offset
operator|+
operator|(
operator|(
name|top
operator|+
name|length
operator|-
literal|1
operator|)
operator|%
name|length
operator|)
operator|)
decl_stmt|;
specifier|final
name|int
name|next
init|=
operator|(
name|offset
operator|+
operator|(
operator|(
name|top
operator|+
literal|1
operator|)
operator|%
name|length
operator|)
operator|)
decl_stmt|;
name|boolean
name|orientation
init|=
name|points
index|[
name|offset
operator|+
name|prev
index|]
operator|.
name|x
operator|>
name|points
index|[
name|offset
operator|+
name|next
index|]
operator|.
name|x
decl_stmt|;
comment|// OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness)
comment|// since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards
comment|// thus if orientation is computed as cw, the logic will translate points across dateline
comment|// and convert to a right handed system
comment|// compute the bounding box and calculate range
name|double
index|[]
name|range
init|=
name|range
argument_list|(
name|points
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
specifier|final
name|double
name|rng
init|=
name|range
index|[
literal|1
index|]
operator|-
name|range
index|[
literal|0
index|]
decl_stmt|;
comment|// translate the points if the following is true
comment|//   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres
comment|//       (translation would result in a collapsed poly)
comment|//   2.  the shell of the candidate hole has been translated (to preserve the coordinate system)
name|boolean
name|incorrectOrientation
init|=
name|component
operator|==
literal|0
operator|&&
name|handedness
operator|!=
name|orientation
decl_stmt|;
if|if
condition|(
operator|(
name|incorrectOrientation
operator|&&
operator|(
name|rng
operator|>
name|DATELINE
operator|&&
name|rng
operator|!=
literal|2
operator|*
name|DATELINE
operator|)
operator|)
operator|||
operator|(
name|translated
operator|.
name|get
argument_list|()
operator|&&
name|component
operator|!=
literal|0
operator|)
condition|)
block|{
name|translate
argument_list|(
name|points
argument_list|)
expr_stmt|;
comment|// flip the translation bit if the shell is being translated
if|if
condition|(
name|component
operator|==
literal|0
condition|)
block|{
name|translated
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// correct the orientation post translation (ccw for shell, cw for holes)
if|if
condition|(
name|component
operator|==
literal|0
operator|||
operator|(
name|component
operator|!=
literal|0
operator|&&
name|handedness
operator|==
name|orientation
operator|)
condition|)
block|{
name|orientation
operator|=
operator|!
name|orientation
expr_stmt|;
block|}
block|}
return|return
name|concat
argument_list|(
name|component
argument_list|,
name|direction
operator|^
name|orientation
argument_list|,
name|points
argument_list|,
name|offset
argument_list|,
name|edges
argument_list|,
name|toffset
argument_list|,
name|length
argument_list|)
return|;
block|}
DECL|method|top
specifier|private
specifier|static
specifier|final
name|int
name|top
parameter_list|(
name|Coordinate
index|[]
name|points
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|top
init|=
literal|0
decl_stmt|;
comment|// we start at 1 here since top points to 0
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|<
name|points
index|[
name|offset
operator|+
name|top
index|]
operator|.
name|y
condition|)
block|{
name|top
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|==
name|points
index|[
name|offset
operator|+
name|top
index|]
operator|.
name|y
condition|)
block|{
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
operator|<
name|points
index|[
name|offset
operator|+
name|top
index|]
operator|.
name|x
condition|)
block|{
name|top
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
return|return
name|top
return|;
block|}
DECL|method|range
specifier|private
specifier|static
specifier|final
name|double
index|[]
name|range
parameter_list|(
name|Coordinate
index|[]
name|points
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|double
name|minX
init|=
name|points
index|[
literal|0
index|]
operator|.
name|x
decl_stmt|;
name|double
name|maxX
init|=
name|points
index|[
literal|0
index|]
operator|.
name|x
decl_stmt|;
name|double
name|minY
init|=
name|points
index|[
literal|0
index|]
operator|.
name|y
decl_stmt|;
name|double
name|maxY
init|=
name|points
index|[
literal|0
index|]
operator|.
name|y
decl_stmt|;
comment|// compute the bounding coordinates (@todo: cleanup brute force)
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
operator|<
name|minX
condition|)
block|{
name|minX
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
operator|>
name|maxX
condition|)
block|{
name|maxX
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|<
name|minY
condition|)
block|{
name|minY
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|>
name|maxY
condition|)
block|{
name|maxY
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
return|return
operator|new
name|double
index|[]
block|{
name|minX
block|,
name|maxX
block|,
name|minY
block|,
name|maxY
block|}
return|;
block|}
comment|/**      * Concatenate a set of points to a polygon      *      * @param component      *            component id of the polygon      * @param direction      *            direction of the ring      * @param points      *            list of points to concatenate      * @param pointOffset      *            index of the first point      * @param edges      *            Array of edges to write the result to      * @param edgeOffset      *            index of the first edge in the result      * @param length      *            number of points to use      * @return the edges creates      */
DECL|method|concat
specifier|private
specifier|static
name|Edge
index|[]
name|concat
parameter_list|(
name|int
name|component
parameter_list|,
name|boolean
name|direction
parameter_list|,
name|Coordinate
index|[]
name|points
parameter_list|,
specifier|final
name|int
name|pointOffset
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|,
specifier|final
name|int
name|edgeOffset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
assert|assert
name|edges
operator|.
name|length
operator|>=
name|length
operator|+
name|edgeOffset
assert|;
assert|assert
name|points
operator|.
name|length
operator|>=
name|length
operator|+
name|pointOffset
assert|;
name|edges
index|[
name|edgeOffset
index|]
operator|=
operator|new
name|Edge
argument_list|(
name|points
index|[
name|pointOffset
index|]
argument_list|,
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|direction
condition|)
block|{
name|edges
index|[
name|edgeOffset
operator|+
name|i
index|]
operator|=
operator|new
name|Edge
argument_list|(
name|points
index|[
name|pointOffset
operator|+
name|i
index|]
argument_list|,
name|edges
index|[
name|edgeOffset
operator|+
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|edges
index|[
name|edgeOffset
operator|+
name|i
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|edges
index|[
name|edgeOffset
operator|+
name|i
operator|-
literal|1
index|]
operator|.
name|coordinate
operator|.
name|equals
argument_list|(
name|points
index|[
name|pointOffset
operator|+
name|i
index|]
argument_list|)
condition|)
block|{
name|edges
index|[
name|edgeOffset
operator|+
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|edges
index|[
name|edgeOffset
operator|+
name|i
index|]
operator|=
operator|new
name|Edge
argument_list|(
name|points
index|[
name|pointOffset
operator|+
name|i
index|]
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|edges
index|[
name|edgeOffset
operator|+
name|i
operator|-
literal|1
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|InvalidShapeException
argument_list|(
literal|"Provided shape has duplicate consecutive coordinates at: "
operator|+
name|points
index|[
name|pointOffset
operator|+
name|i
index|]
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|direction
condition|)
block|{
name|edges
index|[
name|edgeOffset
index|]
operator|.
name|setNext
argument_list|(
name|edges
index|[
name|edgeOffset
operator|+
name|length
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|edges
index|[
name|edgeOffset
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
else|else
block|{
name|edges
index|[
name|edgeOffset
operator|+
name|length
operator|-
literal|1
index|]
operator|.
name|setNext
argument_list|(
name|edges
index|[
name|edgeOffset
index|]
argument_list|)
expr_stmt|;
name|edges
index|[
name|edgeOffset
operator|+
name|length
operator|-
literal|1
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
return|return
name|edges
return|;
block|}
comment|/**      * Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range      */
DECL|method|translate
specifier|private
specifier|static
name|void
name|translate
parameter_list|(
name|Coordinate
index|[]
name|points
parameter_list|)
block|{
for|for
control|(
name|Coordinate
name|c
range|:
name|points
control|)
block|{
if|if
condition|(
name|c
operator|.
name|x
operator|<
literal|0
condition|)
block|{
name|c
operator|.
name|x
operator|+=
literal|2
operator|*
name|DATELINE
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|shell
argument_list|,
name|holes
argument_list|,
name|orientation
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|PolygonBuilder
name|other
init|=
operator|(
name|PolygonBuilder
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|shell
argument_list|,
name|other
operator|.
name|shell
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|holes
argument_list|,
name|other
operator|.
name|holes
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|orientation
argument_list|,
name|other
operator|.
name|orientation
argument_list|)
return|;
block|}
block|}
end_class

end_unit

