begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|FastStringReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|CollectionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ToXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|json
operator|.
name|JsonXContent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|StringTokenizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableSet
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|set
operator|.
name|Sets
operator|.
name|newHashSet
import|;
end_import

begin_class
DECL|class|Strings
specifier|public
class|class
name|Strings
block|{
DECL|field|EMPTY_ARRAY
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|EMPTY_ARRAY
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
DECL|field|FOLDER_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|FOLDER_SEPARATOR
init|=
literal|"/"
decl_stmt|;
DECL|field|WINDOWS_FOLDER_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|WINDOWS_FOLDER_SEPARATOR
init|=
literal|"\\"
decl_stmt|;
DECL|field|TOP_PATH
specifier|private
specifier|static
specifier|final
name|String
name|TOP_PATH
init|=
literal|"src/test"
decl_stmt|;
DECL|field|CURRENT_PATH
specifier|private
specifier|static
specifier|final
name|String
name|CURRENT_PATH
init|=
literal|"."
decl_stmt|;
DECL|method|spaceify
specifier|public
specifier|static
name|void
name|spaceify
parameter_list|(
name|int
name|spaces
parameter_list|,
name|String
name|from
parameter_list|,
name|StringBuilder
name|to
parameter_list|)
throws|throws
name|Exception
block|{
try|try
init|(
name|BufferedReader
name|reader
init|=
operator|new
name|BufferedReader
argument_list|(
operator|new
name|FastStringReader
argument_list|(
name|from
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|spaces
condition|;
name|i
operator|++
control|)
block|{
name|to
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|to
operator|.
name|append
argument_list|(
name|line
argument_list|)
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Splits a backslash escaped string on the separator.      *<p>      * Current backslash escaping supported:      *<br> \n \t \r \b \f are escaped the same as a Java String      *<br> Other characters following a backslash are produced verbatim (\c =&gt; c)      *      * @param s         the string to split      * @param separator the separator to split on      * @param decode    decode backslash escaping      */
DECL|method|splitSmart
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|splitSmart
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|separator
parameter_list|,
name|boolean
name|decode
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|separator
argument_list|,
name|pos
argument_list|)
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
name|pos
operator|+=
name|separator
operator|.
name|length
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|char
name|ch
init|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|decode
condition|)
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
break|break;
comment|// ERROR, or let it go?
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|lst
return|;
block|}
comment|//---------------------------------------------------------------------
comment|// General convenience methods for working with Strings
comment|//---------------------------------------------------------------------
comment|/**      * Check that the given CharSequence is neither<code>null</code> nor of length 0.      * Note: Will return<code>true</code> for a CharSequence that purely consists of whitespace.      *<pre>      * StringUtils.hasLength(null) = false      * StringUtils.hasLength("") = false      * StringUtils.hasLength(" ") = true      * StringUtils.hasLength("Hello") = true      *</pre>      *      * @param str the CharSequence to check (may be<code>null</code>)      * @return<code>true</code> if the CharSequence is not null and has length      * @see #hasText(String)      */
DECL|method|hasLength
specifier|public
specifier|static
name|boolean
name|hasLength
parameter_list|(
name|CharSequence
name|str
parameter_list|)
block|{
return|return
operator|(
name|str
operator|!=
literal|null
operator|&&
name|str
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/**      * Check that the given BytesReference is neither<code>null</code> nor of length 0      * Note: Will return<code>true</code> for a BytesReference that purely consists of whitespace.      *      * @param bytesReference the BytesReference to check (may be<code>null</code>)      * @return<code>true</code> if the BytesReference is not null and has length      * @see #hasLength(CharSequence)      */
DECL|method|hasLength
specifier|public
specifier|static
name|boolean
name|hasLength
parameter_list|(
name|BytesReference
name|bytesReference
parameter_list|)
block|{
return|return
operator|(
name|bytesReference
operator|!=
literal|null
operator|&&
name|bytesReference
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/**      * Check that the given String is neither<code>null</code> nor of length 0.      * Note: Will return<code>true</code> for a String that purely consists of whitespace.      *      * @param str the String to check (may be<code>null</code>)      * @return<code>true</code> if the String is not null and has length      * @see #hasLength(CharSequence)      */
DECL|method|hasLength
specifier|public
specifier|static
name|boolean
name|hasLength
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|hasLength
argument_list|(
operator|(
name|CharSequence
operator|)
name|str
argument_list|)
return|;
block|}
comment|/**      * Check that the given CharSequence is either<code>null</code> or of length 0.      * Note: Will return<code>false</code> for a CharSequence that purely consists of whitespace.      *<pre>      * StringUtils.isEmpty(null) = true      * StringUtils.isEmpty("") = true      * StringUtils.isEmpty(" ") = false      * StringUtils.isEmpty("Hello") = false      *</pre>      *      * @param str the CharSequence to check (may be<code>null</code>)      * @return<code>true</code> if the CharSequence is either null or has a zero length      */
DECL|method|isEmpty
specifier|public
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|CharSequence
name|str
parameter_list|)
block|{
return|return
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
return|;
block|}
comment|/**      * Check whether the given CharSequence has actual text.      * More specifically, returns<code>true</code> if the string not<code>null</code>,      * its length is greater than 0, and it contains at least one non-whitespace character.      *<pre>      * StringUtils.hasText(null) = false      * StringUtils.hasText("") = false      * StringUtils.hasText(" ") = false      * StringUtils.hasText("12345") = true      * StringUtils.hasText(" 12345 ") = true      *</pre>      *      * @param str the CharSequence to check (may be<code>null</code>)      * @return<code>true</code> if the CharSequence is not<code>null</code>,      *         its length is greater than 0, and it does not contain whitespace only      * @see java.lang.Character#isWhitespace      */
DECL|method|hasText
specifier|public
specifier|static
name|boolean
name|hasText
parameter_list|(
name|CharSequence
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|strLen
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Check whether the given String has actual text.      * More specifically, returns<code>true</code> if the string not<code>null</code>,      * its length is greater than 0, and it contains at least one non-whitespace character.      *      * @param str the String to check (may be<code>null</code>)      * @return<code>true</code> if the String is not<code>null</code>, its length is      *         greater than 0, and it does not contain whitespace only      * @see #hasText(CharSequence)      */
DECL|method|hasText
specifier|public
specifier|static
name|boolean
name|hasText
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|hasText
argument_list|(
operator|(
name|CharSequence
operator|)
name|str
argument_list|)
return|;
block|}
comment|/**      * Trim all occurrences of the supplied leading character from the given String.      *      * @param str              the String to check      * @param leadingCharacter the leading character to be trimmed      * @return the trimmed String      */
DECL|method|trimLeadingCharacter
specifier|public
specifier|static
name|String
name|trimLeadingCharacter
parameter_list|(
name|String
name|str
parameter_list|,
name|char
name|leadingCharacter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|sb
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|leadingCharacter
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Test whether the given string matches the given substring      * at the given index.      *      * @param str       the original string (or StringBuilder)      * @param index     the index in the original string to start matching against      * @param substring the substring to match at the given index      */
DECL|method|substringMatch
specifier|public
specifier|static
name|boolean
name|substringMatch
parameter_list|(
name|CharSequence
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|CharSequence
name|substring
parameter_list|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|substring
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|int
name|i
init|=
name|index
operator|+
name|j
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|str
operator|.
name|length
argument_list|()
operator|||
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
name|substring
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Count the occurrences of the substring in string s.      *      * @param str string to search in. Return 0 if this is null.      * @param sub string to search for. Return 0 if this is null.      */
DECL|method|countOccurrencesOf
specifier|public
specifier|static
name|int
name|countOccurrencesOf
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|sub
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|sub
operator|==
literal|null
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|sub
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
while|while
condition|(
operator|(
name|idx
operator|=
name|str
operator|.
name|indexOf
argument_list|(
name|sub
argument_list|,
name|pos
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|pos
operator|=
name|idx
operator|+
name|sub
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**      * Replace all occurrences of a substring within a string with      * another string.      *      * @param inString   String to examine      * @param oldPattern String to replace      * @param newPattern String to insert      * @return a String with the replacements      */
DECL|method|replace
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|inString
parameter_list|,
name|String
name|oldPattern
parameter_list|,
name|String
name|newPattern
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|inString
argument_list|)
operator|||
operator|!
name|hasLength
argument_list|(
name|oldPattern
argument_list|)
operator|||
name|newPattern
operator|==
literal|null
condition|)
block|{
return|return
name|inString
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// our position in the old string
name|int
name|index
init|=
name|inString
operator|.
name|indexOf
argument_list|(
name|oldPattern
argument_list|)
decl_stmt|;
comment|// the index of an occurrence we've found, or -1
name|int
name|patLen
init|=
name|oldPattern
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|inString
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|newPattern
argument_list|)
expr_stmt|;
name|pos
operator|=
name|index
operator|+
name|patLen
expr_stmt|;
name|index
operator|=
name|inString
operator|.
name|indexOf
argument_list|(
name|oldPattern
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|inString
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
comment|// remember to append any characters to the right of a match
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Delete all occurrences of the given substring.      *      * @param inString the original String      * @param pattern  the pattern to delete all occurrences of      * @return the resulting String      */
DECL|method|delete
specifier|public
specifier|static
name|String
name|delete
parameter_list|(
name|String
name|inString
parameter_list|,
name|String
name|pattern
parameter_list|)
block|{
return|return
name|replace
argument_list|(
name|inString
argument_list|,
name|pattern
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * Delete any character in a given String.      *      * @param inString      the original String      * @param charsToDelete a set of characters to delete.      *                      E.g. "az\n" will delete 'a's, 'z's and new lines.      * @return the resulting String      */
DECL|method|deleteAny
specifier|public
specifier|static
name|String
name|deleteAny
parameter_list|(
name|String
name|inString
parameter_list|,
name|String
name|charsToDelete
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|inString
argument_list|)
operator|||
operator|!
name|hasLength
argument_list|(
name|charsToDelete
argument_list|)
condition|)
block|{
return|return
name|inString
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inString
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|inString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|charsToDelete
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//---------------------------------------------------------------------
comment|// Convenience methods for working with formatted Strings
comment|//---------------------------------------------------------------------
comment|/**      * Quote the given String with single quotes.      *      * @param str the input String (e.g. "myString")      * @return the quoted String (e.g. "'myString'"),      *         or<code>null</code> if the input was<code>null</code>      */
DECL|method|quote
specifier|public
specifier|static
name|String
name|quote
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
operator|(
name|str
operator|!=
literal|null
condition|?
literal|"'"
operator|+
name|str
operator|+
literal|"'"
else|:
literal|null
operator|)
return|;
block|}
comment|/**      * Capitalize a<code>String</code>, changing the first letter to      * upper case as per {@link Character#toUpperCase(char)}.      * No other letters are changed.      *      * @param str the String to capitalize, may be<code>null</code>      * @return the capitalized String,<code>null</code> if null      */
DECL|method|capitalize
specifier|public
specifier|static
name|String
name|capitalize
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|changeFirstCharacterCase
argument_list|(
name|str
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|changeFirstCharacterCase
specifier|private
specifier|static
name|String
name|changeFirstCharacterCase
parameter_list|(
name|String
name|str
parameter_list|,
name|boolean
name|capitalize
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|capitalize
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|str
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|INVALID_FILENAME_CHARS
specifier|public
specifier|static
specifier|final
name|Set
argument_list|<
name|Character
argument_list|>
name|INVALID_FILENAME_CHARS
init|=
name|unmodifiableSet
argument_list|(
name|newHashSet
argument_list|(
literal|'\\'
argument_list|,
literal|'/'
argument_list|,
literal|'*'
argument_list|,
literal|'?'
argument_list|,
literal|'"'
argument_list|,
literal|'<'
argument_list|,
literal|'>'
argument_list|,
literal|'|'
argument_list|,
literal|' '
argument_list|,
literal|','
argument_list|)
argument_list|)
decl_stmt|;
DECL|method|validFileName
specifier|public
specifier|static
name|boolean
name|validFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileName
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|fileName
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|INVALID_FILENAME_CHARS
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|validFileNameExcludingAstrix
specifier|public
specifier|static
name|boolean
name|validFileNameExcludingAstrix
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileName
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|fileName
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|INVALID_FILENAME_CHARS
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Normalize the path by suppressing sequences like "path/.." and      * inner simple dots.      *<p>The result is convenient for path comparison. For other uses,      * notice that Windows separators ("\") are replaced by simple slashes.      *      * @param path the original path      * @return the normalized path      */
DECL|method|cleanPath
specifier|public
specifier|static
name|String
name|cleanPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|pathToUse
init|=
name|replace
argument_list|(
name|path
argument_list|,
name|WINDOWS_FOLDER_SEPARATOR
argument_list|,
name|FOLDER_SEPARATOR
argument_list|)
decl_stmt|;
comment|// Strip prefix from path to analyze, to not treat it as part of the
comment|// first path element. This is necessary to correctly parse paths like
comment|// "file:core/../core/io/Resource.class", where the ".." should just
comment|// strip the first "core" directory while keeping the "file:" prefix.
name|int
name|prefixIndex
init|=
name|pathToUse
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|String
name|prefix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|prefixIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|prefix
operator|=
name|pathToUse
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|prefixIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathToUse
operator|=
name|pathToUse
operator|.
name|substring
argument_list|(
name|prefixIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pathToUse
operator|.
name|startsWith
argument_list|(
name|FOLDER_SEPARATOR
argument_list|)
condition|)
block|{
name|prefix
operator|=
name|prefix
operator|+
name|FOLDER_SEPARATOR
expr_stmt|;
name|pathToUse
operator|=
name|pathToUse
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|pathArray
init|=
name|delimitedListToStringArray
argument_list|(
name|pathToUse
argument_list|,
name|FOLDER_SEPARATOR
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|pathElements
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
name|tops
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pathArray
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|String
name|element
init|=
name|pathArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|CURRENT_PATH
operator|.
name|equals
argument_list|(
name|element
argument_list|)
condition|)
block|{
comment|// Points to current directory - drop it.
block|}
elseif|else
if|if
condition|(
name|TOP_PATH
operator|.
name|equals
argument_list|(
name|element
argument_list|)
condition|)
block|{
comment|// Registering top path found.
name|tops
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tops
operator|>
literal|0
condition|)
block|{
comment|// Merging path element with element corresponding to top path.
name|tops
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|// Normal path element found.
name|pathElements
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remaining top paths need to be retained.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tops
condition|;
name|i
operator|++
control|)
block|{
name|pathElements
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|TOP_PATH
argument_list|)
expr_stmt|;
block|}
return|return
name|prefix
operator|+
name|collectionToDelimitedString
argument_list|(
name|pathElements
argument_list|,
name|FOLDER_SEPARATOR
argument_list|)
return|;
block|}
comment|/**      * Copy the given Collection into a String array.      * The Collection must contain String elements only.      *      * @param collection the Collection to copy      * @return the String array (<code>null</code> if the passed-in      *         Collection was<code>null</code>)      */
DECL|method|toStringArray
specifier|public
specifier|static
name|String
index|[]
name|toStringArray
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|collection
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|collection
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
DECL|method|splitStringByCommaToSet
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|splitStringByCommaToSet
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
return|return
name|splitStringToSet
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
return|;
block|}
DECL|method|splitStringByCommaToArray
specifier|public
specifier|static
name|String
index|[]
name|splitStringByCommaToArray
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|Strings
operator|.
name|EMPTY_ARRAY
return|;
else|else
return|return
name|s
operator|.
name|split
argument_list|(
literal|","
argument_list|)
return|;
block|}
comment|/**      * A convenience method for splitting a delimited string into      * a set and trimming leading and trailing whitespace from all      * split strings.      *      * @param s the string to split      * @param c the delimiter to split on      * @return the set of split strings      */
DECL|method|splitStringToSet
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|splitStringToSet
parameter_list|(
specifier|final
name|String
name|s
parameter_list|,
specifier|final
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|Collections
operator|.
name|emptySet
argument_list|()
return|;
block|}
specifier|final
name|char
index|[]
name|chars
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
for|for
control|(
specifier|final
name|char
name|x
range|:
name|chars
control|)
block|{
if|if
condition|(
name|x
operator|==
name|c
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|count
argument_list|)
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|chars
operator|.
name|length
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
comment|// starting index in chars of the current substring.
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// current index in chars.
name|int
name|end
init|=
literal|0
decl_stmt|;
comment|// the position of the end of the current token
for|for
control|(
init|;
name|pos
operator|<
name|len
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|chars
index|[
name|pos
index|]
operator|==
name|c
condition|)
block|{
name|int
name|size
init|=
name|end
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|// only add non empty strings
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
name|end
operator|=
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|chars
index|[
name|pos
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|start
operator|==
name|pos
condition|)
block|{
comment|// skip over preceding whitespace
name|start
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|end
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|int
name|size
init|=
name|end
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Split a String at the first occurrence of the delimiter.      * Does not include the delimiter in the result.      *      * @param toSplit   the string to split      * @param delimiter to split the string up with      * @return a two element array with index 0 being before the delimiter, and      *         index 1 being after the delimiter (neither element includes the delimiter);      *         or<code>null</code> if the delimiter wasn't found in the given input String      */
DECL|method|split
specifier|public
specifier|static
name|String
index|[]
name|split
parameter_list|(
name|String
name|toSplit
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|toSplit
argument_list|)
operator|||
operator|!
name|hasLength
argument_list|(
name|delimiter
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|offset
init|=
name|toSplit
operator|.
name|indexOf
argument_list|(
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|beforeDelimiter
init|=
name|toSplit
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|String
name|afterDelimiter
init|=
name|toSplit
operator|.
name|substring
argument_list|(
name|offset
operator|+
name|delimiter
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
index|[]
block|{
name|beforeDelimiter
block|,
name|afterDelimiter
block|}
return|;
block|}
comment|/**      * Tokenize the given String into a String array via a StringTokenizer.      * Trims tokens and omits empty tokens.      *<p>The given delimiters string is supposed to consist of any number of      * delimiter characters. Each of those characters can be used to separate      * tokens. A delimiter is always a single character; for multi-character      * delimiters, consider using<code>delimitedListToStringArray</code>      *      * @param str        the String to tokenize      * @param delimiters the delimiter characters, assembled as String      *                   (each of those characters is individually considered as delimiter).      * @return an array of the tokens      * @see java.util.StringTokenizer      * @see java.lang.String#trim()      * @see #delimitedListToStringArray      */
DECL|method|tokenizeToStringArray
specifier|public
specifier|static
name|String
index|[]
name|tokenizeToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiters
parameter_list|)
block|{
return|return
name|tokenizeToStringArray
argument_list|(
name|str
argument_list|,
name|delimiters
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Tokenize the given String into a String array via a StringTokenizer.      *<p>The given delimiters string is supposed to consist of any number of      * delimiter characters. Each of those characters can be used to separate      * tokens. A delimiter is always a single character; for multi-character      * delimiters, consider using<code>delimitedListToStringArray</code>      *      * @param str               the String to tokenize      * @param delimiters        the delimiter characters, assembled as String      *                          (each of those characters is individually considered as delimiter)      * @param trimTokens        trim the tokens via String's<code>trim</code>      * @param ignoreEmptyTokens omit empty tokens from the result array      *                          (only applies to tokens that are empty after trimming; StringTokenizer      *                          will not consider subsequent delimiters as token in the first place).      * @return an array of the tokens (<code>null</code> if the input String      *         was<code>null</code>)      * @see java.util.StringTokenizer      * @see java.lang.String#trim()      * @see #delimitedListToStringArray      */
DECL|method|tokenizeToStringArray
specifier|public
specifier|static
name|String
index|[]
name|tokenizeToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiters
parameter_list|,
name|boolean
name|trimTokens
parameter_list|,
name|boolean
name|ignoreEmptyTokens
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|str
argument_list|,
name|delimiters
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|token
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|trimTokens
condition|)
block|{
name|token
operator|=
name|token
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ignoreEmptyTokens
operator|||
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toStringArray
argument_list|(
name|tokens
argument_list|)
return|;
block|}
comment|/**      * Take a String which is a delimited list and convert it to a String array.      *<p>A single delimiter can consists of more than one character: It will still      * be considered as single delimiter string, rather than as bunch of potential      * delimiter characters - in contrast to<code>tokenizeToStringArray</code>.      *      * @param str       the input String      * @param delimiter the delimiter between elements (this is a single delimiter,      *                  rather than a bunch individual delimiter characters)      * @return an array of the tokens in the list      * @see #tokenizeToStringArray      */
DECL|method|delimitedListToStringArray
specifier|public
specifier|static
name|String
index|[]
name|delimitedListToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
return|return
name|delimitedListToStringArray
argument_list|(
name|str
argument_list|,
name|delimiter
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Take a String which is a delimited list and convert it to a String array.      *<p>A single delimiter can consists of more than one character: It will still      * be considered as single delimiter string, rather than as bunch of potential      * delimiter characters - in contrast to<code>tokenizeToStringArray</code>.      *      * @param str           the input String      * @param delimiter     the delimiter between elements (this is a single delimiter,      *                      rather than a bunch individual delimiter characters)      * @param charsToDelete a set of characters to delete. Useful for deleting unwanted      *                      line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String.      * @return an array of the tokens in the list      * @see #tokenizeToStringArray      */
DECL|method|delimitedListToStringArray
specifier|public
specifier|static
name|String
index|[]
name|delimitedListToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiter
parameter_list|,
name|String
name|charsToDelete
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|delimiter
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|String
index|[]
block|{
name|str
block|}
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|delimiter
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|deleteAny
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|charsToDelete
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|delPos
decl_stmt|;
while|while
condition|(
operator|(
name|delPos
operator|=
name|str
operator|.
name|indexOf
argument_list|(
name|delimiter
argument_list|,
name|pos
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|deleteAny
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|delPos
argument_list|)
argument_list|,
name|charsToDelete
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|delPos
operator|+
name|delimiter
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Add rest of String, but not in case of empty input.
name|result
operator|.
name|add
argument_list|(
name|deleteAny
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|charsToDelete
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toStringArray
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Convert a CSV list into an array of Strings.      *      * @param str the input String      * @return an array of Strings, or the empty array in case of empty input      */
DECL|method|commaDelimitedListToStringArray
specifier|public
specifier|static
name|String
index|[]
name|commaDelimitedListToStringArray
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|delimitedListToStringArray
argument_list|(
name|str
argument_list|,
literal|","
argument_list|)
return|;
block|}
comment|/**      * Convenience method to convert a CSV string list to a set.      * Note that this will suppress duplicates.      *      * @param str the input String      * @return a Set of String entries in the list      */
DECL|method|commaDelimitedListToSet
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|commaDelimitedListToSet
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
name|String
index|[]
name|tokens
init|=
name|commaDelimitedListToStringArray
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|tokens
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**      * Convenience method to return a Collection as a delimited (e.g. CSV)      * String. E.g. useful for<code>toString()</code> implementations.      *      * @param coll   the Collection to display      * @param delim  the delimiter to use (probably a ",")      * @param prefix the String to start each element with      * @param suffix the String to end each element with      * @return the delimited String      */
DECL|method|collectionToDelimitedString
specifier|public
specifier|static
name|String
name|collectionToDelimitedString
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|coll
parameter_list|,
name|String
name|delim
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|)
block|{
return|return
name|collectionToDelimitedString
argument_list|(
name|coll
argument_list|,
name|delim
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|,
operator|new
name|StringBuilder
argument_list|()
argument_list|)
return|;
block|}
DECL|method|collectionToDelimitedString
specifier|public
specifier|static
name|String
name|collectionToDelimitedString
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|coll
parameter_list|,
name|String
name|delim
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
block|{
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|coll
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|delim
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Convenience method to return a Collection as a delimited (e.g. CSV)      * String. E.g. useful for<code>toString()</code> implementations.      *      * @param coll  the Collection to display      * @param delim the delimiter to use (probably a ",")      * @return the delimited String      */
DECL|method|collectionToDelimitedString
specifier|public
specifier|static
name|String
name|collectionToDelimitedString
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|coll
parameter_list|,
name|String
name|delim
parameter_list|)
block|{
return|return
name|collectionToDelimitedString
argument_list|(
name|coll
argument_list|,
name|delim
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * Convenience method to return a Collection as a CSV String.      * E.g. useful for<code>toString()</code> implementations.      *      * @param coll the Collection to display      * @return the delimited String      */
DECL|method|collectionToCommaDelimitedString
specifier|public
specifier|static
name|String
name|collectionToCommaDelimitedString
parameter_list|(
name|Iterable
argument_list|<
name|?
argument_list|>
name|coll
parameter_list|)
block|{
return|return
name|collectionToDelimitedString
argument_list|(
name|coll
argument_list|,
literal|","
argument_list|)
return|;
block|}
comment|/**      * Convenience method to return a String array as a delimited (e.g. CSV)      * String. E.g. useful for<code>toString()</code> implementations.      *      * @param arr   the array to display      * @param delim the delimiter to use (probably a ",")      * @return the delimited String      */
DECL|method|arrayToDelimitedString
specifier|public
specifier|static
name|String
name|arrayToDelimitedString
parameter_list|(
name|Object
index|[]
name|arr
parameter_list|,
name|String
name|delim
parameter_list|)
block|{
return|return
name|arrayToDelimitedString
argument_list|(
name|arr
argument_list|,
name|delim
argument_list|,
operator|new
name|StringBuilder
argument_list|()
argument_list|)
return|;
block|}
DECL|method|arrayToDelimitedString
specifier|public
specifier|static
name|String
name|arrayToDelimitedString
parameter_list|(
name|Object
index|[]
name|arr
parameter_list|,
name|String
name|delim
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|arr
argument_list|)
condition|)
block|{
return|return
literal|""
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|delim
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Convenience method to return a String array as a CSV String.      * E.g. useful for<code>toString()</code> implementations.      *      * @param arr the array to display      * @return the delimited String      */
DECL|method|arrayToCommaDelimitedString
specifier|public
specifier|static
name|String
name|arrayToCommaDelimitedString
parameter_list|(
name|Object
index|[]
name|arr
parameter_list|)
block|{
return|return
name|arrayToDelimitedString
argument_list|(
name|arr
argument_list|,
literal|","
argument_list|)
return|;
block|}
comment|/**      * Format the double value with a single decimal points, trimming trailing '.0'.      */
DECL|method|format1Decimals
specifier|public
specifier|static
name|String
name|format1Decimals
parameter_list|(
name|double
name|value
parameter_list|,
name|String
name|suffix
parameter_list|)
block|{
name|String
name|p
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|int
name|ix
init|=
name|p
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|ex
init|=
name|p
operator|.
name|indexOf
argument_list|(
literal|'E'
argument_list|)
decl_stmt|;
name|char
name|fraction
init|=
name|p
operator|.
name|charAt
argument_list|(
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|fraction
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|ex
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
operator|-
literal|1
argument_list|)
operator|+
name|p
operator|.
name|substring
argument_list|(
name|ex
argument_list|)
operator|+
name|suffix
return|;
block|}
else|else
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
operator|-
literal|1
argument_list|)
operator|+
name|suffix
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ex
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
argument_list|)
operator|+
name|fraction
operator|+
name|p
operator|.
name|substring
argument_list|(
name|ex
argument_list|)
operator|+
name|suffix
return|;
block|}
else|else
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
argument_list|)
operator|+
name|fraction
operator|+
name|suffix
return|;
block|}
block|}
block|}
comment|/**      * Determine whether the given array is empty:      * i.e.<code>null</code> or of zero length.      *      * @param array the array to check      */
DECL|method|isEmpty
specifier|private
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Object
index|[]
name|array
parameter_list|)
block|{
return|return
operator|(
name|array
operator|==
literal|null
operator|||
name|array
operator|.
name|length
operator|==
literal|0
operator|)
return|;
block|}
DECL|method|Strings
specifier|private
name|Strings
parameter_list|()
block|{     }
DECL|method|toUTF8Bytes
specifier|public
specifier|static
name|byte
index|[]
name|toUTF8Bytes
parameter_list|(
name|CharSequence
name|charSequence
parameter_list|)
block|{
return|return
name|toUTF8Bytes
argument_list|(
name|charSequence
argument_list|,
operator|new
name|BytesRefBuilder
argument_list|()
argument_list|)
return|;
block|}
DECL|method|toUTF8Bytes
specifier|public
specifier|static
name|byte
index|[]
name|toUTF8Bytes
parameter_list|(
name|CharSequence
name|charSequence
parameter_list|,
name|BytesRefBuilder
name|spare
parameter_list|)
block|{
name|spare
operator|.
name|copyChars
argument_list|(
name|charSequence
argument_list|)
expr_stmt|;
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|spare
operator|.
name|bytes
argument_list|()
argument_list|,
name|spare
operator|.
name|length
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Return substring(beginIndex, endIndex) that is impervious to string length.      */
DECL|method|substring
specifier|public
specifier|static
name|String
name|substring
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|beginIndex
parameter_list|,
name|int
name|endIndex
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return
name|s
return|;
block|}
name|int
name|realEndIndex
init|=
name|s
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
name|s
operator|.
name|length
argument_list|()
operator|-
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|endIndex
operator|>
name|realEndIndex
condition|)
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
name|beginIndex
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|s
operator|.
name|substring
argument_list|(
name|beginIndex
argument_list|,
name|endIndex
argument_list|)
return|;
block|}
block|}
comment|/**      * If an array only consists of zero or one element, which is "*" or "_all" return an empty array      * which is usually used as everything      */
DECL|method|isAllOrWildcard
specifier|public
specifier|static
name|boolean
name|isAllOrWildcard
parameter_list|(
name|String
index|[]
name|data
parameter_list|)
block|{
return|return
name|CollectionUtils
operator|.
name|isEmpty
argument_list|(
name|data
argument_list|)
operator|||
name|data
operator|.
name|length
operator|==
literal|1
operator|&&
operator|(
literal|"_all"
operator|.
name|equals
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|||
literal|"*"
operator|.
name|equals
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
operator|)
return|;
block|}
comment|/**      * Return a {@link String} that is the json representation of the provided      * {@link ToXContent}.      */
DECL|method|toString
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|ToXContent
name|toXContent
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|toXContent
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Return a {@link String} that is the json representation of the provided      * {@link ToXContent}.      * @param wrapInObject set this to true if the ToXContent instance expects to be inside an object      */
DECL|method|toString
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|ToXContent
name|toXContent
parameter_list|,
name|boolean
name|wrapInObject
parameter_list|)
block|{
try|try
block|{
name|XContentBuilder
name|builder
init|=
name|JsonXContent
operator|.
name|contentBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|wrapInObject
condition|)
block|{
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
block|}
name|toXContent
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|ToXContent
operator|.
name|EMPTY_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrapInObject
condition|)
block|{
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|string
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
literal|"Error building toString out of XContent: "
operator|+
name|ExceptionsHelper
operator|.
name|stackTrace
argument_list|(
name|e
argument_list|)
return|;
block|}
block|}
comment|/**      * Truncates string to a length less than length. Backtracks to throw out      * high surrogates.      */
DECL|method|cleanTruncate
specifier|public
specifier|static
name|String
name|cleanTruncate
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
return|return
name|s
return|;
block|}
comment|/*          * Its pretty silly for you to truncate to 0 length but just in case          * someone does this shouldn't break.          */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|""
return|;
block|}
if|if
condition|(
name|length
operator|>=
name|s
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
name|s
return|;
block|}
if|if
condition|(
name|Character
operator|.
name|isHighSurrogate
argument_list|(
name|s
operator|.
name|charAt
argument_list|(
name|length
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|length
operator|--
expr_stmt|;
block|}
return|return
name|s
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
DECL|method|isNullOrEmpty
specifier|public
specifier|static
name|boolean
name|isNullOrEmpty
parameter_list|(
annotation|@
name|Nullable
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|==
literal|null
operator|||
name|s
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|coalesceToEmpty
specifier|public
specifier|static
name|String
name|coalesceToEmpty
parameter_list|(
annotation|@
name|Nullable
name|String
name|s
parameter_list|)
block|{
return|return
name|s
operator|==
literal|null
condition|?
literal|""
else|:
name|s
return|;
block|}
DECL|method|padStart
specifier|public
specifier|static
name|String
name|padStart
parameter_list|(
name|String
name|s
parameter_list|,
name|int
name|minimumLength
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"s"
argument_list|)
throw|;
block|}
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|>=
name|minimumLength
condition|)
block|{
return|return
name|s
return|;
block|}
else|else
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|minimumLength
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|s
operator|.
name|length
argument_list|()
init|;
name|i
operator|<
name|minimumLength
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

