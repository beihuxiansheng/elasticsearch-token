begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.cache
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|cache
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ReleasableLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|ToLongBiFunction
import|;
end_import

begin_comment
comment|/**  * A simple concurrent cache.  *<p>  * Cache is a simple concurrent cache that supports time-based and weight-based evictions, with notifications for all  * evictions. The design goals for this cache were simplicity and read performance. This means that we are willing to  * accept reduced write performance in exchange for easy-to-understand code. Cache statistics for hits, misses and  * evictions are exposed.  *<p>  * The design of the cache is relatively simple. The cache is segmented into 256 segments which are backed by HashMaps.  * Each segment is protected by a re-entrant read/write lock. The read/write locks permit multiple concurrent readers  * without contention, and the segments gives us write throughput without impacting readers (so readers are blocked only  * if they are reading a segment that a writer is writing to).  *<p>  * The LRU functionality is backed by a single doubly-linked list chaining the entries in order of insertion. This  * LRU list is protected by a lock that serializes all writes to it. There are opportunities for improvements  * here if write throughput is a concern.  *<ol>  *<li>LRU list mutations could be inserted into a blocking queue that a single thread is reading from  * and applying to the LRU list.</li>  *<li>Promotions could be deferred for entries that were "recently" promoted.</li>  *<li>Locks on the list could be taken per node being modified instead of globally.</li>  *</ol>  *<p>  * Evictions only occur after a mutation to the cache (meaning an entry promotion, a cache insertion, or a manual  * invalidation) or an explicit call to {@link #refresh()}.  *  * @param<K> The type of the keys  * @param<V> The type of the values  */
end_comment

begin_class
DECL|class|Cache
specifier|public
class|class
name|Cache
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|// positive if entries have an expiration
DECL|field|expireAfterAccess
specifier|private
name|long
name|expireAfterAccess
init|=
operator|-
literal|1
decl_stmt|;
comment|// true if entries can expire after access
DECL|field|entriesExpireAfterAccess
specifier|private
name|boolean
name|entriesExpireAfterAccess
decl_stmt|;
comment|// positive if entries have an expiration after write
DECL|field|expireAfterWrite
specifier|private
name|long
name|expireAfterWrite
init|=
operator|-
literal|1
decl_stmt|;
comment|// true if entries can expire after initial insertion
DECL|field|entriesExpireAfterWrite
specifier|private
name|boolean
name|entriesExpireAfterWrite
decl_stmt|;
comment|// the number of entries in the cache
DECL|field|count
specifier|private
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|// the weight of the entries in the cache
DECL|field|weight
specifier|private
name|long
name|weight
init|=
literal|0
decl_stmt|;
comment|// the maximum weight that this cache supports
DECL|field|maximumWeight
specifier|private
name|long
name|maximumWeight
init|=
operator|-
literal|1
decl_stmt|;
comment|// the weigher of entries
DECL|field|weigher
specifier|private
name|ToLongBiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
init|=
parameter_list|(
name|k
parameter_list|,
name|v
parameter_list|)
lambda|->
literal|1
decl_stmt|;
comment|// the removal callback
DECL|field|removalListener
specifier|private
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
init|=
name|notification
lambda|->
block|{     }
decl_stmt|;
comment|// use CacheBuilder to construct
DECL|method|Cache
name|Cache
parameter_list|()
block|{     }
DECL|method|setExpireAfterAccess
name|void
name|setExpireAfterAccess
parameter_list|(
name|long
name|expireAfterAccess
parameter_list|)
block|{
if|if
condition|(
name|expireAfterAccess
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expireAfterAccess<= 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|expireAfterAccess
operator|=
name|expireAfterAccess
expr_stmt|;
name|this
operator|.
name|entriesExpireAfterAccess
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|setExpireAfterWrite
name|void
name|setExpireAfterWrite
parameter_list|(
name|long
name|expireAfterWrite
parameter_list|)
block|{
if|if
condition|(
name|expireAfterWrite
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"expireAfterWrite<= 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|expireAfterWrite
operator|=
name|expireAfterWrite
expr_stmt|;
name|this
operator|.
name|entriesExpireAfterWrite
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|setMaximumWeight
name|void
name|setMaximumWeight
parameter_list|(
name|long
name|maximumWeight
parameter_list|)
block|{
if|if
condition|(
name|maximumWeight
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"maximumWeight< 0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|maximumWeight
operator|=
name|maximumWeight
expr_stmt|;
block|}
DECL|method|setWeigher
name|void
name|setWeigher
parameter_list|(
name|ToLongBiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|weigher
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|weigher
argument_list|)
expr_stmt|;
name|this
operator|.
name|weigher
operator|=
name|weigher
expr_stmt|;
block|}
DECL|method|setRemovalListener
name|void
name|setRemovalListener
parameter_list|(
name|RemovalListener
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removalListener
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|removalListener
argument_list|)
expr_stmt|;
name|this
operator|.
name|removalListener
operator|=
name|removalListener
expr_stmt|;
block|}
comment|/**      * The relative time used to track time-based evictions.      *      * @return the current relative time      */
DECL|method|now
specifier|protected
name|long
name|now
parameter_list|()
block|{
comment|// System.nanoTime takes non-negligible time, so we only use it if we need it
comment|// use System.nanoTime because we want relative time, not absolute time
return|return
name|entriesExpireAfterAccess
operator|||
name|entriesExpireAfterWrite
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0
return|;
block|}
comment|// the state of an entry in the LRU list
DECL|enum|State
enum|enum
name|State
block|{
DECL|enum constant|NEW
DECL|enum constant|EXISTING
DECL|enum constant|DELETED
name|NEW
block|,
name|EXISTING
block|,
name|DELETED
block|}
DECL|class|Entry
specifier|static
class|class
name|Entry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|value
specifier|final
name|V
name|value
decl_stmt|;
DECL|field|writeTime
name|long
name|writeTime
decl_stmt|;
DECL|field|accessTime
specifier|volatile
name|long
name|accessTime
decl_stmt|;
DECL|field|before
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|before
decl_stmt|;
DECL|field|after
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|after
decl_stmt|;
DECL|field|state
name|State
name|state
init|=
name|State
operator|.
name|NEW
decl_stmt|;
DECL|method|Entry
specifier|public
name|Entry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|long
name|writeTime
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|writeTime
operator|=
name|this
operator|.
name|accessTime
operator|=
name|writeTime
expr_stmt|;
block|}
block|}
comment|/**      * A cache segment.      *<p>      * A CacheSegment is backed by a HashMap and is protected by a read/write lock.      *      * @param<K> the type of the keys      * @param<V> the type of the values      */
DECL|class|CacheSegment
specifier|private
specifier|static
class|class
name|CacheSegment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|// read/write lock protecting mutations to the segment
DECL|field|segmentLock
name|ReadWriteLock
name|segmentLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
DECL|field|readLock
name|ReleasableLock
name|readLock
init|=
operator|new
name|ReleasableLock
argument_list|(
name|segmentLock
operator|.
name|readLock
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|writeLock
name|ReleasableLock
name|writeLock
init|=
operator|new
name|ReleasableLock
argument_list|(
name|segmentLock
operator|.
name|writeLock
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|map
name|Map
argument_list|<
name|K
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|segmentStats
name|SegmentStats
name|segmentStats
init|=
operator|new
name|SegmentStats
argument_list|()
decl_stmt|;
comment|/**          * get an entry from the segment          *          * @param key the key of the entry to get from the cache          * @param now the access time of this entry          * @return the entry if there was one, otherwise null          */
DECL|method|get
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|readLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|entry
operator|=
name|map
operator|.
name|get
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|segmentStats
operator|.
name|hit
argument_list|()
expr_stmt|;
name|entry
operator|.
name|accessTime
operator|=
name|now
expr_stmt|;
block|}
else|else
block|{
name|segmentStats
operator|.
name|miss
argument_list|()
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
comment|/**          * put an entry into the segment          *          * @param key   the key of the entry to add to the cache          * @param value the value of the entry to add to the cache          * @param now   the access time of this entry          * @return a tuple of the new entry and the existing entry, if there was one otherwise null          */
DECL|method|put
name|Tuple
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
operator|new
name|Entry
argument_list|<>
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|existing
decl_stmt|;
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|writeLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|existing
operator|=
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
name|Tuple
operator|.
name|tuple
argument_list|(
name|entry
argument_list|,
name|existing
argument_list|)
return|;
block|}
comment|/**          * remove an entry from the segment          *          * @param key the key of the entry to remove from the cache          * @return the removed entry if there was one, otherwise null          */
DECL|method|remove
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|remove
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
decl_stmt|;
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|writeLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|entry
operator|=
name|map
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|segmentStats
operator|.
name|eviction
argument_list|()
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
DECL|class|SegmentStats
specifier|private
specifier|static
class|class
name|SegmentStats
block|{
DECL|field|hits
specifier|private
specifier|final
name|LongAdder
name|hits
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|misses
specifier|private
specifier|final
name|LongAdder
name|misses
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|field|evictions
specifier|private
specifier|final
name|LongAdder
name|evictions
init|=
operator|new
name|LongAdder
argument_list|()
decl_stmt|;
DECL|method|hit
name|void
name|hit
parameter_list|()
block|{
name|hits
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
DECL|method|miss
name|void
name|miss
parameter_list|()
block|{
name|misses
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
DECL|method|eviction
name|void
name|eviction
parameter_list|()
block|{
name|evictions
operator|.
name|increment
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|field|NUMBER_OF_SEGMENTS
specifier|public
specifier|static
specifier|final
name|int
name|NUMBER_OF_SEGMENTS
init|=
literal|256
decl_stmt|;
DECL|field|segments
specifier|private
specifier|final
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
operator|new
name|CacheSegment
index|[
name|NUMBER_OF_SEGMENTS
index|]
decl_stmt|;
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|CacheSegment
argument_list|<>
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|head
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
decl_stmt|;
DECL|field|tail
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tail
decl_stmt|;
comment|// lock protecting mutations to the LRU list
DECL|field|lruLock
specifier|private
name|ReleasableLock
name|lruLock
init|=
operator|new
name|ReleasableLock
argument_list|(
operator|new
name|ReentrantLock
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.      *      * @param key the key whose associated value is to be returned      * @return the value to which the specified key is mapped, or null if this map contains no mapping for the key      */
DECL|method|get
specifier|public
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|key
argument_list|,
name|now
argument_list|()
argument_list|)
return|;
block|}
DECL|method|get
specifier|private
name|V
name|get
parameter_list|(
name|K
name|key
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|getCacheSegment
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|segment
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
operator|||
name|isExpired
argument_list|(
name|entry
argument_list|,
name|now
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|promote
argument_list|(
name|entry
argument_list|,
name|now
argument_list|)
expr_stmt|;
return|return
name|entry
operator|.
name|value
return|;
block|}
block|}
comment|/**      * If the specified key is not already associated with a value (or is mapped to null), attempts to compute its      * value using the given mapping function and enters it into this map unless null.      *      * @param key    the key whose associated value is to be returned or computed for if non-existant      * @param loader the function to compute a value given a key      * @return the current (existing or computed) value associated with the specified key, or null if the computed      * value is null      * @throws ExecutionException thrown if loader throws an exception      */
DECL|method|computeIfAbsent
specifier|public
name|V
name|computeIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|CacheLoader
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|loader
parameter_list|)
throws|throws
name|ExecutionException
block|{
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|V
name|value
init|=
name|get
argument_list|(
name|key
argument_list|,
name|now
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|getCacheSegment
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// we synchronize against the segment lock; this is to avoid a scenario where another thread is inserting
comment|// a value for the same key via put which would not be observed on this thread without a mechanism
comment|// synchronizing the two threads; it is possible that the segment lock will be too expensive here (it blocks
comment|// readers too!) so consider this as a possible place to optimize should contention be observed
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|segment
operator|.
name|writeLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|value
operator|=
name|get
argument_list|(
name|key
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|value
operator|=
name|loader
operator|.
name|load
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ExecutionException
argument_list|(
operator|new
name|NullPointerException
argument_list|(
literal|"loader returned a null value"
argument_list|)
argument_list|)
throw|;
block|}
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
comment|/**      * Associates the specified value with the specified key in this map. If the map previously contained a mapping for      * the key, the old value is replaced.      *      * @param key   key with which the specified value is to be associated      * @param value value to be associated with the specified key      */
DECL|method|put
specifier|public
name|void
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
DECL|method|put
specifier|private
name|void
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|getCacheSegment
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Tuple
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|tuple
init|=
name|segment
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|now
argument_list|)
decl_stmt|;
name|boolean
name|replaced
init|=
literal|false
decl_stmt|;
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|lruLock
operator|.
name|acquire
argument_list|()
init|)
block|{
if|if
condition|(
name|tuple
operator|.
name|v2
argument_list|()
operator|!=
literal|null
operator|&&
name|tuple
operator|.
name|v2
argument_list|()
operator|.
name|state
operator|==
name|State
operator|.
name|EXISTING
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|tuple
operator|.
name|v2
argument_list|()
argument_list|)
condition|)
block|{
name|replaced
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|promote
argument_list|(
name|tuple
operator|.
name|v1
argument_list|()
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replaced
condition|)
block|{
name|removalListener
operator|.
name|onRemoval
argument_list|(
operator|new
name|RemovalNotification
argument_list|(
name|tuple
operator|.
name|v2
argument_list|()
operator|.
name|key
argument_list|,
name|tuple
operator|.
name|v2
argument_list|()
operator|.
name|value
argument_list|,
name|RemovalNotification
operator|.
name|RemovalReason
operator|.
name|REPLACED
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Invalidate the association for the specified key. A removal notification will be issued for invalidated      * entries with {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.      *      * @param key the key whose mapping is to be invalidated from the cache      */
DECL|method|invalidate
specifier|public
name|void
name|invalidate
parameter_list|(
name|K
name|key
parameter_list|)
block|{
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|getCacheSegment
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|segment
operator|.
name|remove
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|lruLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|delete
argument_list|(
name|entry
argument_list|,
name|RemovalNotification
operator|.
name|RemovalReason
operator|.
name|INVALIDATED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Invalidate all cache entries. A removal notification will be issued for invalidated entries with      * {@link org.elasticsearch.common.cache.RemovalNotification.RemovalReason} INVALIDATED.      */
DECL|method|invalidateAll
specifier|public
name|void
name|invalidateAll
parameter_list|()
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|h
decl_stmt|;
name|boolean
index|[]
name|haveSegmentLock
init|=
operator|new
name|boolean
index|[
name|NUMBER_OF_SEGMENTS
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUMBER_OF_SEGMENTS
condition|;
name|i
operator|++
control|)
block|{
name|segments
index|[
name|i
index|]
operator|.
name|segmentLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|haveSegmentLock
index|[
name|i
index|]
operator|=
literal|true
expr_stmt|;
block|}
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|lruLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|h
operator|=
name|head
expr_stmt|;
name|Arrays
operator|.
name|stream
argument_list|(
name|segments
argument_list|)
operator|.
name|forEach
argument_list|(
name|segment
lambda|->
name|segment
operator|.
name|map
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|current
init|=
name|head
decl_stmt|;
while|while
condition|(
name|current
operator|!=
literal|null
condition|)
block|{
name|current
operator|.
name|state
operator|=
name|State
operator|.
name|DELETED
expr_stmt|;
name|current
operator|=
name|current
operator|.
name|after
expr_stmt|;
block|}
name|head
operator|=
name|tail
operator|=
literal|null
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|weight
operator|=
literal|0
expr_stmt|;
block|}
block|}
finally|finally
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NUMBER_OF_SEGMENTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|haveSegmentLock
index|[
name|i
index|]
condition|)
block|{
name|segments
index|[
name|i
index|]
operator|.
name|segmentLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|h
operator|!=
literal|null
condition|)
block|{
name|removalListener
operator|.
name|onRemoval
argument_list|(
operator|new
name|RemovalNotification
argument_list|<>
argument_list|(
name|h
operator|.
name|key
argument_list|,
name|h
operator|.
name|value
argument_list|,
name|RemovalNotification
operator|.
name|RemovalReason
operator|.
name|INVALIDATED
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|=
name|h
operator|.
name|after
expr_stmt|;
block|}
block|}
comment|/**      * Force any outstanding size-based and time-based evictions to occur      */
DECL|method|refresh
specifier|public
name|void
name|refresh
parameter_list|()
block|{
name|long
name|now
init|=
name|now
argument_list|()
decl_stmt|;
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|lruLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|evict
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * The number of entries in the cache.      *      * @return the number of entries in the cache      */
DECL|method|count
specifier|public
name|int
name|count
parameter_list|()
block|{
return|return
name|count
return|;
block|}
comment|/**      * The weight of the entries in the cache.      *      * @return the weight of the entries in the cache      */
DECL|method|weight
specifier|public
name|long
name|weight
parameter_list|()
block|{
return|return
name|weight
return|;
block|}
comment|/**      * An LRU sequencing of the keys in the cache that supports removal.      *      * @return an LRU-ordered {@link Iterable} over the keys in the cache      */
DECL|method|keys
specifier|public
name|Iterable
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
return|return
parameter_list|()
lambda|->
operator|new
name|Iterator
argument_list|<
name|K
argument_list|>
argument_list|()
block|{
specifier|private
name|CacheIterator
name|iterator
operator|=
operator|new
name|CacheIterator
argument_list|(
name|head
argument_list|)
return|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|key
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
empty_stmt|;
block|}
end_class

begin_comment
comment|/**      * An LRU sequencing of the values in the cache.      *      * @return an LRU-ordered {@link Iterable} over the values in the cache      */
end_comment

begin_function
DECL|method|values
specifier|public
name|Iterable
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
return|return
parameter_list|()
lambda|->
operator|new
name|Iterator
argument_list|<
name|V
argument_list|>
argument_list|()
block|{
specifier|private
name|CacheIterator
name|iterator
operator|=
operator|new
name|CacheIterator
argument_list|(
name|head
argument_list|)
return|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|hasNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|value
return|;
block|}
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_class
unit|}      private
DECL|class|CacheIterator
class|class
name|CacheIterator
implements|implements
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|current
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|current
decl_stmt|;
DECL|field|next
specifier|private
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|method|CacheIterator
name|CacheIterator
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|head
parameter_list|)
block|{
name|current
operator|=
literal|null
expr_stmt|;
name|next
operator|=
name|head
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|next
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
name|current
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|.
name|after
expr_stmt|;
return|return
name|current
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|current
decl_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|null
condition|)
block|{
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|getCacheSegment
argument_list|(
name|entry
operator|.
name|key
argument_list|)
decl_stmt|;
name|segment
operator|.
name|remove
argument_list|(
name|entry
operator|.
name|key
argument_list|)
expr_stmt|;
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|lruLock
operator|.
name|acquire
argument_list|()
init|)
block|{
name|current
operator|=
literal|null
expr_stmt|;
name|delete
argument_list|(
name|entry
argument_list|,
name|RemovalNotification
operator|.
name|RemovalReason
operator|.
name|INVALIDATED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_comment
comment|/**      * The cache statistics tracking hits, misses and evictions. These are taken on a best-effort basis meaning that      * they could be out-of-date mid-flight.      *      * @return the current cache statistics      */
end_comment

begin_function
DECL|method|stats
specifier|public
name|CacheStats
name|stats
parameter_list|()
block|{
name|long
name|hits
init|=
literal|0
decl_stmt|;
name|long
name|misses
init|=
literal|0
decl_stmt|;
name|long
name|evictions
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|hits
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|segmentStats
operator|.
name|hits
operator|.
name|longValue
argument_list|()
expr_stmt|;
name|misses
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|segmentStats
operator|.
name|misses
operator|.
name|longValue
argument_list|()
expr_stmt|;
name|evictions
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|segmentStats
operator|.
name|evictions
operator|.
name|longValue
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|CacheStats
argument_list|(
name|hits
argument_list|,
name|misses
argument_list|,
name|evictions
argument_list|)
return|;
block|}
end_function

begin_class
DECL|class|CacheStats
specifier|public
specifier|static
class|class
name|CacheStats
block|{
DECL|field|hits
specifier|private
name|long
name|hits
decl_stmt|;
DECL|field|misses
specifier|private
name|long
name|misses
decl_stmt|;
DECL|field|evictions
specifier|private
name|long
name|evictions
decl_stmt|;
DECL|method|CacheStats
specifier|public
name|CacheStats
parameter_list|(
name|long
name|hits
parameter_list|,
name|long
name|misses
parameter_list|,
name|long
name|evictions
parameter_list|)
block|{
name|this
operator|.
name|hits
operator|=
name|hits
expr_stmt|;
name|this
operator|.
name|misses
operator|=
name|misses
expr_stmt|;
name|this
operator|.
name|evictions
operator|=
name|evictions
expr_stmt|;
block|}
DECL|method|getHits
specifier|public
name|long
name|getHits
parameter_list|()
block|{
return|return
name|hits
return|;
block|}
DECL|method|getMisses
specifier|public
name|long
name|getMisses
parameter_list|()
block|{
return|return
name|misses
return|;
block|}
DECL|method|getEvictions
specifier|public
name|long
name|getEvictions
parameter_list|()
block|{
return|return
name|evictions
return|;
block|}
block|}
end_class

begin_function
DECL|method|promote
specifier|private
name|boolean
name|promote
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
name|boolean
name|promoted
init|=
literal|true
decl_stmt|;
try|try
init|(
name|ReleasableLock
name|ignored
init|=
name|lruLock
operator|.
name|acquire
argument_list|()
init|)
block|{
switch|switch
condition|(
name|entry
operator|.
name|state
condition|)
block|{
case|case
name|DELETED
case|:
name|promoted
operator|=
literal|false
expr_stmt|;
break|break;
case|case
name|EXISTING
case|:
name|relinkAtHead
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEW
case|:
name|linkAtHead
argument_list|(
name|entry
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|promoted
condition|)
block|{
name|evict
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|promoted
return|;
block|}
end_function

begin_function
DECL|method|evict
specifier|private
name|void
name|evict
parameter_list|(
name|long
name|now
parameter_list|)
block|{
assert|assert
name|lruLock
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
while|while
condition|(
name|tail
operator|!=
literal|null
operator|&&
name|shouldPrune
argument_list|(
name|tail
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segment
init|=
name|getCacheSegment
argument_list|(
name|tail
operator|.
name|key
argument_list|)
decl_stmt|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
init|=
name|tail
decl_stmt|;
if|if
condition|(
name|segment
operator|!=
literal|null
condition|)
block|{
name|segment
operator|.
name|remove
argument_list|(
name|tail
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
name|delete
argument_list|(
name|entry
argument_list|,
name|RemovalNotification
operator|.
name|RemovalReason
operator|.
name|EVICTED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|delete
specifier|private
name|void
name|delete
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|RemovalNotification
operator|.
name|RemovalReason
name|removalReason
parameter_list|)
block|{
assert|assert
name|lruLock
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
if|if
condition|(
name|unlink
argument_list|(
name|entry
argument_list|)
condition|)
block|{
name|removalListener
operator|.
name|onRemoval
argument_list|(
operator|new
name|RemovalNotification
argument_list|<>
argument_list|(
name|entry
operator|.
name|key
argument_list|,
name|entry
operator|.
name|value
argument_list|,
name|removalReason
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|shouldPrune
specifier|private
name|boolean
name|shouldPrune
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
return|return
name|exceedsWeight
argument_list|()
operator|||
name|isExpired
argument_list|(
name|entry
argument_list|,
name|now
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|exceedsWeight
specifier|private
name|boolean
name|exceedsWeight
parameter_list|()
block|{
return|return
name|maximumWeight
operator|!=
operator|-
literal|1
operator|&&
name|weight
operator|>
name|maximumWeight
return|;
block|}
end_function

begin_function
DECL|method|isExpired
specifier|private
name|boolean
name|isExpired
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|,
name|long
name|now
parameter_list|)
block|{
return|return
operator|(
name|entriesExpireAfterAccess
operator|&&
name|now
operator|-
name|entry
operator|.
name|accessTime
operator|>
name|expireAfterAccess
operator|)
operator|||
operator|(
name|entriesExpireAfterWrite
operator|&&
name|now
operator|-
name|entry
operator|.
name|writeTime
operator|>
name|expireAfterWrite
operator|)
return|;
block|}
end_function

begin_function
DECL|method|unlink
specifier|private
name|boolean
name|unlink
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
assert|assert
name|lruLock
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
if|if
condition|(
name|entry
operator|.
name|state
operator|==
name|State
operator|.
name|EXISTING
condition|)
block|{
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|before
init|=
name|entry
operator|.
name|before
decl_stmt|;
specifier|final
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|after
init|=
name|entry
operator|.
name|after
decl_stmt|;
if|if
condition|(
name|before
operator|==
literal|null
condition|)
block|{
comment|// removing the head
assert|assert
name|head
operator|==
name|entry
assert|;
name|head
operator|=
name|after
expr_stmt|;
if|if
condition|(
name|head
operator|!=
literal|null
condition|)
block|{
name|head
operator|.
name|before
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// removing inner element
name|before
operator|.
name|after
operator|=
name|after
expr_stmt|;
name|entry
operator|.
name|before
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|after
operator|==
literal|null
condition|)
block|{
comment|// removing tail
assert|assert
name|tail
operator|==
name|entry
assert|;
name|tail
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|tail
operator|!=
literal|null
condition|)
block|{
name|tail
operator|.
name|after
operator|=
literal|null
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// removing inner element
name|after
operator|.
name|before
operator|=
name|before
expr_stmt|;
name|entry
operator|.
name|after
operator|=
literal|null
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
name|weight
operator|-=
name|weigher
operator|.
name|applyAsLong
argument_list|(
name|entry
operator|.
name|key
argument_list|,
name|entry
operator|.
name|value
argument_list|)
expr_stmt|;
name|entry
operator|.
name|state
operator|=
name|State
operator|.
name|DELETED
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
end_function

begin_function
DECL|method|linkAtHead
specifier|private
name|void
name|linkAtHead
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
assert|assert
name|lruLock
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|h
init|=
name|head
decl_stmt|;
name|entry
operator|.
name|before
operator|=
literal|null
expr_stmt|;
name|entry
operator|.
name|after
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|null
condition|)
block|{
name|tail
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|h
operator|.
name|before
operator|=
name|entry
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
name|weight
operator|+=
name|weigher
operator|.
name|applyAsLong
argument_list|(
name|entry
operator|.
name|key
argument_list|,
name|entry
operator|.
name|value
argument_list|)
expr_stmt|;
name|entry
operator|.
name|state
operator|=
name|State
operator|.
name|EXISTING
expr_stmt|;
block|}
end_function

begin_function
DECL|method|relinkAtHead
specifier|private
name|void
name|relinkAtHead
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entry
parameter_list|)
block|{
assert|assert
name|lruLock
operator|.
name|isHeldByCurrentThread
argument_list|()
assert|;
if|if
condition|(
name|head
operator|!=
name|entry
condition|)
block|{
name|unlink
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|linkAtHead
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|getCacheSegment
specifier|private
name|CacheSegment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getCacheSegment
parameter_list|(
name|K
name|key
parameter_list|)
block|{
return|return
name|segments
index|[
name|key
operator|.
name|hashCode
argument_list|()
operator|&
literal|0xff
index|]
return|;
block|}
end_function

unit|}
end_unit

