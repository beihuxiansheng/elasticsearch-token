begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2006 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.inject.internal
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|internal
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CollectionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|CreationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Key
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|MembersInjector
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Provider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|ProvisionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Scope
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|TypeLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|spi
operator|.
name|Dependency
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|spi
operator|.
name|InjectionListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|spi
operator|.
name|InjectionPoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|spi
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|spi
operator|.
name|TypeListenerBinding
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StringWriter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|annotation
operator|.
name|Annotation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Member
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Formatter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptySet
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableList
import|;
end_import

begin_comment
comment|/**  * A collection of error messages. If this type is passed as a method parameter, the method is  * considered to have executed successfully only if new errors were not added to this collection.  *<p>  * Errors can be chained to provide additional context. To add context, call {@link #withSource}  * to create a new Errors instance that contains additional context. All messages added to the  * returned instance will contain full context.  *<p>  * To avoid messages with redundant context, {@link #withSource} should be added sparingly. A  * good rule of thumb is to assume a ethod's caller has already specified enough context to  * identify that method. When calling a method that's defined in a different context, call that  * method with an errors object that includes its context.  *  * @author jessewilson@google.com (Jesse Wilson)  */
end_comment

begin_class
DECL|class|Errors
specifier|public
specifier|final
class|class
name|Errors
block|{
comment|/**      * The root errors object. Used to access the list of error messages.      */
DECL|field|root
specifier|private
specifier|final
name|Errors
name|root
decl_stmt|;
comment|/**      * The parent errors object. Used to obtain the chain of source objects.      */
DECL|field|parent
specifier|private
specifier|final
name|Errors
name|parent
decl_stmt|;
comment|/**      * The leaf source for errors added here.      */
DECL|field|source
specifier|private
specifier|final
name|Object
name|source
decl_stmt|;
comment|/**      * null unless (root == this) and error messages exist. Never an empty list.      */
DECL|field|errors
specifier|private
name|List
argument_list|<
name|Message
argument_list|>
name|errors
decl_stmt|;
comment|// lazy, use getErrorsForAdd()
DECL|method|Errors
specifier|public
name|Errors
parameter_list|()
block|{
name|this
operator|.
name|root
operator|=
name|this
expr_stmt|;
name|this
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|SourceProvider
operator|.
name|UNKNOWN_SOURCE
expr_stmt|;
block|}
DECL|method|Errors
specifier|public
name|Errors
parameter_list|(
name|Object
name|source
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|this
expr_stmt|;
name|this
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
DECL|method|Errors
specifier|private
name|Errors
parameter_list|(
name|Errors
name|parent
parameter_list|,
name|Object
name|source
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|parent
operator|.
name|root
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
comment|/**      * Returns an instance that uses {@code source} as a reference point for newly added errors.      */
DECL|method|withSource
specifier|public
name|Errors
name|withSource
parameter_list|(
name|Object
name|source
parameter_list|)
block|{
return|return
name|source
operator|==
name|SourceProvider
operator|.
name|UNKNOWN_SOURCE
condition|?
name|this
else|:
operator|new
name|Errors
argument_list|(
name|this
argument_list|,
name|source
argument_list|)
return|;
block|}
comment|/**      * We use a fairly generic error message here. The motivation is to share the      * same message for both bind time errors:      *<pre><code>Guice.createInjector(new AbstractModule() {      *   public void configure() {      *     bind(Runnable.class);      *   }      * }</code></pre>      * ...and at provide-time errors:      *<pre><code>Guice.createInjector().getInstance(Runnable.class);</code></pre>      * Otherwise we need to know who's calling when resolving a just-in-time      * binding, which makes things unnecessarily complex.      */
DECL|method|missingImplementation
specifier|public
name|Errors
name|missingImplementation
parameter_list|(
name|Key
name|key
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"No implementation for %s was bound."
argument_list|,
name|key
argument_list|)
return|;
block|}
DECL|method|converterReturnedNull
specifier|public
name|Errors
name|converterReturnedNull
parameter_list|(
name|String
name|stringValue
parameter_list|,
name|Object
name|source
parameter_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|MatcherAndConverter
name|matchingConverter
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Received null converting '%s' (bound at %s) to %s%n"
operator|+
literal|" using %s."
argument_list|,
name|stringValue
argument_list|,
name|convert
argument_list|(
name|source
argument_list|)
argument_list|,
name|type
argument_list|,
name|matchingConverter
argument_list|)
return|;
block|}
DECL|method|conversionTypeError
specifier|public
name|Errors
name|conversionTypeError
parameter_list|(
name|String
name|stringValue
parameter_list|,
name|Object
name|source
parameter_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|MatcherAndConverter
name|matchingConverter
parameter_list|,
name|Object
name|converted
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Type mismatch converting '%s' (bound at %s) to %s%n"
operator|+
literal|" using %s.%n"
operator|+
literal|" Converter returned %s."
argument_list|,
name|stringValue
argument_list|,
name|convert
argument_list|(
name|source
argument_list|)
argument_list|,
name|type
argument_list|,
name|matchingConverter
argument_list|,
name|converted
argument_list|)
return|;
block|}
DECL|method|conversionError
specifier|public
name|Errors
name|conversionError
parameter_list|(
name|String
name|stringValue
parameter_list|,
name|Object
name|source
parameter_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|MatcherAndConverter
name|matchingConverter
parameter_list|,
name|RuntimeException
name|cause
parameter_list|)
block|{
return|return
name|errorInUserCode
argument_list|(
name|cause
argument_list|,
literal|"Error converting '%s' (bound at %s) to %s%n"
operator|+
literal|" using %s.%n"
operator|+
literal|" Reason: %s"
argument_list|,
name|stringValue
argument_list|,
name|convert
argument_list|(
name|source
argument_list|)
argument_list|,
name|type
argument_list|,
name|matchingConverter
argument_list|,
name|cause
argument_list|)
return|;
block|}
DECL|method|ambiguousTypeConversion
specifier|public
name|Errors
name|ambiguousTypeConversion
parameter_list|(
name|String
name|stringValue
parameter_list|,
name|Object
name|source
parameter_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|MatcherAndConverter
name|a
parameter_list|,
name|MatcherAndConverter
name|b
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Multiple converters can convert '%s' (bound at %s) to %s:%n"
operator|+
literal|" %s and%n"
operator|+
literal|" %s.%n"
operator|+
literal|" Please adjust your type converter configuration to avoid overlapping matches."
argument_list|,
name|stringValue
argument_list|,
name|convert
argument_list|(
name|source
argument_list|)
argument_list|,
name|type
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|bindingToProvider
specifier|public
name|Errors
name|bindingToProvider
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Binding to Provider is not allowed."
argument_list|)
return|;
block|}
DECL|method|subtypeNotProvided
specifier|public
name|Errors
name|subtypeNotProvided
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Provider
argument_list|<
name|?
argument_list|>
argument_list|>
name|providerType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"%s doesn't provide instances of %s."
argument_list|,
name|providerType
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|notASubtype
specifier|public
name|Errors
name|notASubtype
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|implementationType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"%s doesn't extend %s."
argument_list|,
name|implementationType
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|recursiveImplementationType
specifier|public
name|Errors
name|recursiveImplementationType
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"@ImplementedBy points to the same class it annotates."
argument_list|)
return|;
block|}
DECL|method|recursiveProviderType
specifier|public
name|Errors
name|recursiveProviderType
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"@ProvidedBy points to the same class it annotates."
argument_list|)
return|;
block|}
DECL|method|missingRuntimeRetention
specifier|public
name|Errors
name|missingRuntimeRetention
parameter_list|(
name|Object
name|source
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Please annotate with @Retention(RUNTIME).%n"
operator|+
literal|" Bound at %s."
argument_list|,
name|convert
argument_list|(
name|source
argument_list|)
argument_list|)
return|;
block|}
DECL|method|missingScopeAnnotation
specifier|public
name|Errors
name|missingScopeAnnotation
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Please annotate with @ScopeAnnotation."
argument_list|)
return|;
block|}
DECL|method|optionalConstructor
specifier|public
name|Errors
name|optionalConstructor
parameter_list|(
name|Constructor
name|constructor
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"%s is annotated @Inject(optional=true), "
operator|+
literal|"but constructors cannot be optional."
argument_list|,
name|constructor
argument_list|)
return|;
block|}
DECL|method|cannotBindToGuiceType
specifier|public
name|Errors
name|cannotBindToGuiceType
parameter_list|(
name|String
name|simpleName
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Binding to core guice framework type is not allowed: %s."
argument_list|,
name|simpleName
argument_list|)
return|;
block|}
DECL|method|scopeNotFound
specifier|public
name|Errors
name|scopeNotFound
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotation
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"No scope is bound to %s."
argument_list|,
name|scopeAnnotation
argument_list|)
return|;
block|}
DECL|method|scopeAnnotationOnAbstractType
specifier|public
name|Errors
name|scopeAnnotationOnAbstractType
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|scopeAnnotation
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|Object
name|source
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"%s is annotated with %s, but scope annotations are not supported "
operator|+
literal|"for abstract types.%n Bound at %s."
argument_list|,
name|type
argument_list|,
name|scopeAnnotation
argument_list|,
name|convert
argument_list|(
name|source
argument_list|)
argument_list|)
return|;
block|}
DECL|method|misplacedBindingAnnotation
specifier|public
name|Errors
name|misplacedBindingAnnotation
parameter_list|(
name|Member
name|member
parameter_list|,
name|Annotation
name|bindingAnnotation
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"%s is annotated with %s, but binding annotations should be applied "
operator|+
literal|"to its parameters instead."
argument_list|,
name|member
argument_list|,
name|bindingAnnotation
argument_list|)
return|;
block|}
DECL|field|CONSTRUCTOR_RULES
specifier|private
specifier|static
specifier|final
name|String
name|CONSTRUCTOR_RULES
init|=
literal|"Classes must have either one (and only one) constructor "
operator|+
literal|"annotated with @Inject or a zero-argument constructor that is not private."
decl_stmt|;
DECL|method|missingConstructor
specifier|public
name|Errors
name|missingConstructor
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|implementation
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Could not find a suitable constructor in %s. "
operator|+
name|CONSTRUCTOR_RULES
argument_list|,
name|implementation
argument_list|)
return|;
block|}
DECL|method|tooManyConstructors
specifier|public
name|Errors
name|tooManyConstructors
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|implementation
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"%s has more than one constructor annotated with @Inject. "
operator|+
name|CONSTRUCTOR_RULES
argument_list|,
name|implementation
argument_list|)
return|;
block|}
DECL|method|duplicateScopes
specifier|public
name|Errors
name|duplicateScopes
parameter_list|(
name|Scope
name|existing
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|annotationType
parameter_list|,
name|Scope
name|scope
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Scope %s is already bound to %s. Cannot bind %s."
argument_list|,
name|existing
argument_list|,
name|annotationType
argument_list|,
name|scope
argument_list|)
return|;
block|}
DECL|method|voidProviderMethod
specifier|public
name|Errors
name|voidProviderMethod
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Provider methods must return a value. Do not return void."
argument_list|)
return|;
block|}
DECL|method|missingConstantValues
specifier|public
name|Errors
name|missingConstantValues
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Missing constant value. Please call to(...)."
argument_list|)
return|;
block|}
DECL|method|cannotInjectInnerClass
specifier|public
name|Errors
name|cannotInjectInnerClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Injecting into inner classes is not supported.  "
operator|+
literal|"Please use a 'static' class (top-level or nested) instead of %s."
argument_list|,
name|type
argument_list|)
return|;
block|}
DECL|method|duplicateBindingAnnotations
specifier|public
name|Errors
name|duplicateBindingAnnotations
parameter_list|(
name|Member
name|member
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|a
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|b
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"%s has more than one annotation annotated with @BindingAnnotation: "
operator|+
literal|"%s and %s"
argument_list|,
name|member
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|duplicateScopeAnnotations
specifier|public
name|Errors
name|duplicateScopeAnnotations
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|a
parameter_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Annotation
argument_list|>
name|b
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"More than one scope annotation was found: %s and %s."
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
DECL|method|recursiveBinding
specifier|public
name|Errors
name|recursiveBinding
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Binding points to itself."
argument_list|)
return|;
block|}
DECL|method|bindingAlreadySet
specifier|public
name|Errors
name|bindingAlreadySet
parameter_list|(
name|Key
argument_list|<
name|?
argument_list|>
name|key
parameter_list|,
name|Object
name|source
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"A binding to %s was already configured at %s."
argument_list|,
name|key
argument_list|,
name|convert
argument_list|(
name|source
argument_list|)
argument_list|)
return|;
block|}
DECL|method|childBindingAlreadySet
specifier|public
name|Errors
name|childBindingAlreadySet
parameter_list|(
name|Key
argument_list|<
name|?
argument_list|>
name|key
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"A binding to %s already exists on a child injector."
argument_list|,
name|key
argument_list|)
return|;
block|}
DECL|method|errorInjectingMethod
specifier|public
name|Errors
name|errorInjectingMethod
parameter_list|(
name|Throwable
name|cause
parameter_list|)
block|{
return|return
name|errorInUserCode
argument_list|(
name|cause
argument_list|,
literal|"Error injecting method, %s"
argument_list|,
name|cause
argument_list|)
return|;
block|}
DECL|method|errorNotifyingTypeListener
specifier|public
name|Errors
name|errorNotifyingTypeListener
parameter_list|(
name|TypeListenerBinding
name|listener
parameter_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|Throwable
name|cause
parameter_list|)
block|{
return|return
name|errorInUserCode
argument_list|(
name|cause
argument_list|,
literal|"Error notifying TypeListener %s (bound at %s) of %s.%n"
operator|+
literal|" Reason: %s"
argument_list|,
name|listener
operator|.
name|getListener
argument_list|()
argument_list|,
name|convert
argument_list|(
name|listener
operator|.
name|getSource
argument_list|()
argument_list|)
argument_list|,
name|type
argument_list|,
name|cause
argument_list|)
return|;
block|}
DECL|method|errorInjectingConstructor
specifier|public
name|Errors
name|errorInjectingConstructor
parameter_list|(
name|Throwable
name|cause
parameter_list|)
block|{
return|return
name|errorInUserCode
argument_list|(
name|cause
argument_list|,
literal|"Error injecting constructor, %s"
argument_list|,
name|cause
argument_list|)
return|;
block|}
DECL|method|errorInProvider
specifier|public
name|Errors
name|errorInProvider
parameter_list|(
name|RuntimeException
name|runtimeException
parameter_list|)
block|{
return|return
name|errorInUserCode
argument_list|(
name|runtimeException
argument_list|,
literal|"Error in custom provider, %s"
argument_list|,
name|runtimeException
argument_list|)
return|;
block|}
DECL|method|errorInUserInjector
specifier|public
name|Errors
name|errorInUserInjector
parameter_list|(
name|MembersInjector
argument_list|<
name|?
argument_list|>
name|listener
parameter_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|RuntimeException
name|cause
parameter_list|)
block|{
return|return
name|errorInUserCode
argument_list|(
name|cause
argument_list|,
literal|"Error injecting %s using %s.%n"
operator|+
literal|" Reason: %s"
argument_list|,
name|type
argument_list|,
name|listener
argument_list|,
name|cause
argument_list|)
return|;
block|}
DECL|method|errorNotifyingInjectionListener
specifier|public
name|Errors
name|errorNotifyingInjectionListener
parameter_list|(
name|InjectionListener
argument_list|<
name|?
argument_list|>
name|listener
parameter_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
name|type
parameter_list|,
name|RuntimeException
name|cause
parameter_list|)
block|{
return|return
name|errorInUserCode
argument_list|(
name|cause
argument_list|,
literal|"Error notifying InjectionListener %s of %s.%n"
operator|+
literal|" Reason: %s"
argument_list|,
name|listener
argument_list|,
name|type
argument_list|,
name|cause
argument_list|)
return|;
block|}
DECL|method|exposedButNotBound
specifier|public
name|void
name|exposedButNotBound
parameter_list|(
name|Key
argument_list|<
name|?
argument_list|>
name|key
parameter_list|)
block|{
name|addMessage
argument_list|(
literal|"Could not expose() %s, it must be explicitly bound."
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
DECL|method|getMessagesFromThrowable
specifier|public
specifier|static
name|Collection
argument_list|<
name|Message
argument_list|>
name|getMessagesFromThrowable
parameter_list|(
name|Throwable
name|throwable
parameter_list|)
block|{
if|if
condition|(
name|throwable
operator|instanceof
name|ProvisionException
condition|)
block|{
return|return
operator|(
operator|(
name|ProvisionException
operator|)
name|throwable
operator|)
operator|.
name|getErrorMessages
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|throwable
operator|instanceof
name|ConfigurationException
condition|)
block|{
return|return
operator|(
operator|(
name|ConfigurationException
operator|)
name|throwable
operator|)
operator|.
name|getErrorMessages
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|throwable
operator|instanceof
name|CreationException
condition|)
block|{
return|return
operator|(
operator|(
name|CreationException
operator|)
name|throwable
operator|)
operator|.
name|getErrorMessages
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|emptySet
argument_list|()
return|;
block|}
block|}
DECL|method|errorInUserCode
specifier|public
name|Errors
name|errorInUserCode
parameter_list|(
name|Throwable
name|cause
parameter_list|,
name|String
name|messageFormat
parameter_list|,
name|Object
modifier|...
name|arguments
parameter_list|)
block|{
name|Collection
argument_list|<
name|Message
argument_list|>
name|messages
init|=
name|getMessagesFromThrowable
argument_list|(
name|cause
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|messages
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|merge
argument_list|(
name|messages
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|addMessage
argument_list|(
name|cause
argument_list|,
name|messageFormat
argument_list|,
name|arguments
argument_list|)
return|;
block|}
block|}
DECL|method|cannotInjectRawProvider
specifier|public
name|Errors
name|cannotInjectRawProvider
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Cannot inject a Provider that has no type parameter"
argument_list|)
return|;
block|}
DECL|method|cannotInjectRawMembersInjector
specifier|public
name|Errors
name|cannotInjectRawMembersInjector
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Cannot inject a MembersInjector that has no type parameter"
argument_list|)
return|;
block|}
DECL|method|cannotInjectTypeLiteralOf
specifier|public
name|Errors
name|cannotInjectTypeLiteralOf
parameter_list|(
name|Type
name|unsupportedType
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Cannot inject a TypeLiteral of %s"
argument_list|,
name|unsupportedType
argument_list|)
return|;
block|}
DECL|method|cannotInjectRawTypeLiteral
specifier|public
name|Errors
name|cannotInjectRawTypeLiteral
parameter_list|()
block|{
return|return
name|addMessage
argument_list|(
literal|"Cannot inject a TypeLiteral that has no type parameter"
argument_list|)
return|;
block|}
DECL|method|cannotSatisfyCircularDependency
specifier|public
name|Errors
name|cannotSatisfyCircularDependency
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|expectedType
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|"Tried proxying %s to support a circular dependency, but it is not an interface."
argument_list|,
name|expectedType
argument_list|)
return|;
block|}
DECL|method|throwCreationExceptionIfErrorsExist
specifier|public
name|void
name|throwCreationExceptionIfErrorsExist
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasErrors
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|CreationException
argument_list|(
name|getMessages
argument_list|()
argument_list|)
throw|;
block|}
DECL|method|throwConfigurationExceptionIfErrorsExist
specifier|public
name|void
name|throwConfigurationExceptionIfErrorsExist
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasErrors
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|getMessages
argument_list|()
argument_list|)
throw|;
block|}
DECL|method|throwProvisionExceptionIfErrorsExist
specifier|public
name|void
name|throwProvisionExceptionIfErrorsExist
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasErrors
argument_list|()
condition|)
block|{
return|return;
block|}
throw|throw
operator|new
name|ProvisionException
argument_list|(
name|getMessages
argument_list|()
argument_list|)
throw|;
block|}
DECL|method|merge
specifier|private
name|Message
name|merge
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|sources
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|sources
operator|.
name|addAll
argument_list|(
name|getSources
argument_list|()
argument_list|)
expr_stmt|;
name|sources
operator|.
name|addAll
argument_list|(
name|message
operator|.
name|getSources
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|Message
argument_list|(
name|sources
argument_list|,
name|message
operator|.
name|getMessage
argument_list|()
argument_list|,
name|message
operator|.
name|getCause
argument_list|()
argument_list|)
return|;
block|}
DECL|method|merge
specifier|public
name|Errors
name|merge
parameter_list|(
name|Collection
argument_list|<
name|Message
argument_list|>
name|messages
parameter_list|)
block|{
for|for
control|(
name|Message
name|message
range|:
name|messages
control|)
block|{
name|addMessage
argument_list|(
name|merge
argument_list|(
name|message
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|merge
specifier|public
name|Errors
name|merge
parameter_list|(
name|Errors
name|moreErrors
parameter_list|)
block|{
if|if
condition|(
name|moreErrors
operator|.
name|root
operator|==
name|root
operator|||
name|moreErrors
operator|.
name|root
operator|.
name|errors
operator|==
literal|null
condition|)
block|{
return|return
name|this
return|;
block|}
name|merge
argument_list|(
name|moreErrors
operator|.
name|root
operator|.
name|errors
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|getSources
specifier|public
name|List
argument_list|<
name|Object
argument_list|>
name|getSources
parameter_list|()
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|sources
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Errors
name|e
init|=
name|this
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|parent
control|)
block|{
if|if
condition|(
name|e
operator|.
name|source
operator|!=
name|SourceProvider
operator|.
name|UNKNOWN_SOURCE
condition|)
block|{
name|sources
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|e
operator|.
name|source
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sources
return|;
block|}
DECL|method|throwIfNewErrors
specifier|public
name|void
name|throwIfNewErrors
parameter_list|(
name|int
name|expectedSize
parameter_list|)
throws|throws
name|ErrorsException
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
name|expectedSize
condition|)
block|{
return|return;
block|}
throw|throw
name|toException
argument_list|()
throw|;
block|}
DECL|method|toException
specifier|public
name|ErrorsException
name|toException
parameter_list|()
block|{
return|return
operator|new
name|ErrorsException
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|hasErrors
specifier|public
name|boolean
name|hasErrors
parameter_list|()
block|{
return|return
name|root
operator|.
name|errors
operator|!=
literal|null
return|;
block|}
DECL|method|addMessage
specifier|public
name|Errors
name|addMessage
parameter_list|(
name|String
name|messageFormat
parameter_list|,
name|Object
modifier|...
name|arguments
parameter_list|)
block|{
return|return
name|addMessage
argument_list|(
literal|null
argument_list|,
name|messageFormat
argument_list|,
name|arguments
argument_list|)
return|;
block|}
DECL|method|addMessage
specifier|private
name|Errors
name|addMessage
parameter_list|(
name|Throwable
name|cause
parameter_list|,
name|String
name|messageFormat
parameter_list|,
name|Object
modifier|...
name|arguments
parameter_list|)
block|{
name|String
name|message
init|=
name|format
argument_list|(
name|messageFormat
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
name|addMessage
argument_list|(
operator|new
name|Message
argument_list|(
name|getSources
argument_list|()
argument_list|,
name|message
argument_list|,
name|cause
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|addMessage
specifier|public
name|Errors
name|addMessage
parameter_list|(
name|Message
name|message
parameter_list|)
block|{
if|if
condition|(
name|root
operator|.
name|errors
operator|==
literal|null
condition|)
block|{
name|root
operator|.
name|errors
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|root
operator|.
name|errors
operator|.
name|add
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|format
specifier|public
specifier|static
name|String
name|format
parameter_list|(
name|String
name|messageFormat
parameter_list|,
name|Object
modifier|...
name|arguments
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|arguments
index|[
name|i
index|]
operator|=
name|Errors
operator|.
name|convert
argument_list|(
name|arguments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
name|messageFormat
argument_list|,
name|arguments
argument_list|)
return|;
block|}
DECL|method|getMessages
specifier|public
name|List
argument_list|<
name|Message
argument_list|>
name|getMessages
parameter_list|()
block|{
if|if
condition|(
name|root
operator|.
name|errors
operator|==
literal|null
condition|)
block|{
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
name|List
argument_list|<
name|Message
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|root
operator|.
name|errors
argument_list|)
decl_stmt|;
name|CollectionUtil
operator|.
name|timSort
argument_list|(
name|result
argument_list|,
operator|new
name|Comparator
argument_list|<
name|Message
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|Message
name|a
parameter_list|,
name|Message
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|getSource
argument_list|()
operator|.
name|compareTo
argument_list|(
name|b
operator|.
name|getSource
argument_list|()
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|unmodifiableList
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Returns the formatted message for an exception with the specified messages.      */
DECL|method|format
specifier|public
specifier|static
name|String
name|format
parameter_list|(
name|String
name|heading
parameter_list|,
name|Collection
argument_list|<
name|Message
argument_list|>
name|errorMessages
parameter_list|)
block|{
try|try
init|(
name|Formatter
name|fmt
init|=
operator|new
name|Formatter
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
init|)
block|{
name|fmt
operator|.
name|format
argument_list|(
name|heading
argument_list|)
operator|.
name|format
argument_list|(
literal|":%n%n"
argument_list|)
expr_stmt|;
name|int
name|index
init|=
literal|1
decl_stmt|;
name|boolean
name|displayCauses
init|=
name|getOnlyCause
argument_list|(
name|errorMessages
argument_list|)
operator|==
literal|null
decl_stmt|;
for|for
control|(
name|Message
name|errorMessage
range|:
name|errorMessages
control|)
block|{
name|fmt
operator|.
name|format
argument_list|(
literal|"%s) %s%n"
argument_list|,
name|index
operator|++
argument_list|,
name|errorMessage
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|dependencies
init|=
name|errorMessage
operator|.
name|getSources
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|dependencies
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Object
name|source
init|=
name|dependencies
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|formatSource
argument_list|(
name|fmt
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|Throwable
name|cause
init|=
name|errorMessage
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|displayCauses
operator|&&
name|cause
operator|!=
literal|null
condition|)
block|{
name|StringWriter
name|writer
init|=
operator|new
name|StringWriter
argument_list|()
decl_stmt|;
name|cause
operator|.
name|printStackTrace
argument_list|(
operator|new
name|PrintWriter
argument_list|(
name|writer
argument_list|)
argument_list|)
expr_stmt|;
name|fmt
operator|.
name|format
argument_list|(
literal|"Caused by: %s"
argument_list|,
name|writer
operator|.
name|getBuffer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|.
name|format
argument_list|(
literal|"%n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errorMessages
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|fmt
operator|.
name|format
argument_list|(
literal|"1 error"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fmt
operator|.
name|format
argument_list|(
literal|"%s errors"
argument_list|,
name|errorMessages
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|fmt
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns {@code value} if it is non-null allowed to be null. Otherwise a message is added and      * an {@code ErrorsException} is thrown.      */
DECL|method|checkForNull
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|checkForNull
parameter_list|(
name|T
name|value
parameter_list|,
name|Object
name|source
parameter_list|,
name|Dependency
argument_list|<
name|?
argument_list|>
name|dependency
parameter_list|)
throws|throws
name|ErrorsException
block|{
if|if
condition|(
name|value
operator|!=
literal|null
operator|||
name|dependency
operator|.
name|isNullable
argument_list|()
condition|)
block|{
return|return
name|value
return|;
block|}
name|int
name|parameterIndex
init|=
name|dependency
operator|.
name|getParameterIndex
argument_list|()
decl_stmt|;
name|String
name|parameterName
init|=
operator|(
name|parameterIndex
operator|!=
operator|-
literal|1
operator|)
condition|?
literal|"parameter "
operator|+
name|parameterIndex
operator|+
literal|" of "
else|:
literal|""
decl_stmt|;
name|addMessage
argument_list|(
literal|"null returned by binding at %s%n but %s%s is not @Nullable"
argument_list|,
name|source
argument_list|,
name|parameterName
argument_list|,
name|dependency
operator|.
name|getInjectionPoint
argument_list|()
operator|.
name|getMember
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|toException
argument_list|()
throw|;
block|}
comment|/**      * Returns the cause throwable if there is exactly one cause in {@code messages}. If there are      * zero or multiple messages with causes, null is returned.      */
DECL|method|getOnlyCause
specifier|public
specifier|static
name|Throwable
name|getOnlyCause
parameter_list|(
name|Collection
argument_list|<
name|Message
argument_list|>
name|messages
parameter_list|)
block|{
name|Throwable
name|onlyCause
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Message
name|message
range|:
name|messages
control|)
block|{
name|Throwable
name|messageCause
init|=
name|message
operator|.
name|getCause
argument_list|()
decl_stmt|;
if|if
condition|(
name|messageCause
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|onlyCause
operator|!=
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|onlyCause
operator|=
name|messageCause
expr_stmt|;
block|}
return|return
name|onlyCause
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|root
operator|.
name|errors
operator|==
literal|null
condition|?
literal|0
else|:
name|root
operator|.
name|errors
operator|.
name|size
argument_list|()
return|;
block|}
DECL|class|Converter
specifier|private
specifier|abstract
specifier|static
class|class
name|Converter
parameter_list|<
name|T
parameter_list|>
block|{
DECL|field|type
specifier|final
name|Class
argument_list|<
name|T
argument_list|>
name|type
decl_stmt|;
DECL|method|Converter
name|Converter
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
DECL|method|appliesTo
name|boolean
name|appliesTo
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|type
operator|.
name|isAssignableFrom
argument_list|(
name|o
operator|.
name|getClass
argument_list|()
argument_list|)
return|;
block|}
DECL|method|convert
name|String
name|convert
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|toString
argument_list|(
name|type
operator|.
name|cast
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
DECL|method|toString
specifier|abstract
name|String
name|toString
parameter_list|(
name|T
name|t
parameter_list|)
function_decl|;
block|}
DECL|field|converters
specifier|private
specifier|static
specifier|final
name|Collection
argument_list|<
name|Converter
argument_list|<
name|?
argument_list|>
argument_list|>
name|converters
init|=
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|Converter
argument_list|<
name|Class
argument_list|>
argument_list|(
name|Class
operator|.
name|class
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|(
name|Class
name|c
parameter_list|)
block|{
return|return
name|c
operator|.
name|getName
argument_list|()
return|;
block|}
block|}
argument_list|,
operator|new
name|Converter
argument_list|<
name|Member
argument_list|>
argument_list|(
name|Member
operator|.
name|class
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|(
name|Member
name|member
parameter_list|)
block|{
return|return
name|MoreTypes
operator|.
name|toString
argument_list|(
name|member
argument_list|)
return|;
block|}
block|}
argument_list|,
operator|new
name|Converter
argument_list|<
name|Key
argument_list|>
argument_list|(
name|Key
operator|.
name|class
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|(
name|Key
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|getAnnotationType
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|key
operator|.
name|getTypeLiteral
argument_list|()
operator|+
literal|" annotated with "
operator|+
operator|(
name|key
operator|.
name|getAnnotation
argument_list|()
operator|!=
literal|null
condition|?
name|key
operator|.
name|getAnnotation
argument_list|()
else|:
name|key
operator|.
name|getAnnotationType
argument_list|()
operator|)
return|;
block|}
else|else
block|{
return|return
name|key
operator|.
name|getTypeLiteral
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
argument_list|)
decl_stmt|;
DECL|method|convert
specifier|public
specifier|static
name|Object
name|convert
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
for|for
control|(
name|Converter
argument_list|<
name|?
argument_list|>
name|converter
range|:
name|converters
control|)
block|{
if|if
condition|(
name|converter
operator|.
name|appliesTo
argument_list|(
name|o
argument_list|)
condition|)
block|{
return|return
name|converter
operator|.
name|convert
argument_list|(
name|o
argument_list|)
return|;
block|}
block|}
return|return
name|o
return|;
block|}
DECL|method|formatSource
specifier|public
specifier|static
name|void
name|formatSource
parameter_list|(
name|Formatter
name|formatter
parameter_list|,
name|Object
name|source
parameter_list|)
block|{
if|if
condition|(
name|source
operator|instanceof
name|Dependency
condition|)
block|{
name|Dependency
argument_list|<
name|?
argument_list|>
name|dependency
init|=
operator|(
name|Dependency
argument_list|<
name|?
argument_list|>
operator|)
name|source
decl_stmt|;
name|InjectionPoint
name|injectionPoint
init|=
name|dependency
operator|.
name|getInjectionPoint
argument_list|()
decl_stmt|;
if|if
condition|(
name|injectionPoint
operator|!=
literal|null
condition|)
block|{
name|formatInjectionPoint
argument_list|(
name|formatter
argument_list|,
name|dependency
argument_list|,
name|injectionPoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|formatSource
argument_list|(
name|formatter
argument_list|,
name|dependency
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|source
operator|instanceof
name|InjectionPoint
condition|)
block|{
name|formatInjectionPoint
argument_list|(
name|formatter
argument_list|,
literal|null
argument_list|,
operator|(
name|InjectionPoint
operator|)
name|source
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
operator|instanceof
name|Class
condition|)
block|{
name|formatter
operator|.
name|format
argument_list|(
literal|"  at %s%n"
argument_list|,
name|StackTraceElements
operator|.
name|forType
argument_list|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
operator|instanceof
name|Member
condition|)
block|{
name|formatter
operator|.
name|format
argument_list|(
literal|"  at %s%n"
argument_list|,
name|StackTraceElements
operator|.
name|forMember
argument_list|(
operator|(
name|Member
operator|)
name|source
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
operator|instanceof
name|TypeLiteral
condition|)
block|{
name|formatter
operator|.
name|format
argument_list|(
literal|"  while locating %s%n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|source
operator|instanceof
name|Key
condition|)
block|{
name|Key
argument_list|<
name|?
argument_list|>
name|key
init|=
operator|(
name|Key
argument_list|<
name|?
argument_list|>
operator|)
name|source
decl_stmt|;
name|formatter
operator|.
name|format
argument_list|(
literal|"  while locating %s%n"
argument_list|,
name|convert
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|formatter
operator|.
name|format
argument_list|(
literal|"  at %s%n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|formatInjectionPoint
specifier|public
specifier|static
name|void
name|formatInjectionPoint
parameter_list|(
name|Formatter
name|formatter
parameter_list|,
name|Dependency
argument_list|<
name|?
argument_list|>
name|dependency
parameter_list|,
name|InjectionPoint
name|injectionPoint
parameter_list|)
block|{
name|Member
name|member
init|=
name|injectionPoint
operator|.
name|getMember
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Member
argument_list|>
name|memberType
init|=
name|MoreTypes
operator|.
name|memberType
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|memberType
operator|==
name|Field
operator|.
name|class
condition|)
block|{
name|dependency
operator|=
name|injectionPoint
operator|.
name|getDependencies
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|formatter
operator|.
name|format
argument_list|(
literal|"  while locating %s%n"
argument_list|,
name|convert
argument_list|(
name|dependency
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|formatter
operator|.
name|format
argument_list|(
literal|"    for field at %s%n"
argument_list|,
name|StackTraceElements
operator|.
name|forMember
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dependency
operator|!=
literal|null
condition|)
block|{
name|formatter
operator|.
name|format
argument_list|(
literal|"  while locating %s%n"
argument_list|,
name|convert
argument_list|(
name|dependency
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|formatter
operator|.
name|format
argument_list|(
literal|"    for parameter %s at %s%n"
argument_list|,
name|dependency
operator|.
name|getParameterIndex
argument_list|()
argument_list|,
name|StackTraceElements
operator|.
name|forMember
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|formatSource
argument_list|(
name|formatter
argument_list|,
name|injectionPoint
operator|.
name|getMember
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

