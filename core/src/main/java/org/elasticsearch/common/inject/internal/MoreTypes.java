begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2008 Google Inc.  *  * Licensed under the Apache License, Version 2.0 (the "License");  * you may not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.inject.internal
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|internal
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|ConfigurationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|TypeLiteral
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|spi
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|GenericArrayType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|GenericDeclaration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Member
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|ParameterizedType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|TypeVariable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|WildcardType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singleton
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_comment
comment|/**  * Static methods for working with types that we aren't publishing in the  * public {@code Types} API.  *  * @author jessewilson@google.com (Jesse Wilson)  */
end_comment

begin_class
DECL|class|MoreTypes
specifier|public
class|class
name|MoreTypes
block|{
DECL|field|EMPTY_TYPE_ARRAY
specifier|public
specifier|static
specifier|final
name|Type
index|[]
name|EMPTY_TYPE_ARRAY
init|=
operator|new
name|Type
index|[]
block|{}
decl_stmt|;
DECL|method|MoreTypes
specifier|private
name|MoreTypes
parameter_list|()
block|{     }
DECL|field|PRIMITIVE_TO_WRAPPER
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|TypeLiteral
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
argument_list|>
name|PRIMITIVE_TO_WRAPPER
decl_stmt|;
static|static
block|{
name|Map
argument_list|<
name|TypeLiteral
argument_list|<
name|?
argument_list|>
argument_list|,
name|TypeLiteral
argument_list|<
name|?
argument_list|>
argument_list|>
name|primitiveToWrapper
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|boolean
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Boolean
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|byte
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Byte
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|short
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Short
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|int
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Integer
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|long
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Long
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|float
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Float
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|double
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Double
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|char
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Character
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|primitiveToWrapper
operator|.
name|put
argument_list|(
name|TypeLiteral
operator|.
name|get
argument_list|(
name|void
operator|.
name|class
argument_list|)
argument_list|,
name|TypeLiteral
operator|.
name|get
argument_list|(
name|Void
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|PRIMITIVE_TO_WRAPPER
operator|=
name|unmodifiableMap
argument_list|(
name|primitiveToWrapper
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns an equivalent type that's safe for use in a key. The returned type will be free of      * primitive types. Type literals of primitives will return the corresponding wrapper types.      *      * @throws ConfigurationException if {@code type} contains a type variable      */
DECL|method|makeKeySafe
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|TypeLiteral
argument_list|<
name|T
argument_list|>
name|makeKeySafe
parameter_list|(
name|TypeLiteral
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isFullySpecified
argument_list|(
name|type
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|String
name|message
init|=
name|type
operator|+
literal|" cannot be used as a key; It is not fully specified."
decl_stmt|;
throw|throw
operator|new
name|ConfigurationException
argument_list|(
name|singleton
argument_list|(
operator|new
name|Message
argument_list|(
name|message
argument_list|)
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|TypeLiteral
argument_list|<
name|T
argument_list|>
name|wrappedPrimitives
init|=
operator|(
name|TypeLiteral
argument_list|<
name|T
argument_list|>
operator|)
name|PRIMITIVE_TO_WRAPPER
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
name|wrappedPrimitives
operator|!=
literal|null
condition|?
name|wrappedPrimitives
else|:
name|type
return|;
block|}
comment|/**      * Returns true if {@code type} is free from type variables.      */
DECL|method|isFullySpecified
specifier|private
specifier|static
name|boolean
name|isFullySpecified
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|CompositeType
condition|)
block|{
return|return
operator|(
operator|(
name|CompositeType
operator|)
name|type
operator|)
operator|.
name|isFullySpecified
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|TypeVariable
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|CompositeType
operator|)
name|canonicalize
argument_list|(
name|type
argument_list|)
operator|)
operator|.
name|isFullySpecified
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns a type that is functionally equal but not necessarily equal      * according to {@link Object#equals(Object) Object.equals()}.      */
DECL|method|canonicalize
specifier|public
specifier|static
name|Type
name|canonicalize
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|ParameterizedTypeImpl
operator|||
name|type
operator|instanceof
name|GenericArrayTypeImpl
operator|||
name|type
operator|instanceof
name|WildcardTypeImpl
condition|)
block|{
return|return
name|type
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|ParameterizedType
name|p
init|=
operator|(
name|ParameterizedType
operator|)
name|type
decl_stmt|;
return|return
operator|new
name|ParameterizedTypeImpl
argument_list|(
name|p
operator|.
name|getOwnerType
argument_list|()
argument_list|,
name|p
operator|.
name|getRawType
argument_list|()
argument_list|,
name|p
operator|.
name|getActualTypeArguments
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|GenericArrayType
condition|)
block|{
name|GenericArrayType
name|g
init|=
operator|(
name|GenericArrayType
operator|)
name|type
decl_stmt|;
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|g
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|Class
operator|&&
operator|(
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
operator|)
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
decl_stmt|;
return|return
operator|new
name|GenericArrayTypeImpl
argument_list|(
name|c
operator|.
name|getComponentType
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|w
init|=
operator|(
name|WildcardType
operator|)
name|type
decl_stmt|;
return|return
operator|new
name|WildcardTypeImpl
argument_list|(
name|w
operator|.
name|getUpperBounds
argument_list|()
argument_list|,
name|w
operator|.
name|getLowerBounds
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// type is either serializable as-is or unsupported
return|return
name|type
return|;
block|}
block|}
DECL|method|getRawType
specifier|public
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|getRawType
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
condition|)
block|{
comment|// type is a normal class.
return|return
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|type
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|ParameterizedType
name|parameterizedType
init|=
operator|(
name|ParameterizedType
operator|)
name|type
decl_stmt|;
comment|// I'm not exactly sure why getRawType() returns Type instead of Class.
comment|// Neal isn't either but suspects some pathological case related
comment|// to nested classes exists.
name|Type
name|rawType
init|=
name|parameterizedType
operator|.
name|getRawType
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rawType
operator|instanceof
name|Class
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expected a Class, but<"
operator|+
name|type
operator|+
literal|"> is of type "
operator|+
name|type
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|rawType
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|GenericArrayType
condition|)
block|{
comment|// TODO: Is this sufficient?
return|return
name|Object
index|[]
operator|.
name|class
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|TypeVariable
condition|)
block|{
comment|// we could use the variable's bounds, but that'll won't work if there are multiple.
comment|// having a raw type that's more general than necessary is okay
return|return
name|Object
operator|.
name|class
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Expected a Class, ParameterizedType, or "
operator|+
literal|"GenericArrayType, but<"
operator|+
name|type
operator|+
literal|"> is of type "
operator|+
name|type
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns true if {@code a} and {@code b} are equal.      */
DECL|method|equals
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|Type
name|a
parameter_list|,
name|Type
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
condition|)
block|{
comment|// also handles (a == null&& b == null)
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|instanceof
name|Class
condition|)
block|{
comment|// Class already specifies equals().
return|return
name|a
operator|.
name|equals
argument_list|(
name|b
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|instanceof
name|ParameterizedType
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|b
operator|instanceof
name|ParameterizedType
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// TODO: save a .clone() call
name|ParameterizedType
name|pa
init|=
operator|(
name|ParameterizedType
operator|)
name|a
decl_stmt|;
name|ParameterizedType
name|pb
init|=
operator|(
name|ParameterizedType
operator|)
name|b
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|pa
operator|.
name|getOwnerType
argument_list|()
argument_list|,
name|pb
operator|.
name|getOwnerType
argument_list|()
argument_list|)
operator|&&
name|pa
operator|.
name|getRawType
argument_list|()
operator|.
name|equals
argument_list|(
name|pb
operator|.
name|getRawType
argument_list|()
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|pa
operator|.
name|getActualTypeArguments
argument_list|()
argument_list|,
name|pb
operator|.
name|getActualTypeArguments
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|instanceof
name|GenericArrayType
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|b
operator|instanceof
name|GenericArrayType
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|GenericArrayType
name|ga
init|=
operator|(
name|GenericArrayType
operator|)
name|a
decl_stmt|;
name|GenericArrayType
name|gb
init|=
operator|(
name|GenericArrayType
operator|)
name|b
decl_stmt|;
return|return
name|equals
argument_list|(
name|ga
operator|.
name|getGenericComponentType
argument_list|()
argument_list|,
name|gb
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|instanceof
name|WildcardType
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|b
operator|instanceof
name|WildcardType
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|WildcardType
name|wa
init|=
operator|(
name|WildcardType
operator|)
name|a
decl_stmt|;
name|WildcardType
name|wb
init|=
operator|(
name|WildcardType
operator|)
name|b
decl_stmt|;
return|return
name|Arrays
operator|.
name|equals
argument_list|(
name|wa
operator|.
name|getUpperBounds
argument_list|()
argument_list|,
name|wb
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|wa
operator|.
name|getLowerBounds
argument_list|()
argument_list|,
name|wb
operator|.
name|getLowerBounds
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|instanceof
name|TypeVariable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|b
operator|instanceof
name|TypeVariable
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|va
init|=
operator|(
name|TypeVariable
operator|)
name|a
decl_stmt|;
name|TypeVariable
argument_list|<
name|?
argument_list|>
name|vb
init|=
operator|(
name|TypeVariable
operator|)
name|b
decl_stmt|;
return|return
name|va
operator|.
name|getGenericDeclaration
argument_list|()
operator|==
name|vb
operator|.
name|getGenericDeclaration
argument_list|()
operator|&&
name|va
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
name|vb
operator|.
name|getName
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// This isn't a type we support. Could be a generic array type, wildcard type, etc.
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Returns the hashCode of {@code type}.      */
DECL|method|hashCode
specifier|public
specifier|static
name|int
name|hashCode
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|Class
condition|)
block|{
comment|// Class specifies hashCode().
return|return
name|type
operator|.
name|hashCode
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|ParameterizedType
name|p
init|=
operator|(
name|ParameterizedType
operator|)
name|type
decl_stmt|;
return|return
name|Arrays
operator|.
name|hashCode
argument_list|(
name|p
operator|.
name|getActualTypeArguments
argument_list|()
argument_list|)
operator|^
name|p
operator|.
name|getRawType
argument_list|()
operator|.
name|hashCode
argument_list|()
operator|^
name|hashCodeOrZero
argument_list|(
name|p
operator|.
name|getOwnerType
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|GenericArrayType
condition|)
block|{
return|return
name|hashCode
argument_list|(
operator|(
operator|(
name|GenericArrayType
operator|)
name|type
operator|)
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|w
init|=
operator|(
name|WildcardType
operator|)
name|type
decl_stmt|;
return|return
name|Arrays
operator|.
name|hashCode
argument_list|(
name|w
operator|.
name|getLowerBounds
argument_list|()
argument_list|)
operator|^
name|Arrays
operator|.
name|hashCode
argument_list|(
name|w
operator|.
name|getUpperBounds
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
comment|// This isn't a type we support. Probably a type variable
return|return
name|hashCodeOrZero
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
DECL|method|hashCodeOrZero
specifier|private
specifier|static
name|int
name|hashCodeOrZero
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|!=
literal|null
condition|?
name|o
operator|.
name|hashCode
argument_list|()
else|:
literal|0
return|;
block|}
DECL|method|toString
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
condition|)
block|{
return|return
operator|(
operator|(
name|Class
operator|)
name|type
operator|)
operator|.
name|getName
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|ParameterizedType
name|parameterizedType
init|=
operator|(
name|ParameterizedType
operator|)
name|type
decl_stmt|;
name|Type
index|[]
name|arguments
init|=
name|parameterizedType
operator|.
name|getActualTypeArguments
argument_list|()
decl_stmt|;
name|Type
name|ownerType
init|=
name|parameterizedType
operator|.
name|getOwnerType
argument_list|()
decl_stmt|;
name|StringBuilder
name|stringBuilder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|ownerType
operator|!=
literal|null
condition|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
name|toString
argument_list|(
name|ownerType
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|stringBuilder
operator|.
name|append
argument_list|(
name|toString
argument_list|(
name|parameterizedType
operator|.
name|getRawType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arguments
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
literal|"<"
argument_list|)
operator|.
name|append
argument_list|(
name|toString
argument_list|(
name|arguments
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|arguments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|stringBuilder
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
operator|.
name|append
argument_list|(
name|toString
argument_list|(
name|arguments
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stringBuilder
operator|.
name|append
argument_list|(
literal|">"
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|GenericArrayType
condition|)
block|{
return|return
name|toString
argument_list|(
operator|(
operator|(
name|GenericArrayType
operator|)
name|type
operator|)
operator|.
name|getGenericComponentType
argument_list|()
argument_list|)
operator|+
literal|"[]"
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|instanceof
name|WildcardType
condition|)
block|{
name|WildcardType
name|wildcardType
init|=
operator|(
name|WildcardType
operator|)
name|type
decl_stmt|;
name|Type
index|[]
name|lowerBounds
init|=
name|wildcardType
operator|.
name|getLowerBounds
argument_list|()
decl_stmt|;
name|Type
index|[]
name|upperBounds
init|=
name|wildcardType
operator|.
name|getUpperBounds
argument_list|()
decl_stmt|;
if|if
condition|(
name|upperBounds
operator|.
name|length
operator|!=
literal|1
operator|||
name|lowerBounds
operator|.
name|length
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported wildcard type "
operator|+
name|type
argument_list|)
throw|;
block|}
if|if
condition|(
name|lowerBounds
operator|.
name|length
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|upperBounds
index|[
literal|0
index|]
operator|!=
name|Object
operator|.
name|class
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Unsupported wildcard type "
operator|+
name|type
argument_list|)
throw|;
block|}
return|return
literal|"? super "
operator|+
name|toString
argument_list|(
name|lowerBounds
index|[
literal|0
index|]
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|upperBounds
index|[
literal|0
index|]
operator|==
name|Object
operator|.
name|class
condition|)
block|{
return|return
literal|"?"
return|;
block|}
else|else
block|{
return|return
literal|"? extends "
operator|+
name|toString
argument_list|(
name|upperBounds
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|type
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns {@code Field.class}, {@code Method.class} or {@code Constructor.class}.      */
DECL|method|memberType
specifier|public
specifier|static
name|Class
argument_list|<
name|?
extends|extends
name|Member
argument_list|>
name|memberType
parameter_list|(
name|Member
name|member
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|member
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
operator|instanceof
name|MemberImpl
condition|)
block|{
return|return
operator|(
operator|(
name|MemberImpl
operator|)
name|member
operator|)
operator|.
name|memberType
return|;
block|}
elseif|else
if|if
condition|(
name|member
operator|instanceof
name|Field
condition|)
block|{
return|return
name|Field
operator|.
name|class
return|;
block|}
elseif|else
if|if
condition|(
name|member
operator|instanceof
name|Method
condition|)
block|{
return|return
name|Method
operator|.
name|class
return|;
block|}
elseif|else
if|if
condition|(
name|member
operator|instanceof
name|Constructor
condition|)
block|{
return|return
name|Constructor
operator|.
name|class
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unsupported implementation class for Member, "
operator|+
name|member
operator|.
name|getClass
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/**      * Formats a member as concise string, such as {@code java.util.ArrayList.size},      * {@code java.util.ArrayList<init>()} or {@code java.util.List.remove()}.      */
DECL|method|toString
specifier|public
specifier|static
name|String
name|toString
parameter_list|(
name|Member
name|member
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Member
argument_list|>
name|memberType
init|=
name|memberType
argument_list|(
name|member
argument_list|)
decl_stmt|;
if|if
condition|(
name|memberType
operator|==
name|Method
operator|.
name|class
condition|)
block|{
return|return
name|member
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|member
operator|.
name|getName
argument_list|()
operator|+
literal|"()"
return|;
block|}
elseif|else
if|if
condition|(
name|memberType
operator|==
name|Field
operator|.
name|class
condition|)
block|{
return|return
name|member
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"."
operator|+
name|member
operator|.
name|getName
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|memberType
operator|==
name|Constructor
operator|.
name|class
condition|)
block|{
return|return
name|member
operator|.
name|getDeclaringClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|".<init>()"
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
block|}
DECL|method|memberKey
specifier|public
specifier|static
name|String
name|memberKey
parameter_list|(
name|Member
name|member
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|member
argument_list|,
literal|"member"
argument_list|)
expr_stmt|;
return|return
literal|"<NO_MEMBER_KEY>"
return|;
block|}
comment|/**      * Returns the generic supertype for {@code supertype}. For example, given a class {@code      * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the      * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.      */
DECL|method|getGenericSupertype
specifier|public
specifier|static
name|Type
name|getGenericSupertype
parameter_list|(
name|Type
name|type
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|toResolve
parameter_list|)
block|{
if|if
condition|(
name|toResolve
operator|==
name|rawType
condition|)
block|{
return|return
name|type
return|;
block|}
comment|// we skip searching through interfaces if unknown is an interface
if|if
condition|(
name|toResolve
operator|.
name|isInterface
argument_list|()
condition|)
block|{
name|Class
index|[]
name|interfaces
init|=
name|rawType
operator|.
name|getInterfaces
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|length
init|=
name|interfaces
operator|.
name|length
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|interfaces
index|[
name|i
index|]
operator|==
name|toResolve
condition|)
block|{
return|return
name|rawType
operator|.
name|getGenericInterfaces
argument_list|()
index|[
name|i
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|toResolve
operator|.
name|isAssignableFrom
argument_list|(
name|interfaces
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|getGenericSupertype
argument_list|(
name|rawType
operator|.
name|getGenericInterfaces
argument_list|()
index|[
name|i
index|]
argument_list|,
name|interfaces
index|[
name|i
index|]
argument_list|,
name|toResolve
argument_list|)
return|;
block|}
block|}
block|}
comment|// check our supertypes
if|if
condition|(
operator|!
name|rawType
operator|.
name|isInterface
argument_list|()
condition|)
block|{
while|while
condition|(
name|rawType
operator|!=
name|Object
operator|.
name|class
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|rawSupertype
init|=
name|rawType
operator|.
name|getSuperclass
argument_list|()
decl_stmt|;
if|if
condition|(
name|rawSupertype
operator|==
name|toResolve
condition|)
block|{
return|return
name|rawType
operator|.
name|getGenericSuperclass
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|toResolve
operator|.
name|isAssignableFrom
argument_list|(
name|rawSupertype
argument_list|)
condition|)
block|{
return|return
name|getGenericSupertype
argument_list|(
name|rawType
operator|.
name|getGenericSuperclass
argument_list|()
argument_list|,
name|rawSupertype
argument_list|,
name|toResolve
argument_list|)
return|;
block|}
name|rawType
operator|=
name|rawSupertype
expr_stmt|;
block|}
block|}
comment|// we can't resolve this further
return|return
name|toResolve
return|;
block|}
DECL|method|resolveTypeVariable
specifier|public
specifier|static
name|Type
name|resolveTypeVariable
parameter_list|(
name|Type
name|type
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|rawType
parameter_list|,
name|TypeVariable
name|unknown
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|declaredByRaw
init|=
name|declaringClassOf
argument_list|(
name|unknown
argument_list|)
decl_stmt|;
comment|// we can't reduce this further
if|if
condition|(
name|declaredByRaw
operator|==
literal|null
condition|)
block|{
return|return
name|unknown
return|;
block|}
name|Type
name|declaredBy
init|=
name|getGenericSupertype
argument_list|(
name|type
argument_list|,
name|rawType
argument_list|,
name|declaredByRaw
argument_list|)
decl_stmt|;
if|if
condition|(
name|declaredBy
operator|instanceof
name|ParameterizedType
condition|)
block|{
name|int
name|index
init|=
name|indexOf
argument_list|(
name|declaredByRaw
operator|.
name|getTypeParameters
argument_list|()
argument_list|,
name|unknown
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|ParameterizedType
operator|)
name|declaredBy
operator|)
operator|.
name|getActualTypeArguments
argument_list|()
index|[
name|index
index|]
return|;
block|}
return|return
name|unknown
return|;
block|}
DECL|method|indexOf
specifier|private
specifier|static
name|int
name|indexOf
parameter_list|(
name|Object
index|[]
name|array
parameter_list|,
name|Object
name|toFind
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|toFind
operator|.
name|equals
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
comment|/**      * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by      * a class.      */
DECL|method|declaringClassOf
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|declaringClassOf
parameter_list|(
name|TypeVariable
name|typeVariable
parameter_list|)
block|{
name|GenericDeclaration
name|genericDeclaration
init|=
name|typeVariable
operator|.
name|getGenericDeclaration
argument_list|()
decl_stmt|;
return|return
name|genericDeclaration
operator|instanceof
name|Class
condition|?
operator|(
name|Class
argument_list|<
name|?
argument_list|>
operator|)
name|genericDeclaration
else|:
literal|null
return|;
block|}
DECL|class|ParameterizedTypeImpl
specifier|public
specifier|static
class|class
name|ParameterizedTypeImpl
implements|implements
name|ParameterizedType
implements|,
name|CompositeType
block|{
DECL|field|ownerType
specifier|private
specifier|final
name|Type
name|ownerType
decl_stmt|;
DECL|field|rawType
specifier|private
specifier|final
name|Type
name|rawType
decl_stmt|;
DECL|field|typeArguments
specifier|private
specifier|final
name|Type
index|[]
name|typeArguments
decl_stmt|;
DECL|method|ParameterizedTypeImpl
specifier|public
name|ParameterizedTypeImpl
parameter_list|(
name|Type
name|ownerType
parameter_list|,
name|Type
name|rawType
parameter_list|,
name|Type
modifier|...
name|typeArguments
parameter_list|)
block|{
comment|// require an owner type if the raw type needs it
if|if
condition|(
name|rawType
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
condition|)
block|{
name|Class
name|rawTypeAsClass
init|=
operator|(
name|Class
operator|)
name|rawType
decl_stmt|;
if|if
condition|(
name|ownerType
operator|==
literal|null
operator|&&
name|rawTypeAsClass
operator|.
name|getEnclosingClass
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No owner type for enclosed "
operator|+
name|rawType
argument_list|)
throw|;
block|}
if|if
condition|(
name|ownerType
operator|!=
literal|null
operator|&&
name|rawTypeAsClass
operator|.
name|getEnclosingClass
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Owner type for unenclosed "
operator|+
name|rawType
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|ownerType
operator|=
name|ownerType
operator|==
literal|null
condition|?
literal|null
else|:
name|canonicalize
argument_list|(
name|ownerType
argument_list|)
expr_stmt|;
name|this
operator|.
name|rawType
operator|=
name|canonicalize
argument_list|(
name|rawType
argument_list|)
expr_stmt|;
name|this
operator|.
name|typeArguments
operator|=
name|typeArguments
operator|.
name|clone
argument_list|()
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|this
operator|.
name|typeArguments
operator|.
name|length
condition|;
name|t
operator|++
control|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|this
operator|.
name|typeArguments
index|[
name|t
index|]
argument_list|,
literal|"type parameter"
argument_list|)
expr_stmt|;
name|checkNotPrimitive
argument_list|(
name|this
operator|.
name|typeArguments
index|[
name|t
index|]
argument_list|,
literal|"type parameters"
argument_list|)
expr_stmt|;
name|this
operator|.
name|typeArguments
index|[
name|t
index|]
operator|=
name|canonicalize
argument_list|(
name|this
operator|.
name|typeArguments
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getActualTypeArguments
specifier|public
name|Type
index|[]
name|getActualTypeArguments
parameter_list|()
block|{
return|return
name|typeArguments
operator|.
name|clone
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getRawType
specifier|public
name|Type
name|getRawType
parameter_list|()
block|{
return|return
name|rawType
return|;
block|}
annotation|@
name|Override
DECL|method|getOwnerType
specifier|public
name|Type
name|getOwnerType
parameter_list|()
block|{
return|return
name|ownerType
return|;
block|}
annotation|@
name|Override
DECL|method|isFullySpecified
specifier|public
name|boolean
name|isFullySpecified
parameter_list|()
block|{
if|if
condition|(
name|ownerType
operator|!=
literal|null
operator|&&
operator|!
name|MoreTypes
operator|.
name|isFullySpecified
argument_list|(
name|ownerType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|MoreTypes
operator|.
name|isFullySpecified
argument_list|(
name|rawType
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|Type
name|type
range|:
name|typeArguments
control|)
block|{
if|if
condition|(
operator|!
name|MoreTypes
operator|.
name|isFullySpecified
argument_list|(
name|type
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|ParameterizedType
operator|&&
name|MoreTypes
operator|.
name|equals
argument_list|(
name|this
argument_list|,
operator|(
name|ParameterizedType
operator|)
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|hashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|toString
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_class
DECL|class|GenericArrayTypeImpl
specifier|public
specifier|static
class|class
name|GenericArrayTypeImpl
implements|implements
name|GenericArrayType
implements|,
name|CompositeType
block|{
DECL|field|componentType
specifier|private
specifier|final
name|Type
name|componentType
decl_stmt|;
DECL|method|GenericArrayTypeImpl
specifier|public
name|GenericArrayTypeImpl
parameter_list|(
name|Type
name|componentType
parameter_list|)
block|{
name|this
operator|.
name|componentType
operator|=
name|canonicalize
argument_list|(
name|componentType
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getGenericComponentType
specifier|public
name|Type
name|getGenericComponentType
parameter_list|()
block|{
return|return
name|componentType
return|;
block|}
annotation|@
name|Override
DECL|method|isFullySpecified
specifier|public
name|boolean
name|isFullySpecified
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|isFullySpecified
argument_list|(
name|componentType
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|GenericArrayType
operator|&&
name|MoreTypes
operator|.
name|equals
argument_list|(
name|this
argument_list|,
operator|(
name|GenericArrayType
operator|)
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|hashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|toString
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**      * The WildcardType interface supports multiple upper bounds and multiple      * lower bounds. We only support what the Java 6 language needs - at most one      * bound. If a lower bound is set, the upper bound must be Object.class.      */
end_comment

begin_class
DECL|class|WildcardTypeImpl
specifier|public
specifier|static
class|class
name|WildcardTypeImpl
implements|implements
name|WildcardType
implements|,
name|CompositeType
block|{
DECL|field|upperBound
specifier|private
specifier|final
name|Type
name|upperBound
decl_stmt|;
DECL|field|lowerBound
specifier|private
specifier|final
name|Type
name|lowerBound
decl_stmt|;
DECL|method|WildcardTypeImpl
specifier|public
name|WildcardTypeImpl
parameter_list|(
name|Type
index|[]
name|upperBounds
parameter_list|,
name|Type
index|[]
name|lowerBounds
parameter_list|)
block|{
if|if
condition|(
name|lowerBounds
operator|.
name|length
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must have at most one lower bound."
argument_list|)
throw|;
block|}
if|if
condition|(
name|upperBounds
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Must have exactly one upper bound."
argument_list|)
throw|;
block|}
if|if
condition|(
name|lowerBounds
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|lowerBounds
index|[
literal|0
index|]
argument_list|,
literal|"lowerBound"
argument_list|)
expr_stmt|;
name|checkNotPrimitive
argument_list|(
name|lowerBounds
index|[
literal|0
index|]
argument_list|,
literal|"wildcard bounds"
argument_list|)
expr_stmt|;
if|if
condition|(
name|upperBounds
index|[
literal|0
index|]
operator|!=
name|Object
operator|.
name|class
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"bounded both ways"
argument_list|)
throw|;
block|}
name|this
operator|.
name|lowerBound
operator|=
name|canonicalize
argument_list|(
name|lowerBounds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|this
operator|.
name|upperBound
operator|=
name|Object
operator|.
name|class
expr_stmt|;
block|}
else|else
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|upperBounds
index|[
literal|0
index|]
argument_list|,
literal|"upperBound"
argument_list|)
expr_stmt|;
name|checkNotPrimitive
argument_list|(
name|upperBounds
index|[
literal|0
index|]
argument_list|,
literal|"wildcard bounds"
argument_list|)
expr_stmt|;
name|this
operator|.
name|lowerBound
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|upperBound
operator|=
name|canonicalize
argument_list|(
name|upperBounds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getUpperBounds
specifier|public
name|Type
index|[]
name|getUpperBounds
parameter_list|()
block|{
return|return
operator|new
name|Type
index|[]
block|{
name|upperBound
block|}
return|;
block|}
annotation|@
name|Override
DECL|method|getLowerBounds
specifier|public
name|Type
index|[]
name|getLowerBounds
parameter_list|()
block|{
return|return
name|lowerBound
operator|!=
literal|null
condition|?
operator|new
name|Type
index|[]
block|{
name|lowerBound
block|}
else|:
name|EMPTY_TYPE_ARRAY
return|;
block|}
annotation|@
name|Override
DECL|method|isFullySpecified
specifier|public
name|boolean
name|isFullySpecified
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|isFullySpecified
argument_list|(
name|upperBound
argument_list|)
operator|&&
operator|(
name|lowerBound
operator|==
literal|null
operator|||
name|MoreTypes
operator|.
name|isFullySpecified
argument_list|(
name|lowerBound
argument_list|)
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
return|return
name|other
operator|instanceof
name|WildcardType
operator|&&
name|MoreTypes
operator|.
name|equals
argument_list|(
name|this
argument_list|,
operator|(
name|WildcardType
operator|)
name|other
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|hashCode
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|toString
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_function
DECL|method|checkNotPrimitive
specifier|private
specifier|static
name|void
name|checkNotPrimitive
parameter_list|(
name|Type
name|type
parameter_list|,
name|String
name|use
parameter_list|)
block|{
if|if
condition|(
name|type
operator|instanceof
name|Class
argument_list|<
name|?
argument_list|>
operator|&&
operator|(
operator|(
name|Class
operator|)
name|type
operator|)
operator|.
name|isPrimitive
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Primitive types are not allowed in "
operator|+
name|use
operator|+
literal|": "
operator|+
name|type
argument_list|)
throw|;
block|}
block|}
end_function

begin_comment
comment|/**      * We cannot serialize the built-in Java member classes, which prevents us from using Members in      * our exception types. We workaround this with this serializable implementation. It includes all      * of the API methods, plus everything we use for line numbers and messaging.      */
end_comment

begin_class
DECL|class|MemberImpl
specifier|public
specifier|static
class|class
name|MemberImpl
implements|implements
name|Member
block|{
DECL|field|declaringClass
specifier|private
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|declaringClass
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|modifiers
specifier|private
specifier|final
name|int
name|modifiers
decl_stmt|;
DECL|field|synthetic
specifier|private
specifier|final
name|boolean
name|synthetic
decl_stmt|;
DECL|field|memberType
specifier|private
specifier|final
name|Class
argument_list|<
name|?
extends|extends
name|Member
argument_list|>
name|memberType
decl_stmt|;
DECL|field|memberKey
specifier|private
specifier|final
name|String
name|memberKey
decl_stmt|;
DECL|method|MemberImpl
specifier|private
name|MemberImpl
parameter_list|(
name|Member
name|member
parameter_list|)
block|{
name|this
operator|.
name|declaringClass
operator|=
name|member
operator|.
name|getDeclaringClass
argument_list|()
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|member
operator|.
name|getName
argument_list|()
expr_stmt|;
name|this
operator|.
name|modifiers
operator|=
name|member
operator|.
name|getModifiers
argument_list|()
expr_stmt|;
name|this
operator|.
name|synthetic
operator|=
name|member
operator|.
name|isSynthetic
argument_list|()
expr_stmt|;
name|this
operator|.
name|memberType
operator|=
name|memberType
argument_list|(
name|member
argument_list|)
expr_stmt|;
name|this
operator|.
name|memberKey
operator|=
name|memberKey
argument_list|(
name|member
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDeclaringClass
specifier|public
name|Class
name|getDeclaringClass
parameter_list|()
block|{
return|return
name|declaringClass
return|;
block|}
annotation|@
name|Override
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
annotation|@
name|Override
DECL|method|getModifiers
specifier|public
name|int
name|getModifiers
parameter_list|()
block|{
return|return
name|modifiers
return|;
block|}
annotation|@
name|Override
DECL|method|isSynthetic
specifier|public
name|boolean
name|isSynthetic
parameter_list|()
block|{
return|return
name|synthetic
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|MoreTypes
operator|.
name|toString
argument_list|(
name|this
argument_list|)
return|;
block|}
block|}
end_class

begin_comment
comment|/**      * A type formed from other types, such as arrays, parameterized types or wildcard types      */
end_comment

begin_interface
DECL|interface|CompositeType
specifier|private
interface|interface
name|CompositeType
block|{
comment|/**          * Returns true if there are no type variables in this type.          */
DECL|method|isFullySpecified
name|boolean
name|isFullySpecified
parameter_list|()
function_decl|;
block|}
end_interface

unit|}
end_unit

