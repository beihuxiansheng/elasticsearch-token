begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.util.concurrent
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ExponentiallyWeightedMovingAverage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ResizableBlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|BlockingQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadFactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_comment
comment|/**  * An extension to thread pool executor, which automatically adjusts the queue size of the  * {@code ResizableBlockingQueue} according to Little's Law.  */
end_comment

begin_class
DECL|class|QueueResizingEsThreadPoolExecutor
specifier|public
specifier|final
class|class
name|QueueResizingEsThreadPoolExecutor
extends|extends
name|EsThreadPoolExecutor
block|{
comment|// This is a random starting point alpha. TODO: revisit this with actual testing and/or make it configurable
DECL|field|EWMA_ALPHA
specifier|public
specifier|static
name|double
name|EWMA_ALPHA
init|=
literal|0.3
decl_stmt|;
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|ESLoggerFactory
operator|.
name|getLogger
argument_list|(
name|QueueResizingEsThreadPoolExecutor
operator|.
name|class
argument_list|)
decl_stmt|;
comment|// The amount the queue size is adjusted by for each calcuation
DECL|field|QUEUE_ADJUSTMENT_AMOUNT
specifier|private
specifier|static
specifier|final
name|int
name|QUEUE_ADJUSTMENT_AMOUNT
init|=
literal|50
decl_stmt|;
DECL|field|runnableWrapper
specifier|private
specifier|final
name|Function
argument_list|<
name|Runnable
argument_list|,
name|Runnable
argument_list|>
name|runnableWrapper
decl_stmt|;
DECL|field|workQueue
specifier|private
specifier|final
name|ResizableBlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|workQueue
decl_stmt|;
DECL|field|tasksPerFrame
specifier|private
specifier|final
name|int
name|tasksPerFrame
decl_stmt|;
DECL|field|minQueueSize
specifier|private
specifier|final
name|int
name|minQueueSize
decl_stmt|;
DECL|field|maxQueueSize
specifier|private
specifier|final
name|int
name|maxQueueSize
decl_stmt|;
DECL|field|targetedResponseTimeNanos
specifier|private
specifier|final
name|long
name|targetedResponseTimeNanos
decl_stmt|;
DECL|field|executionEWMA
specifier|private
specifier|final
name|ExponentiallyWeightedMovingAverage
name|executionEWMA
decl_stmt|;
DECL|field|totalTaskNanos
specifier|private
specifier|final
name|AtomicLong
name|totalTaskNanos
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|taskCount
specifier|private
specifier|final
name|AtomicInteger
name|taskCount
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|startNs
specifier|private
name|long
name|startNs
decl_stmt|;
DECL|method|QueueResizingEsThreadPoolExecutor
name|QueueResizingEsThreadPoolExecutor
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|corePoolSize
parameter_list|,
name|int
name|maximumPoolSize
parameter_list|,
name|long
name|keepAliveTime
parameter_list|,
name|TimeUnit
name|unit
parameter_list|,
name|ResizableBlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|workQueue
parameter_list|,
name|int
name|minQueueSize
parameter_list|,
name|int
name|maxQueueSize
parameter_list|,
name|Function
argument_list|<
name|Runnable
argument_list|,
name|Runnable
argument_list|>
name|runnableWrapper
parameter_list|,
specifier|final
name|int
name|tasksPerFrame
parameter_list|,
name|TimeValue
name|targetedResponseTime
parameter_list|,
name|ThreadFactory
name|threadFactory
parameter_list|,
name|XRejectedExecutionHandler
name|handler
parameter_list|,
name|ThreadContext
name|contextHolder
parameter_list|)
block|{
name|super
argument_list|(
name|name
argument_list|,
name|corePoolSize
argument_list|,
name|maximumPoolSize
argument_list|,
name|keepAliveTime
argument_list|,
name|unit
argument_list|,
name|workQueue
argument_list|,
name|threadFactory
argument_list|,
name|handler
argument_list|,
name|contextHolder
argument_list|)
expr_stmt|;
name|this
operator|.
name|runnableWrapper
operator|=
name|runnableWrapper
expr_stmt|;
name|this
operator|.
name|workQueue
operator|=
name|workQueue
expr_stmt|;
name|this
operator|.
name|tasksPerFrame
operator|=
name|tasksPerFrame
expr_stmt|;
name|this
operator|.
name|startNs
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|this
operator|.
name|minQueueSize
operator|=
name|minQueueSize
expr_stmt|;
name|this
operator|.
name|maxQueueSize
operator|=
name|maxQueueSize
expr_stmt|;
name|this
operator|.
name|targetedResponseTimeNanos
operator|=
name|targetedResponseTime
operator|.
name|getNanos
argument_list|()
expr_stmt|;
comment|// We choose to start the EWMA with the targeted response time, reasoning that it is a
comment|// better start point for a realistic task execution time than starting at 0
name|this
operator|.
name|executionEWMA
operator|=
operator|new
name|ExponentiallyWeightedMovingAverage
argument_list|(
name|EWMA_ALPHA
argument_list|,
name|targetedResponseTimeNanos
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"thread pool [{}] will adjust queue by [{}] when determining automatic queue size"
argument_list|,
name|name
argument_list|,
name|QUEUE_ADJUSTMENT_AMOUNT
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doExecute
specifier|protected
name|void
name|doExecute
parameter_list|(
specifier|final
name|Runnable
name|command
parameter_list|)
block|{
comment|// we are submitting a task, it has not yet started running (because super.excute() has not
comment|// been called), but it could be immediately run, or run at a later time. We need the time
comment|// this task entered the queue, which we get by creating a TimedRunnable, which starts the
comment|// clock as soon as it is created.
name|super
operator|.
name|doExecute
argument_list|(
name|this
operator|.
name|runnableWrapper
operator|.
name|apply
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Calculate task rate (Î»), for a fixed number of tasks and time it took those tasks to be measured      *      * @param totalNumberOfTasks total number of tasks that were measured      * @param totalFrameTaskNanos nanoseconds during which the tasks were received      * @return the rate of tasks in the system      */
DECL|method|calculateLambda
specifier|static
name|double
name|calculateLambda
parameter_list|(
specifier|final
name|int
name|totalNumberOfTasks
parameter_list|,
specifier|final
name|long
name|totalFrameTaskNanos
parameter_list|)
block|{
assert|assert
name|totalFrameTaskNanos
operator|>
literal|0
operator|:
literal|"cannot calculate for instantaneous tasks, got: "
operator|+
name|totalFrameTaskNanos
assert|;
assert|assert
name|totalNumberOfTasks
operator|>
literal|0
operator|:
literal|"cannot calculate for no tasks, got: "
operator|+
name|totalNumberOfTasks
assert|;
comment|// There is no set execution time, instead we adjust the time window based on the
comment|// number of completed tasks, so there is no background thread required to update the
comment|// queue size at a regular interval. This means we need to calculate our Î» by the
comment|// total runtime, rather than a fixed interval.
comment|// Î» = total tasks divided by measurement time
return|return
operator|(
name|double
operator|)
name|totalNumberOfTasks
operator|/
name|totalFrameTaskNanos
return|;
block|}
comment|/**      * Calculate Little's Law (L), which is the "optimal" queue size for a particular task rate (lambda) and targeted response time.      *      * @param lambda the arrival rate of tasks in nanoseconds      * @param targetedResponseTimeNanos nanoseconds for the average targeted response rate of requests      * @return the optimal queue size for the give task rate and targeted response time      */
DECL|method|calculateL
specifier|static
name|int
name|calculateL
parameter_list|(
specifier|final
name|double
name|lambda
parameter_list|,
specifier|final
name|long
name|targetedResponseTimeNanos
parameter_list|)
block|{
assert|assert
name|targetedResponseTimeNanos
operator|>
literal|0
operator|:
literal|"cannot calculate for instantaneous requests"
assert|;
comment|// L = Î» * W
return|return
name|Math
operator|.
name|toIntExact
argument_list|(
call|(
name|long
call|)
argument_list|(
name|lambda
operator|*
name|targetedResponseTimeNanos
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns the current queue capacity      */
DECL|method|getCurrentCapacity
specifier|public
name|int
name|getCurrentCapacity
parameter_list|()
block|{
return|return
name|workQueue
operator|.
name|capacity
argument_list|()
return|;
block|}
comment|/**      * Returns the exponentially weighted moving average of the task execution time      */
DECL|method|getTaskExecutionEWMA
specifier|public
name|double
name|getTaskExecutionEWMA
parameter_list|()
block|{
return|return
name|executionEWMA
operator|.
name|getAverage
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|afterExecute
specifier|protected
name|void
name|afterExecute
parameter_list|(
name|Runnable
name|r
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|super
operator|.
name|afterExecute
argument_list|(
name|r
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// A task has been completed, it has left the building. We should now be able to get the
comment|// total time as a combination of the time in the queue and time spent running the task. We
comment|// only want runnables that did not throw errors though, because they could be fast-failures
comment|// that throw off our timings, so only check when t is null.
assert|assert
name|r
operator|instanceof
name|TimedRunnable
operator|:
literal|"expected only TimedRunnables in queue"
assert|;
specifier|final
name|long
name|taskNanos
init|=
operator|(
operator|(
name|TimedRunnable
operator|)
name|r
operator|)
operator|.
name|getTotalNanos
argument_list|()
decl_stmt|;
specifier|final
name|long
name|totalNanos
init|=
name|totalTaskNanos
operator|.
name|addAndGet
argument_list|(
name|taskNanos
argument_list|)
decl_stmt|;
specifier|final
name|long
name|taskExecutionNanos
init|=
operator|(
operator|(
name|TimedRunnable
operator|)
name|r
operator|)
operator|.
name|getTotalExecutionNanos
argument_list|()
decl_stmt|;
assert|assert
name|taskExecutionNanos
operator|>=
literal|0
operator|:
literal|"expected task to always take longer than 0 nanoseconds, got: "
operator|+
name|taskExecutionNanos
assert|;
name|executionEWMA
operator|.
name|addValue
argument_list|(
name|taskExecutionNanos
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskCount
operator|.
name|incrementAndGet
argument_list|()
operator|==
name|this
operator|.
name|tasksPerFrame
condition|)
block|{
specifier|final
name|long
name|endTimeNs
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
specifier|final
name|long
name|totalRuntime
init|=
name|endTimeNs
operator|-
name|this
operator|.
name|startNs
decl_stmt|;
comment|// Reset the start time for all tasks. At first glance this appears to need to be
comment|// volatile, since we are reading from a different thread when it is set, but it
comment|// is protected by the taskCount memory barrier.
comment|// See: https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html
name|startNs
operator|=
name|endTimeNs
expr_stmt|;
comment|// Calculate the new desired queue size
try|try
block|{
specifier|final
name|double
name|lambda
init|=
name|calculateLambda
argument_list|(
name|tasksPerFrame
argument_list|,
name|totalNanos
argument_list|)
decl_stmt|;
specifier|final
name|int
name|desiredQueueSize
init|=
name|calculateL
argument_list|(
name|lambda
argument_list|,
name|targetedResponseTimeNanos
argument_list|)
decl_stmt|;
specifier|final
name|int
name|oldCapacity
init|=
name|workQueue
operator|.
name|capacity
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
specifier|final
name|long
name|avgTaskTime
init|=
name|totalNanos
operator|/
name|tasksPerFrame
decl_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}]: there were [{}] tasks in [{}], avg task time [{}], EWMA task execution [{}], "
operator|+
literal|"[{} tasks/s], optimal queue is [{}], current capacity [{}]"
argument_list|,
name|name
argument_list|,
name|tasksPerFrame
argument_list|,
name|TimeValue
operator|.
name|timeValueNanos
argument_list|(
name|totalRuntime
argument_list|)
argument_list|,
name|TimeValue
operator|.
name|timeValueNanos
argument_list|(
name|avgTaskTime
argument_list|)
argument_list|,
name|TimeValue
operator|.
name|timeValueNanos
argument_list|(
operator|(
name|long
operator|)
name|executionEWMA
operator|.
name|getAverage
argument_list|()
argument_list|)
argument_list|,
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"%.2f"
argument_list|,
name|lambda
operator|*
name|TimeValue
operator|.
name|timeValueSeconds
argument_list|(
literal|1
argument_list|)
operator|.
name|nanos
argument_list|()
argument_list|)
argument_list|,
name|desiredQueueSize
argument_list|,
name|oldCapacity
argument_list|)
expr_stmt|;
block|}
comment|// Adjust the queue size towards the desired capacity using an adjust of
comment|// QUEUE_ADJUSTMENT_AMOUNT (either up or down), keeping in mind the min and max
comment|// values the queue size can have.
specifier|final
name|int
name|newCapacity
init|=
name|workQueue
operator|.
name|adjustCapacity
argument_list|(
name|desiredQueueSize
argument_list|,
name|QUEUE_ADJUSTMENT_AMOUNT
argument_list|,
name|minQueueSize
argument_list|,
name|maxQueueSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|!=
name|newCapacity
operator|&&
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"adjusted [{}] queue size by [{}], old capacity: [{}], new capacity: [{}]"
argument_list|,
name|name
argument_list|,
name|newCapacity
operator|>
name|oldCapacity
condition|?
name|QUEUE_ADJUSTMENT_AMOUNT
else|:
operator|-
name|QUEUE_ADJUSTMENT_AMOUNT
argument_list|,
name|oldCapacity
argument_list|,
name|newCapacity
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ArithmeticException
name|e
parameter_list|)
block|{
comment|// There was an integer overflow, so just log about it, rather than adjust the queue size
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to calculate optimal queue size for [{}] thread pool, "
operator|+
literal|"total frame time [{}ns], tasks [{}], task execution time [{}ns]"
argument_list|,
name|name
argument_list|,
name|totalRuntime
argument_list|,
name|tasksPerFrame
argument_list|,
name|totalNanos
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Finally, decrement the task count and time back to their starting values. We
comment|// do this at the end so there is no concurrent adjustments happening. We also
comment|// decrement them instead of resetting them back to zero, as resetting them back
comment|// to zero causes operations that came in during the adjustment to be uncounted
name|int
name|tasks
init|=
name|taskCount
operator|.
name|addAndGet
argument_list|(
operator|-
name|this
operator|.
name|tasksPerFrame
argument_list|)
decl_stmt|;
assert|assert
name|tasks
operator|>=
literal|0
operator|:
literal|"tasks should never be negative, got: "
operator|+
name|tasks
assert|;
if|if
condition|(
name|tasks
operator|>=
name|this
operator|.
name|tasksPerFrame
condition|)
block|{
comment|// Start over, because we can potentially reach a "never adjusting" state,
comment|//
comment|// consider the following:
comment|// - If the frame window is 10, and there are 10 tasks, then an adjustment will begin. (taskCount == 10)
comment|// - Prior to the adjustment being done, 15 more tasks come in, the taskCount is now 25
comment|// - Adjustment happens and we decrement the tasks by 10, taskCount is now 15
comment|// - Since taskCount will now be incremented forever, it will never be 10 again,
comment|//   so there will be no further adjustments
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}]: too many incoming tasks while queue size adjustment occurs, resetting measurements to 0"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|totalTaskNanos
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|taskCount
operator|.
name|getAndSet
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|startNs
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Do a regular adjustment
name|totalTaskNanos
operator|.
name|addAndGet
argument_list|(
operator|-
name|totalNanos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
name|getClass
argument_list|()
operator|.
name|getSimpleName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
name|name
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|ResizableBlockingQueue
name|queue
init|=
operator|(
name|ResizableBlockingQueue
operator|)
name|getQueue
argument_list|()
decl_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"queue capacity = "
argument_list|)
operator|.
name|append
argument_list|(
name|getCurrentCapacity
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"min queue capacity = "
argument_list|)
operator|.
name|append
argument_list|(
name|minQueueSize
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"max queue capacity = "
argument_list|)
operator|.
name|append
argument_list|(
name|maxQueueSize
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"frame size = "
argument_list|)
operator|.
name|append
argument_list|(
name|tasksPerFrame
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"targeted response rate = "
argument_list|)
operator|.
name|append
argument_list|(
name|TimeValue
operator|.
name|timeValueNanos
argument_list|(
name|targetedResponseTimeNanos
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"task execution EWMA = "
argument_list|)
operator|.
name|append
argument_list|(
name|TimeValue
operator|.
name|timeValueNanos
argument_list|(
operator|(
name|long
operator|)
name|executionEWMA
operator|.
name|getAverage
argument_list|()
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|b
operator|.
name|append
argument_list|(
literal|"adjustment amount = "
argument_list|)
operator|.
name|append
argument_list|(
name|QUEUE_ADJUSTMENT_AMOUNT
argument_list|)
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
comment|/*          * ThreadPoolExecutor has some nice information in its toString but we          * can't get at it easily without just getting the toString.          */
name|b
operator|.
name|append
argument_list|(
name|super
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

