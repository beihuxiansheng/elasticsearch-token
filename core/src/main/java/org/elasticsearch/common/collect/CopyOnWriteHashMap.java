begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.collect
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|mutable
operator|.
name|MutableValueInt
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_comment
comment|/**  * An immutable map whose writes result in a new copy of the map to be created.  *  * This is essentially a hash array mapped trie: inner nodes use a bitmap in  * order to map hashes to slots by counting ones. In case of a collision (two  * values having the same 32-bits hash), a leaf node is created which stores  * and searches for values sequentially.  *  * Reads and writes both perform in logarithmic time. Null keys and values are  * not supported.  *  * This structure might need to perform several object creations per write so  * it is better suited for work-loads that are not too write-intensive.  *  * @see<a href="http://en.wikipedia.org/wiki/Hash_array_mapped_trie">the wikipedia page</a>  */
end_comment

begin_class
DECL|class|CopyOnWriteHashMap
specifier|public
specifier|final
class|class
name|CopyOnWriteHashMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|TOTAL_HASH_BITS
specifier|private
specifier|static
specifier|final
name|int
name|TOTAL_HASH_BITS
init|=
literal|32
decl_stmt|;
DECL|field|EMPTY_ARRAY
specifier|private
specifier|static
specifier|final
name|Object
index|[]
name|EMPTY_ARRAY
init|=
operator|new
name|Object
index|[
literal|0
index|]
decl_stmt|;
DECL|field|HASH_BITS
specifier|private
specifier|static
specifier|final
name|int
name|HASH_BITS
init|=
literal|6
decl_stmt|;
DECL|field|HASH_MASK
specifier|private
specifier|static
specifier|final
name|int
name|HASH_MASK
init|=
literal|0x3F
decl_stmt|;
comment|/**      * Return a copy of the provided map.      */
DECL|method|copyOf
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyOf
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|map
parameter_list|)
block|{
if|if
condition|(
name|map
operator|instanceof
name|CopyOnWriteHashMap
condition|)
block|{
comment|// no need to copy in that case
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|cowMap
init|=
operator|(
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|map
decl_stmt|;
return|return
name|cowMap
return|;
block|}
else|else
block|{
return|return
operator|new
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
operator|.
name|copyAndPutAll
argument_list|(
name|map
argument_list|)
return|;
block|}
block|}
comment|/**      * Abstraction of a node, implemented by both inner and leaf nodes.      */
DECL|class|Node
specifier|private
specifier|static
specifier|abstract
class|class
name|Node
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * Recursively get the key with the given hash.          */
DECL|method|get
specifier|abstract
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
function_decl|;
comment|/**          * Recursively add a new entry to this node.<code>hashBits</code> is          * the number of bits that are still set in the hash. When this value          * reaches a number that is less than or equal to<tt>0</tt>, a leaf          * node needs to be created since it means that a collision occurred          * on the 32 bits of the hash.          */
DECL|method|put
specifier|abstract
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|int
name|hashBits
parameter_list|,
name|V
name|value
parameter_list|,
name|MutableValueInt
name|newValue
parameter_list|)
function_decl|;
comment|/**          * Recursively remove an entry from this node.          */
DECL|method|remove
specifier|abstract
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
function_decl|;
comment|/**          * For the current node only, append entries that are stored on this          * node to<code>entries</code> and sub nodes to<code>nodes</code>.          */
DECL|method|visit
specifier|abstract
name|void
name|visit
parameter_list|(
name|Deque
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|,
name|Deque
argument_list|<
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|nodes
parameter_list|)
function_decl|;
comment|/**          * Whether this node stores nothing under it.          */
DECL|method|isEmpty
specifier|abstract
name|boolean
name|isEmpty
parameter_list|()
function_decl|;
block|}
comment|/**      * A leaf of the tree where all hashes are equal. Values are added and retrieved in linear time.      */
DECL|class|Leaf
specifier|private
specifier|static
class|class
name|Leaf
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|keys
specifier|private
specifier|final
name|K
index|[]
name|keys
decl_stmt|;
DECL|field|values
specifier|private
specifier|final
name|V
index|[]
name|values
decl_stmt|;
DECL|method|Leaf
name|Leaf
parameter_list|(
name|K
index|[]
name|keys
parameter_list|,
name|V
index|[]
name|values
parameter_list|)
block|{
name|this
operator|.
name|keys
operator|=
name|keys
expr_stmt|;
name|this
operator|.
name|values
operator|=
name|values
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|Leaf
name|Leaf
parameter_list|()
block|{
name|this
argument_list|(
operator|(
name|K
index|[]
operator|)
name|EMPTY_ARRAY
argument_list|,
operator|(
name|V
index|[]
operator|)
name|EMPTY_ARRAY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|keys
operator|.
name|length
operator|==
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|visit
name|void
name|visit
parameter_list|(
name|Deque
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|,
name|Deque
argument_list|<
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|entries
operator|.
name|add
argument_list|(
operator|new
name|AbstractMap
operator|.
name|SimpleImmutableEntry
argument_list|<>
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|values
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|get
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|values
index|[
name|i
index|]
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|replace
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|replace
parameter_list|(
name|T
index|[]
name|array
parameter_list|,
name|int
name|index
parameter_list|,
name|T
name|value
parameter_list|)
block|{
specifier|final
name|T
index|[]
name|copy
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|array
argument_list|,
name|array
operator|.
name|length
argument_list|)
decl_stmt|;
name|copy
index|[
name|index
index|]
operator|=
name|value
expr_stmt|;
return|return
name|copy
return|;
block|}
annotation|@
name|Override
DECL|method|put
name|Leaf
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|int
name|hashBits
parameter_list|,
name|V
name|value
parameter_list|,
name|MutableValueInt
name|newValue
parameter_list|)
block|{
assert|assert
name|hashBits
operator|<=
literal|0
operator|:
name|hashBits
assert|;
name|int
name|slot
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
specifier|final
name|K
index|[]
name|keys2
decl_stmt|;
specifier|final
name|V
index|[]
name|values2
decl_stmt|;
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
name|keys2
operator|=
name|appendElement
argument_list|(
name|keys
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|values2
operator|=
name|appendElement
argument_list|(
name|values
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|newValue
operator|.
name|value
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|keys2
operator|=
name|replace
argument_list|(
name|keys
argument_list|,
name|slot
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|values2
operator|=
name|replace
argument_list|(
name|values
argument_list|,
name|slot
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Leaf
argument_list|<>
argument_list|(
name|keys2
argument_list|,
name|values2
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove
name|Leaf
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
name|int
name|slot
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|key
operator|.
name|equals
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|K
index|[]
name|keys2
init|=
name|removeArrayElement
argument_list|(
name|keys
argument_list|,
name|slot
argument_list|)
decl_stmt|;
specifier|final
name|V
index|[]
name|values2
init|=
name|removeArrayElement
argument_list|(
name|values
argument_list|,
name|slot
argument_list|)
decl_stmt|;
return|return
operator|new
name|Leaf
argument_list|<>
argument_list|(
name|keys2
argument_list|,
name|values2
argument_list|)
return|;
block|}
block|}
DECL|method|removeArrayElement
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|removeArrayElement
parameter_list|(
name|T
index|[]
name|array
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|final
name|Object
name|result
init|=
name|Array
operator|.
name|newInstance
argument_list|(
name|array
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|array
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|array
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|result
argument_list|,
name|index
argument_list|,
name|array
operator|.
name|length
operator|-
name|index
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|T
index|[]
operator|)
name|result
return|;
block|}
DECL|method|appendElement
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|appendElement
parameter_list|(
specifier|final
name|T
index|[]
name|array
parameter_list|,
specifier|final
name|T
name|element
parameter_list|)
block|{
specifier|final
name|T
index|[]
name|newArray
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|array
argument_list|,
name|array
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|newArray
index|[
name|newArray
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|element
expr_stmt|;
return|return
name|newArray
return|;
block|}
DECL|method|insertElement
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|insertElement
parameter_list|(
specifier|final
name|T
index|[]
name|array
parameter_list|,
specifier|final
name|T
name|element
parameter_list|,
specifier|final
name|int
name|index
parameter_list|)
block|{
specifier|final
name|T
index|[]
name|result
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|array
argument_list|,
name|array
operator|.
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|result
index|[
name|index
index|]
operator|=
name|element
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|array
operator|.
name|length
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
name|index
argument_list|,
name|result
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|array
operator|.
name|length
operator|-
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * An inner node in this trie. Inner nodes store up to 64 key-value pairs      * and use a bitmap in order to associate hashes to them. For example, if      * an inner node contains 5 values, then 5 bits will be set in the bitmap      * and the ordinal of the bit set in this bit map will be the slot number.      *      * As a consequence, the number of slots in an inner node is equal to the      * number of one bits in the bitmap.      */
DECL|class|InnerNode
specifier|private
specifier|static
class|class
name|InnerNode
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|mask
specifier|private
specifier|final
name|long
name|mask
decl_stmt|;
comment|// the bitmap
DECL|field|keys
specifier|private
specifier|final
name|K
index|[]
name|keys
decl_stmt|;
DECL|field|subNodes
specifier|final
name|Object
index|[]
name|subNodes
decl_stmt|;
comment|// subNodes[slot] is either a value or a sub node in case of a hash collision
DECL|method|InnerNode
name|InnerNode
parameter_list|(
name|long
name|mask
parameter_list|,
name|K
index|[]
name|keys
parameter_list|,
name|Object
index|[]
name|subNodes
parameter_list|)
block|{
name|this
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|this
operator|.
name|keys
operator|=
name|keys
expr_stmt|;
name|this
operator|.
name|subNodes
operator|=
name|subNodes
expr_stmt|;
assert|assert
name|consistent
argument_list|()
assert|;
block|}
comment|// only used in assert
DECL|method|consistent
specifier|private
name|boolean
name|consistent
parameter_list|()
block|{
assert|assert
name|Long
operator|.
name|bitCount
argument_list|(
name|mask
argument_list|)
operator|==
name|keys
operator|.
name|length
assert|;
assert|assert
name|Long
operator|.
name|bitCount
argument_list|(
name|mask
argument_list|)
operator|==
name|subNodes
operator|.
name|length
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|subNodes
index|[
name|i
index|]
operator|instanceof
name|Node
condition|)
block|{
assert|assert
name|keys
index|[
name|i
index|]
operator|==
literal|null
assert|;
block|}
else|else
block|{
assert|assert
name|keys
index|[
name|i
index|]
operator|!=
literal|null
assert|;
block|}
block|}
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|mask
operator|==
literal|0
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|InnerNode
name|InnerNode
parameter_list|()
block|{
name|this
argument_list|(
literal|0
argument_list|,
operator|(
name|K
index|[]
operator|)
name|EMPTY_ARRAY
argument_list|,
name|EMPTY_ARRAY
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|visit
name|void
name|visit
parameter_list|(
name|Deque
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
parameter_list|,
name|Deque
argument_list|<
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|nodes
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|keys
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
specifier|final
name|Object
name|sub
init|=
name|subNodes
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|sub
operator|instanceof
name|Node
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subNode
init|=
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|sub
decl_stmt|;
assert|assert
name|keys
index|[
name|i
index|]
operator|==
literal|null
assert|;
name|nodes
operator|.
name|add
argument_list|(
name|subNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|V
name|value
init|=
operator|(
name|V
operator|)
name|sub
decl_stmt|;
name|entries
operator|.
name|add
argument_list|(
operator|new
name|AbstractMap
operator|.
name|SimpleImmutableEntry
argument_list|<>
argument_list|(
name|keys
index|[
name|i
index|]
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * For a given hash on 6 bits, its value is set if the bitmap has a one          * at the corresponding index.          */
DECL|method|exists
specifier|private
name|boolean
name|exists
parameter_list|(
name|int
name|hash6
parameter_list|)
block|{
return|return
operator|(
name|mask
operator|&
operator|(
literal|1L
operator|<<
name|hash6
operator|)
operator|)
operator|!=
literal|0
return|;
block|}
comment|/**          * For a given hash on 6 bits, the slot number is the number of one          * bits on the right of the<code>hash6</code>-th bit.          */
DECL|method|slot
specifier|private
name|int
name|slot
parameter_list|(
name|int
name|hash6
parameter_list|)
block|{
return|return
name|Long
operator|.
name|bitCount
argument_list|(
name|mask
operator|&
operator|(
operator|(
literal|1L
operator|<<
name|hash6
operator|)
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|get
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
specifier|final
name|int
name|hash6
init|=
name|hash
operator|&
name|HASH_MASK
decl_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|hash6
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|int
name|slot
init|=
name|slot
argument_list|(
name|hash6
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|sub
init|=
name|subNodes
index|[
name|slot
index|]
decl_stmt|;
assert|assert
name|sub
operator|!=
literal|null
assert|;
if|if
condition|(
name|sub
operator|instanceof
name|Node
condition|)
block|{
assert|assert
name|keys
index|[
name|slot
index|]
operator|==
literal|null
assert|;
comment|// keys don't make sense on inner nodes
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subNode
init|=
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|sub
decl_stmt|;
return|return
name|subNode
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
operator|>>>
name|HASH_BITS
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|keys
index|[
name|slot
index|]
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|V
name|v
init|=
operator|(
name|V
operator|)
name|sub
decl_stmt|;
return|return
name|v
return|;
block|}
else|else
block|{
comment|// we have an entry for this hash, but the value is different
return|return
literal|null
return|;
block|}
block|}
block|}
DECL|method|newSubNode
specifier|private
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newSubNode
parameter_list|(
name|int
name|hashBits
parameter_list|)
block|{
if|if
condition|(
name|hashBits
operator|<=
literal|0
condition|)
block|{
return|return
operator|new
name|Leaf
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
return|;
block|}
block|}
DECL|method|putExisting
specifier|private
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|putExisting
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|int
name|hashBits
parameter_list|,
name|int
name|slot
parameter_list|,
name|V
name|value
parameter_list|,
name|MutableValueInt
name|newValue
parameter_list|)
block|{
specifier|final
name|K
index|[]
name|keys2
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|keys
argument_list|,
name|keys
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|Object
index|[]
name|subNodes2
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|subNodes
argument_list|,
name|subNodes
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|previousValue
init|=
name|subNodes2
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|previousValue
operator|instanceof
name|Node
condition|)
block|{
comment|// insert recursively
assert|assert
name|keys
index|[
name|slot
index|]
operator|==
literal|null
assert|;
name|subNodes2
index|[
name|slot
index|]
operator|=
operator|(
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|previousValue
operator|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|hashBits
argument_list|,
name|value
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keys
index|[
name|slot
index|]
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// replace the existing entry
name|subNodes2
index|[
name|slot
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
comment|// hash collision
specifier|final
name|K
name|previousKey
init|=
name|keys
index|[
name|slot
index|]
decl_stmt|;
specifier|final
name|int
name|previousHash
init|=
name|previousKey
operator|.
name|hashCode
argument_list|()
operator|>>>
operator|(
name|TOTAL_HASH_BITS
operator|-
name|hashBits
operator|)
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subNode
init|=
name|newSubNode
argument_list|(
name|hashBits
argument_list|)
decl_stmt|;
name|subNode
operator|=
name|subNode
operator|.
name|put
argument_list|(
name|previousKey
argument_list|,
name|previousHash
argument_list|,
name|hashBits
argument_list|,
operator|(
name|V
operator|)
name|previousValue
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|subNode
operator|=
name|subNode
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|hashBits
argument_list|,
name|value
argument_list|,
name|newValue
argument_list|)
expr_stmt|;
name|keys2
index|[
name|slot
index|]
operator|=
literal|null
expr_stmt|;
name|subNodes2
index|[
name|slot
index|]
operator|=
name|subNode
expr_stmt|;
block|}
return|return
operator|new
name|InnerNode
argument_list|<>
argument_list|(
name|mask
argument_list|,
name|keys2
argument_list|,
name|subNodes2
argument_list|)
return|;
block|}
DECL|method|putNew
specifier|private
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|putNew
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash6
parameter_list|,
name|int
name|slot
parameter_list|,
name|V
name|value
parameter_list|)
block|{
specifier|final
name|long
name|mask2
init|=
name|mask
operator||
operator|(
literal|1L
operator|<<
name|hash6
operator|)
decl_stmt|;
specifier|final
name|K
index|[]
name|keys2
init|=
name|insertElement
argument_list|(
name|keys
argument_list|,
name|key
argument_list|,
name|slot
argument_list|)
decl_stmt|;
specifier|final
name|Object
index|[]
name|subNodes2
init|=
name|insertElement
argument_list|(
name|subNodes
argument_list|,
name|value
argument_list|,
name|slot
argument_list|)
decl_stmt|;
return|return
operator|new
name|InnerNode
argument_list|<>
argument_list|(
name|mask2
argument_list|,
name|keys2
argument_list|,
name|subNodes2
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|put
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|int
name|hashBits
parameter_list|,
name|V
name|value
parameter_list|,
name|MutableValueInt
name|newValue
parameter_list|)
block|{
specifier|final
name|int
name|hash6
init|=
name|hash
operator|&
name|HASH_MASK
decl_stmt|;
specifier|final
name|int
name|slot
init|=
name|slot
argument_list|(
name|hash6
argument_list|)
decl_stmt|;
if|if
condition|(
name|exists
argument_list|(
name|hash6
argument_list|)
condition|)
block|{
name|hash
operator|>>>=
name|HASH_BITS
expr_stmt|;
name|hashBits
operator|-=
name|HASH_BITS
expr_stmt|;
return|return
name|putExisting
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|hashBits
argument_list|,
name|slot
argument_list|,
name|value
argument_list|,
name|newValue
argument_list|)
return|;
block|}
else|else
block|{
name|newValue
operator|.
name|value
operator|=
literal|1
expr_stmt|;
return|return
name|putNew
argument_list|(
name|key
argument_list|,
name|hash6
argument_list|,
name|slot
argument_list|,
name|value
argument_list|)
return|;
block|}
block|}
DECL|method|removeSlot
specifier|private
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removeSlot
parameter_list|(
name|int
name|hash6
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
specifier|final
name|long
name|mask2
init|=
name|mask
operator|&
operator|~
operator|(
literal|1L
operator|<<
name|hash6
operator|)
decl_stmt|;
specifier|final
name|K
index|[]
name|keys2
init|=
name|removeArrayElement
argument_list|(
name|keys
argument_list|,
name|slot
argument_list|)
decl_stmt|;
specifier|final
name|Object
index|[]
name|subNodes2
init|=
name|removeArrayElement
argument_list|(
name|subNodes
argument_list|,
name|slot
argument_list|)
decl_stmt|;
return|return
operator|new
name|InnerNode
argument_list|<>
argument_list|(
name|mask2
argument_list|,
name|keys2
argument_list|,
name|subNodes2
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
specifier|final
name|int
name|hash6
init|=
name|hash
operator|&
name|HASH_MASK
decl_stmt|;
if|if
condition|(
operator|!
name|exists
argument_list|(
name|hash6
argument_list|)
condition|)
block|{
return|return
name|this
return|;
block|}
specifier|final
name|int
name|slot
init|=
name|slot
argument_list|(
name|hash6
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|previousValue
init|=
name|subNodes
index|[
name|slot
index|]
decl_stmt|;
if|if
condition|(
name|previousValue
operator|instanceof
name|Node
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|subNode
init|=
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|previousValue
decl_stmt|;
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|removed
init|=
name|subNode
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
operator|>>>
name|HASH_BITS
argument_list|)
decl_stmt|;
if|if
condition|(
name|removed
operator|==
name|subNode
condition|)
block|{
comment|// not in sub-nodes
return|return
name|this
return|;
block|}
if|if
condition|(
name|removed
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|removeSlot
argument_list|(
name|hash6
argument_list|,
name|slot
argument_list|)
return|;
block|}
specifier|final
name|K
index|[]
name|keys2
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|keys
argument_list|,
name|keys
operator|.
name|length
argument_list|)
decl_stmt|;
specifier|final
name|Object
index|[]
name|subNodes2
init|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|subNodes
argument_list|,
name|subNodes
operator|.
name|length
argument_list|)
decl_stmt|;
name|subNodes2
index|[
name|slot
index|]
operator|=
name|removed
expr_stmt|;
return|return
operator|new
name|InnerNode
argument_list|<>
argument_list|(
name|mask
argument_list|,
name|keys2
argument_list|,
name|subNodes2
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|keys
index|[
name|slot
index|]
operator|.
name|equals
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// remove entry
return|return
name|removeSlot
argument_list|(
name|hash6
argument_list|,
name|slot
argument_list|)
return|;
block|}
else|else
block|{
comment|// hash collision, nothing to remove
return|return
name|this
return|;
block|}
block|}
block|}
DECL|class|EntryIterator
specifier|private
specifier|static
class|class
name|EntryIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|entries
specifier|private
specifier|final
name|Deque
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entries
decl_stmt|;
DECL|field|nodes
specifier|private
specifier|final
name|Deque
argument_list|<
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|nodes
decl_stmt|;
DECL|method|EntryIterator
specifier|public
name|EntryIterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|node
parameter_list|)
block|{
name|entries
operator|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
expr_stmt|;
name|nodes
operator|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
expr_stmt|;
name|node
operator|.
name|visit
argument_list|(
name|entries
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
operator|!
name|entries
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|next
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
while|while
condition|(
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextNode
init|=
name|nodes
operator|.
name|pop
argument_list|()
decl_stmt|;
name|nextNode
operator|.
name|visit
argument_list|(
name|entries
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
block|}
return|return
name|entries
operator|.
name|pop
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
specifier|final
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
DECL|field|root
specifier|private
specifier|final
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|root
decl_stmt|;
DECL|field|size
specifier|private
specifier|final
name|int
name|size
decl_stmt|;
comment|/**      * Create a new empty map.      */
DECL|method|CopyOnWriteHashMap
specifier|public
name|CopyOnWriteHashMap
parameter_list|()
block|{
name|this
argument_list|(
operator|new
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|CopyOnWriteHashMap
specifier|private
name|CopyOnWriteHashMap
parameter_list|(
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|root
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
comment|// works fine since null values are not supported
return|return
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|get
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"null keys are not supported"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|hash
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
return|return
name|root
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
assert|assert
name|size
operator|!=
literal|0
operator|||
name|root
operator|.
name|isEmpty
argument_list|()
assert|;
return|return
name|size
return|;
block|}
comment|/**      * Associate<code>key</code> with<code>value</code> and return a new copy      * of the hash table. The current hash table is not modified.      */
DECL|method|copyAndPut
specifier|public
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyAndPut
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"null keys are not supported"
argument_list|)
throw|;
block|}
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"null values are not supported"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|hash
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
specifier|final
name|MutableValueInt
name|newValue
init|=
operator|new
name|MutableValueInt
argument_list|()
decl_stmt|;
specifier|final
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newRoot
init|=
name|root
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|TOTAL_HASH_BITS
argument_list|,
name|value
argument_list|,
name|newValue
argument_list|)
decl_stmt|;
specifier|final
name|int
name|newSize
init|=
name|size
operator|+
name|newValue
operator|.
name|value
decl_stmt|;
return|return
operator|new
name|CopyOnWriteHashMap
argument_list|<>
argument_list|(
name|newRoot
argument_list|,
name|newSize
argument_list|)
return|;
block|}
comment|/**      * Same as {@link #copyAndPut(Object, Object)} but for an arbitrary number of entries.      */
DECL|method|copyAndPutAll
specifier|public
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyAndPutAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|other
parameter_list|)
block|{
return|return
name|copyAndPutAll
argument_list|(
name|other
operator|.
name|entrySet
argument_list|()
argument_list|)
return|;
block|}
DECL|method|copyAndPutAll
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyAndPutAll
parameter_list|(
name|Iterable
argument_list|<
name|Entry
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
name|this
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
name|entry
range|:
name|entries
control|)
block|{
name|result
operator|=
name|result
operator|.
name|copyAndPut
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|copyAndPutAll
specifier|public
parameter_list|<
name|K1
extends|extends
name|K
parameter_list|,
name|V1
extends|extends
name|V
parameter_list|>
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyAndPutAll
parameter_list|(
name|Stream
argument_list|<
name|Entry
argument_list|<
name|K1
argument_list|,
name|V1
argument_list|>
argument_list|>
name|entries
parameter_list|)
block|{
return|return
name|copyAndPutAll
argument_list|(
name|entries
operator|::
name|iterator
argument_list|)
return|;
block|}
comment|/**      * Remove the given key from this map. The current hash table is not modified.      */
DECL|method|copyAndRemove
specifier|public
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyAndRemove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"null keys are not supported"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|hash
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
specifier|final
name|InnerNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newRoot
init|=
name|root
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|newRoot
condition|)
block|{
return|return
name|this
return|;
block|}
else|else
block|{
return|return
operator|new
name|CopyOnWriteHashMap
argument_list|<>
argument_list|(
name|newRoot
argument_list|,
name|size
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**      * Same as {@link #copyAndRemove(Object)} but for an arbitrary number of entries.      */
DECL|method|copyAndRemoveAll
specifier|public
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|copyAndRemoveAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|keys
parameter_list|)
block|{
name|CopyOnWriteHashMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
init|=
name|this
decl_stmt|;
for|for
control|(
name|Object
name|key
range|:
name|keys
control|)
block|{
name|result
operator|=
name|result
operator|.
name|copyAndRemove
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|entrySet
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|<>
argument_list|(
name|root
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
operator|||
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
init|=
operator|(
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|equals
argument_list|(
name|CopyOnWriteHashMap
operator|.
name|this
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|CopyOnWriteHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
end_class

end_unit

