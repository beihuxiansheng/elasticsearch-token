begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.settings
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|util
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|spell
operator|.
name|LevensteinDistance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CollectionUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|regex
operator|.
name|Regex
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|SortedMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/**  * A basic setting service that can be used for per-index and per-cluster settings.  * This service offers transactional application of updates settings.  */
end_comment

begin_class
DECL|class|AbstractScopedSettings
specifier|public
specifier|abstract
class|class
name|AbstractScopedSettings
extends|extends
name|AbstractComponent
block|{
DECL|field|ARCHIVED_SETTINGS_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|ARCHIVED_SETTINGS_PREFIX
init|=
literal|"archived."
decl_stmt|;
DECL|field|lastSettingsApplied
specifier|private
name|Settings
name|lastSettingsApplied
init|=
name|Settings
operator|.
name|EMPTY
decl_stmt|;
DECL|field|settingUpdaters
specifier|private
specifier|final
name|List
argument_list|<
name|SettingUpdater
argument_list|<
name|?
argument_list|>
argument_list|>
name|settingUpdaters
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|complexMatchers
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|complexMatchers
decl_stmt|;
DECL|field|keySettings
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|keySettings
decl_stmt|;
DECL|field|scope
specifier|private
specifier|final
name|Setting
operator|.
name|Property
name|scope
decl_stmt|;
DECL|field|KEY_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|KEY_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:[-\\w]+[.])*[-\\w]+$"
argument_list|)
decl_stmt|;
DECL|field|GROUP_KEY_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|GROUP_KEY_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:[-\\w]+[.])+$"
argument_list|)
decl_stmt|;
DECL|field|AFFIX_KEY_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|AFFIX_KEY_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:[-\\w]+[.])+(?:[*][.])+[-\\w]+$"
argument_list|)
decl_stmt|;
DECL|method|AbstractScopedSettings
specifier|protected
name|AbstractScopedSettings
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|Set
argument_list|<
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|settingsSet
parameter_list|,
name|Setting
operator|.
name|Property
name|scope
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastSettingsApplied
operator|=
name|Settings
operator|.
name|EMPTY
expr_stmt|;
name|this
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|complexMatchers
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|keySettings
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Setting
argument_list|<
name|?
argument_list|>
name|setting
range|:
name|settingsSet
control|)
block|{
if|if
condition|(
name|setting
operator|.
name|getProperties
argument_list|()
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Setting must be a "
operator|+
name|scope
operator|+
literal|" setting but has: "
operator|+
name|setting
operator|.
name|getProperties
argument_list|()
argument_list|)
throw|;
block|}
name|validateSettingKey
argument_list|(
name|setting
argument_list|)
expr_stmt|;
if|if
condition|(
name|setting
operator|.
name|hasComplexMatcher
argument_list|()
condition|)
block|{
name|Setting
argument_list|<
name|?
argument_list|>
name|overlappingSetting
init|=
name|findOverlappingSetting
argument_list|(
name|setting
argument_list|,
name|complexMatchers
argument_list|)
decl_stmt|;
if|if
condition|(
name|overlappingSetting
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"complex setting key: ["
operator|+
name|setting
operator|.
name|getKey
argument_list|()
operator|+
literal|"] overlaps existing setting key: ["
operator|+
name|overlappingSetting
operator|.
name|getKey
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|complexMatchers
operator|.
name|putIfAbsent
argument_list|(
name|setting
operator|.
name|getKey
argument_list|()
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|keySettings
operator|.
name|putIfAbsent
argument_list|(
name|setting
operator|.
name|getKey
argument_list|()
argument_list|,
name|setting
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|complexMatchers
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|complexMatchers
argument_list|)
expr_stmt|;
name|this
operator|.
name|keySettings
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|keySettings
argument_list|)
expr_stmt|;
block|}
DECL|method|validateSettingKey
specifier|protected
name|void
name|validateSettingKey
parameter_list|(
name|Setting
name|setting
parameter_list|)
block|{
if|if
condition|(
name|isValidKey
argument_list|(
name|setting
operator|.
name|getKey
argument_list|()
argument_list|)
operator|==
literal|false
operator|&&
operator|(
name|setting
operator|.
name|isGroupSetting
argument_list|()
operator|&&
name|isValidGroupKey
argument_list|(
name|setting
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|isValidAffixKey
argument_list|(
name|setting
operator|.
name|getKey
argument_list|()
argument_list|)
operator|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"illegal settings key: ["
operator|+
name|setting
operator|.
name|getKey
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
DECL|method|AbstractScopedSettings
specifier|protected
name|AbstractScopedSettings
parameter_list|(
name|Settings
name|nodeSettings
parameter_list|,
name|Settings
name|scopeSettings
parameter_list|,
name|AbstractScopedSettings
name|other
parameter_list|)
block|{
name|super
argument_list|(
name|nodeSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|lastSettingsApplied
operator|=
name|scopeSettings
expr_stmt|;
name|this
operator|.
name|scope
operator|=
name|other
operator|.
name|scope
expr_stmt|;
name|complexMatchers
operator|=
name|other
operator|.
name|complexMatchers
expr_stmt|;
name|keySettings
operator|=
name|other
operator|.
name|keySettings
expr_stmt|;
name|settingUpdaters
operator|.
name|addAll
argument_list|(
name|other
operator|.
name|settingUpdaters
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<code>true</code> iff the given key is a valid settings key otherwise<code>false</code>      */
DECL|method|isValidKey
specifier|public
specifier|static
name|boolean
name|isValidKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|KEY_PATTERN
operator|.
name|matcher
argument_list|(
name|key
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
DECL|method|isValidGroupKey
specifier|private
specifier|static
name|boolean
name|isValidGroupKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|GROUP_KEY_PATTERN
operator|.
name|matcher
argument_list|(
name|key
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
DECL|method|isValidAffixKey
specifier|private
specifier|static
name|boolean
name|isValidAffixKey
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
name|AFFIX_KEY_PATTERN
operator|.
name|matcher
argument_list|(
name|key
argument_list|)
operator|.
name|matches
argument_list|()
return|;
block|}
DECL|method|getScope
specifier|public
name|Setting
operator|.
name|Property
name|getScope
parameter_list|()
block|{
return|return
name|this
operator|.
name|scope
return|;
block|}
comment|/**      * Validates the given settings by running it through all update listeners without applying it. This      * method will not change any settings but will fail if any of the settings can't be applied.      */
DECL|method|validateUpdate
specifier|public
specifier|synchronized
name|Settings
name|validateUpdate
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
specifier|final
name|Settings
name|current
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|this
operator|.
name|settings
argument_list|)
operator|.
name|put
argument_list|(
name|settings
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Settings
name|previous
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|this
operator|.
name|settings
argument_list|)
operator|.
name|put
argument_list|(
name|this
operator|.
name|lastSettingsApplied
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|RuntimeException
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SettingUpdater
argument_list|<
name|?
argument_list|>
name|settingUpdater
range|:
name|settingUpdaters
control|)
block|{
try|try
block|{
comment|// ensure running this through the updater / dynamic validator
comment|// don't check if the value has changed we wanna test this anyways
name|settingUpdater
operator|.
name|getValue
argument_list|(
name|current
argument_list|,
name|previous
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|ex
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to prepareCommit settings for [{}]"
argument_list|,
name|settingUpdater
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|// here we are exhaustive and record all settings that failed.
name|ExceptionsHelper
operator|.
name|rethrowAndSuppress
argument_list|(
name|exceptions
argument_list|)
expr_stmt|;
return|return
name|current
return|;
block|}
comment|/**      * Applies the given settings to all the settings consumers or to none of them. The settings      * will be merged with the node settings before they are applied while given settings override existing node      * settings.      * @param newSettings the settings to apply      * @return the unmerged applied settings     */
DECL|method|applySettings
specifier|public
specifier|synchronized
name|Settings
name|applySettings
parameter_list|(
name|Settings
name|newSettings
parameter_list|)
block|{
if|if
condition|(
name|lastSettingsApplied
operator|!=
literal|null
operator|&&
name|newSettings
operator|.
name|equals
argument_list|(
name|lastSettingsApplied
argument_list|)
condition|)
block|{
comment|// nothing changed in the settings, ignore
return|return
name|newSettings
return|;
block|}
specifier|final
name|Settings
name|current
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|this
operator|.
name|settings
argument_list|)
operator|.
name|put
argument_list|(
name|newSettings
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
specifier|final
name|Settings
name|previous
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|this
operator|.
name|settings
argument_list|)
operator|.
name|put
argument_list|(
name|this
operator|.
name|lastSettingsApplied
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
try|try
block|{
name|List
argument_list|<
name|Runnable
argument_list|>
name|applyRunnables
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SettingUpdater
argument_list|<
name|?
argument_list|>
name|settingUpdater
range|:
name|settingUpdaters
control|)
block|{
try|try
block|{
name|applyRunnables
operator|.
name|add
argument_list|(
name|settingUpdater
operator|.
name|updater
argument_list|(
name|current
argument_list|,
name|previous
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to prepareCommit settings for [{}]"
argument_list|,
name|settingUpdater
argument_list|)
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
block|}
for|for
control|(
name|Runnable
name|settingUpdater
range|:
name|applyRunnables
control|)
block|{
name|settingUpdater
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to apply settings"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
finally|finally
block|{         }
return|return
name|lastSettingsApplied
operator|=
name|newSettings
return|;
block|}
comment|/**      * Adds a settings consumer with a predicate that is only evaluated at update time.      *<p>      * Note: Only settings registered in {@link SettingsModule} can be changed dynamically.      *</p>      * @param validator an additional validator that is only applied to updates of this setting.      *                  This is useful to add additional validation to settings at runtime compared to at startup time.      */
DECL|method|addSettingsUpdateConsumer
specifier|public
specifier|synchronized
parameter_list|<
name|T
parameter_list|>
name|void
name|addSettingsUpdateConsumer
parameter_list|(
name|Setting
argument_list|<
name|T
argument_list|>
name|setting
parameter_list|,
name|Consumer
argument_list|<
name|T
argument_list|>
name|consumer
parameter_list|,
name|Consumer
argument_list|<
name|T
argument_list|>
name|validator
parameter_list|)
block|{
if|if
condition|(
name|setting
operator|!=
name|get
argument_list|(
name|setting
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Setting is not registered for key ["
operator|+
name|setting
operator|.
name|getKey
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|addSettingsUpdater
argument_list|(
name|setting
operator|.
name|newUpdater
argument_list|(
name|consumer
argument_list|,
name|logger
argument_list|,
name|validator
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addSettingsUpdater
specifier|synchronized
name|void
name|addSettingsUpdater
parameter_list|(
name|SettingUpdater
argument_list|<
name|?
argument_list|>
name|updater
parameter_list|)
block|{
name|this
operator|.
name|settingUpdaters
operator|.
name|add
argument_list|(
name|updater
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a settings consumer that accepts the values for two settings. The consumer if only notified if one or both settings change.      *<p>      * Note: Only settings registered in {@link SettingsModule} can be changed dynamically.      *</p>      * This method registers a compound updater that is useful if two settings are depending on each other. The consumer is always provided      * with both values even if only one of the two changes.      */
DECL|method|addSettingsUpdateConsumer
specifier|public
specifier|synchronized
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
name|void
name|addSettingsUpdateConsumer
parameter_list|(
name|Setting
argument_list|<
name|A
argument_list|>
name|a
parameter_list|,
name|Setting
argument_list|<
name|B
argument_list|>
name|b
parameter_list|,
name|BiConsumer
argument_list|<
name|A
argument_list|,
name|B
argument_list|>
name|consumer
parameter_list|)
block|{
if|if
condition|(
name|a
operator|!=
name|get
argument_list|(
name|a
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Setting is not registered for key ["
operator|+
name|a
operator|.
name|getKey
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|b
operator|!=
name|get
argument_list|(
name|b
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Setting is not registered for key ["
operator|+
name|b
operator|.
name|getKey
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|addSettingsUpdater
argument_list|(
name|Setting
operator|.
name|compoundUpdater
argument_list|(
name|consumer
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|logger
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a settings consumer.      *<p>      * Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically.      *</p>      */
DECL|method|addSettingsUpdateConsumer
specifier|public
specifier|synchronized
parameter_list|<
name|T
parameter_list|>
name|void
name|addSettingsUpdateConsumer
parameter_list|(
name|Setting
argument_list|<
name|T
argument_list|>
name|setting
parameter_list|,
name|Consumer
argument_list|<
name|T
argument_list|>
name|consumer
parameter_list|)
block|{
name|addSettingsUpdateConsumer
argument_list|(
name|setting
argument_list|,
name|consumer
argument_list|,
parameter_list|(
name|s
parameter_list|)
lambda|->
block|{}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates that all settings in the builder are registered and valid      */
DECL|method|validate
specifier|public
specifier|final
name|void
name|validate
parameter_list|(
name|Settings
operator|.
name|Builder
name|settingsBuilder
parameter_list|)
block|{
name|validate
argument_list|(
name|settingsBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * * Validates that all given settings are registered and valid      */
DECL|method|validate
specifier|public
specifier|final
name|void
name|validate
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|List
argument_list|<
name|RuntimeException
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// we want them sorted for deterministic error messages
name|SortedMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|sortedSettings
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|(
name|settings
operator|.
name|getAsMap
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|sortedSettings
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|validate
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|settings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|ex
parameter_list|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|ExceptionsHelper
operator|.
name|rethrowAndSuppress
argument_list|(
name|exceptions
argument_list|)
expr_stmt|;
block|}
comment|/**      * Validates that the setting is valid      */
DECL|method|validate
specifier|public
specifier|final
name|void
name|validate
parameter_list|(
name|String
name|key
parameter_list|,
name|Settings
name|settings
parameter_list|)
block|{
name|Setting
name|setting
init|=
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|setting
operator|==
literal|null
condition|)
block|{
name|LevensteinDistance
name|ld
init|=
operator|new
name|LevensteinDistance
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Tuple
argument_list|<
name|Float
argument_list|,
name|String
argument_list|>
argument_list|>
name|scoredKeys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|k
range|:
name|this
operator|.
name|keySettings
operator|.
name|keySet
argument_list|()
control|)
block|{
name|float
name|distance
init|=
name|ld
operator|.
name|getDistance
argument_list|(
name|key
argument_list|,
name|k
argument_list|)
decl_stmt|;
if|if
condition|(
name|distance
operator|>
literal|0.7f
condition|)
block|{
name|scoredKeys
operator|.
name|add
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|distance
argument_list|,
name|k
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|CollectionUtil
operator|.
name|timSort
argument_list|(
name|scoredKeys
argument_list|,
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
lambda|->
name|b
operator|.
name|v1
argument_list|()
operator|.
name|compareTo
argument_list|(
name|a
operator|.
name|v1
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|msg
init|=
literal|"unknown setting ["
operator|+
name|key
operator|+
literal|"]"
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|keys
init|=
name|scoredKeys
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
parameter_list|(
name|a
parameter_list|)
lambda|->
name|a
operator|.
name|v2
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|keys
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|msg
operator|+=
literal|" did you mean "
operator|+
operator|(
name|keys
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|?
literal|"["
operator|+
name|keys
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|+
literal|"]"
else|:
literal|"any of "
operator|+
name|keys
operator|.
name|toString
argument_list|()
operator|)
operator|+
literal|"?"
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|+=
literal|" please check that any required plugins are installed, or check the breaking changes documentation for removed "
operator|+
literal|"settings"
expr_stmt|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
name|setting
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
block|}
comment|/**      * Transactional interface to update settings.      * @see Setting      * @param<T> the type of the value of the setting      */
DECL|interface|SettingUpdater
specifier|public
interface|interface
name|SettingUpdater
parameter_list|<
name|T
parameter_list|>
block|{
comment|/**          * Returns true if this updaters setting has changed with the current update          * @param current the current settings          * @param previous the previous setting          * @return true if this updaters setting has changed with the current update          */
DECL|method|hasChanged
name|boolean
name|hasChanged
parameter_list|(
name|Settings
name|current
parameter_list|,
name|Settings
name|previous
parameter_list|)
function_decl|;
comment|/**          * Returns the instance value for the current settings. This method is stateless and idempotent.          * This method will throw an exception if the source of this value is invalid.          */
DECL|method|getValue
name|T
name|getValue
parameter_list|(
name|Settings
name|current
parameter_list|,
name|Settings
name|previous
parameter_list|)
function_decl|;
comment|/**          * Applies the given value to the updater. This methods will actually run the update.          */
DECL|method|apply
name|void
name|apply
parameter_list|(
name|T
name|value
parameter_list|,
name|Settings
name|current
parameter_list|,
name|Settings
name|previous
parameter_list|)
function_decl|;
comment|/**          * Updates this updaters value if it has changed.          * @return<code>true</code> iff the value has been updated.          */
DECL|method|apply
specifier|default
name|boolean
name|apply
parameter_list|(
name|Settings
name|current
parameter_list|,
name|Settings
name|previous
parameter_list|)
block|{
if|if
condition|(
name|hasChanged
argument_list|(
name|current
argument_list|,
name|previous
argument_list|)
condition|)
block|{
name|T
name|value
init|=
name|getValue
argument_list|(
name|current
argument_list|,
name|previous
argument_list|)
decl_stmt|;
name|apply
argument_list|(
name|value
argument_list|,
name|current
argument_list|,
name|previous
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings          * actually changed. This allows to defer the update to a later point in time while keeping type safety.          * If the value didn't change the returned runnable is a noop.          */
DECL|method|updater
specifier|default
name|Runnable
name|updater
parameter_list|(
name|Settings
name|current
parameter_list|,
name|Settings
name|previous
parameter_list|)
block|{
if|if
condition|(
name|hasChanged
argument_list|(
name|current
argument_list|,
name|previous
argument_list|)
condition|)
block|{
name|T
name|value
init|=
name|getValue
argument_list|(
name|current
argument_list|,
name|previous
argument_list|)
decl_stmt|;
return|return
parameter_list|()
lambda|->
block|{
name|apply
argument_list|(
name|value
argument_list|,
name|current
argument_list|,
name|previous
argument_list|)
expr_stmt|;
block|}
return|;
block|}
return|return
parameter_list|()
lambda|->
block|{}
return|;
block|}
block|}
comment|/**      * Returns the {@link Setting} for the given key or<code>null</code> if the setting can not be found.      */
DECL|method|get
specifier|public
name|Setting
argument_list|<
name|?
argument_list|>
name|get
parameter_list|(
name|String
name|key
parameter_list|)
block|{
name|Setting
argument_list|<
name|?
argument_list|>
name|setting
init|=
name|keySettings
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|setting
operator|!=
literal|null
condition|)
block|{
return|return
name|setting
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|complexMatchers
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|match
argument_list|(
name|key
argument_list|)
condition|)
block|{
assert|assert
name|assertMatcher
argument_list|(
name|key
argument_list|,
literal|1
argument_list|)
assert|;
return|return
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getConcreteSetting
argument_list|(
name|key
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|assertMatcher
specifier|private
name|boolean
name|assertMatcher
parameter_list|(
name|String
name|key
parameter_list|,
name|int
name|numComplexMatchers
parameter_list|)
block|{
name|List
argument_list|<
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|entry
range|:
name|complexMatchers
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|match
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getConcreteSetting
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
assert|assert
name|list
operator|.
name|size
argument_list|()
operator|==
name|numComplexMatchers
operator|:
literal|"Expected "
operator|+
name|numComplexMatchers
operator|+
literal|" complex matchers to match key ["
operator|+
name|key
operator|+
literal|"] but got: "
operator|+
name|list
operator|.
name|toString
argument_list|()
assert|;
return|return
literal|true
return|;
block|}
comment|/**      * Returns<code>true</code> if the setting for the given key is dynamically updateable. Otherwise<code>false</code>.      */
DECL|method|hasDynamicSetting
specifier|public
name|boolean
name|hasDynamicSetting
parameter_list|(
name|String
name|key
parameter_list|)
block|{
specifier|final
name|Setting
argument_list|<
name|?
argument_list|>
name|setting
init|=
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|setting
operator|!=
literal|null
operator|&&
name|setting
operator|.
name|isDynamic
argument_list|()
return|;
block|}
comment|/**      * Returns a settings object that contains all settings that are not      * already set in the given source. The diff contains either the default value for each      * setting or the settings value in the given default settings.      */
DECL|method|diff
specifier|public
name|Settings
name|diff
parameter_list|(
name|Settings
name|source
parameter_list|,
name|Settings
name|defaultSettings
parameter_list|)
block|{
name|Settings
operator|.
name|Builder
name|builder
init|=
name|Settings
operator|.
name|builder
argument_list|()
decl_stmt|;
for|for
control|(
name|Setting
argument_list|<
name|?
argument_list|>
name|setting
range|:
name|keySettings
operator|.
name|values
argument_list|()
control|)
block|{
name|setting
operator|.
name|diff
argument_list|(
name|builder
argument_list|,
name|source
argument_list|,
name|defaultSettings
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Setting
argument_list|<
name|?
argument_list|>
name|setting
range|:
name|complexMatchers
operator|.
name|values
argument_list|()
control|)
block|{
name|setting
operator|.
name|diff
argument_list|(
name|builder
argument_list|,
name|source
argument_list|,
name|defaultSettings
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Returns the value for the given setting.      */
DECL|method|get
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|get
parameter_list|(
name|Setting
argument_list|<
name|T
argument_list|>
name|setting
parameter_list|)
block|{
if|if
condition|(
name|setting
operator|.
name|getProperties
argument_list|()
operator|.
name|contains
argument_list|(
name|scope
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"settings scope doesn't match the setting scope ["
operator|+
name|this
operator|.
name|scope
operator|+
literal|"] not in ["
operator|+
name|setting
operator|.
name|getProperties
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|get
argument_list|(
name|setting
operator|.
name|getKey
argument_list|()
argument_list|)
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"setting "
operator|+
name|setting
operator|.
name|getKey
argument_list|()
operator|+
literal|" has not been registered"
argument_list|)
throw|;
block|}
return|return
name|setting
operator|.
name|get
argument_list|(
name|this
operator|.
name|lastSettingsApplied
argument_list|,
name|settings
argument_list|)
return|;
block|}
comment|/**      * Updates a target settings builder with new, updated or deleted settings from a given settings builder.      *<p>      * Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an      * {@link IllegalArgumentException} is thrown instead.      *</p>      *      * @param toApply the new settings to apply      * @param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be      *        removed from this builder      * @param updates a settings builder that holds all updates applied to target      * @param type a free text string to allow better exceptions messages      * @return<code>true</code> if the target has changed otherwise<code>false</code>      */
DECL|method|updateDynamicSettings
specifier|public
name|boolean
name|updateDynamicSettings
parameter_list|(
name|Settings
name|toApply
parameter_list|,
name|Settings
operator|.
name|Builder
name|target
parameter_list|,
name|Settings
operator|.
name|Builder
name|updates
parameter_list|,
name|String
name|type
parameter_list|)
block|{
return|return
name|updateSettings
argument_list|(
name|toApply
argument_list|,
name|target
argument_list|,
name|updates
argument_list|,
name|type
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Updates a target settings builder with new, updated or deleted settings from a given settings builder.      *      * @param toApply the new settings to apply      * @param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be      *        removed from this builder      * @param updates a settings builder that holds all updates applied to target      * @param type a free text string to allow better exceptions messages      * @return<code>true</code> if the target has changed otherwise<code>false</code>      */
DECL|method|updateSettings
specifier|public
name|boolean
name|updateSettings
parameter_list|(
name|Settings
name|toApply
parameter_list|,
name|Settings
operator|.
name|Builder
name|target
parameter_list|,
name|Settings
operator|.
name|Builder
name|updates
parameter_list|,
name|String
name|type
parameter_list|)
block|{
return|return
name|updateSettings
argument_list|(
name|toApply
argument_list|,
name|target
argument_list|,
name|updates
argument_list|,
name|type
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Updates a target settings builder with new, updated or deleted settings from a given settings builder.      *      * @param toApply the new settings to apply      * @param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be      *        removed from this builder      * @param updates a settings builder that holds all updates applied to target      * @param type a free text string to allow better exceptions messages      * @param onlyDynamic if<code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to      *<code>true</code> and a non-dynamic setting is updated an exception is thrown.      * @return<code>true</code> if the target has changed otherwise<code>false</code>      */
DECL|method|updateSettings
specifier|private
name|boolean
name|updateSettings
parameter_list|(
name|Settings
name|toApply
parameter_list|,
name|Settings
operator|.
name|Builder
name|target
parameter_list|,
name|Settings
operator|.
name|Builder
name|updates
parameter_list|,
name|String
name|type
parameter_list|,
name|boolean
name|onlyDynamic
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|toRemove
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Settings
operator|.
name|Builder
name|settingsBuilder
init|=
name|Settings
operator|.
name|builder
argument_list|()
decl_stmt|;
specifier|final
name|Predicate
argument_list|<
name|String
argument_list|>
name|canUpdate
init|=
parameter_list|(
name|key
parameter_list|)
lambda|->
operator|(
name|onlyDynamic
operator|==
literal|false
operator|&&
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
operator|)
operator|||
name|hasDynamicSetting
argument_list|(
name|key
argument_list|)
decl_stmt|;
specifier|final
name|Predicate
argument_list|<
name|String
argument_list|>
name|canRemove
init|=
parameter_list|(
name|key
parameter_list|)
lambda|->
operator|(
comment|// we can delete if
name|onlyDynamic
operator|&&
name|hasDynamicSetting
argument_list|(
name|key
argument_list|)
comment|// it's a dynamicSetting and we only do dynamic settings
operator|||
name|get
argument_list|(
name|key
argument_list|)
operator|==
literal|null
operator|&&
name|key
operator|.
name|startsWith
argument_list|(
name|ARCHIVED_SETTINGS_PREFIX
argument_list|)
comment|// the setting is not registered AND it's been archived
operator|||
operator|(
name|onlyDynamic
operator|==
literal|false
operator|&&
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
operator|)
operator|)
decl_stmt|;
comment|// if it's not dynamic AND we have a key
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|toApply
operator|.
name|getAsMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|==
literal|null
operator|&&
operator|(
name|canRemove
operator|.
name|test
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"*"
argument_list|)
operator|)
condition|)
block|{
comment|// this either accepts null values that suffice the canUpdate test OR wildcard expressions (key ends with *)
comment|// we don't validate if there is any dynamic setting with that prefix yet we could do in the future
name|toRemove
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
comment|// we don't set changed here it's set after we apply deletes below if something actually changed
block|}
elseif|else
if|if
condition|(
name|entry
operator|.
name|getValue
argument_list|()
operator|!=
literal|null
operator|&&
name|canUpdate
operator|.
name|test
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|validate
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|toApply
argument_list|)
expr_stmt|;
name|settingsBuilder
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|updates
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|type
operator|+
literal|" setting ["
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"], not dynamically updateable"
argument_list|)
throw|;
block|}
block|}
name|changed
operator||=
name|applyDeletes
argument_list|(
name|toRemove
argument_list|,
name|target
argument_list|,
name|canRemove
argument_list|)
expr_stmt|;
name|target
operator|.
name|put
argument_list|(
name|settingsBuilder
operator|.
name|build
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
DECL|method|applyDeletes
specifier|private
specifier|static
name|boolean
name|applyDeletes
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|deletes
parameter_list|,
name|Settings
operator|.
name|Builder
name|builder
parameter_list|,
name|Predicate
argument_list|<
name|String
argument_list|>
name|canRemove
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|String
name|entry
range|:
name|deletes
control|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|keysToRemove
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|keySet
init|=
name|builder
operator|.
name|internalMap
argument_list|()
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|key
range|:
name|keySet
control|)
block|{
if|if
condition|(
name|Regex
operator|.
name|simpleMatch
argument_list|(
name|entry
argument_list|,
name|key
argument_list|)
operator|&&
name|canRemove
operator|.
name|test
argument_list|(
name|key
argument_list|)
condition|)
block|{
comment|// we have to re-check with canRemove here since we might have a wildcard expression foo.* that matches
comment|// dynamic as well as static settings if that is the case we might remove static settings since we resolve the
comment|// wildcards late
name|keysToRemove
operator|.
name|add
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|String
name|key
range|:
name|keysToRemove
control|)
block|{
name|builder
operator|.
name|remove
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
DECL|method|findOverlappingSetting
specifier|private
specifier|static
name|Setting
argument_list|<
name|?
argument_list|>
name|findOverlappingSetting
parameter_list|(
name|Setting
argument_list|<
name|?
argument_list|>
name|newSetting
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Setting
argument_list|<
name|?
argument_list|>
argument_list|>
name|complexMatchers
parameter_list|)
block|{
assert|assert
name|newSetting
operator|.
name|hasComplexMatcher
argument_list|()
assert|;
if|if
condition|(
name|complexMatchers
operator|.
name|containsKey
argument_list|(
name|newSetting
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
comment|// we return null here because we use a putIfAbsent call when inserting into the map, so if it exists then we already checked
comment|// the setting to make sure there are no overlapping settings.
return|return
literal|null
return|;
block|}
for|for
control|(
name|Setting
argument_list|<
name|?
argument_list|>
name|existingSetting
range|:
name|complexMatchers
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|newSetting
operator|.
name|match
argument_list|(
name|existingSetting
operator|.
name|getKey
argument_list|()
argument_list|)
operator|||
name|existingSetting
operator|.
name|match
argument_list|(
name|newSetting
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|existingSetting
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Archives invalid or unknown settings. Any setting that is not recognized or fails validation      * will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}      * and remains in the settings object. This can be used to detect invalid settings via APIs.      *      * @param settings        the {@link Settings} instance to scan for unknown or invalid settings      * @param unknownConsumer callback on unknown settings (consumer receives unknown key and its      *                        associated value)      * @param invalidConsumer callback on invalid settings (consumer receives invalid key, its      *                        associated value and an exception)      * @return a {@link Settings} instance with the unknown or invalid settings archived      */
DECL|method|archiveUnknownOrInvalidSettings
specifier|public
name|Settings
name|archiveUnknownOrInvalidSettings
parameter_list|(
specifier|final
name|Settings
name|settings
parameter_list|,
specifier|final
name|Consumer
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|unknownConsumer
parameter_list|,
specifier|final
name|BiConsumer
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|IllegalArgumentException
argument_list|>
name|invalidConsumer
parameter_list|)
block|{
name|Settings
operator|.
name|Builder
name|builder
init|=
name|Settings
operator|.
name|builder
argument_list|()
decl_stmt|;
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|settings
operator|.
name|getAsMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|Setting
argument_list|<
name|?
argument_list|>
name|setting
init|=
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|setting
operator|!=
literal|null
condition|)
block|{
name|setting
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|builder
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|startsWith
argument_list|(
name|ARCHIVED_SETTINGS_PREFIX
argument_list|)
operator|||
name|isPrivateSetting
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|builder
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|changed
operator|=
literal|true
expr_stmt|;
name|unknownConsumer
operator|.
name|accept
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/*                          * We put them back in here such that tools can check from the outside if there are any indices with invalid                          * settings. The setting can remain there but we want users to be aware that some of their setting are invalid and                          * they can research why and what they need to do to replace them.                          */
name|builder
operator|.
name|put
argument_list|(
name|ARCHIVED_SETTINGS_PREFIX
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|changed
operator|=
literal|true
expr_stmt|;
name|invalidConsumer
operator|.
name|accept
argument_list|(
name|entry
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|/*                  * We put them back in here such that tools can check from the outside if there are any indices with invalid settings. The                  * setting can remain there but we want users to be aware that some of their setting are invalid and they can research why                  * and what they need to do to replace them.                  */
name|builder
operator|.
name|put
argument_list|(
name|ARCHIVED_SETTINGS_PREFIX
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
block|{
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|settings
return|;
block|}
block|}
comment|/**      * Returns<code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal      * representation. Otherwise<code>false</code>      */
comment|// TODO this should be replaced by Setting.Property.HIDDEN or something like this.
DECL|method|isPrivateSetting
specifier|protected
name|boolean
name|isPrivateSetting
parameter_list|(
name|String
name|key
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

