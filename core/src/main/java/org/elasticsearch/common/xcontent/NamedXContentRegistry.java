begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.xcontent
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|CheckedFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParsingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyList
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Objects
operator|.
name|requireNonNull
import|;
end_import

begin_class
DECL|class|NamedXContentRegistry
specifier|public
class|class
name|NamedXContentRegistry
block|{
comment|/**      * The empty {@link NamedXContentRegistry} for use when you are sure that you aren't going to call      * {@link XContentParser#namedObject(Class, String, Object)}. Be *very* careful with this singleton because a parser using it will fail      * every call to {@linkplain XContentParser#namedObject(Class, String, Object)}. Every non-test usage really should be checked      * thoroughly and marked with a comment about how it was checked. That way anyone that sees code that uses it knows that it is      * potentially dangerous.      */
DECL|field|EMPTY
specifier|public
specifier|static
specifier|final
name|NamedXContentRegistry
name|EMPTY
init|=
operator|new
name|NamedXContentRegistry
argument_list|(
name|emptyList
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * An entry in the {@linkplain NamedXContentRegistry} containing the name of the object and the parser that can parse it.      */
DECL|class|Entry
specifier|public
specifier|static
class|class
name|Entry
block|{
comment|/** The class that this entry can read. */
DECL|field|categoryClass
specifier|public
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|categoryClass
decl_stmt|;
comment|/** A name for the entry which is unique within the {@link #categoryClass}. */
DECL|field|name
specifier|public
specifier|final
name|ParseField
name|name
decl_stmt|;
comment|/** A parser capability of parser the entry's class. */
DECL|field|parser
specifier|private
specifier|final
name|ContextParser
argument_list|<
name|Object
argument_list|,
name|?
argument_list|>
name|parser
decl_stmt|;
comment|/** Creates a new entry which can be stored by the registry. */
DECL|method|Entry
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Entry
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|categoryClass
parameter_list|,
name|ParseField
name|name
parameter_list|,
name|CheckedFunction
argument_list|<
name|XContentParser
argument_list|,
name|?
extends|extends
name|T
argument_list|,
name|IOException
argument_list|>
name|parser
parameter_list|)
block|{
name|this
operator|.
name|categoryClass
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|categoryClass
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|parser
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
parameter_list|(
name|p
parameter_list|,
name|c
parameter_list|)
lambda|->
name|parser
operator|.
name|apply
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**          * Creates a new entry which can be stored by the registry.          * @deprecated prefer {@link Entry#Entry(Class, ParseField, CheckedFunction)}. Contexts will be removed when possible          */
annotation|@
name|Deprecated
DECL|method|Entry
specifier|public
parameter_list|<
name|T
parameter_list|>
name|Entry
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|categoryClass
parameter_list|,
name|ParseField
name|name
parameter_list|,
name|ContextParser
argument_list|<
name|Object
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|parser
parameter_list|)
block|{
name|this
operator|.
name|categoryClass
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|categoryClass
argument_list|)
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|parser
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|registry
specifier|private
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Entry
argument_list|>
argument_list|>
name|registry
decl_stmt|;
DECL|method|NamedXContentRegistry
specifier|public
name|NamedXContentRegistry
parameter_list|(
name|List
argument_list|<
name|Entry
argument_list|>
name|entries
parameter_list|)
block|{
if|if
condition|(
name|entries
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|registry
operator|=
name|emptyMap
argument_list|()
expr_stmt|;
return|return;
block|}
name|entries
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|.
name|sort
argument_list|(
parameter_list|(
name|e1
parameter_list|,
name|e2
parameter_list|)
lambda|->
name|e1
operator|.
name|categoryClass
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|e2
operator|.
name|categoryClass
operator|.
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Entry
argument_list|>
argument_list|>
name|registry
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Entry
argument_list|>
name|parsers
init|=
literal|null
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|currentCategory
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Entry
name|entry
range|:
name|entries
control|)
block|{
if|if
condition|(
name|currentCategory
operator|!=
name|entry
operator|.
name|categoryClass
condition|)
block|{
if|if
condition|(
name|currentCategory
operator|!=
literal|null
condition|)
block|{
comment|// we've seen the last of this category, put it into the big map
name|registry
operator|.
name|put
argument_list|(
name|currentCategory
argument_list|,
name|unmodifiableMap
argument_list|(
name|parsers
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parsers
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|currentCategory
operator|=
name|entry
operator|.
name|categoryClass
expr_stmt|;
block|}
for|for
control|(
name|String
name|name
range|:
name|entry
operator|.
name|name
operator|.
name|getAllNamesIncludedDeprecated
argument_list|()
control|)
block|{
name|Object
name|old
init|=
name|parsers
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|old
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"NamedXContent ["
operator|+
name|currentCategory
operator|.
name|getName
argument_list|()
operator|+
literal|"]["
operator|+
name|entry
operator|.
name|name
operator|+
literal|"]"
operator|+
literal|" is already registered for ["
operator|+
name|old
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"],"
operator|+
literal|" cannot register ["
operator|+
name|entry
operator|.
name|parser
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
comment|// handle the last category
name|registry
operator|.
name|put
argument_list|(
name|currentCategory
argument_list|,
name|unmodifiableMap
argument_list|(
name|parsers
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|registry
operator|=
name|unmodifiableMap
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
comment|/**      * Parse a named object, throwing an exception if the parser isn't found. Throws an {@link ElasticsearchException} if the      * {@code categoryClass} isn't registered because this is almost always a bug. Throws a {@link UnknownNamedObjectException} if the      * {@code categoryClass} is registered but the {@code name} isn't.      */
DECL|method|parseNamedObject
specifier|public
parameter_list|<
name|T
parameter_list|,
name|C
parameter_list|>
name|T
name|parseNamedObject
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|categoryClass
parameter_list|,
name|String
name|name
parameter_list|,
name|XContentParser
name|parser
parameter_list|,
name|C
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Entry
argument_list|>
name|parsers
init|=
name|registry
operator|.
name|get
argument_list|(
name|categoryClass
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsers
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|registry
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// The "empty" registry will never work so we throw a better exception as a hint.
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"namedObject is not supported for this parser"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"Unknown namedObject category ["
operator|+
name|categoryClass
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|Entry
name|entry
init|=
name|parsers
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|UnknownNamedObjectException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
name|categoryClass
argument_list|,
name|name
argument_list|)
throw|;
block|}
if|if
condition|(
literal|false
operator|==
name|entry
operator|.
name|name
operator|.
name|match
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* Note that this shouldn't happen because we already looked up the entry using the names but we need to call `match` anyway              * because it is responsible for logging deprecation warnings. */
throw|throw
operator|new
name|ParsingException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
literal|"Unknown "
operator|+
name|categoryClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" ["
operator|+
name|name
operator|+
literal|"]: Parser didn't match"
argument_list|)
throw|;
block|}
return|return
name|categoryClass
operator|.
name|cast
argument_list|(
name|entry
operator|.
name|parser
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Thrown when {@link NamedXContentRegistry#parseNamedObject(Class, String, XContentParser, Object)} is called with an unregistered      * name. When this bubbles up to the rest layer it is converted into a response with {@code 400 BAD REQUEST} status.      */
DECL|class|UnknownNamedObjectException
specifier|public
specifier|static
class|class
name|UnknownNamedObjectException
extends|extends
name|ParsingException
block|{
DECL|field|categoryClass
specifier|private
specifier|final
name|String
name|categoryClass
decl_stmt|;
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|method|UnknownNamedObjectException
specifier|public
name|UnknownNamedObjectException
parameter_list|(
name|XContentLocation
name|contentLocation
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|categoryClass
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|super
argument_list|(
name|contentLocation
argument_list|,
literal|"Unknown "
operator|+
name|categoryClass
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|" ["
operator|+
name|name
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|this
operator|.
name|categoryClass
operator|=
name|requireNonNull
argument_list|(
name|categoryClass
argument_list|,
literal|"categoryClass is required"
argument_list|)
operator|.
name|getName
argument_list|()
expr_stmt|;
name|this
operator|.
name|name
operator|=
name|requireNonNull
argument_list|(
name|name
argument_list|,
literal|"name is required"
argument_list|)
expr_stmt|;
block|}
comment|/**          * Read from a stream.          */
DECL|method|UnknownNamedObjectException
specifier|public
name|UnknownNamedObjectException
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|categoryClass
operator|=
name|in
operator|.
name|readString
argument_list|()
expr_stmt|;
name|name
operator|=
name|in
operator|.
name|readString
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeString
argument_list|(
name|categoryClass
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeString
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/**          * Category class that was missing a parser. This is a String instead of a class because the class might not be on the classpath          * of all nodes or it might be exclusive to a plugin or something.          */
DECL|method|getCategoryClass
specifier|public
name|String
name|getCategoryClass
parameter_list|()
block|{
return|return
name|categoryClass
return|;
block|}
comment|/**          * Name of the missing parser.          */
DECL|method|getName
specifier|public
name|String
name|getName
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
block|}
end_class

end_unit

