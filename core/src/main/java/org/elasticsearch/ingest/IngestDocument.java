begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.ingest
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|ingest
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|IdFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|IndexFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|ParentFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|RoutingFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|SourceFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|TypeFieldMapper
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Base64
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Date
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_comment
comment|/**  * Represents a single document being captured before indexing and holds the source and metadata (like id, type and index).  */
end_comment

begin_class
DECL|class|IngestDocument
specifier|public
specifier|final
class|class
name|IngestDocument
block|{
DECL|field|INGEST_KEY
specifier|public
specifier|static
specifier|final
name|String
name|INGEST_KEY
init|=
literal|"_ingest"
decl_stmt|;
DECL|field|INGEST_KEY_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|INGEST_KEY_PREFIX
init|=
name|INGEST_KEY
operator|+
literal|"."
decl_stmt|;
DECL|field|SOURCE_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|SOURCE_PREFIX
init|=
name|SourceFieldMapper
operator|.
name|NAME
operator|+
literal|"."
decl_stmt|;
DECL|field|TIMESTAMP
specifier|static
specifier|final
name|String
name|TIMESTAMP
init|=
literal|"timestamp"
decl_stmt|;
DECL|field|sourceAndMetadata
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|sourceAndMetadata
decl_stmt|;
DECL|field|ingestMetadata
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|ingestMetadata
decl_stmt|;
DECL|method|IngestDocument
specifier|public
name|IngestDocument
parameter_list|(
name|String
name|index
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|,
name|String
name|routing
parameter_list|,
name|String
name|parent
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|source
parameter_list|)
block|{
name|this
operator|.
name|sourceAndMetadata
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|sourceAndMetadata
operator|.
name|putAll
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|this
operator|.
name|sourceAndMetadata
operator|.
name|put
argument_list|(
name|MetaData
operator|.
name|INDEX
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|this
operator|.
name|sourceAndMetadata
operator|.
name|put
argument_list|(
name|MetaData
operator|.
name|TYPE
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|sourceAndMetadata
operator|.
name|put
argument_list|(
name|MetaData
operator|.
name|ID
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|routing
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|sourceAndMetadata
operator|.
name|put
argument_list|(
name|MetaData
operator|.
name|ROUTING
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|routing
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|sourceAndMetadata
operator|.
name|put
argument_list|(
name|MetaData
operator|.
name|PARENT
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|ingestMetadata
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|this
operator|.
name|ingestMetadata
operator|.
name|put
argument_list|(
name|TIMESTAMP
argument_list|,
operator|new
name|Date
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Copy constructor that creates a new {@link IngestDocument} which has exactly the same properties as the one provided as argument      */
DECL|method|IngestDocument
specifier|public
name|IngestDocument
parameter_list|(
name|IngestDocument
name|other
parameter_list|)
block|{
name|this
argument_list|(
name|deepCopyMap
argument_list|(
name|other
operator|.
name|sourceAndMetadata
argument_list|)
argument_list|,
name|deepCopyMap
argument_list|(
name|other
operator|.
name|ingestMetadata
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructor needed for testing that allows to create a new {@link IngestDocument} given the provided elasticsearch metadata,      * source and ingest metadata. This is needed because the ingest metadata will be initialized with the current timestamp at      * init time, which makes equality comparisons impossible in tests.      */
DECL|method|IngestDocument
specifier|public
name|IngestDocument
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|sourceAndMetadata
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|ingestMetadata
parameter_list|)
block|{
name|this
operator|.
name|sourceAndMetadata
operator|=
name|sourceAndMetadata
expr_stmt|;
name|this
operator|.
name|ingestMetadata
operator|=
name|ingestMetadata
expr_stmt|;
block|}
comment|/**      * Returns the value contained in the document for the provided path      * @param path The path within the document in dot-notation      * @param clazz The expected class of the field value      * @return the value for the provided path if existing, null otherwise      * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist      * or if the field that is found at the provided path is not of the expected type.      */
DECL|method|getFieldValue
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getFieldValue
parameter_list|(
name|String
name|path
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
name|FieldPath
name|fieldPath
init|=
operator|new
name|FieldPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Object
name|context
init|=
name|fieldPath
operator|.
name|initialContext
decl_stmt|;
for|for
control|(
name|String
name|pathElement
range|:
name|fieldPath
operator|.
name|pathElements
control|)
block|{
name|context
operator|=
name|resolve
argument_list|(
name|pathElement
argument_list|,
name|path
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
return|return
name|cast
argument_list|(
name|path
argument_list|,
name|context
argument_list|,
name|clazz
argument_list|)
return|;
block|}
comment|/**      * Returns the value contained in the document for the provided path      *      * @param path The path within the document in dot-notation      * @param clazz The expected class of the field value      * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.      * @return the value for the provided path if existing, null otherwise.      * @throws IllegalArgumentException only if ignoreMissing is false and the path is null, empty, invalid, if the field doesn't exist      * or if the field that is found at the provided path is not of the expected type.      */
DECL|method|getFieldValue
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getFieldValue
parameter_list|(
name|String
name|path
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|,
name|boolean
name|ignoreMissing
parameter_list|)
block|{
try|try
block|{
return|return
name|getFieldValue
argument_list|(
name|path
argument_list|,
name|clazz
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|e
parameter_list|)
block|{
if|if
condition|(
name|ignoreMissing
operator|&&
name|hasField
argument_list|(
name|path
argument_list|)
operator|!=
literal|true
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
throw|throw
name|e
throw|;
block|}
block|}
block|}
comment|/**      * Returns the value contained in the document with the provided templated path      * @param pathTemplate The path within the document in dot-notation      * @param clazz The expected class fo the field value      * @return the value fro the provided path if existing, null otherwise      * @throws IllegalArgumentException if the pathTemplate is null, empty, invalid, if the field doesn't exist,      * or if the field that is found at the provided path is not of the expected type.      */
DECL|method|getFieldValue
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|getFieldValue
parameter_list|(
name|TemplateService
operator|.
name|Template
name|pathTemplate
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
name|getFieldValue
argument_list|(
name|renderTemplate
argument_list|(
name|pathTemplate
argument_list|)
argument_list|,
name|clazz
argument_list|)
return|;
block|}
comment|/**      * Returns the value contained in the document for the provided path as a byte array.      * If the path value is a string, a base64 decode operation will happen.      * If the path value is a byte array, it is just returned      * @param path The path within the document in dot-notation      * @return the byte array for the provided path if existing      * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist      * or if the field that is found at the provided path is not of the expected type.      */
DECL|method|getFieldValueAsBytes
specifier|public
name|byte
index|[]
name|getFieldValueAsBytes
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|getFieldValueAsBytes
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Returns the value contained in the document for the provided path as a byte array.      * If the path value is a string, a base64 decode operation will happen.      * If the path value is a byte array, it is just returned      * @param path The path within the document in dot-notation      * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.      * @return the byte array for the provided path if existing      * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist      * or if the field that is found at the provided path is not of the expected type.      */
DECL|method|getFieldValueAsBytes
specifier|public
name|byte
index|[]
name|getFieldValueAsBytes
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|ignoreMissing
parameter_list|)
block|{
name|Object
name|object
init|=
name|getFieldValue
argument_list|(
name|path
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|ignoreMissing
argument_list|)
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|object
operator|instanceof
name|byte
index|[]
condition|)
block|{
return|return
operator|(
name|byte
index|[]
operator|)
name|object
return|;
block|}
elseif|else
if|if
condition|(
name|object
operator|instanceof
name|String
condition|)
block|{
return|return
name|Base64
operator|.
name|getDecoder
argument_list|()
operator|.
name|decode
argument_list|(
name|object
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Content field ["
operator|+
name|path
operator|+
literal|"] of unknown type ["
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"], must be string or byte array"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Checks whether the document contains a value for the provided templated path      * @param fieldPathTemplate the template for the path within the document in dot-notation      * @return true if the document contains a value for the field, false otherwise      * @throws IllegalArgumentException if the path is null, empty or invalid      */
DECL|method|hasField
specifier|public
name|boolean
name|hasField
parameter_list|(
name|TemplateService
operator|.
name|Template
name|fieldPathTemplate
parameter_list|)
block|{
return|return
name|hasField
argument_list|(
name|renderTemplate
argument_list|(
name|fieldPathTemplate
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Checks whether the document contains a value for the provided path      * @param path The path within the document in dot-notation      * @return true if the document contains a value for the field, false otherwise      * @throws IllegalArgumentException if the path is null, empty or invalid.      */
DECL|method|hasField
specifier|public
name|boolean
name|hasField
parameter_list|(
name|String
name|path
parameter_list|)
block|{
return|return
name|hasField
argument_list|(
name|path
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * Checks whether the document contains a value for the provided path      * @param path The path within the document in dot-notation      * @param failOutOfRange Whether to throw an IllegalArgumentException if array is accessed outside of its range      * @return true if the document contains a value for the field, false otherwise      * @throws IllegalArgumentException if the path is null, empty or invalid.      */
DECL|method|hasField
specifier|public
name|boolean
name|hasField
parameter_list|(
name|String
name|path
parameter_list|,
name|boolean
name|failOutOfRange
parameter_list|)
block|{
name|FieldPath
name|fieldPath
init|=
operator|new
name|FieldPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Object
name|context
init|=
name|fieldPath
operator|.
name|initialContext
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldPath
operator|.
name|pathElements
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|String
name|pathElement
init|=
name|fieldPath
operator|.
name|pathElements
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|context
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
name|context
operator|=
name|map
operator|.
name|get
argument_list|(
name|pathElement
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|pathElement
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
if|if
condition|(
name|failOutOfRange
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|index
operator|+
literal|"] is out of bounds for array with length ["
operator|+
name|list
operator|.
name|size
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
name|context
operator|=
name|list
operator|.
name|get
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
name|String
name|leafKey
init|=
name|fieldPath
operator|.
name|pathElements
index|[
name|fieldPath
operator|.
name|pathElements
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|context
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|leafKey
argument_list|)
return|;
block|}
if|if
condition|(
name|context
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|leafKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|failOutOfRange
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|index
operator|+
literal|"] is out of bounds for array with length ["
operator|+
name|list
operator|.
name|size
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Removes the field identified by the provided path.      * @param fieldPathTemplate Resolves to the path with dot-notation within the document      * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.      */
DECL|method|removeField
specifier|public
name|void
name|removeField
parameter_list|(
name|TemplateService
operator|.
name|Template
name|fieldPathTemplate
parameter_list|)
block|{
name|removeField
argument_list|(
name|renderTemplate
argument_list|(
name|fieldPathTemplate
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the field identified by the provided path.      * @param path the path of the field to be removed      * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.      */
DECL|method|removeField
specifier|public
name|void
name|removeField
parameter_list|(
name|String
name|path
parameter_list|)
block|{
name|FieldPath
name|fieldPath
init|=
operator|new
name|FieldPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Object
name|context
init|=
name|fieldPath
operator|.
name|initialContext
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldPath
operator|.
name|pathElements
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|context
operator|=
name|resolve
argument_list|(
name|fieldPath
operator|.
name|pathElements
index|[
name|i
index|]
argument_list|,
name|path
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
name|String
name|leafKey
init|=
name|fieldPath
operator|.
name|pathElements
index|[
name|fieldPath
operator|.
name|pathElements
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|context
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|leafKey
argument_list|)
condition|)
block|{
name|map
operator|.
name|remove
argument_list|(
name|leafKey
argument_list|)
expr_stmt|;
return|return;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ["
operator|+
name|leafKey
operator|+
literal|"] not present as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
name|int
name|index
decl_stmt|;
try|try
block|{
name|index
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|leafKey
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|leafKey
operator|+
literal|"] is not an integer, cannot be used as an index as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|index
operator|+
literal|"] is out of bounds for array with length ["
operator|+
name|list
operator|.
name|size
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|list
operator|.
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot remove ["
operator|+
name|leafKey
operator|+
literal|"] from null as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot remove ["
operator|+
name|leafKey
operator|+
literal|"] from object of type ["
operator|+
name|context
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
DECL|method|resolve
specifier|private
specifier|static
name|Object
name|resolve
parameter_list|(
name|String
name|pathElement
parameter_list|,
name|String
name|fullPath
parameter_list|,
name|Object
name|context
parameter_list|)
block|{
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot resolve ["
operator|+
name|pathElement
operator|+
literal|"] from null as part of path ["
operator|+
name|fullPath
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|pathElement
argument_list|)
condition|)
block|{
return|return
name|map
operator|.
name|get
argument_list|(
name|pathElement
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ["
operator|+
name|pathElement
operator|+
literal|"] not present as part of path ["
operator|+
name|fullPath
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
name|int
name|index
decl_stmt|;
try|try
block|{
name|index
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|pathElement
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|pathElement
operator|+
literal|"] is not an integer, cannot be used as an index as part of path ["
operator|+
name|fullPath
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|index
operator|+
literal|"] is out of bounds for array with length ["
operator|+
name|list
operator|.
name|size
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|fullPath
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|list
operator|.
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot resolve ["
operator|+
name|pathElement
operator|+
literal|"] from object of type ["
operator|+
name|context
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|fullPath
operator|+
literal|"]"
argument_list|)
throw|;
block|}
comment|/**      * Appends the provided value to the provided path in the document.      * Any non existing path element will be created.      * If the path identifies a list, the value will be appended to the existing list.      * If the path identifies a scalar, the scalar will be converted to a list and      * the provided value will be added to the newly created list.      * Supports multiple values too provided in forms of list, in that case all the values will be appended to the      * existing (or newly created) list.      * @param path The path within the document in dot-notation      * @param value The value or values to append to the existing ones      * @throws IllegalArgumentException if the path is null, empty or invalid.      */
DECL|method|appendFieldValue
specifier|public
name|void
name|appendFieldValue
parameter_list|(
name|String
name|path
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|setFieldValue
argument_list|(
name|path
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Appends the provided value to the provided path in the document.      * Any non existing path element will be created.      * If the path identifies a list, the value will be appended to the existing list.      * If the path identifies a scalar, the scalar will be converted to a list and      * the provided value will be added to the newly created list.      * Supports multiple values too provided in forms of list, in that case all the values will be appended to the      * existing (or newly created) list.      * @param fieldPathTemplate Resolves to the path with dot-notation within the document      * @param valueSource The value source that will produce the value or values to append to the existing ones      * @throws IllegalArgumentException if the path is null, empty or invalid.      */
DECL|method|appendFieldValue
specifier|public
name|void
name|appendFieldValue
parameter_list|(
name|TemplateService
operator|.
name|Template
name|fieldPathTemplate
parameter_list|,
name|ValueSource
name|valueSource
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|model
init|=
name|createTemplateModel
argument_list|()
decl_stmt|;
name|appendFieldValue
argument_list|(
name|fieldPathTemplate
operator|.
name|execute
argument_list|(
name|model
argument_list|)
argument_list|,
name|valueSource
operator|.
name|copyAndResolve
argument_list|(
name|model
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the provided value to the provided path in the document.      * Any non existing path element will be created.      * If the last item in the path is a list, the value will replace the existing list as a whole.      * Use {@link #appendFieldValue(String, Object)} to append values to lists instead.      * @param path The path within the document in dot-notation      * @param value The value to put in for the path key      * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the      * item identified by the provided path.      */
DECL|method|setFieldValue
specifier|public
name|void
name|setFieldValue
parameter_list|(
name|String
name|path
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|setFieldValue
argument_list|(
name|path
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the provided value to the provided path in the document.      * Any non existing path element will be created. If the last element is a list,      * the value will replace the existing list.      * @param fieldPathTemplate Resolves to the path with dot-notation within the document      * @param valueSource The value source that will produce the value to put in for the path key      * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the      * item identified by the provided path.      */
DECL|method|setFieldValue
specifier|public
name|void
name|setFieldValue
parameter_list|(
name|TemplateService
operator|.
name|Template
name|fieldPathTemplate
parameter_list|,
name|ValueSource
name|valueSource
parameter_list|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|model
init|=
name|createTemplateModel
argument_list|()
decl_stmt|;
name|setFieldValue
argument_list|(
name|fieldPathTemplate
operator|.
name|execute
argument_list|(
name|model
argument_list|)
argument_list|,
name|valueSource
operator|.
name|copyAndResolve
argument_list|(
name|model
argument_list|)
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|setFieldValue
specifier|private
name|void
name|setFieldValue
parameter_list|(
name|String
name|path
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|append
parameter_list|)
block|{
name|FieldPath
name|fieldPath
init|=
operator|new
name|FieldPath
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Object
name|context
init|=
name|fieldPath
operator|.
name|initialContext
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fieldPath
operator|.
name|pathElements
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|String
name|pathElement
init|=
name|fieldPath
operator|.
name|pathElements
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot resolve ["
operator|+
name|pathElement
operator|+
literal|"] from null as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|pathElement
argument_list|)
condition|)
block|{
name|context
operator|=
name|map
operator|.
name|get
argument_list|(
name|pathElement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HashMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|newMap
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
name|pathElement
argument_list|,
name|newMap
argument_list|)
expr_stmt|;
name|context
operator|=
name|newMap
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|context
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
name|int
name|index
decl_stmt|;
try|try
block|{
name|index
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|pathElement
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|pathElement
operator|+
literal|"] is not an integer, cannot be used as an index as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|index
operator|+
literal|"] is out of bounds for array with length ["
operator|+
name|list
operator|.
name|size
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|context
operator|=
name|list
operator|.
name|get
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot resolve ["
operator|+
name|pathElement
operator|+
literal|"] from object of type ["
operator|+
name|context
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
name|String
name|leafKey
init|=
name|fieldPath
operator|.
name|pathElements
index|[
name|fieldPath
operator|.
name|pathElements
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot set ["
operator|+
name|leafKey
operator|+
literal|"] with null parent as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|instanceof
name|Map
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
if|if
condition|(
name|append
condition|)
block|{
if|if
condition|(
name|map
operator|.
name|containsKey
argument_list|(
name|leafKey
argument_list|)
condition|)
block|{
name|Object
name|object
init|=
name|map
operator|.
name|get
argument_list|(
name|leafKey
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
name|appendValues
argument_list|(
name|object
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|!=
name|object
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|leafKey
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|appendValues
argument_list|(
name|list
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|leafKey
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|map
operator|.
name|put
argument_list|(
name|leafKey
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|context
decl_stmt|;
name|int
name|index
decl_stmt|;
try|try
block|{
name|index
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|leafKey
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|leafKey
operator|+
literal|"] is not an integer, cannot be used as an index as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|list
operator|.
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"["
operator|+
name|index
operator|+
literal|"] is out of bounds for array with length ["
operator|+
name|list
operator|.
name|size
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|append
condition|)
block|{
name|Object
name|object
init|=
name|list
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|newList
init|=
name|appendValues
argument_list|(
name|object
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|newList
operator|!=
name|object
condition|)
block|{
name|list
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|newList
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|list
operator|.
name|set
argument_list|(
name|index
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot set ["
operator|+
name|leafKey
operator|+
literal|"] with parent object of type ["
operator|+
name|context
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"] as part of path ["
operator|+
name|path
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|appendValues
specifier|private
specifier|static
name|List
argument_list|<
name|Object
argument_list|>
name|appendValues
parameter_list|(
name|Object
name|maybeList
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|list
decl_stmt|;
if|if
condition|(
name|maybeList
operator|instanceof
name|List
condition|)
block|{
comment|//maybeList is already a list, we append the provided values to it
name|list
operator|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|maybeList
expr_stmt|;
block|}
else|else
block|{
comment|//maybeList is a scalar, we convert it to a list and append the provided values to it
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|list
operator|.
name|add
argument_list|(
name|maybeList
argument_list|)
expr_stmt|;
block|}
name|appendValues
argument_list|(
name|list
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
DECL|method|appendValues
specifier|private
specifier|static
name|void
name|appendValues
parameter_list|(
name|List
argument_list|<
name|Object
argument_list|>
name|list
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|?
argument_list|>
name|valueList
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
decl_stmt|;
name|valueList
operator|.
name|stream
argument_list|()
operator|.
name|forEach
argument_list|(
name|list
operator|::
name|add
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|.
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|cast
specifier|private
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|cast
parameter_list|(
name|String
name|path
parameter_list|,
name|Object
name|object
parameter_list|,
name|Class
argument_list|<
name|T
argument_list|>
name|clazz
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
if|if
condition|(
name|clazz
operator|.
name|isInstance
argument_list|(
name|object
argument_list|)
condition|)
block|{
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|object
argument_list|)
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"field ["
operator|+
name|path
operator|+
literal|"] of type ["
operator|+
name|object
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"] cannot be cast to ["
operator|+
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
DECL|method|renderTemplate
specifier|public
name|String
name|renderTemplate
parameter_list|(
name|TemplateService
operator|.
name|Template
name|template
parameter_list|)
block|{
return|return
name|template
operator|.
name|execute
argument_list|(
name|createTemplateModel
argument_list|()
argument_list|)
return|;
block|}
DECL|method|createTemplateModel
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|createTemplateModel
parameter_list|()
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|model
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|sourceAndMetadata
argument_list|)
decl_stmt|;
name|model
operator|.
name|put
argument_list|(
name|SourceFieldMapper
operator|.
name|NAME
argument_list|,
name|sourceAndMetadata
argument_list|)
expr_stmt|;
comment|// If there is a field in the source with the name '_ingest' it gets overwritten here,
comment|// if access to that field is required then it get accessed via '_source._ingest'
name|model
operator|.
name|put
argument_list|(
name|INGEST_KEY
argument_list|,
name|ingestMetadata
argument_list|)
expr_stmt|;
return|return
name|model
return|;
block|}
comment|/**      * one time operation that extracts the metadata fields from the ingest document and returns them.      * Metadata fields that used to be accessible as ordinary top level fields will be removed as part of this call.      */
DECL|method|extractMetadata
specifier|public
name|Map
argument_list|<
name|MetaData
argument_list|,
name|String
argument_list|>
name|extractMetadata
parameter_list|()
block|{
name|Map
argument_list|<
name|MetaData
argument_list|,
name|String
argument_list|>
name|metadataMap
init|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|MetaData
operator|.
name|class
argument_list|)
decl_stmt|;
for|for
control|(
name|MetaData
name|metaData
range|:
name|MetaData
operator|.
name|values
argument_list|()
control|)
block|{
name|metadataMap
operator|.
name|put
argument_list|(
name|metaData
argument_list|,
name|cast
argument_list|(
name|metaData
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|sourceAndMetadata
operator|.
name|remove
argument_list|(
name|metaData
operator|.
name|getFieldName
argument_list|()
argument_list|)
argument_list|,
name|String
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|metadataMap
return|;
block|}
comment|/**      * Returns the available ingest metadata fields, by default only timestamp, but it is possible to set additional ones.      * Use only for reading values, modify them instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}      */
DECL|method|getIngestMetadata
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getIngestMetadata
parameter_list|()
block|{
return|return
name|this
operator|.
name|ingestMetadata
return|;
block|}
comment|/**      * Returns the document including its metadata fields, unless {@link #extractMetadata()} has been called, in which case the      * metadata fields will not be present anymore.      * Modify the document instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}      */
DECL|method|getSourceAndMetadata
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|getSourceAndMetadata
parameter_list|()
block|{
return|return
name|this
operator|.
name|sourceAndMetadata
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|deepCopyMap
specifier|private
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|deepCopyMap
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|source
parameter_list|)
block|{
return|return
operator|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|deepCopy
argument_list|(
name|source
argument_list|)
return|;
block|}
DECL|method|deepCopy
specifier|private
specifier|static
name|Object
name|deepCopy
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Map
condition|)
block|{
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|mapValue
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|value
decl_stmt|;
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|copy
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|mapValue
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|mapValue
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|copy
operator|.
name|put
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|deepCopy
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|?
argument_list|>
name|listValue
init|=
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|value
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|copy
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|listValue
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Object
name|itemValue
range|:
name|listValue
control|)
block|{
name|copy
operator|.
name|add
argument_list|(
name|deepCopy
argument_list|(
name|itemValue
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|copy
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|byte
index|[]
condition|)
block|{
name|byte
index|[]
name|bytes
init|=
operator|(
name|byte
index|[]
operator|)
name|value
decl_stmt|;
return|return
name|Arrays
operator|.
name|copyOf
argument_list|(
name|bytes
argument_list|,
name|bytes
operator|.
name|length
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|instanceof
name|String
operator|||
name|value
operator|instanceof
name|Integer
operator|||
name|value
operator|instanceof
name|Long
operator|||
name|value
operator|instanceof
name|Float
operator|||
name|value
operator|instanceof
name|Double
operator|||
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Date
condition|)
block|{
return|return
operator|(
operator|(
name|Date
operator|)
name|value
operator|)
operator|.
name|clone
argument_list|()
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unexpected value type ["
operator|+
name|value
operator|.
name|getClass
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|IngestDocument
name|other
init|=
operator|(
name|IngestDocument
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|sourceAndMetadata
argument_list|,
name|other
operator|.
name|sourceAndMetadata
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|ingestMetadata
argument_list|,
name|other
operator|.
name|ingestMetadata
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|sourceAndMetadata
argument_list|,
name|ingestMetadata
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IngestDocument{"
operator|+
literal|" sourceAndMetadata="
operator|+
name|sourceAndMetadata
operator|+
literal|", ingestMetadata="
operator|+
name|ingestMetadata
operator|+
literal|'}'
return|;
block|}
DECL|enum|MetaData
specifier|public
enum|enum
name|MetaData
block|{
DECL|enum constant|INDEX
name|INDEX
parameter_list|(
name|IndexFieldMapper
operator|.
name|NAME
parameter_list|)
operator|,
DECL|enum constant|TYPE
constructor|TYPE(TypeFieldMapper.NAME
block|)
enum|,
DECL|enum constant|ID
name|ID
parameter_list|(
name|IdFieldMapper
operator|.
name|NAME
parameter_list|)
operator|,
DECL|enum constant|ROUTING
constructor|ROUTING(RoutingFieldMapper.NAME
block|)
operator|,
DECL|enum constant|PARENT
name|PARENT
argument_list|(
name|ParentFieldMapper
operator|.
name|NAME
argument_list|)
expr_stmt|;
end_class

begin_decl_stmt
DECL|field|fieldName
specifier|private
specifier|final
name|String
name|fieldName
decl_stmt|;
end_decl_stmt

begin_expr_stmt
DECL|method|MetaData
name|MetaData
argument_list|(
name|String
name|fieldName
argument_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
block|;         }
DECL|method|getFieldName
specifier|public
name|String
name|getFieldName
argument_list|()
block|{
return|return
name|fieldName
return|;
block|}
end_expr_stmt

begin_class
unit|}      private
DECL|class|FieldPath
class|class
name|FieldPath
block|{
DECL|field|pathElements
specifier|private
specifier|final
name|String
index|[]
name|pathElements
decl_stmt|;
DECL|field|initialContext
specifier|private
specifier|final
name|Object
name|initialContext
decl_stmt|;
DECL|method|FieldPath
specifier|private
name|FieldPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|Strings
operator|.
name|isEmpty
argument_list|(
name|path
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path cannot be null nor empty"
argument_list|)
throw|;
block|}
name|String
name|newPath
decl_stmt|;
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|INGEST_KEY_PREFIX
argument_list|)
condition|)
block|{
name|initialContext
operator|=
name|ingestMetadata
expr_stmt|;
name|newPath
operator|=
name|path
operator|.
name|substring
argument_list|(
name|INGEST_KEY_PREFIX
operator|.
name|length
argument_list|()
argument_list|,
name|path
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|initialContext
operator|=
name|sourceAndMetadata
expr_stmt|;
if|if
condition|(
name|path
operator|.
name|startsWith
argument_list|(
name|SOURCE_PREFIX
argument_list|)
condition|)
block|{
name|newPath
operator|=
name|path
operator|.
name|substring
argument_list|(
name|SOURCE_PREFIX
operator|.
name|length
argument_list|()
argument_list|,
name|path
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newPath
operator|=
name|path
expr_stmt|;
block|}
block|}
name|this
operator|.
name|pathElements
operator|=
name|newPath
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathElements
operator|.
name|length
operator|==
literal|1
operator|&&
name|pathElements
index|[
literal|0
index|]
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"path ["
operator|+
name|path
operator|+
literal|"] is not valid"
argument_list|)
throw|;
block|}
block|}
block|}
end_class

unit|}
end_unit

