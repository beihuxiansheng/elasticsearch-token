begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.percolator
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|percolator
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntObjectHashMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|ReaderUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|memory
operator|.
name|ExtendedMemoryIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|memory
operator|.
name|MemoryIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CloseableThreadLocal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|percolate
operator|.
name|PercolateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|percolate
operator|.
name|PercolateShardRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|percolate
operator|.
name|PercolateShardResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cache
operator|.
name|recycler
operator|.
name|PageCacheRecycler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|MappingUpdatedAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexNameExpressionResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseFieldMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|search
operator|.
name|Queries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|text
operator|.
name|BytesText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|text
operator|.
name|StringText
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|text
operator|.
name|Text
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|BigArrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|Engine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|SortedBinaryDocValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|internal
operator|.
name|UidFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|percolator
operator|.
name|stats
operator|.
name|ShardPercolateService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|ParsedQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|percolator
operator|.
name|QueryCollector
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|script
operator|.
name|ScriptService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|SearchParseElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|SearchShardTarget
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|AggregationPhase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|InternalAggregation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|InternalAggregation
operator|.
name|ReduceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|InternalAggregations
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|pipeline
operator|.
name|PipelineAggregator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|pipeline
operator|.
name|SiblingPipelineAggregator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|highlight
operator|.
name|HighlightField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|highlight
operator|.
name|HighlightPhase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|internal
operator|.
name|SearchContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|sort
operator|.
name|SortParseElement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|SourceToParse
operator|.
name|source
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|percolator
operator|.
name|QueryCollector
operator|.
name|*
import|;
end_import

begin_class
DECL|class|PercolatorService
specifier|public
class|class
name|PercolatorService
extends|extends
name|AbstractComponent
block|{
DECL|field|NO_SCORE
specifier|public
specifier|final
specifier|static
name|float
name|NO_SCORE
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
DECL|field|TYPE_NAME
specifier|public
specifier|final
specifier|static
name|String
name|TYPE_NAME
init|=
literal|".percolator"
decl_stmt|;
DECL|field|indexNameExpressionResolver
specifier|private
specifier|final
name|IndexNameExpressionResolver
name|indexNameExpressionResolver
decl_stmt|;
DECL|field|indicesService
specifier|private
specifier|final
name|IndicesService
name|indicesService
decl_stmt|;
DECL|field|percolatorTypes
specifier|private
specifier|final
name|IntObjectHashMap
argument_list|<
name|PercolatorType
argument_list|>
name|percolatorTypes
decl_stmt|;
DECL|field|pageCacheRecycler
specifier|private
specifier|final
name|PageCacheRecycler
name|pageCacheRecycler
decl_stmt|;
DECL|field|bigArrays
specifier|private
specifier|final
name|BigArrays
name|bigArrays
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|single
specifier|private
specifier|final
name|PercolatorIndex
name|single
decl_stmt|;
DECL|field|multi
specifier|private
specifier|final
name|PercolatorIndex
name|multi
decl_stmt|;
DECL|field|highlightPhase
specifier|private
specifier|final
name|HighlightPhase
name|highlightPhase
decl_stmt|;
DECL|field|aggregationPhase
specifier|private
specifier|final
name|AggregationPhase
name|aggregationPhase
decl_stmt|;
DECL|field|sortParseElement
specifier|private
specifier|final
name|SortParseElement
name|sortParseElement
decl_stmt|;
DECL|field|scriptService
specifier|private
specifier|final
name|ScriptService
name|scriptService
decl_stmt|;
DECL|field|mappingUpdatedAction
specifier|private
specifier|final
name|MappingUpdatedAction
name|mappingUpdatedAction
decl_stmt|;
DECL|field|cache
specifier|private
specifier|final
name|CloseableThreadLocal
argument_list|<
name|MemoryIndex
argument_list|>
name|cache
decl_stmt|;
DECL|field|parseFieldMatcher
specifier|private
specifier|final
name|ParseFieldMatcher
name|parseFieldMatcher
decl_stmt|;
annotation|@
name|Inject
DECL|method|PercolatorService
specifier|public
name|PercolatorService
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|IndexNameExpressionResolver
name|indexNameExpressionResolver
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|,
name|PageCacheRecycler
name|pageCacheRecycler
parameter_list|,
name|BigArrays
name|bigArrays
parameter_list|,
name|HighlightPhase
name|highlightPhase
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|AggregationPhase
name|aggregationPhase
parameter_list|,
name|ScriptService
name|scriptService
parameter_list|,
name|MappingUpdatedAction
name|mappingUpdatedAction
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexNameExpressionResolver
operator|=
name|indexNameExpressionResolver
expr_stmt|;
name|this
operator|.
name|parseFieldMatcher
operator|=
operator|new
name|ParseFieldMatcher
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
name|this
operator|.
name|pageCacheRecycler
operator|=
name|pageCacheRecycler
expr_stmt|;
name|this
operator|.
name|bigArrays
operator|=
name|bigArrays
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|highlightPhase
operator|=
name|highlightPhase
expr_stmt|;
name|this
operator|.
name|aggregationPhase
operator|=
name|aggregationPhase
expr_stmt|;
name|this
operator|.
name|scriptService
operator|=
name|scriptService
expr_stmt|;
name|this
operator|.
name|mappingUpdatedAction
operator|=
name|mappingUpdatedAction
expr_stmt|;
name|this
operator|.
name|sortParseElement
operator|=
operator|new
name|SortParseElement
argument_list|()
expr_stmt|;
specifier|final
name|long
name|maxReuseBytes
init|=
name|settings
operator|.
name|getAsBytesSize
argument_list|(
literal|"indices.memory.memory_index.size_per_thread"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|1
argument_list|,
name|ByteSizeUnit
operator|.
name|MB
argument_list|)
argument_list|)
operator|.
name|bytes
argument_list|()
decl_stmt|;
name|cache
operator|=
operator|new
name|CloseableThreadLocal
argument_list|<
name|MemoryIndex
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|MemoryIndex
name|initialValue
parameter_list|()
block|{
comment|// TODO: should we expose payloads as an option? should offsets be turned on always?
return|return
operator|new
name|ExtendedMemoryIndex
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|,
name|maxReuseBytes
argument_list|)
return|;
block|}
block|}
expr_stmt|;
name|single
operator|=
operator|new
name|SingleDocumentPercolatorIndex
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|multi
operator|=
operator|new
name|MultiDocumentPercolatorIndex
argument_list|(
name|cache
argument_list|)
expr_stmt|;
name|percolatorTypes
operator|=
operator|new
name|IntObjectHashMap
argument_list|<>
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|percolatorTypes
operator|.
name|put
argument_list|(
name|countPercolator
operator|.
name|id
argument_list|()
argument_list|,
name|countPercolator
argument_list|)
expr_stmt|;
name|percolatorTypes
operator|.
name|put
argument_list|(
name|queryCountPercolator
operator|.
name|id
argument_list|()
argument_list|,
name|queryCountPercolator
argument_list|)
expr_stmt|;
name|percolatorTypes
operator|.
name|put
argument_list|(
name|matchPercolator
operator|.
name|id
argument_list|()
argument_list|,
name|matchPercolator
argument_list|)
expr_stmt|;
name|percolatorTypes
operator|.
name|put
argument_list|(
name|queryPercolator
operator|.
name|id
argument_list|()
argument_list|,
name|queryPercolator
argument_list|)
expr_stmt|;
name|percolatorTypes
operator|.
name|put
argument_list|(
name|scoringPercolator
operator|.
name|id
argument_list|()
argument_list|,
name|scoringPercolator
argument_list|)
expr_stmt|;
name|percolatorTypes
operator|.
name|put
argument_list|(
name|topMatchingPercolator
operator|.
name|id
argument_list|()
argument_list|,
name|topMatchingPercolator
argument_list|)
expr_stmt|;
block|}
DECL|method|reduce
specifier|public
name|ReduceResult
name|reduce
parameter_list|(
name|byte
name|percolatorTypeId
parameter_list|,
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
name|PercolatorType
name|percolatorType
init|=
name|percolatorTypes
operator|.
name|get
argument_list|(
name|percolatorTypeId
argument_list|)
decl_stmt|;
return|return
name|percolatorType
operator|.
name|reduce
argument_list|(
name|shardResults
argument_list|)
return|;
block|}
DECL|method|percolate
specifier|public
name|PercolateShardResponse
name|percolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|)
block|{
name|IndexService
name|percolateIndexService
init|=
name|indicesService
operator|.
name|indexServiceSafe
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|IndexShard
name|indexShard
init|=
name|percolateIndexService
operator|.
name|shardSafe
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|readAllowed
argument_list|()
expr_stmt|;
comment|// check if we can read the shard...
name|ShardPercolateService
name|shardPercolateService
init|=
name|indexShard
operator|.
name|shardPercolateService
argument_list|()
decl_stmt|;
name|shardPercolateService
operator|.
name|prePercolate
argument_list|()
expr_stmt|;
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
comment|// TODO: The filteringAliases should be looked up at the coordinating node and serialized with all shard request,
comment|// just like is done in other apis.
name|String
index|[]
name|filteringAliases
init|=
name|indexNameExpressionResolver
operator|.
name|filteringAliases
argument_list|(
name|clusterService
operator|.
name|state
argument_list|()
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|request
operator|.
name|indices
argument_list|()
argument_list|)
decl_stmt|;
name|Query
name|aliasFilter
init|=
name|percolateIndexService
operator|.
name|aliasesService
argument_list|()
operator|.
name|aliasFilter
argument_list|(
name|filteringAliases
argument_list|)
decl_stmt|;
name|SearchShardTarget
name|searchShardTarget
init|=
operator|new
name|SearchShardTarget
argument_list|(
name|clusterService
operator|.
name|localNode
argument_list|()
operator|.
name|id
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|PercolateContext
name|context
init|=
operator|new
name|PercolateContext
argument_list|(
name|request
argument_list|,
name|searchShardTarget
argument_list|,
name|indexShard
argument_list|,
name|percolateIndexService
argument_list|,
name|pageCacheRecycler
argument_list|,
name|bigArrays
argument_list|,
name|scriptService
argument_list|,
name|aliasFilter
argument_list|,
name|parseFieldMatcher
argument_list|)
decl_stmt|;
name|SearchContext
operator|.
name|setCurrent
argument_list|(
name|context
argument_list|)
expr_stmt|;
try|try
block|{
name|ParsedDocument
name|parsedDocument
init|=
name|parseRequest
argument_list|(
name|percolateIndexService
argument_list|,
name|request
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|percolateQueries
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
if|if
condition|(
name|request
operator|.
name|docSource
argument_list|()
operator|!=
literal|null
operator|&&
name|request
operator|.
name|docSource
argument_list|()
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|parsedDocument
operator|=
name|parseFetchedDoc
argument_list|(
name|context
argument_list|,
name|request
operator|.
name|docSource
argument_list|()
argument_list|,
name|percolateIndexService
argument_list|,
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parsedDocument
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Nothing to percolate"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|.
name|percolateQuery
argument_list|()
operator|==
literal|null
operator|&&
operator|(
name|context
operator|.
name|trackScores
argument_list|()
operator|||
name|context
operator|.
name|doSort
operator|||
name|context
operator|.
name|aggregations
argument_list|()
operator|!=
literal|null
operator|)
operator|||
name|context
operator|.
name|aliasFilter
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|percolateQuery
argument_list|(
operator|new
name|MatchAllDocsQuery
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|.
name|doSort
operator|&&
operator|!
name|context
operator|.
name|limit
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't sort if size isn't specified"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|context
operator|.
name|limit
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't highlight if size isn't specified"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|.
name|size
argument_list|()
operator|<
literal|0
condition|)
block|{
name|context
operator|.
name|size
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// parse the source either into one MemoryIndex, if it is a single document or index multiple docs if nested
name|PercolatorIndex
name|percolatorIndex
decl_stmt|;
name|boolean
name|isNested
init|=
name|indexShard
operator|.
name|mapperService
argument_list|()
operator|.
name|documentMapper
argument_list|(
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
operator|.
name|hasNestedObjects
argument_list|()
decl_stmt|;
if|if
condition|(
name|parsedDocument
operator|.
name|docs
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
assert|assert
name|isNested
assert|;
name|percolatorIndex
operator|=
name|multi
expr_stmt|;
block|}
else|else
block|{
name|percolatorIndex
operator|=
name|single
expr_stmt|;
block|}
name|PercolatorType
name|action
decl_stmt|;
if|if
condition|(
name|request
operator|.
name|onlyCount
argument_list|()
condition|)
block|{
name|action
operator|=
name|context
operator|.
name|percolateQuery
argument_list|()
operator|!=
literal|null
condition|?
name|queryCountPercolator
else|:
name|countPercolator
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|context
operator|.
name|doSort
condition|)
block|{
name|action
operator|=
name|topMatchingPercolator
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|.
name|percolateQuery
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|action
operator|=
name|context
operator|.
name|trackScores
argument_list|()
condition|?
name|scoringPercolator
else|:
name|queryPercolator
expr_stmt|;
block|}
else|else
block|{
name|action
operator|=
name|matchPercolator
expr_stmt|;
block|}
block|}
name|context
operator|.
name|percolatorTypeId
operator|=
name|action
operator|.
name|id
argument_list|()
expr_stmt|;
name|percolatorIndex
operator|.
name|prepare
argument_list|(
name|context
argument_list|,
name|parsedDocument
argument_list|)
expr_stmt|;
return|return
name|action
operator|.
name|doPercolate
argument_list|(
name|request
argument_list|,
name|context
argument_list|,
name|isNested
argument_list|)
return|;
block|}
finally|finally
block|{
name|SearchContext
operator|.
name|removeCurrent
argument_list|()
expr_stmt|;
name|context
operator|.
name|close
argument_list|()
expr_stmt|;
name|shardPercolateService
operator|.
name|postPercolate
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseRequest
specifier|private
name|ParsedDocument
name|parseRequest
parameter_list|(
name|IndexService
name|documentIndexService
parameter_list|,
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|)
block|{
name|BytesReference
name|source
init|=
name|request
operator|.
name|source
argument_list|()
decl_stmt|;
if|if
condition|(
name|source
operator|==
literal|null
operator|||
name|source
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// TODO: combine all feature parse elements into one map
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|SearchParseElement
argument_list|>
name|hlElements
init|=
name|highlightPhase
operator|.
name|parseElements
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|SearchParseElement
argument_list|>
name|aggregationElements
init|=
name|aggregationPhase
operator|.
name|parseElements
argument_list|()
decl_stmt|;
name|ParsedDocument
name|doc
init|=
literal|null
decl_stmt|;
name|XContentParser
name|parser
init|=
literal|null
decl_stmt|;
comment|// Some queries (function_score query when for decay functions) rely on a SearchContext being set:
comment|// We switch types because this context needs to be in the context of the percolate queries in the shard and
comment|// not the in memory percolate doc
name|String
index|[]
name|previousTypes
init|=
name|context
operator|.
name|types
argument_list|()
decl_stmt|;
name|context
operator|.
name|types
argument_list|(
operator|new
name|String
index|[]
block|{
name|TYPE_NAME
block|}
argument_list|)
expr_stmt|;
try|try
block|{
name|parser
operator|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|source
argument_list|)
operator|.
name|createParser
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|String
name|currentFieldName
init|=
literal|null
decl_stmt|;
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
comment|// we need to check the "doc" here, so the next token will be START_OBJECT which is
comment|// the actual document starting
if|if
condition|(
literal|"doc"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Either specify doc or get, not both"
argument_list|)
throw|;
block|}
name|MapperService
name|mapperService
init|=
name|documentIndexService
operator|.
name|mapperService
argument_list|()
decl_stmt|;
name|Tuple
argument_list|<
name|DocumentMapper
argument_list|,
name|Mapping
argument_list|>
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
decl_stmt|;
name|doc
operator|=
name|docMapper
operator|.
name|v1
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|(
name|parser
argument_list|)
operator|.
name|type
argument_list|(
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
operator|.
name|flyweight
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|docMapper
operator|.
name|v2
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|docMapper
operator|.
name|v2
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doc
operator|.
name|dynamicMappingsUpdate
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|mappingUpdatedAction
operator|.
name|updateMappingOnMasterSynchronously
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|,
name|request
operator|.
name|documentType
argument_list|()
argument_list|,
name|doc
operator|.
name|dynamicMappingsUpdate
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// the document parsing exists the "doc" object, so we need to set the new current field.
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
name|SearchParseElement
name|element
init|=
name|hlElements
operator|.
name|get
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
name|element
operator|=
name|aggregationElements
operator|.
name|get
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"query"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|percolateQuery
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Either specify query or filter, not both"
argument_list|)
throw|;
block|}
name|context
operator|.
name|percolateQuery
argument_list|(
name|documentIndexService
operator|.
name|queryParserService
argument_list|()
operator|.
name|parse
argument_list|(
name|parser
argument_list|)
operator|.
name|query
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"filter"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|percolateQuery
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Either specify query or filter, not both"
argument_list|)
throw|;
block|}
name|Query
name|filter
init|=
name|documentIndexService
operator|.
name|queryParserService
argument_list|()
operator|.
name|parseInnerFilter
argument_list|(
name|parser
argument_list|)
operator|.
name|query
argument_list|()
decl_stmt|;
name|context
operator|.
name|percolateQuery
argument_list|(
operator|new
name|ConstantScoreQuery
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"sort"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|parseSort
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|!=
literal|null
condition|)
block|{
name|element
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
if|if
condition|(
literal|"sort"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|parseSort
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|isValue
argument_list|()
condition|)
block|{
if|if
condition|(
literal|"size"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|context
operator|.
name|size
argument_list|(
name|parser
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|size
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"size is set to [{}] and is expected to be higher or equal to 0"
argument_list|,
name|context
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"sort"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|parseSort
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"track_scores"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
operator|||
literal|"trackScores"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|context
operator|.
name|trackScores
argument_list|(
name|parser
operator|.
name|booleanValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// We need to get the actual source from the request body for highlighting, so parse the request body again
comment|// and only get the doc source.
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentFieldName
operator|=
literal|null
expr_stmt|;
name|parser
operator|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|source
argument_list|)
operator|.
name|createParser
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
assert|assert
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
assert|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
if|if
condition|(
literal|"doc"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|BytesStreamOutput
name|bStream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|XContentType
operator|.
name|SMILE
argument_list|,
name|bStream
argument_list|)
decl_stmt|;
name|builder
operator|.
name|copyCurrentStructure
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|builder
operator|.
name|close
argument_list|()
expr_stmt|;
name|doc
operator|.
name|setSource
argument_list|(
name|bStream
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|parser
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"failed to parse request"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|context
operator|.
name|types
argument_list|(
name|previousTypes
argument_list|)
expr_stmt|;
if|if
condition|(
name|parser
operator|!=
literal|null
condition|)
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|doc
return|;
block|}
DECL|method|parseSort
specifier|private
name|void
name|parseSort
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|PercolateContext
name|context
parameter_list|)
throws|throws
name|Exception
block|{
name|sortParseElement
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|// null, means default sorting by relevancy
if|if
condition|(
name|context
operator|.
name|sort
argument_list|()
operator|==
literal|null
condition|)
block|{
name|context
operator|.
name|doSort
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Only _score desc is supported"
argument_list|)
throw|;
block|}
block|}
DECL|method|parseFetchedDoc
specifier|private
name|ParsedDocument
name|parseFetchedDoc
parameter_list|(
name|PercolateContext
name|context
parameter_list|,
name|BytesReference
name|fetchedDoc
parameter_list|,
name|IndexService
name|documentIndexService
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|ParsedDocument
name|doc
init|=
literal|null
decl_stmt|;
name|XContentParser
name|parser
init|=
literal|null
decl_stmt|;
try|try
block|{
name|parser
operator|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|fetchedDoc
argument_list|)
operator|.
name|createParser
argument_list|(
name|fetchedDoc
argument_list|)
expr_stmt|;
name|MapperService
name|mapperService
init|=
name|documentIndexService
operator|.
name|mapperService
argument_list|()
decl_stmt|;
name|Tuple
argument_list|<
name|DocumentMapper
argument_list|,
name|Mapping
argument_list|>
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|doc
operator|=
name|docMapper
operator|.
name|v1
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|(
name|parser
argument_list|)
operator|.
name|type
argument_list|(
name|type
argument_list|)
operator|.
name|flyweight
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|setSource
argument_list|(
name|fetchedDoc
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"failed to parse request"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|parser
operator|!=
literal|null
condition|)
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"No doc to percolate in the request"
argument_list|)
throw|;
block|}
return|return
name|doc
return|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|cache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
DECL|interface|PercolatorType
interface|interface
name|PercolatorType
block|{
comment|// 0x00 is reserved for empty type.
DECL|method|id
name|byte
name|id
parameter_list|()
function_decl|;
DECL|method|reduce
name|ReduceResult
name|reduce
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
function_decl|;
DECL|method|doPercolate
name|PercolateShardResponse
name|doPercolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|boolean
name|isNested
parameter_list|)
function_decl|;
block|}
DECL|field|countPercolator
specifier|private
specifier|final
name|PercolatorType
name|countPercolator
init|=
operator|new
name|PercolatorType
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
name|id
parameter_list|()
block|{
return|return
literal|0x01
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReduceResult
name|reduce
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
name|long
name|finalCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PercolateShardResponse
name|shardResponse
range|:
name|shardResults
control|)
block|{
name|finalCount
operator|+=
name|shardResponse
operator|.
name|count
argument_list|()
expr_stmt|;
block|}
assert|assert
operator|!
name|shardResults
operator|.
name|isEmpty
argument_list|()
assert|;
name|InternalAggregations
name|reducedAggregations
init|=
name|reduceAggregations
argument_list|(
name|shardResults
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReduceResult
argument_list|(
name|finalCount
argument_list|,
name|reducedAggregations
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PercolateShardResponse
name|doPercolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|boolean
name|isNested
parameter_list|)
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
name|Lucene
operator|.
name|EarlyTerminatingCollector
name|collector
init|=
name|Lucene
operator|.
name|createExistsCollector
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|Query
argument_list|>
name|entry
range|:
name|context
operator|.
name|percolateQueries
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
if|if
condition|(
name|isNested
condition|)
block|{
name|Lucene
operator|.
name|exists
argument_list|(
name|context
operator|.
name|docSearcher
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|Queries
operator|.
name|newNonNestedFilter
argument_list|()
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Lucene
operator|.
name|exists
argument_list|(
name|context
operator|.
name|docSearcher
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"["
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"] failed to execute query"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PercolateException
argument_list|(
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|collector
operator|.
name|exists
argument_list|()
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|count
argument_list|,
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|queryCountPercolator
specifier|private
specifier|final
name|PercolatorType
name|queryCountPercolator
init|=
operator|new
name|PercolatorType
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
name|id
parameter_list|()
block|{
return|return
literal|0x02
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReduceResult
name|reduce
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
return|return
name|countPercolator
operator|.
name|reduce
argument_list|(
name|shardResults
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PercolateShardResponse
name|doPercolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|boolean
name|isNested
parameter_list|)
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
name|Engine
operator|.
name|Searcher
name|percolatorSearcher
init|=
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|acquireSearcher
argument_list|(
literal|"percolate"
argument_list|)
decl_stmt|;
try|try
block|{
name|Count
name|countCollector
init|=
name|count
argument_list|(
name|logger
argument_list|,
name|context
argument_list|,
name|isNested
argument_list|)
decl_stmt|;
name|queryBasedPercolating
argument_list|(
name|percolatorSearcher
argument_list|,
name|context
argument_list|,
name|countCollector
argument_list|)
expr_stmt|;
name|count
operator|=
name|countCollector
operator|.
name|counter
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|percolatorSearcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|count
argument_list|,
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|matchPercolator
specifier|private
specifier|final
name|PercolatorType
name|matchPercolator
init|=
operator|new
name|PercolatorType
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
name|id
parameter_list|()
block|{
return|return
literal|0x03
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReduceResult
name|reduce
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
name|long
name|foundMatches
init|=
literal|0
decl_stmt|;
name|int
name|numMatches
init|=
literal|0
decl_stmt|;
for|for
control|(
name|PercolateShardResponse
name|response
range|:
name|shardResults
control|)
block|{
name|foundMatches
operator|+=
name|response
operator|.
name|count
argument_list|()
expr_stmt|;
name|numMatches
operator|+=
name|response
operator|.
name|matches
argument_list|()
operator|.
name|length
expr_stmt|;
block|}
name|int
name|requestedSize
init|=
name|shardResults
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|requestedSize
argument_list|()
decl_stmt|;
comment|// Use a custom impl of AbstractBigArray for Object[]?
name|List
argument_list|<
name|PercolateResponse
operator|.
name|Match
argument_list|>
name|finalMatches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|requestedSize
operator|==
literal|0
condition|?
name|numMatches
else|:
name|requestedSize
argument_list|)
decl_stmt|;
name|outer
label|:
for|for
control|(
name|PercolateShardResponse
name|response
range|:
name|shardResults
control|)
block|{
name|Text
name|index
init|=
operator|new
name|StringText
argument_list|(
name|response
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|response
operator|.
name|matches
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|float
name|score
init|=
name|response
operator|.
name|scores
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|?
name|NO_SCORE
else|:
name|response
operator|.
name|scores
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|Text
name|match
init|=
operator|new
name|BytesText
argument_list|(
operator|new
name|BytesArray
argument_list|(
name|response
operator|.
name|matches
argument_list|()
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|HighlightField
argument_list|>
name|hl
init|=
name|response
operator|.
name|hls
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|?
literal|null
else|:
name|response
operator|.
name|hls
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|finalMatches
operator|.
name|add
argument_list|(
operator|new
name|PercolateResponse
operator|.
name|Match
argument_list|(
name|index
argument_list|,
name|match
argument_list|,
name|score
argument_list|,
name|hl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|requestedSize
operator|!=
literal|0
operator|&&
name|finalMatches
operator|.
name|size
argument_list|()
operator|==
name|requestedSize
condition|)
block|{
break|break
name|outer
break|;
block|}
block|}
block|}
assert|assert
operator|!
name|shardResults
operator|.
name|isEmpty
argument_list|()
assert|;
name|InternalAggregations
name|reducedAggregations
init|=
name|reduceAggregations
argument_list|(
name|shardResults
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReduceResult
argument_list|(
name|foundMatches
argument_list|,
name|finalMatches
operator|.
name|toArray
argument_list|(
operator|new
name|PercolateResponse
operator|.
name|Match
index|[
name|finalMatches
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|reducedAggregations
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PercolateShardResponse
name|doPercolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|boolean
name|isNested
parameter_list|)
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|BytesRef
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|HighlightField
argument_list|>
argument_list|>
name|hls
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Lucene
operator|.
name|EarlyTerminatingCollector
name|collector
init|=
name|Lucene
operator|.
name|createExistsCollector
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|Query
argument_list|>
name|entry
range|:
name|context
operator|.
name|percolateQueries
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|parsedQuery
argument_list|(
operator|new
name|ParsedQuery
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|hitContext
argument_list|()
operator|.
name|cache
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
try|try
block|{
if|if
condition|(
name|isNested
condition|)
block|{
name|Lucene
operator|.
name|exists
argument_list|(
name|context
operator|.
name|docSearcher
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|Queries
operator|.
name|newNonNestedFilter
argument_list|()
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Lucene
operator|.
name|exists
argument_list|(
name|context
operator|.
name|docSearcher
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|collector
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"["
operator|+
name|entry
operator|.
name|getKey
argument_list|()
operator|+
literal|"] failed to execute query"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PercolateException
argument_list|(
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|collector
operator|.
name|exists
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|context
operator|.
name|limit
operator|||
name|count
operator|<
name|context
operator|.
name|size
argument_list|()
condition|)
block|{
name|matches
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|highlightPhase
operator|.
name|hitExecute
argument_list|(
name|context
argument_list|,
name|context
operator|.
name|hitContext
argument_list|()
argument_list|)
expr_stmt|;
name|hls
operator|.
name|add
argument_list|(
name|context
operator|.
name|hitContext
argument_list|()
operator|.
name|hit
argument_list|()
operator|.
name|getHighlightFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
name|BytesRef
index|[]
name|finalMatches
init|=
name|matches
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|matches
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|finalMatches
argument_list|,
name|hls
argument_list|,
name|count
argument_list|,
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|queryPercolator
specifier|private
specifier|final
name|PercolatorType
name|queryPercolator
init|=
operator|new
name|PercolatorType
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
name|id
parameter_list|()
block|{
return|return
literal|0x04
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReduceResult
name|reduce
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
return|return
name|matchPercolator
operator|.
name|reduce
argument_list|(
name|shardResults
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PercolateShardResponse
name|doPercolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|boolean
name|isNested
parameter_list|)
block|{
name|Engine
operator|.
name|Searcher
name|percolatorSearcher
init|=
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|acquireSearcher
argument_list|(
literal|"percolate"
argument_list|)
decl_stmt|;
try|try
block|{
name|Match
name|match
init|=
name|match
argument_list|(
name|logger
argument_list|,
name|context
argument_list|,
name|highlightPhase
argument_list|,
name|isNested
argument_list|)
decl_stmt|;
name|queryBasedPercolating
argument_list|(
name|percolatorSearcher
argument_list|,
name|context
argument_list|,
name|match
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|BytesRef
argument_list|>
name|matches
init|=
name|match
operator|.
name|matches
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|HighlightField
argument_list|>
argument_list|>
name|hls
init|=
name|match
operator|.
name|hls
argument_list|()
decl_stmt|;
name|long
name|count
init|=
name|match
operator|.
name|counter
argument_list|()
decl_stmt|;
name|BytesRef
index|[]
name|finalMatches
init|=
name|matches
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|matches
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|finalMatches
argument_list|,
name|hls
argument_list|,
name|count
argument_list|,
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PercolateException
argument_list|(
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|percolatorSearcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
DECL|field|scoringPercolator
specifier|private
specifier|final
name|PercolatorType
name|scoringPercolator
init|=
operator|new
name|PercolatorType
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
name|id
parameter_list|()
block|{
return|return
literal|0x05
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReduceResult
name|reduce
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
return|return
name|matchPercolator
operator|.
name|reduce
argument_list|(
name|shardResults
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PercolateShardResponse
name|doPercolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|boolean
name|isNested
parameter_list|)
block|{
name|Engine
operator|.
name|Searcher
name|percolatorSearcher
init|=
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|acquireSearcher
argument_list|(
literal|"percolate"
argument_list|)
decl_stmt|;
try|try
block|{
name|MatchAndScore
name|matchAndScore
init|=
name|matchAndScore
argument_list|(
name|logger
argument_list|,
name|context
argument_list|,
name|highlightPhase
argument_list|,
name|isNested
argument_list|)
decl_stmt|;
name|queryBasedPercolating
argument_list|(
name|percolatorSearcher
argument_list|,
name|context
argument_list|,
name|matchAndScore
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|BytesRef
argument_list|>
name|matches
init|=
name|matchAndScore
operator|.
name|matches
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|HighlightField
argument_list|>
argument_list|>
name|hls
init|=
name|matchAndScore
operator|.
name|hls
argument_list|()
decl_stmt|;
name|float
index|[]
name|scores
init|=
name|matchAndScore
operator|.
name|scores
argument_list|()
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|long
name|count
init|=
name|matchAndScore
operator|.
name|counter
argument_list|()
decl_stmt|;
name|BytesRef
index|[]
name|finalMatches
init|=
name|matches
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|matches
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|finalMatches
argument_list|,
name|hls
argument_list|,
name|count
argument_list|,
name|scores
argument_list|,
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PercolateException
argument_list|(
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|percolatorSearcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
DECL|field|topMatchingPercolator
specifier|private
specifier|final
name|PercolatorType
name|topMatchingPercolator
init|=
operator|new
name|PercolatorType
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|byte
name|id
parameter_list|()
block|{
return|return
literal|0x06
return|;
block|}
annotation|@
name|Override
specifier|public
name|ReduceResult
name|reduce
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
name|long
name|foundMatches
init|=
literal|0
decl_stmt|;
name|int
name|nonEmptyResponses
init|=
literal|0
decl_stmt|;
name|int
name|firstNonEmptyIndex
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shardResults
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|PercolateShardResponse
name|response
init|=
name|shardResults
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|foundMatches
operator|+=
name|response
operator|.
name|count
argument_list|()
expr_stmt|;
if|if
condition|(
name|response
operator|.
name|matches
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|firstNonEmptyIndex
operator|==
literal|0
condition|)
block|{
name|firstNonEmptyIndex
operator|=
name|i
expr_stmt|;
block|}
name|nonEmptyResponses
operator|++
expr_stmt|;
block|}
block|}
name|int
name|requestedSize
init|=
name|shardResults
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|requestedSize
argument_list|()
decl_stmt|;
comment|// Use a custom impl of AbstractBigArray for Object[]?
name|List
argument_list|<
name|PercolateResponse
operator|.
name|Match
argument_list|>
name|finalMatches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|requestedSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|nonEmptyResponses
operator|==
literal|1
condition|)
block|{
name|PercolateShardResponse
name|response
init|=
name|shardResults
operator|.
name|get
argument_list|(
name|firstNonEmptyIndex
argument_list|)
decl_stmt|;
name|Text
name|index
init|=
operator|new
name|StringText
argument_list|(
name|response
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|response
operator|.
name|matches
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|float
name|score
init|=
name|response
operator|.
name|scores
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|?
name|Float
operator|.
name|NaN
else|:
name|response
operator|.
name|scores
argument_list|()
index|[
name|i
index|]
decl_stmt|;
name|Text
name|match
init|=
operator|new
name|BytesText
argument_list|(
operator|new
name|BytesArray
argument_list|(
name|response
operator|.
name|matches
argument_list|()
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|response
operator|.
name|hls
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|HighlightField
argument_list|>
name|hl
init|=
name|response
operator|.
name|hls
argument_list|()
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|finalMatches
operator|.
name|add
argument_list|(
operator|new
name|PercolateResponse
operator|.
name|Match
argument_list|(
name|index
argument_list|,
name|match
argument_list|,
name|score
argument_list|,
name|hl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|finalMatches
operator|.
name|add
argument_list|(
operator|new
name|PercolateResponse
operator|.
name|Match
argument_list|(
name|index
argument_list|,
name|match
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
index|[]
name|slots
init|=
operator|new
name|int
index|[
name|shardResults
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|float
name|lowestScore
init|=
name|Float
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
name|int
name|requestIndex
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|itemIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shardResults
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|int
name|scoreIndex
init|=
name|slots
index|[
name|i
index|]
decl_stmt|;
name|float
index|[]
name|scores
init|=
name|shardResults
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|scores
argument_list|()
decl_stmt|;
if|if
condition|(
name|scoreIndex
operator|>=
name|scores
operator|.
name|length
condition|)
block|{
continue|continue;
block|}
name|float
name|score
init|=
name|scores
index|[
name|scoreIndex
index|]
decl_stmt|;
name|int
name|cmp
init|=
name|Float
operator|.
name|compare
argument_list|(
name|lowestScore
argument_list|,
name|score
argument_list|)
decl_stmt|;
comment|// TODO: Maybe add a tie?
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|requestIndex
operator|=
name|i
expr_stmt|;
name|itemIndex
operator|=
name|scoreIndex
expr_stmt|;
name|lowestScore
operator|=
name|score
expr_stmt|;
block|}
block|}
comment|// This means the shard matches have been exhausted and we should bail
if|if
condition|(
name|requestIndex
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
name|slots
index|[
name|requestIndex
index|]
operator|++
expr_stmt|;
name|PercolateShardResponse
name|shardResponse
init|=
name|shardResults
operator|.
name|get
argument_list|(
name|requestIndex
argument_list|)
decl_stmt|;
name|Text
name|index
init|=
operator|new
name|StringText
argument_list|(
name|shardResponse
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|Text
name|match
init|=
operator|new
name|BytesText
argument_list|(
operator|new
name|BytesArray
argument_list|(
name|shardResponse
operator|.
name|matches
argument_list|()
index|[
name|itemIndex
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|float
name|score
init|=
name|shardResponse
operator|.
name|scores
argument_list|()
index|[
name|itemIndex
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|shardResponse
operator|.
name|hls
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|HighlightField
argument_list|>
name|hl
init|=
name|shardResponse
operator|.
name|hls
argument_list|()
operator|.
name|get
argument_list|(
name|itemIndex
argument_list|)
decl_stmt|;
name|finalMatches
operator|.
name|add
argument_list|(
operator|new
name|PercolateResponse
operator|.
name|Match
argument_list|(
name|index
argument_list|,
name|match
argument_list|,
name|score
argument_list|,
name|hl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|finalMatches
operator|.
name|add
argument_list|(
operator|new
name|PercolateResponse
operator|.
name|Match
argument_list|(
name|index
argument_list|,
name|match
argument_list|,
name|score
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finalMatches
operator|.
name|size
argument_list|()
operator|==
name|requestedSize
condition|)
block|{
break|break;
block|}
block|}
block|}
assert|assert
operator|!
name|shardResults
operator|.
name|isEmpty
argument_list|()
assert|;
name|InternalAggregations
name|reducedAggregations
init|=
name|reduceAggregations
argument_list|(
name|shardResults
argument_list|)
decl_stmt|;
return|return
operator|new
name|ReduceResult
argument_list|(
name|foundMatches
argument_list|,
name|finalMatches
operator|.
name|toArray
argument_list|(
operator|new
name|PercolateResponse
operator|.
name|Match
index|[
name|finalMatches
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|reducedAggregations
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|PercolateShardResponse
name|doPercolate
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|boolean
name|isNested
parameter_list|)
block|{
name|Engine
operator|.
name|Searcher
name|percolatorSearcher
init|=
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|acquireSearcher
argument_list|(
literal|"percolate"
argument_list|)
decl_stmt|;
try|try
block|{
name|MatchAndSort
name|matchAndSort
init|=
name|QueryCollector
operator|.
name|matchAndSort
argument_list|(
name|logger
argument_list|,
name|context
argument_list|,
name|isNested
argument_list|)
decl_stmt|;
name|queryBasedPercolating
argument_list|(
name|percolatorSearcher
argument_list|,
name|context
argument_list|,
name|matchAndSort
argument_list|)
expr_stmt|;
name|TopDocs
name|topDocs
init|=
name|matchAndSort
operator|.
name|topDocs
argument_list|()
decl_stmt|;
name|long
name|count
init|=
name|topDocs
operator|.
name|totalHits
decl_stmt|;
name|List
argument_list|<
name|BytesRef
argument_list|>
name|matches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
argument_list|)
decl_stmt|;
name|float
index|[]
name|scores
init|=
operator|new
name|float
index|[
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
index|]
decl_stmt|;
name|List
argument_list|<
name|Map
argument_list|<
name|String
argument_list|,
name|HighlightField
argument_list|>
argument_list|>
name|hls
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|hls
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|topDocs
operator|.
name|scoreDocs
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|final
name|MappedFieldType
name|uidMapper
init|=
name|context
operator|.
name|mapperService
argument_list|()
operator|.
name|smartNameFieldType
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|)
decl_stmt|;
specifier|final
name|IndexFieldData
argument_list|<
name|?
argument_list|>
name|uidFieldData
init|=
name|context
operator|.
name|fieldData
argument_list|()
operator|.
name|getForField
argument_list|(
name|uidMapper
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ScoreDoc
name|scoreDoc
range|:
name|topDocs
operator|.
name|scoreDocs
control|)
block|{
name|int
name|segmentIdx
init|=
name|ReaderUtil
operator|.
name|subIndex
argument_list|(
name|scoreDoc
operator|.
name|doc
argument_list|,
name|percolatorSearcher
operator|.
name|reader
argument_list|()
operator|.
name|leaves
argument_list|()
argument_list|)
decl_stmt|;
name|LeafReaderContext
name|atomicReaderContext
init|=
name|percolatorSearcher
operator|.
name|reader
argument_list|()
operator|.
name|leaves
argument_list|()
operator|.
name|get
argument_list|(
name|segmentIdx
argument_list|)
decl_stmt|;
name|SortedBinaryDocValues
name|values
init|=
name|uidFieldData
operator|.
name|load
argument_list|(
name|atomicReaderContext
argument_list|)
operator|.
name|getBytesValues
argument_list|()
decl_stmt|;
specifier|final
name|int
name|localDocId
init|=
name|scoreDoc
operator|.
name|doc
operator|-
name|atomicReaderContext
operator|.
name|docBase
decl_stmt|;
name|values
operator|.
name|setDocument
argument_list|(
name|localDocId
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numValues
init|=
name|values
operator|.
name|count
argument_list|()
decl_stmt|;
assert|assert
name|numValues
operator|==
literal|1
assert|;
name|BytesRef
name|bytes
init|=
name|Uid
operator|.
name|splitUidIntoTypeAndId
argument_list|(
name|values
operator|.
name|valueAt
argument_list|(
literal|0
argument_list|)
argument_list|)
index|[
literal|1
index|]
decl_stmt|;
name|matches
operator|.
name|add
argument_list|(
name|BytesRef
operator|.
name|deepCopyOf
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hls
operator|!=
literal|null
condition|)
block|{
name|Query
name|query
init|=
name|context
operator|.
name|percolateQueries
argument_list|()
operator|.
name|get
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
name|context
operator|.
name|parsedQuery
argument_list|(
operator|new
name|ParsedQuery
argument_list|(
name|query
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|hitContext
argument_list|()
operator|.
name|cache
argument_list|()
operator|.
name|clear
argument_list|()
expr_stmt|;
name|highlightPhase
operator|.
name|hitExecute
argument_list|(
name|context
argument_list|,
name|context
operator|.
name|hitContext
argument_list|()
argument_list|)
expr_stmt|;
name|hls
operator|.
name|add
argument_list|(
name|i
argument_list|,
name|context
operator|.
name|hitContext
argument_list|()
operator|.
name|hit
argument_list|()
operator|.
name|getHighlightFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|scores
index|[
name|i
operator|++
index|]
operator|=
name|scoreDoc
operator|.
name|score
expr_stmt|;
block|}
if|if
condition|(
name|hls
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|matches
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|matches
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|hls
argument_list|,
name|count
argument_list|,
name|scores
argument_list|,
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|PercolateShardResponse
argument_list|(
name|matches
operator|.
name|toArray
argument_list|(
operator|new
name|BytesRef
index|[
name|matches
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|count
argument_list|,
name|scores
argument_list|,
name|context
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|PercolateException
argument_list|(
name|context
operator|.
name|indexShard
argument_list|()
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"failed to execute"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|percolatorSearcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
DECL|method|queryBasedPercolating
specifier|private
name|void
name|queryBasedPercolating
parameter_list|(
name|Engine
operator|.
name|Searcher
name|percolatorSearcher
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|QueryCollector
name|percolateCollector
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|percolatorTypeFilter
init|=
name|context
operator|.
name|indexService
argument_list|()
operator|.
name|mapperService
argument_list|()
operator|.
name|documentMapper
argument_list|(
name|TYPE_NAME
argument_list|)
operator|.
name|typeFilter
argument_list|()
decl_stmt|;
specifier|final
name|Query
name|filter
decl_stmt|;
if|if
condition|(
name|context
operator|.
name|aliasFilter
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|BooleanQuery
name|booleanFilter
init|=
operator|new
name|BooleanQuery
argument_list|()
decl_stmt|;
name|booleanFilter
operator|.
name|add
argument_list|(
name|context
operator|.
name|aliasFilter
argument_list|()
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|booleanFilter
operator|.
name|add
argument_list|(
name|percolatorTypeFilter
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|MUST
argument_list|)
expr_stmt|;
name|filter
operator|=
name|booleanFilter
expr_stmt|;
block|}
else|else
block|{
name|filter
operator|=
name|percolatorTypeFilter
expr_stmt|;
block|}
name|Query
name|query
init|=
name|Queries
operator|.
name|filtered
argument_list|(
name|context
operator|.
name|percolateQuery
argument_list|()
argument_list|,
name|filter
argument_list|)
decl_stmt|;
name|percolatorSearcher
operator|.
name|searcher
argument_list|()
operator|.
name|search
argument_list|(
name|query
argument_list|,
name|percolateCollector
argument_list|)
expr_stmt|;
name|percolateCollector
operator|.
name|aggregatorCollector
operator|.
name|postCollection
argument_list|()
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|aggregations
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|aggregationPhase
operator|.
name|execute
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ReduceResult
specifier|public
specifier|final
specifier|static
class|class
name|ReduceResult
block|{
DECL|field|count
specifier|private
specifier|final
name|long
name|count
decl_stmt|;
DECL|field|matches
specifier|private
specifier|final
name|PercolateResponse
operator|.
name|Match
index|[]
name|matches
decl_stmt|;
DECL|field|reducedAggregations
specifier|private
specifier|final
name|InternalAggregations
name|reducedAggregations
decl_stmt|;
DECL|method|ReduceResult
name|ReduceResult
parameter_list|(
name|long
name|count
parameter_list|,
name|PercolateResponse
operator|.
name|Match
index|[]
name|matches
parameter_list|,
name|InternalAggregations
name|reducedAggregations
parameter_list|)
block|{
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|matches
operator|=
name|matches
expr_stmt|;
name|this
operator|.
name|reducedAggregations
operator|=
name|reducedAggregations
expr_stmt|;
block|}
DECL|method|ReduceResult
specifier|public
name|ReduceResult
parameter_list|(
name|long
name|count
parameter_list|,
name|InternalAggregations
name|reducedAggregations
parameter_list|)
block|{
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|matches
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|reducedAggregations
operator|=
name|reducedAggregations
expr_stmt|;
block|}
DECL|method|count
specifier|public
name|long
name|count
parameter_list|()
block|{
return|return
name|count
return|;
block|}
DECL|method|matches
specifier|public
name|PercolateResponse
operator|.
name|Match
index|[]
name|matches
parameter_list|()
block|{
return|return
name|matches
return|;
block|}
DECL|method|reducedAggregations
specifier|public
name|InternalAggregations
name|reducedAggregations
parameter_list|()
block|{
return|return
name|reducedAggregations
return|;
block|}
block|}
DECL|method|reduceAggregations
specifier|private
name|InternalAggregations
name|reduceAggregations
parameter_list|(
name|List
argument_list|<
name|PercolateShardResponse
argument_list|>
name|shardResults
parameter_list|)
block|{
if|if
condition|(
name|shardResults
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|aggregations
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|InternalAggregations
argument_list|>
name|aggregationsList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|shardResults
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|PercolateShardResponse
name|shardResult
range|:
name|shardResults
control|)
block|{
name|aggregationsList
operator|.
name|add
argument_list|(
name|shardResult
operator|.
name|aggregations
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|InternalAggregations
name|aggregations
init|=
name|InternalAggregations
operator|.
name|reduce
argument_list|(
name|aggregationsList
argument_list|,
operator|new
name|ReduceContext
argument_list|(
name|bigArrays
argument_list|,
name|scriptService
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|aggregations
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|SiblingPipelineAggregator
argument_list|>
name|pipelineAggregators
init|=
name|shardResults
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|pipelineAggregators
argument_list|()
decl_stmt|;
if|if
condition|(
name|pipelineAggregators
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|InternalAggregation
argument_list|>
name|newAggs
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|Lists
operator|.
name|transform
argument_list|(
name|aggregations
operator|.
name|asList
argument_list|()
argument_list|,
name|PipelineAggregator
operator|.
name|AGGREGATION_TRANFORM_FUNCTION
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|SiblingPipelineAggregator
name|pipelineAggregator
range|:
name|pipelineAggregators
control|)
block|{
name|InternalAggregation
name|newAgg
init|=
name|pipelineAggregator
operator|.
name|doReduce
argument_list|(
operator|new
name|InternalAggregations
argument_list|(
name|newAggs
argument_list|)
argument_list|,
operator|new
name|ReduceContext
argument_list|(
name|bigArrays
argument_list|,
name|scriptService
argument_list|)
argument_list|)
decl_stmt|;
name|newAggs
operator|.
name|add
argument_list|(
name|newAgg
argument_list|)
expr_stmt|;
block|}
name|aggregations
operator|=
operator|new
name|InternalAggregations
argument_list|(
name|newAggs
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|aggregations
return|;
block|}
block|}
end_class

end_unit

