begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.percolator
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|percolator
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ConstantScoreQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|percolate
operator|.
name|PercolateShardRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|DocumentMapperForType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|ParsedDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryShardContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|SearchParseElement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|AggregationPhase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|highlight
operator|.
name|HighlightPhase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|sort
operator|.
name|SortParseElement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|SourceToParse
operator|.
name|source
import|;
end_import

begin_class
DECL|class|PercolateDocumentParser
specifier|public
class|class
name|PercolateDocumentParser
block|{
DECL|field|highlightPhase
specifier|private
specifier|final
name|HighlightPhase
name|highlightPhase
decl_stmt|;
DECL|field|sortParseElement
specifier|private
specifier|final
name|SortParseElement
name|sortParseElement
decl_stmt|;
DECL|field|aggregationPhase
specifier|private
specifier|final
name|AggregationPhase
name|aggregationPhase
decl_stmt|;
annotation|@
name|Inject
DECL|method|PercolateDocumentParser
specifier|public
name|PercolateDocumentParser
parameter_list|(
name|HighlightPhase
name|highlightPhase
parameter_list|,
name|SortParseElement
name|sortParseElement
parameter_list|,
name|AggregationPhase
name|aggregationPhase
parameter_list|)
block|{
name|this
operator|.
name|highlightPhase
operator|=
name|highlightPhase
expr_stmt|;
name|this
operator|.
name|sortParseElement
operator|=
name|sortParseElement
expr_stmt|;
name|this
operator|.
name|aggregationPhase
operator|=
name|aggregationPhase
expr_stmt|;
block|}
DECL|method|parse
specifier|public
name|ParsedDocument
name|parse
parameter_list|(
name|PercolateShardRequest
name|request
parameter_list|,
name|PercolateContext
name|context
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|QueryShardContext
name|queryShardContext
parameter_list|)
block|{
name|BytesReference
name|source
init|=
name|request
operator|.
name|source
argument_list|()
decl_stmt|;
if|if
condition|(
name|source
operator|==
literal|null
operator|||
name|source
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|request
operator|.
name|docSource
argument_list|()
operator|!=
literal|null
operator|&&
name|request
operator|.
name|docSource
argument_list|()
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
return|return
name|parseFetchedDoc
argument_list|(
name|context
argument_list|,
name|request
operator|.
name|docSource
argument_list|()
argument_list|,
name|mapperService
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
comment|// TODO: combine all feature parse elements into one map
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|SearchParseElement
argument_list|>
name|hlElements
init|=
name|highlightPhase
operator|.
name|parseElements
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|?
extends|extends
name|SearchParseElement
argument_list|>
name|aggregationElements
init|=
name|aggregationPhase
operator|.
name|parseElements
argument_list|()
decl_stmt|;
name|ParsedDocument
name|doc
init|=
literal|null
decl_stmt|;
comment|// Some queries (function_score query when for decay functions) rely on a SearchContext being set:
comment|// We switch types because this context needs to be in the context of the percolate queries in the shard and
comment|// not the in memory percolate doc
name|String
index|[]
name|previousTypes
init|=
name|context
operator|.
name|getQueryShardContext
argument_list|()
operator|.
name|getTypes
argument_list|()
decl_stmt|;
name|context
operator|.
name|getQueryShardContext
argument_list|()
operator|.
name|setTypes
argument_list|(
name|PercolatorService
operator|.
name|TYPE_NAME
argument_list|)
expr_stmt|;
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|source
argument_list|)
operator|.
name|createParser
argument_list|(
name|source
argument_list|)
init|;
init|)
block|{
name|String
name|currentFieldName
init|=
literal|null
decl_stmt|;
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
comment|// we need to check the "doc" here, so the next token will be START_OBJECT which is
comment|// the actual document starting
if|if
condition|(
literal|"doc"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Either specify doc or get, not both"
argument_list|)
throw|;
block|}
name|DocumentMapperForType
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|index
init|=
name|context
operator|.
name|shardTarget
argument_list|()
operator|.
name|index
argument_list|()
decl_stmt|;
name|doc
operator|=
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|(
name|parser
argument_list|)
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|type
argument_list|(
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
operator|.
name|id
argument_list|(
literal|"_id_for_percolate_api"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|docMapper
operator|.
name|getMapping
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|docMapper
operator|.
name|getMapping
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// the document parsing exists the "doc" object, so we need to set the new current field.
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
name|SearchParseElement
name|element
init|=
name|hlElements
operator|.
name|get
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|==
literal|null
condition|)
block|{
name|element
operator|=
name|aggregationElements
operator|.
name|get
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|"query"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|percolateQuery
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Either specify query or filter, not both"
argument_list|)
throw|;
block|}
name|context
operator|.
name|percolateQuery
argument_list|(
name|queryShardContext
operator|.
name|parse
argument_list|(
name|parser
argument_list|)
operator|.
name|query
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"filter"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|percolateQuery
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Either specify query or filter, not both"
argument_list|)
throw|;
block|}
name|Query
name|filter
init|=
name|queryShardContext
operator|.
name|parseInnerFilter
argument_list|(
name|parser
argument_list|)
operator|.
name|query
argument_list|()
decl_stmt|;
name|context
operator|.
name|percolateQuery
argument_list|(
operator|new
name|ConstantScoreQuery
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"sort"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|parseSort
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|element
operator|!=
literal|null
condition|)
block|{
name|element
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
if|if
condition|(
literal|"sort"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|parseSort
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|isValue
argument_list|()
condition|)
block|{
if|if
condition|(
literal|"size"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|context
operator|.
name|size
argument_list|(
name|parser
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|.
name|size
argument_list|()
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"size is set to [{}] and is expected to be higher or equal to 0"
argument_list|,
name|context
operator|.
name|size
argument_list|()
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
literal|"sort"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|parseSort
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"track_scores"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
operator|||
literal|"trackScores"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|context
operator|.
name|trackScores
argument_list|(
name|parser
operator|.
name|booleanValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// We need to get the actual source from the request body for highlighting, so parse the request body again
comment|// and only get the doc source.
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
name|currentFieldName
operator|=
literal|null
expr_stmt|;
try|try
init|(
name|XContentParser
name|parserForHighlighter
init|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|source
argument_list|)
operator|.
name|createParser
argument_list|(
name|source
argument_list|)
init|)
block|{
name|token
operator|=
name|parserForHighlighter
operator|.
name|nextToken
argument_list|()
expr_stmt|;
assert|assert
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
assert|;
while|while
condition|(
operator|(
name|token
operator|=
name|parserForHighlighter
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|currentFieldName
operator|=
name|parserForHighlighter
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
if|if
condition|(
literal|"doc"
operator|.
name|equals
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
name|BytesStreamOutput
name|bStream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|XContentType
operator|.
name|SMILE
argument_list|,
name|bStream
argument_list|)
decl_stmt|;
name|builder
operator|.
name|copyCurrentStructure
argument_list|(
name|parserForHighlighter
argument_list|)
expr_stmt|;
name|builder
operator|.
name|close
argument_list|()
expr_stmt|;
name|doc
operator|.
name|setSource
argument_list|(
name|bStream
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|parserForHighlighter
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"failed to parse request"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|context
operator|.
name|getQueryShardContext
argument_list|()
operator|.
name|setTypes
argument_list|(
name|previousTypes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|.
name|docSource
argument_list|()
operator|!=
literal|null
operator|&&
name|request
operator|.
name|docSource
argument_list|()
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|doc
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Can't specify the document to percolate in the source of the request and as document id"
argument_list|)
throw|;
block|}
name|doc
operator|=
name|parseFetchedDoc
argument_list|(
name|context
argument_list|,
name|request
operator|.
name|docSource
argument_list|()
argument_list|,
name|mapperService
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|request
operator|.
name|documentType
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Nothing to percolate"
argument_list|)
throw|;
block|}
return|return
name|doc
return|;
block|}
DECL|method|parseSort
specifier|private
name|void
name|parseSort
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|PercolateContext
name|context
parameter_list|)
throws|throws
name|Exception
block|{
name|context
operator|.
name|trackScores
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|sortParseElement
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|// null, means default sorting by relevancy
if|if
condition|(
name|context
operator|.
name|sort
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Only _score desc is supported"
argument_list|)
throw|;
block|}
block|}
DECL|method|parseFetchedDoc
specifier|private
name|ParsedDocument
name|parseFetchedDoc
parameter_list|(
name|PercolateContext
name|context
parameter_list|,
name|BytesReference
name|fetchedDoc
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|String
name|index
parameter_list|,
name|String
name|type
parameter_list|)
block|{
name|DocumentMapperForType
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|(
name|fetchedDoc
argument_list|)
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|type
argument_list|(
name|type
argument_list|)
operator|.
name|id
argument_list|(
literal|"_id_for_percolate_api"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|doc
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"No doc to percolate in the request"
argument_list|)
throw|;
block|}
if|if
condition|(
name|context
operator|.
name|highlight
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|setSource
argument_list|(
name|fetchedDoc
argument_list|)
expr_stmt|;
block|}
return|return
name|doc
return|;
block|}
block|}
end_class

end_unit

