begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.env
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|env
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Sets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|primitives
operator|.
name|Ints
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|SuppressForbidden
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|FileSystemUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|settings
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|FsDirectoryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|monitor
operator|.
name|fs
operator|.
name|FsInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|monitor
operator|.
name|fs
operator|.
name|FsProbe
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_comment
comment|/**  * A component that holds all data paths for a single node.  */
end_comment

begin_class
DECL|class|NodeEnvironment
specifier|public
class|class
name|NodeEnvironment
extends|extends
name|AbstractComponent
implements|implements
name|Closeable
block|{
DECL|class|NodePath
specifier|public
specifier|static
class|class
name|NodePath
block|{
comment|/* ${data.paths}/nodes/{node.id} */
DECL|field|path
specifier|public
specifier|final
name|Path
name|path
decl_stmt|;
comment|/* ${data.paths}/nodes/{node.id}/indices */
DECL|field|indicesPath
specifier|public
specifier|final
name|Path
name|indicesPath
decl_stmt|;
comment|/** Cached FileStore from path */
DECL|field|fileStore
specifier|public
specifier|final
name|FileStore
name|fileStore
decl_stmt|;
comment|/** Cached result of Lucene's {@code IOUtils.spins} on path.  This is a trilean value: null means we could not determine it (we are          *  not running on Linux, or we hit an exception trying), True means the device possibly spins and False means it does not. */
DECL|field|spins
specifier|public
specifier|final
name|Boolean
name|spins
decl_stmt|;
DECL|method|NodePath
specifier|public
name|NodePath
parameter_list|(
name|Path
name|path
parameter_list|,
name|Environment
name|environment
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|indicesPath
operator|=
name|path
operator|.
name|resolve
argument_list|(
name|INDICES_FOLDER
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileStore
operator|=
name|environment
operator|.
name|getFileStore
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileStore
operator|.
name|supportsFileAttributeView
argument_list|(
literal|"lucene"
argument_list|)
condition|)
block|{
name|this
operator|.
name|spins
operator|=
operator|(
name|Boolean
operator|)
name|fileStore
operator|.
name|getAttribute
argument_list|(
literal|"lucene:spins"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|spins
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**          * Resolves the given shards directory against this NodePath          */
DECL|method|resolve
specifier|public
name|Path
name|resolve
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
return|return
name|resolve
argument_list|(
name|shardId
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Resolves the given indexes directory against this NodePath          */
DECL|method|resolve
specifier|public
name|Path
name|resolve
parameter_list|(
name|Index
name|index
parameter_list|)
block|{
return|return
name|indicesPath
operator|.
name|resolve
argument_list|(
name|index
operator|.
name|name
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodePath{"
operator|+
literal|"path="
operator|+
name|path
operator|+
literal|", spins="
operator|+
name|spins
operator|+
literal|'}'
return|;
block|}
block|}
DECL|field|nodePaths
specifier|private
specifier|final
name|NodePath
index|[]
name|nodePaths
decl_stmt|;
DECL|field|sharedDataPath
specifier|private
specifier|final
name|Path
name|sharedDataPath
decl_stmt|;
DECL|field|locks
specifier|private
specifier|final
name|Lock
index|[]
name|locks
decl_stmt|;
DECL|field|addNodeId
specifier|private
specifier|final
name|boolean
name|addNodeId
decl_stmt|;
DECL|field|localNodeId
specifier|private
specifier|final
name|int
name|localNodeId
decl_stmt|;
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|shardLocks
specifier|private
specifier|final
name|Map
argument_list|<
name|ShardId
argument_list|,
name|InternalShardLock
argument_list|>
name|shardLocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// Setting to automatically append node id to custom data paths
DECL|field|ADD_NODE_ID_TO_CUSTOM_PATH
specifier|public
specifier|static
specifier|final
name|String
name|ADD_NODE_ID_TO_CUSTOM_PATH
init|=
literal|"node.add_id_to_custom_path"
decl_stmt|;
comment|// If enabled, the [verbose] SegmentInfos.infoStream logging is sent to System.out:
DECL|field|SETTING_ENABLE_LUCENE_SEGMENT_INFOS_TRACE
specifier|public
specifier|static
specifier|final
name|String
name|SETTING_ENABLE_LUCENE_SEGMENT_INFOS_TRACE
init|=
literal|"node.enable_lucene_segment_infos_trace"
decl_stmt|;
DECL|field|NODES_FOLDER
specifier|public
specifier|static
specifier|final
name|String
name|NODES_FOLDER
init|=
literal|"nodes"
decl_stmt|;
DECL|field|INDICES_FOLDER
specifier|public
specifier|static
specifier|final
name|String
name|INDICES_FOLDER
init|=
literal|"indices"
decl_stmt|;
DECL|field|NODE_LOCK_FILENAME
specifier|public
specifier|static
specifier|final
name|String
name|NODE_LOCK_FILENAME
init|=
literal|"node.lock"
decl_stmt|;
annotation|@
name|Inject
annotation|@
name|SuppressForbidden
argument_list|(
name|reason
operator|=
literal|"System.out.*"
argument_list|)
DECL|method|NodeEnvironment
specifier|public
name|NodeEnvironment
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|Environment
name|environment
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|addNodeId
operator|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|ADD_NODE_ID_TO_CUSTOM_PATH
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DiscoveryNode
operator|.
name|nodeRequiresLocalStorage
argument_list|(
name|settings
argument_list|)
condition|)
block|{
name|nodePaths
operator|=
literal|null
expr_stmt|;
name|sharedDataPath
operator|=
literal|null
expr_stmt|;
name|locks
operator|=
literal|null
expr_stmt|;
name|localNodeId
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
specifier|final
name|NodePath
index|[]
name|nodePaths
init|=
operator|new
name|NodePath
index|[
name|environment
operator|.
name|dataWithClusterFiles
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|Lock
index|[]
name|locks
init|=
operator|new
name|Lock
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
name|sharedDataPath
operator|=
name|environment
operator|.
name|sharedDataFile
argument_list|()
expr_stmt|;
name|int
name|localNodeId
init|=
operator|-
literal|1
decl_stmt|;
name|IOException
name|lastException
init|=
literal|null
decl_stmt|;
name|int
name|maxLocalStorageNodes
init|=
name|settings
operator|.
name|getAsInt
argument_list|(
literal|"node.max_local_storage_nodes"
argument_list|,
literal|50
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|possibleLockId
init|=
literal|0
init|;
name|possibleLockId
operator|<
name|maxLocalStorageNodes
condition|;
name|possibleLockId
operator|++
control|)
block|{
for|for
control|(
name|int
name|dirIndex
init|=
literal|0
init|;
name|dirIndex
operator|<
name|environment
operator|.
name|dataWithClusterFiles
argument_list|()
operator|.
name|length
condition|;
name|dirIndex
operator|++
control|)
block|{
name|Path
name|dir
init|=
name|environment
operator|.
name|dataWithClusterFiles
argument_list|()
index|[
name|dirIndex
index|]
operator|.
name|resolve
argument_list|(
name|NODES_FOLDER
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|possibleLockId
argument_list|)
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|dir
argument_list|)
expr_stmt|;
try|try
init|(
name|Directory
name|luceneDir
init|=
name|FSDirectory
operator|.
name|open
argument_list|(
name|dir
argument_list|,
name|NativeFSLockFactory
operator|.
name|INSTANCE
argument_list|)
init|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"obtaining node lock on {} ..."
argument_list|,
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|locks
index|[
name|dirIndex
index|]
operator|=
name|Lucene
operator|.
name|acquireLock
argument_list|(
name|luceneDir
argument_list|,
name|NODE_LOCK_FILENAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nodePaths
index|[
name|dirIndex
index|]
operator|=
operator|new
name|NodePath
argument_list|(
name|dir
argument_list|,
name|environment
argument_list|)
expr_stmt|;
name|localNodeId
operator|=
name|possibleLockId
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockObtainFailedException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"failed to obtain node lock on {}"
argument_list|,
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// release all the ones that were obtained up until now
name|releaseAndNullLocks
argument_list|(
name|locks
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"failed to obtain node lock on {}"
argument_list|,
name|e
argument_list|,
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|lastException
operator|=
operator|new
name|IOException
argument_list|(
literal|"failed to obtain lock on "
operator|+
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// release all the ones that were obtained up until now
name|releaseAndNullLocks
argument_list|(
name|locks
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|locks
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
comment|// we found a lock, break
break|break;
block|}
block|}
if|if
condition|(
name|locks
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Failed to obtain node lock, is the following location writable?: "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|environment
operator|.
name|dataWithClusterFiles
argument_list|()
argument_list|)
argument_list|,
name|lastException
argument_list|)
throw|;
block|}
name|this
operator|.
name|localNodeId
operator|=
name|localNodeId
expr_stmt|;
name|this
operator|.
name|locks
operator|=
name|locks
expr_stmt|;
name|this
operator|.
name|nodePaths
operator|=
name|nodePaths
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"using node location [{}], local_node_id [{}]"
argument_list|,
name|nodePaths
argument_list|,
name|localNodeId
argument_list|)
expr_stmt|;
block|}
name|maybeLogPathDetails
argument_list|()
expr_stmt|;
if|if
condition|(
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|SETTING_ENABLE_LUCENE_SEGMENT_INFOS_TRACE
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|SegmentInfos
operator|.
name|setInfoStream
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|releaseAndNullLocks
specifier|private
specifier|static
name|void
name|releaseAndNullLocks
parameter_list|(
name|Lock
index|[]
name|locks
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|locks
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|locks
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|maybeLogPathDetails
specifier|private
name|void
name|maybeLogPathDetails
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We do some I/O in here, so skip this if DEBUG/INFO are not enabled:
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Log one line per path.data:
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"node data locations details:"
argument_list|)
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
operator|.
name|append
argument_list|(
literal|" -> "
argument_list|)
operator|.
name|append
argument_list|(
name|nodePath
operator|.
name|path
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|spinsDesc
decl_stmt|;
if|if
condition|(
name|nodePath
operator|.
name|spins
operator|==
literal|null
condition|)
block|{
name|spinsDesc
operator|=
literal|"unknown"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodePath
operator|.
name|spins
condition|)
block|{
name|spinsDesc
operator|=
literal|"possibly"
expr_stmt|;
block|}
else|else
block|{
name|spinsDesc
operator|=
literal|"no"
expr_stmt|;
block|}
name|FsInfo
operator|.
name|Path
name|fsPath
init|=
name|FsProbe
operator|.
name|getFSInfo
argument_list|(
name|nodePath
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", free_space ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getFree
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], usable_space ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getAvailable
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], total_space ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getTotal
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], spins? ["
argument_list|)
operator|.
name|append
argument_list|(
name|spinsDesc
argument_list|)
operator|.
name|append
argument_list|(
literal|"], mount ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getMount
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], type ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|debug
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|FsInfo
operator|.
name|Path
name|totFSPath
init|=
operator|new
name|FsInfo
operator|.
name|Path
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allTypes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allSpins
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allMounts
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|FsInfo
operator|.
name|Path
name|fsPath
init|=
name|FsProbe
operator|.
name|getFSInfo
argument_list|(
name|nodePath
argument_list|)
decl_stmt|;
name|String
name|mount
init|=
name|fsPath
operator|.
name|getMount
argument_list|()
decl_stmt|;
if|if
condition|(
name|allMounts
operator|.
name|contains
argument_list|(
name|mount
argument_list|)
operator|==
literal|false
condition|)
block|{
name|allMounts
operator|.
name|add
argument_list|(
name|mount
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|fsPath
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|allTypes
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|Boolean
name|spins
init|=
name|fsPath
operator|.
name|getSpins
argument_list|()
decl_stmt|;
if|if
condition|(
name|spins
operator|==
literal|null
condition|)
block|{
name|allSpins
operator|.
name|add
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|allSpins
operator|.
name|add
argument_list|(
literal|"possibly"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allSpins
operator|.
name|add
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
block|}
name|totFSPath
operator|.
name|add
argument_list|(
name|fsPath
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Just log a 1-line summary:
name|logger
operator|.
name|info
argument_list|(
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"using [%d] data paths, mounts [%s], net usable_space [%s], net total_space [%s], spins? [%s], types [%s]"
argument_list|,
name|nodePaths
operator|.
name|length
argument_list|,
name|allMounts
argument_list|,
name|totFSPath
operator|.
name|getAvailable
argument_list|()
argument_list|,
name|totFSPath
operator|.
name|getTotal
argument_list|()
argument_list|,
name|toString
argument_list|(
name|allSpins
argument_list|)
argument_list|,
name|toString
argument_list|(
name|allTypes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString
specifier|private
specifier|static
name|String
name|toString
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|items
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|item
range|:
name|items
control|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Deletes a shard data directory iff the shards locks were successfully acquired.      *      * @param shardId the id of the shard to delete to delete      * @throws IOException if an IOException occurs      */
DECL|method|deleteShardDirectorySafe
specifier|public
name|void
name|deleteShardDirectorySafe
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is to ensure someone doesn't use Settings.EMPTY
assert|assert
name|indexSettings
operator|!=
name|Settings
operator|.
name|EMPTY
assert|;
specifier|final
name|Path
index|[]
name|paths
init|=
name|availableShardPaths
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting shard {} directory, paths: [{}]"
argument_list|,
name|shardId
argument_list|,
name|paths
argument_list|)
expr_stmt|;
try|try
init|(
name|ShardLock
name|lock
init|=
name|shardLock
argument_list|(
name|shardId
argument_list|)
init|)
block|{
name|deleteShardDirectoryUnderLock
argument_list|(
name|lock
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Acquires, then releases, all {@code write.lock} files in the given      * shard paths. The "write.lock" file is assumed to be under the shard      * path's "index" directory as used by Elasticsearch.      *      * @throws LockObtainFailedException if any of the locks could not be acquired      */
DECL|method|acquireFSLockForPaths
specifier|public
specifier|static
name|void
name|acquireFSLockForPaths
parameter_list|(
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|,
name|Path
modifier|...
name|shardPaths
parameter_list|)
throws|throws
name|IOException
block|{
name|Lock
index|[]
name|locks
init|=
operator|new
name|Lock
index|[
name|shardPaths
operator|.
name|length
index|]
decl_stmt|;
name|Directory
index|[]
name|dirs
init|=
operator|new
name|Directory
index|[
name|shardPaths
operator|.
name|length
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shardPaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// resolve the directory the shard actually lives in
name|Path
name|p
init|=
name|shardPaths
index|[
name|i
index|]
operator|.
name|resolve
argument_list|(
literal|"index"
argument_list|)
decl_stmt|;
comment|// open a directory (will be immediately closed) on the shard's location
name|dirs
index|[
name|i
index|]
operator|=
operator|new
name|SimpleFSDirectory
argument_list|(
name|p
argument_list|,
name|FsDirectoryService
operator|.
name|buildLockFactory
argument_list|(
name|indexSettings
argument_list|)
argument_list|)
expr_stmt|;
comment|// create a lock for the "write.lock" file
try|try
block|{
name|locks
index|[
name|i
index|]
operator|=
name|Lucene
operator|.
name|acquireWriteLock
argument_list|(
name|dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"unable to acquire "
operator|+
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
operator|+
literal|" for "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Deletes a shard data directory. Note: this method assumes that the shard      * lock is acquired. This method will also attempt to acquire the write      * locks for the shard's paths before deleting the data, but this is best      * effort, as the lock is released before the deletion happens in order to      * allow the folder to be deleted      *      * @param lock the shards lock      * @throws IOException if an IOException occurs      * @throws ElasticsearchException if the write.lock is not acquirable      */
DECL|method|deleteShardDirectoryUnderLock
specifier|public
name|void
name|deleteShardDirectoryUnderLock
parameter_list|(
name|ShardLock
name|lock
parameter_list|,
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|indexSettings
operator|!=
name|Settings
operator|.
name|EMPTY
assert|;
specifier|final
name|ShardId
name|shardId
init|=
name|lock
operator|.
name|getShardId
argument_list|()
decl_stmt|;
assert|assert
name|isShardLocked
argument_list|(
name|shardId
argument_list|)
operator|:
literal|"shard "
operator|+
name|shardId
operator|+
literal|" is not locked"
assert|;
specifier|final
name|Path
index|[]
name|paths
init|=
name|availableShardPaths
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"acquiring locks for {}, paths: [{}]"
argument_list|,
name|shardId
argument_list|,
name|paths
argument_list|)
expr_stmt|;
name|acquireFSLockForPaths
argument_list|(
name|indexSettings
argument_list|,
name|paths
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasCustomDataPath
argument_list|(
name|indexSettings
argument_list|)
condition|)
block|{
name|Path
name|customLocation
init|=
name|resolveCustomLocation
argument_list|(
name|indexSettings
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"acquiring lock for {}, custom path: [{}]"
argument_list|,
name|shardId
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|acquireFSLockForPaths
argument_list|(
name|indexSettings
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting custom shard {} directory [{}]"
argument_list|,
name|shardId
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|customLocation
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"deleted shard {} directory, paths: [{}]"
argument_list|,
name|shardId
argument_list|,
name|paths
argument_list|)
expr_stmt|;
assert|assert
name|FileSystemUtils
operator|.
name|exists
argument_list|(
name|paths
argument_list|)
operator|==
literal|false
assert|;
block|}
DECL|method|isShardLocked
specifier|private
name|boolean
name|isShardLocked
parameter_list|(
name|ShardId
name|id
parameter_list|)
block|{
try|try
block|{
name|shardLock
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Deletes an indexes data directory recursively iff all of the indexes      * shards locks were successfully acquired. If any of the indexes shard directories can't be locked      * non of the shards will be deleted      *      * @param index the index to delete      * @param lockTimeoutMS how long to wait for acquiring the indices shard locks      * @param indexSettings settings for the index being deleted      * @throws Exception if any of the shards data directories can't be locked or deleted      */
DECL|method|deleteIndexDirectorySafe
specifier|public
name|void
name|deleteIndexDirectorySafe
parameter_list|(
name|Index
name|index
parameter_list|,
name|long
name|lockTimeoutMS
parameter_list|,
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is to ensure someone doesn't use Settings.EMPTY
assert|assert
name|indexSettings
operator|!=
name|Settings
operator|.
name|EMPTY
assert|;
specifier|final
name|List
argument_list|<
name|ShardLock
argument_list|>
name|locks
init|=
name|lockAllForIndex
argument_list|(
name|index
argument_list|,
name|indexSettings
argument_list|,
name|lockTimeoutMS
argument_list|)
decl_stmt|;
try|try
block|{
name|deleteIndexDirectoryUnderLock
argument_list|(
name|index
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Deletes an indexes data directory recursively.      * Note: this method assumes that the shard lock is acquired      *      * @param index the index to delete      * @param indexSettings settings for the index being deleted      */
DECL|method|deleteIndexDirectoryUnderLock
specifier|public
name|void
name|deleteIndexDirectoryUnderLock
parameter_list|(
name|Index
name|index
parameter_list|,
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
comment|// This is to ensure someone doesn't use Settings.EMPTY
assert|assert
name|indexSettings
operator|!=
name|Settings
operator|.
name|EMPTY
assert|;
specifier|final
name|Path
index|[]
name|indexPaths
init|=
name|indexPaths
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting index {} directory, paths({}): [{}]"
argument_list|,
name|index
argument_list|,
name|indexPaths
operator|.
name|length
argument_list|,
name|indexPaths
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|indexPaths
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasCustomDataPath
argument_list|(
name|indexSettings
argument_list|)
condition|)
block|{
name|Path
name|customLocation
init|=
name|resolveCustomLocation
argument_list|(
name|indexSettings
argument_list|,
name|index
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting custom index {} directory [{}]"
argument_list|,
name|index
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|customLocation
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tries to lock all local shards for the given index. If any of the shard locks can't be acquired      * an {@link LockObtainFailedException} is thrown and all previously acquired locks are released.      *      * @param index the index to lock shards for      * @param lockTimeoutMS how long to wait for acquiring the indices shard locks      * @return the {@link ShardLock} instances for this index.      * @throws IOException if an IOException occurs.      */
DECL|method|lockAllForIndex
specifier|public
name|List
argument_list|<
name|ShardLock
argument_list|>
name|lockAllForIndex
parameter_list|(
name|Index
name|index
parameter_list|,
annotation|@
name|IndexSettings
name|Settings
name|settings
parameter_list|,
name|long
name|lockTimeoutMS
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Integer
name|numShards
init|=
name|settings
operator|.
name|getAsInt
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_SHARDS
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|numShards
operator|==
literal|null
operator|||
name|numShards
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"settings must contain a non-null> 0 number of shards"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"locking all shards for index {} - [{}]"
argument_list|,
name|index
argument_list|,
name|numShards
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ShardLock
argument_list|>
name|allLocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|numShards
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|long
name|startTimeNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numShards
condition|;
name|i
operator|++
control|)
block|{
name|long
name|timeoutLeftMS
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|lockTimeoutMS
operator|-
name|TimeValue
operator|.
name|nsecToMSec
argument_list|(
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNS
operator|)
argument_list|)
argument_list|)
decl_stmt|;
name|allLocks
operator|.
name|add
argument_list|(
name|shardLock
argument_list|(
operator|new
name|ShardId
argument_list|(
name|index
argument_list|,
name|i
argument_list|)
argument_list|,
name|timeoutLeftMS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"unable to lock all shards for index {}"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|allLocks
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allLocks
return|;
block|}
comment|/**      * Tries to lock the given shards ID. A shard lock is required to perform any kind of      * write operation on a shards data directory like deleting files, creating a new index writer      * or recover from a different shard instance into it. If the shard lock can not be acquired      * an {@link LockObtainFailedException} is thrown.      *      * Note: this method will return immediately if the lock can't be acquired.      *      * @param id the shard ID to lock      * @return the shard lock. Call {@link ShardLock#close()} to release the lock      * @throws IOException if an IOException occurs.      */
DECL|method|shardLock
specifier|public
name|ShardLock
name|shardLock
parameter_list|(
name|ShardId
name|id
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|shardLock
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * Tries to lock the given shards ID. A shard lock is required to perform any kind of      * write operation on a shards data directory like deleting files, creating a new index writer      * or recover from a different shard instance into it. If the shard lock can not be acquired      * an {@link org.apache.lucene.store.LockObtainFailedException} is thrown      * @param id the shard ID to lock      * @param lockTimeoutMS the lock timeout in milliseconds      * @return the shard lock. Call {@link ShardLock#close()} to release the lock      * @throws IOException if an IOException occurs.      */
DECL|method|shardLock
specifier|public
name|ShardLock
name|shardLock
parameter_list|(
specifier|final
name|ShardId
name|id
parameter_list|,
name|long
name|lockTimeoutMS
parameter_list|)
throws|throws
name|IOException
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"acquiring node shardlock on [{}], timeout [{}]"
argument_list|,
name|id
argument_list|,
name|lockTimeoutMS
argument_list|)
expr_stmt|;
specifier|final
name|InternalShardLock
name|shardLock
decl_stmt|;
specifier|final
name|boolean
name|acquired
decl_stmt|;
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
if|if
condition|(
name|shardLocks
operator|.
name|containsKey
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|shardLock
operator|=
name|shardLocks
operator|.
name|get
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|shardLock
operator|.
name|incWaitCount
argument_list|()
expr_stmt|;
name|acquired
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|shardLock
operator|=
operator|new
name|InternalShardLock
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|shardLocks
operator|.
name|put
argument_list|(
name|id
argument_list|,
name|shardLock
argument_list|)
expr_stmt|;
name|acquired
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|acquired
operator|==
literal|false
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|shardLock
operator|.
name|acquire
argument_list|(
name|lockTimeoutMS
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|shardLock
operator|.
name|decWaitCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"successfully acquired shardlock for [{}]"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|new
name|ShardLock
argument_list|(
name|id
argument_list|)
block|{
comment|// new instance prevents double closing
annotation|@
name|Override
specifier|protected
name|void
name|closeInternal
parameter_list|()
block|{
name|shardLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"released shard lock for [{}]"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * Returns all currently lock shards      */
DECL|method|lockedShards
specifier|public
name|Set
argument_list|<
name|ShardId
argument_list|>
name|lockedShards
parameter_list|()
block|{
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
name|ImmutableSet
operator|.
name|Builder
argument_list|<
name|ShardId
argument_list|>
name|builder
init|=
name|ImmutableSet
operator|.
name|builder
argument_list|()
decl_stmt|;
return|return
name|builder
operator|.
name|addAll
argument_list|(
name|shardLocks
operator|.
name|keySet
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
DECL|class|InternalShardLock
specifier|private
specifier|final
class|class
name|InternalShardLock
block|{
comment|/*          * This class holds a mutex for exclusive access and timeout / wait semantics          * and a reference count to cleanup the shard lock instance form the internal data          * structure if nobody is waiting for it. the wait count is guarded by the same lock          * that is used to mutate the map holding the shard locks to ensure exclusive access          */
DECL|field|mutex
specifier|private
specifier|final
name|Semaphore
name|mutex
init|=
operator|new
name|Semaphore
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|waitCount
specifier|private
name|int
name|waitCount
init|=
literal|1
decl_stmt|;
comment|// guarded by shardLocks
DECL|field|shardId
specifier|private
name|ShardId
name|shardId
decl_stmt|;
DECL|method|InternalShardLock
name|InternalShardLock
parameter_list|(
name|ShardId
name|id
parameter_list|)
block|{
name|shardId
operator|=
name|id
expr_stmt|;
name|mutex
operator|.
name|acquireUninterruptibly
argument_list|()
expr_stmt|;
block|}
DECL|method|release
specifier|protected
name|void
name|release
parameter_list|()
block|{
name|mutex
operator|.
name|release
argument_list|()
expr_stmt|;
name|decWaitCount
argument_list|()
expr_stmt|;
block|}
DECL|method|incWaitCount
name|void
name|incWaitCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
assert|assert
name|waitCount
operator|>
literal|0
operator|:
literal|"waitCount is "
operator|+
name|waitCount
operator|+
literal|" but should be> 0"
assert|;
name|waitCount
operator|++
expr_stmt|;
block|}
block|}
DECL|method|decWaitCount
specifier|private
name|void
name|decWaitCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
assert|assert
name|waitCount
operator|>
literal|0
operator|:
literal|"waitCount is "
operator|+
name|waitCount
operator|+
literal|" but should be> 0"
assert|;
operator|--
name|waitCount
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"shard lock wait count for [{}] is now [{}]"
argument_list|,
name|shardId
argument_list|,
name|waitCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitCount
operator|==
literal|0
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"last shard lock wait decremented, removing lock for [{}]"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|InternalShardLock
name|remove
init|=
name|shardLocks
operator|.
name|remove
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
assert|assert
name|remove
operator|!=
literal|null
operator|:
literal|"Removed lock was null"
assert|;
block|}
block|}
block|}
DECL|method|acquire
name|void
name|acquire
parameter_list|(
name|long
name|timeoutInMillis
parameter_list|)
throws|throws
name|LockObtainFailedException
block|{
try|try
block|{
if|if
condition|(
name|mutex
operator|.
name|tryAcquire
argument_list|(
name|timeoutInMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Can't lock shard "
operator|+
name|shardId
operator|+
literal|", timed out after "
operator|+
name|timeoutInMillis
operator|+
literal|"ms"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Can't lock shard "
operator|+
name|shardId
operator|+
literal|", interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|localNodeId
specifier|public
name|int
name|localNodeId
parameter_list|()
block|{
return|return
name|this
operator|.
name|localNodeId
return|;
block|}
DECL|method|hasNodeFile
specifier|public
name|boolean
name|hasNodeFile
parameter_list|()
block|{
return|return
name|nodePaths
operator|!=
literal|null
operator|&&
name|locks
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns an array of all of the nodes data locations.      * @throws IllegalStateException if the node is not configured to store local locations      */
DECL|method|nodeDataPaths
specifier|public
name|Path
index|[]
name|nodeDataPaths
parameter_list|()
block|{
assert|assert
name|assertEnvIsLocked
argument_list|()
assert|;
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
name|Path
index|[]
name|paths
init|=
operator|new
name|Path
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|paths
index|[
name|i
index|]
operator|=
name|nodePaths
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
comment|/**      * Returns an array of all of the {@link NodePath}s.      */
DECL|method|nodePaths
specifier|public
name|NodePath
index|[]
name|nodePaths
parameter_list|()
block|{
assert|assert
name|assertEnvIsLocked
argument_list|()
assert|;
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
return|return
name|nodePaths
return|;
block|}
comment|/**      * Returns all index paths.      */
DECL|method|indexPaths
specifier|public
name|Path
index|[]
name|indexPaths
parameter_list|(
name|Index
name|index
parameter_list|)
block|{
assert|assert
name|assertEnvIsLocked
argument_list|()
assert|;
name|Path
index|[]
name|indexPaths
init|=
operator|new
name|Path
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodePaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|indexPaths
index|[
name|i
index|]
operator|=
name|nodePaths
index|[
name|i
index|]
operator|.
name|indicesPath
operator|.
name|resolve
argument_list|(
name|index
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|indexPaths
return|;
block|}
comment|/**      * Returns all shard paths excluding custom shard path. Note: Shards are only allocated on one of the      * returned paths. The returned array may contain paths to non-existing directories.      *      * @see #hasCustomDataPath(org.elasticsearch.common.settings.Settings)      * @see #resolveCustomLocation(org.elasticsearch.common.settings.Settings, org.elasticsearch.index.shard.ShardId)      *      */
DECL|method|availableShardPaths
specifier|public
name|Path
index|[]
name|availableShardPaths
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
assert|assert
name|assertEnvIsLocked
argument_list|()
assert|;
specifier|final
name|NodePath
index|[]
name|nodePaths
init|=
name|nodePaths
argument_list|()
decl_stmt|;
specifier|final
name|Path
index|[]
name|shardLocations
init|=
operator|new
name|Path
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodePaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|shardLocations
index|[
name|i
index|]
operator|=
name|nodePaths
index|[
name|i
index|]
operator|.
name|resolve
argument_list|(
name|shardId
argument_list|)
expr_stmt|;
block|}
return|return
name|shardLocations
return|;
block|}
DECL|method|findAllIndices
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|findAllIndices
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
assert|assert
name|assertEnvIsLocked
argument_list|()
assert|;
name|Set
argument_list|<
name|String
argument_list|>
name|indices
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|Path
name|indicesLocation
init|=
name|nodePath
operator|.
name|indicesPath
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|indicesLocation
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|indicesLocation
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|index
range|:
name|stream
control|)
block|{
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|indices
operator|.
name|add
argument_list|(
name|index
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|indices
return|;
block|}
comment|/**      * Tries to find all allocated shards for the given index      * on the current node. NOTE: This methods is prone to race-conditions on the filesystem layer since it might not      * see directories created concurrently or while it's traversing.      * @param index the index to filter shards      * @return a set of shard IDs      * @throws IOException if an IOException occurs      */
DECL|method|findAllShardIds
specifier|public
name|Set
argument_list|<
name|ShardId
argument_list|>
name|findAllShardIds
parameter_list|(
specifier|final
name|Index
name|index
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|index
operator|!=
literal|null
assert|;
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
assert|assert
name|assertEnvIsLocked
argument_list|()
assert|;
specifier|final
name|Set
argument_list|<
name|ShardId
argument_list|>
name|shardIds
init|=
name|Sets
operator|.
name|newHashSet
argument_list|()
decl_stmt|;
name|String
name|indexName
init|=
name|index
operator|.
name|name
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|Path
name|location
init|=
name|nodePath
operator|.
name|indicesPath
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|location
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|indexStream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|location
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|indexPath
range|:
name|indexStream
control|)
block|{
if|if
condition|(
name|indexName
operator|.
name|equals
argument_list|(
name|indexPath
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|shardIds
operator|.
name|addAll
argument_list|(
name|findAllShardsForIndex
argument_list|(
name|indexPath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|shardIds
return|;
block|}
DECL|method|findAllShardsForIndex
specifier|private
specifier|static
name|Set
argument_list|<
name|ShardId
argument_list|>
name|findAllShardsForIndex
parameter_list|(
name|Path
name|indexPath
parameter_list|)
throws|throws
name|IOException
block|{
name|Set
argument_list|<
name|ShardId
argument_list|>
name|shardIds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|indexPath
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|indexPath
argument_list|)
init|)
block|{
name|String
name|currentIndex
init|=
name|indexPath
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|shardPath
range|:
name|stream
control|)
block|{
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|shardPath
argument_list|)
condition|)
block|{
name|Integer
name|shardId
init|=
name|Ints
operator|.
name|tryParse
argument_list|(
name|shardPath
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
name|ShardId
name|id
init|=
operator|new
name|ShardId
argument_list|(
name|currentIndex
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|shardIds
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|shardIds
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
operator|&&
name|locks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Lock
name|lock
range|:
name|locks
control|)
block|{
try|try
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"releasing lock [{}]"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|lock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"failed to release lock [{}]"
argument_list|,
name|e
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|assertEnvIsLocked
specifier|private
name|boolean
name|assertEnvIsLocked
parameter_list|()
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
name|locks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Lock
name|lock
range|:
name|locks
control|)
block|{
try|try
block|{
assert|assert
name|lock
operator|.
name|isLocked
argument_list|()
operator|:
literal|"Lock: "
operator|+
name|lock
operator|+
literal|"is not locked"
assert|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"lock assertion failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * This method tries to write an empty file and moves it using an atomic move operation.      * This method throws an {@link IllegalStateException} if this operation is      * not supported by the filesystem. This test is executed on each of the data directories.      * This method cleans up all files even in the case of an error.      */
DECL|method|ensureAtomicMoveSupported
specifier|public
name|void
name|ensureAtomicMoveSupported
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|NodePath
index|[]
name|nodePaths
init|=
name|nodePaths
argument_list|()
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
assert|assert
name|Files
operator|.
name|isDirectory
argument_list|(
name|nodePath
operator|.
name|path
argument_list|)
operator|:
name|nodePath
operator|.
name|path
operator|+
literal|" is not a directory"
assert|;
specifier|final
name|Path
name|src
init|=
name|nodePath
operator|.
name|path
operator|.
name|resolve
argument_list|(
literal|"__es__.tmp"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createFile
argument_list|(
name|src
argument_list|)
expr_stmt|;
specifier|final
name|Path
name|target
init|=
name|nodePath
operator|.
name|path
operator|.
name|resolve
argument_list|(
literal|"__es__.final"
argument_list|)
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|move
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|StandardCopyOption
operator|.
name|ATOMIC_MOVE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AtomicMoveNotSupportedException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"atomic_move is not supported by the filesystem on path ["
operator|+
name|nodePath
operator|.
name|path
operator|+
literal|"] atomic_move is required for elasticsearch to work correctly."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getSettings
name|Settings
name|getSettings
parameter_list|()
block|{
comment|// for testing
return|return
name|settings
return|;
block|}
comment|/**      * @param indexSettings settings for an index      * @return true if the index has a custom data path      */
DECL|method|hasCustomDataPath
specifier|public
specifier|static
name|boolean
name|hasCustomDataPath
parameter_list|(
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|)
block|{
return|return
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_DATA_PATH
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Resolve the custom path for a index's shard.      * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine      * the root path for the index.      *      * @param indexSettings settings for the index      */
DECL|method|resolveCustomLocation
specifier|private
name|Path
name|resolveCustomLocation
parameter_list|(
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|)
block|{
assert|assert
name|indexSettings
operator|!=
name|Settings
operator|.
name|EMPTY
assert|;
name|String
name|customDataDir
init|=
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_DATA_PATH
argument_list|)
decl_stmt|;
if|if
condition|(
name|customDataDir
operator|!=
literal|null
condition|)
block|{
comment|// This assert is because this should be caught by MetaDataCreateIndexService
assert|assert
name|sharedDataPath
operator|!=
literal|null
assert|;
if|if
condition|(
name|addNodeId
condition|)
block|{
return|return
name|sharedDataPath
operator|.
name|resolve
argument_list|(
name|customDataDir
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|this
operator|.
name|localNodeId
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|sharedDataPath
operator|.
name|resolve
argument_list|(
name|customDataDir
argument_list|)
return|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no custom "
operator|+
name|IndexMetaData
operator|.
name|SETTING_DATA_PATH
operator|+
literal|" setting available"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Resolve the custom path for a index's shard.      * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine      * the root path for the index.      *      * @param indexSettings settings for the index      * @param indexName index to resolve the path for      */
DECL|method|resolveCustomLocation
specifier|private
name|Path
name|resolveCustomLocation
parameter_list|(
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|,
specifier|final
name|String
name|indexName
parameter_list|)
block|{
return|return
name|resolveCustomLocation
argument_list|(
name|indexSettings
argument_list|)
operator|.
name|resolve
argument_list|(
name|indexName
argument_list|)
return|;
block|}
comment|/**      * Resolve the custom path for a index's shard.      * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine      * the root path for the index.      *      * @param indexSettings settings for the index      * @param shardId shard to resolve the path to      */
DECL|method|resolveCustomLocation
specifier|public
name|Path
name|resolveCustomLocation
parameter_list|(
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|,
specifier|final
name|ShardId
name|shardId
parameter_list|)
block|{
return|return
name|resolveCustomLocation
argument_list|(
name|indexSettings
argument_list|,
name|shardId
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns the {@code NodePath.path} for this shard.      */
DECL|method|shardStatePathToDataPath
specifier|public
specifier|static
name|Path
name|shardStatePathToDataPath
parameter_list|(
name|Path
name|shardPath
parameter_list|)
block|{
name|int
name|count
init|=
name|shardPath
operator|.
name|getNameCount
argument_list|()
decl_stmt|;
comment|// Sanity check:
assert|assert
name|Integer
operator|.
name|parseInt
argument_list|(
name|shardPath
operator|.
name|getName
argument_list|(
name|count
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
operator|>=
literal|0
assert|;
assert|assert
literal|"indices"
operator|.
name|equals
argument_list|(
name|shardPath
operator|.
name|getName
argument_list|(
name|count
operator|-
literal|3
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
assert|;
return|return
name|shardPath
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
return|;
block|}
block|}
end_class

end_unit

