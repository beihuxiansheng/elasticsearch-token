begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.env
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|env
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Directory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|FSDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|NativeFSLockFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|SimpleFSDirectory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Randomness
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|SuppressForbidden
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|UUIDs
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|FileSystemUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|DeprecationLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|Loggers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|MetaDataStateFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|FsDirectoryService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|monitor
operator|.
name|fs
operator|.
name|FsInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|monitor
operator|.
name|fs
operator|.
name|FsProbe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|monitor
operator|.
name|jvm
operator|.
name|JvmInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|node
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|AtomicMoveNotSupportedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileStore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardCopyOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Semaphore
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableSet
import|;
end_import

begin_comment
comment|/**  * A component that holds all data paths for a single node.  */
end_comment

begin_class
DECL|class|NodeEnvironment
specifier|public
specifier|final
class|class
name|NodeEnvironment
implements|implements
name|Closeable
block|{
DECL|field|logger
specifier|private
specifier|final
name|ESLogger
name|logger
decl_stmt|;
DECL|class|NodePath
specifier|public
specifier|static
class|class
name|NodePath
block|{
comment|/* ${data.paths}/nodes/{node.id} */
DECL|field|path
specifier|public
specifier|final
name|Path
name|path
decl_stmt|;
comment|/* ${data.paths}/nodes/{node.id}/indices */
DECL|field|indicesPath
specifier|public
specifier|final
name|Path
name|indicesPath
decl_stmt|;
comment|/** Cached FileStore from path */
DECL|field|fileStore
specifier|public
specifier|final
name|FileStore
name|fileStore
decl_stmt|;
comment|/** Cached result of Lucene's {@code IOUtils.spins} on path.  This is a trilean value: null means we could not determine it (we are          *  not running on Linux, or we hit an exception trying), True means the device possibly spins and False means it does not. */
DECL|field|spins
specifier|public
specifier|final
name|Boolean
name|spins
decl_stmt|;
DECL|field|majorDeviceNumber
specifier|public
specifier|final
name|int
name|majorDeviceNumber
decl_stmt|;
DECL|field|minorDeviceNumber
specifier|public
specifier|final
name|int
name|minorDeviceNumber
decl_stmt|;
DECL|method|NodePath
specifier|public
name|NodePath
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|indicesPath
operator|=
name|path
operator|.
name|resolve
argument_list|(
name|INDICES_FOLDER
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileStore
operator|=
name|Environment
operator|.
name|getFileStore
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileStore
operator|.
name|supportsFileAttributeView
argument_list|(
literal|"lucene"
argument_list|)
condition|)
block|{
name|this
operator|.
name|spins
operator|=
operator|(
name|Boolean
operator|)
name|fileStore
operator|.
name|getAttribute
argument_list|(
literal|"lucene:spins"
argument_list|)
expr_stmt|;
name|this
operator|.
name|majorDeviceNumber
operator|=
operator|(
name|int
operator|)
name|fileStore
operator|.
name|getAttribute
argument_list|(
literal|"lucene:major_device_number"
argument_list|)
expr_stmt|;
name|this
operator|.
name|minorDeviceNumber
operator|=
operator|(
name|int
operator|)
name|fileStore
operator|.
name|getAttribute
argument_list|(
literal|"lucene:minor_device_number"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|spins
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|majorDeviceNumber
operator|=
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|minorDeviceNumber
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/**          * Resolves the given shards directory against this NodePath          * ${data.paths}/nodes/{node.id}/indices/{index.uuid}/{shard.id}          */
DECL|method|resolve
specifier|public
name|Path
name|resolve
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
return|return
name|resolve
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Resolves index directory against this NodePath          * ${data.paths}/nodes/{node.id}/indices/{index.uuid}          */
DECL|method|resolve
specifier|public
name|Path
name|resolve
parameter_list|(
name|Index
name|index
parameter_list|)
block|{
return|return
name|indicesPath
operator|.
name|resolve
argument_list|(
name|index
operator|.
name|getUUID
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"NodePath{"
operator|+
literal|"path="
operator|+
name|path
operator|+
literal|", spins="
operator|+
name|spins
operator|+
literal|'}'
return|;
block|}
block|}
DECL|field|nodePaths
specifier|private
specifier|final
name|NodePath
index|[]
name|nodePaths
decl_stmt|;
DECL|field|sharedDataPath
specifier|private
specifier|final
name|Path
name|sharedDataPath
decl_stmt|;
DECL|field|locks
specifier|private
specifier|final
name|Lock
index|[]
name|locks
decl_stmt|;
DECL|field|nodeLockId
specifier|private
specifier|final
name|int
name|nodeLockId
decl_stmt|;
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|shardLocks
specifier|private
specifier|final
name|Map
argument_list|<
name|ShardId
argument_list|,
name|InternalShardLock
argument_list|>
name|shardLocks
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|nodeMetaData
specifier|private
specifier|final
name|NodeMetaData
name|nodeMetaData
decl_stmt|;
comment|/**      * Maximum number of data nodes that should run in an environment.      */
DECL|field|MAX_LOCAL_STORAGE_NODES_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|MAX_LOCAL_STORAGE_NODES_SETTING
init|=
name|Setting
operator|.
name|intSetting
argument_list|(
literal|"node.max_local_storage_nodes"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
comment|/**      * If true automatically append node lock id to custom data paths.      */
DECL|field|ADD_NODE_LOCK_ID_TO_CUSTOM_PATH
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Boolean
argument_list|>
name|ADD_NODE_LOCK_ID_TO_CUSTOM_PATH
init|=
name|Setting
operator|.
name|boolSetting
argument_list|(
literal|"node.add_lock_id_to_custom_path"
argument_list|,
literal|true
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
comment|/**      * Seed for determining a persisted unique uuid of this node. If the node has already a persisted uuid on disk,      * this seed will be ignored and the uuid from disk will be reused.      */
DECL|field|NODE_ID_SEED_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Long
argument_list|>
name|NODE_ID_SEED_SETTING
init|=
name|Setting
operator|.
name|longSetting
argument_list|(
literal|"node.id.seed"
argument_list|,
literal|0L
argument_list|,
name|Long
operator|.
name|MIN_VALUE
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
comment|/**      * If true the [verbose] SegmentInfos.infoStream logging is sent to System.out.      */
DECL|field|ENABLE_LUCENE_SEGMENT_INFOS_TRACE_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Boolean
argument_list|>
name|ENABLE_LUCENE_SEGMENT_INFOS_TRACE_SETTING
init|=
name|Setting
operator|.
name|boolSetting
argument_list|(
literal|"node.enable_lucene_segment_infos_trace"
argument_list|,
literal|false
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|NODES_FOLDER
specifier|public
specifier|static
specifier|final
name|String
name|NODES_FOLDER
init|=
literal|"nodes"
decl_stmt|;
DECL|field|INDICES_FOLDER
specifier|public
specifier|static
specifier|final
name|String
name|INDICES_FOLDER
init|=
literal|"indices"
decl_stmt|;
DECL|field|NODE_LOCK_FILENAME
specifier|public
specifier|static
specifier|final
name|String
name|NODE_LOCK_FILENAME
init|=
literal|"node.lock"
decl_stmt|;
DECL|method|NodeEnvironment
specifier|public
name|NodeEnvironment
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|Environment
name|environment
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|DiscoveryNode
operator|.
name|nodeRequiresLocalStorage
argument_list|(
name|settings
argument_list|)
condition|)
block|{
name|nodePaths
operator|=
literal|null
expr_stmt|;
name|sharedDataPath
operator|=
literal|null
expr_stmt|;
name|locks
operator|=
literal|null
expr_stmt|;
name|nodeLockId
operator|=
operator|-
literal|1
expr_stmt|;
name|nodeMetaData
operator|=
operator|new
name|NodeMetaData
argument_list|(
name|generateNodeId
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|=
name|Loggers
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|,
name|Node
operator|.
name|addNodeNameIfNeeded
argument_list|(
name|settings
argument_list|,
name|this
operator|.
name|nodeMetaData
operator|.
name|nodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|NodePath
index|[]
name|nodePaths
init|=
operator|new
name|NodePath
index|[
name|environment
operator|.
name|dataWithClusterFiles
argument_list|()
operator|.
name|length
index|]
decl_stmt|;
specifier|final
name|Lock
index|[]
name|locks
init|=
operator|new
name|Lock
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
comment|// trace logger to debug issues before the default node name is derived from the node id
name|ESLogger
name|startupTraceLogger
init|=
name|Loggers
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|,
name|settings
argument_list|)
decl_stmt|;
try|try
block|{
name|sharedDataPath
operator|=
name|environment
operator|.
name|sharedDataFile
argument_list|()
expr_stmt|;
name|int
name|nodeLockId
init|=
operator|-
literal|1
decl_stmt|;
name|IOException
name|lastException
init|=
literal|null
decl_stmt|;
name|int
name|maxLocalStorageNodes
init|=
name|MAX_LOCAL_STORAGE_NODES_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|possibleLockId
init|=
literal|0
init|;
name|possibleLockId
operator|<
name|maxLocalStorageNodes
condition|;
name|possibleLockId
operator|++
control|)
block|{
for|for
control|(
name|int
name|dirIndex
init|=
literal|0
init|;
name|dirIndex
operator|<
name|environment
operator|.
name|dataFiles
argument_list|()
operator|.
name|length
condition|;
name|dirIndex
operator|++
control|)
block|{
name|Path
name|dataDirWithClusterName
init|=
name|environment
operator|.
name|dataWithClusterFiles
argument_list|()
index|[
name|dirIndex
index|]
decl_stmt|;
name|Path
name|dataDir
init|=
name|environment
operator|.
name|dataFiles
argument_list|()
index|[
name|dirIndex
index|]
decl_stmt|;
comment|// TODO: Remove this in 6.0, we are no longer going to read from the cluster name directory
if|if
condition|(
name|readFromDataPathWithClusterName
argument_list|(
name|dataDirWithClusterName
argument_list|)
condition|)
block|{
name|DeprecationLogger
name|deprecationLogger
init|=
operator|new
name|DeprecationLogger
argument_list|(
name|startupTraceLogger
argument_list|)
decl_stmt|;
name|deprecationLogger
operator|.
name|deprecated
argument_list|(
literal|"ES has detected the [path.data] folder using the cluster name as a folder [{}], "
operator|+
literal|"Elasticsearch 6.0 will not allow the cluster name as a folder within the data path"
argument_list|,
name|dataDir
argument_list|)
expr_stmt|;
name|dataDir
operator|=
name|dataDirWithClusterName
expr_stmt|;
block|}
name|Path
name|dir
init|=
name|dataDir
operator|.
name|resolve
argument_list|(
name|NODES_FOLDER
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|possibleLockId
argument_list|)
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|dir
argument_list|)
expr_stmt|;
try|try
init|(
name|Directory
name|luceneDir
init|=
name|FSDirectory
operator|.
name|open
argument_list|(
name|dir
argument_list|,
name|NativeFSLockFactory
operator|.
name|INSTANCE
argument_list|)
init|)
block|{
name|startupTraceLogger
operator|.
name|trace
argument_list|(
literal|"obtaining node lock on {} ..."
argument_list|,
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|locks
index|[
name|dirIndex
index|]
operator|=
name|luceneDir
operator|.
name|obtainLock
argument_list|(
name|NODE_LOCK_FILENAME
argument_list|)
expr_stmt|;
name|nodePaths
index|[
name|dirIndex
index|]
operator|=
operator|new
name|NodePath
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|nodeLockId
operator|=
name|possibleLockId
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockObtainFailedException
name|ex
parameter_list|)
block|{
name|startupTraceLogger
operator|.
name|trace
argument_list|(
literal|"failed to obtain node lock on {}"
argument_list|,
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
comment|// release all the ones that were obtained up until now
name|releaseAndNullLocks
argument_list|(
name|locks
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|startupTraceLogger
operator|.
name|trace
argument_list|(
literal|"failed to obtain node lock on {}"
argument_list|,
name|e
argument_list|,
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|lastException
operator|=
operator|new
name|IOException
argument_list|(
literal|"failed to obtain lock on "
operator|+
name|dir
operator|.
name|toAbsolutePath
argument_list|()
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// release all the ones that were obtained up until now
name|releaseAndNullLocks
argument_list|(
name|locks
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|locks
index|[
literal|0
index|]
operator|!=
literal|null
condition|)
block|{
comment|// we found a lock, break
break|break;
block|}
block|}
if|if
condition|(
name|locks
index|[
literal|0
index|]
operator|==
literal|null
condition|)
block|{
specifier|final
name|String
name|message
init|=
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"failed to obtain node locks, tried [%s] with lock id%s;"
operator|+
literal|" maybe these locations are not writable or multiple nodes were started without increasing [%s] (was [%d])?"
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|environment
operator|.
name|dataWithClusterFiles
argument_list|()
argument_list|)
argument_list|,
name|maxLocalStorageNodes
operator|==
literal|1
condition|?
literal|" [0]"
else|:
literal|"s [0--"
operator|+
operator|(
name|maxLocalStorageNodes
operator|-
literal|1
operator|)
operator|+
literal|"]"
argument_list|,
name|MAX_LOCAL_STORAGE_NODES_SETTING
operator|.
name|getKey
argument_list|()
argument_list|,
name|maxLocalStorageNodes
argument_list|)
decl_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|message
argument_list|,
name|lastException
argument_list|)
throw|;
block|}
name|this
operator|.
name|nodeMetaData
operator|=
name|loadOrCreateNodeMetaData
argument_list|(
name|settings
argument_list|,
name|startupTraceLogger
argument_list|,
name|nodePaths
argument_list|)
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|Loggers
operator|.
name|getLogger
argument_list|(
name|getClass
argument_list|()
argument_list|,
name|Node
operator|.
name|addNodeNameIfNeeded
argument_list|(
name|settings
argument_list|,
name|this
operator|.
name|nodeMetaData
operator|.
name|nodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeLockId
operator|=
name|nodeLockId
expr_stmt|;
name|this
operator|.
name|locks
operator|=
name|locks
expr_stmt|;
name|this
operator|.
name|nodePaths
operator|=
name|nodePaths
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"using node location [{}], local_lock_id [{}]"
argument_list|,
name|nodePaths
argument_list|,
name|nodeLockId
argument_list|)
expr_stmt|;
block|}
name|maybeLogPathDetails
argument_list|()
expr_stmt|;
name|maybeLogHeapDetails
argument_list|()
expr_stmt|;
name|applySegmentInfosTrace
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|assertCanWrite
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Returns true if the directory is empty */
DECL|method|dirEmpty
specifier|private
specifier|static
name|boolean
name|dirEmpty
parameter_list|(
specifier|final
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|path
argument_list|)
init|)
block|{
return|return
name|stream
operator|.
name|iterator
argument_list|()
operator|.
name|hasNext
argument_list|()
operator|==
literal|false
return|;
block|}
block|}
comment|// Visible for testing
comment|/** Returns true if data should be read from the data path that includes the cluster name (ie, it has data in it) */
DECL|method|readFromDataPathWithClusterName
specifier|static
name|boolean
name|readFromDataPathWithClusterName
parameter_list|(
name|Path
name|dataPathWithClusterName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|dataPathWithClusterName
argument_list|)
operator|==
literal|false
operator|||
comment|// If it doesn't exist
name|Files
operator|.
name|isDirectory
argument_list|(
name|dataPathWithClusterName
argument_list|)
operator|==
literal|false
operator|||
comment|// Or isn't a directory
name|dirEmpty
argument_list|(
name|dataPathWithClusterName
argument_list|)
condition|)
block|{
comment|// Or if it's empty
comment|// No need to read from cluster-name folder!
return|return
literal|false
return|;
block|}
comment|// The "nodes" directory inside of the cluster name
name|Path
name|nodesPath
init|=
name|dataPathWithClusterName
operator|.
name|resolve
argument_list|(
name|NODES_FOLDER
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|nodesPath
argument_list|)
condition|)
block|{
comment|// The cluster has data in the "nodes" so we should read from the cluster-named folder for now
return|return
literal|true
return|;
block|}
comment|// Hey the nodes directory didn't exist, so we can safely use whatever directory we feel appropriate
return|return
literal|false
return|;
block|}
DECL|method|releaseAndNullLocks
specifier|private
specifier|static
name|void
name|releaseAndNullLocks
parameter_list|(
name|Lock
index|[]
name|locks
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|locks
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|locks
index|[
name|i
index|]
operator|!=
literal|null
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|locks
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|maybeLogPathDetails
specifier|private
name|void
name|maybeLogPathDetails
parameter_list|()
throws|throws
name|IOException
block|{
comment|// We do some I/O in here, so skip this if DEBUG/INFO are not enabled:
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
comment|// Log one line per path.data:
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'\n'
argument_list|)
operator|.
name|append
argument_list|(
literal|" -> "
argument_list|)
operator|.
name|append
argument_list|(
name|nodePath
operator|.
name|path
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|spinsDesc
decl_stmt|;
if|if
condition|(
name|nodePath
operator|.
name|spins
operator|==
literal|null
condition|)
block|{
name|spinsDesc
operator|=
literal|"unknown"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nodePath
operator|.
name|spins
condition|)
block|{
name|spinsDesc
operator|=
literal|"possibly"
expr_stmt|;
block|}
else|else
block|{
name|spinsDesc
operator|=
literal|"no"
expr_stmt|;
block|}
name|FsInfo
operator|.
name|Path
name|fsPath
init|=
name|FsProbe
operator|.
name|getFSInfo
argument_list|(
name|nodePath
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|", free_space ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getFree
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], usable_space ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getAvailable
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], total_space ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getTotal
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], spins? ["
argument_list|)
operator|.
name|append
argument_list|(
name|spinsDesc
argument_list|)
operator|.
name|append
argument_list|(
literal|"], mount ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getMount
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"], type ["
argument_list|)
operator|.
name|append
argument_list|(
name|fsPath
operator|.
name|getType
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"node data locations details:{}"
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isInfoEnabled
argument_list|()
condition|)
block|{
name|FsInfo
operator|.
name|Path
name|totFSPath
init|=
operator|new
name|FsInfo
operator|.
name|Path
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allTypes
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allSpins
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|allMounts
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|FsInfo
operator|.
name|Path
name|fsPath
init|=
name|FsProbe
operator|.
name|getFSInfo
argument_list|(
name|nodePath
argument_list|)
decl_stmt|;
name|String
name|mount
init|=
name|fsPath
operator|.
name|getMount
argument_list|()
decl_stmt|;
if|if
condition|(
name|allMounts
operator|.
name|contains
argument_list|(
name|mount
argument_list|)
operator|==
literal|false
condition|)
block|{
name|allMounts
operator|.
name|add
argument_list|(
name|mount
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|fsPath
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|type
operator|!=
literal|null
condition|)
block|{
name|allTypes
operator|.
name|add
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|Boolean
name|spins
init|=
name|fsPath
operator|.
name|getSpins
argument_list|()
decl_stmt|;
if|if
condition|(
name|spins
operator|==
literal|null
condition|)
block|{
name|allSpins
operator|.
name|add
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|.
name|booleanValue
argument_list|()
condition|)
block|{
name|allSpins
operator|.
name|add
argument_list|(
literal|"possibly"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allSpins
operator|.
name|add
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
block|}
name|totFSPath
operator|.
name|add
argument_list|(
name|fsPath
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Just log a 1-line summary:
name|logger
operator|.
name|info
argument_list|(
literal|"using [{}] data paths, mounts [{}], net usable_space [{}], net total_space [{}], spins? [{}], types [{}]"
argument_list|,
name|nodePaths
operator|.
name|length
argument_list|,
name|allMounts
argument_list|,
name|totFSPath
operator|.
name|getAvailable
argument_list|()
argument_list|,
name|totFSPath
operator|.
name|getTotal
argument_list|()
argument_list|,
name|toString
argument_list|(
name|allSpins
argument_list|)
argument_list|,
name|toString
argument_list|(
name|allTypes
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|maybeLogHeapDetails
specifier|private
name|void
name|maybeLogHeapDetails
parameter_list|()
block|{
name|JvmInfo
name|jvmInfo
init|=
name|JvmInfo
operator|.
name|jvmInfo
argument_list|()
decl_stmt|;
name|ByteSizeValue
name|maxHeapSize
init|=
name|jvmInfo
operator|.
name|getMem
argument_list|()
operator|.
name|getHeapMax
argument_list|()
decl_stmt|;
name|String
name|useCompressedOops
init|=
name|jvmInfo
operator|.
name|useCompressedOops
argument_list|()
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"heap size [{}], compressed ordinary object pointers [{}]"
argument_list|,
name|maxHeapSize
argument_list|,
name|useCompressedOops
argument_list|)
expr_stmt|;
block|}
comment|/**      * scans the node paths and loads existing metaData file. If not found a new meta data will be generated      * and persisted into the nodePaths      */
DECL|method|loadOrCreateNodeMetaData
specifier|private
specifier|static
name|NodeMetaData
name|loadOrCreateNodeMetaData
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|ESLogger
name|logger
parameter_list|,
name|NodePath
modifier|...
name|nodePaths
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
index|[]
name|paths
init|=
name|Arrays
operator|.
name|stream
argument_list|(
name|nodePaths
argument_list|)
operator|.
name|map
argument_list|(
name|np
lambda|->
name|np
operator|.
name|path
argument_list|)
operator|.
name|toArray
argument_list|(
name|Path
index|[]
operator|::
operator|new
argument_list|)
decl_stmt|;
name|NodeMetaData
name|metaData
init|=
name|NodeMetaData
operator|.
name|FORMAT
operator|.
name|loadLatestState
argument_list|(
name|logger
argument_list|,
name|paths
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaData
operator|==
literal|null
condition|)
block|{
name|metaData
operator|=
operator|new
name|NodeMetaData
argument_list|(
name|generateNodeId
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// we write again to make sure all paths have the latest state file
name|NodeMetaData
operator|.
name|FORMAT
operator|.
name|write
argument_list|(
name|metaData
argument_list|,
name|paths
argument_list|)
expr_stmt|;
return|return
name|metaData
return|;
block|}
DECL|method|generateNodeId
specifier|public
specifier|static
name|String
name|generateNodeId
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|Random
name|random
init|=
name|Randomness
operator|.
name|get
argument_list|(
name|settings
argument_list|,
name|NODE_ID_SEED_SETTING
argument_list|)
decl_stmt|;
return|return
name|UUIDs
operator|.
name|randomBase64UUID
argument_list|(
name|random
argument_list|)
return|;
block|}
annotation|@
name|SuppressForbidden
argument_list|(
name|reason
operator|=
literal|"System.out.*"
argument_list|)
DECL|method|applySegmentInfosTrace
specifier|static
name|void
name|applySegmentInfosTrace
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
if|if
condition|(
name|ENABLE_LUCENE_SEGMENT_INFOS_TRACE_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
condition|)
block|{
name|SegmentInfos
operator|.
name|setInfoStream
argument_list|(
name|System
operator|.
name|out
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString
specifier|private
specifier|static
name|String
name|toString
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|items
parameter_list|)
block|{
name|StringBuilder
name|b
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|item
range|:
name|items
control|)
block|{
if|if
condition|(
name|b
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|b
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Deletes a shard data directory iff the shards locks were successfully acquired.      *      * @param shardId the id of the shard to delete to delete      * @throws IOException if an IOException occurs      */
DECL|method|deleteShardDirectorySafe
specifier|public
name|void
name|deleteShardDirectorySafe
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
index|[]
name|paths
init|=
name|availableShardPaths
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting shard {} directory, paths: [{}]"
argument_list|,
name|shardId
argument_list|,
name|paths
argument_list|)
expr_stmt|;
try|try
init|(
name|ShardLock
name|lock
init|=
name|shardLock
argument_list|(
name|shardId
argument_list|)
init|)
block|{
name|deleteShardDirectoryUnderLock
argument_list|(
name|lock
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Acquires, then releases, all {@code write.lock} files in the given      * shard paths. The "write.lock" file is assumed to be under the shard      * path's "index" directory as used by Elasticsearch.      *      * @throws LockObtainFailedException if any of the locks could not be acquired      */
DECL|method|acquireFSLockForPaths
specifier|public
specifier|static
name|void
name|acquireFSLockForPaths
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|,
name|Path
modifier|...
name|shardPaths
parameter_list|)
throws|throws
name|IOException
block|{
name|Lock
index|[]
name|locks
init|=
operator|new
name|Lock
index|[
name|shardPaths
operator|.
name|length
index|]
decl_stmt|;
name|Directory
index|[]
name|dirs
init|=
operator|new
name|Directory
index|[
name|shardPaths
operator|.
name|length
index|]
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|shardPaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// resolve the directory the shard actually lives in
name|Path
name|p
init|=
name|shardPaths
index|[
name|i
index|]
operator|.
name|resolve
argument_list|(
literal|"index"
argument_list|)
decl_stmt|;
comment|// open a directory (will be immediately closed) on the shard's location
name|dirs
index|[
name|i
index|]
operator|=
operator|new
name|SimpleFSDirectory
argument_list|(
name|p
argument_list|,
name|indexSettings
operator|.
name|getValue
argument_list|(
name|FsDirectoryService
operator|.
name|INDEX_LOCK_FACTOR_SETTING
argument_list|)
argument_list|)
expr_stmt|;
comment|// create a lock for the "write.lock" file
try|try
block|{
name|locks
index|[
name|i
index|]
operator|=
name|dirs
index|[
name|i
index|]
operator|.
name|obtainLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"unable to acquire "
operator|+
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
operator|+
literal|" for "
operator|+
name|p
argument_list|)
throw|;
block|}
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Deletes a shard data directory. Note: this method assumes that the shard      * lock is acquired. This method will also attempt to acquire the write      * locks for the shard's paths before deleting the data, but this is best      * effort, as the lock is released before the deletion happens in order to      * allow the folder to be deleted      *      * @param lock the shards lock      * @throws IOException if an IOException occurs      * @throws ElasticsearchException if the write.lock is not acquirable      */
DECL|method|deleteShardDirectoryUnderLock
specifier|public
name|void
name|deleteShardDirectoryUnderLock
parameter_list|(
name|ShardLock
name|lock
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ShardId
name|shardId
init|=
name|lock
operator|.
name|getShardId
argument_list|()
decl_stmt|;
assert|assert
name|isShardLocked
argument_list|(
name|shardId
argument_list|)
operator|:
literal|"shard "
operator|+
name|shardId
operator|+
literal|" is not locked"
assert|;
specifier|final
name|Path
index|[]
name|paths
init|=
name|availableShardPaths
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"acquiring locks for {}, paths: [{}]"
argument_list|,
name|shardId
argument_list|,
name|paths
argument_list|)
expr_stmt|;
name|acquireFSLockForPaths
argument_list|(
name|indexSettings
argument_list|,
name|paths
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexSettings
operator|.
name|hasCustomDataPath
argument_list|()
condition|)
block|{
name|Path
name|customLocation
init|=
name|resolveCustomLocation
argument_list|(
name|indexSettings
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"acquiring lock for {}, custom path: [{}]"
argument_list|,
name|shardId
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|acquireFSLockForPaths
argument_list|(
name|indexSettings
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting custom shard {} directory [{}]"
argument_list|,
name|shardId
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|customLocation
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"deleted shard {} directory, paths: [{}]"
argument_list|,
name|shardId
argument_list|,
name|paths
argument_list|)
expr_stmt|;
assert|assert
name|FileSystemUtils
operator|.
name|exists
argument_list|(
name|paths
argument_list|)
operator|==
literal|false
assert|;
block|}
DECL|method|isShardLocked
specifier|private
name|boolean
name|isShardLocked
parameter_list|(
name|ShardId
name|id
parameter_list|)
block|{
try|try
block|{
name|shardLock
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
operator|.
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Deletes an indexes data directory recursively iff all of the indexes      * shards locks were successfully acquired. If any of the indexes shard directories can't be locked      * non of the shards will be deleted      *      * @param index the index to delete      * @param lockTimeoutMS how long to wait for acquiring the indices shard locks      * @param indexSettings settings for the index being deleted      * @throws IOException if any of the shards data directories can't be locked or deleted      */
DECL|method|deleteIndexDirectorySafe
specifier|public
name|void
name|deleteIndexDirectorySafe
parameter_list|(
name|Index
name|index
parameter_list|,
name|long
name|lockTimeoutMS
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|List
argument_list|<
name|ShardLock
argument_list|>
name|locks
init|=
name|lockAllForIndex
argument_list|(
name|index
argument_list|,
name|indexSettings
argument_list|,
name|lockTimeoutMS
argument_list|)
decl_stmt|;
try|try
block|{
name|deleteIndexDirectoryUnderLock
argument_list|(
name|index
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|locks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Deletes an indexes data directory recursively.      * Note: this method assumes that the shard lock is acquired      *      * @param index the index to delete      * @param indexSettings settings for the index being deleted      */
DECL|method|deleteIndexDirectoryUnderLock
specifier|public
name|void
name|deleteIndexDirectoryUnderLock
parameter_list|(
name|Index
name|index
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Path
index|[]
name|indexPaths
init|=
name|indexPaths
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting index {} directory, paths({}): [{}]"
argument_list|,
name|index
argument_list|,
name|indexPaths
operator|.
name|length
argument_list|,
name|indexPaths
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|indexPaths
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexSettings
operator|.
name|hasCustomDataPath
argument_list|()
condition|)
block|{
name|Path
name|customLocation
init|=
name|resolveIndexCustomLocation
argument_list|(
name|indexSettings
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"deleting custom index {} directory [{}]"
argument_list|,
name|index
argument_list|,
name|customLocation
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|rm
argument_list|(
name|customLocation
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tries to lock all local shards for the given index. If any of the shard locks can't be acquired      * an {@link LockObtainFailedException} is thrown and all previously acquired locks are released.      *      * @param index the index to lock shards for      * @param lockTimeoutMS how long to wait for acquiring the indices shard locks      * @return the {@link ShardLock} instances for this index.      * @throws IOException if an IOException occurs.      */
DECL|method|lockAllForIndex
specifier|public
name|List
argument_list|<
name|ShardLock
argument_list|>
name|lockAllForIndex
parameter_list|(
name|Index
name|index
parameter_list|,
name|IndexSettings
name|settings
parameter_list|,
name|long
name|lockTimeoutMS
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|numShards
init|=
name|settings
operator|.
name|getNumberOfShards
argument_list|()
decl_stmt|;
if|if
condition|(
name|numShards
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"settings must contain a non-null> 0 number of shards"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"locking all shards for index {} - [{}]"
argument_list|,
name|index
argument_list|,
name|numShards
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ShardLock
argument_list|>
name|allLocks
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|numShards
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|long
name|startTimeNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numShards
condition|;
name|i
operator|++
control|)
block|{
name|long
name|timeoutLeftMS
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|lockTimeoutMS
operator|-
name|TimeValue
operator|.
name|nsecToMSec
argument_list|(
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTimeNS
operator|)
argument_list|)
argument_list|)
decl_stmt|;
name|allLocks
operator|.
name|add
argument_list|(
name|shardLock
argument_list|(
operator|new
name|ShardId
argument_list|(
name|index
argument_list|,
name|i
argument_list|)
argument_list|,
name|timeoutLeftMS
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"unable to lock all shards for index {}"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|allLocks
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|allLocks
return|;
block|}
comment|/**      * Tries to lock the given shards ID. A shard lock is required to perform any kind of      * write operation on a shards data directory like deleting files, creating a new index writer      * or recover from a different shard instance into it. If the shard lock can not be acquired      * an {@link LockObtainFailedException} is thrown.      *      * Note: this method will return immediately if the lock can't be acquired.      *      * @param id the shard ID to lock      * @return the shard lock. Call {@link ShardLock#close()} to release the lock      * @throws IOException if an IOException occurs.      */
DECL|method|shardLock
specifier|public
name|ShardLock
name|shardLock
parameter_list|(
name|ShardId
name|id
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|shardLock
argument_list|(
name|id
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * Tries to lock the given shards ID. A shard lock is required to perform any kind of      * write operation on a shards data directory like deleting files, creating a new index writer      * or recover from a different shard instance into it. If the shard lock can not be acquired      * an {@link org.apache.lucene.store.LockObtainFailedException} is thrown      * @param shardId the shard ID to lock      * @param lockTimeoutMS the lock timeout in milliseconds      * @return the shard lock. Call {@link ShardLock#close()} to release the lock      * @throws IOException if an IOException occurs.      */
DECL|method|shardLock
specifier|public
name|ShardLock
name|shardLock
parameter_list|(
specifier|final
name|ShardId
name|shardId
parameter_list|,
name|long
name|lockTimeoutMS
parameter_list|)
throws|throws
name|IOException
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"acquiring node shardlock on [{}], timeout [{}]"
argument_list|,
name|shardId
argument_list|,
name|lockTimeoutMS
argument_list|)
expr_stmt|;
specifier|final
name|InternalShardLock
name|shardLock
decl_stmt|;
specifier|final
name|boolean
name|acquired
decl_stmt|;
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
if|if
condition|(
name|shardLocks
operator|.
name|containsKey
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
name|shardLock
operator|=
name|shardLocks
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
expr_stmt|;
name|shardLock
operator|.
name|incWaitCount
argument_list|()
expr_stmt|;
name|acquired
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|shardLock
operator|=
operator|new
name|InternalShardLock
argument_list|(
name|shardId
argument_list|)
expr_stmt|;
name|shardLocks
operator|.
name|put
argument_list|(
name|shardId
argument_list|,
name|shardLock
argument_list|)
expr_stmt|;
name|acquired
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|acquired
operator|==
literal|false
condition|)
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|shardLock
operator|.
name|acquire
argument_list|(
name|lockTimeoutMS
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|shardLock
operator|.
name|decWaitCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"successfully acquired shardlock for [{}]"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
return|return
operator|new
name|ShardLock
argument_list|(
name|shardId
argument_list|)
block|{
comment|// new instance prevents double closing
annotation|@
name|Override
specifier|protected
name|void
name|closeInternal
parameter_list|()
block|{
name|shardLock
operator|.
name|release
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"released shard lock for [{}]"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
block|}
return|;
block|}
comment|/**      * A functional interface that people can use to reference {@link #shardLock(ShardId, long)}      */
annotation|@
name|FunctionalInterface
DECL|interface|ShardLocker
specifier|public
interface|interface
name|ShardLocker
block|{
DECL|method|lock
name|ShardLock
name|lock
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|long
name|lockTimeoutMS
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
comment|/**      * Returns all currently lock shards.      *      * Note: the shard ids return do not contain a valid Index UUID      */
DECL|method|lockedShards
specifier|public
name|Set
argument_list|<
name|ShardId
argument_list|>
name|lockedShards
parameter_list|()
block|{
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
return|return
name|unmodifiableSet
argument_list|(
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|shardLocks
operator|.
name|keySet
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|class|InternalShardLock
specifier|private
specifier|final
class|class
name|InternalShardLock
block|{
comment|/*          * This class holds a mutex for exclusive access and timeout / wait semantics          * and a reference count to cleanup the shard lock instance form the internal data          * structure if nobody is waiting for it. the wait count is guarded by the same lock          * that is used to mutate the map holding the shard locks to ensure exclusive access          */
DECL|field|mutex
specifier|private
specifier|final
name|Semaphore
name|mutex
init|=
operator|new
name|Semaphore
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|waitCount
specifier|private
name|int
name|waitCount
init|=
literal|1
decl_stmt|;
comment|// guarded by shardLocks
DECL|field|shardId
specifier|private
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|method|InternalShardLock
name|InternalShardLock
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|mutex
operator|.
name|acquireUninterruptibly
argument_list|()
expr_stmt|;
block|}
DECL|method|release
specifier|protected
name|void
name|release
parameter_list|()
block|{
name|mutex
operator|.
name|release
argument_list|()
expr_stmt|;
name|decWaitCount
argument_list|()
expr_stmt|;
block|}
DECL|method|incWaitCount
name|void
name|incWaitCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
assert|assert
name|waitCount
operator|>
literal|0
operator|:
literal|"waitCount is "
operator|+
name|waitCount
operator|+
literal|" but should be> 0"
assert|;
name|waitCount
operator|++
expr_stmt|;
block|}
block|}
DECL|method|decWaitCount
specifier|private
name|void
name|decWaitCount
parameter_list|()
block|{
synchronized|synchronized
init|(
name|shardLocks
init|)
block|{
assert|assert
name|waitCount
operator|>
literal|0
operator|:
literal|"waitCount is "
operator|+
name|waitCount
operator|+
literal|" but should be> 0"
assert|;
operator|--
name|waitCount
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"shard lock wait count for {} is now [{}]"
argument_list|,
name|shardId
argument_list|,
name|waitCount
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitCount
operator|==
literal|0
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"last shard lock wait decremented, removing lock for {}"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|InternalShardLock
name|remove
init|=
name|shardLocks
operator|.
name|remove
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
assert|assert
name|remove
operator|!=
literal|null
operator|:
literal|"Removed lock was null"
assert|;
block|}
block|}
block|}
DECL|method|acquire
name|void
name|acquire
parameter_list|(
name|long
name|timeoutInMillis
parameter_list|)
throws|throws
name|LockObtainFailedException
block|{
try|try
block|{
if|if
condition|(
name|mutex
operator|.
name|tryAcquire
argument_list|(
name|timeoutInMillis
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Can't lock shard "
operator|+
name|shardId
operator|+
literal|", timed out after "
operator|+
name|timeoutInMillis
operator|+
literal|"ms"
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|LockObtainFailedException
argument_list|(
literal|"Can't lock shard "
operator|+
name|shardId
operator|+
literal|", interrupted"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|hasNodeFile
specifier|public
name|boolean
name|hasNodeFile
parameter_list|()
block|{
return|return
name|nodePaths
operator|!=
literal|null
operator|&&
name|locks
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns an array of all of the nodes data locations.      * @throws IllegalStateException if the node is not configured to store local locations      */
DECL|method|nodeDataPaths
specifier|public
name|Path
index|[]
name|nodeDataPaths
parameter_list|()
block|{
name|assertEnvIsLocked
argument_list|()
expr_stmt|;
name|Path
index|[]
name|paths
init|=
operator|new
name|Path
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|paths
index|[
name|i
index|]
operator|=
name|nodePaths
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
block|}
return|return
name|paths
return|;
block|}
comment|/**      * returns the unique uuid describing this node. The uuid is persistent in the data folder of this node      * and remains across restarts.      **/
DECL|method|nodeId
specifier|public
name|String
name|nodeId
parameter_list|()
block|{
comment|// we currently only return the ID and hide the underlying nodeMetaData implementation in order to avoid
comment|// confusion with other "metadata" like node settings found in elasticsearch.yml. In future
comment|// we can encapsulate both (and more) in one NodeMetaData (or NodeSettings) object ala IndexSettings
return|return
name|nodeMetaData
operator|.
name|nodeId
argument_list|()
return|;
block|}
comment|/**      * Returns an array of all of the {@link NodePath}s.      */
DECL|method|nodePaths
specifier|public
name|NodePath
index|[]
name|nodePaths
parameter_list|()
block|{
name|assertEnvIsLocked
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
return|return
name|nodePaths
return|;
block|}
comment|/**      * Returns all index paths.      */
DECL|method|indexPaths
specifier|public
name|Path
index|[]
name|indexPaths
parameter_list|(
name|Index
name|index
parameter_list|)
block|{
name|assertEnvIsLocked
argument_list|()
expr_stmt|;
name|Path
index|[]
name|indexPaths
init|=
operator|new
name|Path
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodePaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|indexPaths
index|[
name|i
index|]
operator|=
name|nodePaths
index|[
name|i
index|]
operator|.
name|resolve
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
return|return
name|indexPaths
return|;
block|}
comment|/**      * Returns all shard paths excluding custom shard path. Note: Shards are only allocated on one of the      * returned paths. The returned array may contain paths to non-existing directories.      *      * @see IndexSettings#hasCustomDataPath()      * @see #resolveCustomLocation(IndexSettings, ShardId)      *      */
DECL|method|availableShardPaths
specifier|public
name|Path
index|[]
name|availableShardPaths
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
name|assertEnvIsLocked
argument_list|()
expr_stmt|;
specifier|final
name|NodePath
index|[]
name|nodePaths
init|=
name|nodePaths
argument_list|()
decl_stmt|;
specifier|final
name|Path
index|[]
name|shardLocations
init|=
operator|new
name|Path
index|[
name|nodePaths
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nodePaths
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|shardLocations
index|[
name|i
index|]
operator|=
name|nodePaths
index|[
name|i
index|]
operator|.
name|resolve
argument_list|(
name|shardId
argument_list|)
expr_stmt|;
block|}
return|return
name|shardLocations
return|;
block|}
comment|/**      * Returns all folder names in ${data.paths}/nodes/{node.id}/indices folder      */
DECL|method|availableIndexFolders
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|availableIndexFolders
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
name|assertEnvIsLocked
argument_list|()
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|indexFolders
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|Path
name|indicesLocation
init|=
name|nodePath
operator|.
name|indicesPath
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|indicesLocation
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|indicesLocation
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|index
range|:
name|stream
control|)
block|{
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|indexFolders
operator|.
name|add
argument_list|(
name|index
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|indexFolders
return|;
block|}
comment|/**      * Resolves all existing paths to<code>indexFolderName</code> in ${data.paths}/nodes/{node.id}/indices      */
DECL|method|resolveIndexFolder
specifier|public
name|Path
index|[]
name|resolveIndexFolder
parameter_list|(
name|String
name|indexFolderName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
name|assertEnvIsLocked
argument_list|()
expr_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|nodePaths
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|Path
name|indexFolder
init|=
name|nodePath
operator|.
name|indicesPath
operator|.
name|resolve
argument_list|(
name|indexFolderName
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|indexFolder
argument_list|)
condition|)
block|{
name|paths
operator|.
name|add
argument_list|(
name|indexFolder
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|paths
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
name|paths
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Tries to find all allocated shards for the given index      * on the current node. NOTE: This methods is prone to race-conditions on the filesystem layer since it might not      * see directories created concurrently or while it's traversing.      * @param index the index to filter shards      * @return a set of shard IDs      * @throws IOException if an IOException occurs      */
DECL|method|findAllShardIds
specifier|public
name|Set
argument_list|<
name|ShardId
argument_list|>
name|findAllShardIds
parameter_list|(
specifier|final
name|Index
name|index
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|index
operator|!=
literal|null
assert|;
if|if
condition|(
name|nodePaths
operator|==
literal|null
operator|||
name|locks
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"node is not configured to store local location"
argument_list|)
throw|;
block|}
name|assertEnvIsLocked
argument_list|()
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|ShardId
argument_list|>
name|shardIds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|String
name|indexUniquePathId
init|=
name|index
operator|.
name|getUUID
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
name|Path
name|location
init|=
name|nodePath
operator|.
name|indicesPath
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|location
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|indexStream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|location
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|indexPath
range|:
name|indexStream
control|)
block|{
if|if
condition|(
name|indexUniquePathId
operator|.
name|equals
argument_list|(
name|indexPath
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|shardIds
operator|.
name|addAll
argument_list|(
name|findAllShardsForIndex
argument_list|(
name|indexPath
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|shardIds
return|;
block|}
DECL|method|findAllShardsForIndex
specifier|private
specifier|static
name|Set
argument_list|<
name|ShardId
argument_list|>
name|findAllShardsForIndex
parameter_list|(
name|Path
name|indexPath
parameter_list|,
name|Index
name|index
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|indexPath
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
name|index
operator|.
name|getUUID
argument_list|()
argument_list|)
assert|;
name|Set
argument_list|<
name|ShardId
argument_list|>
name|shardIds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|indexPath
argument_list|)
condition|)
block|{
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|indexPath
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|shardPath
range|:
name|stream
control|)
block|{
name|String
name|fileName
init|=
name|shardPath
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|shardPath
argument_list|)
operator|&&
name|fileName
operator|.
name|chars
argument_list|()
operator|.
name|allMatch
argument_list|(
name|Character
operator|::
name|isDigit
argument_list|)
condition|)
block|{
name|int
name|shardId
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|ShardId
name|id
init|=
operator|new
name|ShardId
argument_list|(
name|index
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|shardIds
operator|.
name|add
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|shardIds
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
operator|&&
name|locks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Lock
name|lock
range|:
name|locks
control|)
block|{
try|try
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"releasing lock [{}]"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|lock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"failed to release lock [{}]"
argument_list|,
name|e
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|assertEnvIsLocked
specifier|private
name|void
name|assertEnvIsLocked
parameter_list|()
block|{
if|if
condition|(
operator|!
name|closed
operator|.
name|get
argument_list|()
operator|&&
name|locks
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Lock
name|lock
range|:
name|locks
control|)
block|{
try|try
block|{
name|lock
operator|.
name|ensureValid
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"lock assertion failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"environment is not locked"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * This method tries to write an empty file and moves it using an atomic move operation.      * This method throws an {@link IllegalStateException} if this operation is      * not supported by the filesystem. This test is executed on each of the data directories.      * This method cleans up all files even in the case of an error.      */
DECL|method|ensureAtomicMoveSupported
specifier|public
name|void
name|ensureAtomicMoveSupported
parameter_list|()
throws|throws
name|IOException
block|{
specifier|final
name|NodePath
index|[]
name|nodePaths
init|=
name|nodePaths
argument_list|()
decl_stmt|;
for|for
control|(
name|NodePath
name|nodePath
range|:
name|nodePaths
control|)
block|{
assert|assert
name|Files
operator|.
name|isDirectory
argument_list|(
name|nodePath
operator|.
name|path
argument_list|)
operator|:
name|nodePath
operator|.
name|path
operator|+
literal|" is not a directory"
assert|;
specifier|final
name|Path
name|src
init|=
name|nodePath
operator|.
name|path
operator|.
name|resolve
argument_list|(
literal|"__es__.tmp"
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|target
init|=
name|nodePath
operator|.
name|path
operator|.
name|resolve
argument_list|(
literal|"__es__.final"
argument_list|)
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|createFile
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|Files
operator|.
name|move
argument_list|(
name|src
argument_list|,
name|target
argument_list|,
name|StandardCopyOption
operator|.
name|ATOMIC_MOVE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AtomicMoveNotSupportedException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"atomic_move is not supported by the filesystem on path ["
operator|+
name|nodePath
operator|.
name|path
operator|+
literal|"] atomic_move is required for elasticsearch to work correctly."
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Resolve the custom path for a index's shard.      * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine      * the root path for the index.      *      * @param indexSettings settings for the index      */
DECL|method|resolveBaseCustomLocation
specifier|public
name|Path
name|resolveBaseCustomLocation
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|)
block|{
name|String
name|customDataDir
init|=
name|indexSettings
operator|.
name|customDataPath
argument_list|()
decl_stmt|;
if|if
condition|(
name|customDataDir
operator|!=
literal|null
condition|)
block|{
comment|// This assert is because this should be caught by MetaDataCreateIndexService
assert|assert
name|sharedDataPath
operator|!=
literal|null
assert|;
if|if
condition|(
name|ADD_NODE_LOCK_ID_TO_CUSTOM_PATH
operator|.
name|get
argument_list|(
name|indexSettings
operator|.
name|getNodeSettings
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|sharedDataPath
operator|.
name|resolve
argument_list|(
name|customDataDir
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|this
operator|.
name|nodeLockId
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|sharedDataPath
operator|.
name|resolve
argument_list|(
name|customDataDir
argument_list|)
return|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no custom "
operator|+
name|IndexMetaData
operator|.
name|SETTING_DATA_PATH
operator|+
literal|" setting available"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Resolve the custom path for a index's shard.      * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine      * the root path for the index.      *      * @param indexSettings settings for the index      */
DECL|method|resolveIndexCustomLocation
specifier|private
name|Path
name|resolveIndexCustomLocation
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|)
block|{
return|return
name|resolveBaseCustomLocation
argument_list|(
name|indexSettings
argument_list|)
operator|.
name|resolve
argument_list|(
name|indexSettings
operator|.
name|getUUID
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Resolve the custom path for a index's shard.      * Uses the {@code IndexMetaData.SETTING_DATA_PATH} setting to determine      * the root path for the index.      *      * @param indexSettings settings for the index      * @param shardId shard to resolve the path to      */
DECL|method|resolveCustomLocation
specifier|public
name|Path
name|resolveCustomLocation
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|,
specifier|final
name|ShardId
name|shardId
parameter_list|)
block|{
return|return
name|resolveIndexCustomLocation
argument_list|(
name|indexSettings
argument_list|)
operator|.
name|resolve
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Returns the {@code NodePath.path} for this shard.      */
DECL|method|shardStatePathToDataPath
specifier|public
specifier|static
name|Path
name|shardStatePathToDataPath
parameter_list|(
name|Path
name|shardPath
parameter_list|)
block|{
name|int
name|count
init|=
name|shardPath
operator|.
name|getNameCount
argument_list|()
decl_stmt|;
comment|// Sanity check:
assert|assert
name|Integer
operator|.
name|parseInt
argument_list|(
name|shardPath
operator|.
name|getName
argument_list|(
name|count
operator|-
literal|1
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
operator|>=
literal|0
assert|;
assert|assert
literal|"indices"
operator|.
name|equals
argument_list|(
name|shardPath
operator|.
name|getName
argument_list|(
name|count
operator|-
literal|3
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
assert|;
return|return
name|shardPath
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
operator|.
name|getParent
argument_list|()
return|;
block|}
comment|/**      * This is a best effort to ensure that we actually have write permissions to write in all our data directories.      * This prevents disasters if nodes are started under the wrong username etc.      */
DECL|method|assertCanWrite
specifier|private
name|void
name|assertCanWrite
parameter_list|()
throws|throws
name|IOException
block|{
for|for
control|(
name|Path
name|path
range|:
name|nodeDataPaths
argument_list|()
control|)
block|{
comment|// check node-paths are writable
name|tryWriteTempFile
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|indexFolderName
range|:
name|this
operator|.
name|availableIndexFolders
argument_list|()
control|)
block|{
for|for
control|(
name|Path
name|indexPath
range|:
name|this
operator|.
name|resolveIndexFolder
argument_list|(
name|indexFolderName
argument_list|)
control|)
block|{
comment|// check index paths are writable
name|Path
name|indexStatePath
init|=
name|indexPath
operator|.
name|resolve
argument_list|(
name|MetaDataStateFormat
operator|.
name|STATE_DIR_NAME
argument_list|)
decl_stmt|;
name|tryWriteTempFile
argument_list|(
name|indexStatePath
argument_list|)
expr_stmt|;
name|tryWriteTempFile
argument_list|(
name|indexPath
argument_list|)
expr_stmt|;
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|indexPath
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|shardPath
range|:
name|stream
control|)
block|{
name|String
name|fileName
init|=
name|shardPath
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|shardPath
argument_list|)
operator|&&
name|fileName
operator|.
name|chars
argument_list|()
operator|.
name|allMatch
argument_list|(
name|Character
operator|::
name|isDigit
argument_list|)
condition|)
block|{
name|Path
name|indexDir
init|=
name|shardPath
operator|.
name|resolve
argument_list|(
name|ShardPath
operator|.
name|INDEX_FOLDER_NAME
argument_list|)
decl_stmt|;
name|Path
name|statePath
init|=
name|shardPath
operator|.
name|resolve
argument_list|(
name|MetaDataStateFormat
operator|.
name|STATE_DIR_NAME
argument_list|)
decl_stmt|;
name|Path
name|translogDir
init|=
name|shardPath
operator|.
name|resolve
argument_list|(
name|ShardPath
operator|.
name|TRANSLOG_FOLDER_NAME
argument_list|)
decl_stmt|;
name|tryWriteTempFile
argument_list|(
name|indexDir
argument_list|)
expr_stmt|;
name|tryWriteTempFile
argument_list|(
name|translogDir
argument_list|)
expr_stmt|;
name|tryWriteTempFile
argument_list|(
name|statePath
argument_list|)
expr_stmt|;
name|tryWriteTempFile
argument_list|(
name|shardPath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|tryWriteTempFile
specifier|private
specifier|static
name|void
name|tryWriteTempFile
parameter_list|(
name|Path
name|path
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|Path
name|resolve
init|=
name|path
operator|.
name|resolve
argument_list|(
literal|".es_temp_file"
argument_list|)
decl_stmt|;
try|try
block|{
name|Files
operator|.
name|createFile
argument_list|(
name|resolve
argument_list|)
expr_stmt|;
name|Files
operator|.
name|deleteIfExists
argument_list|(
name|resolve
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IOException
argument_list|(
literal|"failed to write in data directory ["
operator|+
name|path
operator|+
literal|"] write permission is required"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

