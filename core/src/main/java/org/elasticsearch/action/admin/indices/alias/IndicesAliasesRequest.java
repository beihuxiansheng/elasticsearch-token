begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.action.admin.indices.alias
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|alias
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectCursor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchGenerationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ActionRequestValidationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|AliasesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|CompositeIndicesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|IndicesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|IndicesOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|master
operator|.
name|AcknowledgedRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|AliasAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|AliasMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseFieldMatcherSupplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParsingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableOpenMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|Writeable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ConstructingObjectParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ObjectParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ObjectParser
operator|.
name|ValueType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ToXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryBuilder
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ValidateActions
operator|.
name|addValidationError
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ConstructingObjectParser
operator|.
name|optionalConstructorArg
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ObjectParser
operator|.
name|fromList
import|;
end_import

begin_comment
comment|/**  * A request to add/remove aliases for one or more indices.  */
end_comment

begin_class
DECL|class|IndicesAliasesRequest
specifier|public
class|class
name|IndicesAliasesRequest
extends|extends
name|AcknowledgedRequest
argument_list|<
name|IndicesAliasesRequest
argument_list|>
implements|implements
name|CompositeIndicesRequest
block|{
DECL|field|allAliasActions
specifier|private
name|List
argument_list|<
name|AliasActions
argument_list|>
name|allAliasActions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|//indices options that require every specified index to exist, expand wildcards only to open indices and
comment|//don't allow that no indices are resolved from wildcard expressions
DECL|field|INDICES_OPTIONS
specifier|private
specifier|static
specifier|final
name|IndicesOptions
name|INDICES_OPTIONS
init|=
name|IndicesOptions
operator|.
name|fromOptions
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
DECL|method|IndicesAliasesRequest
specifier|public
name|IndicesAliasesRequest
parameter_list|()
block|{      }
comment|/**      * Request to take one or more actions on one or more indexes and alias combinations.      */
DECL|class|AliasActions
specifier|public
specifier|static
class|class
name|AliasActions
implements|implements
name|AliasesRequest
implements|,
name|Writeable
block|{
DECL|enum|Type
specifier|public
enum|enum
name|Type
block|{
DECL|enum constant|ADD
name|ADD
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
block|,
DECL|enum constant|REMOVE
name|REMOVE
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|)
block|,
DECL|enum constant|REMOVE_INDEX
name|REMOVE_INDEX
argument_list|(
operator|(
name|byte
operator|)
literal|2
argument_list|)
block|;
DECL|field|value
specifier|private
specifier|final
name|byte
name|value
decl_stmt|;
DECL|method|Type
name|Type
parameter_list|(
name|byte
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|value
specifier|public
name|byte
name|value
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|fromValue
specifier|public
specifier|static
name|Type
name|fromValue
parameter_list|(
name|byte
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|value
condition|)
block|{
case|case
literal|0
case|:
return|return
name|ADD
return|;
case|case
literal|1
case|:
return|return
name|REMOVE
return|;
case|case
literal|2
case|:
return|return
name|REMOVE_INDEX
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No type for action ["
operator|+
name|value
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**          * Build a new {@link AliasAction} to add aliases.          */
DECL|method|add
specifier|public
specifier|static
name|AliasActions
name|add
parameter_list|()
block|{
return|return
operator|new
name|AliasActions
argument_list|(
name|AliasActions
operator|.
name|Type
operator|.
name|ADD
argument_list|)
return|;
block|}
comment|/**          * Build a new {@link AliasAction} to remove aliases.          */
DECL|method|remove
specifier|public
specifier|static
name|AliasActions
name|remove
parameter_list|()
block|{
return|return
operator|new
name|AliasActions
argument_list|(
name|AliasActions
operator|.
name|Type
operator|.
name|REMOVE
argument_list|)
return|;
block|}
comment|/**          * Build a new {@link AliasAction} to remove aliases.          */
DECL|method|removeIndex
specifier|public
specifier|static
name|AliasActions
name|removeIndex
parameter_list|()
block|{
return|return
operator|new
name|AliasActions
argument_list|(
name|AliasActions
operator|.
name|Type
operator|.
name|REMOVE_INDEX
argument_list|)
return|;
block|}
DECL|method|parser
specifier|private
specifier|static
name|ObjectParser
argument_list|<
name|AliasActions
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|parser
parameter_list|(
name|String
name|name
parameter_list|,
name|Supplier
argument_list|<
name|AliasActions
argument_list|>
name|supplier
parameter_list|)
block|{
name|ObjectParser
argument_list|<
name|AliasActions
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|parser
init|=
operator|new
name|ObjectParser
argument_list|<>
argument_list|(
name|name
argument_list|,
name|supplier
argument_list|)
decl_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
parameter_list|(
name|action
parameter_list|,
name|index
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|action
operator|.
name|indices
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only one of [index] and [indices] is supported"
argument_list|)
throw|;
block|}
name|action
operator|.
name|index
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"index"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareStringArray
argument_list|(
name|fromList
argument_list|(
name|String
operator|.
name|class
argument_list|,
parameter_list|(
name|action
parameter_list|,
name|indices
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|action
operator|.
name|indices
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only one of [index] and [indices] is supported"
argument_list|)
throw|;
block|}
name|action
operator|.
name|indices
argument_list|(
name|indices
argument_list|)
expr_stmt|;
block|}
argument_list|)
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"indices"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
parameter_list|(
name|action
parameter_list|,
name|alias
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|action
operator|.
name|aliases
argument_list|()
operator|!=
literal|null
operator|&&
name|action
operator|.
name|aliases
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only one of [alias] and [aliases] is supported"
argument_list|)
throw|;
block|}
name|action
operator|.
name|alias
argument_list|(
name|alias
argument_list|)
expr_stmt|;
block|}
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"alias"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareStringArray
argument_list|(
name|fromList
argument_list|(
name|String
operator|.
name|class
argument_list|,
parameter_list|(
name|action
parameter_list|,
name|aliases
parameter_list|)
lambda|->
block|{
if|if
condition|(
name|action
operator|.
name|aliases
argument_list|()
operator|!=
literal|null
operator|&&
name|action
operator|.
name|aliases
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Only one of [alias] and [aliases] is supported"
argument_list|)
throw|;
block|}
name|action
operator|.
name|aliases
argument_list|(
name|aliases
argument_list|)
expr_stmt|;
block|}
argument_list|)
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"aliases"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|parser
return|;
block|}
DECL|field|ADD_PARSER
specifier|private
specifier|static
specifier|final
name|ObjectParser
argument_list|<
name|AliasActions
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|ADD_PARSER
init|=
name|parser
argument_list|(
literal|"add"
argument_list|,
name|AliasActions
operator|::
name|add
argument_list|)
decl_stmt|;
static|static
block|{
name|ADD_PARSER
operator|.
name|declareObject
argument_list|(
name|AliasActions
operator|::
name|filter
argument_list|,
parameter_list|(
name|parser
parameter_list|,
name|m
parameter_list|)
lambda|->
block|{
try|try
block|{
return|return
name|parser
operator|.
name|mapOrdered
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ParsingException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
literal|"Problems parsing [filter]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"filter"
argument_list|)
argument_list|)
expr_stmt|;
comment|// Since we need to support numbers AND strings here we have to use ValueType.INT.
name|ADD_PARSER
operator|.
name|declareField
argument_list|(
name|AliasActions
operator|::
name|routing
argument_list|,
name|p
lambda|->
name|p
operator|.
name|text
argument_list|()
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"routing"
argument_list|)
argument_list|,
name|ValueType
operator|.
name|INT
argument_list|)
expr_stmt|;
name|ADD_PARSER
operator|.
name|declareField
argument_list|(
name|AliasActions
operator|::
name|indexRouting
argument_list|,
name|p
lambda|->
name|p
operator|.
name|text
argument_list|()
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"index_routing"
argument_list|)
argument_list|,
name|ValueType
operator|.
name|INT
argument_list|)
expr_stmt|;
name|ADD_PARSER
operator|.
name|declareField
argument_list|(
name|AliasActions
operator|::
name|searchRouting
argument_list|,
name|p
lambda|->
name|p
operator|.
name|text
argument_list|()
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"search_routing"
argument_list|)
argument_list|,
name|ValueType
operator|.
name|INT
argument_list|)
expr_stmt|;
block|}
DECL|field|REMOVE_PARSER
specifier|private
specifier|static
specifier|final
name|ObjectParser
argument_list|<
name|AliasActions
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|REMOVE_PARSER
init|=
name|parser
argument_list|(
literal|"remove"
argument_list|,
name|AliasActions
operator|::
name|remove
argument_list|)
decl_stmt|;
DECL|field|REMOVE_INDEX_PARSER
specifier|private
specifier|static
specifier|final
name|ObjectParser
argument_list|<
name|AliasActions
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|REMOVE_INDEX_PARSER
init|=
name|parser
argument_list|(
literal|"remove_index"
argument_list|,
name|AliasActions
operator|::
name|removeIndex
argument_list|)
decl_stmt|;
comment|/**          * Parser for any one {@link AliasAction}.          */
DECL|field|PARSER
specifier|public
specifier|static
specifier|final
name|ConstructingObjectParser
argument_list|<
name|AliasActions
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|PARSER
init|=
operator|new
name|ConstructingObjectParser
argument_list|<>
argument_list|(
literal|"alias_action"
argument_list|,
name|a
lambda|->
block|{
comment|// Take the first action and complain if there are more than one actions
name|AliasActions
name|action
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Object
name|o
range|:
name|a
control|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
block|{
name|action
operator|=
operator|(
name|AliasActions
operator|)
name|o
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Too many operations declared in on opeation entry"
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|action
return|;
block|}
argument_list|)
decl_stmt|;
static|static
block|{
name|PARSER
operator|.
name|declareObject
argument_list|(
name|optionalConstructorArg
argument_list|()
argument_list|,
name|ADD_PARSER
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"add"
argument_list|)
argument_list|)
expr_stmt|;
name|PARSER
operator|.
name|declareObject
argument_list|(
name|optionalConstructorArg
argument_list|()
argument_list|,
name|REMOVE_PARSER
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"remove"
argument_list|)
argument_list|)
expr_stmt|;
name|PARSER
operator|.
name|declareObject
argument_list|(
name|optionalConstructorArg
argument_list|()
argument_list|,
name|REMOVE_INDEX_PARSER
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"remove_index"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|field|type
specifier|private
specifier|final
name|AliasActions
operator|.
name|Type
name|type
decl_stmt|;
DECL|field|indices
specifier|private
name|String
index|[]
name|indices
decl_stmt|;
DECL|field|aliases
specifier|private
name|String
index|[]
name|aliases
init|=
name|Strings
operator|.
name|EMPTY_ARRAY
decl_stmt|;
DECL|field|filter
specifier|private
name|String
name|filter
decl_stmt|;
DECL|field|routing
specifier|private
name|String
name|routing
decl_stmt|;
DECL|field|indexRouting
specifier|private
name|String
name|indexRouting
decl_stmt|;
DECL|field|searchRouting
specifier|private
name|String
name|searchRouting
decl_stmt|;
DECL|method|AliasActions
name|AliasActions
parameter_list|(
name|AliasActions
operator|.
name|Type
name|type
parameter_list|)
block|{
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
block|}
comment|/**          * Read from a stream.          */
DECL|method|AliasActions
specifier|public
name|AliasActions
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|type
operator|=
name|AliasActions
operator|.
name|Type
operator|.
name|fromValue
argument_list|(
name|in
operator|.
name|readByte
argument_list|()
argument_list|)
expr_stmt|;
name|indices
operator|=
name|in
operator|.
name|readStringArray
argument_list|()
expr_stmt|;
name|aliases
operator|=
name|in
operator|.
name|readStringArray
argument_list|()
expr_stmt|;
name|filter
operator|=
name|in
operator|.
name|readOptionalString
argument_list|()
expr_stmt|;
name|routing
operator|=
name|in
operator|.
name|readOptionalString
argument_list|()
expr_stmt|;
name|searchRouting
operator|=
name|in
operator|.
name|readOptionalString
argument_list|()
expr_stmt|;
name|indexRouting
operator|=
name|in
operator|.
name|readOptionalString
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeByte
argument_list|(
name|type
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeStringArray
argument_list|(
name|indices
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeStringArray
argument_list|(
name|aliases
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalString
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalString
argument_list|(
name|routing
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalString
argument_list|(
name|searchRouting
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalString
argument_list|(
name|indexRouting
argument_list|)
expr_stmt|;
block|}
comment|/**          * Validate that the action is sane. Called when the action is added to the request because actions can be invalid while being          * built.          */
DECL|method|validate
name|void
name|validate
parameter_list|()
block|{
if|if
condition|(
name|indices
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"One of [index] or [indices] is required"
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|!=
name|AliasActions
operator|.
name|Type
operator|.
name|REMOVE_INDEX
operator|&&
operator|(
name|aliases
operator|==
literal|null
operator|||
name|aliases
operator|.
name|length
operator|==
literal|0
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"One of [alias] or [aliases] is required"
argument_list|)
throw|;
block|}
block|}
comment|/**          * Type of the action to perform.          */
DECL|method|actionType
specifier|public
name|AliasActions
operator|.
name|Type
name|actionType
parameter_list|()
block|{
return|return
name|type
return|;
block|}
annotation|@
name|Override
DECL|method|indices
specifier|public
name|AliasActions
name|indices
parameter_list|(
name|String
modifier|...
name|indices
parameter_list|)
block|{
if|if
condition|(
name|indices
operator|==
literal|null
operator|||
name|indices
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[indices] can't be empty"
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|index
range|:
name|indices
control|)
block|{
if|if
condition|(
literal|false
operator|==
name|Strings
operator|.
name|hasLength
argument_list|(
name|index
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[indices] can't contain empty string"
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|indices
operator|=
name|indices
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the index this action is operating on.          */
DECL|method|index
specifier|public
name|AliasActions
name|index
parameter_list|(
name|String
name|index
parameter_list|)
block|{
if|if
condition|(
literal|false
operator|==
name|Strings
operator|.
name|hasLength
argument_list|(
name|index
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[index] can't be empty string"
argument_list|)
throw|;
block|}
name|this
operator|.
name|indices
operator|=
operator|new
name|String
index|[]
block|{
name|index
block|}
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Aliases to use with this action.          */
annotation|@
name|Override
DECL|method|aliases
specifier|public
name|AliasActions
name|aliases
parameter_list|(
name|String
modifier|...
name|aliases
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|AliasActions
operator|.
name|Type
operator|.
name|REMOVE_INDEX
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[aliases] is unsupported for ["
operator|+
name|type
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|aliases
operator|==
literal|null
operator|||
name|aliases
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[aliases] can't be empty"
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|alias
range|:
name|aliases
control|)
block|{
if|if
condition|(
literal|false
operator|==
name|Strings
operator|.
name|hasLength
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[aliases] can't contain empty string"
argument_list|)
throw|;
block|}
block|}
name|this
operator|.
name|aliases
operator|=
name|aliases
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the alias this action is operating on.          */
DECL|method|alias
specifier|public
name|AliasActions
name|alias
parameter_list|(
name|String
name|alias
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|AliasActions
operator|.
name|Type
operator|.
name|REMOVE_INDEX
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[alias] is unsupported for ["
operator|+
name|type
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
literal|false
operator|==
name|Strings
operator|.
name|hasLength
argument_list|(
name|alias
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[alias] can't be empty string"
argument_list|)
throw|;
block|}
name|this
operator|.
name|aliases
operator|=
operator|new
name|String
index|[]
block|{
name|alias
block|}
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**          * Set the default routing.          */
DECL|method|routing
specifier|public
name|AliasActions
name|routing
parameter_list|(
name|String
name|routing
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|AliasActions
operator|.
name|Type
operator|.
name|ADD
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[routing] is unsupported for ["
operator|+
name|type
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|this
operator|.
name|routing
operator|=
name|routing
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|searchRouting
specifier|public
name|String
name|searchRouting
parameter_list|()
block|{
return|return
name|searchRouting
operator|==
literal|null
condition|?
name|routing
else|:
name|searchRouting
return|;
block|}
DECL|method|searchRouting
specifier|public
name|AliasActions
name|searchRouting
parameter_list|(
name|String
name|searchRouting
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|AliasActions
operator|.
name|Type
operator|.
name|ADD
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[search_routing] is unsupported for ["
operator|+
name|type
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|this
operator|.
name|searchRouting
operator|=
name|searchRouting
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|indexRouting
specifier|public
name|String
name|indexRouting
parameter_list|()
block|{
return|return
name|indexRouting
operator|==
literal|null
condition|?
name|routing
else|:
name|indexRouting
return|;
block|}
DECL|method|indexRouting
specifier|public
name|AliasActions
name|indexRouting
parameter_list|(
name|String
name|indexRouting
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|AliasActions
operator|.
name|Type
operator|.
name|ADD
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[index_routing] is unsupported for ["
operator|+
name|type
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|this
operator|.
name|indexRouting
operator|=
name|indexRouting
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|filter
specifier|public
name|String
name|filter
parameter_list|()
block|{
return|return
name|filter
return|;
block|}
DECL|method|filter
specifier|public
name|AliasActions
name|filter
parameter_list|(
name|String
name|filter
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|AliasActions
operator|.
name|Type
operator|.
name|ADD
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[filter] is unsupported for ["
operator|+
name|type
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|this
operator|.
name|filter
operator|=
name|filter
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|filter
specifier|public
name|AliasActions
name|filter
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|filter
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|==
literal|null
operator|||
name|filter
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|filter
operator|=
literal|null
expr_stmt|;
return|return
name|this
return|;
block|}
try|try
block|{
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|XContentType
operator|.
name|JSON
argument_list|)
decl_stmt|;
name|builder
operator|.
name|map
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|builder
operator|.
name|string
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchGenerationException
argument_list|(
literal|"Failed to generate ["
operator|+
name|filter
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|filter
specifier|public
name|AliasActions
name|filter
parameter_list|(
name|QueryBuilder
name|filter
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|==
literal|null
condition|)
block|{
name|this
operator|.
name|filter
operator|=
literal|null
expr_stmt|;
return|return
name|this
return|;
block|}
try|try
block|{
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|jsonBuilder
argument_list|()
decl_stmt|;
name|filter
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|ToXContent
operator|.
name|EMPTY_PARAMS
argument_list|)
expr_stmt|;
name|builder
operator|.
name|close
argument_list|()
expr_stmt|;
name|this
operator|.
name|filter
operator|=
name|builder
operator|.
name|string
argument_list|()
expr_stmt|;
return|return
name|this
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchGenerationException
argument_list|(
literal|"Failed to build json for alias request"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|aliases
specifier|public
name|String
index|[]
name|aliases
parameter_list|()
block|{
return|return
name|aliases
return|;
block|}
annotation|@
name|Override
DECL|method|expandAliasesWildcards
specifier|public
name|boolean
name|expandAliasesWildcards
parameter_list|()
block|{
comment|//remove operations support wildcards among aliases, add operations don't
return|return
name|type
operator|==
name|Type
operator|.
name|REMOVE
return|;
block|}
annotation|@
name|Override
DECL|method|indices
specifier|public
name|String
index|[]
name|indices
parameter_list|()
block|{
return|return
name|indices
return|;
block|}
annotation|@
name|Override
DECL|method|indicesOptions
specifier|public
name|IndicesOptions
name|indicesOptions
parameter_list|()
block|{
return|return
name|INDICES_OPTIONS
return|;
block|}
DECL|method|concreteAliases
specifier|public
name|String
index|[]
name|concreteAliases
parameter_list|(
name|MetaData
name|metaData
parameter_list|,
name|String
name|concreteIndex
parameter_list|)
block|{
if|if
condition|(
name|expandAliasesWildcards
argument_list|()
condition|)
block|{
comment|//for DELETE we expand the aliases
name|String
index|[]
name|indexAsArray
init|=
block|{
name|concreteIndex
block|}
decl_stmt|;
name|ImmutableOpenMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|AliasMetaData
argument_list|>
argument_list|>
name|aliasMetaData
init|=
name|metaData
operator|.
name|findAliases
argument_list|(
name|aliases
argument_list|,
name|indexAsArray
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|finalAliases
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ObjectCursor
argument_list|<
name|List
argument_list|<
name|AliasMetaData
argument_list|>
argument_list|>
name|curAliases
range|:
name|aliasMetaData
operator|.
name|values
argument_list|()
control|)
block|{
for|for
control|(
name|AliasMetaData
name|aliasMeta
range|:
name|curAliases
operator|.
name|value
control|)
block|{
name|finalAliases
operator|.
name|add
argument_list|(
name|aliasMeta
operator|.
name|alias
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|finalAliases
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|finalAliases
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
else|else
block|{
comment|//for add we just return the current aliases
return|return
name|aliases
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"AliasActions["
operator|+
literal|"type="
operator|+
name|type
operator|+
literal|",indices="
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|indices
argument_list|)
operator|+
literal|",aliases="
operator|+
name|Arrays
operator|.
name|deepToString
argument_list|(
name|aliases
argument_list|)
operator|+
literal|",filter="
operator|+
name|filter
operator|+
literal|",routing="
operator|+
name|routing
operator|+
literal|",indexRouting="
operator|+
name|indexRouting
operator|+
literal|",searchRouting="
operator|+
name|searchRouting
operator|+
literal|"]"
return|;
block|}
comment|// equals, and hashCode implemented for easy testing of round trip
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
operator|||
name|obj
operator|.
name|getClass
argument_list|()
operator|!=
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|AliasActions
name|other
init|=
operator|(
name|AliasActions
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|type
argument_list|,
name|other
operator|.
name|type
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|indices
argument_list|,
name|other
operator|.
name|indices
argument_list|)
operator|&&
name|Arrays
operator|.
name|equals
argument_list|(
name|aliases
argument_list|,
name|other
operator|.
name|aliases
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|filter
argument_list|,
name|other
operator|.
name|filter
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|routing
argument_list|,
name|other
operator|.
name|routing
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|indexRouting
argument_list|,
name|other
operator|.
name|indexRouting
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|searchRouting
argument_list|,
name|other
operator|.
name|searchRouting
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|type
argument_list|,
name|indices
argument_list|,
name|aliases
argument_list|,
name|filter
argument_list|,
name|routing
argument_list|,
name|indexRouting
argument_list|,
name|searchRouting
argument_list|)
return|;
block|}
block|}
comment|/**      * Add the action to this request and validate it.      */
DECL|method|addAliasAction
specifier|public
name|IndicesAliasesRequest
name|addAliasAction
parameter_list|(
name|AliasActions
name|aliasAction
parameter_list|)
block|{
name|aliasAction
operator|.
name|validate
argument_list|()
expr_stmt|;
name|allAliasActions
operator|.
name|add
argument_list|(
name|aliasAction
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|aliasActions
name|List
argument_list|<
name|AliasActions
argument_list|>
name|aliasActions
parameter_list|()
block|{
return|return
name|this
operator|.
name|allAliasActions
return|;
block|}
DECL|method|getAliasActions
specifier|public
name|List
argument_list|<
name|AliasActions
argument_list|>
name|getAliasActions
parameter_list|()
block|{
return|return
name|aliasActions
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|validate
specifier|public
name|ActionRequestValidationException
name|validate
parameter_list|()
block|{
name|ActionRequestValidationException
name|validationException
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|allAliasActions
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|addValidationError
argument_list|(
literal|"Must specify at least one alias action"
argument_list|,
name|validationException
argument_list|)
return|;
block|}
return|return
name|validationException
return|;
block|}
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|allAliasActions
operator|=
name|in
operator|.
name|readList
argument_list|(
name|AliasActions
operator|::
operator|new
argument_list|)
expr_stmt|;
name|readTimeout
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeList
argument_list|(
name|allAliasActions
argument_list|)
expr_stmt|;
name|writeTimeout
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|indicesOptions
specifier|public
name|IndicesOptions
name|indicesOptions
parameter_list|()
block|{
return|return
name|INDICES_OPTIONS
return|;
block|}
annotation|@
name|Override
DECL|method|subRequests
specifier|public
name|List
argument_list|<
name|?
extends|extends
name|IndicesRequest
argument_list|>
name|subRequests
parameter_list|()
block|{
return|return
name|allAliasActions
return|;
block|}
block|}
end_class

end_unit

