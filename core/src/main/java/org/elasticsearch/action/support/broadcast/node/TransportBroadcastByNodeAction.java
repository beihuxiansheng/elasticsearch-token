begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.action.support.broadcast.node
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|broadcast
operator|.
name|node
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|FailedNodeException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|IndicesRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|NoShardAvailableActionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ShardOperationFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|ActionFilters
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|ChildTaskRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|DefaultShardOperationFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|HandledTransportAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|IndicesOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|TransportActions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|broadcast
operator|.
name|BroadcastRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|broadcast
operator|.
name|BroadcastResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|broadcast
operator|.
name|BroadcastShardOperationFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|block
operator|.
name|ClusterBlockException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexNameExpressionResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardsIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|service
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|Streamable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|BaseTransportResponseHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|NodeShouldNotConnectException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequestHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceArray
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Supplier
import|;
end_import

begin_comment
comment|/**  * Abstraction for transporting aggregated shard-level operations in a single request (NodeRequest) per-node  * and executing the shard-level operations serially on the receiving node. Each shard-level operation can produce a  * result (ShardOperationResult), these per-node shard-level results are aggregated into a single result  * (BroadcastByNodeResponse) to the coordinating node. These per-node results are aggregated into a single result (Result)  * to the client.  *  * @param<Request>              the underlying client request  * @param<Response>             the response to the client request  * @param<ShardOperationResult> per-shard operation results  */
end_comment

begin_class
DECL|class|TransportBroadcastByNodeAction
specifier|public
specifier|abstract
class|class
name|TransportBroadcastByNodeAction
parameter_list|<
name|Request
extends|extends
name|BroadcastRequest
parameter_list|<
name|Request
parameter_list|>
parameter_list|,
name|Response
extends|extends
name|BroadcastResponse
parameter_list|,
name|ShardOperationResult
extends|extends
name|Streamable
parameter_list|>
extends|extends
name|HandledTransportAction
argument_list|<
name|Request
argument_list|,
name|Response
argument_list|>
block|{
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|transportService
specifier|private
specifier|final
name|TransportService
name|transportService
decl_stmt|;
DECL|field|transportNodeBroadcastAction
specifier|final
name|String
name|transportNodeBroadcastAction
decl_stmt|;
DECL|method|TransportBroadcastByNodeAction
specifier|public
name|TransportBroadcastByNodeAction
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|String
name|actionName
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|TransportService
name|transportService
parameter_list|,
name|ActionFilters
name|actionFilters
parameter_list|,
name|IndexNameExpressionResolver
name|indexNameExpressionResolver
parameter_list|,
name|Supplier
argument_list|<
name|Request
argument_list|>
name|request
parameter_list|,
name|String
name|executor
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|,
name|actionName
argument_list|,
name|threadPool
argument_list|,
name|transportService
argument_list|,
name|actionFilters
argument_list|,
name|indexNameExpressionResolver
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|transportService
operator|=
name|transportService
expr_stmt|;
name|transportNodeBroadcastAction
operator|=
name|actionName
operator|+
literal|"[n]"
expr_stmt|;
name|transportService
operator|.
name|registerRequestHandler
argument_list|(
name|transportNodeBroadcastAction
argument_list|,
name|NodeRequest
operator|::
operator|new
argument_list|,
name|executor
argument_list|,
operator|new
name|BroadcastByNodeTransportRequestHandler
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|newResponse
specifier|private
name|Response
name|newResponse
parameter_list|(
name|Request
name|request
parameter_list|,
name|AtomicReferenceArray
name|responses
parameter_list|,
name|List
argument_list|<
name|NoShardAvailableActionException
argument_list|>
name|unavailableShardExceptions
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|nodes
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|)
block|{
name|int
name|totalShards
init|=
literal|0
decl_stmt|;
name|int
name|successfulShards
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|ShardOperationResult
argument_list|>
name|broadcastByNodeResponses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ShardOperationFailedException
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|responses
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|responses
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|instanceof
name|FailedNodeException
condition|)
block|{
name|FailedNodeException
name|exception
init|=
operator|(
name|FailedNodeException
operator|)
name|responses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|totalShards
operator|+=
name|nodes
operator|.
name|get
argument_list|(
name|exception
operator|.
name|nodeId
argument_list|()
argument_list|)
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|nodes
operator|.
name|get
argument_list|(
name|exception
operator|.
name|nodeId
argument_list|()
argument_list|)
control|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
operator|new
name|DefaultShardOperationFailedException
argument_list|(
name|shard
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|shard
operator|.
name|getId
argument_list|()
argument_list|,
name|exception
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|NodeResponse
name|response
init|=
operator|(
name|NodeResponse
operator|)
name|responses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|broadcastByNodeResponses
operator|.
name|addAll
argument_list|(
name|response
operator|.
name|results
argument_list|)
expr_stmt|;
name|totalShards
operator|+=
name|response
operator|.
name|getTotalShards
argument_list|()
expr_stmt|;
name|successfulShards
operator|+=
name|response
operator|.
name|getSuccessfulShards
argument_list|()
expr_stmt|;
for|for
control|(
name|BroadcastShardOperationFailedException
name|throwable
range|:
name|response
operator|.
name|getExceptions
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|TransportActions
operator|.
name|isShardNotAvailableException
argument_list|(
name|throwable
argument_list|)
condition|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
operator|new
name|DefaultShardOperationFailedException
argument_list|(
name|throwable
operator|.
name|getShardId
argument_list|()
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|throwable
operator|.
name|getShardId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|throwable
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|totalShards
operator|+=
name|unavailableShardExceptions
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|failedShards
init|=
name|exceptions
operator|.
name|size
argument_list|()
decl_stmt|;
return|return
name|newResponse
argument_list|(
name|request
argument_list|,
name|totalShards
argument_list|,
name|successfulShards
argument_list|,
name|failedShards
argument_list|,
name|broadcastByNodeResponses
argument_list|,
name|exceptions
argument_list|,
name|clusterState
argument_list|)
return|;
block|}
comment|/**      * Deserialize a shard-level result from an input stream      *      * @param in input stream      * @return a deserialized shard-level result      */
DECL|method|readShardResult
specifier|protected
specifier|abstract
name|ShardOperationResult
name|readShardResult
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Creates a new response to the underlying request.      *      * @param request          the underlying request      * @param totalShards      the total number of shards considered for execution of the operation      * @param successfulShards the total number of shards for which execution of the operation was successful      * @param failedShards     the total number of shards for which execution of the operation failed      * @param results          the per-node aggregated shard-level results      * @param shardFailures    the exceptions corresponding to shard operationa failures      * @param clusterState     the cluster state      * @return the response      */
DECL|method|newResponse
specifier|protected
specifier|abstract
name|Response
name|newResponse
parameter_list|(
name|Request
name|request
parameter_list|,
name|int
name|totalShards
parameter_list|,
name|int
name|successfulShards
parameter_list|,
name|int
name|failedShards
parameter_list|,
name|List
argument_list|<
name|ShardOperationResult
argument_list|>
name|results
parameter_list|,
name|List
argument_list|<
name|ShardOperationFailedException
argument_list|>
name|shardFailures
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|)
function_decl|;
comment|/**      * Deserialize a request from an input stream      *      * @param in input stream      * @return a de-serialized request      */
DECL|method|readRequestFrom
specifier|protected
specifier|abstract
name|Request
name|readRequestFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Executes the shard-level operation. This method is called once per shard serially on the receiving node.      *      * @param request      the node-level request      * @param shardRouting the shard on which to execute the operation      * @return the result of the shard-level operation for the shard      */
DECL|method|shardOperation
specifier|protected
specifier|abstract
name|ShardOperationResult
name|shardOperation
parameter_list|(
name|Request
name|request
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Determines the shards on which this operation will be executed on. The operation is executed once per shard.      *      * @param clusterState    the cluster state      * @param request         the underlying request      * @param concreteIndices the concrete indices on which to execute the operation      * @return the shards on which to execute the operation      */
DECL|method|shards
specifier|protected
specifier|abstract
name|ShardsIterator
name|shards
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|Request
name|request
parameter_list|,
name|String
index|[]
name|concreteIndices
parameter_list|)
function_decl|;
comment|/**      * Executes a global block check before polling the cluster state.      *      * @param state   the cluster state      * @param request the underlying request      * @return a non-null exception if the operation is blocked      */
DECL|method|checkGlobalBlock
specifier|protected
specifier|abstract
name|ClusterBlockException
name|checkGlobalBlock
parameter_list|(
name|ClusterState
name|state
parameter_list|,
name|Request
name|request
parameter_list|)
function_decl|;
comment|/**      * Executes a global request-level check before polling the cluster state.      *      * @param state           the cluster state      * @param request         the underlying request      * @param concreteIndices the concrete indices on which to execute the operation      * @return a non-null exception if the operation if blocked      */
DECL|method|checkRequestBlock
specifier|protected
specifier|abstract
name|ClusterBlockException
name|checkRequestBlock
parameter_list|(
name|ClusterState
name|state
parameter_list|,
name|Request
name|request
parameter_list|,
name|String
index|[]
name|concreteIndices
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|doExecute
specifier|protected
specifier|final
name|void
name|doExecute
parameter_list|(
name|Request
name|request
parameter_list|,
name|ActionListener
argument_list|<
name|Response
argument_list|>
name|listener
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"the task parameter is required for this operation"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|doExecute
specifier|protected
name|void
name|doExecute
parameter_list|(
name|Task
name|task
parameter_list|,
name|Request
name|request
parameter_list|,
name|ActionListener
argument_list|<
name|Response
argument_list|>
name|listener
parameter_list|)
block|{
operator|new
name|AsyncAction
argument_list|(
name|task
argument_list|,
name|request
argument_list|,
name|listener
argument_list|)
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
DECL|class|AsyncAction
specifier|protected
class|class
name|AsyncAction
block|{
DECL|field|task
specifier|private
specifier|final
name|Task
name|task
decl_stmt|;
DECL|field|request
specifier|private
specifier|final
name|Request
name|request
decl_stmt|;
DECL|field|listener
specifier|private
specifier|final
name|ActionListener
argument_list|<
name|Response
argument_list|>
name|listener
decl_stmt|;
DECL|field|clusterState
specifier|private
specifier|final
name|ClusterState
name|clusterState
decl_stmt|;
DECL|field|nodes
specifier|private
specifier|final
name|DiscoveryNodes
name|nodes
decl_stmt|;
DECL|field|nodeIds
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|nodeIds
decl_stmt|;
DECL|field|responses
specifier|private
specifier|final
name|AtomicReferenceArray
argument_list|<
name|Object
argument_list|>
name|responses
decl_stmt|;
DECL|field|counter
specifier|private
specifier|final
name|AtomicInteger
name|counter
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
DECL|field|unavailableShardExceptions
specifier|private
name|List
argument_list|<
name|NoShardAvailableActionException
argument_list|>
name|unavailableShardExceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|AsyncAction
specifier|protected
name|AsyncAction
parameter_list|(
name|Task
name|task
parameter_list|,
name|Request
name|request
parameter_list|,
name|ActionListener
argument_list|<
name|Response
argument_list|>
name|listener
parameter_list|)
block|{
name|this
operator|.
name|task
operator|=
name|task
expr_stmt|;
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|listener
operator|=
name|listener
expr_stmt|;
name|clusterState
operator|=
name|clusterService
operator|.
name|state
argument_list|()
expr_stmt|;
name|nodes
operator|=
name|clusterState
operator|.
name|nodes
argument_list|()
expr_stmt|;
name|ClusterBlockException
name|globalBlockException
init|=
name|checkGlobalBlock
argument_list|(
name|clusterState
argument_list|,
name|request
argument_list|)
decl_stmt|;
if|if
condition|(
name|globalBlockException
operator|!=
literal|null
condition|)
block|{
throw|throw
name|globalBlockException
throw|;
block|}
name|String
index|[]
name|concreteIndices
init|=
name|indexNameExpressionResolver
operator|.
name|concreteIndexNames
argument_list|(
name|clusterState
argument_list|,
name|request
argument_list|)
decl_stmt|;
name|ClusterBlockException
name|requestBlockException
init|=
name|checkRequestBlock
argument_list|(
name|clusterState
argument_list|,
name|request
argument_list|,
name|concreteIndices
argument_list|)
decl_stmt|;
if|if
condition|(
name|requestBlockException
operator|!=
literal|null
condition|)
block|{
throw|throw
name|requestBlockException
throw|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"resolving shards for [{}] based on cluster state version [{}]"
argument_list|,
name|actionName
argument_list|,
name|clusterState
operator|.
name|version
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ShardsIterator
name|shardIt
init|=
name|shards
argument_list|(
name|clusterState
argument_list|,
name|request
argument_list|,
name|concreteIndices
argument_list|)
decl_stmt|;
name|nodeIds
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|shardIt
operator|.
name|asUnordered
argument_list|()
control|)
block|{
comment|// send a request to the shard only if it is assigned to a node that is in the local node's cluster state
comment|// a scenario in which a shard can be assigned but to a node that is not in the local node's cluster state
comment|// is when the shard is assigned to the master node, the local node has detected the master as failed
comment|// and a new master has not yet been elected; in this situation the local node will have removed the
comment|// master node from the local cluster state, but the shards assigned to the master will still be in the
comment|// routing table as such
if|if
condition|(
name|shard
operator|.
name|assignedToNode
argument_list|()
operator|&&
name|nodes
operator|.
name|get
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|String
name|nodeId
init|=
name|shard
operator|.
name|currentNodeId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|nodeIds
operator|.
name|containsKey
argument_list|(
name|nodeId
argument_list|)
condition|)
block|{
name|nodeIds
operator|.
name|put
argument_list|(
name|nodeId
argument_list|,
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|nodeIds
operator|.
name|get
argument_list|(
name|nodeId
argument_list|)
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unavailableShardExceptions
operator|.
name|add
argument_list|(
operator|new
name|NoShardAvailableActionException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|" no shards available for shard "
operator|+
name|shard
operator|.
name|toString
argument_list|()
operator|+
literal|" while executing "
operator|+
name|actionName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|responses
operator|=
operator|new
name|AtomicReferenceArray
argument_list|<>
argument_list|(
name|nodeIds
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|start
specifier|public
name|void
name|start
parameter_list|()
block|{
if|if
condition|(
name|nodeIds
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
try|try
block|{
name|onCompletion
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|listener
operator|.
name|onFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|nodeIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|entry
range|:
name|nodeIds
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|nodeIndex
operator|++
expr_stmt|;
name|DiscoveryNode
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|sendNodeRequest
argument_list|(
name|node
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|nodeIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|sendNodeRequest
specifier|private
name|void
name|sendNodeRequest
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|,
specifier|final
name|int
name|nodeIndex
parameter_list|)
block|{
try|try
block|{
name|NodeRequest
name|nodeRequest
init|=
operator|new
name|NodeRequest
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|request
argument_list|,
name|shards
argument_list|)
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
block|{
name|nodeRequest
operator|.
name|setParentTask
argument_list|(
name|clusterService
operator|.
name|localNode
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|task
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|taskManager
operator|.
name|registerChildTask
argument_list|(
name|task
argument_list|,
name|node
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|transportService
operator|.
name|sendRequest
argument_list|(
name|node
argument_list|,
name|transportNodeBroadcastAction
argument_list|,
name|nodeRequest
argument_list|,
operator|new
name|BaseTransportResponseHandler
argument_list|<
name|NodeResponse
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|NodeResponse
name|newInstance
parameter_list|()
block|{
return|return
operator|new
name|NodeResponse
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleResponse
parameter_list|(
name|NodeResponse
name|response
parameter_list|)
block|{
name|onNodeResponse
argument_list|(
name|node
argument_list|,
name|nodeIndex
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|handleException
parameter_list|(
name|TransportException
name|exp
parameter_list|)
block|{
name|onNodeFailure
argument_list|(
name|node
argument_list|,
name|nodeIndex
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|executor
parameter_list|()
block|{
return|return
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|onNodeFailure
argument_list|(
name|node
argument_list|,
name|nodeIndex
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|onNodeResponse
specifier|protected
name|void
name|onNodeResponse
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|int
name|nodeIndex
parameter_list|,
name|NodeResponse
name|response
parameter_list|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"received response for [{}] from node [{}]"
argument_list|,
name|actionName
argument_list|,
name|node
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// this is defensive to protect against the possibility of double invocation
comment|// the current implementation of TransportService#sendRequest guards against this
comment|// but concurrency is hard, safety is important, and the small performance loss here does not matter
if|if
condition|(
name|responses
operator|.
name|compareAndSet
argument_list|(
name|nodeIndex
argument_list|,
literal|null
argument_list|,
name|response
argument_list|)
condition|)
block|{
if|if
condition|(
name|counter
operator|.
name|incrementAndGet
argument_list|()
operator|==
name|responses
operator|.
name|length
argument_list|()
condition|)
block|{
name|onCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|onNodeFailure
specifier|protected
name|void
name|onNodeFailure
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|int
name|nodeIndex
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|String
name|nodeId
init|=
name|node
operator|.
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
operator|!
operator|(
name|t
operator|instanceof
name|NodeShouldNotConnectException
operator|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to execute [{}] on node [{}]"
argument_list|,
name|t
argument_list|,
name|actionName
argument_list|,
name|nodeId
argument_list|)
expr_stmt|;
block|}
comment|// this is defensive to protect against the possibility of double invocation
comment|// the current implementation of TransportService#sendRequest guards against this
comment|// but concurrency is hard, safety is important, and the small performance loss here does not matter
if|if
condition|(
name|responses
operator|.
name|compareAndSet
argument_list|(
name|nodeIndex
argument_list|,
literal|null
argument_list|,
operator|new
name|FailedNodeException
argument_list|(
name|nodeId
argument_list|,
literal|"Failed node ["
operator|+
name|nodeId
operator|+
literal|"]"
argument_list|,
name|t
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|counter
operator|.
name|incrementAndGet
argument_list|()
operator|==
name|responses
operator|.
name|length
argument_list|()
condition|)
block|{
name|onCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|onCompletion
specifier|protected
name|void
name|onCompletion
parameter_list|()
block|{
name|Response
name|response
init|=
literal|null
decl_stmt|;
try|try
block|{
name|response
operator|=
name|newResponse
argument_list|(
name|request
argument_list|,
name|responses
argument_list|,
name|unavailableShardExceptions
argument_list|,
name|nodeIds
argument_list|,
name|clusterState
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to combine responses from nodes"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|listener
operator|.
name|onFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|listener
operator|.
name|onResponse
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|listener
operator|.
name|onFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|BroadcastByNodeTransportRequestHandler
class|class
name|BroadcastByNodeTransportRequestHandler
implements|implements
name|TransportRequestHandler
argument_list|<
name|NodeRequest
argument_list|>
block|{
annotation|@
name|Override
DECL|method|messageReceived
specifier|public
name|void
name|messageReceived
parameter_list|(
specifier|final
name|NodeRequest
name|request
parameter_list|,
name|TransportChannel
name|channel
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
init|=
name|request
operator|.
name|getShards
argument_list|()
decl_stmt|;
specifier|final
name|int
name|totalShards
init|=
name|shards
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] executing operation on [{}] shards"
argument_list|,
name|actionName
argument_list|,
name|totalShards
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Object
index|[]
name|shardResultOrExceptions
init|=
operator|new
name|Object
index|[
name|totalShards
index|]
decl_stmt|;
name|int
name|shardIndex
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
specifier|final
name|ShardRouting
name|shardRouting
range|:
name|shards
control|)
block|{
name|shardIndex
operator|++
expr_stmt|;
name|onShardOperation
argument_list|(
name|request
argument_list|,
name|shardResultOrExceptions
argument_list|,
name|shardIndex
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|BroadcastShardOperationFailedException
argument_list|>
name|accumulatedExceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ShardOperationResult
argument_list|>
name|results
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|totalShards
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shardResultOrExceptions
index|[
name|i
index|]
operator|instanceof
name|BroadcastShardOperationFailedException
condition|)
block|{
name|accumulatedExceptions
operator|.
name|add
argument_list|(
operator|(
name|BroadcastShardOperationFailedException
operator|)
name|shardResultOrExceptions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|results
operator|.
name|add
argument_list|(
operator|(
name|ShardOperationResult
operator|)
name|shardResultOrExceptions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|channel
operator|.
name|sendResponse
argument_list|(
operator|new
name|NodeResponse
argument_list|(
name|request
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|totalShards
argument_list|,
name|results
argument_list|,
name|accumulatedExceptions
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|onShardOperation
specifier|private
name|void
name|onShardOperation
parameter_list|(
specifier|final
name|NodeRequest
name|request
parameter_list|,
specifier|final
name|Object
index|[]
name|shardResults
parameter_list|,
specifier|final
name|int
name|shardIndex
parameter_list|,
specifier|final
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}]  executing operation for shard [{}]"
argument_list|,
name|actionName
argument_list|,
name|shardRouting
operator|.
name|shortSummary
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ShardOperationResult
name|result
init|=
name|shardOperation
argument_list|(
name|request
operator|.
name|indicesLevelRequest
argument_list|,
name|shardRouting
argument_list|)
decl_stmt|;
name|shardResults
index|[
name|shardIndex
index|]
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}]  completed operation for shard [{}]"
argument_list|,
name|actionName
argument_list|,
name|shardRouting
operator|.
name|shortSummary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|BroadcastShardOperationFailedException
name|e
init|=
operator|new
name|BroadcastShardOperationFailedException
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"operation "
operator|+
name|actionName
operator|+
literal|" failed"
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|e
operator|.
name|setIndex
argument_list|(
name|shardRouting
operator|.
name|getIndexName
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|.
name|setShard
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
name|shardResults
index|[
name|shardIndex
index|]
operator|=
name|e
expr_stmt|;
if|if
condition|(
name|TransportActions
operator|.
name|isShardNotAvailableException
argument_list|(
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] failed to execute operation for shard [{}]"
argument_list|,
name|t
argument_list|,
name|actionName
argument_list|,
name|shardRouting
operator|.
name|shortSummary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] failed to execute operation for shard [{}]"
argument_list|,
name|t
argument_list|,
name|actionName
argument_list|,
name|shardRouting
operator|.
name|shortSummary
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|NodeRequest
specifier|public
class|class
name|NodeRequest
extends|extends
name|ChildTaskRequest
implements|implements
name|IndicesRequest
block|{
DECL|field|nodeId
specifier|private
name|String
name|nodeId
decl_stmt|;
DECL|field|shards
specifier|private
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
decl_stmt|;
DECL|field|indicesLevelRequest
specifier|protected
name|Request
name|indicesLevelRequest
decl_stmt|;
DECL|method|NodeRequest
specifier|public
name|NodeRequest
parameter_list|()
block|{         }
DECL|method|NodeRequest
specifier|public
name|NodeRequest
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|Request
name|request
parameter_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|shards
parameter_list|)
block|{
name|this
operator|.
name|indicesLevelRequest
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|shards
operator|=
name|shards
expr_stmt|;
name|this
operator|.
name|nodeId
operator|=
name|nodeId
expr_stmt|;
block|}
DECL|method|getShards
specifier|public
name|List
argument_list|<
name|ShardRouting
argument_list|>
name|getShards
parameter_list|()
block|{
return|return
name|shards
return|;
block|}
DECL|method|getNodeId
specifier|public
name|String
name|getNodeId
parameter_list|()
block|{
return|return
name|nodeId
return|;
block|}
annotation|@
name|Override
DECL|method|indices
specifier|public
name|String
index|[]
name|indices
parameter_list|()
block|{
return|return
name|indicesLevelRequest
operator|.
name|indices
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|indicesOptions
specifier|public
name|IndicesOptions
name|indicesOptions
parameter_list|()
block|{
return|return
name|indicesLevelRequest
operator|.
name|indicesOptions
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|indicesLevelRequest
operator|=
name|readRequestFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|int
name|size
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|shards
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|shards
operator|.
name|add
argument_list|(
name|ShardRouting
operator|.
name|readShardRoutingEntry
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nodeId
operator|=
name|in
operator|.
name|readString
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|indicesLevelRequest
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|int
name|size
init|=
name|shards
operator|.
name|size
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|shards
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeString
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|NodeResponse
class|class
name|NodeResponse
extends|extends
name|TransportResponse
block|{
DECL|field|nodeId
specifier|protected
name|String
name|nodeId
decl_stmt|;
DECL|field|totalShards
specifier|protected
name|int
name|totalShards
decl_stmt|;
DECL|field|exceptions
specifier|protected
name|List
argument_list|<
name|BroadcastShardOperationFailedException
argument_list|>
name|exceptions
decl_stmt|;
DECL|field|results
specifier|protected
name|List
argument_list|<
name|ShardOperationResult
argument_list|>
name|results
decl_stmt|;
DECL|method|NodeResponse
specifier|public
name|NodeResponse
parameter_list|()
block|{         }
DECL|method|NodeResponse
specifier|public
name|NodeResponse
parameter_list|(
name|String
name|nodeId
parameter_list|,
name|int
name|totalShards
parameter_list|,
name|List
argument_list|<
name|ShardOperationResult
argument_list|>
name|results
parameter_list|,
name|List
argument_list|<
name|BroadcastShardOperationFailedException
argument_list|>
name|exceptions
parameter_list|)
block|{
name|this
operator|.
name|nodeId
operator|=
name|nodeId
expr_stmt|;
name|this
operator|.
name|totalShards
operator|=
name|totalShards
expr_stmt|;
name|this
operator|.
name|results
operator|=
name|results
expr_stmt|;
name|this
operator|.
name|exceptions
operator|=
name|exceptions
expr_stmt|;
block|}
DECL|method|getNodeId
specifier|public
name|String
name|getNodeId
parameter_list|()
block|{
return|return
name|nodeId
return|;
block|}
DECL|method|getTotalShards
specifier|public
name|int
name|getTotalShards
parameter_list|()
block|{
return|return
name|totalShards
return|;
block|}
DECL|method|getSuccessfulShards
specifier|public
name|int
name|getSuccessfulShards
parameter_list|()
block|{
return|return
name|results
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getExceptions
specifier|public
name|List
argument_list|<
name|BroadcastShardOperationFailedException
argument_list|>
name|getExceptions
parameter_list|()
block|{
return|return
name|exceptions
return|;
block|}
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|nodeId
operator|=
name|in
operator|.
name|readString
argument_list|()
expr_stmt|;
name|totalShards
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|int
name|resultsSize
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|results
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|resultsSize
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|resultsSize
operator|>
literal|0
condition|;
name|resultsSize
operator|--
control|)
block|{
specifier|final
name|ShardOperationResult
name|result
init|=
name|in
operator|.
name|readBoolean
argument_list|()
condition|?
name|readShardResult
argument_list|(
name|in
argument_list|)
else|:
literal|null
decl_stmt|;
name|results
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|.
name|readBoolean
argument_list|()
condition|)
block|{
name|int
name|failureShards
init|=
name|in
operator|.
name|readVInt
argument_list|()
decl_stmt|;
name|exceptions
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|failureShards
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|failureShards
condition|;
name|i
operator|++
control|)
block|{
name|exceptions
operator|.
name|add
argument_list|(
operator|new
name|BroadcastShardOperationFailedException
argument_list|(
name|in
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exceptions
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeString
argument_list|(
name|nodeId
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|totalShards
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|results
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|ShardOperationResult
name|result
range|:
name|results
control|)
block|{
name|out
operator|.
name|writeOptionalStreamable
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeBoolean
argument_list|(
name|exceptions
operator|!=
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|exceptions
operator|!=
literal|null
condition|)
block|{
name|int
name|failureShards
init|=
name|exceptions
operator|.
name|size
argument_list|()
decl_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|failureShards
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|failureShards
condition|;
name|i
operator|++
control|)
block|{
name|exceptions
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Can be used for implementations of {@link #shardOperation(BroadcastRequest, ShardRouting) shardOperation} for      * which there is no shard-level return value.      */
DECL|class|EmptyResult
specifier|public
specifier|final
specifier|static
class|class
name|EmptyResult
implements|implements
name|Streamable
block|{
DECL|field|INSTANCE
specifier|public
specifier|static
name|EmptyResult
name|INSTANCE
init|=
operator|new
name|EmptyResult
argument_list|()
decl_stmt|;
DECL|method|EmptyResult
specifier|private
name|EmptyResult
parameter_list|()
block|{         }
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{         }
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{         }
DECL|method|readEmptyResultFrom
specifier|public
specifier|static
name|EmptyResult
name|readEmptyResultFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
block|{
return|return
name|INSTANCE
return|;
block|}
block|}
block|}
end_class

end_unit

