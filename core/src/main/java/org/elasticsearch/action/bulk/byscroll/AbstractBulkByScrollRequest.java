begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.action.bulk.byscroll
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|bulk
operator|.
name|byscroll
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ActionRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ActionRequestValidationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|search
operator|.
name|SearchRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|ActiveShardCount
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|support
operator|.
name|replication
operator|.
name|ReplicationRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|builder
operator|.
name|SearchSourceBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|TaskId
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ValidateActions
operator|.
name|addValidationError
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
operator|.
name|timeValueMillis
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
operator|.
name|timeValueMinutes
import|;
end_import

begin_class
DECL|class|AbstractBulkByScrollRequest
specifier|public
specifier|abstract
class|class
name|AbstractBulkByScrollRequest
parameter_list|<
name|Self
extends|extends
name|AbstractBulkByScrollRequest
parameter_list|<
name|Self
parameter_list|>
parameter_list|>
extends|extends
name|ActionRequest
block|{
DECL|field|SIZE_ALL_MATCHES
specifier|public
specifier|static
specifier|final
name|int
name|SIZE_ALL_MATCHES
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|DEFAULT_SCROLL_TIMEOUT
specifier|private
specifier|static
specifier|final
name|TimeValue
name|DEFAULT_SCROLL_TIMEOUT
init|=
name|timeValueMinutes
argument_list|(
literal|5
argument_list|)
decl_stmt|;
DECL|field|DEFAULT_SCROLL_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_SCROLL_SIZE
init|=
literal|1000
decl_stmt|;
comment|/**      * The search to be executed.      */
DECL|field|searchRequest
specifier|private
name|SearchRequest
name|searchRequest
decl_stmt|;
comment|/**      * Maximum number of processed documents. Defaults to -1 meaning process all      * documents.      */
DECL|field|size
specifier|private
name|int
name|size
init|=
name|SIZE_ALL_MATCHES
decl_stmt|;
comment|/**      * Should version conflicts cause aborts? Defaults to true.      */
DECL|field|abortOnVersionConflict
specifier|private
name|boolean
name|abortOnVersionConflict
init|=
literal|true
decl_stmt|;
comment|/**      * Call refresh on the indexes we've written to after the request ends?      */
DECL|field|refresh
specifier|private
name|boolean
name|refresh
init|=
literal|false
decl_stmt|;
comment|/**      * Timeout to wait for the shards on to be available for each bulk request?      */
DECL|field|timeout
specifier|private
name|TimeValue
name|timeout
init|=
name|ReplicationRequest
operator|.
name|DEFAULT_TIMEOUT
decl_stmt|;
comment|/**      * The number of shard copies that must be active before proceeding with the write.      */
DECL|field|activeShardCount
specifier|private
name|ActiveShardCount
name|activeShardCount
init|=
name|ActiveShardCount
operator|.
name|DEFAULT
decl_stmt|;
comment|/**      * Initial delay after a rejection before retrying a bulk request. With the default maxRetries the total backoff for retrying rejections      * is about one minute per bulk request. Once the entire bulk request is successful the retry counter resets.      */
DECL|field|retryBackoffInitialTime
specifier|private
name|TimeValue
name|retryBackoffInitialTime
init|=
name|timeValueMillis
argument_list|(
literal|500
argument_list|)
decl_stmt|;
comment|/**      * Total number of retries attempted for rejections. There is no way to ask for unlimited retries.      */
DECL|field|maxRetries
specifier|private
name|int
name|maxRetries
init|=
literal|11
decl_stmt|;
comment|/**      * The throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the      * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to      * make sure that it contains any time that we might wait.      */
DECL|field|requestsPerSecond
specifier|private
name|float
name|requestsPerSecond
init|=
name|Float
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
comment|/**      * Should this task store its result?      */
DECL|field|shouldStoreResult
specifier|private
name|boolean
name|shouldStoreResult
decl_stmt|;
comment|/**      * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.      */
DECL|field|slices
specifier|private
name|int
name|slices
init|=
literal|1
decl_stmt|;
comment|/**      * Constructor for deserialization.      */
DECL|method|AbstractBulkByScrollRequest
specifier|public
name|AbstractBulkByScrollRequest
parameter_list|()
block|{     }
comment|/**      * Constructor for actual use.      *      * @param searchRequest the search request to execute to get the documents to process      * @param setDefaults should this request set the defaults on the search request? Usually set to true but leave it false to support      *        request slicing      */
DECL|method|AbstractBulkByScrollRequest
specifier|public
name|AbstractBulkByScrollRequest
parameter_list|(
name|SearchRequest
name|searchRequest
parameter_list|,
name|boolean
name|setDefaults
parameter_list|)
block|{
name|this
operator|.
name|searchRequest
operator|=
name|searchRequest
expr_stmt|;
comment|// Set the defaults which differ from SearchRequest's defaults.
if|if
condition|(
name|setDefaults
condition|)
block|{
name|searchRequest
operator|.
name|scroll
argument_list|(
name|DEFAULT_SCROLL_TIMEOUT
argument_list|)
expr_stmt|;
name|searchRequest
operator|.
name|source
argument_list|(
operator|new
name|SearchSourceBuilder
argument_list|()
argument_list|)
expr_stmt|;
name|searchRequest
operator|.
name|source
argument_list|()
operator|.
name|size
argument_list|(
name|DEFAULT_SCROLL_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * `this` cast to Self. Used for building fluent methods without cast      * warnings.      */
DECL|method|self
specifier|protected
specifier|abstract
name|Self
name|self
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|validate
specifier|public
name|ActionRequestValidationException
name|validate
parameter_list|()
block|{
name|ActionRequestValidationException
name|e
init|=
name|searchRequest
operator|.
name|validate
argument_list|()
decl_stmt|;
if|if
condition|(
name|searchRequest
operator|.
name|source
argument_list|()
operator|.
name|from
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
name|e
operator|=
name|addValidationError
argument_list|(
literal|"from is not supported in this context"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|searchRequest
operator|.
name|source
argument_list|()
operator|.
name|storedFields
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|e
operator|=
name|addValidationError
argument_list|(
literal|"stored_fields is not supported in this context"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxRetries
operator|<
literal|0
condition|)
block|{
name|e
operator|=
name|addValidationError
argument_list|(
literal|"retries cannnot be negative"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
operator|==
operator|(
name|size
operator|==
operator|-
literal|1
operator|||
name|size
operator|>
literal|0
operator|)
condition|)
block|{
name|e
operator|=
name|addValidationError
argument_list|(
literal|"size should be greater than 0 if the request is limited to some number of documents or -1 if it isn't but it was ["
operator|+
name|size
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|searchRequest
operator|.
name|source
argument_list|()
operator|.
name|slice
argument_list|()
operator|!=
literal|null
operator|&&
name|slices
operator|!=
literal|1
condition|)
block|{
name|e
operator|=
name|addValidationError
argument_list|(
literal|"can't specify both slice and workers"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|e
return|;
block|}
comment|/**      * Maximum number of processed documents. Defaults to -1 meaning process all      * documents.      */
DECL|method|getSize
specifier|public
name|int
name|getSize
parameter_list|()
block|{
return|return
name|size
return|;
block|}
comment|/**      * Maximum number of processed documents. Defaults to -1 meaning process all      * documents.      */
DECL|method|setSize
specifier|public
name|Self
name|setSize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Should version conflicts cause aborts? Defaults to false.      */
DECL|method|isAbortOnVersionConflict
specifier|public
name|boolean
name|isAbortOnVersionConflict
parameter_list|()
block|{
return|return
name|abortOnVersionConflict
return|;
block|}
comment|/**      * Should version conflicts cause aborts? Defaults to false.      */
DECL|method|setAbortOnVersionConflict
specifier|public
name|Self
name|setAbortOnVersionConflict
parameter_list|(
name|boolean
name|abortOnVersionConflict
parameter_list|)
block|{
name|this
operator|.
name|abortOnVersionConflict
operator|=
name|abortOnVersionConflict
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Sets abortOnVersionConflict based on REST-friendly names.      */
DECL|method|setConflicts
specifier|public
name|void
name|setConflicts
parameter_list|(
name|String
name|conflicts
parameter_list|)
block|{
switch|switch
condition|(
name|conflicts
condition|)
block|{
case|case
literal|"proceed"
case|:
name|setAbortOnVersionConflict
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
case|case
literal|"abort"
case|:
name|setAbortOnVersionConflict
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"conflicts may only be \"proceed\" or \"abort\" but was ["
operator|+
name|conflicts
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
comment|/**      * The search request that matches the documents to process.      */
DECL|method|getSearchRequest
specifier|public
name|SearchRequest
name|getSearchRequest
parameter_list|()
block|{
return|return
name|searchRequest
return|;
block|}
comment|/**      * Call refresh on the indexes we've written to after the request ends?      */
DECL|method|isRefresh
specifier|public
name|boolean
name|isRefresh
parameter_list|()
block|{
return|return
name|refresh
return|;
block|}
comment|/**      * Call refresh on the indexes we've written to after the request ends?      */
DECL|method|setRefresh
specifier|public
name|Self
name|setRefresh
parameter_list|(
name|boolean
name|refresh
parameter_list|)
block|{
name|this
operator|.
name|refresh
operator|=
name|refresh
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Timeout to wait for the shards on to be available for each bulk request?      */
DECL|method|getTimeout
specifier|public
name|TimeValue
name|getTimeout
parameter_list|()
block|{
return|return
name|timeout
return|;
block|}
comment|/**      * Timeout to wait for the shards on to be available for each bulk request?      */
DECL|method|setTimeout
specifier|public
name|Self
name|setTimeout
parameter_list|(
name|TimeValue
name|timeout
parameter_list|)
block|{
name|this
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * The number of shard copies that must be active before proceeding with the write.      */
DECL|method|getWaitForActiveShards
specifier|public
name|ActiveShardCount
name|getWaitForActiveShards
parameter_list|()
block|{
return|return
name|activeShardCount
return|;
block|}
comment|/**      * Sets the number of shard copies that must be active before proceeding with the write.      * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.      */
DECL|method|setWaitForActiveShards
specifier|public
name|Self
name|setWaitForActiveShards
parameter_list|(
name|ActiveShardCount
name|activeShardCount
parameter_list|)
block|{
name|this
operator|.
name|activeShardCount
operator|=
name|activeShardCount
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical      * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}      * to get the ActiveShardCount.      */
DECL|method|setWaitForActiveShards
specifier|public
name|Self
name|setWaitForActiveShards
parameter_list|(
specifier|final
name|int
name|waitForActiveShards
parameter_list|)
block|{
return|return
name|setWaitForActiveShards
argument_list|(
name|ActiveShardCount
operator|.
name|from
argument_list|(
name|waitForActiveShards
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Initial delay after a rejection before retrying request.      */
DECL|method|getRetryBackoffInitialTime
specifier|public
name|TimeValue
name|getRetryBackoffInitialTime
parameter_list|()
block|{
return|return
name|retryBackoffInitialTime
return|;
block|}
comment|/**      * Set the initial delay after a rejection before retrying request.      */
DECL|method|setRetryBackoffInitialTime
specifier|public
name|Self
name|setRetryBackoffInitialTime
parameter_list|(
name|TimeValue
name|retryBackoffInitialTime
parameter_list|)
block|{
name|this
operator|.
name|retryBackoffInitialTime
operator|=
name|retryBackoffInitialTime
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Total number of retries attempted for rejections.      */
DECL|method|getMaxRetries
specifier|public
name|int
name|getMaxRetries
parameter_list|()
block|{
return|return
name|maxRetries
return|;
block|}
comment|/**      * Set the total number of retries attempted for rejections. There is no way to ask for unlimited retries.      */
DECL|method|setMaxRetries
specifier|public
name|Self
name|setMaxRetries
parameter_list|(
name|int
name|maxRetries
parameter_list|)
block|{
name|this
operator|.
name|maxRetries
operator|=
name|maxRetries
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * The throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the      * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to      * make sure that it contains any time that we might wait.      */
DECL|method|getRequestsPerSecond
specifier|public
name|float
name|getRequestsPerSecond
parameter_list|()
block|{
return|return
name|requestsPerSecond
return|;
block|}
comment|/**      * Set the throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the      * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to      * make sure that it contains any time that we might wait.      */
DECL|method|setRequestsPerSecond
specifier|public
name|Self
name|setRequestsPerSecond
parameter_list|(
name|float
name|requestsPerSecond
parameter_list|)
block|{
if|if
condition|(
name|requestsPerSecond
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[requests_per_second] must be greater than 0. Use Float.POSITIVE_INFINITY to disable throttling."
argument_list|)
throw|;
block|}
name|this
operator|.
name|requestsPerSecond
operator|=
name|requestsPerSecond
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * Should this task store its result after it has finished?      */
DECL|method|setShouldStoreResult
specifier|public
name|Self
name|setShouldStoreResult
parameter_list|(
name|boolean
name|shouldStoreResult
parameter_list|)
block|{
name|this
operator|.
name|shouldStoreResult
operator|=
name|shouldStoreResult
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getShouldStoreResult
specifier|public
name|boolean
name|getShouldStoreResult
parameter_list|()
block|{
return|return
name|shouldStoreResult
return|;
block|}
comment|/**      * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.      */
DECL|method|setSlices
specifier|public
name|Self
name|setSlices
parameter_list|(
name|int
name|slices
parameter_list|)
block|{
if|if
condition|(
name|slices
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[slices] must be at least 1"
argument_list|)
throw|;
block|}
name|this
operator|.
name|slices
operator|=
name|slices
expr_stmt|;
return|return
name|self
argument_list|()
return|;
block|}
comment|/**      * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.      */
DECL|method|getSlices
specifier|public
name|int
name|getSlices
parameter_list|()
block|{
return|return
name|slices
return|;
block|}
comment|/**      * Build a new request for a slice of the parent request.      */
DECL|method|forSlice
specifier|protected
specifier|abstract
name|Self
name|forSlice
parameter_list|(
name|TaskId
name|slicingTask
parameter_list|,
name|SearchRequest
name|slice
parameter_list|)
function_decl|;
comment|/**      * Setup a clone of this request with the information needed to process a slice of it.      */
DECL|method|doForSlice
specifier|protected
name|Self
name|doForSlice
parameter_list|(
name|Self
name|request
parameter_list|,
name|TaskId
name|slicingTask
parameter_list|)
block|{
name|request
operator|.
name|setAbortOnVersionConflict
argument_list|(
name|abortOnVersionConflict
argument_list|)
operator|.
name|setRefresh
argument_list|(
name|refresh
argument_list|)
operator|.
name|setTimeout
argument_list|(
name|timeout
argument_list|)
operator|.
name|setWaitForActiveShards
argument_list|(
name|activeShardCount
argument_list|)
operator|.
name|setRetryBackoffInitialTime
argument_list|(
name|retryBackoffInitialTime
argument_list|)
operator|.
name|setMaxRetries
argument_list|(
name|maxRetries
argument_list|)
comment|// Parent task will store result
operator|.
name|setShouldStoreResult
argument_list|(
literal|false
argument_list|)
comment|// Split requests per second between all slices
operator|.
name|setRequestsPerSecond
argument_list|(
name|requestsPerSecond
operator|/
name|slices
argument_list|)
comment|// Size is split between workers. This means the size might round down!
operator|.
name|setSize
argument_list|(
name|size
operator|==
name|SIZE_ALL_MATCHES
condition|?
name|SIZE_ALL_MATCHES
else|:
name|size
operator|/
name|slices
argument_list|)
comment|// Sub requests don't have workers
operator|.
name|setSlices
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Set the parent task so this task is cancelled if we cancel the parent
name|request
operator|.
name|setParentTask
argument_list|(
name|slicingTask
argument_list|)
expr_stmt|;
comment|// TODO It'd be nice not to refresh on every slice. Instead we should refresh after the sub requests finish.
return|return
name|request
return|;
block|}
annotation|@
name|Override
DECL|method|createTask
specifier|public
name|Task
name|createTask
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|action
parameter_list|,
name|TaskId
name|parentTaskId
parameter_list|)
block|{
if|if
condition|(
name|slices
operator|>
literal|1
condition|)
block|{
return|return
operator|new
name|ParentBulkByScrollTask
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|action
argument_list|,
name|getDescription
argument_list|()
argument_list|,
name|parentTaskId
argument_list|,
name|slices
argument_list|)
return|;
block|}
comment|/* Extract the slice from the search request so it'll be available in the status. This is potentially useful for users that manually          * slice their search requests so they can keep track of it and **absolutely** useful for automatically sliced reindex requests so          * they can properly track the responses. */
name|Integer
name|sliceId
init|=
name|searchRequest
operator|.
name|source
argument_list|()
operator|.
name|slice
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|searchRequest
operator|.
name|source
argument_list|()
operator|.
name|slice
argument_list|()
operator|.
name|getId
argument_list|()
decl_stmt|;
return|return
operator|new
name|WorkingBulkByScrollTask
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|action
argument_list|,
name|getDescription
argument_list|()
argument_list|,
name|parentTaskId
argument_list|,
name|sliceId
argument_list|,
name|requestsPerSecond
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|searchRequest
operator|=
operator|new
name|SearchRequest
argument_list|()
expr_stmt|;
name|searchRequest
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|abortOnVersionConflict
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|size
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|refresh
operator|=
name|in
operator|.
name|readBoolean
argument_list|()
expr_stmt|;
name|timeout
operator|=
operator|new
name|TimeValue
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|activeShardCount
operator|=
name|ActiveShardCount
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|retryBackoffInitialTime
operator|=
operator|new
name|TimeValue
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|maxRetries
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|requestsPerSecond
operator|=
name|in
operator|.
name|readFloat
argument_list|()
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_5_1_1
argument_list|)
condition|)
block|{
name|slices
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|slices
operator|=
literal|1
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|searchRequest
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|abortOnVersionConflict
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBoolean
argument_list|(
name|refresh
argument_list|)
expr_stmt|;
name|timeout
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|activeShardCount
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|retryBackoffInitialTime
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|maxRetries
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeFloat
argument_list|(
name|requestsPerSecond
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_5_1_1
argument_list|)
condition|)
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|slices
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slices
operator|>
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempting to send sliced reindex-style request to a node that doesn't support "
operator|+
literal|"it. Version is ["
operator|+
name|out
operator|.
name|getVersion
argument_list|()
operator|+
literal|"] but must be ["
operator|+
name|Version
operator|.
name|V_5_1_1
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Append a short description of the search request to a StringBuilder. Used      * to make toString.      */
DECL|method|searchToString
specifier|protected
name|void
name|searchToString
parameter_list|(
name|StringBuilder
name|b
parameter_list|)
block|{
if|if
condition|(
name|searchRequest
operator|.
name|indices
argument_list|()
operator|!=
literal|null
operator|&&
name|searchRequest
operator|.
name|indices
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|searchRequest
operator|.
name|indices
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b
operator|.
name|append
argument_list|(
literal|"[all indices]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|searchRequest
operator|.
name|types
argument_list|()
operator|!=
literal|null
operator|&&
name|searchRequest
operator|.
name|types
argument_list|()
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|b
operator|.
name|append
argument_list|(
name|Arrays
operator|.
name|toString
argument_list|(
name|searchRequest
operator|.
name|types
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getDescription
specifier|public
name|String
name|getDescription
parameter_list|()
block|{
return|return
name|this
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
end_class

end_unit

