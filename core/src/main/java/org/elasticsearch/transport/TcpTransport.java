begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.transport
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|transport
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntHashSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|util
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|NotifyOnceListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|CheckedBiConsumer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|breaker
operator|.
name|CircuitBreaker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|CompositeBytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|Lifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|Compressor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|CompressorFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|NotCompressedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|NamedWriteableAwareStreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|NamedWriteableRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|ReleasableBytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lease
operator|.
name|Releasable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lease
operator|.
name|Releasables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|metrics
operator|.
name|CounterMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|metrics
operator|.
name|MeanMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|network
operator|.
name|NetworkAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|network
operator|.
name|NetworkService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|network
operator|.
name|NetworkUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|transport
operator|.
name|BoundTransportAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|transport
operator|.
name|PortsRange
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|transport
operator|.
name|TransportAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|BigArrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractLifecycleRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|EsRejectedExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|KeyedLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|iterable
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|breaker
operator|.
name|CircuitBreakerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|monitor
operator|.
name|jvm
operator|.
name|JvmInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|rest
operator|.
name|RestStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|StreamCorruptedException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|BindException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|InetSocketAddress
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|UnknownHostException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|CancelledKeyException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Optional
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
operator|.
name|boolSetting
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
operator|.
name|intSetting
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
operator|.
name|timeSetting
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|transport
operator|.
name|NetworkExceptionHelper
operator|.
name|isCloseConnectionException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|transport
operator|.
name|NetworkExceptionHelper
operator|.
name|isConnectException
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
operator|.
name|newConcurrentMap
import|;
end_import

begin_class
DECL|class|TcpTransport
specifier|public
specifier|abstract
class|class
name|TcpTransport
parameter_list|<
name|Channel
parameter_list|>
extends|extends
name|AbstractLifecycleComponent
implements|implements
name|Transport
block|{
DECL|field|TRANSPORT_SERVER_WORKER_THREAD_NAME_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|TRANSPORT_SERVER_WORKER_THREAD_NAME_PREFIX
init|=
literal|"transport_server_worker"
decl_stmt|;
DECL|field|TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX
specifier|public
specifier|static
specifier|final
name|String
name|TRANSPORT_CLIENT_BOSS_THREAD_NAME_PREFIX
init|=
literal|"transport_client_boss"
decl_stmt|;
comment|// the scheduled internal ping interval setting, defaults to disabled (-1)
DECL|field|PING_SCHEDULE
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|TimeValue
argument_list|>
name|PING_SCHEDULE
init|=
name|timeSetting
argument_list|(
literal|"transport.ping_schedule"
argument_list|,
name|TimeValue
operator|.
name|timeValueSeconds
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|CONNECTIONS_PER_NODE_RECOVERY
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|CONNECTIONS_PER_NODE_RECOVERY
init|=
name|intSetting
argument_list|(
literal|"transport.connections_per_node.recovery"
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|CONNECTIONS_PER_NODE_BULK
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|CONNECTIONS_PER_NODE_BULK
init|=
name|intSetting
argument_list|(
literal|"transport.connections_per_node.bulk"
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|CONNECTIONS_PER_NODE_REG
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|CONNECTIONS_PER_NODE_REG
init|=
name|intSetting
argument_list|(
literal|"transport.connections_per_node.reg"
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|CONNECTIONS_PER_NODE_STATE
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|CONNECTIONS_PER_NODE_STATE
init|=
name|intSetting
argument_list|(
literal|"transport.connections_per_node.state"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|CONNECTIONS_PER_NODE_PING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|CONNECTIONS_PER_NODE_PING
init|=
name|intSetting
argument_list|(
literal|"transport.connections_per_node.ping"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|TCP_CONNECT_TIMEOUT
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|TimeValue
argument_list|>
name|TCP_CONNECT_TIMEOUT
init|=
name|timeSetting
argument_list|(
literal|"transport.tcp.connect_timeout"
argument_list|,
name|NetworkService
operator|.
name|TcpSettings
operator|.
name|TCP_CONNECT_TIMEOUT
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|TCP_NO_DELAY
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Boolean
argument_list|>
name|TCP_NO_DELAY
init|=
name|boolSetting
argument_list|(
literal|"transport.tcp_no_delay"
argument_list|,
name|NetworkService
operator|.
name|TcpSettings
operator|.
name|TCP_NO_DELAY
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|TCP_KEEP_ALIVE
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Boolean
argument_list|>
name|TCP_KEEP_ALIVE
init|=
name|boolSetting
argument_list|(
literal|"transport.tcp.keep_alive"
argument_list|,
name|NetworkService
operator|.
name|TcpSettings
operator|.
name|TCP_KEEP_ALIVE
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|TCP_REUSE_ADDRESS
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Boolean
argument_list|>
name|TCP_REUSE_ADDRESS
init|=
name|boolSetting
argument_list|(
literal|"transport.tcp.reuse_address"
argument_list|,
name|NetworkService
operator|.
name|TcpSettings
operator|.
name|TCP_REUSE_ADDRESS
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|TCP_SEND_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|ByteSizeValue
argument_list|>
name|TCP_SEND_BUFFER_SIZE
init|=
name|Setting
operator|.
name|byteSizeSetting
argument_list|(
literal|"transport.tcp.send_buffer_size"
argument_list|,
name|NetworkService
operator|.
name|TcpSettings
operator|.
name|TCP_SEND_BUFFER_SIZE
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|TCP_RECEIVE_BUFFER_SIZE
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|ByteSizeValue
argument_list|>
name|TCP_RECEIVE_BUFFER_SIZE
init|=
name|Setting
operator|.
name|byteSizeSetting
argument_list|(
literal|"transport.tcp.receive_buffer_size"
argument_list|,
name|NetworkService
operator|.
name|TcpSettings
operator|.
name|TCP_RECEIVE_BUFFER_SIZE
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|NINETY_PER_HEAP_SIZE
specifier|private
specifier|static
specifier|final
name|long
name|NINETY_PER_HEAP_SIZE
init|=
call|(
name|long
call|)
argument_list|(
name|JvmInfo
operator|.
name|jvmInfo
argument_list|()
operator|.
name|getMem
argument_list|()
operator|.
name|getHeapMax
argument_list|()
operator|.
name|getBytes
argument_list|()
operator|*
literal|0.9
argument_list|)
decl_stmt|;
DECL|field|PING_DATA_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|PING_DATA_SIZE
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|circuitBreakerService
specifier|private
specifier|final
name|CircuitBreakerService
name|circuitBreakerService
decl_stmt|;
comment|// package visibility for tests
DECL|field|scheduledPing
specifier|protected
specifier|final
name|ScheduledPing
name|scheduledPing
decl_stmt|;
DECL|field|pingSchedule
specifier|private
specifier|final
name|TimeValue
name|pingSchedule
decl_stmt|;
DECL|field|threadPool
specifier|protected
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|bigArrays
specifier|private
specifier|final
name|BigArrays
name|bigArrays
decl_stmt|;
DECL|field|networkService
specifier|protected
specifier|final
name|NetworkService
name|networkService
decl_stmt|;
DECL|field|transportServiceAdapter
specifier|protected
specifier|volatile
name|TransportServiceAdapter
name|transportServiceAdapter
decl_stmt|;
comment|// node id to actual channel
DECL|field|connectedNodes
specifier|protected
specifier|final
name|ConcurrentMap
argument_list|<
name|DiscoveryNode
argument_list|,
name|NodeChannels
argument_list|>
name|connectedNodes
init|=
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|field|serverChannels
specifier|protected
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Channel
argument_list|>
argument_list|>
name|serverChannels
init|=
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|field|profileBoundAddresses
specifier|protected
specifier|final
name|ConcurrentMap
argument_list|<
name|String
argument_list|,
name|BoundTransportAddress
argument_list|>
name|profileBoundAddresses
init|=
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|field|connectionLock
specifier|protected
specifier|final
name|KeyedLock
argument_list|<
name|String
argument_list|>
name|connectionLock
init|=
operator|new
name|KeyedLock
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|namedWriteableRegistry
specifier|private
specifier|final
name|NamedWriteableRegistry
name|namedWriteableRegistry
decl_stmt|;
comment|// this lock is here to make sure we close this transport and disconnect all the client nodes
comment|// connections while no connect operations is going on... (this might help with 100% CPU when stopping the transport?)
DECL|field|closeLock
specifier|protected
specifier|final
name|ReadWriteLock
name|closeLock
init|=
operator|new
name|ReentrantReadWriteLock
argument_list|()
decl_stmt|;
DECL|field|compress
specifier|protected
specifier|final
name|boolean
name|compress
decl_stmt|;
DECL|field|boundAddress
specifier|protected
specifier|volatile
name|BoundTransportAddress
name|boundAddress
decl_stmt|;
DECL|field|transportName
specifier|private
specifier|final
name|String
name|transportName
decl_stmt|;
DECL|field|defaultConnectionProfile
specifier|protected
specifier|final
name|ConnectionProfile
name|defaultConnectionProfile
decl_stmt|;
DECL|field|pendingHandshakes
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Long
argument_list|,
name|HandshakeResponseHandler
argument_list|>
name|pendingHandshakes
init|=
operator|new
name|ConcurrentHashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|requestIdGenerator
specifier|private
specifier|final
name|AtomicLong
name|requestIdGenerator
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|numHandshakes
specifier|private
specifier|final
name|CounterMetric
name|numHandshakes
init|=
operator|new
name|CounterMetric
argument_list|()
decl_stmt|;
DECL|field|HANDSHAKE_ACTION_NAME
specifier|private
specifier|static
specifier|final
name|String
name|HANDSHAKE_ACTION_NAME
init|=
literal|"internal:tcp/handshake"
decl_stmt|;
DECL|field|readBytesMetric
specifier|private
specifier|final
name|MeanMetric
name|readBytesMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|field|transmittedBytesMetric
specifier|private
specifier|final
name|MeanMetric
name|transmittedBytesMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|method|TcpTransport
specifier|public
name|TcpTransport
parameter_list|(
name|String
name|transportName
parameter_list|,
name|Settings
name|settings
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|BigArrays
name|bigArrays
parameter_list|,
name|CircuitBreakerService
name|circuitBreakerService
parameter_list|,
name|NamedWriteableRegistry
name|namedWriteableRegistry
parameter_list|,
name|NetworkService
name|networkService
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|bigArrays
operator|=
name|bigArrays
expr_stmt|;
name|this
operator|.
name|circuitBreakerService
operator|=
name|circuitBreakerService
expr_stmt|;
name|this
operator|.
name|scheduledPing
operator|=
operator|new
name|ScheduledPing
argument_list|()
expr_stmt|;
name|this
operator|.
name|pingSchedule
operator|=
name|PING_SCHEDULE
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|namedWriteableRegistry
operator|=
name|namedWriteableRegistry
expr_stmt|;
name|this
operator|.
name|compress
operator|=
name|Transport
operator|.
name|TRANSPORT_TCP_COMPRESS
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|networkService
operator|=
name|networkService
expr_stmt|;
name|this
operator|.
name|transportName
operator|=
name|transportName
expr_stmt|;
name|defaultConnectionProfile
operator|=
name|buildDefaultConnectionProfile
argument_list|(
name|settings
argument_list|)
expr_stmt|;
block|}
DECL|method|buildDefaultConnectionProfile
specifier|static
name|ConnectionProfile
name|buildDefaultConnectionProfile
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|int
name|connectionsPerNodeRecovery
init|=
name|CONNECTIONS_PER_NODE_RECOVERY
operator|.
name|get
argument_list|(
name|settings
argument_list|)
decl_stmt|;
name|int
name|connectionsPerNodeBulk
init|=
name|CONNECTIONS_PER_NODE_BULK
operator|.
name|get
argument_list|(
name|settings
argument_list|)
decl_stmt|;
name|int
name|connectionsPerNodeReg
init|=
name|CONNECTIONS_PER_NODE_REG
operator|.
name|get
argument_list|(
name|settings
argument_list|)
decl_stmt|;
name|int
name|connectionsPerNodeState
init|=
name|CONNECTIONS_PER_NODE_STATE
operator|.
name|get
argument_list|(
name|settings
argument_list|)
decl_stmt|;
name|int
name|connectionsPerNodePing
init|=
name|CONNECTIONS_PER_NODE_PING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
decl_stmt|;
name|ConnectionProfile
operator|.
name|Builder
name|builder
init|=
operator|new
name|ConnectionProfile
operator|.
name|Builder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|setConnectTimeout
argument_list|(
name|TCP_CONNECT_TIMEOUT
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|setHandshakeTimeout
argument_list|(
name|TCP_CONNECT_TIMEOUT
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addConnections
argument_list|(
name|connectionsPerNodeBulk
argument_list|,
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|BULK
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addConnections
argument_list|(
name|connectionsPerNodePing
argument_list|,
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|PING
argument_list|)
expr_stmt|;
comment|// if we are not master eligible we don't need a dedicated channel to publish the state
name|builder
operator|.
name|addConnections
argument_list|(
name|DiscoveryNode
operator|.
name|isMasterNode
argument_list|(
name|settings
argument_list|)
condition|?
name|connectionsPerNodeState
else|:
literal|0
argument_list|,
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|STATE
argument_list|)
expr_stmt|;
comment|// if we are not a data-node we don't need any dedicated channels for recovery
name|builder
operator|.
name|addConnections
argument_list|(
name|DiscoveryNode
operator|.
name|isDataNode
argument_list|(
name|settings
argument_list|)
condition|?
name|connectionsPerNodeRecovery
else|:
literal|0
argument_list|,
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|RECOVERY
argument_list|)
expr_stmt|;
name|builder
operator|.
name|addConnections
argument_list|(
name|connectionsPerNodeReg
argument_list|,
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|REG
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
if|if
condition|(
name|pingSchedule
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|threadPool
operator|.
name|schedule
argument_list|(
name|pingSchedule
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|GENERIC
argument_list|,
name|scheduledPing
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|getInFlightRequestBreaker
specifier|public
name|CircuitBreaker
name|getInFlightRequestBreaker
parameter_list|()
block|{
comment|// We always obtain a fresh breaker to reflect changes to the breaker configuration.
return|return
name|circuitBreakerService
operator|.
name|getBreaker
argument_list|(
name|CircuitBreaker
operator|.
name|IN_FLIGHT_REQUESTS
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|transportServiceAdapter
specifier|public
name|void
name|transportServiceAdapter
parameter_list|(
name|TransportServiceAdapter
name|service
parameter_list|)
block|{
if|if
condition|(
name|service
operator|.
name|getRequestHandler
argument_list|(
name|HANDSHAKE_ACTION_NAME
argument_list|)
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|HANDSHAKE_ACTION_NAME
operator|+
literal|" is a reserved request handler and must not be registered"
argument_list|)
throw|;
block|}
name|this
operator|.
name|transportServiceAdapter
operator|=
name|service
expr_stmt|;
block|}
DECL|class|HandshakeResponseHandler
specifier|private
specifier|static
class|class
name|HandshakeResponseHandler
parameter_list|<
name|Channel
parameter_list|>
implements|implements
name|TransportResponseHandler
argument_list|<
name|VersionHandshakeResponse
argument_list|>
block|{
DECL|field|versionRef
specifier|final
name|AtomicReference
argument_list|<
name|Version
argument_list|>
name|versionRef
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|latch
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
DECL|field|exceptionRef
specifier|final
name|AtomicReference
argument_list|<
name|Exception
argument_list|>
name|exceptionRef
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|channel
specifier|final
name|Channel
name|channel
decl_stmt|;
DECL|method|HandshakeResponseHandler
name|HandshakeResponseHandler
parameter_list|(
name|Channel
name|channel
parameter_list|)
block|{
name|this
operator|.
name|channel
operator|=
name|channel
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|newInstance
specifier|public
name|VersionHandshakeResponse
name|newInstance
parameter_list|()
block|{
return|return
operator|new
name|VersionHandshakeResponse
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|handleResponse
specifier|public
name|void
name|handleResponse
parameter_list|(
name|VersionHandshakeResponse
name|response
parameter_list|)
block|{
specifier|final
name|boolean
name|success
init|=
name|versionRef
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|response
operator|.
name|version
argument_list|)
decl_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
assert|assert
name|success
assert|;
block|}
annotation|@
name|Override
DECL|method|handleException
specifier|public
name|void
name|handleException
parameter_list|(
name|TransportException
name|exp
parameter_list|)
block|{
specifier|final
name|boolean
name|success
init|=
name|exceptionRef
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|exp
argument_list|)
decl_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
assert|assert
name|success
assert|;
block|}
annotation|@
name|Override
DECL|method|executor
specifier|public
name|String
name|executor
parameter_list|()
block|{
return|return
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
return|;
block|}
block|}
DECL|class|ScheduledPing
specifier|public
class|class
name|ScheduledPing
extends|extends
name|AbstractLifecycleRunnable
block|{
comment|/**          * The magic number (must be lower than 0) for a ping message. This is handled          * specifically in {@link TcpTransport#validateMessageHeader}.          */
DECL|field|pingHeader
specifier|private
specifier|final
name|BytesReference
name|pingHeader
decl_stmt|;
DECL|field|successfulPings
specifier|final
name|CounterMetric
name|successfulPings
init|=
operator|new
name|CounterMetric
argument_list|()
decl_stmt|;
DECL|field|failedPings
specifier|final
name|CounterMetric
name|failedPings
init|=
operator|new
name|CounterMetric
argument_list|()
decl_stmt|;
DECL|method|ScheduledPing
specifier|public
name|ScheduledPing
parameter_list|()
block|{
name|super
argument_list|(
name|lifecycle
argument_list|,
name|logger
argument_list|)
expr_stmt|;
try|try
init|(
name|BytesStreamOutput
name|out
init|=
operator|new
name|BytesStreamOutput
argument_list|()
init|)
block|{
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|'E'
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeByte
argument_list|(
operator|(
name|byte
operator|)
literal|'S'
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|PING_DATA_SIZE
argument_list|)
expr_stmt|;
name|pingHeader
operator|=
name|out
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
comment|// won't happen
block|}
block|}
annotation|@
name|Override
DECL|method|doRunInLifecycle
specifier|protected
name|void
name|doRunInLifecycle
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|DiscoveryNode
argument_list|,
name|NodeChannels
argument_list|>
name|entry
range|:
name|connectedNodes
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|DiscoveryNode
name|node
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|NodeChannels
name|channels
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|Channel
name|channel
range|:
name|channels
operator|.
name|getChannels
argument_list|()
control|)
block|{
name|internalSendMessage
argument_list|(
name|channel
argument_list|,
name|pingHeader
argument_list|,
operator|new
name|SendMetricListener
argument_list|<
name|Channel
argument_list|>
argument_list|(
name|pingHeader
operator|.
name|length
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|innerInnerOnResponse
parameter_list|(
name|Channel
name|channel
parameter_list|)
block|{
name|successfulPings
operator|.
name|inc
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|innerOnFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|isOpen
argument_list|(
name|channel
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] failed to send ping transport message"
argument_list|,
name|node
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|failedPings
operator|.
name|inc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] failed to send ping transport message (channel closed)"
argument_list|,
name|node
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getSuccessfulPings
specifier|public
name|long
name|getSuccessfulPings
parameter_list|()
block|{
return|return
name|successfulPings
operator|.
name|count
argument_list|()
return|;
block|}
DECL|method|getFailedPings
specifier|public
name|long
name|getFailedPings
parameter_list|()
block|{
return|return
name|failedPings
operator|.
name|count
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|onAfterInLifecycle
specifier|protected
name|void
name|onAfterInLifecycle
parameter_list|()
block|{
try|try
block|{
name|threadPool
operator|.
name|schedule
argument_list|(
name|pingSchedule
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|GENERIC
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EsRejectedExecutionException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|.
name|isExecutorShutdown
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"couldn't schedule new ping execution, executor is shutting down"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|ex
throw|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onFailure
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|lifecycle
operator|.
name|stoppedOrClosed
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"failed to send ping transport message"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to send ping transport message"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|NodeChannels
specifier|public
specifier|final
class|class
name|NodeChannels
implements|implements
name|Connection
block|{
DECL|field|typeMapping
specifier|private
specifier|final
name|Map
argument_list|<
name|TransportRequestOptions
operator|.
name|Type
argument_list|,
name|ConnectionProfile
operator|.
name|ConnectionTypeHandle
argument_list|>
name|typeMapping
decl_stmt|;
DECL|field|channels
specifier|private
specifier|final
name|Channel
index|[]
name|channels
decl_stmt|;
DECL|field|node
specifier|private
specifier|final
name|DiscoveryNode
name|node
decl_stmt|;
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|version
specifier|private
specifier|final
name|Version
name|version
decl_stmt|;
DECL|method|NodeChannels
specifier|public
name|NodeChannels
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|Channel
index|[]
name|channels
parameter_list|,
name|ConnectionProfile
name|connectionProfile
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|channels
operator|=
name|channels
expr_stmt|;
assert|assert
name|channels
operator|.
name|length
operator|==
name|connectionProfile
operator|.
name|getNumConnections
argument_list|()
operator|:
literal|"expected channels size to be == "
operator|+
name|connectionProfile
operator|.
name|getNumConnections
argument_list|()
operator|+
literal|" but was: ["
operator|+
name|channels
operator|.
name|length
operator|+
literal|"]"
assert|;
name|typeMapping
operator|=
operator|new
name|EnumMap
argument_list|<>
argument_list|(
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|ConnectionProfile
operator|.
name|ConnectionTypeHandle
name|handle
range|:
name|connectionProfile
operator|.
name|getHandles
argument_list|()
control|)
block|{
for|for
control|(
name|TransportRequestOptions
operator|.
name|Type
name|type
range|:
name|handle
operator|.
name|getTypes
argument_list|()
control|)
name|typeMapping
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|handle
argument_list|)
expr_stmt|;
block|}
name|version
operator|=
name|node
operator|.
name|getVersion
argument_list|()
expr_stmt|;
block|}
DECL|method|NodeChannels
name|NodeChannels
parameter_list|(
name|NodeChannels
name|channels
parameter_list|,
name|Version
name|handshakeVersion
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|channels
operator|.
name|node
expr_stmt|;
name|this
operator|.
name|channels
operator|=
name|channels
operator|.
name|channels
expr_stmt|;
name|this
operator|.
name|typeMapping
operator|=
name|channels
operator|.
name|typeMapping
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|handshakeVersion
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getVersion
specifier|public
name|Version
name|getVersion
parameter_list|()
block|{
return|return
name|version
return|;
block|}
DECL|method|getChannels
specifier|public
name|List
argument_list|<
name|Channel
argument_list|>
name|getChannels
parameter_list|()
block|{
return|return
name|Arrays
operator|.
name|asList
argument_list|(
name|channels
argument_list|)
return|;
block|}
DECL|method|channel
specifier|public
name|Channel
name|channel
parameter_list|(
name|TransportRequestOptions
operator|.
name|Type
name|type
parameter_list|)
block|{
name|ConnectionProfile
operator|.
name|ConnectionTypeHandle
name|connectionTypeHandle
init|=
name|typeMapping
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|connectionTypeHandle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no type channel for ["
operator|+
name|type
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|connectionTypeHandle
operator|.
name|getChannel
argument_list|(
name|channels
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
try|try
block|{
name|closeChannels
argument_list|(
name|Arrays
operator|.
name|stream
argument_list|(
name|channels
argument_list|)
operator|.
name|filter
argument_list|(
name|Objects
operator|::
name|nonNull
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|transportServiceAdapter
operator|.
name|onConnectionClosed
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|getNode
specifier|public
name|DiscoveryNode
name|getNode
parameter_list|()
block|{
return|return
name|this
operator|.
name|node
return|;
block|}
annotation|@
name|Override
DECL|method|sendRequest
specifier|public
name|void
name|sendRequest
parameter_list|(
name|long
name|requestId
parameter_list|,
name|String
name|action
parameter_list|,
name|TransportRequest
name|request
parameter_list|,
name|TransportRequestOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransportException
block|{
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NodeNotConnectedException
argument_list|(
name|node
argument_list|,
literal|"connection already closed"
argument_list|)
throw|;
block|}
name|Channel
name|channel
init|=
name|channel
argument_list|(
name|options
operator|.
name|type
argument_list|()
argument_list|)
decl_stmt|;
name|sendRequestToChannel
argument_list|(
name|this
operator|.
name|node
argument_list|,
name|channel
argument_list|,
name|requestId
argument_list|,
name|action
argument_list|,
name|request
argument_list|,
name|options
argument_list|,
name|getVersion
argument_list|()
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|isClosed
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|closed
operator|.
name|get
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|nodeConnected
specifier|public
name|boolean
name|nodeConnected
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|)
block|{
return|return
name|connectedNodes
operator|.
name|containsKey
argument_list|(
name|node
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|connectToNode
specifier|public
name|void
name|connectToNode
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|ConnectionProfile
name|connectionProfile
parameter_list|,
name|CheckedBiConsumer
argument_list|<
name|Connection
argument_list|,
name|ConnectionProfile
argument_list|,
name|IOException
argument_list|>
name|connectionValidator
parameter_list|)
throws|throws
name|ConnectTransportException
block|{
name|connectionProfile
operator|=
name|resolveConnectionProfile
argument_list|(
name|connectionProfile
argument_list|,
name|defaultConnectionProfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConnectTransportException
argument_list|(
literal|null
argument_list|,
literal|"can't connect to a null node"
argument_list|)
throw|;
block|}
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// ensure we don't open connections while we are closing
try|try
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
init|(
name|Releasable
name|ignored
init|=
name|connectionLock
operator|.
name|acquire
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|)
init|)
block|{
name|NodeChannels
name|nodeChannels
init|=
name|connectedNodes
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeChannels
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
name|nodeChannels
operator|=
name|openConnection
argument_list|(
name|node
argument_list|,
name|connectionProfile
argument_list|)
expr_stmt|;
name|connectionValidator
operator|.
name|accept
argument_list|(
name|nodeChannels
argument_list|,
name|connectionProfile
argument_list|)
expr_stmt|;
comment|// we acquire a connection lock, so no way there is an existing connection
name|connectedNodes
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|nodeChannels
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"connected to node [{}]"
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|transportServiceAdapter
operator|.
name|onNodeConnected
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|nodeChannels
operator|.
name|isClosed
argument_list|()
condition|)
block|{
comment|// we got closed concurrently due to a disconnect or some other event on the channel.
comment|// the close callback will close the NodeChannel instance first and then try to remove
comment|// the connection from the connected nodes. It will NOT acquire the connectionLock for
comment|// the node to prevent any blocking calls on network threads. Yet, we still establish a happens
comment|// before relationship to the connectedNodes.put since we check if we can remove the
comment|// (DiscoveryNode, NodeChannels) tuple from the map after we closed. Here we check if it's closed an if so we
comment|// try to remove it first either way one of the two wins even if the callback has run before we even added the
comment|// tuple to the map since in that case we remove it here again
if|if
condition|(
name|connectedNodes
operator|.
name|remove
argument_list|(
name|node
argument_list|,
name|nodeChannels
argument_list|)
condition|)
block|{
name|transportServiceAdapter
operator|.
name|onNodeDisconnected
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
throw|throw
operator|new
name|NodeNotConnectedException
argument_list|(
name|node
argument_list|,
literal|"connection concurrently closed"
argument_list|)
throw|;
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ConnectTransportException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConnectTransportException
argument_list|(
name|node
argument_list|,
literal|"general node connection failure"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
comment|// close the connection if there is a failure
name|logger
operator|.
name|trace
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to connect to [{}], cleaning dangling connections"
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|nodeChannels
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * takes a {@link ConnectionProfile} that have been passed as a parameter to the public methods      * and resolves it to a fully specified (i.e., no nulls) profile      */
DECL|method|resolveConnectionProfile
specifier|static
name|ConnectionProfile
name|resolveConnectionProfile
parameter_list|(
annotation|@
name|Nullable
name|ConnectionProfile
name|connectionProfile
parameter_list|,
name|ConnectionProfile
name|defaultConnectionProfile
parameter_list|)
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|defaultConnectionProfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|connectionProfile
operator|==
literal|null
condition|)
block|{
return|return
name|defaultConnectionProfile
return|;
block|}
elseif|else
if|if
condition|(
name|connectionProfile
operator|.
name|getConnectTimeout
argument_list|()
operator|!=
literal|null
operator|&&
name|connectionProfile
operator|.
name|getHandshakeTimeout
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|connectionProfile
return|;
block|}
else|else
block|{
name|ConnectionProfile
operator|.
name|Builder
name|builder
init|=
operator|new
name|ConnectionProfile
operator|.
name|Builder
argument_list|(
name|connectionProfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|connectionProfile
operator|.
name|getConnectTimeout
argument_list|()
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|setConnectTimeout
argument_list|(
name|defaultConnectionProfile
operator|.
name|getConnectTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connectionProfile
operator|.
name|getHandshakeTimeout
argument_list|()
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|setHandshakeTimeout
argument_list|(
name|defaultConnectionProfile
operator|.
name|getHandshakeTimeout
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
operator|.
name|build
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|openConnection
specifier|public
specifier|final
name|NodeChannels
name|openConnection
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|ConnectionProfile
name|connectionProfile
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ConnectTransportException
argument_list|(
literal|null
argument_list|,
literal|"can't open connection to a null node"
argument_list|)
throw|;
block|}
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|NodeChannels
name|nodeChannels
init|=
literal|null
decl_stmt|;
name|connectionProfile
operator|=
name|resolveConnectionProfile
argument_list|(
name|connectionProfile
argument_list|,
name|defaultConnectionProfile
argument_list|)
expr_stmt|;
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// ensure we don't open connections while we are closing
try|try
block|{
name|ensureOpen
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|AtomicBoolean
name|runOnce
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|NodeChannels
argument_list|>
name|connectionRef
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
name|Consumer
argument_list|<
name|Channel
argument_list|>
name|onClose
init|=
name|c
lambda|->
block|{
assert|assert
name|isOpen
argument_list|(
name|c
argument_list|)
operator|==
literal|false
operator|:
literal|"channel is still open when onClose is called"
assert|;
try|try
block|{
name|onChannelClosed
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// we only need to disconnect from the nodes once since all other channels
comment|// will also try to run this we protect it from running multiple times.
if|if
condition|(
name|runOnce
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|NodeChannels
name|connection
init|=
name|connectionRef
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|connection
operator|!=
literal|null
condition|)
block|{
name|disconnectFromNodeCloseAndNotify
argument_list|(
name|node
argument_list|,
name|connection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
decl_stmt|;
name|nodeChannels
operator|=
name|connectToChannels
argument_list|(
name|node
argument_list|,
name|connectionProfile
argument_list|,
name|onClose
argument_list|)
expr_stmt|;
specifier|final
name|Channel
name|channel
init|=
name|nodeChannels
operator|.
name|getChannels
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|// one channel is guaranteed by the connection profile
specifier|final
name|TimeValue
name|connectTimeout
init|=
name|connectionProfile
operator|.
name|getConnectTimeout
argument_list|()
operator|==
literal|null
condition|?
name|defaultConnectionProfile
operator|.
name|getConnectTimeout
argument_list|()
else|:
name|connectionProfile
operator|.
name|getConnectTimeout
argument_list|()
decl_stmt|;
specifier|final
name|TimeValue
name|handshakeTimeout
init|=
name|connectionProfile
operator|.
name|getHandshakeTimeout
argument_list|()
operator|==
literal|null
condition|?
name|connectTimeout
else|:
name|connectionProfile
operator|.
name|getHandshakeTimeout
argument_list|()
decl_stmt|;
specifier|final
name|Version
name|version
init|=
name|executeHandshake
argument_list|(
name|node
argument_list|,
name|channel
argument_list|,
name|handshakeTimeout
argument_list|)
decl_stmt|;
name|nodeChannels
operator|=
operator|new
name|NodeChannels
argument_list|(
name|nodeChannels
argument_list|,
name|version
argument_list|)
expr_stmt|;
comment|// clone the channels - we now have the correct version
name|transportServiceAdapter
operator|.
name|onConnectionOpened
argument_list|(
name|nodeChannels
argument_list|)
expr_stmt|;
name|connectionRef
operator|.
name|set
argument_list|(
name|nodeChannels
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|nodeChannels
return|;
block|}
catch|catch
parameter_list|(
name|ConnectTransportException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// ConnectTransportExceptions are handled specifically on the caller end - we wrap the actual exception to ensure
comment|// only relevant exceptions are logged on the caller end.. this is the same as in connectToNode
throw|throw
operator|new
name|ConnectTransportException
argument_list|(
name|node
argument_list|,
literal|"general node connection failure"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|nodeChannels
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|disconnectFromNodeCloseAndNotify
specifier|private
name|void
name|disconnectFromNodeCloseAndNotify
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|NodeChannels
name|nodeChannels
parameter_list|)
block|{
assert|assert
name|nodeChannels
operator|!=
literal|null
operator|:
literal|"nodeChannels must not be null"
assert|;
try|try
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|nodeChannels
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|connectedNodes
operator|.
name|remove
argument_list|(
name|node
argument_list|,
name|nodeChannels
argument_list|)
condition|)
block|{
name|transportServiceAdapter
operator|.
name|onNodeDisconnected
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Disconnects from a node if a channel is found as part of that nodes channels.      */
DECL|method|closeChannelWhileHandlingExceptions
specifier|protected
specifier|final
name|void
name|closeChannelWhileHandlingExceptions
parameter_list|(
specifier|final
name|Channel
name|channel
parameter_list|)
block|{
if|if
condition|(
name|isOpen
argument_list|(
name|channel
argument_list|)
condition|)
block|{
try|try
block|{
name|closeChannels
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to close channel"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|getConnection
specifier|public
name|NodeChannels
name|getConnection
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|)
block|{
name|NodeChannels
name|nodeChannels
init|=
name|connectedNodes
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeChannels
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NodeNotConnectedException
argument_list|(
name|node
argument_list|,
literal|"Node not connected"
argument_list|)
throw|;
block|}
return|return
name|nodeChannels
return|;
block|}
annotation|@
name|Override
DECL|method|disconnectFromNode
specifier|public
name|void
name|disconnectFromNode
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|)
block|{
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
name|NodeChannels
name|nodeChannels
init|=
literal|null
decl_stmt|;
try|try
init|(
name|Releasable
name|ignored
init|=
name|connectionLock
operator|.
name|acquire
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|)
init|)
block|{
name|nodeChannels
operator|=
name|connectedNodes
operator|.
name|remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|closeLock
operator|.
name|readLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodeChannels
operator|!=
literal|null
condition|)
block|{
comment|// if we found it and removed it we close and notify
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|nodeChannels
argument_list|,
parameter_list|()
lambda|->
name|transportServiceAdapter
operator|.
name|onNodeDisconnected
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getCurrentVersion
specifier|protected
name|Version
name|getCurrentVersion
parameter_list|()
block|{
comment|// this is just for tests to mock stuff like the nodes version - tests can override this internally
return|return
name|Version
operator|.
name|CURRENT
return|;
block|}
annotation|@
name|Override
DECL|method|boundAddress
specifier|public
name|BoundTransportAddress
name|boundAddress
parameter_list|()
block|{
return|return
name|this
operator|.
name|boundAddress
return|;
block|}
annotation|@
name|Override
DECL|method|profileBoundAddresses
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|BoundTransportAddress
argument_list|>
name|profileBoundAddresses
parameter_list|()
block|{
return|return
name|unmodifiableMap
argument_list|(
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|profileBoundAddresses
argument_list|)
argument_list|)
return|;
block|}
DECL|method|buildProfileSettings
specifier|protected
name|Map
argument_list|<
name|String
argument_list|,
name|Settings
argument_list|>
name|buildProfileSettings
parameter_list|()
block|{
comment|// extract default profile first and create standard bootstrap
name|Map
argument_list|<
name|String
argument_list|,
name|Settings
argument_list|>
name|profiles
init|=
name|TransportSettings
operator|.
name|TRANSPORT_PROFILES_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
operator|.
name|getAsGroups
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|profiles
operator|.
name|containsKey
argument_list|(
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
argument_list|)
condition|)
block|{
name|profiles
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|profiles
argument_list|)
expr_stmt|;
name|profiles
operator|.
name|put
argument_list|(
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
argument_list|,
name|Settings
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
block|}
name|Settings
name|defaultSettings
init|=
name|profiles
operator|.
name|get
argument_list|(
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Settings
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// loop through all profiles and start them up, special handling for default one
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Settings
argument_list|>
name|entry
range|:
name|profiles
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Settings
name|profileSettings
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Strings
operator|.
name|hasLength
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"transport profile configured without a name. skipping profile with settings [{}]"
argument_list|,
name|profileSettings
operator|.
name|toDelimitedString
argument_list|(
literal|','
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|profileSettings
operator|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|profileSettings
argument_list|)
operator|.
name|put
argument_list|(
literal|"port"
argument_list|,
name|profileSettings
operator|.
name|get
argument_list|(
literal|"port"
argument_list|,
name|TransportSettings
operator|.
name|PORT
operator|.
name|get
argument_list|(
name|this
operator|.
name|settings
argument_list|)
argument_list|)
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|profileSettings
operator|.
name|get
argument_list|(
literal|"port"
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// if profile does not have a port, skip it
name|logger
operator|.
name|info
argument_list|(
literal|"No port configured for profile [{}], not binding"
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Settings
name|mergedSettings
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|defaultSettings
argument_list|)
operator|.
name|put
argument_list|(
name|profileSettings
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|result
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|mergedSettings
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|getLocalAddresses
specifier|public
name|List
argument_list|<
name|String
argument_list|>
name|getLocalAddresses
parameter_list|()
block|{
name|List
argument_list|<
name|String
argument_list|>
name|local
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|local
operator|.
name|add
argument_list|(
literal|"127.0.0.1"
argument_list|)
expr_stmt|;
comment|// check if v6 is supported, if so, v4 will also work via mapped addresses.
if|if
condition|(
name|NetworkUtils
operator|.
name|SUPPORTS_V6
condition|)
block|{
name|local
operator|.
name|add
argument_list|(
literal|"[::1]"
argument_list|)
expr_stmt|;
comment|// may get ports appended!
block|}
return|return
name|local
return|;
block|}
DECL|method|bindServer
specifier|protected
name|void
name|bindServer
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Settings
name|settings
parameter_list|)
block|{
comment|// Bind and start to accept incoming connections.
name|InetAddress
name|hostAddresses
index|[]
decl_stmt|;
name|String
name|bindHosts
index|[]
init|=
name|settings
operator|.
name|getAsArray
argument_list|(
literal|"bind_host"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
name|hostAddresses
operator|=
name|networkService
operator|.
name|resolveBindHostAddresses
argument_list|(
name|bindHosts
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BindTransportException
argument_list|(
literal|"Failed to resolve host "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|bindHosts
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|String
index|[]
name|addresses
init|=
operator|new
name|String
index|[
name|hostAddresses
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hostAddresses
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|addresses
index|[
name|i
index|]
operator|=
name|NetworkAddress
operator|.
name|format
argument_list|(
name|hostAddresses
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"binding server bootstrap to: {}"
argument_list|,
operator|(
name|Object
operator|)
name|addresses
argument_list|)
expr_stmt|;
block|}
assert|assert
name|hostAddresses
operator|.
name|length
operator|>
literal|0
assert|;
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|boundAddresses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|InetAddress
name|hostAddress
range|:
name|hostAddresses
control|)
block|{
name|boundAddresses
operator|.
name|add
argument_list|(
name|bindToPort
argument_list|(
name|name
argument_list|,
name|hostAddress
argument_list|,
name|settings
operator|.
name|get
argument_list|(
literal|"port"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|BoundTransportAddress
name|boundTransportAddress
init|=
name|createBoundTransportAddress
argument_list|(
name|name
argument_list|,
name|settings
argument_list|,
name|boundAddresses
argument_list|)
decl_stmt|;
if|if
condition|(
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|this
operator|.
name|boundAddress
operator|=
name|boundTransportAddress
expr_stmt|;
block|}
else|else
block|{
name|profileBoundAddresses
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|boundTransportAddress
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|bindToPort
specifier|protected
name|InetSocketAddress
name|bindToPort
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|InetAddress
name|hostAddress
parameter_list|,
name|String
name|port
parameter_list|)
block|{
name|PortsRange
name|portsRange
init|=
operator|new
name|PortsRange
argument_list|(
name|port
argument_list|)
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|Exception
argument_list|>
name|lastException
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|InetSocketAddress
argument_list|>
name|boundSocket
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
name|portsRange
operator|.
name|iterate
argument_list|(
name|portNumber
lambda|->
block|{
try|try
block|{
name|Channel
name|channel
init|=
name|bind
argument_list|(
name|name
argument_list|,
operator|new
name|InetSocketAddress
argument_list|(
name|hostAddress
argument_list|,
name|portNumber
argument_list|)
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|serverChannels
init|)
block|{
name|List
argument_list|<
name|Channel
argument_list|>
name|list
init|=
name|serverChannels
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
literal|null
condition|)
block|{
name|list
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|serverChannels
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|list
operator|.
name|add
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|boundSocket
operator|.
name|set
argument_list|(
name|getLocalAddress
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|lastException
operator|.
name|set
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
throw|throw
operator|new
name|BindTransportException
argument_list|(
literal|"Failed to bind to ["
operator|+
name|port
operator|+
literal|"]"
argument_list|,
name|lastException
operator|.
name|get
argument_list|()
argument_list|)
throw|;
block|}
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Bound profile [{}] to address {{}}"
argument_list|,
name|name
argument_list|,
name|NetworkAddress
operator|.
name|format
argument_list|(
name|boundSocket
operator|.
name|get
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|boundSocket
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|createBoundTransportAddress
specifier|private
name|BoundTransportAddress
name|createBoundTransportAddress
parameter_list|(
name|String
name|name
parameter_list|,
name|Settings
name|profileSettings
parameter_list|,
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|boundAddresses
parameter_list|)
block|{
name|String
index|[]
name|boundAddressesHostStrings
init|=
operator|new
name|String
index|[
name|boundAddresses
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|TransportAddress
index|[]
name|transportBoundAddresses
init|=
operator|new
name|TransportAddress
index|[
name|boundAddresses
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|boundAddresses
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|InetSocketAddress
name|boundAddress
init|=
name|boundAddresses
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|boundAddressesHostStrings
index|[
name|i
index|]
operator|=
name|boundAddress
operator|.
name|getHostString
argument_list|()
expr_stmt|;
name|transportBoundAddresses
index|[
name|i
index|]
operator|=
operator|new
name|TransportAddress
argument_list|(
name|boundAddress
argument_list|)
expr_stmt|;
block|}
specifier|final
name|String
index|[]
name|publishHosts
decl_stmt|;
if|if
condition|(
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|publishHosts
operator|=
name|TransportSettings
operator|.
name|PUBLISH_HOST
operator|.
name|get
argument_list|(
name|settings
argument_list|)
operator|.
name|toArray
argument_list|(
name|Strings
operator|.
name|EMPTY_ARRAY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|publishHosts
operator|=
name|profileSettings
operator|.
name|getAsArray
argument_list|(
literal|"publish_host"
argument_list|,
name|boundAddressesHostStrings
argument_list|)
expr_stmt|;
block|}
specifier|final
name|InetAddress
name|publishInetAddress
decl_stmt|;
try|try
block|{
name|publishInetAddress
operator|=
name|networkService
operator|.
name|resolvePublishHostAddresses
argument_list|(
name|publishHosts
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|BindTransportException
argument_list|(
literal|"Failed to resolve publish address"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|int
name|publishPort
init|=
name|resolvePublishPort
argument_list|(
name|name
argument_list|,
name|settings
argument_list|,
name|profileSettings
argument_list|,
name|boundAddresses
argument_list|,
name|publishInetAddress
argument_list|)
decl_stmt|;
specifier|final
name|TransportAddress
name|publishAddress
init|=
operator|new
name|TransportAddress
argument_list|(
operator|new
name|InetSocketAddress
argument_list|(
name|publishInetAddress
argument_list|,
name|publishPort
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|BoundTransportAddress
argument_list|(
name|transportBoundAddresses
argument_list|,
name|publishAddress
argument_list|)
return|;
block|}
comment|// package private for tests
DECL|method|resolvePublishPort
specifier|public
specifier|static
name|int
name|resolvePublishPort
parameter_list|(
name|String
name|profileName
parameter_list|,
name|Settings
name|settings
parameter_list|,
name|Settings
name|profileSettings
parameter_list|,
name|List
argument_list|<
name|InetSocketAddress
argument_list|>
name|boundAddresses
parameter_list|,
name|InetAddress
name|publishInetAddress
parameter_list|)
block|{
name|int
name|publishPort
decl_stmt|;
if|if
condition|(
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
operator|.
name|equals
argument_list|(
name|profileName
argument_list|)
condition|)
block|{
name|publishPort
operator|=
name|TransportSettings
operator|.
name|PUBLISH_PORT
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|publishPort
operator|=
name|profileSettings
operator|.
name|getAsInt
argument_list|(
literal|"publish_port"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// if port not explicitly provided, search for port of address in boundAddresses that matches publishInetAddress
if|if
condition|(
name|publishPort
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|InetSocketAddress
name|boundAddress
range|:
name|boundAddresses
control|)
block|{
name|InetAddress
name|boundInetAddress
init|=
name|boundAddress
operator|.
name|getAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|boundInetAddress
operator|.
name|isAnyLocalAddress
argument_list|()
operator|||
name|boundInetAddress
operator|.
name|equals
argument_list|(
name|publishInetAddress
argument_list|)
condition|)
block|{
name|publishPort
operator|=
name|boundAddress
operator|.
name|getPort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// if no matching boundAddress found, check if there is a unique port for all bound addresses
if|if
condition|(
name|publishPort
operator|<
literal|0
condition|)
block|{
specifier|final
name|IntSet
name|ports
init|=
operator|new
name|IntHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|InetSocketAddress
name|boundAddress
range|:
name|boundAddresses
control|)
block|{
name|ports
operator|.
name|add
argument_list|(
name|boundAddress
operator|.
name|getPort
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ports
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|publishPort
operator|=
name|ports
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
operator|.
name|value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|publishPort
operator|<
literal|0
condition|)
block|{
name|String
name|profileExplanation
init|=
name|TransportSettings
operator|.
name|DEFAULT_PROFILE
operator|.
name|equals
argument_list|(
name|profileName
argument_list|)
condition|?
literal|""
else|:
literal|" for profile "
operator|+
name|profileName
decl_stmt|;
throw|throw
operator|new
name|BindTransportException
argument_list|(
literal|"Failed to auto-resolve publish port"
operator|+
name|profileExplanation
operator|+
literal|", multiple bound addresses "
operator|+
name|boundAddresses
operator|+
literal|" with distinct ports and none of them matched the publish address ("
operator|+
name|publishInetAddress
operator|+
literal|"). "
operator|+
literal|"Please specify a unique port by setting "
operator|+
name|TransportSettings
operator|.
name|PORT
operator|.
name|getKey
argument_list|()
operator|+
literal|" or "
operator|+
name|TransportSettings
operator|.
name|PUBLISH_PORT
operator|.
name|getKey
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|publishPort
return|;
block|}
annotation|@
name|Override
DECL|method|addressesFromString
specifier|public
name|TransportAddress
index|[]
name|addressesFromString
parameter_list|(
name|String
name|address
parameter_list|,
name|int
name|perAddressLimit
parameter_list|)
throws|throws
name|UnknownHostException
block|{
return|return
name|parse
argument_list|(
name|address
argument_list|,
name|settings
operator|.
name|get
argument_list|(
literal|"transport.profiles.default.port"
argument_list|,
name|TransportSettings
operator|.
name|PORT
operator|.
name|get
argument_list|(
name|settings
argument_list|)
argument_list|)
argument_list|,
name|perAddressLimit
argument_list|)
return|;
block|}
comment|// this code is a take on guava's HostAndPort, like a HostAndPortRange
comment|// pattern for validating ipv6 bracket addresses.
comment|// not perfect, but PortsRange should take care of any port range validation, not a regex
DECL|field|BRACKET_PATTERN
specifier|private
specifier|static
specifier|final
name|Pattern
name|BRACKET_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^\\[(.*:.*)\\](?::([\\d\\-]*))?$"
argument_list|)
decl_stmt|;
comment|/** parse a hostname+port range spec into its equivalent addresses */
DECL|method|parse
specifier|static
name|TransportAddress
index|[]
name|parse
parameter_list|(
name|String
name|hostPortString
parameter_list|,
name|String
name|defaultPortRange
parameter_list|,
name|int
name|perAddressLimit
parameter_list|)
throws|throws
name|UnknownHostException
block|{
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|hostPortString
argument_list|)
expr_stmt|;
name|String
name|host
decl_stmt|;
name|String
name|portString
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|hostPortString
operator|.
name|startsWith
argument_list|(
literal|"["
argument_list|)
condition|)
block|{
comment|// Parse a bracketed host, typically an IPv6 literal.
name|Matcher
name|matcher
init|=
name|BRACKET_PATTERN
operator|.
name|matcher
argument_list|(
name|hostPortString
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|matcher
operator|.
name|matches
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid bracketed host/port range: "
operator|+
name|hostPortString
argument_list|)
throw|;
block|}
name|host
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|portString
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|// could be null
block|}
else|else
block|{
name|int
name|colonPos
init|=
name|hostPortString
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|colonPos
operator|>=
literal|0
operator|&&
name|hostPortString
operator|.
name|indexOf
argument_list|(
literal|':'
argument_list|,
name|colonPos
operator|+
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Exactly 1 colon.  Split into host:port.
name|host
operator|=
name|hostPortString
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|colonPos
argument_list|)
expr_stmt|;
name|portString
operator|=
name|hostPortString
operator|.
name|substring
argument_list|(
name|colonPos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// 0 or 2+ colons.  Bare hostname or IPv6 literal.
name|host
operator|=
name|hostPortString
expr_stmt|;
comment|// 2+ colons and not bracketed: exception
if|if
condition|(
name|colonPos
operator|>=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"IPv6 addresses must be bracketed: "
operator|+
name|hostPortString
argument_list|)
throw|;
block|}
block|}
block|}
comment|// if port isn't specified, fill with the default
if|if
condition|(
name|portString
operator|==
literal|null
operator|||
name|portString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|portString
operator|=
name|defaultPortRange
expr_stmt|;
block|}
comment|// generate address for each port in the range
name|Set
argument_list|<
name|InetAddress
argument_list|>
name|addresses
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|InetAddress
operator|.
name|getAllByName
argument_list|(
name|host
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TransportAddress
argument_list|>
name|transportAddresses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|int
index|[]
name|ports
init|=
operator|new
name|PortsRange
argument_list|(
name|portString
argument_list|)
operator|.
name|ports
argument_list|()
decl_stmt|;
name|int
name|limit
init|=
name|Math
operator|.
name|min
argument_list|(
name|ports
operator|.
name|length
argument_list|,
name|perAddressLimit
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|InetAddress
name|address
range|:
name|addresses
control|)
block|{
name|transportAddresses
operator|.
name|add
argument_list|(
operator|new
name|TransportAddress
argument_list|(
name|address
argument_list|,
name|ports
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|transportAddresses
operator|.
name|toArray
argument_list|(
operator|new
name|TransportAddress
index|[
name|transportAddresses
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
specifier|final
name|void
name|doClose
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|doStop
specifier|protected
specifier|final
name|void
name|doStop
parameter_list|()
block|{
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|// make sure we run it on another thread than a possible IO handler thread
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
name|closeLock
operator|.
name|writeLock
argument_list|()
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// first stop to accept any incoming connections so nobody can connect to this transport
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Channel
argument_list|>
argument_list|>
name|entry
range|:
name|serverChannels
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|closeChannels
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"Error closing serverChannel for profile [{}]"
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we are holding a write lock so nobody modifies the connectedNodes / openConnections map - it's safe to first close
comment|// all instances and then clear them maps
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|DiscoveryNode
argument_list|,
name|NodeChannels
argument_list|>
argument_list|>
name|iterator
init|=
name|connectedNodes
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|DiscoveryNode
argument_list|,
name|NodeChannels
argument_list|>
name|next
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
try|try
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|next
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|transportServiceAdapter
operator|.
name|onNodeDisconnected
argument_list|(
name|next
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|stopInternal
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|closeLock
operator|.
name|writeLock
argument_list|()
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
try|try
block|{
name|latch
operator|.
name|await
argument_list|(
literal|30
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
comment|// ignore
block|}
block|}
DECL|method|onException
specifier|protected
name|void
name|onException
parameter_list|(
name|Channel
name|channel
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lifecycle
operator|.
name|started
argument_list|()
condition|)
block|{
comment|// just close and ignore - we are already stopped and just need to make sure we release all resources
name|closeChannelWhileHandlingExceptions
argument_list|(
name|channel
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isCloseConnectionException
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"close connection exception caught on transport layer [{}], disconnecting from relevant node"
argument_list|,
name|channel
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// close the channel, which will cause a node to be disconnected if relevant
name|closeChannelWhileHandlingExceptions
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isConnectException
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"connect exception caught on transport layer [{}]"
argument_list|,
name|channel
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// close the channel as safe measure, which will cause a node to be disconnected if relevant
name|closeChannelWhileHandlingExceptions
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|BindException
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"bind exception caught on transport layer [{}]"
argument_list|,
name|channel
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// close the channel as safe measure, which will cause a node to be disconnected if relevant
name|closeChannelWhileHandlingExceptions
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|CancelledKeyException
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"cancelled key exception caught on transport layer [{}], disconnecting from relevant node"
argument_list|,
name|channel
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// close the channel as safe measure, which will cause a node to be disconnected if relevant
name|closeChannelWhileHandlingExceptions
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|TcpTransport
operator|.
name|HttpOnTransportException
condition|)
block|{
comment|// in case we are able to return data, serialize the exception content and sent it back to the client
if|if
condition|(
name|isOpen
argument_list|(
name|channel
argument_list|)
condition|)
block|{
name|BytesArray
name|message
init|=
operator|new
name|BytesArray
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
operator|.
name|getBytes
argument_list|(
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|SendMetricListener
argument_list|<
name|Channel
argument_list|>
name|closeChannel
init|=
operator|new
name|SendMetricListener
argument_list|<
name|Channel
argument_list|>
argument_list|(
name|message
operator|.
name|length
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|innerInnerOnResponse
parameter_list|(
name|Channel
name|channel
parameter_list|)
block|{
try|try
block|{
name|closeChannels
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e1
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to close httpOnTransport channel"
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|innerOnFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
try|try
block|{
name|closeChannels
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e1
parameter_list|)
block|{
name|e
operator|.
name|addSuppressed
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to close httpOnTransport channel"
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|internalSendMessage
argument_list|(
name|channel
argument_list|,
name|message
argument_list|,
name|closeChannel
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"exception caught on transport layer [{}], closing connection"
argument_list|,
name|channel
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// close the channel, which will cause a node to be disconnected if relevant
name|closeChannelWhileHandlingExceptions
argument_list|(
name|channel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the channels local address      */
DECL|method|getLocalAddress
specifier|protected
specifier|abstract
name|InetSocketAddress
name|getLocalAddress
parameter_list|(
name|Channel
name|channel
parameter_list|)
function_decl|;
comment|/**      * Binds to the given {@link InetSocketAddress}      *      * @param name    the profile name      * @param address the address to bind to      */
DECL|method|bind
specifier|protected
specifier|abstract
name|Channel
name|bind
parameter_list|(
name|String
name|name
parameter_list|,
name|InetSocketAddress
name|address
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Closes all channels in this list      */
DECL|method|closeChannels
specifier|protected
specifier|abstract
name|void
name|closeChannels
parameter_list|(
name|List
argument_list|<
name|Channel
argument_list|>
name|channel
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Sends message to channel. The listener's onResponse method will be called when the send is complete unless an exception      * is thrown during the send. If an exception is thrown, the listener's onException method will be called.      * @param channel the destination channel      * @param reference the byte reference for the message      * @param listener the listener to call when the operation has completed      */
DECL|method|sendMessage
specifier|protected
specifier|abstract
name|void
name|sendMessage
parameter_list|(
name|Channel
name|channel
parameter_list|,
name|BytesReference
name|reference
parameter_list|,
name|ActionListener
argument_list|<
name|Channel
argument_list|>
name|listener
parameter_list|)
function_decl|;
DECL|method|connectToChannels
specifier|protected
specifier|abstract
name|NodeChannels
name|connectToChannels
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|ConnectionProfile
name|connectionProfile
parameter_list|,
name|Consumer
argument_list|<
name|Channel
argument_list|>
name|onChannelClose
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Called to tear down internal resources      */
DECL|method|stopInternal
specifier|protected
name|void
name|stopInternal
parameter_list|()
block|{}
DECL|method|canCompress
specifier|public
name|boolean
name|canCompress
parameter_list|(
name|TransportRequest
name|request
parameter_list|)
block|{
return|return
name|compress
operator|&&
operator|(
operator|!
operator|(
name|request
operator|instanceof
name|BytesTransportRequest
operator|)
operator|)
return|;
block|}
DECL|method|sendRequestToChannel
specifier|private
name|void
name|sendRequestToChannel
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|,
specifier|final
name|Channel
name|targetChannel
parameter_list|,
specifier|final
name|long
name|requestId
parameter_list|,
specifier|final
name|String
name|action
parameter_list|,
specifier|final
name|TransportRequest
name|request
parameter_list|,
name|TransportRequestOptions
name|options
parameter_list|,
name|Version
name|channelVersion
parameter_list|,
name|byte
name|status
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransportException
block|{
if|if
condition|(
name|compress
condition|)
block|{
name|options
operator|=
name|TransportRequestOptions
operator|.
name|builder
argument_list|(
name|options
argument_list|)
operator|.
name|withCompress
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// only compress if asked and the request is not bytes. Otherwise only
comment|// the header part is compressed, and the "body" can't be extracted as compressed
specifier|final
name|boolean
name|compressMessage
init|=
name|options
operator|.
name|compress
argument_list|()
operator|&&
name|canCompress
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|status
operator|=
name|TransportStatus
operator|.
name|setRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|ReleasableBytesStreamOutput
name|bStream
init|=
operator|new
name|ReleasableBytesStreamOutput
argument_list|(
name|bigArrays
argument_list|)
decl_stmt|;
specifier|final
name|CompressibleBytesOutputStream
name|stream
init|=
operator|new
name|CompressibleBytesOutputStream
argument_list|(
name|bStream
argument_list|,
name|compressMessage
argument_list|)
decl_stmt|;
name|boolean
name|addedReleaseListener
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|compressMessage
condition|)
block|{
name|status
operator|=
name|TransportStatus
operator|.
name|setCompress
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|// we pick the smallest of the 2, to support both backward and forward compatibility
comment|// note, this is the only place we need to do this, since from here on, we use the serialized version
comment|// as the version to use also when the node receiving this request will send the response with
name|Version
name|version
init|=
name|Version
operator|.
name|min
argument_list|(
name|getCurrentVersion
argument_list|()
argument_list|,
name|channelVersion
argument_list|)
decl_stmt|;
name|stream
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|threadPool
operator|.
name|getThreadContext
argument_list|()
operator|.
name|writeTo
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeString
argument_list|(
name|action
argument_list|)
expr_stmt|;
name|BytesReference
name|message
init|=
name|buildMessage
argument_list|(
name|requestId
argument_list|,
name|status
argument_list|,
name|node
operator|.
name|getVersion
argument_list|()
argument_list|,
name|request
argument_list|,
name|stream
argument_list|)
decl_stmt|;
specifier|final
name|TransportRequestOptions
name|finalOptions
init|=
name|options
decl_stmt|;
comment|// this might be called in a different thread
name|SendListener
name|onRequestSent
init|=
operator|new
name|SendListener
argument_list|(
name|stream
argument_list|,
parameter_list|()
lambda|->
name|transportServiceAdapter
operator|.
name|onRequestSent
argument_list|(
name|node
argument_list|,
name|requestId
argument_list|,
name|action
argument_list|,
name|request
argument_list|,
name|finalOptions
argument_list|)
argument_list|,
name|message
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|internalSendMessage
argument_list|(
name|targetChannel
argument_list|,
name|message
argument_list|,
name|onRequestSent
argument_list|)
expr_stmt|;
name|addedReleaseListener
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|addedReleaseListener
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * sends a message to the given channel, using the given callbacks.      */
DECL|method|internalSendMessage
specifier|private
name|void
name|internalSendMessage
parameter_list|(
name|Channel
name|targetChannel
parameter_list|,
name|BytesReference
name|message
parameter_list|,
name|SendMetricListener
argument_list|<
name|Channel
argument_list|>
name|listener
parameter_list|)
block|{
try|try
block|{
name|sendMessage
argument_list|(
name|targetChannel
argument_list|,
name|message
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// call listener to ensure that any resources are released
name|listener
operator|.
name|onFailure
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|onException
argument_list|(
name|targetChannel
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sends back an error response to the caller via the given channel      *      * @param nodeVersion the caller node version      * @param channel the channel to send the response to      * @param error the error to return      * @param requestId the request ID this response replies to      * @param action the action this response replies to      */
DECL|method|sendErrorResponse
specifier|public
name|void
name|sendErrorResponse
parameter_list|(
name|Version
name|nodeVersion
parameter_list|,
name|Channel
name|channel
parameter_list|,
specifier|final
name|Exception
name|error
parameter_list|,
specifier|final
name|long
name|requestId
parameter_list|,
specifier|final
name|String
name|action
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|BytesStreamOutput
name|stream
init|=
operator|new
name|BytesStreamOutput
argument_list|()
init|)
block|{
name|stream
operator|.
name|setVersion
argument_list|(
name|nodeVersion
argument_list|)
expr_stmt|;
name|RemoteTransportException
name|tx
init|=
operator|new
name|RemoteTransportException
argument_list|(
name|nodeName
argument_list|()
argument_list|,
operator|new
name|TransportAddress
argument_list|(
name|getLocalAddress
argument_list|(
name|channel
argument_list|)
argument_list|)
argument_list|,
name|action
argument_list|,
name|error
argument_list|)
decl_stmt|;
name|threadPool
operator|.
name|getThreadContext
argument_list|()
operator|.
name|writeTo
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|.
name|writeException
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|byte
name|status
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|TransportStatus
operator|.
name|setResponse
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|TransportStatus
operator|.
name|setError
argument_list|(
name|status
argument_list|)
expr_stmt|;
specifier|final
name|BytesReference
name|bytes
init|=
name|stream
operator|.
name|bytes
argument_list|()
decl_stmt|;
specifier|final
name|BytesReference
name|header
init|=
name|buildHeader
argument_list|(
name|requestId
argument_list|,
name|status
argument_list|,
name|nodeVersion
argument_list|,
name|bytes
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|CompositeBytesReference
name|message
init|=
operator|new
name|CompositeBytesReference
argument_list|(
name|header
argument_list|,
name|bytes
argument_list|)
decl_stmt|;
name|SendListener
name|onResponseSent
init|=
operator|new
name|SendListener
argument_list|(
literal|null
argument_list|,
parameter_list|()
lambda|->
name|transportServiceAdapter
operator|.
name|onResponseSent
argument_list|(
name|requestId
argument_list|,
name|action
argument_list|,
name|error
argument_list|)
argument_list|,
name|message
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|internalSendMessage
argument_list|(
name|channel
argument_list|,
name|message
argument_list|,
name|onResponseSent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Sends the response to the given channel. This method should be used to send {@link TransportResponse} objects back to the caller.      *      * @see #sendErrorResponse(Version, Object, Exception, long, String) for sending back errors to the caller      */
DECL|method|sendResponse
specifier|public
name|void
name|sendResponse
parameter_list|(
name|Version
name|nodeVersion
parameter_list|,
name|Channel
name|channel
parameter_list|,
specifier|final
name|TransportResponse
name|response
parameter_list|,
specifier|final
name|long
name|requestId
parameter_list|,
specifier|final
name|String
name|action
parameter_list|,
name|TransportResponseOptions
name|options
parameter_list|)
throws|throws
name|IOException
block|{
name|sendResponse
argument_list|(
name|nodeVersion
argument_list|,
name|channel
argument_list|,
name|response
argument_list|,
name|requestId
argument_list|,
name|action
argument_list|,
name|options
argument_list|,
operator|(
name|byte
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|sendResponse
specifier|private
name|void
name|sendResponse
parameter_list|(
name|Version
name|nodeVersion
parameter_list|,
name|Channel
name|channel
parameter_list|,
specifier|final
name|TransportResponse
name|response
parameter_list|,
specifier|final
name|long
name|requestId
parameter_list|,
specifier|final
name|String
name|action
parameter_list|,
name|TransportResponseOptions
name|options
parameter_list|,
name|byte
name|status
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|compress
condition|)
block|{
name|options
operator|=
name|TransportResponseOptions
operator|.
name|builder
argument_list|(
name|options
argument_list|)
operator|.
name|withCompress
argument_list|(
literal|true
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
name|status
operator|=
name|TransportStatus
operator|.
name|setResponse
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|// TODO share some code with sendRequest
name|ReleasableBytesStreamOutput
name|bStream
init|=
operator|new
name|ReleasableBytesStreamOutput
argument_list|(
name|bigArrays
argument_list|)
decl_stmt|;
name|CompressibleBytesOutputStream
name|stream
init|=
operator|new
name|CompressibleBytesOutputStream
argument_list|(
name|bStream
argument_list|,
name|options
operator|.
name|compress
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|addedReleaseListener
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|options
operator|.
name|compress
argument_list|()
condition|)
block|{
name|status
operator|=
name|TransportStatus
operator|.
name|setCompress
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|threadPool
operator|.
name|getThreadContext
argument_list|()
operator|.
name|writeTo
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|stream
operator|.
name|setVersion
argument_list|(
name|nodeVersion
argument_list|)
expr_stmt|;
name|BytesReference
name|message
init|=
name|buildMessage
argument_list|(
name|requestId
argument_list|,
name|status
argument_list|,
name|nodeVersion
argument_list|,
name|response
argument_list|,
name|stream
argument_list|)
decl_stmt|;
specifier|final
name|TransportResponseOptions
name|finalOptions
init|=
name|options
decl_stmt|;
comment|// this might be called in a different thread
name|SendListener
name|listener
init|=
operator|new
name|SendListener
argument_list|(
name|stream
argument_list|,
parameter_list|()
lambda|->
name|transportServiceAdapter
operator|.
name|onResponseSent
argument_list|(
name|requestId
argument_list|,
name|action
argument_list|,
name|response
argument_list|,
name|finalOptions
argument_list|)
argument_list|,
name|message
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|internalSendMessage
argument_list|(
name|channel
argument_list|,
name|message
argument_list|,
name|listener
argument_list|)
expr_stmt|;
name|addedReleaseListener
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|addedReleaseListener
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Writes the Tcp message header into a bytes reference.      *      * @param requestId       the request ID      * @param status          the request status      * @param protocolVersion the protocol version used to serialize the data in the message      * @param length          the payload length in bytes      * @see TcpHeader      */
DECL|method|buildHeader
specifier|final
name|BytesReference
name|buildHeader
parameter_list|(
name|long
name|requestId
parameter_list|,
name|byte
name|status
parameter_list|,
name|Version
name|protocolVersion
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
try|try
init|(
name|BytesStreamOutput
name|headerOutput
init|=
operator|new
name|BytesStreamOutput
argument_list|(
name|TcpHeader
operator|.
name|HEADER_SIZE
argument_list|)
init|)
block|{
name|headerOutput
operator|.
name|setVersion
argument_list|(
name|protocolVersion
argument_list|)
expr_stmt|;
name|TcpHeader
operator|.
name|writeHeader
argument_list|(
name|headerOutput
argument_list|,
name|requestId
argument_list|,
name|status
argument_list|,
name|protocolVersion
argument_list|,
name|length
argument_list|)
expr_stmt|;
specifier|final
name|BytesReference
name|bytes
init|=
name|headerOutput
operator|.
name|bytes
argument_list|()
decl_stmt|;
assert|assert
name|bytes
operator|.
name|length
argument_list|()
operator|==
name|TcpHeader
operator|.
name|HEADER_SIZE
operator|:
literal|"header size mismatch expected: "
operator|+
name|TcpHeader
operator|.
name|HEADER_SIZE
operator|+
literal|" but was: "
operator|+
name|bytes
operator|.
name|length
argument_list|()
assert|;
return|return
name|bytes
return|;
block|}
block|}
comment|/**      * Serializes the given message into a bytes representation      */
DECL|method|buildMessage
specifier|private
name|BytesReference
name|buildMessage
parameter_list|(
name|long
name|requestId
parameter_list|,
name|byte
name|status
parameter_list|,
name|Version
name|nodeVersion
parameter_list|,
name|TransportMessage
name|message
parameter_list|,
name|CompressibleBytesOutputStream
name|stream
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|BytesReference
name|zeroCopyBuffer
decl_stmt|;
if|if
condition|(
name|message
operator|instanceof
name|BytesTransportRequest
condition|)
block|{
comment|// what a shitty optimization - we should use a direct send method instead
name|BytesTransportRequest
name|bRequest
init|=
operator|(
name|BytesTransportRequest
operator|)
name|message
decl_stmt|;
assert|assert
name|nodeVersion
operator|.
name|equals
argument_list|(
name|bRequest
operator|.
name|version
argument_list|()
argument_list|)
assert|;
name|bRequest
operator|.
name|writeThin
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|zeroCopyBuffer
operator|=
name|bRequest
operator|.
name|bytes
expr_stmt|;
block|}
else|else
block|{
name|message
operator|.
name|writeTo
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|zeroCopyBuffer
operator|=
name|BytesArray
operator|.
name|EMPTY
expr_stmt|;
block|}
comment|// we have to call materializeBytes() here before accessing the bytes. A CompressibleBytesOutputStream
comment|// might be implementing compression. And materializeBytes() ensures that some marker bytes (EOS marker)
comment|// are written. Otherwise we barf on the decompressing end when we read past EOF on purpose in the
comment|// #validateRequest method. this might be a problem in deflate after all but it's important to write
comment|// the marker bytes.
specifier|final
name|BytesReference
name|messageBody
init|=
name|stream
operator|.
name|materializeBytes
argument_list|()
decl_stmt|;
specifier|final
name|BytesReference
name|header
init|=
name|buildHeader
argument_list|(
name|requestId
argument_list|,
name|status
argument_list|,
name|stream
operator|.
name|getVersion
argument_list|()
argument_list|,
name|messageBody
operator|.
name|length
argument_list|()
operator|+
name|zeroCopyBuffer
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|CompositeBytesReference
argument_list|(
name|header
argument_list|,
name|messageBody
argument_list|,
name|zeroCopyBuffer
argument_list|)
return|;
block|}
comment|/**      * Validates the first N bytes of the message header and returns<code>false</code> if the message is      * a ping message and has no payload ie. isn't a real user level message.      *      * @throws IllegalStateException if the message is too short, less than the header or less that the header plus the message size      * @throws HttpOnTransportException if the message has no valid header and appears to be a HTTP message      * @throws IllegalArgumentException if the message is greater that the maximum allowed frame size. This is dependent on the available      * memory.      */
DECL|method|validateMessageHeader
specifier|public
specifier|static
name|boolean
name|validateMessageHeader
parameter_list|(
name|BytesReference
name|buffer
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|sizeHeaderLength
init|=
name|TcpHeader
operator|.
name|MARKER_BYTES_SIZE
operator|+
name|TcpHeader
operator|.
name|MESSAGE_LENGTH_SIZE
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|<
name|sizeHeaderLength
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"message size must be>= to the header size"
argument_list|)
throw|;
block|}
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buffer
operator|.
name|get
argument_list|(
name|offset
argument_list|)
operator|!=
literal|'E'
operator|||
name|buffer
operator|.
name|get
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
operator|!=
literal|'S'
condition|)
block|{
comment|// special handling for what is probably HTTP
if|if
condition|(
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"GET "
argument_list|)
operator|||
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"POST "
argument_list|)
operator|||
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"PUT "
argument_list|)
operator|||
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"HEAD "
argument_list|)
operator|||
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"DELETE "
argument_list|)
operator|||
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"OPTIONS "
argument_list|)
operator|||
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"PATCH "
argument_list|)
operator|||
name|bufferStartsWith
argument_list|(
name|buffer
argument_list|,
name|offset
argument_list|,
literal|"TRACE "
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|HttpOnTransportException
argument_list|(
literal|"This is not a HTTP port"
argument_list|)
throw|;
block|}
comment|// we have 6 readable bytes, show 4 (should be enough)
throw|throw
operator|new
name|StreamCorruptedException
argument_list|(
literal|"invalid internal transport message format, got ("
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|buffer
operator|.
name|get
argument_list|(
name|offset
argument_list|)
operator|&
literal|0xFF
argument_list|)
operator|+
literal|","
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|buffer
operator|.
name|get
argument_list|(
name|offset
operator|+
literal|1
argument_list|)
operator|&
literal|0xFF
argument_list|)
operator|+
literal|","
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|buffer
operator|.
name|get
argument_list|(
name|offset
operator|+
literal|2
argument_list|)
operator|&
literal|0xFF
argument_list|)
operator|+
literal|","
operator|+
name|Integer
operator|.
name|toHexString
argument_list|(
name|buffer
operator|.
name|get
argument_list|(
name|offset
operator|+
literal|3
argument_list|)
operator|&
literal|0xFF
argument_list|)
operator|+
literal|")"
argument_list|)
throw|;
block|}
specifier|final
name|int
name|dataLen
decl_stmt|;
try|try
init|(
name|StreamInput
name|input
init|=
name|buffer
operator|.
name|streamInput
argument_list|()
init|)
block|{
name|input
operator|.
name|skip
argument_list|(
name|TcpHeader
operator|.
name|MARKER_BYTES_SIZE
argument_list|)
expr_stmt|;
name|dataLen
operator|=
name|input
operator|.
name|readInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|dataLen
operator|==
name|PING_DATA_SIZE
condition|)
block|{
comment|// discard the messages we read and continue, this is achieved by skipping the bytes
comment|// and returning null
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|dataLen
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|StreamCorruptedException
argument_list|(
literal|"invalid data length: "
operator|+
name|dataLen
argument_list|)
throw|;
block|}
comment|// safety against too large frames being sent
if|if
condition|(
name|dataLen
operator|>
name|NINETY_PER_HEAP_SIZE
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"transport content length received ["
operator|+
operator|new
name|ByteSizeValue
argument_list|(
name|dataLen
argument_list|)
operator|+
literal|"] exceeded ["
operator|+
operator|new
name|ByteSizeValue
argument_list|(
name|NINETY_PER_HEAP_SIZE
argument_list|)
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|buffer
operator|.
name|length
argument_list|()
operator|<
name|dataLen
operator|+
name|sizeHeaderLength
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"buffer must be>= to the message size but wasn't"
argument_list|)
throw|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|bufferStartsWith
specifier|private
specifier|static
name|boolean
name|bufferStartsWith
parameter_list|(
name|BytesReference
name|buffer
parameter_list|,
name|int
name|offset
parameter_list|,
name|String
name|method
parameter_list|)
block|{
name|char
index|[]
name|chars
init|=
name|method
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|chars
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buffer
operator|.
name|get
argument_list|(
name|offset
operator|+
name|i
argument_list|)
operator|!=
name|chars
index|[
name|i
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * A helper exception to mark an incoming connection as potentially being HTTP      * so an appropriate error code can be returned      */
DECL|class|HttpOnTransportException
specifier|public
specifier|static
class|class
name|HttpOnTransportException
extends|extends
name|ElasticsearchException
block|{
DECL|method|HttpOnTransportException
specifier|public
name|HttpOnTransportException
parameter_list|(
name|String
name|msg
parameter_list|)
block|{
name|super
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|status
specifier|public
name|RestStatus
name|status
parameter_list|()
block|{
return|return
name|RestStatus
operator|.
name|BAD_REQUEST
return|;
block|}
DECL|method|HttpOnTransportException
specifier|public
name|HttpOnTransportException
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isOpen
specifier|protected
specifier|abstract
name|boolean
name|isOpen
parameter_list|(
name|Channel
name|channel
parameter_list|)
function_decl|;
comment|/**      * This method handles the message receive part for both request and responses      */
DECL|method|messageReceived
specifier|public
specifier|final
name|void
name|messageReceived
parameter_list|(
name|BytesReference
name|reference
parameter_list|,
name|Channel
name|channel
parameter_list|,
name|String
name|profileName
parameter_list|,
name|InetSocketAddress
name|remoteAddress
parameter_list|,
name|int
name|messageLengthBytes
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|totalMessageSize
init|=
name|messageLengthBytes
operator|+
name|TcpHeader
operator|.
name|MARKER_BYTES_SIZE
operator|+
name|TcpHeader
operator|.
name|MESSAGE_LENGTH_SIZE
decl_stmt|;
name|readBytesMetric
operator|.
name|inc
argument_list|(
name|totalMessageSize
argument_list|)
expr_stmt|;
comment|// we have additional bytes to read, outside of the header
name|boolean
name|hasMessageBytesToRead
init|=
operator|(
name|totalMessageSize
operator|-
name|TcpHeader
operator|.
name|HEADER_SIZE
operator|)
operator|>
literal|0
decl_stmt|;
name|StreamInput
name|streamIn
init|=
name|reference
operator|.
name|streamInput
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
init|(
name|ThreadContext
operator|.
name|StoredContext
name|tCtx
init|=
name|threadPool
operator|.
name|getThreadContext
argument_list|()
operator|.
name|stashContext
argument_list|()
init|)
block|{
name|long
name|requestId
init|=
name|streamIn
operator|.
name|readLong
argument_list|()
decl_stmt|;
name|byte
name|status
init|=
name|streamIn
operator|.
name|readByte
argument_list|()
decl_stmt|;
name|Version
name|version
init|=
name|Version
operator|.
name|fromId
argument_list|(
name|streamIn
operator|.
name|readInt
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|TransportStatus
operator|.
name|isCompress
argument_list|(
name|status
argument_list|)
operator|&&
name|hasMessageBytesToRead
operator|&&
name|streamIn
operator|.
name|available
argument_list|()
operator|>
literal|0
condition|)
block|{
name|Compressor
name|compressor
decl_stmt|;
try|try
block|{
specifier|final
name|int
name|bytesConsumed
init|=
name|TcpHeader
operator|.
name|REQUEST_ID_SIZE
operator|+
name|TcpHeader
operator|.
name|STATUS_SIZE
operator|+
name|TcpHeader
operator|.
name|VERSION_ID_SIZE
decl_stmt|;
name|compressor
operator|=
name|CompressorFactory
operator|.
name|compressor
argument_list|(
name|reference
operator|.
name|slice
argument_list|(
name|bytesConsumed
argument_list|,
name|reference
operator|.
name|length
argument_list|()
operator|-
name|bytesConsumed
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NotCompressedException
name|ex
parameter_list|)
block|{
name|int
name|maxToRead
init|=
name|Math
operator|.
name|min
argument_list|(
name|reference
operator|.
name|length
argument_list|()
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"stream marked as compressed, but no compressor found, first ["
argument_list|)
operator|.
name|append
argument_list|(
name|maxToRead
argument_list|)
operator|.
name|append
argument_list|(
literal|"] content bytes out of ["
argument_list|)
operator|.
name|append
argument_list|(
name|reference
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"] readable bytes with message size ["
argument_list|)
operator|.
name|append
argument_list|(
name|messageLengthBytes
argument_list|)
operator|.
name|append
argument_list|(
literal|"] "
argument_list|)
operator|.
name|append
argument_list|(
literal|"] are ["
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|maxToRead
condition|;
name|i
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|reference
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|append
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
name|streamIn
operator|=
name|compressor
operator|.
name|streamInput
argument_list|(
name|streamIn
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|isHandshake
init|=
name|TransportStatus
operator|.
name|isHandshake
argument_list|(
name|status
argument_list|)
decl_stmt|;
name|ensureVersionCompatibility
argument_list|(
name|version
argument_list|,
name|getCurrentVersion
argument_list|()
argument_list|,
name|isHandshake
argument_list|)
expr_stmt|;
name|streamIn
operator|=
operator|new
name|NamedWriteableAwareStreamInput
argument_list|(
name|streamIn
argument_list|,
name|namedWriteableRegistry
argument_list|)
expr_stmt|;
name|streamIn
operator|.
name|setVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|threadPool
operator|.
name|getThreadContext
argument_list|()
operator|.
name|readHeaders
argument_list|(
name|streamIn
argument_list|)
expr_stmt|;
if|if
condition|(
name|TransportStatus
operator|.
name|isRequest
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|handleRequest
argument_list|(
name|channel
argument_list|,
name|profileName
argument_list|,
name|streamIn
argument_list|,
name|requestId
argument_list|,
name|messageLengthBytes
argument_list|,
name|version
argument_list|,
name|remoteAddress
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|TransportResponseHandler
argument_list|<
name|?
argument_list|>
name|handler
decl_stmt|;
if|if
condition|(
name|isHandshake
condition|)
block|{
name|handler
operator|=
name|pendingHandshakes
operator|.
name|remove
argument_list|(
name|requestId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TransportResponseHandler
name|theHandler
init|=
name|transportServiceAdapter
operator|.
name|onResponseReceived
argument_list|(
name|requestId
argument_list|)
decl_stmt|;
if|if
condition|(
name|theHandler
operator|==
literal|null
operator|&&
name|TransportStatus
operator|.
name|isError
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|handler
operator|=
name|pendingHandshakes
operator|.
name|remove
argument_list|(
name|requestId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handler
operator|=
name|theHandler
expr_stmt|;
block|}
block|}
comment|// ignore if its null, the adapter logs it
if|if
condition|(
name|handler
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|TransportStatus
operator|.
name|isError
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|handlerResponseError
argument_list|(
name|streamIn
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handleResponse
argument_list|(
name|remoteAddress
argument_list|,
name|streamIn
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|// Check the entire message has been read
specifier|final
name|int
name|nextByte
init|=
name|streamIn
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// calling read() is useful to make sure the message is fully read, even if there is an EOS marker
if|if
condition|(
name|nextByte
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Message not fully read (response) for requestId ["
operator|+
name|requestId
operator|+
literal|"], handler ["
operator|+
name|handler
operator|+
literal|"], error ["
operator|+
name|TransportStatus
operator|.
name|isError
argument_list|(
name|status
argument_list|)
operator|+
literal|"]; resetting"
argument_list|)
throw|;
block|}
block|}
block|}
name|success
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
condition|)
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|streamIn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|streamIn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|ensureVersionCompatibility
specifier|static
name|void
name|ensureVersionCompatibility
parameter_list|(
name|Version
name|version
parameter_list|,
name|Version
name|currentVersion
parameter_list|,
name|boolean
name|isHandshake
parameter_list|)
block|{
comment|// for handshakes we are compatible with N-2 since otherwise we can't figure out our initial version
comment|// since we are compatible with N-1 and N+1 so we always send our minCompatVersion as the initial version in the
comment|// handshake. This looks odd but it's required to establish the connection correctly we check for real compatibility
comment|// once the connection is established
specifier|final
name|Version
name|compatibilityVersion
init|=
name|isHandshake
condition|?
name|currentVersion
operator|.
name|minimumCompatibilityVersion
argument_list|()
else|:
name|currentVersion
decl_stmt|;
if|if
condition|(
name|version
operator|.
name|isCompatible
argument_list|(
name|compatibilityVersion
argument_list|)
operator|==
literal|false
condition|)
block|{
specifier|final
name|Version
name|minCompatibilityVersion
init|=
name|isHandshake
condition|?
name|compatibilityVersion
else|:
name|compatibilityVersion
operator|.
name|minimumCompatibilityVersion
argument_list|()
decl_stmt|;
name|String
name|msg
init|=
literal|"Received "
operator|+
operator|(
name|isHandshake
condition|?
literal|"handshake "
else|:
literal|""
operator|)
operator|+
literal|"message from unsupported version: ["
decl_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|msg
operator|+
name|version
operator|+
literal|"] minimal compatible version is: ["
operator|+
name|minCompatibilityVersion
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
DECL|method|handleResponse
specifier|private
name|void
name|handleResponse
parameter_list|(
name|InetSocketAddress
name|remoteAddress
parameter_list|,
specifier|final
name|StreamInput
name|stream
parameter_list|,
specifier|final
name|TransportResponseHandler
name|handler
parameter_list|)
block|{
specifier|final
name|TransportResponse
name|response
init|=
name|handler
operator|.
name|newInstance
argument_list|()
decl_stmt|;
name|response
operator|.
name|remoteAddress
argument_list|(
operator|new
name|TransportAddress
argument_list|(
name|remoteAddress
argument_list|)
argument_list|)
expr_stmt|;
try|try
block|{
name|response
operator|.
name|readFrom
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|handleException
argument_list|(
name|handler
argument_list|,
operator|new
name|TransportSerializationException
argument_list|(
literal|"Failed to deserialize response of type ["
operator|+
name|response
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|threadPool
operator|.
name|executor
argument_list|(
name|handler
operator|.
name|executor
argument_list|()
argument_list|)
operator|.
name|execute
argument_list|(
operator|new
name|AbstractRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|handleException
argument_list|(
name|handler
argument_list|,
operator|new
name|ResponseHandlerFailureTransportException
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
name|handler
operator|.
name|handleResponse
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Executed for a received response error      */
DECL|method|handlerResponseError
specifier|private
name|void
name|handlerResponseError
parameter_list|(
name|StreamInput
name|stream
parameter_list|,
specifier|final
name|TransportResponseHandler
name|handler
parameter_list|)
block|{
name|Exception
name|error
decl_stmt|;
try|try
block|{
name|error
operator|=
name|stream
operator|.
name|readException
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|error
operator|=
operator|new
name|TransportSerializationException
argument_list|(
literal|"Failed to deserialize exception response from stream"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|handleException
argument_list|(
name|handler
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
DECL|method|handleException
specifier|private
name|void
name|handleException
parameter_list|(
specifier|final
name|TransportResponseHandler
name|handler
parameter_list|,
name|Throwable
name|error
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|error
operator|instanceof
name|RemoteTransportException
operator|)
condition|)
block|{
name|error
operator|=
operator|new
name|RemoteTransportException
argument_list|(
name|error
operator|.
name|getMessage
argument_list|()
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RemoteTransportException
name|rtx
init|=
operator|(
name|RemoteTransportException
operator|)
name|error
decl_stmt|;
name|threadPool
operator|.
name|executor
argument_list|(
name|handler
operator|.
name|executor
argument_list|()
argument_list|)
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
name|handler
operator|.
name|handleException
argument_list|(
name|rtx
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to handle exception response [{}]"
argument_list|,
name|handler
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|handleRequest
specifier|protected
name|String
name|handleRequest
parameter_list|(
name|Channel
name|channel
parameter_list|,
name|String
name|profileName
parameter_list|,
specifier|final
name|StreamInput
name|stream
parameter_list|,
name|long
name|requestId
parameter_list|,
name|int
name|messageLengthBytes
parameter_list|,
name|Version
name|version
parameter_list|,
name|InetSocketAddress
name|remoteAddress
parameter_list|,
name|byte
name|status
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|action
init|=
name|stream
operator|.
name|readString
argument_list|()
decl_stmt|;
name|transportServiceAdapter
operator|.
name|onRequestReceived
argument_list|(
name|requestId
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|TransportChannel
name|transportChannel
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|TransportStatus
operator|.
name|isHandshake
argument_list|(
name|status
argument_list|)
condition|)
block|{
specifier|final
name|VersionHandshakeResponse
name|response
init|=
operator|new
name|VersionHandshakeResponse
argument_list|(
name|getCurrentVersion
argument_list|()
argument_list|)
decl_stmt|;
name|sendResponse
argument_list|(
name|version
argument_list|,
name|channel
argument_list|,
name|response
argument_list|,
name|requestId
argument_list|,
name|HANDSHAKE_ACTION_NAME
argument_list|,
name|TransportResponseOptions
operator|.
name|EMPTY
argument_list|,
name|TransportStatus
operator|.
name|setHandshake
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|RequestHandlerRegistry
name|reg
init|=
name|transportServiceAdapter
operator|.
name|getRequestHandler
argument_list|(
name|action
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ActionNotFoundTransportException
argument_list|(
name|action
argument_list|)
throw|;
block|}
if|if
condition|(
name|reg
operator|.
name|canTripCircuitBreaker
argument_list|()
condition|)
block|{
name|getInFlightRequestBreaker
argument_list|()
operator|.
name|addEstimateBytesAndMaybeBreak
argument_list|(
name|messageLengthBytes
argument_list|,
literal|"<transport_request>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getInFlightRequestBreaker
argument_list|()
operator|.
name|addWithoutBreaking
argument_list|(
name|messageLengthBytes
argument_list|)
expr_stmt|;
block|}
name|transportChannel
operator|=
operator|new
name|TcpTransportChannel
argument_list|<>
argument_list|(
name|this
argument_list|,
name|channel
argument_list|,
name|transportName
argument_list|,
name|action
argument_list|,
name|requestId
argument_list|,
name|version
argument_list|,
name|profileName
argument_list|,
name|messageLengthBytes
argument_list|)
expr_stmt|;
specifier|final
name|TransportRequest
name|request
init|=
name|reg
operator|.
name|newRequest
argument_list|()
decl_stmt|;
name|request
operator|.
name|remoteAddress
argument_list|(
operator|new
name|TransportAddress
argument_list|(
name|remoteAddress
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|.
name|readFrom
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|// in case we throw an exception, i.e. when the limit is hit, we don't want to verify
name|validateRequest
argument_list|(
name|stream
argument_list|,
name|requestId
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|threadPool
operator|.
name|executor
argument_list|(
name|reg
operator|.
name|getExecutor
argument_list|()
argument_list|)
operator|.
name|execute
argument_list|(
operator|new
name|RequestHandler
argument_list|(
name|reg
argument_list|,
name|request
argument_list|,
name|transportChannel
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// the circuit breaker tripped
if|if
condition|(
name|transportChannel
operator|==
literal|null
condition|)
block|{
name|transportChannel
operator|=
operator|new
name|TcpTransportChannel
argument_list|<>
argument_list|(
name|this
argument_list|,
name|channel
argument_list|,
name|transportName
argument_list|,
name|action
argument_list|,
name|requestId
argument_list|,
name|version
argument_list|,
name|profileName
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|transportChannel
operator|.
name|sendResponse
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|inner
parameter_list|)
block|{
name|inner
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"Failed to send error message back to client for action [{}]"
argument_list|,
name|action
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|action
return|;
block|}
comment|// This template method is needed to inject custom error checking logic in tests.
DECL|method|validateRequest
specifier|protected
name|void
name|validateRequest
parameter_list|(
name|StreamInput
name|stream
parameter_list|,
name|long
name|requestId
parameter_list|,
name|String
name|action
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|nextByte
init|=
name|stream
operator|.
name|read
argument_list|()
decl_stmt|;
comment|// calling read() is useful to make sure the message is fully read, even if there some kind of EOS marker
if|if
condition|(
name|nextByte
operator|!=
operator|-
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Message not fully read (request) for requestId ["
operator|+
name|requestId
operator|+
literal|"], action ["
operator|+
name|action
operator|+
literal|"], available ["
operator|+
name|stream
operator|.
name|available
argument_list|()
operator|+
literal|"]; resetting"
argument_list|)
throw|;
block|}
block|}
DECL|class|RequestHandler
class|class
name|RequestHandler
extends|extends
name|AbstractRunnable
block|{
DECL|field|reg
specifier|private
specifier|final
name|RequestHandlerRegistry
name|reg
decl_stmt|;
DECL|field|request
specifier|private
specifier|final
name|TransportRequest
name|request
decl_stmt|;
DECL|field|transportChannel
specifier|private
specifier|final
name|TransportChannel
name|transportChannel
decl_stmt|;
DECL|method|RequestHandler
name|RequestHandler
parameter_list|(
name|RequestHandlerRegistry
name|reg
parameter_list|,
name|TransportRequest
name|request
parameter_list|,
name|TransportChannel
name|transportChannel
parameter_list|)
block|{
name|this
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|transportChannel
operator|=
name|transportChannel
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|}
argument_list|)
annotation|@
name|Override
DECL|method|doRun
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
name|reg
operator|.
name|processMessageReceived
argument_list|(
name|request
argument_list|,
name|transportChannel
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|isForceExecution
specifier|public
name|boolean
name|isForceExecution
parameter_list|()
block|{
return|return
name|reg
operator|.
name|isForceExecution
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|onFailure
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|lifecycleState
argument_list|()
operator|==
name|Lifecycle
operator|.
name|State
operator|.
name|STARTED
condition|)
block|{
comment|// we can only send a response transport is started....
try|try
block|{
name|transportChannel
operator|.
name|sendResponse
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|inner
parameter_list|)
block|{
name|inner
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"Failed to send error message back to client for action [{}]"
argument_list|,
name|reg
operator|.
name|getAction
argument_list|()
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|VersionHandshakeResponse
specifier|private
specifier|static
specifier|final
class|class
name|VersionHandshakeResponse
extends|extends
name|TransportResponse
block|{
DECL|field|version
specifier|private
name|Version
name|version
decl_stmt|;
DECL|method|VersionHandshakeResponse
specifier|private
name|VersionHandshakeResponse
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
block|}
DECL|method|VersionHandshakeResponse
specifier|private
name|VersionHandshakeResponse
parameter_list|()
block|{}
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|version
operator|=
name|Version
operator|.
name|readVersion
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
assert|assert
name|version
operator|!=
literal|null
assert|;
name|Version
operator|.
name|writeVersion
argument_list|(
name|version
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|executeHandshake
specifier|protected
name|Version
name|executeHandshake
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|Channel
name|channel
parameter_list|,
name|TimeValue
name|timeout
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|numHandshakes
operator|.
name|inc
argument_list|()
expr_stmt|;
specifier|final
name|long
name|requestId
init|=
name|newRequestId
argument_list|()
decl_stmt|;
specifier|final
name|HandshakeResponseHandler
name|handler
init|=
operator|new
name|HandshakeResponseHandler
argument_list|(
name|channel
argument_list|)
decl_stmt|;
name|AtomicReference
argument_list|<
name|Version
argument_list|>
name|versionRef
init|=
name|handler
operator|.
name|versionRef
decl_stmt|;
name|AtomicReference
argument_list|<
name|Exception
argument_list|>
name|exceptionRef
init|=
name|handler
operator|.
name|exceptionRef
decl_stmt|;
name|pendingHandshakes
operator|.
name|put
argument_list|(
name|requestId
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|isOpen
argument_list|(
name|channel
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// we have to protect us here since sendRequestToChannel won't barf if the channel is closed.
comment|// it's weird but to change it will cause a lot of impact on the exception handling code all over the codebase.
comment|// yet, if we don't check the state here we might have registered a pending handshake handler but the close
comment|// listener calling #onChannelClosed might have already run and we are waiting on the latch below unitl we time out.
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"handshake failed, channel already closed"
argument_list|)
throw|;
block|}
comment|// for the request we use the minCompatVersion since we don't know what's the version of the node we talk to
comment|// we also have no payload on the request but the response will contain the actual version of the node we talk
comment|// to as the payload.
specifier|final
name|Version
name|minCompatVersion
init|=
name|getCurrentVersion
argument_list|()
operator|.
name|minimumCompatibilityVersion
argument_list|()
decl_stmt|;
name|sendRequestToChannel
argument_list|(
name|node
argument_list|,
name|channel
argument_list|,
name|requestId
argument_list|,
name|HANDSHAKE_ACTION_NAME
argument_list|,
name|TransportRequest
operator|.
name|Empty
operator|.
name|INSTANCE
argument_list|,
name|TransportRequestOptions
operator|.
name|EMPTY
argument_list|,
name|minCompatVersion
argument_list|,
name|TransportStatus
operator|.
name|setHandshake
argument_list|(
operator|(
name|byte
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|.
name|latch
operator|.
name|await
argument_list|(
name|timeout
operator|.
name|millis
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|ConnectTransportException
argument_list|(
name|node
argument_list|,
literal|"handshake_timeout["
operator|+
name|timeout
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|success
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|exceptionRef
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"handshake failed"
argument_list|,
name|exceptionRef
operator|.
name|get
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|Version
name|version
init|=
name|versionRef
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|getCurrentVersion
argument_list|()
operator|.
name|isCompatible
argument_list|(
name|version
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Received message from unsupported version: ["
operator|+
name|version
operator|+
literal|"] minimal compatible version is: ["
operator|+
name|getCurrentVersion
argument_list|()
operator|.
name|minimumCompatibilityVersion
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|version
return|;
block|}
block|}
finally|finally
block|{
specifier|final
name|TransportResponseHandler
argument_list|<
name|?
argument_list|>
name|removedHandler
init|=
name|pendingHandshakes
operator|.
name|remove
argument_list|(
name|requestId
argument_list|)
decl_stmt|;
comment|// in the case of a timeout or an exception on the send part the handshake has not been removed yet.
comment|// but the timeout is tricky since it's basically a race condition so we only assert on the success case.
assert|assert
name|success
operator|&&
name|removedHandler
operator|==
literal|null
operator|||
name|success
operator|==
literal|false
operator|:
literal|"handler for requestId ["
operator|+
name|requestId
operator|+
literal|"] is not been removed"
assert|;
block|}
block|}
DECL|method|getNumPendingHandshakes
specifier|final
name|int
name|getNumPendingHandshakes
parameter_list|()
block|{
comment|// for testing
return|return
name|pendingHandshakes
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getNumHandshakes
specifier|final
name|long
name|getNumHandshakes
parameter_list|()
block|{
return|return
name|numHandshakes
operator|.
name|count
argument_list|()
return|;
comment|// for testing
block|}
annotation|@
name|Override
DECL|method|newRequestId
specifier|public
name|long
name|newRequestId
parameter_list|()
block|{
return|return
name|requestIdGenerator
operator|.
name|incrementAndGet
argument_list|()
return|;
block|}
comment|/**      * Called once the channel is closed for instance due to a disconnect or a closed socket etc.      */
DECL|method|onChannelClosed
specifier|private
name|void
name|onChannelClosed
parameter_list|(
name|Channel
name|channel
parameter_list|)
block|{
specifier|final
name|Optional
argument_list|<
name|Long
argument_list|>
name|first
init|=
name|pendingHandshakes
operator|.
name|entrySet
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
parameter_list|(
name|entry
parameter_list|)
lambda|->
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|channel
operator|==
name|channel
argument_list|)
operator|.
name|map
argument_list|(
parameter_list|(
name|e
parameter_list|)
lambda|->
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|.
name|findFirst
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|isPresent
argument_list|()
condition|)
block|{
specifier|final
name|Long
name|requestId
init|=
name|first
operator|.
name|get
argument_list|()
decl_stmt|;
specifier|final
name|HandshakeResponseHandler
name|handler
init|=
name|pendingHandshakes
operator|.
name|remove
argument_list|(
name|requestId
argument_list|)
decl_stmt|;
if|if
condition|(
name|handler
operator|!=
literal|null
condition|)
block|{
comment|// there might be a race removing this or this method might be called twice concurrently depending on how
comment|// the channel is closed ie. due to connection reset or broken pipes
name|handler
operator|.
name|handleException
argument_list|(
operator|new
name|TransportException
argument_list|(
literal|"connection reset"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Ensures this transport is still started / open      *      * @throws IllegalStateException if the transport is not started / open      */
DECL|method|ensureOpen
specifier|protected
specifier|final
name|void
name|ensureOpen
parameter_list|()
block|{
if|if
condition|(
name|lifecycle
operator|.
name|started
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"transport has been stopped"
argument_list|)
throw|;
block|}
block|}
comment|/**      * This listener increments the transmitted bytes metric on success.      */
DECL|class|SendMetricListener
specifier|private
specifier|abstract
class|class
name|SendMetricListener
parameter_list|<
name|T
parameter_list|>
extends|extends
name|NotifyOnceListener
argument_list|<
name|T
argument_list|>
block|{
DECL|field|messageSize
specifier|private
specifier|final
name|long
name|messageSize
decl_stmt|;
DECL|method|SendMetricListener
specifier|private
name|SendMetricListener
parameter_list|(
name|long
name|messageSize
parameter_list|)
block|{
name|this
operator|.
name|messageSize
operator|=
name|messageSize
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|innerOnResponse
specifier|protected
specifier|final
name|void
name|innerOnResponse
parameter_list|(
name|T
name|object
parameter_list|)
block|{
name|transmittedBytesMetric
operator|.
name|inc
argument_list|(
name|messageSize
argument_list|)
expr_stmt|;
name|innerInnerOnResponse
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
DECL|method|innerInnerOnResponse
specifier|protected
specifier|abstract
name|void
name|innerInnerOnResponse
parameter_list|(
name|T
name|object
parameter_list|)
function_decl|;
block|}
DECL|class|SendListener
specifier|private
specifier|final
class|class
name|SendListener
extends|extends
name|SendMetricListener
argument_list|<
name|Channel
argument_list|>
block|{
DECL|field|optionalReleasable
specifier|private
specifier|final
name|Releasable
name|optionalReleasable
decl_stmt|;
DECL|field|transportAdaptorCallback
specifier|private
specifier|final
name|Runnable
name|transportAdaptorCallback
decl_stmt|;
DECL|method|SendListener
specifier|private
name|SendListener
parameter_list|(
name|Releasable
name|optionalReleasable
parameter_list|,
name|Runnable
name|transportAdaptorCallback
parameter_list|,
name|long
name|messageLength
parameter_list|)
block|{
name|super
argument_list|(
name|messageLength
argument_list|)
expr_stmt|;
name|this
operator|.
name|optionalReleasable
operator|=
name|optionalReleasable
expr_stmt|;
name|this
operator|.
name|transportAdaptorCallback
operator|=
name|transportAdaptorCallback
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|innerInnerOnResponse
specifier|protected
name|void
name|innerInnerOnResponse
parameter_list|(
name|Channel
name|channel
parameter_list|)
block|{
name|release
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|innerOnFailure
specifier|protected
name|void
name|innerOnFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|release
argument_list|()
expr_stmt|;
block|}
DECL|method|release
specifier|private
name|void
name|release
parameter_list|()
block|{
name|Releasables
operator|.
name|close
argument_list|(
name|optionalReleasable
argument_list|,
name|transportAdaptorCallback
operator|::
name|run
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns count of currently open connections      */
DECL|method|getNumOpenServerConnections
specifier|protected
specifier|abstract
name|long
name|getNumOpenServerConnections
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|getStats
specifier|public
specifier|final
name|TransportStats
name|getStats
parameter_list|()
block|{
return|return
operator|new
name|TransportStats
argument_list|(
name|getNumOpenServerConnections
argument_list|()
argument_list|,
name|readBytesMetric
operator|.
name|count
argument_list|()
argument_list|,
name|readBytesMetric
operator|.
name|sum
argument_list|()
argument_list|,
name|transmittedBytesMetric
operator|.
name|count
argument_list|()
argument_list|,
name|transmittedBytesMetric
operator|.
name|sum
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

