begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.indices.recovery
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimiter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|Streams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|CancellableThreads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|CancellableThreads
operator|.
name|Interruptable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|RecoveryEngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|Translog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|EmptyTransportResponseHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|RemoteTransportException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequestOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadPoolExecutor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|StreamSupport
import|;
end_import

begin_comment
comment|/**  * RecoverySourceHandler handles the three phases of shard recovery, which is  * everything relating to copying the segment files as well as sending translog  * operations across the wire once the segments have been copied.  */
end_comment

begin_class
DECL|class|RecoverySourceHandler
specifier|public
class|class
name|RecoverySourceHandler
block|{
DECL|field|CHUNK_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|CHUNK_SIZE
init|=
operator|new
name|ByteSizeValue
argument_list|(
literal|512
argument_list|,
name|ByteSizeUnit
operator|.
name|KB
argument_list|)
operator|.
name|bytesAsInt
argument_list|()
decl_stmt|;
DECL|field|logger
specifier|protected
specifier|final
name|ESLogger
name|logger
decl_stmt|;
comment|// Shard that is going to be recovered (the "source")
DECL|field|shard
specifier|private
specifier|final
name|IndexShard
name|shard
decl_stmt|;
DECL|field|indexName
specifier|private
specifier|final
name|String
name|indexName
decl_stmt|;
DECL|field|shardId
specifier|private
specifier|final
name|int
name|shardId
decl_stmt|;
comment|// Request containing source and target node information
DECL|field|request
specifier|private
specifier|final
name|StartRecoveryRequest
name|request
decl_stmt|;
DECL|field|recoverySettings
specifier|private
specifier|final
name|RecoverySettings
name|recoverySettings
decl_stmt|;
DECL|field|transportService
specifier|private
specifier|final
name|TransportService
name|transportService
decl_stmt|;
DECL|field|response
specifier|protected
specifier|final
name|RecoveryResponse
name|response
decl_stmt|;
DECL|field|cancellableThreads
specifier|private
specifier|final
name|CancellableThreads
name|cancellableThreads
init|=
operator|new
name|CancellableThreads
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|onCancel
parameter_list|(
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|suppressedException
parameter_list|)
block|{
name|RuntimeException
name|e
decl_stmt|;
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// check if the shard got closed on us
name|e
operator|=
operator|new
name|IndexShardClosedException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"shard is closed and recovery was canceled reason ["
operator|+
name|reason
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
operator|new
name|ExecutionCancelledException
argument_list|(
literal|"recovery was canceled reason ["
operator|+
name|reason
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suppressedException
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|addSuppressed
argument_list|(
name|suppressedException
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
decl_stmt|;
DECL|method|RecoverySourceHandler
specifier|public
name|RecoverySourceHandler
parameter_list|(
specifier|final
name|IndexShard
name|shard
parameter_list|,
specifier|final
name|StartRecoveryRequest
name|request
parameter_list|,
specifier|final
name|RecoverySettings
name|recoverySettings
parameter_list|,
specifier|final
name|TransportService
name|transportService
parameter_list|,
specifier|final
name|ESLogger
name|logger
parameter_list|)
block|{
name|this
operator|.
name|shard
operator|=
name|shard
expr_stmt|;
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|recoverySettings
operator|=
name|recoverySettings
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|transportService
operator|=
name|transportService
expr_stmt|;
name|this
operator|.
name|indexName
operator|=
name|this
operator|.
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|this
operator|.
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
expr_stmt|;
name|this
operator|.
name|response
operator|=
operator|new
name|RecoveryResponse
argument_list|()
expr_stmt|;
block|}
comment|/**      * performs the recovery from the local engine to the target      */
DECL|method|recoverToTarget
specifier|public
name|RecoveryResponse
name|recoverToTarget
parameter_list|()
block|{
try|try
init|(
name|Translog
operator|.
name|View
name|translogView
init|=
name|shard
operator|.
name|acquireTranslogView
argument_list|()
init|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"captured translog id [{}] for recovery"
argument_list|,
name|translogView
operator|.
name|minTranslogGeneration
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|IndexCommit
name|phase1Snapshot
decl_stmt|;
try|try
block|{
name|phase1Snapshot
operator|=
name|shard
operator|.
name|snapshotIndex
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|translogView
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RecoveryEngineException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|"Snapshot failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|phase1
argument_list|(
name|phase1Snapshot
argument_list|,
name|translogView
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RecoveryEngineException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|"phase1 failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
name|shard
operator|.
name|releaseSnapshot
argument_list|(
name|phase1Snapshot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"releasing snapshot caused exception"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"snapshot translog for recovery. current size is [{}]"
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
name|Translog
operator|.
name|Snapshot
name|phase2Snapshot
init|=
name|translogView
operator|.
name|snapshot
argument_list|()
init|)
block|{
name|phase2
argument_list|(
name|phase2Snapshot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RecoveryEngineException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|"phase2 failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|finalizeRecovery
argument_list|()
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
comment|/**      * Perform phase1 of the recovery operations. Once this {@link IndexCommit}      * snapshot has been performed no commit operations (files being fsync'd)      * are effectively allowed on this index until all recovery phases are done      *<p>      * Phase1 examines the segment files on the target node and copies over the      * segments that are missing. Only segments that have the same size and      * checksum can be reused      */
DECL|method|phase1
specifier|public
name|void
name|phase1
parameter_list|(
specifier|final
name|IndexCommit
name|snapshot
parameter_list|,
specifier|final
name|Translog
operator|.
name|View
name|translogView
parameter_list|)
block|{
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
comment|// Total size of segment files that are recovered
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
comment|// Total size of segment files that were able to be re-used
name|long
name|existingTotalSize
init|=
literal|0
decl_stmt|;
specifier|final
name|Store
name|store
init|=
name|shard
operator|.
name|store
argument_list|()
decl_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|recoverySourceMetadata
decl_stmt|;
try|try
block|{
name|recoverySourceMetadata
operator|=
name|store
operator|.
name|getMetadata
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|ex
parameter_list|)
block|{
name|shard
operator|.
name|failShard
argument_list|(
literal|"recovery"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
for|for
control|(
name|String
name|name
range|:
name|snapshot
operator|.
name|getFileNames
argument_list|()
control|)
block|{
specifier|final
name|StoreFileMetaData
name|md
init|=
name|recoverySourceMetadata
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Snapshot differs from actual index for file: {} meta: {}"
argument_list|,
name|name
argument_list|,
name|recoverySourceMetadata
operator|.
name|asMap
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"Snapshot differs from actual index - maybe index was removed metadata has "
operator|+
name|recoverySourceMetadata
operator|.
name|asMap
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" files"
argument_list|,
name|name
argument_list|)
throw|;
block|}
block|}
comment|// Generate a "diff" of all the identical, different, and missing
comment|// segment files on the target node, using the existing files on
comment|// the source node
name|String
name|recoverySourceSyncId
init|=
name|recoverySourceMetadata
operator|.
name|getSyncId
argument_list|()
decl_stmt|;
name|String
name|recoveryTargetSyncId
init|=
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|getSyncId
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|recoverWithSyncId
init|=
name|recoverySourceSyncId
operator|!=
literal|null
operator|&&
name|recoverySourceSyncId
operator|.
name|equals
argument_list|(
name|recoveryTargetSyncId
argument_list|)
decl_stmt|;
if|if
condition|(
name|recoverWithSyncId
condition|)
block|{
specifier|final
name|long
name|numDocsTarget
init|=
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|getNumDocs
argument_list|()
decl_stmt|;
specifier|final
name|long
name|numDocsSource
init|=
name|recoverySourceMetadata
operator|.
name|getNumDocs
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDocsTarget
operator|!=
name|numDocsSource
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"try to recover "
operator|+
name|request
operator|.
name|shardId
argument_list|()
operator|+
literal|" from primary shard with sync id but number of docs differ: "
operator|+
name|numDocsTarget
operator|+
literal|" ("
operator|+
name|request
operator|.
name|sourceNode
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", primary) vs "
operator|+
name|numDocsSource
operator|+
literal|"("
operator|+
name|request
operator|.
name|targetNode
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// we shortcut recovery here because we have nothing to copy. but we must still start the engine on the target.
comment|// so we don't return here
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] skipping [phase1] to {} - identical sync id [{}] found on both source and target"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|recoverySourceSyncId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Store
operator|.
name|RecoveryDiff
name|diff
init|=
name|recoverySourceMetadata
operator|.
name|recoveryDiff
argument_list|(
name|request
operator|.
name|metadataSnapshot
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|diff
operator|.
name|identical
control|)
block|{
name|response
operator|.
name|phase1ExistingFileNames
operator|.
name|add
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase1ExistingFileSizes
operator|.
name|add
argument_list|(
name|md
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|existingTotalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: not recovering [{}], exists in local store and has checksum [{}], size [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
operator|.
name|name
argument_list|()
argument_list|,
name|md
operator|.
name|checksum
argument_list|()
argument_list|,
name|md
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|totalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|StoreFileMetaData
argument_list|>
name|phase1Files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|diff
operator|.
name|different
operator|.
name|size
argument_list|()
operator|+
name|diff
operator|.
name|missing
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|phase1Files
operator|.
name|addAll
argument_list|(
name|diff
operator|.
name|different
argument_list|)
expr_stmt|;
name|phase1Files
operator|.
name|addAll
argument_list|(
name|diff
operator|.
name|missing
argument_list|)
expr_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|phase1Files
control|)
block|{
if|if
condition|(
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|asMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: recovering [{}], exists in local store, but is different: remote [{}], local [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
operator|.
name|name
argument_list|()
argument_list|,
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|asMap
argument_list|()
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: recovering [{}], does not exists in remote"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|phase1FileNames
operator|.
name|add
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase1FileSizes
operator|.
name|add
argument_list|(
name|md
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|response
operator|.
name|phase1TotalSize
operator|=
name|totalSize
expr_stmt|;
name|response
operator|.
name|phase1ExistingTotalSize
operator|=
name|existingTotalSize
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: recovering_files [{}] with total_size [{}], reusing_files [{}] with total_size [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|response
operator|.
name|phase1FileNames
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|totalSize
argument_list|)
argument_list|,
name|response
operator|.
name|phase1ExistingFileNames
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|existingTotalSize
argument_list|)
argument_list|)
expr_stmt|;
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
name|RecoveryFilesInfoRequest
name|recoveryInfoFilesRequest
init|=
operator|new
name|RecoveryFilesInfoRequest
argument_list|(
name|request
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|response
operator|.
name|phase1FileNames
argument_list|,
name|response
operator|.
name|phase1FileSizes
argument_list|,
name|response
operator|.
name|phase1ExistingFileNames
argument_list|,
name|response
operator|.
name|phase1ExistingFileSizes
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
decl_stmt|;
name|transportService
operator|.
name|submitRequest
argument_list|(
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|FILES_INFO
argument_list|,
name|recoveryInfoFilesRequest
argument_list|,
name|TransportRequestOptions
operator|.
name|builder
argument_list|()
operator|.
name|withTimeout
argument_list|(
name|recoverySettings
operator|.
name|internalActionTimeout
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
operator|.
name|txGet
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
comment|// How many bytes we've copied since we last called RateLimiter.pause
specifier|final
name|AtomicLong
name|bytesSinceLastPause
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
specifier|final
name|Function
argument_list|<
name|StoreFileMetaData
argument_list|,
name|OutputStream
argument_list|>
name|outputStreamFactories
init|=
parameter_list|(
name|md
parameter_list|)
lambda|->
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|RecoveryOutputStream
argument_list|(
name|md
argument_list|,
name|bytesSinceLastPause
argument_list|,
name|translogView
argument_list|)
argument_list|,
name|CHUNK_SIZE
argument_list|)
decl_stmt|;
name|sendFiles
argument_list|(
name|store
argument_list|,
name|phase1Files
operator|.
name|toArray
argument_list|(
operator|new
name|StoreFileMetaData
index|[
name|phase1Files
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|outputStreamFactories
argument_list|)
expr_stmt|;
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
comment|// Send the CLEAN_FILES request, which takes all of the files that
comment|// were transferred and renames them from their temporary file
comment|// names to the actual file names. It also writes checksums for
comment|// the files after they have been renamed.
comment|//
comment|// Once the files have been renamed, any other files that are not
comment|// related to this recovery (out of date segments, for example)
comment|// are deleted
try|try
block|{
name|transportService
operator|.
name|submitRequest
argument_list|(
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|CLEAN_FILES
argument_list|,
operator|new
name|RecoveryCleanFilesRequest
argument_list|(
name|request
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|recoverySourceMetadata
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
argument_list|,
name|TransportRequestOptions
operator|.
name|builder
argument_list|()
operator|.
name|withTimeout
argument_list|(
name|recoverySettings
operator|.
name|internalActionTimeout
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
operator|.
name|txGet
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteTransportException
name|remoteException
parameter_list|)
block|{
specifier|final
name|IOException
name|corruptIndexException
decl_stmt|;
comment|// we realized that after the index was copied and we wanted to finalize the recovery
comment|// the index was corrupted:
comment|//   - maybe due to a broken segments file on an empty index (transferred with no checksum)
comment|//   - maybe due to old segments without checksums or length only checks
if|if
condition|(
operator|(
name|corruptIndexException
operator|=
name|ExceptionsHelper
operator|.
name|unwrapCorruption
argument_list|(
name|remoteException
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|recoverySourceMetadata1
init|=
name|store
operator|.
name|getMetadata
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|StoreFileMetaData
index|[]
name|metadata
init|=
name|StreamSupport
operator|.
name|stream
argument_list|(
name|recoverySourceMetadata1
operator|.
name|spliterator
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|toArray
argument_list|(
name|size
lambda|->
operator|new
name|StoreFileMetaData
index|[
name|size
index|]
argument_list|)
decl_stmt|;
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|metadata
argument_list|,
operator|new
name|Comparator
argument_list|<
name|StoreFileMetaData
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|StoreFileMetaData
name|o1
parameter_list|,
name|StoreFileMetaData
name|o2
parameter_list|)
block|{
return|return
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|length
argument_list|()
argument_list|,
name|o2
operator|.
name|length
argument_list|()
argument_list|)
return|;
comment|// check small files first
block|}
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|metadata
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} checking integrity for file {} after remove corruption exception"
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|checkIntegrityNoException
argument_list|(
name|md
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// we are corrupted on the primary -- fail!
name|shard
operator|.
name|failShard
argument_list|(
literal|"recovery"
argument_list|,
name|corruptIndexException
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Corrupted file detected {} checksum mismatch"
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|md
argument_list|)
expr_stmt|;
throw|throw
name|corruptIndexException
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|remoteException
operator|.
name|addSuppressed
argument_list|(
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|remoteException
throw|;
block|}
comment|// corruption has happened on the way to replica
name|RemoteTransportException
name|exception
init|=
operator|new
name|RemoteTransportException
argument_list|(
literal|"File corruption occurred on recovery but checksums are ok"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|exception
operator|.
name|addSuppressed
argument_list|(
name|remoteException
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Remote file corruption during finalization on node {}, recovering {}. local checksum OK"
argument_list|,
name|corruptIndexException
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
else|else
block|{
throw|throw
name|remoteException
throw|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|prepareTargetForTranslog
argument_list|(
name|translogView
argument_list|)
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: took [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase1Time
operator|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RecoverFilesRecoveryException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|response
operator|.
name|phase1FileNames
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|totalSize
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|prepareTargetForTranslog
specifier|protected
name|void
name|prepareTargetForTranslog
parameter_list|(
specifier|final
name|Translog
operator|.
name|View
name|translogView
parameter_list|)
block|{
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase1] to {}: prepare remote engine for translog"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|startEngineStart
init|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
decl_stmt|;
name|cancellableThreads
operator|.
name|execute
argument_list|(
operator|new
name|Interruptable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
throws|throws
name|InterruptedException
block|{
comment|// Send a request preparing the new shard's translog to receive
comment|// operations. This ensures the shard engine is started and disables
comment|// garbage collection (not the JVM's GC!) of tombstone deletes
name|transportService
operator|.
name|submitRequest
argument_list|(
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|PREPARE_TRANSLOG
argument_list|,
operator|new
name|RecoveryPrepareForTranslogOperationsRequest
argument_list|(
name|request
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
argument_list|,
name|TransportRequestOptions
operator|.
name|builder
argument_list|()
operator|.
name|withTimeout
argument_list|(
name|recoverySettings
operator|.
name|internalActionTimeout
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
operator|.
name|txGet
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
name|stopWatch
operator|.
name|stop
argument_list|()
expr_stmt|;
name|response
operator|.
name|startTime
operator|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
operator|-
name|startEngineStart
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase1] to {}: remote engine start took [{}]"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Perform phase2 of the recovery process      *<p>      * Phase2 takes a snapshot of the current translog *without* acquiring the      * write lock (however, the translog snapshot is a point-in-time view of      * the translog). It then sends each translog operation to the target node      * so it can be replayed into the new shard.      */
DECL|method|phase2
specifier|public
name|void
name|phase2
parameter_list|(
name|Translog
operator|.
name|Snapshot
name|snapshot
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase2] to {}: sending transaction log operations"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
comment|// Send all the snapshot's translog operations to the target
name|int
name|totalOperations
init|=
name|sendSnapshot
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|stopWatch
operator|.
name|stop
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase2] to {}: took [{}]"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase2Time
operator|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
expr_stmt|;
name|response
operator|.
name|phase2Operations
operator|=
name|totalOperations
expr_stmt|;
block|}
comment|/**      * finalizes the recovery process      */
DECL|method|finalizeRecovery
specifier|public
name|void
name|finalizeRecovery
parameter_list|()
block|{
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] finalizing recovery to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
name|cancellableThreads
operator|.
name|execute
argument_list|(
operator|new
name|Interruptable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
throws|throws
name|InterruptedException
block|{
comment|// Send the FINALIZE request to the target node. The finalize request
comment|// clears unreferenced translog files, refreshes the engine now that
comment|// new segments are available, and enables garbage collection of
comment|// tombstone files. The shard is also moved to the POST_RECOVERY phase
comment|// during this time
name|transportService
operator|.
name|submitRequest
argument_list|(
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|FINALIZE
argument_list|,
operator|new
name|RecoveryFinalizeRecoveryRequest
argument_list|(
name|request
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
argument_list|,
name|TransportRequestOptions
operator|.
name|builder
argument_list|()
operator|.
name|withTimeout
argument_list|(
name|recoverySettings
operator|.
name|internalActionLongTimeout
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
operator|.
name|txGet
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|.
name|markAsRelocated
argument_list|()
condition|)
block|{
comment|// TODO what happens if the recovery process fails afterwards, we need to mark this back to started
try|try
block|{
name|shard
operator|.
name|relocated
argument_list|(
literal|"to "
operator|+
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalIndexShardStateException
name|e
parameter_list|)
block|{
comment|// we can ignore this exception since, on the other node, when it moved to phase3
comment|// it will also send shard started, which might cause the index shard we work against
comment|// to move be closed by the time we get to the the relocated method
block|}
block|}
name|stopWatch
operator|.
name|stop
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] finalizing recovery to {}: took [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Send the given snapshot's operations to this handler's target node.      *<p>      * Operations are bulked into a single request depending on an operation      * count limit or size-in-bytes limit      *      * @return the total number of translog operations that were sent      */
DECL|method|sendSnapshot
specifier|protected
name|int
name|sendSnapshot
parameter_list|(
specifier|final
name|Translog
operator|.
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|int
name|ops
init|=
literal|0
decl_stmt|;
name|long
name|size
init|=
literal|0
decl_stmt|;
name|int
name|totalOperations
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Translog
operator|.
name|Operation
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Translog
operator|.
name|Operation
name|operation
decl_stmt|;
try|try
block|{
name|operation
operator|=
name|snapshot
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// this ex should bubble up
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to get next operation from translog"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
specifier|final
name|TransportRequestOptions
name|recoveryOptions
init|=
name|TransportRequestOptions
operator|.
name|builder
argument_list|()
operator|.
name|withCompress
argument_list|(
literal|true
argument_list|)
operator|.
name|withType
argument_list|(
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|RECOVERY
argument_list|)
operator|.
name|withTimeout
argument_list|(
name|recoverySettings
operator|.
name|internalActionLongTimeout
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
if|if
condition|(
name|operation
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] no translog operations to send to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|operation
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
name|operations
operator|.
name|add
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|ops
operator|+=
literal|1
expr_stmt|;
name|size
operator|+=
name|operation
operator|.
name|estimateSize
argument_list|()
expr_stmt|;
name|totalOperations
operator|++
expr_stmt|;
comment|// Check if this request is past bytes threshold, and
comment|// if so, send it off
if|if
condition|(
name|size
operator|>=
name|CHUNK_SIZE
condition|)
block|{
comment|// don't throttle translog, since we lock for phase3 indexing,
comment|// so we need to move it as fast as possible. Note, since we
comment|// index docs to replicas while the index files are recovered
comment|// the lock can potentially be removed, in which case, it might
comment|// make sense to re-enable throttling in this phase
comment|//                if (recoverySettings.rateLimiter() != null) {
comment|//                    recoverySettings.rateLimiter().pause(size);
comment|//                }
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
specifier|final
name|RecoveryTranslogOperationsRequest
name|translogOperationsRequest
init|=
operator|new
name|RecoveryTranslogOperationsRequest
argument_list|(
name|request
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|operations
argument_list|,
name|snapshot
operator|.
name|estimatedTotalOperations
argument_list|()
argument_list|)
decl_stmt|;
name|transportService
operator|.
name|submitRequest
argument_list|(
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|TRANSLOG_OPS
argument_list|,
name|translogOperationsRequest
argument_list|,
name|recoveryOptions
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
operator|.
name|txGet
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] sent batch of [{}][{}] (total: [{}]) translog operations to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|ops
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|size
argument_list|)
argument_list|,
name|snapshot
operator|.
name|estimatedTotalOperations
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ops
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|operations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|operation
operator|=
name|snapshot
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// this ex should bubble up
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to get next operation from translog"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|// send the leftover
if|if
condition|(
operator|!
name|operations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
name|RecoveryTranslogOperationsRequest
name|translogOperationsRequest
init|=
operator|new
name|RecoveryTranslogOperationsRequest
argument_list|(
name|request
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|operations
argument_list|,
name|snapshot
operator|.
name|estimatedTotalOperations
argument_list|()
argument_list|)
decl_stmt|;
name|transportService
operator|.
name|submitRequest
argument_list|(
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|TRANSLOG_OPS
argument_list|,
name|translogOperationsRequest
argument_list|,
name|recoveryOptions
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
operator|.
name|txGet
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] sent final batch of [{}][{}] (total: [{}]) translog operations to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|ops
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|size
argument_list|)
argument_list|,
name|snapshot
operator|.
name|estimatedTotalOperations
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|totalOperations
return|;
block|}
comment|/**      * Cancels the recovery and interrupts all eligible threads.      */
DECL|method|cancel
specifier|public
name|void
name|cancel
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|cancellableThreads
operator|.
name|cancel
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ShardRecoveryHandler{"
operator|+
literal|"shardId="
operator|+
name|request
operator|.
name|shardId
argument_list|()
operator|+
literal|", sourceNode="
operator|+
name|request
operator|.
name|sourceNode
argument_list|()
operator|+
literal|", targetNode="
operator|+
name|request
operator|.
name|targetNode
argument_list|()
operator|+
literal|'}'
return|;
block|}
DECL|class|RecoveryOutputStream
specifier|final
class|class
name|RecoveryOutputStream
extends|extends
name|OutputStream
block|{
DECL|field|md
specifier|private
specifier|final
name|StoreFileMetaData
name|md
decl_stmt|;
DECL|field|bytesSinceLastPause
specifier|private
specifier|final
name|AtomicLong
name|bytesSinceLastPause
decl_stmt|;
DECL|field|translogView
specifier|private
specifier|final
name|Translog
operator|.
name|View
name|translogView
decl_stmt|;
DECL|field|position
specifier|private
name|long
name|position
init|=
literal|0
decl_stmt|;
DECL|field|failed
specifier|private
name|boolean
name|failed
init|=
literal|false
decl_stmt|;
DECL|method|RecoveryOutputStream
name|RecoveryOutputStream
parameter_list|(
name|StoreFileMetaData
name|md
parameter_list|,
name|AtomicLong
name|bytesSinceLastPause
parameter_list|,
name|Translog
operator|.
name|View
name|translogView
parameter_list|)
block|{
name|this
operator|.
name|md
operator|=
name|md
expr_stmt|;
name|this
operator|.
name|bytesSinceLastPause
operator|=
name|bytesSinceLastPause
expr_stmt|;
name|this
operator|.
name|translogView
operator|=
name|translogView
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
name|write
argument_list|(
operator|new
name|byte
index|[]
block|{
operator|(
name|byte
operator|)
name|b
block|}
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|failed
operator|==
literal|false
condition|)
block|{
comment|/* since we are an outputstream a wrapper might get flushed on close after we threw an exception.                  * that might cause another exception from the other side of the recovery since we are in a bad state                  * due to a corrupted file stream etc. the biggest issue is that we will turn into a loop of exceptions                  * and we will always suppress the original one which might cause the recovery to retry over and over again.                  * To prevent this we try to not send chunks again after we failed once.*/
try|try
block|{
name|sendNextChunk
argument_list|(
name|position
argument_list|,
operator|new
name|BytesArray
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|,
name|md
operator|.
name|length
argument_list|()
operator|==
name|position
operator|+
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
assert|assert
name|md
operator|.
name|length
argument_list|()
operator|>=
name|position
operator|:
literal|"length: "
operator|+
name|md
operator|.
name|length
argument_list|()
operator|+
literal|" but positions was: "
operator|+
name|position
assert|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|failed
operator|=
literal|true
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
block|}
DECL|method|sendNextChunk
specifier|private
name|void
name|sendNextChunk
parameter_list|(
name|long
name|position
parameter_list|,
name|BytesArray
name|content
parameter_list|,
name|boolean
name|lastChunk
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|TransportRequestOptions
name|chunkSendOptions
init|=
name|TransportRequestOptions
operator|.
name|builder
argument_list|()
operator|.
name|withCompress
argument_list|(
literal|false
argument_list|)
operator|.
name|withType
argument_list|(
name|TransportRequestOptions
operator|.
name|Type
operator|.
name|RECOVERY
argument_list|)
operator|.
name|withTimeout
argument_list|(
name|recoverySettings
operator|.
name|internalActionTimeout
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
comment|// Pause using the rate limiter, if desired, to throttle the recovery
specifier|final
name|long
name|throttleTimeInNanos
decl_stmt|;
specifier|final
name|RateLimiter
name|rl
init|=
name|recoverySettings
operator|.
name|rateLimiter
argument_list|()
decl_stmt|;
if|if
condition|(
name|rl
operator|!=
literal|null
condition|)
block|{
name|long
name|bytes
init|=
name|bytesSinceLastPause
operator|.
name|addAndGet
argument_list|(
name|content
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
name|rl
operator|.
name|getMinPauseCheckBytes
argument_list|()
condition|)
block|{
comment|// Time to pause
name|bytesSinceLastPause
operator|.
name|addAndGet
argument_list|(
operator|-
name|bytes
argument_list|)
expr_stmt|;
try|try
block|{
name|throttleTimeInNanos
operator|=
name|rl
operator|.
name|pause
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
name|shard
operator|.
name|recoveryStats
argument_list|()
operator|.
name|addThrottleTime
argument_list|(
name|throttleTimeInNanos
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to pause recovery"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|throttleTimeInNanos
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|throttleTimeInNanos
operator|=
literal|0
expr_stmt|;
block|}
comment|// Actually send the file chunk to the target node, waiting for it to complete
name|transportService
operator|.
name|submitRequest
argument_list|(
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|FILE_CHUNK
argument_list|,
operator|new
name|RecoveryFileChunkRequest
argument_list|(
name|request
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|md
argument_list|,
name|position
argument_list|,
name|content
argument_list|,
name|lastChunk
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|,
comment|/* we send totalOperations with every request since we collect stats on the target and that way we can                                  * see how many translog ops we accumulate while copying files across the network. A future optimization                                  * would be in to restart file copy again (new deltas) if we have too many translog ops are piling up.                                  */
name|throttleTimeInNanos
argument_list|)
argument_list|,
name|chunkSendOptions
argument_list|,
name|EmptyTransportResponseHandler
operator|.
name|INSTANCE_SAME
argument_list|)
operator|.
name|txGet
argument_list|()
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// check if the shard got closed on us
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|sendFiles
name|void
name|sendFiles
parameter_list|(
name|Store
name|store
parameter_list|,
name|StoreFileMetaData
index|[]
name|files
parameter_list|,
name|Function
argument_list|<
name|StoreFileMetaData
argument_list|,
name|OutputStream
argument_list|>
name|outputStreamFactory
parameter_list|)
throws|throws
name|Throwable
block|{
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
name|Future
index|[]
name|runners
init|=
name|asyncSendFiles
argument_list|(
name|store
argument_list|,
name|files
argument_list|,
name|outputStreamFactory
argument_list|)
decl_stmt|;
name|IOException
name|corruptedEngine
init|=
literal|null
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Throwable
argument_list|>
name|exceptions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|runners
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|StoreFileMetaData
name|md
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
try|try
block|{
name|runners
index|[
name|i
index|]
operator|.
name|get
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|t
parameter_list|)
block|{
name|corruptedEngine
operator|=
name|handleExecutionException
argument_list|(
name|store
argument_list|,
name|corruptedEngine
argument_list|,
name|exceptions
argument_list|,
name|md
argument_list|,
name|t
operator|.
name|getCause
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|t
parameter_list|)
block|{
name|corruptedEngine
operator|=
name|handleExecutionException
argument_list|(
name|store
argument_list|,
name|corruptedEngine
argument_list|,
name|exceptions
argument_list|,
name|md
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|corruptedEngine
operator|!=
literal|null
condition|)
block|{
name|failEngine
argument_list|(
name|corruptedEngine
argument_list|)
expr_stmt|;
throw|throw
name|corruptedEngine
throw|;
block|}
else|else
block|{
name|ExceptionsHelper
operator|.
name|rethrowAndSuppress
argument_list|(
name|exceptions
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|handleExecutionException
specifier|private
name|IOException
name|handleExecutionException
parameter_list|(
name|Store
name|store
parameter_list|,
name|IOException
name|corruptedEngine
parameter_list|,
name|List
argument_list|<
name|Throwable
argument_list|>
name|exceptions
parameter_list|,
name|StoreFileMetaData
name|md
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Failed to transfer file ["
operator|+
name|md
operator|+
literal|"] on recovery"
argument_list|)
expr_stmt|;
specifier|final
name|IOException
name|corruptIndexException
decl_stmt|;
specifier|final
name|boolean
name|checkIntegrity
init|=
name|corruptedEngine
operator|==
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|corruptIndexException
operator|=
name|ExceptionsHelper
operator|.
name|unwrapCorruption
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|checkIntegrity
operator|&&
name|store
operator|.
name|checkIntegrityNoException
argument_list|(
name|md
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// we are corrupted on the primary -- fail!
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Corrupted file detected {} checksum mismatch"
argument_list|,
name|shardId
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|corruptedEngine
operator|=
name|corruptIndexException
expr_stmt|;
block|}
else|else
block|{
comment|// corruption has happened on the way to replica
name|RemoteTransportException
name|exception
init|=
operator|new
name|RemoteTransportException
argument_list|(
literal|"File corruption occurred on recovery but checksums are ok"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|exception
operator|.
name|addSuppressed
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkIntegrity
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Remote file corruption on node {}, recovering {}. local checksum OK"
argument_list|,
name|corruptIndexException
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Remote file corruption on node {}, recovering {}. local checksum are skipped"
argument_list|,
name|corruptIndexException
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
name|exceptions
operator|.
name|add
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|exceptions
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|corruptedEngine
return|;
block|}
DECL|method|failEngine
specifier|protected
name|void
name|failEngine
parameter_list|(
name|IOException
name|cause
parameter_list|)
block|{
name|shard
operator|.
name|failShard
argument_list|(
literal|"recovery"
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
DECL|method|asyncSendFiles
name|Future
argument_list|<
name|Void
argument_list|>
index|[]
name|asyncSendFiles
parameter_list|(
name|Store
name|store
parameter_list|,
name|StoreFileMetaData
index|[]
name|files
parameter_list|,
name|Function
argument_list|<
name|StoreFileMetaData
argument_list|,
name|OutputStream
argument_list|>
name|outputStreamFactory
parameter_list|)
block|{
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Future
argument_list|<
name|Void
argument_list|>
index|[]
name|futures
init|=
operator|new
name|Future
index|[
name|files
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoreFileMetaData
name|md
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
name|long
name|fileSize
init|=
name|md
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// Files are split into two categories, files that are "small"
comment|// (under 5mb) and other files. Small files are transferred
comment|// using a separate thread pool dedicated to small files.
comment|//
comment|// The idea behind this is that while we are transferring an
comment|// older, large index, a user may create a new index, but that
comment|// index will not be able to recover until the large index
comment|// finishes, by using two different thread pools we can allow
comment|// tiny files (like segments for a brand new index) to be
comment|// recovered while ongoing large segment recoveries are
comment|// happening. It also allows these pools to be configured
comment|// separately.
name|ThreadPoolExecutor
name|pool
decl_stmt|;
if|if
condition|(
name|fileSize
operator|>
name|RecoverySettings
operator|.
name|SMALL_FILE_CUTOFF_BYTES
condition|)
block|{
name|pool
operator|=
name|recoverySettings
operator|.
name|concurrentStreamPool
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pool
operator|=
name|recoverySettings
operator|.
name|concurrentSmallFileStreamPool
argument_list|()
expr_stmt|;
block|}
name|Future
argument_list|<
name|Void
argument_list|>
name|future
init|=
name|pool
operator|.
name|submit
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
init|(
specifier|final
name|OutputStream
name|outputStream
init|=
name|outputStreamFactory
operator|.
name|apply
argument_list|(
name|md
argument_list|)
init|;
name|final
name|IndexInput
name|indexInput
operator|=
name|store
operator|.
name|directory
argument_list|()
operator|.
name|openInput
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|,
name|IOContext
operator|.
name|READONCE
argument_list|)
init|)
block|{
name|Streams
operator|.
name|copy
argument_list|(
operator|new
name|InputStreamIndexInput
argument_list|(
name|indexInput
argument_list|,
name|md
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|outputStream
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
argument_list|)
decl_stmt|;
name|futures
index|[
name|i
index|]
operator|=
name|future
expr_stmt|;
block|}
return|return
name|futures
return|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

