begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.indices.recovery
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimiter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|StopWatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|Streams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|CancellableThreads
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|RecoveryEngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IllegalIndexShardStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|Translog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|RemoteTransportException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|BufferedOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|StreamSupport
import|;
end_import

begin_comment
comment|/**  * RecoverySourceHandler handles the three phases of shard recovery, which is  * everything relating to copying the segment files as well as sending translog  * operations across the wire once the segments have been copied.  *  * Note: There is always one source handler per recovery that handles all the  * file and translog transfer. This handler is completely isolated from other recoveries  * while the {@link RateLimiter} passed via {@link RecoverySettings} is shared across recoveries  * originating from this nodes to throttle the number bytes send during file transfer. The transaction log  * phase bypasses the rate limiter entirely.  */
end_comment

begin_class
DECL|class|RecoverySourceHandler
specifier|public
class|class
name|RecoverySourceHandler
block|{
DECL|field|logger
specifier|protected
specifier|final
name|ESLogger
name|logger
decl_stmt|;
comment|// Shard that is going to be recovered (the "source")
DECL|field|shard
specifier|private
specifier|final
name|IndexShard
name|shard
decl_stmt|;
DECL|field|indexName
specifier|private
specifier|final
name|String
name|indexName
decl_stmt|;
DECL|field|shardId
specifier|private
specifier|final
name|int
name|shardId
decl_stmt|;
comment|// Request containing source and target node information
DECL|field|request
specifier|private
specifier|final
name|StartRecoveryRequest
name|request
decl_stmt|;
DECL|field|chunkSizeInBytes
specifier|private
specifier|final
name|int
name|chunkSizeInBytes
decl_stmt|;
DECL|field|recoveryTarget
specifier|private
specifier|final
name|RecoveryTargetHandler
name|recoveryTarget
decl_stmt|;
DECL|field|response
specifier|protected
specifier|final
name|RecoveryResponse
name|response
decl_stmt|;
DECL|field|cancellableThreads
specifier|private
specifier|final
name|CancellableThreads
name|cancellableThreads
init|=
operator|new
name|CancellableThreads
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|onCancel
parameter_list|(
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|suppressedException
parameter_list|)
block|{
name|RuntimeException
name|e
decl_stmt|;
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// check if the shard got closed on us
name|e
operator|=
operator|new
name|IndexShardClosedException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"shard is closed and recovery was canceled reason ["
operator|+
name|reason
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
operator|new
name|ExecutionCancelledException
argument_list|(
literal|"recovery was canceled reason ["
operator|+
name|reason
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suppressedException
operator|!=
literal|null
condition|)
block|{
name|e
operator|.
name|addSuppressed
argument_list|(
name|suppressedException
argument_list|)
expr_stmt|;
block|}
throw|throw
name|e
throw|;
block|}
block|}
decl_stmt|;
DECL|method|RecoverySourceHandler
specifier|public
name|RecoverySourceHandler
parameter_list|(
specifier|final
name|IndexShard
name|shard
parameter_list|,
name|RecoveryTargetHandler
name|recoveryTarget
parameter_list|,
specifier|final
name|StartRecoveryRequest
name|request
parameter_list|,
specifier|final
name|int
name|fileChunkSizeInBytes
parameter_list|,
specifier|final
name|ESLogger
name|logger
parameter_list|)
block|{
name|this
operator|.
name|shard
operator|=
name|shard
expr_stmt|;
name|this
operator|.
name|recoveryTarget
operator|=
name|recoveryTarget
expr_stmt|;
name|this
operator|.
name|request
operator|=
name|request
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|indexName
operator|=
name|this
operator|.
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|getIndex
argument_list|()
operator|.
name|getName
argument_list|()
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|this
operator|.
name|request
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
expr_stmt|;
name|this
operator|.
name|chunkSizeInBytes
operator|=
name|fileChunkSizeInBytes
expr_stmt|;
name|this
operator|.
name|response
operator|=
operator|new
name|RecoveryResponse
argument_list|()
expr_stmt|;
block|}
comment|/**      * performs the recovery from the local engine to the target      */
DECL|method|recoverToTarget
specifier|public
name|RecoveryResponse
name|recoverToTarget
parameter_list|()
throws|throws
name|IOException
block|{
try|try
init|(
name|Translog
operator|.
name|View
name|translogView
init|=
name|shard
operator|.
name|acquireTranslogView
argument_list|()
init|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"captured translog id [{}] for recovery"
argument_list|,
name|translogView
operator|.
name|minTranslogGeneration
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|IndexCommit
name|phase1Snapshot
decl_stmt|;
try|try
block|{
name|phase1Snapshot
operator|=
name|shard
operator|.
name|snapshotIndex
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|translogView
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|RecoveryEngineException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|"Snapshot failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
try|try
block|{
name|phase1
argument_list|(
name|phase1Snapshot
argument_list|,
name|translogView
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RecoveryEngineException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|1
argument_list|,
literal|"phase1 failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
try|try
block|{
name|shard
operator|.
name|releaseSnapshot
argument_list|(
name|phase1Snapshot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"releasing snapshot caused exception"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"snapshot translog for recovery. current size is [{}]"
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|phase2
argument_list|(
name|translogView
operator|.
name|snapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RecoveryEngineException
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|2
argument_list|,
literal|"phase2 failed"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|finalizeRecovery
argument_list|()
expr_stmt|;
block|}
return|return
name|response
return|;
block|}
comment|/**      * Perform phase1 of the recovery operations. Once this {@link IndexCommit}      * snapshot has been performed no commit operations (files being fsync'd)      * are effectively allowed on this index until all recovery phases are done      *<p>      * Phase1 examines the segment files on the target node and copies over the      * segments that are missing. Only segments that have the same size and      * checksum can be reused      */
DECL|method|phase1
specifier|public
name|void
name|phase1
parameter_list|(
specifier|final
name|IndexCommit
name|snapshot
parameter_list|,
specifier|final
name|Translog
operator|.
name|View
name|translogView
parameter_list|)
block|{
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
comment|// Total size of segment files that are recovered
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
comment|// Total size of segment files that were able to be re-used
name|long
name|existingTotalSize
init|=
literal|0
decl_stmt|;
specifier|final
name|Store
name|store
init|=
name|shard
operator|.
name|store
argument_list|()
decl_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|recoverySourceMetadata
decl_stmt|;
try|try
block|{
name|recoverySourceMetadata
operator|=
name|store
operator|.
name|getMetadata
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|ex
parameter_list|)
block|{
name|shard
operator|.
name|failShard
argument_list|(
literal|"recovery"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
for|for
control|(
name|String
name|name
range|:
name|snapshot
operator|.
name|getFileNames
argument_list|()
control|)
block|{
specifier|final
name|StoreFileMetaData
name|md
init|=
name|recoverySourceMetadata
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Snapshot differs from actual index for file: {} meta: {}"
argument_list|,
name|name
argument_list|,
name|recoverySourceMetadata
operator|.
name|asMap
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|CorruptIndexException
argument_list|(
literal|"Snapshot differs from actual index - maybe index was removed metadata has "
operator|+
name|recoverySourceMetadata
operator|.
name|asMap
argument_list|()
operator|.
name|size
argument_list|()
operator|+
literal|" files"
argument_list|,
name|name
argument_list|)
throw|;
block|}
block|}
comment|// Generate a "diff" of all the identical, different, and missing
comment|// segment files on the target node, using the existing files on
comment|// the source node
name|String
name|recoverySourceSyncId
init|=
name|recoverySourceMetadata
operator|.
name|getSyncId
argument_list|()
decl_stmt|;
name|String
name|recoveryTargetSyncId
init|=
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|getSyncId
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|recoverWithSyncId
init|=
name|recoverySourceSyncId
operator|!=
literal|null
operator|&&
name|recoverySourceSyncId
operator|.
name|equals
argument_list|(
name|recoveryTargetSyncId
argument_list|)
decl_stmt|;
if|if
condition|(
name|recoverWithSyncId
condition|)
block|{
specifier|final
name|long
name|numDocsTarget
init|=
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|getNumDocs
argument_list|()
decl_stmt|;
specifier|final
name|long
name|numDocsSource
init|=
name|recoverySourceMetadata
operator|.
name|getNumDocs
argument_list|()
decl_stmt|;
if|if
condition|(
name|numDocsTarget
operator|!=
name|numDocsSource
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"try to recover "
operator|+
name|request
operator|.
name|shardId
argument_list|()
operator|+
literal|" from primary shard with sync id but number "
operator|+
literal|"of docs differ: "
operator|+
name|numDocsTarget
operator|+
literal|" ("
operator|+
name|request
operator|.
name|sourceNode
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|", primary) vs "
operator|+
name|numDocsSource
operator|+
literal|"("
operator|+
name|request
operator|.
name|targetNode
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
comment|// we shortcut recovery here because we have nothing to copy. but we must still start the engine on the target.
comment|// so we don't return here
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] skipping [phase1] to {} - identical sync id [{}] found on both source and target"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|recoverySourceSyncId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Store
operator|.
name|RecoveryDiff
name|diff
init|=
name|recoverySourceMetadata
operator|.
name|recoveryDiff
argument_list|(
name|request
operator|.
name|metadataSnapshot
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|diff
operator|.
name|identical
control|)
block|{
name|response
operator|.
name|phase1ExistingFileNames
operator|.
name|add
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase1ExistingFileSizes
operator|.
name|add
argument_list|(
name|md
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|existingTotalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: not recovering [{}], exists in local store and has checksum [{}],"
operator|+
literal|" size [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
operator|.
name|name
argument_list|()
argument_list|,
name|md
operator|.
name|checksum
argument_list|()
argument_list|,
name|md
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|totalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|List
argument_list|<
name|StoreFileMetaData
argument_list|>
name|phase1Files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|diff
operator|.
name|different
operator|.
name|size
argument_list|()
operator|+
name|diff
operator|.
name|missing
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|phase1Files
operator|.
name|addAll
argument_list|(
name|diff
operator|.
name|different
argument_list|)
expr_stmt|;
name|phase1Files
operator|.
name|addAll
argument_list|(
name|diff
operator|.
name|missing
argument_list|)
expr_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|phase1Files
control|)
block|{
if|if
condition|(
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|asMap
argument_list|()
operator|.
name|containsKey
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: recovering [{}], exists in local store, but is different: remote "
operator|+
literal|"[{}], local [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
operator|.
name|name
argument_list|()
argument_list|,
name|request
operator|.
name|metadataSnapshot
argument_list|()
operator|.
name|asMap
argument_list|()
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
name|md
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: recovering [{}], does not exists in remote"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|response
operator|.
name|phase1FileNames
operator|.
name|add
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase1FileSizes
operator|.
name|add
argument_list|(
name|md
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|totalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
name|response
operator|.
name|phase1TotalSize
operator|=
name|totalSize
expr_stmt|;
name|response
operator|.
name|phase1ExistingTotalSize
operator|=
name|existingTotalSize
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: recovering_files [{}] with total_size [{}], reusing_files [{}] with "
operator|+
literal|"total_size [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|response
operator|.
name|phase1FileNames
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|totalSize
argument_list|)
argument_list|,
name|response
operator|.
name|phase1ExistingFileNames
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|existingTotalSize
argument_list|)
argument_list|)
expr_stmt|;
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
name|recoveryTarget
operator|.
name|receiveFileInfo
argument_list|(
name|response
operator|.
name|phase1FileNames
argument_list|,
name|response
operator|.
name|phase1FileSizes
argument_list|,
name|response
operator|.
name|phase1ExistingFileNames
argument_list|,
name|response
operator|.
name|phase1ExistingFileSizes
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// How many bytes we've copied since we last called RateLimiter.pause
specifier|final
name|Function
argument_list|<
name|StoreFileMetaData
argument_list|,
name|OutputStream
argument_list|>
name|outputStreamFactories
init|=
name|md
lambda|->
operator|new
name|BufferedOutputStream
argument_list|(
operator|new
name|RecoveryOutputStream
argument_list|(
name|md
argument_list|,
name|translogView
argument_list|)
argument_list|,
name|chunkSizeInBytes
argument_list|)
decl_stmt|;
name|sendFiles
argument_list|(
name|store
argument_list|,
name|phase1Files
operator|.
name|toArray
argument_list|(
operator|new
name|StoreFileMetaData
index|[
name|phase1Files
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|outputStreamFactories
argument_list|)
expr_stmt|;
comment|// Send the CLEAN_FILES request, which takes all of the files that
comment|// were transferred and renames them from their temporary file
comment|// names to the actual file names. It also writes checksums for
comment|// the files after they have been renamed.
comment|//
comment|// Once the files have been renamed, any other files that are not
comment|// related to this recovery (out of date segments, for example)
comment|// are deleted
try|try
block|{
name|cancellableThreads
operator|.
name|executeIO
argument_list|(
parameter_list|()
lambda|->
name|recoveryTarget
operator|.
name|cleanFiles
argument_list|(
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|,
name|recoverySourceMetadata
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|RemoteTransportException
decl||
name|IOException
name|targetException
parameter_list|)
block|{
specifier|final
name|IOException
name|corruptIndexException
decl_stmt|;
comment|// we realized that after the index was copied and we wanted to finalize the recovery
comment|// the index was corrupted:
comment|//   - maybe due to a broken segments file on an empty index (transferred with no checksum)
comment|//   - maybe due to old segments without checksums or length only checks
if|if
condition|(
operator|(
name|corruptIndexException
operator|=
name|ExceptionsHelper
operator|.
name|unwrapCorruption
argument_list|(
name|targetException
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|recoverySourceMetadata1
init|=
name|store
operator|.
name|getMetadata
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|StoreFileMetaData
index|[]
name|metadata
init|=
name|StreamSupport
operator|.
name|stream
argument_list|(
name|recoverySourceMetadata1
operator|.
name|spliterator
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|toArray
argument_list|(
name|size
lambda|->
operator|new
name|StoreFileMetaData
index|[
name|size
index|]
argument_list|)
decl_stmt|;
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|metadata
argument_list|,
parameter_list|(
name|o1
parameter_list|,
name|o2
parameter_list|)
lambda|->
block|{
return|return
name|Long
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|length
argument_list|()
argument_list|,
name|o2
operator|.
name|length
argument_list|()
argument_list|)
return|;
comment|// check small files first
block|}
argument_list|)
expr_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|metadata
control|)
block|{
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"{} checking integrity for file {} after remove corruption exception"
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|checkIntegrityNoException
argument_list|(
name|md
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// we are corrupted on the primary -- fail!
name|shard
operator|.
name|failShard
argument_list|(
literal|"recovery"
argument_list|,
name|corruptIndexException
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Corrupted file detected {} checksum mismatch"
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|md
argument_list|)
expr_stmt|;
throw|throw
name|corruptIndexException
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|targetException
operator|.
name|addSuppressed
argument_list|(
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|targetException
throw|;
block|}
comment|// corruption has happened on the way to replica
name|RemoteTransportException
name|exception
init|=
operator|new
name|RemoteTransportException
argument_list|(
literal|"File corruption occurred on recovery but "
operator|+
literal|"checksums are ok"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|exception
operator|.
name|addSuppressed
argument_list|(
name|targetException
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Remote file corruption during finalization on node {}, recovering {}. local checksum OK"
argument_list|,
name|corruptIndexException
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
else|else
block|{
throw|throw
name|targetException
throw|;
block|}
block|}
block|}
name|prepareTargetForTranslog
argument_list|(
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] recovery [phase1] to {}: took [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase1Time
operator|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RecoverFilesRecoveryException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|response
operator|.
name|phase1FileNames
operator|.
name|size
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|totalSize
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|prepareTargetForTranslog
specifier|protected
name|void
name|prepareTargetForTranslog
parameter_list|(
specifier|final
name|int
name|totalTranslogOps
parameter_list|)
throws|throws
name|IOException
block|{
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase1] to {}: prepare remote engine for translog"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|long
name|startEngineStart
init|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
decl_stmt|;
comment|// Send a request preparing the new shard's translog to receive
comment|// operations. This ensures the shard engine is started and disables
comment|// garbage collection (not the JVM's GC!) of tombstone deletes
name|cancellableThreads
operator|.
name|executeIO
argument_list|(
parameter_list|()
lambda|->
name|recoveryTarget
operator|.
name|prepareForTranslogOperations
argument_list|(
name|totalTranslogOps
argument_list|)
argument_list|)
expr_stmt|;
name|stopWatch
operator|.
name|stop
argument_list|()
expr_stmt|;
name|response
operator|.
name|startTime
operator|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
operator|-
name|startEngineStart
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase1] to {}: remote engine start took [{}]"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Perform phase2 of the recovery process      *<p>      * Phase2 takes a snapshot of the current translog *without* acquiring the      * write lock (however, the translog snapshot is a point-in-time view of      * the translog). It then sends each translog operation to the target node      * so it can be replayed into the new shard.      */
DECL|method|phase2
specifier|public
name|void
name|phase2
parameter_list|(
name|Translog
operator|.
name|Snapshot
name|snapshot
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase2] to {}: sending transaction log operations"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
comment|// Send all the snapshot's translog operations to the target
name|int
name|totalOperations
init|=
name|sendSnapshot
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|stopWatch
operator|.
name|stop
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} recovery [phase2] to {}: took [{}]"
argument_list|,
name|request
operator|.
name|shardId
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
name|response
operator|.
name|phase2Time
operator|=
name|stopWatch
operator|.
name|totalTime
argument_list|()
operator|.
name|millis
argument_list|()
expr_stmt|;
name|response
operator|.
name|phase2Operations
operator|=
name|totalOperations
expr_stmt|;
block|}
comment|/**      * finalizes the recovery process      */
DECL|method|finalizeRecovery
specifier|public
name|void
name|finalizeRecovery
parameter_list|()
block|{
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
name|StopWatch
name|stopWatch
init|=
operator|new
name|StopWatch
argument_list|()
operator|.
name|start
argument_list|()
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] finalizing recovery to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
name|cancellableThreads
operator|.
name|execute
argument_list|(
name|recoveryTarget
operator|::
name|finalizeRecovery
argument_list|)
expr_stmt|;
if|if
condition|(
name|isPrimaryRelocation
argument_list|()
condition|)
block|{
comment|/**              * if the recovery process fails after setting the shard state to RELOCATED, both relocation source and              * target are failed (see {@link IndexShard#updateRoutingEntry}).              */
try|try
block|{
name|shard
operator|.
name|relocated
argument_list|(
literal|"to "
operator|+
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalIndexShardStateException
name|e
parameter_list|)
block|{
comment|// we can ignore this exception since, on the other node, when it moved to phase3
comment|// it will also send shard started, which might cause the index shard we work against
comment|// to move be closed by the time we get to the relocated method
block|}
block|}
name|stopWatch
operator|.
name|stop
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] finalizing recovery to {}: took [{}]"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|stopWatch
operator|.
name|totalTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|isPrimaryRelocation
specifier|protected
name|boolean
name|isPrimaryRelocation
parameter_list|()
block|{
return|return
name|request
operator|.
name|recoveryType
argument_list|()
operator|==
name|RecoveryState
operator|.
name|Type
operator|.
name|PRIMARY_RELOCATION
return|;
block|}
comment|/**      * Send the given snapshot's operations to this handler's target node.      *<p>      * Operations are bulked into a single request depending on an operation      * count limit or size-in-bytes limit      *      * @return the total number of translog operations that were sent      */
DECL|method|sendSnapshot
specifier|protected
name|int
name|sendSnapshot
parameter_list|(
specifier|final
name|Translog
operator|.
name|Snapshot
name|snapshot
parameter_list|)
block|{
name|int
name|ops
init|=
literal|0
decl_stmt|;
name|long
name|size
init|=
literal|0
decl_stmt|;
name|int
name|totalOperations
init|=
literal|0
decl_stmt|;
specifier|final
name|List
argument_list|<
name|Translog
operator|.
name|Operation
argument_list|>
name|operations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Translog
operator|.
name|Operation
name|operation
decl_stmt|;
try|try
block|{
name|operation
operator|=
name|snapshot
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// this ex should bubble up
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to get next operation from translog"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
if|if
condition|(
name|operation
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] no translog operations to send to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|operation
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
name|cancellableThreads
operator|.
name|checkForCancel
argument_list|()
expr_stmt|;
name|operations
operator|.
name|add
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|ops
operator|+=
literal|1
expr_stmt|;
name|size
operator|+=
name|operation
operator|.
name|estimateSize
argument_list|()
expr_stmt|;
name|totalOperations
operator|++
expr_stmt|;
comment|// Check if this request is past bytes threshold, and
comment|// if so, send it off
if|if
condition|(
name|size
operator|>=
name|chunkSizeInBytes
condition|)
block|{
comment|// don't throttle translog, since we lock for phase3 indexing,
comment|// so we need to move it as fast as possible. Note, since we
comment|// index docs to replicas while the index files are recovered
comment|// the lock can potentially be removed, in which case, it might
comment|// make sense to re-enable throttling in this phase
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
name|recoveryTarget
operator|.
name|indexTranslogOperations
argument_list|(
name|operations
argument_list|,
name|snapshot
operator|.
name|totalOperations
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] sent batch of [{}][{}] (total: [{}]) translog operations to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|ops
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|size
argument_list|)
argument_list|,
name|snapshot
operator|.
name|totalOperations
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|ops
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|operations
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
try|try
block|{
name|operation
operator|=
name|snapshot
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// this ex should bubble up
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to get next operation from translog"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|// send the leftover
if|if
condition|(
operator|!
name|operations
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cancellableThreads
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
name|recoveryTarget
operator|.
name|indexTranslogOperations
argument_list|(
name|operations
argument_list|,
name|snapshot
operator|.
name|totalOperations
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}][{}] sent final batch of [{}][{}] (total: [{}]) translog operations to {}"
argument_list|,
name|indexName
argument_list|,
name|shardId
argument_list|,
name|ops
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|size
argument_list|)
argument_list|,
name|snapshot
operator|.
name|totalOperations
argument_list|()
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|totalOperations
return|;
block|}
comment|/**      * Cancels the recovery and interrupts all eligible threads.      */
DECL|method|cancel
specifier|public
name|void
name|cancel
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|cancellableThreads
operator|.
name|cancel
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"ShardRecoveryHandler{"
operator|+
literal|"shardId="
operator|+
name|request
operator|.
name|shardId
argument_list|()
operator|+
literal|", sourceNode="
operator|+
name|request
operator|.
name|sourceNode
argument_list|()
operator|+
literal|", targetNode="
operator|+
name|request
operator|.
name|targetNode
argument_list|()
operator|+
literal|'}'
return|;
block|}
DECL|class|RecoveryOutputStream
specifier|final
class|class
name|RecoveryOutputStream
extends|extends
name|OutputStream
block|{
DECL|field|md
specifier|private
specifier|final
name|StoreFileMetaData
name|md
decl_stmt|;
DECL|field|translogView
specifier|private
specifier|final
name|Translog
operator|.
name|View
name|translogView
decl_stmt|;
DECL|field|position
specifier|private
name|long
name|position
init|=
literal|0
decl_stmt|;
DECL|method|RecoveryOutputStream
name|RecoveryOutputStream
parameter_list|(
name|StoreFileMetaData
name|md
parameter_list|,
name|Translog
operator|.
name|View
name|translogView
parameter_list|)
block|{
name|this
operator|.
name|md
operator|=
name|md
expr_stmt|;
name|this
operator|.
name|translogView
operator|=
name|translogView
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|int
name|b
parameter_list|)
throws|throws
name|IOException
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"we can't send single bytes over the wire"
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|write
specifier|public
specifier|final
name|void
name|write
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
throws|throws
name|IOException
block|{
name|sendNextChunk
argument_list|(
name|position
argument_list|,
operator|new
name|BytesArray
argument_list|(
name|b
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
argument_list|,
name|md
operator|.
name|length
argument_list|()
operator|==
name|position
operator|+
name|length
argument_list|)
expr_stmt|;
name|position
operator|+=
name|length
expr_stmt|;
assert|assert
name|md
operator|.
name|length
argument_list|()
operator|>=
name|position
operator|:
literal|"length: "
operator|+
name|md
operator|.
name|length
argument_list|()
operator|+
literal|" but positions was: "
operator|+
name|position
assert|;
block|}
DECL|method|sendNextChunk
specifier|private
name|void
name|sendNextChunk
parameter_list|(
name|long
name|position
parameter_list|,
name|BytesArray
name|content
parameter_list|,
name|boolean
name|lastChunk
parameter_list|)
throws|throws
name|IOException
block|{
comment|// Actually send the file chunk to the target node, waiting for it to complete
name|cancellableThreads
operator|.
name|executeIO
argument_list|(
parameter_list|()
lambda|->
name|recoveryTarget
operator|.
name|writeFileChunk
argument_list|(
name|md
argument_list|,
name|position
argument_list|,
name|content
argument_list|,
name|lastChunk
argument_list|,
name|translogView
operator|.
name|totalOperations
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// check if the shard got closed on us
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|request
operator|.
name|shardId
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|sendFiles
name|void
name|sendFiles
parameter_list|(
name|Store
name|store
parameter_list|,
name|StoreFileMetaData
index|[]
name|files
parameter_list|,
name|Function
argument_list|<
name|StoreFileMetaData
argument_list|,
name|OutputStream
argument_list|>
name|outputStreamFactory
parameter_list|)
throws|throws
name|Throwable
block|{
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
name|ArrayUtil
operator|.
name|timSort
argument_list|(
name|files
argument_list|,
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
lambda|->
name|Long
operator|.
name|compare
argument_list|(
name|a
operator|.
name|length
argument_list|()
argument_list|,
name|b
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// send smallest first
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|files
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|StoreFileMetaData
name|md
init|=
name|files
index|[
name|i
index|]
decl_stmt|;
try|try
init|(
specifier|final
name|IndexInput
name|indexInput
init|=
name|store
operator|.
name|directory
argument_list|()
operator|.
name|openInput
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|,
name|IOContext
operator|.
name|READONCE
argument_list|)
init|)
block|{
comment|// it's fine that we are only having the indexInput in the try/with block. The copy methods handles
comment|// exceptions during close correctly and doesn't hide the original exception.
name|Streams
operator|.
name|copy
argument_list|(
operator|new
name|InputStreamIndexInput
argument_list|(
name|indexInput
argument_list|,
name|md
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|outputStreamFactory
operator|.
name|apply
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
specifier|final
name|IOException
name|corruptIndexException
decl_stmt|;
if|if
condition|(
operator|(
name|corruptIndexException
operator|=
name|ExceptionsHelper
operator|.
name|unwrapCorruption
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|store
operator|.
name|checkIntegrityNoException
argument_list|(
name|md
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// we are corrupted on the primary -- fail!
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Corrupted file detected {} checksum mismatch"
argument_list|,
name|shardId
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|failEngine
argument_list|(
name|corruptIndexException
argument_list|)
expr_stmt|;
throw|throw
name|corruptIndexException
throw|;
block|}
else|else
block|{
comment|// corruption has happened on the way to replica
name|RemoteTransportException
name|exception
init|=
operator|new
name|RemoteTransportException
argument_list|(
literal|"File corruption occurred on recovery but "
operator|+
literal|"checksums are ok"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|exception
operator|.
name|addSuppressed
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Remote file corruption on node {}, recovering {}. local checksum OK"
argument_list|,
name|corruptIndexException
argument_list|,
name|shardId
argument_list|,
name|request
operator|.
name|targetNode
argument_list|()
argument_list|,
name|md
argument_list|)
expr_stmt|;
throw|throw
name|exception
throw|;
block|}
block|}
else|else
block|{
throw|throw
name|t
throw|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|failEngine
specifier|protected
name|void
name|failEngine
parameter_list|(
name|IOException
name|cause
parameter_list|)
block|{
name|shard
operator|.
name|failShard
argument_list|(
literal|"recovery"
argument_list|,
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

