begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.indices.cluster
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|cluster
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntHashSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectCursor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|NodeIndexDeletedAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|NodeMappingRefreshAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|shard
operator|.
name|NoOpShardStateActionListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|shard
operator|.
name|ShardStateAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MappingMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|IndexRoutingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|IndexShardRoutingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RestoreSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|CompressedXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|Callback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexShardAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|NodeServicesProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|DocumentMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|flush
operator|.
name|SyncedFlushService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|memory
operator|.
name|IndexingMemoryController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoverySource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryTarget
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoriesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|SearchService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|RestoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|IndicesClusterStateService
specifier|public
class|class
name|IndicesClusterStateService
extends|extends
name|AbstractLifecycleComponent
argument_list|<
name|IndicesClusterStateService
argument_list|>
implements|implements
name|ClusterStateListener
block|{
DECL|field|indicesService
specifier|private
specifier|final
name|IndicesService
name|indicesService
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|recoveryTarget
specifier|private
specifier|final
name|RecoveryTarget
name|recoveryTarget
decl_stmt|;
DECL|field|shardStateAction
specifier|private
specifier|final
name|ShardStateAction
name|shardStateAction
decl_stmt|;
DECL|field|nodeIndexDeletedAction
specifier|private
specifier|final
name|NodeIndexDeletedAction
name|nodeIndexDeletedAction
decl_stmt|;
DECL|field|nodeMappingRefreshAction
specifier|private
specifier|final
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
decl_stmt|;
DECL|field|nodeServicesProvider
specifier|private
specifier|final
name|NodeServicesProvider
name|nodeServicesProvider
decl_stmt|;
DECL|field|SHARD_STATE_ACTION_LISTENER
specifier|private
specifier|static
specifier|final
name|ShardStateAction
operator|.
name|Listener
name|SHARD_STATE_ACTION_LISTENER
init|=
operator|new
name|NoOpShardStateActionListener
argument_list|()
decl_stmt|;
comment|// a map of mappings type we have seen per index due to cluster state
comment|// we need this so we won't remove types automatically created as part of the indexing process
DECL|field|seenMappings
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Boolean
argument_list|>
name|seenMappings
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
comment|// a list of shards that failed during recovery
comment|// we keep track of these shards in order to prevent repeated recovery of these shards on each cluster state update
DECL|field|failedShards
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ShardId
argument_list|,
name|FailedShard
argument_list|>
name|failedShards
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|field|restoreService
specifier|private
specifier|final
name|RestoreService
name|restoreService
decl_stmt|;
DECL|field|repositoriesService
specifier|private
specifier|final
name|RepositoriesService
name|repositoriesService
decl_stmt|;
DECL|class|FailedShard
specifier|static
class|class
name|FailedShard
block|{
DECL|field|version
specifier|public
specifier|final
name|long
name|version
decl_stmt|;
DECL|field|timestamp
specifier|public
specifier|final
name|long
name|timestamp
decl_stmt|;
DECL|method|FailedShard
name|FailedShard
parameter_list|(
name|long
name|version
parameter_list|)
block|{
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|failedShardHandler
specifier|private
specifier|final
name|FailedShardHandler
name|failedShardHandler
init|=
operator|new
name|FailedShardHandler
argument_list|()
decl_stmt|;
DECL|field|sendRefreshMapping
specifier|private
specifier|final
name|boolean
name|sendRefreshMapping
decl_stmt|;
DECL|field|buildInIndexListener
specifier|private
specifier|final
name|List
argument_list|<
name|IndexEventListener
argument_list|>
name|buildInIndexListener
decl_stmt|;
annotation|@
name|Inject
DECL|method|IndicesClusterStateService
specifier|public
name|IndicesClusterStateService
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|RecoveryTarget
name|recoveryTarget
parameter_list|,
name|ShardStateAction
name|shardStateAction
parameter_list|,
name|NodeIndexDeletedAction
name|nodeIndexDeletedAction
parameter_list|,
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
parameter_list|,
name|RepositoriesService
name|repositoriesService
parameter_list|,
name|RestoreService
name|restoreService
parameter_list|,
name|SearchService
name|searchService
parameter_list|,
name|SyncedFlushService
name|syncedFlushService
parameter_list|,
name|RecoverySource
name|recoverySource
parameter_list|,
name|NodeServicesProvider
name|nodeServicesProvider
parameter_list|,
name|IndexingMemoryController
name|indexingMemoryController
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|buildInIndexListener
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|recoverySource
argument_list|,
name|recoveryTarget
argument_list|,
name|searchService
argument_list|,
name|syncedFlushService
argument_list|,
name|indexingMemoryController
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|recoveryTarget
operator|=
name|recoveryTarget
expr_stmt|;
name|this
operator|.
name|shardStateAction
operator|=
name|shardStateAction
expr_stmt|;
name|this
operator|.
name|nodeIndexDeletedAction
operator|=
name|nodeIndexDeletedAction
expr_stmt|;
name|this
operator|.
name|nodeMappingRefreshAction
operator|=
name|nodeMappingRefreshAction
expr_stmt|;
name|this
operator|.
name|restoreService
operator|=
name|restoreService
expr_stmt|;
name|this
operator|.
name|repositoriesService
operator|=
name|repositoriesService
expr_stmt|;
name|this
operator|.
name|sendRefreshMapping
operator|=
name|this
operator|.
name|settings
operator|.
name|getAsBoolean
argument_list|(
literal|"indices.cluster.send_refresh_mapping"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeServicesProvider
operator|=
name|nodeServicesProvider
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|clusterService
operator|.
name|addFirst
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|clusterService
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|clusterChanged
specifier|public
name|void
name|clusterChanged
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|changesAllowed
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|lifecycle
operator|.
name|started
argument_list|()
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|mutex
init|)
block|{
comment|// we need to clean the shards and indices we have on this node, since we
comment|// are going to recover them again once state persistence is disabled (no master / not recovered)
comment|// TODO: this feels a bit hacky here, a block disables state persistence, and then we clean the allocated shards, maybe another flag in blocks?
if|if
condition|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
condition|)
block|{
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|shardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (disabled block persistence)"
argument_list|,
name|index
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
argument_list|,
literal|"removing shard (disabled block persistence)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to remove shard (disabled block persistence)"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"cleaning index (disabled block persistence)"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|cleanFailedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyDeletedIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyNewIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyMappings
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyNewOrUpdatedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyDeletedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyCleanedIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applySettings
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyCleanedIndices
specifier|private
name|void
name|applyCleanedIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// handle closed indices, since they are not allocated on a node once they are closed
comment|// so applyDeletedIndices might not take them into account
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|!=
literal|null
operator|&&
name|indexMetaData
operator|.
name|getState
argument_list|()
operator|==
name|IndexMetaData
operator|.
name|State
operator|.
name|CLOSE
condition|)
block|{
for|for
control|(
name|Integer
name|shardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (index is closed)"
argument_list|,
name|index
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
argument_list|,
literal|"removing shard (index is closed)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to remove shard (index is closed)"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexService
operator|.
name|shardIds
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] cleaning index (no shards allocated)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// clean the index
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"removing index (no shards allocated)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyDeletedIndices
specifier|private
name|void
name|applyDeletedIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
specifier|final
name|ClusterState
name|previousState
init|=
name|event
operator|.
name|previousState
argument_list|()
decl_stmt|;
specifier|final
name|String
name|localNodeId
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
decl_stmt|;
assert|assert
name|localNodeId
operator|!=
literal|null
assert|;
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|indexMetaData
operator|.
name|isSameUUID
argument_list|(
name|indexService
operator|.
name|indexUUID
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] mismatch on index UUIDs between cluster state and local state, cleaning the index so it will be recreated"
argument_list|,
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
name|deleteIndex
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|,
literal|"mismatch on index UUIDs between cluster state and local state, cleaning the index so it will be recreated"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|index
range|:
name|event
operator|.
name|indicesDeleted
argument_list|()
control|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] cleaning index, no longer part of the metadata"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IndexService
name|idxService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|IndexSettings
name|indexSettings
decl_stmt|;
if|if
condition|(
name|idxService
operator|!=
literal|null
condition|)
block|{
name|indexSettings
operator|=
name|idxService
operator|.
name|getIndexSettings
argument_list|()
expr_stmt|;
name|deleteIndex
argument_list|(
name|index
argument_list|,
literal|"index no longer part of the metadata"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|IndexMetaData
name|metaData
init|=
name|previousState
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
assert|assert
name|metaData
operator|!=
literal|null
assert|;
name|indexSettings
operator|=
operator|new
name|IndexSettings
argument_list|(
name|metaData
argument_list|,
name|settings
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|)
expr_stmt|;
name|indicesService
operator|.
name|deleteClosedIndex
argument_list|(
literal|"closed index no longer part of the metadata"
argument_list|,
name|metaData
argument_list|,
name|event
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|nodeIndexDeletedAction
operator|.
name|nodeIndexDeleted
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
name|index
argument_list|,
name|indexSettings
argument_list|,
name|localNodeId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to send to master index {} deleted event"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyDeletedShards
specifier|private
name|void
name|applyDeletedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|IntHashSet
name|newShardIds
init|=
operator|new
name|IntHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
decl_stmt|;
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// now, go over and delete shards that needs to get deleted
name|newShardIds
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|index
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|newShardIds
operator|.
name|add
argument_list|(
name|shard
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Integer
name|existingShardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|newShardIds
operator|.
name|contains
argument_list|(
name|existingShardId
argument_list|)
condition|)
block|{
if|if
condition|(
name|indexMetaData
operator|.
name|getState
argument_list|()
operator|==
name|IndexMetaData
operator|.
name|State
operator|.
name|CLOSE
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (index is closed)"
argument_list|,
name|index
argument_list|,
name|existingShardId
argument_list|)
expr_stmt|;
block|}
name|indexService
operator|.
name|removeShard
argument_list|(
name|existingShardId
argument_list|,
literal|"removing shard (index is closed)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we can just remove the shard, without cleaning it locally, since we will clean it
comment|// when all shards are allocated in the IndicesStore
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (not allocated)"
argument_list|,
name|index
argument_list|,
name|existingShardId
argument_list|)
expr_stmt|;
block|}
name|indexService
operator|.
name|removeShard
argument_list|(
name|existingShardId
argument_list|,
literal|"removing shard (not allocated)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|applyNewIndices
specifier|private
name|void
name|applyNewIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// we only create indices for shards that are allocated
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNode
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] creating index"
argument_list|,
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|indicesService
operator|.
name|createIndex
argument_list|(
name|nodeServicesProvider
argument_list|,
name|indexMetaData
argument_list|,
name|buildInIndexListener
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|sendFailShard
argument_list|(
name|shard
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
literal|"failed to create index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|applySettings
specifier|private
name|void
name|applySettings
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|metaDataChanged
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|)
block|{
comment|// we only create / update here
continue|continue;
block|}
comment|// if the index meta data didn't change, no need check for refreshed settings
if|if
condition|(
operator|!
name|event
operator|.
name|indexMetaDataChanged
argument_list|(
name|indexMetaData
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|index
init|=
name|indexMetaData
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// already deleted on us, ignore it
continue|continue;
block|}
name|indexService
operator|.
name|updateMetaData
argument_list|(
name|indexMetaData
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyMappings
specifier|private
name|void
name|applyMappings
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// go over and update mappings
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|)
block|{
comment|// we only create / update here
continue|continue;
block|}
name|boolean
name|requireRefresh
init|=
literal|false
decl_stmt|;
name|String
name|index
init|=
name|indexMetaData
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// got deleted on us, ignore (closing the node)
return|return;
block|}
try|try
block|{
name|MapperService
name|mapperService
init|=
name|indexService
operator|.
name|mapperService
argument_list|()
decl_stmt|;
comment|// go over and add the relevant mappings (or update them)
for|for
control|(
name|ObjectCursor
argument_list|<
name|MappingMetaData
argument_list|>
name|cursor
range|:
name|indexMetaData
operator|.
name|getMappings
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|MappingMetaData
name|mappingMd
init|=
name|cursor
operator|.
name|value
decl_stmt|;
name|String
name|mappingType
init|=
name|mappingMd
operator|.
name|type
argument_list|()
decl_stmt|;
name|CompressedXContent
name|mappingSource
init|=
name|mappingMd
operator|.
name|source
argument_list|()
decl_stmt|;
name|requireRefresh
operator||=
name|processMapping
argument_list|(
name|index
argument_list|,
name|mapperService
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requireRefresh
operator|&&
name|sendRefreshMapping
condition|)
block|{
name|nodeMappingRefreshAction
operator|.
name|nodeMappingRefresh
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
operator|new
name|NodeMappingRefreshAction
operator|.
name|NodeMappingRefreshRequest
argument_list|(
name|index
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// if we failed the mappings anywhere, we need to fail the shards for this index, note, we safeguard
comment|// by creating the processing the mappings on the master, or on the node the mapping was introduced on,
comment|// so this failure typically means wrong node level configuration or something similar
for|for
control|(
name|IndexShard
name|indexShard
range|:
name|indexService
control|)
block|{
name|ShardRouting
name|shardRouting
init|=
name|indexShard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
operator|.
name|indexUUID
argument_list|()
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"failed to update mappings"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|processMapping
specifier|private
name|boolean
name|processMapping
parameter_list|(
name|String
name|index
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|String
name|mappingType
parameter_list|,
name|CompressedXContent
name|mappingSource
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// refresh mapping can happen when the parsing/merging of the mapping from the metadata doesn't result in the same
comment|// mapping, in this case, we send to the master to refresh its own version of the mappings (to conform with the
comment|// merge version of it, which it does when refreshing the mappings), and warn log it.
name|boolean
name|requiresRefresh
init|=
literal|false
decl_stmt|;
try|try
block|{
name|DocumentMapper
name|existingMapper
init|=
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingMapper
operator|==
literal|null
operator|||
name|mappingSource
operator|.
name|equals
argument_list|(
name|existingMapper
operator|.
name|mappingSource
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|String
name|op
init|=
name|existingMapper
operator|==
literal|null
condition|?
literal|"adding"
else|:
literal|"updating"
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|mappingSource
operator|.
name|compressed
argument_list|()
operator|.
name|length
operator|<
literal|512
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] {} mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|op
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] {} mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|op
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)"
argument_list|,
name|index
argument_list|,
name|op
argument_list|,
name|mappingType
argument_list|)
expr_stmt|;
block|}
comment|// we don't apply default, since it has been applied when the mappings were parsed initially
name|mapperService
operator|.
name|merge
argument_list|(
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
operator|.
name|equals
argument_list|(
name|mappingSource
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
argument_list|)
expr_stmt|;
name|requiresRefresh
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to add mapping [{}], source [{}]"
argument_list|,
name|e
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|requiresRefresh
return|;
block|}
DECL|method|applyNewOrUpdatedShards
specifier|private
name|void
name|applyNewOrUpdatedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|changesAllowed
argument_list|()
condition|)
block|{
return|return;
block|}
name|RoutingTable
name|routingTable
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|routingTable
argument_list|()
decl_stmt|;
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
name|failedShards
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|DiscoveryNodes
name|nodes
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ShardRouting
name|shardRouting
range|:
name|routingNode
control|)
block|{
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// got deleted on us, ignore
continue|continue;
block|}
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|==
literal|null
condition|)
block|{
comment|// the index got deleted on the metadata, we will clean it later in the apply deleted method call
continue|continue;
block|}
specifier|final
name|int
name|shardId
init|=
name|shardRouting
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
operator|&&
name|shardRouting
operator|.
name|started
argument_list|()
condition|)
block|{
if|if
condition|(
name|failedShards
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|masterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|resendShardFailed
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|" marked shard as started, but shard has previous failed. resending shard failure."
argument_list|,
literal|null
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the master thinks we are started, but we don't have this shard at all, mark it as failed
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
literal|"master ["
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|"] marked shard as started, but shard has not been created, mark shard as failed"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|!=
literal|null
condition|)
block|{
name|ShardRouting
name|currentRoutingEntry
init|=
name|indexShard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
comment|// if the current and global routing are initializing, but are still not the same, its a different "shard" being allocated
comment|// for example: a shard that recovers from one node and now needs to recover to another node,
comment|//              or a replica allocated and then allocating a primary because the primary failed on another node
name|boolean
name|shardHasBeenRemoved
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|currentRoutingEntry
operator|.
name|isSameAllocation
argument_list|(
name|shardRouting
argument_list|)
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
name|currentRoutingEntry
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
comment|// closing the shard will also cancel any ongoing recovery.
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (different instance of it allocated on this node)"
argument_list|)
expr_stmt|;
name|shardHasBeenRemoved
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPeerRecovery
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
specifier|final
name|DiscoveryNode
name|sourceNode
init|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|shardRouting
argument_list|)
decl_stmt|;
comment|// check if there is an existing recovery going, and if so, and the source node is not the same, cancel the recovery to restart it
if|if
condition|(
name|recoveryTarget
operator|.
name|cancelRecoveriesForShard
argument_list|(
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"recovery source node changed"
argument_list|,
name|status
lambda|->
operator|!
name|status
operator|.
name|sourceNode
argument_list|()
operator|.
name|equals
argument_list|(
name|sourceNode
argument_list|)
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (recovery source changed), current [{}], global [{}])"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
name|currentRoutingEntry
argument_list|,
name|shardRouting
argument_list|)
block|;
comment|// closing the shard will also cancel any ongoing recovery.
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (recovery source node changed)"
argument_list|)
empty_stmt|;
name|shardHasBeenRemoved
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shardHasBeenRemoved
operator|==
literal|false
condition|)
block|{
comment|// shadow replicas do not support primary promotion. The master would reinitialize the shard, giving it a new allocation, meaning we should be there.
assert|assert
operator|(
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|currentRoutingEntry
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|)
operator|==
literal|false
operator|||
name|indexShard
operator|.
name|allowsPrimaryPromotion
argument_list|()
operator|:
literal|"shard for doesn't support primary promotion but master promoted it with changing allocation. New routing "
operator|+
name|shardRouting
operator|+
literal|", current routing "
operator|+
name|currentRoutingEntry
assert|;
name|indexShard
operator|.
name|updateRoutingEntry
argument_list|(
name|shardRouting
argument_list|,
name|event
operator|.
name|state
argument_list|()
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
operator|==
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shardRouting
operator|.
name|initializing
argument_list|()
condition|)
block|{
name|applyInitializingShard
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
name|indexMetaData
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_function
DECL|method|cleanFailedShards
specifier|private
name|void
name|cleanFailedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|RoutingTable
name|routingTable
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|routingTable
argument_list|()
decl_stmt|;
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
name|failedShards
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|DiscoveryNodes
name|nodes
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|String
name|localNodeId
init|=
name|nodes
operator|.
name|localNodeId
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|FailedShard
argument_list|>
argument_list|>
name|iterator
init|=
name|failedShards
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|shards
label|:
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|FailedShard
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|FailedShard
name|failedShard
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|IndexRoutingTable
name|indexRoutingTable
init|=
name|routingTable
operator|.
name|index
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexRoutingTable
operator|!=
literal|null
condition|)
block|{
name|IndexShardRoutingTable
name|shardRoutingTable
init|=
name|indexRoutingTable
operator|.
name|shard
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardRoutingTable
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|shardRoutingTable
operator|.
name|assignedShards
argument_list|()
control|)
block|{
if|if
condition|(
name|localNodeId
operator|.
name|equals
argument_list|(
name|shardRouting
operator|.
name|currentNodeId
argument_list|()
argument_list|)
condition|)
block|{
comment|// we have a timeout here just to make sure we don't have dangled failed shards for some reason
comment|// its just another safely layer
if|if
condition|(
name|shardRouting
operator|.
name|version
argument_list|()
operator|==
name|failedShard
operator|.
name|version
operator|&&
operator|(
operator|(
name|now
operator|-
name|failedShard
operator|.
name|timestamp
operator|)
operator|<
name|TimeValue
operator|.
name|timeValueMinutes
argument_list|(
literal|60
argument_list|)
operator|.
name|millis
argument_list|()
operator|)
condition|)
block|{
comment|// It's the same failed shard - keep it if it hasn't timed out
continue|continue
name|shards
continue|;
block|}
else|else
block|{
comment|// Different version or expired, remove it
break|break;
block|}
block|}
block|}
block|}
block|}
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|applyInitializingShard
specifier|private
name|void
name|applyInitializingShard
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|,
specifier|final
name|IndexMetaData
name|indexMetaData
parameter_list|,
specifier|final
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// got deleted on us, ignore
return|return;
block|}
specifier|final
name|RoutingTable
name|routingTable
init|=
name|state
operator|.
name|routingTable
argument_list|()
decl_stmt|;
specifier|final
name|DiscoveryNodes
name|nodes
init|=
name|state
operator|.
name|getNodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|shardId
init|=
name|shardRouting
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|getShard
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
comment|// the master thinks we are initializing, but we are already started or on POST_RECOVERY and waiting
comment|// for master to confirm a shard started message (either master failover, or a cluster event before
comment|// we managed to tell the master we started), mark us as started
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"{} master marked shard as initializing, but shard has state [{}], resending shard started to {}"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nodes
operator|.
name|masterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|" marked shard as initializing, but shard state is ["
operator|+
name|indexShard
operator|.
name|state
argument_list|()
operator|+
literal|"], mark shard as started"
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
if|if
condition|(
name|indexShard
operator|.
name|ignoreRecoveryAttempt
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring recovery instruction for an existing shard {} (shard state: [{}])"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// if we're in peer recovery, try to find out the source node now so in case it fails, we will not create the index shard
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isPeerRecovery
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
name|sourceNode
operator|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring initializing shard {} - no source node can be found."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// if there is no shard, create it
if|if
condition|(
operator|!
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
if|if
condition|(
name|failedShards
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|masterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|resendShardFailed
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|" marked shard as initializing, but shard is marked as failed, resend shard failure"
argument_list|,
literal|null
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] creating shard"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|createShard
argument_list|(
name|shardRouting
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|addShardFailureCallback
argument_list|(
name|failedShardHandler
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexShardAlreadyExistsException
name|e
parameter_list|)
block|{
comment|// ignore this, the method call can happen several times
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
operator|.
name|indexUUID
argument_list|()
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"failed to create shard"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
specifier|final
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|getShard
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|.
name|ignoreRecoveryAttempt
argument_list|()
condition|)
block|{
comment|// we are already recovering (we can get to this state since the cluster event can happen several
comment|// times while we recover)
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring recovery instruction for shard {} (shard state: [{}])"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|RestoreSource
name|restoreSource
init|=
name|shardRouting
operator|.
name|restoreSource
argument_list|()
decl_stmt|;
if|if
condition|(
name|isPeerRecovery
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
try|try
block|{
assert|assert
name|sourceNode
operator|!=
literal|null
operator|:
literal|"peer recovery started but sourceNode is null"
assert|;
comment|// we don't mark this one as relocated at the end.
comment|// For primaries: requests in any case are routed to both when its relocating and that way we handle
comment|//    the edge case where its mark as relocated, and we might need to roll it back...
comment|// For replicas: we are recovering a backup from a primary
name|RecoveryState
operator|.
name|Type
name|type
init|=
name|shardRouting
operator|.
name|primary
argument_list|()
condition|?
name|RecoveryState
operator|.
name|Type
operator|.
name|RELOCATION
else|:
name|RecoveryState
operator|.
name|Type
operator|.
name|REPLICA
decl_stmt|;
name|RecoveryState
name|recoveryState
init|=
operator|new
name|RecoveryState
argument_list|(
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|type
argument_list|,
name|sourceNode
argument_list|,
name|nodes
operator|.
name|localNode
argument_list|()
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|markAsRecovering
argument_list|(
literal|"from "
operator|+
name|sourceNode
argument_list|,
name|recoveryState
argument_list|)
expr_stmt|;
name|recoveryTarget
operator|.
name|startRecovery
argument_list|(
name|indexShard
argument_list|,
name|type
argument_list|,
name|sourceNode
argument_list|,
operator|new
name|PeerRecoveryListener
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
name|indexMetaData
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|indexShard
operator|.
name|failShard
argument_list|(
literal|"corrupted preexisting index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
literal|true
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|restoreSource
operator|==
literal|null
condition|)
block|{
assert|assert
name|indexShard
operator|.
name|routingEntry
argument_list|()
operator|.
name|equals
argument_list|(
name|shardRouting
argument_list|)
assert|;
comment|// should have already be done before
comment|// recover from filesystem store
specifier|final
name|RecoveryState
name|recoveryState
init|=
operator|new
name|RecoveryState
argument_list|(
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|RecoveryState
operator|.
name|Type
operator|.
name|STORE
argument_list|,
name|nodes
operator|.
name|localNode
argument_list|()
argument_list|,
name|nodes
operator|.
name|localNode
argument_list|()
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|markAsRecovering
argument_list|(
literal|"from store"
argument_list|,
name|recoveryState
argument_list|)
expr_stmt|;
comment|// mark the shard as recovering on the cluster state thread
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
if|if
condition|(
name|indexShard
operator|.
name|recoverFromStore
argument_list|(
name|nodes
operator|.
name|localNode
argument_list|()
argument_list|)
condition|)
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
literal|"after recovery from store"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
literal|true
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// recover from a restore
specifier|final
name|RecoveryState
name|recoveryState
init|=
operator|new
name|RecoveryState
argument_list|(
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|RecoveryState
operator|.
name|Type
operator|.
name|SNAPSHOT
argument_list|,
name|shardRouting
operator|.
name|restoreSource
argument_list|()
argument_list|,
name|nodes
operator|.
name|localNode
argument_list|()
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|markAsRecovering
argument_list|(
literal|"from snapshot"
argument_list|,
name|recoveryState
argument_list|)
expr_stmt|;
comment|// mark the shard as recovering on the cluster state thread
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
specifier|final
name|ShardId
name|sId
init|=
name|indexShard
operator|.
name|shardId
argument_list|()
decl_stmt|;
try|try
block|{
specifier|final
name|IndexShardRepository
name|indexShardRepository
init|=
name|repositoriesService
operator|.
name|indexShardRepository
argument_list|(
name|restoreSource
operator|.
name|snapshotId
argument_list|()
operator|.
name|getRepository
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|.
name|restoreFromRepository
argument_list|(
name|indexShardRepository
argument_list|,
name|nodes
operator|.
name|localNode
argument_list|()
argument_list|)
condition|)
block|{
name|restoreService
operator|.
name|indexShardRestoreCompleted
argument_list|(
name|restoreSource
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|sId
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
literal|"after recovery from repository"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|first
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|Lucene
operator|.
name|isCorruptionException
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|restoreService
operator|.
name|failRestore
argument_list|(
name|restoreSource
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|sId
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|second
parameter_list|)
block|{
name|first
operator|.
name|addSuppressed
argument_list|(
name|second
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
literal|true
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**      * Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard      * routing to *require* peer recovery, use {@link #isPeerRecovery(org.elasticsearch.cluster.routing.ShardRouting)} to      * check if its needed or not.      */
end_comment

begin_function
DECL|method|findSourceNodeForPeerRecovery
specifier|private
name|DiscoveryNode
name|findSourceNodeForPeerRecovery
parameter_list|(
name|RoutingTable
name|routingTable
parameter_list|,
name|DiscoveryNodes
name|nodes
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|IndexShardRoutingTable
name|shardRoutingTable
init|=
name|routingTable
operator|.
name|index
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|shard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ShardRouting
name|entry
range|:
name|shardRoutingTable
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|primary
argument_list|()
operator|&&
name|entry
operator|.
name|active
argument_list|()
condition|)
block|{
comment|// only recover from started primary, if we can't find one, we will do it next round
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|entry
operator|.
name|currentNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node because primary shard {} is assigned to an unknown node."
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node for {} because a primary shard can not be found."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find relocation source node for shard {} because it is assigned to an unknown node [{}]."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"trying to find source node for peer recovery when routing state means no peer recovery: "
operator|+
name|shardRouting
argument_list|)
throw|;
block|}
return|return
name|sourceNode
return|;
block|}
end_function

begin_function
DECL|method|isPeerRecovery
specifier|private
name|boolean
name|isPeerRecovery
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
return|return
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
operator|||
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
return|;
block|}
end_function

begin_class
DECL|class|PeerRecoveryListener
specifier|private
class|class
name|PeerRecoveryListener
implements|implements
name|RecoveryTarget
operator|.
name|RecoveryListener
block|{
DECL|field|shardRouting
specifier|private
specifier|final
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|field|indexService
specifier|private
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|field|indexMetaData
specifier|private
specifier|final
name|IndexMetaData
name|indexMetaData
decl_stmt|;
DECL|method|PeerRecoveryListener
specifier|private
name|PeerRecoveryListener
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|IndexService
name|indexService
parameter_list|,
name|IndexMetaData
name|indexMetaData
parameter_list|)
block|{
name|this
operator|.
name|shardRouting
operator|=
name|shardRouting
expr_stmt|;
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
name|this
operator|.
name|indexMetaData
operator|=
name|indexMetaData
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onRecoveryDone
specifier|public
name|void
name|onRecoveryDone
parameter_list|(
name|RecoveryState
name|state
parameter_list|)
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
literal|"after recovery (replica) from node ["
operator|+
name|state
operator|.
name|getSourceNode
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onRecoveryFailure
specifier|public
name|void
name|onRecoveryFailure
parameter_list|(
name|RecoveryState
name|state
parameter_list|,
name|RecoveryFailedException
name|e
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|)
block|{
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
name|sendShardFailure
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_class

begin_function
DECL|method|handleRecoveryFailure
specifier|private
name|void
name|handleRecoveryFailure
parameter_list|(
name|IndexService
name|indexService
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
operator|.
name|indexUUID
argument_list|()
argument_list|,
name|indexService
argument_list|,
name|sendShardFailure
argument_list|,
literal|"failed recovery"
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|removeIndex
specifier|private
name|void
name|removeIndex
parameter_list|(
name|String
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
try|try
block|{
name|indicesService
operator|.
name|removeIndex
argument_list|(
name|index
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to clean index ({})"
argument_list|,
name|e
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|deleteIndex
specifier|private
name|void
name|deleteIndex
parameter_list|(
name|String
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
try|try
block|{
name|indicesService
operator|.
name|deleteIndex
argument_list|(
name|index
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to delete index ({})"
argument_list|,
name|e
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|failAndRemoveShard
specifier|private
name|void
name|failAndRemoveShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|String
name|indexUUID
parameter_list|,
annotation|@
name|Nullable
name|IndexService
name|indexService
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
if|if
condition|(
name|indexService
operator|!=
literal|null
operator|&&
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|// if the indexService is null we can't remove the shard, that's fine since we might have a failure
comment|// when the index is remove and then we already removed the index service for that shard...
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ShardNotFoundException
name|e
parameter_list|)
block|{
comment|// the node got closed on us, ignore it
block|}
catch|catch
parameter_list|(
name|Throwable
name|e1
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] failed to remove shard after failure ([{}])"
argument_list|,
name|e1
argument_list|,
name|shardRouting
operator|.
name|getIndex
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendShardFailure
condition|)
block|{
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
name|indexUUID
argument_list|,
name|message
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|sendFailShard
specifier|private
name|void
name|sendFailShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|String
name|indexUUID
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
try|try
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] marking and sending shard failed due to [{}]"
argument_list|,
name|failure
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|failedShards
operator|.
name|put
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
operator|new
name|FailedShard
argument_list|(
name|shardRouting
operator|.
name|version
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|shardFailed
argument_list|(
name|shardRouting
argument_list|,
name|indexUUID
argument_list|,
name|message
argument_list|,
name|failure
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e1
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] failed to mark shard as failed (because of [{}])"
argument_list|,
name|e1
argument_list|,
name|shardRouting
operator|.
name|getIndex
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_class
DECL|class|FailedShardHandler
specifier|private
class|class
name|FailedShardHandler
implements|implements
name|Callback
argument_list|<
name|IndexShard
operator|.
name|ShardFailure
argument_list|>
block|{
annotation|@
name|Override
DECL|method|handle
specifier|public
name|void
name|handle
parameter_list|(
specifier|final
name|IndexShard
operator|.
name|ShardFailure
name|shardFailure
parameter_list|)
block|{
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardFailure
operator|.
name|routing
operator|.
name|shardId
argument_list|()
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ShardRouting
name|shardRouting
init|=
name|shardFailure
operator|.
name|routing
decl_stmt|;
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|shardFailure
operator|.
name|indexUUID
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"shard failure, reason ["
operator|+
name|shardFailure
operator|.
name|reason
operator|+
literal|"]"
argument_list|,
name|shardFailure
operator|.
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
end_class

unit|}
end_unit

