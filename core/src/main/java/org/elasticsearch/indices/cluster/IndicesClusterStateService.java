begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.indices.cluster
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|cluster
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectCursor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|NodeIndexDeletedAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|NodeMappingRefreshAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|shard
operator|.
name|ShardStateAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MappingMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|IndexShardRoutingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|service
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|CompressedXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|Callback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|GatewayService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexShardAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|NodeServicesProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|DocumentMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|seqno
operator|.
name|GlobalCheckpointSyncAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|flush
operator|.
name|SyncedFlushService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoverySource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryTargetService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoriesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|SearchService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|RestoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|IndicesClusterStateService
specifier|public
class|class
name|IndicesClusterStateService
extends|extends
name|AbstractLifecycleComponent
argument_list|<
name|IndicesClusterStateService
argument_list|>
implements|implements
name|ClusterStateListener
block|{
DECL|field|indicesService
specifier|private
specifier|final
name|IndicesService
name|indicesService
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|recoveryTargetService
specifier|private
specifier|final
name|RecoveryTargetService
name|recoveryTargetService
decl_stmt|;
DECL|field|shardStateAction
specifier|private
specifier|final
name|ShardStateAction
name|shardStateAction
decl_stmt|;
DECL|field|nodeIndexDeletedAction
specifier|private
specifier|final
name|NodeIndexDeletedAction
name|nodeIndexDeletedAction
decl_stmt|;
DECL|field|nodeMappingRefreshAction
specifier|private
specifier|final
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
decl_stmt|;
DECL|field|nodeServicesProvider
specifier|private
specifier|final
name|NodeServicesProvider
name|nodeServicesProvider
decl_stmt|;
DECL|field|globalCheckpointSyncAction
specifier|private
specifier|final
name|GlobalCheckpointSyncAction
name|globalCheckpointSyncAction
decl_stmt|;
DECL|field|SHARD_STATE_ACTION_LISTENER
specifier|private
specifier|static
specifier|final
name|ShardStateAction
operator|.
name|Listener
name|SHARD_STATE_ACTION_LISTENER
init|=
operator|new
name|ShardStateAction
operator|.
name|Listener
argument_list|()
block|{     }
decl_stmt|;
comment|// a list of shards that failed during recovery
comment|// we keep track of these shards in order to prevent repeated recovery of these shards on each cluster state update
DECL|field|failedShards
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
name|failedShards
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|field|restoreService
specifier|private
specifier|final
name|RestoreService
name|restoreService
decl_stmt|;
DECL|field|repositoriesService
specifier|private
specifier|final
name|RepositoriesService
name|repositoriesService
decl_stmt|;
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|failedShardHandler
specifier|private
specifier|final
name|FailedShardHandler
name|failedShardHandler
init|=
operator|new
name|FailedShardHandler
argument_list|()
decl_stmt|;
DECL|field|sendRefreshMapping
specifier|private
specifier|final
name|boolean
name|sendRefreshMapping
decl_stmt|;
DECL|field|buildInIndexListener
specifier|private
specifier|final
name|List
argument_list|<
name|IndexEventListener
argument_list|>
name|buildInIndexListener
decl_stmt|;
annotation|@
name|Inject
DECL|method|IndicesClusterStateService
specifier|public
name|IndicesClusterStateService
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|RecoveryTargetService
name|recoveryTargetService
parameter_list|,
name|ShardStateAction
name|shardStateAction
parameter_list|,
name|NodeIndexDeletedAction
name|nodeIndexDeletedAction
parameter_list|,
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
parameter_list|,
name|RepositoriesService
name|repositoriesService
parameter_list|,
name|RestoreService
name|restoreService
parameter_list|,
name|SearchService
name|searchService
parameter_list|,
name|SyncedFlushService
name|syncedFlushService
parameter_list|,
name|RecoverySource
name|recoverySource
parameter_list|,
name|NodeServicesProvider
name|nodeServicesProvider
parameter_list|,
name|GlobalCheckpointSyncAction
name|globalCheckpointSyncAction
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|buildInIndexListener
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|recoverySource
argument_list|,
name|recoveryTargetService
argument_list|,
name|searchService
argument_list|,
name|syncedFlushService
argument_list|)
expr_stmt|;
name|this
operator|.
name|globalCheckpointSyncAction
operator|=
name|globalCheckpointSyncAction
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|recoveryTargetService
operator|=
name|recoveryTargetService
expr_stmt|;
name|this
operator|.
name|shardStateAction
operator|=
name|shardStateAction
expr_stmt|;
name|this
operator|.
name|nodeIndexDeletedAction
operator|=
name|nodeIndexDeletedAction
expr_stmt|;
name|this
operator|.
name|nodeMappingRefreshAction
operator|=
name|nodeMappingRefreshAction
expr_stmt|;
name|this
operator|.
name|restoreService
operator|=
name|restoreService
expr_stmt|;
name|this
operator|.
name|repositoriesService
operator|=
name|repositoriesService
expr_stmt|;
name|this
operator|.
name|sendRefreshMapping
operator|=
name|this
operator|.
name|settings
operator|.
name|getAsBoolean
argument_list|(
literal|"indices.cluster.send_refresh_mapping"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeServicesProvider
operator|=
name|nodeServicesProvider
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|clusterService
operator|.
name|addFirst
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|clusterService
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|clusterChanged
specifier|public
name|void
name|clusterChanged
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|changesAllowed
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|lifecycle
operator|.
name|started
argument_list|()
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|mutex
init|)
block|{
comment|// we need to clean the shards and indices we have on this node, since we
comment|// are going to recover them again once state persistence is disabled (no master / not recovered)
comment|// TODO: this feels a bit hacky here, a block disables state persistence, and then we clean the allocated shards, maybe another flag in blocks?
if|if
condition|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
condition|)
block|{
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|Index
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|shardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{}[{}] removing shard (disabled block persistence)"
argument_list|,
name|index
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
argument_list|,
literal|"removing shard (disabled block persistence)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} failed to remove shard (disabled block persistence)"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"cleaning index (disabled block persistence)"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|cleanFailedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// cleaning up indices that are completely deleted so we won't need to worry about them
comment|// when checking for shards
name|applyDeletedIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyDeletedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// call after deleted shards so indices with no shards will be cleaned
name|applyCleanedIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// make sure that newly created shards use the latest meta data
name|applyIndexMetaData
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyNewIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// apply mappings also updates new indices. TODO: make new indices good to begin with
name|applyMappings
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyNewOrUpdatedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|cleanFailedShards
specifier|private
name|void
name|cleanFailedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|RoutingNode
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
name|failedShards
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
argument_list|>
name|iterator
init|=
name|failedShards
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|ShardRouting
name|failedShardRouting
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ShardRouting
name|matchedShardRouting
init|=
name|routingNode
operator|.
name|getByShardId
argument_list|(
name|failedShardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchedShardRouting
operator|==
literal|null
operator|||
name|matchedShardRouting
operator|.
name|isSameAllocation
argument_list|(
name|failedShardRouting
argument_list|)
operator|==
literal|false
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyDeletedIndices
specifier|private
name|void
name|applyDeletedIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
specifier|final
name|ClusterState
name|previousState
init|=
name|event
operator|.
name|previousState
argument_list|()
decl_stmt|;
specifier|final
name|String
name|localNodeId
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
decl_stmt|;
assert|assert
name|localNodeId
operator|!=
literal|null
assert|;
for|for
control|(
name|Index
name|index
range|:
name|event
operator|.
name|indicesDeleted
argument_list|()
control|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] cleaning index, no longer part of the metadata"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
specifier|final
name|IndexService
name|idxService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|IndexSettings
name|indexSettings
decl_stmt|;
if|if
condition|(
name|idxService
operator|!=
literal|null
condition|)
block|{
name|indexSettings
operator|=
name|idxService
operator|.
name|getIndexSettings
argument_list|()
expr_stmt|;
name|deleteIndex
argument_list|(
name|index
argument_list|,
literal|"index no longer part of the metadata"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|previousState
operator|.
name|metaData
argument_list|()
operator|.
name|hasIndex
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// The deleted index was part of the previous cluster state, but not loaded on the local node
specifier|final
name|IndexMetaData
name|metaData
init|=
name|previousState
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|indexSettings
operator|=
operator|new
name|IndexSettings
argument_list|(
name|metaData
argument_list|,
name|settings
argument_list|)
expr_stmt|;
name|indicesService
operator|.
name|deleteUnassignedIndex
argument_list|(
literal|"deleted index was not assigned to local node"
argument_list|,
name|metaData
argument_list|,
name|event
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The previous cluster state's metadata also does not contain the index,
comment|// which is what happens on node startup when an index was deleted while the
comment|// node was not part of the cluster.  In this case, try reading the index
comment|// metadata from disk.  If its not there, there is nothing to delete.
comment|// First, though, verify the precondition for applying this case by
comment|// asserting that the previous cluster state is not initialized/recovered.
assert|assert
name|previousState
operator|.
name|blocks
argument_list|()
operator|.
name|hasGlobalBlock
argument_list|(
name|GatewayService
operator|.
name|STATE_NOT_RECOVERED_BLOCK
argument_list|)
assert|;
specifier|final
name|IndexMetaData
name|metaData
init|=
name|indicesService
operator|.
name|verifyIndexIsDeleted
argument_list|(
name|index
argument_list|,
name|event
operator|.
name|state
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|indexSettings
operator|=
operator|new
name|IndexSettings
argument_list|(
name|metaData
argument_list|,
name|settings
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexSettings
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// indexSettings can only be null if there was no IndexService and no metadata existed
comment|// on disk for this index, so it won't need to go through the node deleted action anyway
if|if
condition|(
name|indexSettings
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|nodeIndexDeletedAction
operator|.
name|nodeIndexDeleted
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
name|index
argument_list|,
name|indexSettings
argument_list|,
name|localNodeId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to send to master index {} deleted event"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|indexService
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|==
literal|null
condition|)
block|{
assert|assert
literal|false
operator|:
literal|"index"
operator|+
name|indexService
operator|.
name|index
argument_list|()
operator|+
literal|" exists locally, doesn't have a metadata but is not part "
operator|+
literal|" of the delete index list. \nprevious state: "
operator|+
name|event
operator|.
name|previousState
argument_list|()
operator|.
name|prettyPrint
argument_list|()
operator|+
literal|"\n current state:\n"
operator|+
name|event
operator|.
name|state
argument_list|()
operator|.
name|prettyPrint
argument_list|()
assert|;
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] isn't part of metadata but is part of in memory structures. removing"
argument_list|,
name|indexService
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
name|deleteIndex
argument_list|(
name|indexService
operator|.
name|index
argument_list|()
argument_list|,
literal|"isn't part of metadata (explicit check)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyDeletedShards
specifier|private
name|void
name|applyDeletedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|RoutingNode
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|newShardAllocationIds
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|Index
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
decl_stmt|;
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
assert|assert
name|indexMetaData
operator|!=
literal|null
operator|:
literal|"local index doesn't have metadata, should have been cleaned up by applyDeletedIndices: "
operator|+
name|index
assert|;
comment|// now, go over and delete shards that needs to get deleted
name|newShardAllocationIds
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|index
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
condition|)
block|{
comment|// use the allocation id and not object so we won't be influence by relocation targets
name|newShardAllocationIds
operator|.
name|add
argument_list|(
name|shard
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|IndexShard
name|existingShard
range|:
name|indexService
control|)
block|{
if|if
condition|(
name|newShardAllocationIds
operator|.
name|contains
argument_list|(
name|existingShard
operator|.
name|routingEntry
argument_list|()
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|indexMetaData
operator|.
name|getState
argument_list|()
operator|==
name|IndexMetaData
operator|.
name|State
operator|.
name|CLOSE
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} removing shard (index is closed)"
argument_list|,
name|existingShard
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|indexService
operator|.
name|removeShard
argument_list|(
name|existingShard
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (index is closed)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we can just remove the shard, without cleaning it locally, since we will clean it
comment|// when all shards are allocated in the IndicesStore
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} removing shard (not allocated)"
argument_list|,
name|existingShard
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|indexService
operator|.
name|removeShard
argument_list|(
name|existingShard
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (not allocated)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|applyCleanedIndices
specifier|private
name|void
name|applyCleanedIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// handle closed indices, since they are not allocated on a node once they are closed
comment|// so applyDeletedIndices might not take them into account
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|Index
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
decl_stmt|;
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|!=
literal|null
operator|&&
name|indexMetaData
operator|.
name|getState
argument_list|()
operator|==
name|IndexMetaData
operator|.
name|State
operator|.
name|CLOSE
condition|)
block|{
for|for
control|(
name|Integer
name|shardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{}[{}] removing shard (index is closed)"
argument_list|,
name|index
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
argument_list|,
literal|"removing shard (index is closed)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} failed to remove shard (index is closed)"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
specifier|final
name|Set
argument_list|<
name|Index
argument_list|>
name|hasAllocations
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|RoutingNode
name|node
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
comment|// if no shards are allocated ie. if this node is a master-only node it can return nul
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ShardRouting
name|routing
range|:
name|node
control|)
block|{
name|hasAllocations
operator|.
name|add
argument_list|(
name|routing
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|Index
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasAllocations
operator|.
name|contains
argument_list|(
name|index
argument_list|)
operator|==
literal|false
condition|)
block|{
assert|assert
name|indexService
operator|.
name|shardIds
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"no locally assigned shards, but index wasn't emptied by applyDeletedShards."
operator|+
literal|" index "
operator|+
name|index
operator|+
literal|", shards: "
operator|+
name|indexService
operator|.
name|shardIds
argument_list|()
assert|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} cleaning index (no shards allocated)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// clean the index
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"removing index (no shards allocated)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyIndexMetaData
specifier|private
name|void
name|applyIndexMetaData
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|metaDataChanged
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|)
condition|)
block|{
comment|// we only create / update here
continue|continue;
block|}
comment|// if the index meta data didn't change, no need check for refreshed settings
if|if
condition|(
operator|!
name|event
operator|.
name|indexMetaDataChanged
argument_list|(
name|indexMetaData
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|Index
name|index
init|=
name|indexMetaData
operator|.
name|getIndex
argument_list|()
decl_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// already deleted on us, ignore it
continue|continue;
block|}
name|indexService
operator|.
name|updateMetaData
argument_list|(
name|indexMetaData
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyNewIndices
specifier|private
name|void
name|applyNewIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// we only create indices for shards that are allocated
name|RoutingNode
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|ShardRouting
name|shard
range|:
name|routingNode
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|getIndexSafe
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] creating index"
argument_list|,
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|indicesService
operator|.
name|createIndex
argument_list|(
name|nodeServicesProvider
argument_list|,
name|indexMetaData
argument_list|,
name|buildInIndexListener
argument_list|,
name|globalCheckpointSyncAction
operator|::
name|updateCheckpointForShard
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|sendFailShard
argument_list|(
name|shard
argument_list|,
literal|"failed to create index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|applyMappings
specifier|private
name|void
name|applyMappings
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// go over and update mappings
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
control|)
block|{
name|Index
name|index
init|=
name|indexMetaData
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|index
argument_list|)
condition|)
block|{
comment|// we only create / update here
continue|continue;
block|}
name|boolean
name|requireRefresh
init|=
literal|false
decl_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// got deleted on us, ignore (closing the node)
return|return;
block|}
try|try
block|{
name|MapperService
name|mapperService
init|=
name|indexService
operator|.
name|mapperService
argument_list|()
decl_stmt|;
comment|// go over and add the relevant mappings (or update them)
for|for
control|(
name|ObjectCursor
argument_list|<
name|MappingMetaData
argument_list|>
name|cursor
range|:
name|indexMetaData
operator|.
name|getMappings
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|MappingMetaData
name|mappingMd
init|=
name|cursor
operator|.
name|value
decl_stmt|;
name|String
name|mappingType
init|=
name|mappingMd
operator|.
name|type
argument_list|()
decl_stmt|;
name|CompressedXContent
name|mappingSource
init|=
name|mappingMd
operator|.
name|source
argument_list|()
decl_stmt|;
name|requireRefresh
operator||=
name|processMapping
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|,
name|mapperService
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|requireRefresh
operator|&&
name|sendRefreshMapping
condition|)
block|{
name|nodeMappingRefreshAction
operator|.
name|nodeMappingRefresh
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
operator|new
name|NodeMappingRefreshAction
operator|.
name|NodeMappingRefreshRequest
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// if we failed the mappings anywhere, we need to fail the shards for this index, note, we safeguard
comment|// by creating the processing the mappings on the master, or on the node the mapping was introduced on,
comment|// so this failure typically means wrong node level configuration or something similar
for|for
control|(
name|IndexShard
name|indexShard
range|:
name|indexService
control|)
block|{
name|ShardRouting
name|shardRouting
init|=
name|indexShard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"failed to update mappings"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|processMapping
specifier|private
name|boolean
name|processMapping
parameter_list|(
name|String
name|index
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|String
name|mappingType
parameter_list|,
name|CompressedXContent
name|mappingSource
parameter_list|)
throws|throws
name|Throwable
block|{
comment|// refresh mapping can happen when the parsing/merging of the mapping from the metadata doesn't result in the same
comment|// mapping, in this case, we send to the master to refresh its own version of the mappings (to conform with the
comment|// merge version of it, which it does when refreshing the mappings), and warn log it.
name|boolean
name|requiresRefresh
init|=
literal|false
decl_stmt|;
try|try
block|{
name|DocumentMapper
name|existingMapper
init|=
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingMapper
operator|==
literal|null
operator|||
name|mappingSource
operator|.
name|equals
argument_list|(
name|existingMapper
operator|.
name|mappingSource
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|String
name|op
init|=
name|existingMapper
operator|==
literal|null
condition|?
literal|"adding"
else|:
literal|"updating"
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|mappingSource
operator|.
name|compressed
argument_list|()
operator|.
name|length
operator|<
literal|512
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] {} mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|op
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] {} mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|op
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)"
argument_list|,
name|index
argument_list|,
name|op
argument_list|,
name|mappingType
argument_list|)
expr_stmt|;
block|}
name|mapperService
operator|.
name|merge
argument_list|(
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
name|MapperService
operator|.
name|MergeReason
operator|.
name|MAPPING_RECOVERY
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
operator|.
name|equals
argument_list|(
name|mappingSource
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
argument_list|)
expr_stmt|;
name|requiresRefresh
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to add mapping [{}], source [{}]"
argument_list|,
name|e
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|requiresRefresh
return|;
block|}
DECL|method|applyNewOrUpdatedShards
specifier|private
name|void
name|applyNewOrUpdatedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|changesAllowed
argument_list|()
condition|)
block|{
return|return;
block|}
name|RoutingTable
name|routingTable
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|routingTable
argument_list|()
decl_stmt|;
name|RoutingNode
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
name|failedShards
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|DiscoveryNodes
name|nodes
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ShardRouting
name|shardRouting
range|:
name|routingNode
control|)
block|{
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// creation failed for some reasons
assert|assert
name|failedShards
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
operator|:
literal|"index has local allocation but is not created by applyNewIndices and is not failed "
operator|+
name|shardRouting
assert|;
continue|continue;
block|}
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|indexMetaData
operator|!=
literal|null
operator|:
literal|"index has local allocation but no meta data. "
operator|+
name|shardRouting
operator|.
name|index
argument_list|()
assert|;
specifier|final
name|int
name|shardId
init|=
name|shardRouting
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
operator|&&
name|shardRouting
operator|.
name|started
argument_list|()
condition|)
block|{
if|if
condition|(
name|failedShards
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|message
init|=
literal|"master "
operator|+
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|+
literal|" marked shard as started, but shard has previous failed. resending shard failure"
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] re-sending failed shard [{}], reason [{}]"
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|shardFailed
argument_list|(
name|shardRouting
argument_list|,
name|shardRouting
argument_list|,
name|message
argument_list|,
literal|null
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the master thinks we are started, but we don't have this shard at all, mark it as failed
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
literal|"master ["
operator|+
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|+
literal|"] marked shard as started, but shard has not been created, mark shard as failed"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|!=
literal|null
condition|)
block|{
name|ShardRouting
name|currentRoutingEntry
init|=
name|indexShard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
comment|// if the current and global routing are initializing, but are still not the same, its a different "shard" being allocated
comment|// for example: a shard that recovers from one node and now needs to recover to another node,
comment|//              or a replica allocated and then allocating a primary because the primary failed on another node
name|boolean
name|shardHasBeenRemoved
init|=
literal|false
decl_stmt|;
assert|assert
name|currentRoutingEntry
operator|.
name|isSameAllocation
argument_list|(
name|shardRouting
argument_list|)
operator|:
literal|"local shard has a different allocation id but wasn't cleaning by applyDeletedShards. "
operator|+
literal|"cluster state: "
operator|+
name|shardRouting
operator|+
literal|" local: "
operator|+
name|currentRoutingEntry
assert|;
if|if
condition|(
name|shardRouting
operator|.
name|isPeerRecovery
argument_list|()
condition|)
block|{
name|RecoveryState
name|recoveryState
init|=
name|indexShard
operator|.
name|recoveryState
argument_list|()
decl_stmt|;
specifier|final
name|DiscoveryNode
name|sourceNode
init|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|logger
argument_list|,
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|shardRouting
argument_list|)
decl_stmt|;
if|if
condition|(
name|recoveryState
operator|.
name|getSourceNode
argument_list|()
operator|.
name|equals
argument_list|(
name|sourceNode
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|recoveryTargetService
operator|.
name|cancelRecoveriesForShard
argument_list|(
name|currentRoutingEntry
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"recovery source node changed"
argument_list|)
condition|)
block|{
comment|// getting here means that the shard was still recovering
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (recovery source changed), current [{}], global [{}])"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
name|currentRoutingEntry
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (recovery source node changed)"
argument_list|)
expr_stmt|;
name|shardHasBeenRemoved
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|shardHasBeenRemoved
operator|==
literal|false
condition|)
block|{
try|try
block|{
name|indexShard
operator|.
name|updateRoutingEntry
argument_list|(
name|shardRouting
argument_list|,
name|event
operator|.
name|state
argument_list|()
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
operator|==
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
specifier|final
name|IndexShardRoutingTable
name|shardRoutingTable
init|=
name|routingTable
operator|.
name|shardRoutingTable
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|activeIds
init|=
name|shardRoutingTable
operator|.
name|activeShards
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|sr
lambda|->
name|sr
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toSet
argument_list|()
argument_list|)
decl_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|initializingIds
init|=
name|shardRoutingTable
operator|.
name|getAllInitializingShards
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|sr
lambda|->
name|sr
operator|.
name|allocationId
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toSet
argument_list|()
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|updateAllocationIdsFromMaster
argument_list|(
name|activeIds
argument_list|,
name|initializingIds
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"failed updating shard routing entry"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|shardRouting
operator|.
name|initializing
argument_list|()
condition|)
block|{
name|applyInitializingShard
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
name|indexService
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyInitializingShard
specifier|private
name|void
name|applyInitializingShard
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|,
name|IndexService
name|indexService
parameter_list|,
specifier|final
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
specifier|final
name|RoutingTable
name|routingTable
init|=
name|state
operator|.
name|routingTable
argument_list|()
decl_stmt|;
specifier|final
name|DiscoveryNodes
name|nodes
init|=
name|state
operator|.
name|getNodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|shardId
init|=
name|shardRouting
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|getShard
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
comment|// the master thinks we are initializing, but we are already started or on POST_RECOVERY and waiting
comment|// for master to confirm a shard started message (either master failover, or a cluster event before
comment|// we managed to tell the master we started), mark us as started
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"{} master marked shard as initializing, but shard has state [{}], resending shard started to {}"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|,
name|nodes
operator|.
name|getMasterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|+
literal|" marked shard as initializing, but shard state is ["
operator|+
name|indexShard
operator|.
name|state
argument_list|()
operator|+
literal|"], mark shard as started"
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
if|if
condition|(
name|indexShard
operator|.
name|ignoreRecoveryAttempt
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring recovery instruction for an existing shard {} (shard state: [{}])"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// if we're in peer recovery, try to find out the source node now so in case it fails, we will not create the index shard
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|shardRouting
operator|.
name|isPeerRecovery
argument_list|()
condition|)
block|{
name|sourceNode
operator|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|logger
argument_list|,
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring initializing shard {} - no source node can be found."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// if there is no shard, create it
if|if
condition|(
operator|!
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
if|if
condition|(
name|failedShards
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|String
name|message
init|=
literal|"master "
operator|+
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|+
literal|" marked shard as initializing, but shard is marked as failed, resend shard failure"
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] re-sending failed shard [{}], reason [{}]"
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|shardFailed
argument_list|(
name|shardRouting
argument_list|,
name|shardRouting
argument_list|,
name|message
argument_list|,
literal|null
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] creating shard"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|createShard
argument_list|(
name|shardRouting
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|addShardFailureCallback
argument_list|(
name|failedShardHandler
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexShardAlreadyExistsException
name|e
parameter_list|)
block|{
comment|// ignore this, the method call can happen several times
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"failed to create shard"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
specifier|final
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|getShard
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|.
name|ignoreRecoveryAttempt
argument_list|()
condition|)
block|{
comment|// we are already recovering (we can get to this state since the cluster event can happen several
comment|// times while we recover)
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring recovery instruction for shard {} (shard state: [{}])"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|indexShard
operator|.
name|startRecovery
argument_list|(
name|nodes
operator|.
name|getLocalNode
argument_list|()
argument_list|,
name|sourceNode
argument_list|,
name|recoveryTargetService
argument_list|,
operator|new
name|RecoveryListener
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|)
argument_list|,
name|repositoriesService
argument_list|)
expr_stmt|;
block|}
comment|/**      * Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard      * routing to *require* peer recovery, use {@link ShardRouting#isPeerRecovery()} to      * check if its needed or not.      */
DECL|method|findSourceNodeForPeerRecovery
specifier|private
specifier|static
name|DiscoveryNode
name|findSourceNodeForPeerRecovery
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|RoutingTable
name|routingTable
parameter_list|,
name|DiscoveryNodes
name|nodes
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|ShardRouting
name|primary
init|=
name|routingTable
operator|.
name|shardRoutingTable
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
operator|.
name|primaryShard
argument_list|()
decl_stmt|;
comment|// only recover from started primary, if we can't find one, we will do it next round
if|if
condition|(
name|primary
operator|.
name|active
argument_list|()
condition|)
block|{
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|primary
operator|.
name|currentNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node because primary shard {} is assigned to an unknown node."
argument_list|,
name|primary
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node because primary shard {} is not active."
argument_list|,
name|primary
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find relocation source node for shard {} because it is assigned to an unknown node [{}]."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"trying to find source node for peer recovery when routing state means no peer recovery: "
operator|+
name|shardRouting
argument_list|)
throw|;
block|}
return|return
name|sourceNode
return|;
block|}
DECL|class|RecoveryListener
specifier|private
class|class
name|RecoveryListener
implements|implements
name|RecoveryTargetService
operator|.
name|RecoveryListener
block|{
DECL|field|shardRouting
specifier|private
specifier|final
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|field|indexService
specifier|private
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|method|RecoveryListener
specifier|private
name|RecoveryListener
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|IndexService
name|indexService
parameter_list|)
block|{
name|this
operator|.
name|shardRouting
operator|=
name|shardRouting
expr_stmt|;
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onRecoveryDone
specifier|public
name|void
name|onRecoveryDone
parameter_list|(
name|RecoveryState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|getType
argument_list|()
operator|==
name|RecoveryState
operator|.
name|Type
operator|.
name|SNAPSHOT
condition|)
block|{
name|restoreService
operator|.
name|indexShardRestoreCompleted
argument_list|(
name|state
operator|.
name|getRestoreSource
argument_list|()
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|message
argument_list|(
name|state
argument_list|)
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
DECL|method|message
specifier|private
name|String
name|message
parameter_list|(
name|RecoveryState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|SNAPSHOT
case|:
return|return
literal|"after recovery from repository"
return|;
case|case
name|STORE
case|:
return|return
literal|"after recovery from store"
return|;
case|case
name|PRIMARY_RELOCATION
case|:
return|return
literal|"after recovery (primary relocation) from node ["
operator|+
name|state
operator|.
name|getSourceNode
argument_list|()
operator|+
literal|"]"
return|;
case|case
name|REPLICA
case|:
return|return
literal|"after recovery (replica) from node ["
operator|+
name|state
operator|.
name|getSourceNode
argument_list|()
operator|+
literal|"]"
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|state
operator|.
name|getType
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|onRecoveryFailure
specifier|public
name|void
name|onRecoveryFailure
parameter_list|(
name|RecoveryState
name|state
parameter_list|,
name|RecoveryFailedException
name|e
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|getType
argument_list|()
operator|==
name|RecoveryState
operator|.
name|Type
operator|.
name|SNAPSHOT
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Lucene
operator|.
name|isCorruptionException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
condition|)
block|{
name|restoreService
operator|.
name|failRestore
argument_list|(
name|state
operator|.
name|getRestoreSource
argument_list|()
operator|.
name|snapshotId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|inner
parameter_list|)
block|{
name|e
operator|.
name|addSuppressed
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
name|sendShardFailure
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
name|sendShardFailure
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|handleRecoveryFailure
specifier|private
name|void
name|handleRecoveryFailure
parameter_list|(
name|IndexService
name|indexService
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
name|sendShardFailure
argument_list|,
literal|"failed recovery"
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeIndex
specifier|private
name|void
name|removeIndex
parameter_list|(
name|Index
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
try|try
block|{
name|indicesService
operator|.
name|removeIndex
argument_list|(
name|index
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to clean index ({})"
argument_list|,
name|e
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|deleteIndex
specifier|private
name|void
name|deleteIndex
parameter_list|(
name|Index
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
try|try
block|{
name|indicesService
operator|.
name|deleteIndex
argument_list|(
name|index
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to delete index ({})"
argument_list|,
name|e
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|failAndRemoveShard
specifier|private
name|void
name|failAndRemoveShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
annotation|@
name|Nullable
name|IndexService
name|indexService
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
if|if
condition|(
name|indexService
operator|!=
literal|null
operator|&&
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|// if the indexService is null we can't remove the shard, that's fine since we might have a failure
comment|// when the index is remove and then we already removed the index service for that shard...
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ShardNotFoundException
name|e
parameter_list|)
block|{
comment|// the node got closed on us, ignore it
block|}
catch|catch
parameter_list|(
name|Throwable
name|e1
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] failed to remove shard after failure ([{}])"
argument_list|,
name|e1
argument_list|,
name|shardRouting
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendShardFailure
condition|)
block|{
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
name|message
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sendFailShard
specifier|private
name|void
name|sendFailShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
try|try
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] marking and sending shard failed due to [{}]"
argument_list|,
name|failure
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|failedShards
operator|.
name|put
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|shardFailed
argument_list|(
name|shardRouting
argument_list|,
name|shardRouting
argument_list|,
name|message
argument_list|,
name|failure
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e1
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] failed to mark shard as failed (because of [{}])"
argument_list|,
name|e1
argument_list|,
name|shardRouting
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FailedShardHandler
specifier|private
class|class
name|FailedShardHandler
implements|implements
name|Callback
argument_list|<
name|IndexShard
operator|.
name|ShardFailure
argument_list|>
block|{
annotation|@
name|Override
DECL|method|handle
specifier|public
name|void
name|handle
parameter_list|(
specifier|final
name|IndexShard
operator|.
name|ShardFailure
name|shardFailure
parameter_list|)
block|{
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardFailure
operator|.
name|routing
operator|.
name|shardId
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ShardRouting
name|shardRouting
init|=
name|shardFailure
operator|.
name|routing
decl_stmt|;
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"shard failure, reason ["
operator|+
name|shardFailure
operator|.
name|reason
operator|+
literal|"]"
argument_list|,
name|shardFailure
operator|.
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

