begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.indices.cluster
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|cluster
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|util
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|LockObtainFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|NodeMappingRefreshAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|shard
operator|.
name|ShardStateAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RecoverySource
operator|.
name|SnapshotRecoverySource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RecoverySource
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|service
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|Callback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|ShardLockObtainFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|GatewayService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexShardAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|NodeServicesProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|seqno
operator|.
name|GlobalCheckpointSyncAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardRelocatedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndexAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|flush
operator|.
name|SyncedFlushService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|PeerRecoverySourceService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|PeerRecoveryTargetService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoriesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|SearchService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|RestoreService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_class
DECL|class|IndicesClusterStateService
specifier|public
class|class
name|IndicesClusterStateService
extends|extends
name|AbstractLifecycleComponent
implements|implements
name|ClusterStateListener
block|{
DECL|field|indicesService
specifier|final
name|AllocatedIndices
argument_list|<
name|?
extends|extends
name|Shard
argument_list|,
name|?
extends|extends
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
argument_list|>
name|indicesService
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|recoveryTargetService
specifier|private
specifier|final
name|PeerRecoveryTargetService
name|recoveryTargetService
decl_stmt|;
DECL|field|shardStateAction
specifier|private
specifier|final
name|ShardStateAction
name|shardStateAction
decl_stmt|;
DECL|field|nodeMappingRefreshAction
specifier|private
specifier|final
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
decl_stmt|;
DECL|field|nodeServicesProvider
specifier|private
specifier|final
name|NodeServicesProvider
name|nodeServicesProvider
decl_stmt|;
DECL|field|globalCheckpointSyncer
specifier|private
specifier|final
name|Consumer
argument_list|<
name|ShardId
argument_list|>
name|globalCheckpointSyncer
decl_stmt|;
DECL|field|SHARD_STATE_ACTION_LISTENER
specifier|private
specifier|static
specifier|final
name|ShardStateAction
operator|.
name|Listener
name|SHARD_STATE_ACTION_LISTENER
init|=
operator|new
name|ShardStateAction
operator|.
name|Listener
argument_list|()
block|{     }
decl_stmt|;
comment|// a list of shards that failed during recovery
comment|// we keep track of these shards in order to prevent repeated recovery of these shards on each cluster state update
DECL|field|failedShardsCache
specifier|final
name|ConcurrentMap
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
name|failedShardsCache
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|field|restoreService
specifier|private
specifier|final
name|RestoreService
name|restoreService
decl_stmt|;
DECL|field|repositoriesService
specifier|private
specifier|final
name|RepositoriesService
name|repositoriesService
decl_stmt|;
DECL|field|failedShardHandler
specifier|private
specifier|final
name|FailedShardHandler
name|failedShardHandler
init|=
operator|new
name|FailedShardHandler
argument_list|()
decl_stmt|;
DECL|field|sendRefreshMapping
specifier|private
specifier|final
name|boolean
name|sendRefreshMapping
decl_stmt|;
DECL|field|buildInIndexListener
specifier|private
specifier|final
name|List
argument_list|<
name|IndexEventListener
argument_list|>
name|buildInIndexListener
decl_stmt|;
annotation|@
name|Inject
DECL|method|IndicesClusterStateService
specifier|public
name|IndicesClusterStateService
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|PeerRecoveryTargetService
name|recoveryTargetService
parameter_list|,
name|ShardStateAction
name|shardStateAction
parameter_list|,
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
parameter_list|,
name|RepositoriesService
name|repositoriesService
parameter_list|,
name|RestoreService
name|restoreService
parameter_list|,
name|SearchService
name|searchService
parameter_list|,
name|SyncedFlushService
name|syncedFlushService
parameter_list|,
name|PeerRecoverySourceService
name|peerRecoverySourceService
parameter_list|,
name|NodeServicesProvider
name|nodeServicesProvider
parameter_list|,
name|GlobalCheckpointSyncAction
name|globalCheckpointSyncAction
parameter_list|)
block|{
name|this
argument_list|(
name|settings
argument_list|,
operator|(
name|AllocatedIndices
argument_list|<
name|?
extends|extends
name|Shard
argument_list|,
name|?
extends|extends
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
argument_list|>
operator|)
name|indicesService
argument_list|,
name|clusterService
argument_list|,
name|threadPool
argument_list|,
name|recoveryTargetService
argument_list|,
name|shardStateAction
argument_list|,
name|nodeMappingRefreshAction
argument_list|,
name|repositoriesService
argument_list|,
name|restoreService
argument_list|,
name|searchService
argument_list|,
name|syncedFlushService
argument_list|,
name|peerRecoverySourceService
argument_list|,
name|nodeServicesProvider
argument_list|,
name|globalCheckpointSyncAction
operator|::
name|updateCheckpointForShard
argument_list|)
expr_stmt|;
block|}
comment|// for tests
DECL|method|IndicesClusterStateService
name|IndicesClusterStateService
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|AllocatedIndices
argument_list|<
name|?
extends|extends
name|Shard
argument_list|,
name|?
extends|extends
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
argument_list|>
name|indicesService
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|PeerRecoveryTargetService
name|recoveryTargetService
parameter_list|,
name|ShardStateAction
name|shardStateAction
parameter_list|,
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
parameter_list|,
name|RepositoriesService
name|repositoriesService
parameter_list|,
name|RestoreService
name|restoreService
parameter_list|,
name|SearchService
name|searchService
parameter_list|,
name|SyncedFlushService
name|syncedFlushService
parameter_list|,
name|PeerRecoverySourceService
name|peerRecoverySourceService
parameter_list|,
name|NodeServicesProvider
name|nodeServicesProvider
parameter_list|,
name|Consumer
argument_list|<
name|ShardId
argument_list|>
name|globalCheckpointSyncer
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|buildInIndexListener
operator|=
name|Arrays
operator|.
name|asList
argument_list|(
name|peerRecoverySourceService
argument_list|,
name|recoveryTargetService
argument_list|,
name|searchService
argument_list|,
name|syncedFlushService
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|recoveryTargetService
operator|=
name|recoveryTargetService
expr_stmt|;
name|this
operator|.
name|shardStateAction
operator|=
name|shardStateAction
expr_stmt|;
name|this
operator|.
name|nodeMappingRefreshAction
operator|=
name|nodeMappingRefreshAction
expr_stmt|;
name|this
operator|.
name|restoreService
operator|=
name|restoreService
expr_stmt|;
name|this
operator|.
name|repositoriesService
operator|=
name|repositoriesService
expr_stmt|;
name|this
operator|.
name|sendRefreshMapping
operator|=
name|this
operator|.
name|settings
operator|.
name|getAsBoolean
argument_list|(
literal|"indices.cluster.send_refresh_mapping"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeServicesProvider
operator|=
name|nodeServicesProvider
expr_stmt|;
name|this
operator|.
name|globalCheckpointSyncer
operator|=
name|globalCheckpointSyncer
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|clusterService
operator|.
name|addFirst
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|clusterService
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|clusterChanged
specifier|public
specifier|synchronized
name|void
name|clusterChanged
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lifecycle
operator|.
name|started
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|ClusterState
name|state
init|=
name|event
operator|.
name|state
argument_list|()
decl_stmt|;
comment|// we need to clean the shards and indices we have on this node, since we
comment|// are going to recover them again once state persistence is disabled (no master / not recovered)
comment|// TODO: feels hacky, a block disables state persistence, and then we clean the allocated shards, maybe another flag in blocks?
if|if
condition|(
name|state
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
condition|)
block|{
for|for
control|(
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
range|:
name|indicesService
control|)
block|{
name|indicesService
operator|.
name|removeIndex
argument_list|(
name|indexService
operator|.
name|index
argument_list|()
argument_list|,
literal|"cleaning index (disabled block persistence)"
argument_list|)
expr_stmt|;
comment|// also cleans shards
block|}
return|return;
block|}
name|updateFailedShardsCache
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|deleteIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// also deletes shards of deleted indices
name|removeUnallocatedIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// also removes shards of removed indices
name|failMissingShards
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|removeShards
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|updateIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
comment|// can also fail shards, but these are then guaranteed to be in failedShardsCache
name|createIndices
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|createOrUpdateShards
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes shard entries from the failed shards cache that are no longer allocated to this node by the master.      * Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node.      * Resends shard failures for shards that are still marked as allocated to this node but previously failed.      *      * @param state new cluster state      */
DECL|method|updateFailedShardsCache
specifier|private
name|void
name|updateFailedShardsCache
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|)
block|{
name|RoutingNode
name|localRoutingNode
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localRoutingNode
operator|==
literal|null
condition|)
block|{
name|failedShardsCache
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|DiscoveryNode
name|masterNode
init|=
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
decl_stmt|;
comment|// remove items from cache which are not in our routing table anymore and resend failures that have not executed on master yet
for|for
control|(
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|ShardRouting
argument_list|>
argument_list|>
name|iterator
init|=
name|failedShardsCache
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|iterator
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|ShardRouting
name|failedShardRouting
init|=
name|iterator
operator|.
name|next
argument_list|()
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|ShardRouting
name|matchedRouting
init|=
name|localRoutingNode
operator|.
name|getByShardId
argument_list|(
name|failedShardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|matchedRouting
operator|==
literal|null
operator|||
name|matchedRouting
operator|.
name|isSameAllocation
argument_list|(
name|failedShardRouting
argument_list|)
operator|==
literal|false
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|masterNode
operator|!=
literal|null
condition|)
block|{
comment|// TODO: can we remove this? Is resending shard failures the responsibility of shardStateAction?
name|String
name|message
init|=
literal|"master "
operator|+
name|masterNode
operator|+
literal|" has not removed previously failed shard. resending shard failure"
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] re-sending failed shard [{}], reason [{}]"
argument_list|,
name|matchedRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|matchedRouting
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|localShardFailed
argument_list|(
name|matchedRouting
argument_list|,
name|message
argument_list|,
literal|null
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Deletes indices (with shard data).      *      * @param event cluster change event      */
DECL|method|deleteIndices
specifier|private
name|void
name|deleteIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
specifier|final
name|ClusterState
name|previousState
init|=
name|event
operator|.
name|previousState
argument_list|()
decl_stmt|;
specifier|final
name|ClusterState
name|state
init|=
name|event
operator|.
name|state
argument_list|()
decl_stmt|;
specifier|final
name|String
name|localNodeId
init|=
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
decl_stmt|;
assert|assert
name|localNodeId
operator|!=
literal|null
assert|;
for|for
control|(
name|Index
name|index
range|:
name|event
operator|.
name|indicesDeleted
argument_list|()
control|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] cleaning index, no longer part of the metadata"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
specifier|final
name|IndexSettings
name|indexSettings
decl_stmt|;
if|if
condition|(
name|indexService
operator|!=
literal|null
condition|)
block|{
name|indexSettings
operator|=
name|indexService
operator|.
name|getIndexSettings
argument_list|()
expr_stmt|;
name|indicesService
operator|.
name|deleteIndex
argument_list|(
name|index
argument_list|,
literal|"index no longer part of the metadata"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|previousState
operator|.
name|metaData
argument_list|()
operator|.
name|hasIndex
argument_list|(
name|index
operator|.
name|getName
argument_list|()
argument_list|)
condition|)
block|{
comment|// The deleted index was part of the previous cluster state, but not loaded on the local node
specifier|final
name|IndexMetaData
name|metaData
init|=
name|previousState
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|indexSettings
operator|=
operator|new
name|IndexSettings
argument_list|(
name|metaData
argument_list|,
name|settings
argument_list|)
expr_stmt|;
name|indicesService
operator|.
name|deleteUnassignedIndex
argument_list|(
literal|"deleted index was not assigned to local node"
argument_list|,
name|metaData
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The previous cluster state's metadata also does not contain the index,
comment|// which is what happens on node startup when an index was deleted while the
comment|// node was not part of the cluster.  In this case, try reading the index
comment|// metadata from disk.  If its not there, there is nothing to delete.
comment|// First, though, verify the precondition for applying this case by
comment|// asserting that the previous cluster state is not initialized/recovered.
assert|assert
name|previousState
operator|.
name|blocks
argument_list|()
operator|.
name|hasGlobalBlock
argument_list|(
name|GatewayService
operator|.
name|STATE_NOT_RECOVERED_BLOCK
argument_list|)
assert|;
specifier|final
name|IndexMetaData
name|metaData
init|=
name|indicesService
operator|.
name|verifyIndexIsDeleted
argument_list|(
name|index
argument_list|,
name|event
operator|.
name|state
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|metaData
operator|!=
literal|null
condition|)
block|{
name|indexSettings
operator|=
operator|new
name|IndexSettings
argument_list|(
name|metaData
argument_list|,
name|settings
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexSettings
operator|=
literal|null
expr_stmt|;
block|}
block|}
if|if
condition|(
name|indexSettings
operator|!=
literal|null
condition|)
block|{
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
operator|new
name|AbstractRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] failed to complete pending deletion for index"
argument_list|,
name|index
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
try|try
block|{
comment|// we are waiting until we can lock the index / all shards on the node and then we ack the delete of the store
comment|// to the master. If we can't acquire the locks here immediately there might be a shard of this index still
comment|// holding on to the lock due to a "currently canceled recovery" or so. The shard will delete itself BEFORE the
comment|// lock is released so it's guaranteed to be deleted by the time we get the lock
name|indicesService
operator|.
name|processPendingDeletes
argument_list|(
name|index
argument_list|,
name|indexSettings
argument_list|,
operator|new
name|TimeValue
argument_list|(
literal|30
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|LockObtainFailedException
name|exc
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to lock all shards for index - timed out after 30 seconds"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to lock all shards for index - interrupted"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough      * shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).      *      * @param event the cluster changed event      */
DECL|method|removeUnallocatedIndices
specifier|private
name|void
name|removeUnallocatedIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
specifier|final
name|ClusterState
name|state
init|=
name|event
operator|.
name|state
argument_list|()
decl_stmt|;
specifier|final
name|String
name|localNodeId
init|=
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
decl_stmt|;
assert|assert
name|localNodeId
operator|!=
literal|null
assert|;
name|Set
argument_list|<
name|Index
argument_list|>
name|indicesWithShards
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
name|RoutingNode
name|localRoutingNode
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|localNodeId
argument_list|)
decl_stmt|;
if|if
condition|(
name|localRoutingNode
operator|!=
literal|null
condition|)
block|{
comment|// null e.g. if we are not a data node
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|localRoutingNode
control|)
block|{
name|indicesWithShards
operator|.
name|add
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
range|:
name|indicesService
control|)
block|{
name|Index
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
decl_stmt|;
if|if
condition|(
name|indicesWithShards
operator|.
name|contains
argument_list|(
name|index
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// if the cluster change indicates a brand new cluster, we only want
comment|// to remove the in-memory structures for the index and not delete the
comment|// contents on disk because the index will later be re-imported as a
comment|// dangling index
assert|assert
name|state
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|!=
literal|null
operator|||
name|event
operator|.
name|isNewCluster
argument_list|()
operator|:
literal|"index "
operator|+
name|index
operator|+
literal|" does not exist in the cluster state, it should either "
operator|+
literal|"have been deleted or the cluster must be new"
assert|;
name|logger
operator|.
name|debug
argument_list|(
literal|"{} removing index, no shards allocated"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|indicesService
operator|.
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"removing index (no shards allocated)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Notifies master about shards that don't exist but are supposed to be active on this node.      *      * @param state new cluster state      */
DECL|method|failMissingShards
specifier|private
name|void
name|failMissingShards
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|)
block|{
name|RoutingNode
name|localRoutingNode
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localRoutingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
specifier|final
name|ShardRouting
name|shardRouting
range|:
name|localRoutingNode
control|)
block|{
name|ShardId
name|shardId
init|=
name|shardRouting
operator|.
name|shardId
argument_list|()
decl_stmt|;
if|if
condition|(
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|==
literal|false
operator|&&
name|failedShardsCache
operator|.
name|containsKey
argument_list|(
name|shardId
argument_list|)
operator|==
literal|false
operator|&&
name|indicesService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// the master thinks we are active, but we don't have this shard at all, mark it as failed
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
literal|"master marked shard as active, but shard has not been created, mark shard as failed"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node.      * Also removes shards where the recovery source node has changed.      * This method does not delete the shard data.      *      * @param state new cluster state      */
DECL|method|removeShards
specifier|private
name|void
name|removeShards
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|)
block|{
specifier|final
name|RoutingTable
name|routingTable
init|=
name|state
operator|.
name|routingTable
argument_list|()
decl_stmt|;
specifier|final
name|DiscoveryNodes
name|nodes
init|=
name|state
operator|.
name|nodes
argument_list|()
decl_stmt|;
specifier|final
name|String
name|localNodeId
init|=
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
decl_stmt|;
assert|assert
name|localNodeId
operator|!=
literal|null
assert|;
comment|// remove shards based on routing nodes (no deletion of data)
name|RoutingNode
name|localRoutingNode
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|localNodeId
argument_list|)
decl_stmt|;
for|for
control|(
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
range|:
name|indicesService
control|)
block|{
for|for
control|(
name|Shard
name|shard
range|:
name|indexService
control|)
block|{
name|ShardRouting
name|currentRoutingEntry
init|=
name|shard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
name|ShardId
name|shardId
init|=
name|currentRoutingEntry
operator|.
name|shardId
argument_list|()
decl_stmt|;
name|ShardRouting
name|newShardRouting
init|=
name|localRoutingNode
operator|==
literal|null
condition|?
literal|null
else|:
name|localRoutingNode
operator|.
name|getByShardId
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|newShardRouting
operator|==
literal|null
operator|||
name|newShardRouting
operator|.
name|isSameAllocation
argument_list|(
name|currentRoutingEntry
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// we can just remove the shard without cleaning it locally, since we will clean it in IndicesStore
comment|// once all shards are allocated
name|logger
operator|.
name|debug
argument_list|(
literal|"{} removing shard (not allocated)"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (not allocated)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// remove shards where recovery source has changed. This re-initializes shards later in createOrUpdateShards
if|if
condition|(
name|newShardRouting
operator|.
name|recoverySource
argument_list|()
operator|!=
literal|null
operator|&&
name|newShardRouting
operator|.
name|recoverySource
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|PEER
condition|)
block|{
name|RecoveryState
name|recoveryState
init|=
name|shard
operator|.
name|recoveryState
argument_list|()
decl_stmt|;
specifier|final
name|DiscoveryNode
name|sourceNode
init|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|logger
argument_list|,
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|newShardRouting
argument_list|)
decl_stmt|;
if|if
condition|(
name|recoveryState
operator|.
name|getSourceNode
argument_list|()
operator|.
name|equals
argument_list|(
name|sourceNode
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|recoveryTargetService
operator|.
name|cancelRecoveriesForShard
argument_list|(
name|shardId
argument_list|,
literal|"recovery source node changed"
argument_list|)
condition|)
block|{
comment|// getting here means that the shard was still recovering
name|logger
operator|.
name|debug
argument_list|(
literal|"{} removing shard (recovery source changed), current [{}], global [{}], shard [{}])"
argument_list|,
name|shardId
argument_list|,
name|recoveryState
operator|.
name|getSourceNode
argument_list|()
argument_list|,
name|sourceNode
argument_list|,
name|newShardRouting
argument_list|)
expr_stmt|;
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (recovery source node changed)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|createIndices
specifier|private
name|void
name|createIndices
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|)
block|{
comment|// we only create indices for shards that are allocated
name|RoutingNode
name|localRoutingNode
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localRoutingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
comment|// create map of indices to create with shards to fail if index creation fails
specifier|final
name|Map
argument_list|<
name|Index
argument_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|indicesToCreate
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|localRoutingNode
control|)
block|{
if|if
condition|(
name|failedShardsCache
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
specifier|final
name|Index
name|index
init|=
name|shardRouting
operator|.
name|index
argument_list|()
decl_stmt|;
if|if
condition|(
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
operator|==
literal|null
condition|)
block|{
name|indicesToCreate
operator|.
name|computeIfAbsent
argument_list|(
name|index
argument_list|,
name|k
lambda|->
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Index
argument_list|,
name|List
argument_list|<
name|ShardRouting
argument_list|>
argument_list|>
name|entry
range|:
name|indicesToCreate
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|Index
name|index
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|state
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] creating index"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
init|=
literal|null
decl_stmt|;
try|try
block|{
name|indexService
operator|=
name|indicesService
operator|.
name|createIndex
argument_list|(
name|nodeServicesProvider
argument_list|,
name|indexMetaData
argument_list|,
name|buildInIndexListener
argument_list|,
name|globalCheckpointSyncer
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexService
operator|.
name|updateMapping
argument_list|(
name|indexMetaData
argument_list|)
operator|&&
name|sendRefreshMapping
condition|)
block|{
name|nodeMappingRefreshAction
operator|.
name|nodeMappingRefresh
argument_list|(
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|,
operator|new
name|NodeMappingRefreshAction
operator|.
name|NodeMappingRefreshRequest
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
specifier|final
name|String
name|failShardReason
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
name|failShardReason
operator|=
literal|"failed to create index"
expr_stmt|;
block|}
else|else
block|{
name|failShardReason
operator|=
literal|"failed to update mapping for index"
expr_stmt|;
name|indicesService
operator|.
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"removing index (mapping update failed)"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|entry
operator|.
name|getValue
argument_list|()
control|)
block|{
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
name|failShardReason
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|updateIndices
specifier|private
name|void
name|updateIndices
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|metaDataChanged
argument_list|()
condition|)
block|{
return|return;
block|}
specifier|final
name|ClusterState
name|state
init|=
name|event
operator|.
name|state
argument_list|()
decl_stmt|;
for|for
control|(
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
range|:
name|indicesService
control|)
block|{
specifier|final
name|Index
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
decl_stmt|;
specifier|final
name|IndexMetaData
name|currentIndexMetaData
init|=
name|indexService
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getIndexMetaData
argument_list|()
decl_stmt|;
specifier|final
name|IndexMetaData
name|newIndexMetaData
init|=
name|state
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
assert|assert
name|newIndexMetaData
operator|!=
literal|null
operator|:
literal|"index "
operator|+
name|index
operator|+
literal|" should have been removed by deleteIndices"
assert|;
if|if
condition|(
name|ClusterChangedEvent
operator|.
name|indexMetaDataChanged
argument_list|(
name|currentIndexMetaData
argument_list|,
name|newIndexMetaData
argument_list|)
condition|)
block|{
name|indexService
operator|.
name|updateMetaData
argument_list|(
name|newIndexMetaData
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|indexService
operator|.
name|updateMapping
argument_list|(
name|newIndexMetaData
argument_list|)
operator|&&
name|sendRefreshMapping
condition|)
block|{
name|nodeMappingRefreshAction
operator|.
name|nodeMappingRefresh
argument_list|(
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|,
operator|new
name|NodeMappingRefreshAction
operator|.
name|NodeMappingRefreshRequest
argument_list|(
name|newIndexMetaData
operator|.
name|getIndex
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|newIndexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|,
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|indicesService
operator|.
name|removeIndex
argument_list|(
name|indexService
operator|.
name|index
argument_list|()
argument_list|,
literal|"removing index (mapping update failed)"
argument_list|)
expr_stmt|;
comment|// fail shards that would be created or updated by createOrUpdateShards
name|RoutingNode
name|localRoutingNode
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localRoutingNode
operator|!=
literal|null
condition|)
block|{
for|for
control|(
specifier|final
name|ShardRouting
name|shardRouting
range|:
name|localRoutingNode
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|index
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
operator|&&
name|failedShardsCache
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
literal|"failed to update mapping for index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|createOrUpdateShards
specifier|private
name|void
name|createOrUpdateShards
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|)
block|{
name|RoutingNode
name|localRoutingNode
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|localRoutingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|DiscoveryNodes
name|nodes
init|=
name|state
operator|.
name|nodes
argument_list|()
decl_stmt|;
name|RoutingTable
name|routingTable
init|=
name|state
operator|.
name|routingTable
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ShardRouting
name|shardRouting
range|:
name|localRoutingNode
control|)
block|{
name|ShardId
name|shardId
init|=
name|shardRouting
operator|.
name|shardId
argument_list|()
decl_stmt|;
if|if
condition|(
name|failedShardsCache
operator|.
name|containsKey
argument_list|(
name|shardId
argument_list|)
operator|==
literal|false
condition|)
block|{
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|indexService
operator|!=
literal|null
operator|:
literal|"index "
operator|+
name|shardId
operator|.
name|getIndex
argument_list|()
operator|+
literal|" should have been created by createIndices"
assert|;
name|Shard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|==
literal|null
condition|)
block|{
assert|assert
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|:
name|shardRouting
operator|+
literal|" should have been removed by failMissingShards"
assert|;
name|createShard
argument_list|(
name|nodes
argument_list|,
name|routingTable
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|updateShard
argument_list|(
name|nodes
argument_list|,
name|shardRouting
argument_list|,
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|createShard
specifier|private
name|void
name|createShard
parameter_list|(
name|DiscoveryNodes
name|nodes
parameter_list|,
name|RoutingTable
name|routingTable
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
assert|assert
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|:
literal|"only allow shard creation for initializing shard but was "
operator|+
name|shardRouting
assert|;
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|shardRouting
operator|.
name|recoverySource
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|PEER
condition|)
block|{
name|sourceNode
operator|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|logger
argument_list|,
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring initializing shard {} - no source node can be found."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
try|try
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} creating shard"
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
name|RecoveryState
name|recoveryState
init|=
operator|new
name|RecoveryState
argument_list|(
name|shardRouting
argument_list|,
name|nodes
operator|.
name|getLocalNode
argument_list|()
argument_list|,
name|sourceNode
argument_list|)
decl_stmt|;
name|indicesService
operator|.
name|createShard
argument_list|(
name|shardRouting
argument_list|,
name|recoveryState
argument_list|,
name|recoveryTargetService
argument_list|,
operator|new
name|RecoveryListener
argument_list|(
name|shardRouting
argument_list|)
argument_list|,
name|repositoriesService
argument_list|,
name|nodeServicesProvider
argument_list|,
name|failedShardHandler
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexShardAlreadyExistsException
name|e
parameter_list|)
block|{
comment|// ignore this, the method call can happen several times
name|logger
operator|.
name|debug
argument_list|(
literal|"Trying to create shard that already exists"
argument_list|,
name|e
argument_list|)
expr_stmt|;
assert|assert
literal|false
assert|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
literal|true
argument_list|,
literal|"failed to create shard"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|updateShard
specifier|private
name|void
name|updateShard
parameter_list|(
name|DiscoveryNodes
name|nodes
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|,
name|Shard
name|shard
parameter_list|)
block|{
specifier|final
name|ShardRouting
name|currentRoutingEntry
init|=
name|shard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
assert|assert
name|currentRoutingEntry
operator|.
name|isSameAllocation
argument_list|(
name|shardRouting
argument_list|)
operator|:
literal|"local shard has a different allocation id but wasn't cleaning by removeShards. "
operator|+
literal|"cluster state: "
operator|+
name|shardRouting
operator|+
literal|" local: "
operator|+
name|currentRoutingEntry
assert|;
try|try
block|{
name|shard
operator|.
name|updateRoutingEntry
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
literal|true
argument_list|,
literal|"failed updating shard routing entry"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|IndexShardState
name|state
init|=
name|shard
operator|.
name|state
argument_list|()
decl_stmt|;
if|if
condition|(
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|&&
operator|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
operator|)
condition|)
block|{
comment|// the master thinks we are initializing, but we are already started or on POST_RECOVERY and waiting
comment|// for master to confirm a shard started message (either master failover, or a cluster event before
comment|// we managed to tell the master we started), mark us as started
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"{} master marked shard as initializing, but shard has state [{}], resending shard started to {}"
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|state
argument_list|,
name|nodes
operator|.
name|getMasterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|+
literal|" marked shard as initializing, but shard state is ["
operator|+
name|state
operator|+
literal|"], mark shard as started"
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard      * routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to      * check if its needed or not.      */
DECL|method|findSourceNodeForPeerRecovery
specifier|private
specifier|static
name|DiscoveryNode
name|findSourceNodeForPeerRecovery
parameter_list|(
name|Logger
name|logger
parameter_list|,
name|RoutingTable
name|routingTable
parameter_list|,
name|DiscoveryNodes
name|nodes
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|ShardRouting
name|primary
init|=
name|routingTable
operator|.
name|shardRoutingTable
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
operator|.
name|primaryShard
argument_list|()
decl_stmt|;
comment|// only recover from started primary, if we can't find one, we will do it next round
if|if
condition|(
name|primary
operator|.
name|active
argument_list|()
condition|)
block|{
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|primary
operator|.
name|currentNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node because primary shard {} is assigned to an unknown node."
argument_list|,
name|primary
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node because primary shard {} is not active."
argument_list|,
name|primary
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find relocation source node for shard {} because it is assigned to an unknown node [{}]."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"trying to find source node for peer recovery when routing state means no peer recovery: "
operator|+
name|shardRouting
argument_list|)
throw|;
block|}
return|return
name|sourceNode
return|;
block|}
DECL|class|RecoveryListener
specifier|private
class|class
name|RecoveryListener
implements|implements
name|PeerRecoveryTargetService
operator|.
name|RecoveryListener
block|{
DECL|field|shardRouting
specifier|private
specifier|final
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|method|RecoveryListener
specifier|private
name|RecoveryListener
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
name|this
operator|.
name|shardRouting
operator|=
name|shardRouting
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onRecoveryDone
specifier|public
name|void
name|onRecoveryDone
parameter_list|(
name|RecoveryState
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|getRecoverySource
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|SNAPSHOT
condition|)
block|{
name|SnapshotRecoverySource
name|snapshotRecoverySource
init|=
operator|(
name|SnapshotRecoverySource
operator|)
name|state
operator|.
name|getRecoverySource
argument_list|()
decl_stmt|;
name|restoreService
operator|.
name|indexShardRestoreCompleted
argument_list|(
name|snapshotRecoverySource
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
literal|"after "
operator|+
name|state
operator|.
name|getRecoverySource
argument_list|()
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onRecoveryFailure
specifier|public
name|void
name|onRecoveryFailure
parameter_list|(
name|RecoveryState
name|state
parameter_list|,
name|RecoveryFailedException
name|e
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|)
block|{
if|if
condition|(
name|state
operator|.
name|getRecoverySource
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|Type
operator|.
name|SNAPSHOT
condition|)
block|{
try|try
block|{
if|if
condition|(
name|Lucene
operator|.
name|isCorruptionException
argument_list|(
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
condition|)
block|{
name|SnapshotRecoverySource
name|snapshotRecoverySource
init|=
operator|(
name|SnapshotRecoverySource
operator|)
name|state
operator|.
name|getRecoverySource
argument_list|()
decl_stmt|;
name|restoreService
operator|.
name|failRestore
argument_list|(
name|snapshotRecoverySource
operator|.
name|snapshot
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|inner
parameter_list|)
block|{
name|e
operator|.
name|addSuppressed
argument_list|(
name|inner
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|handleRecoveryFailure
argument_list|(
name|shardRouting
argument_list|,
name|sendShardFailure
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|handleRecoveryFailure
argument_list|(
name|shardRouting
argument_list|,
name|sendShardFailure
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|handleRecoveryFailure
specifier|private
specifier|synchronized
name|void
name|handleRecoveryFailure
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|Exception
name|failure
parameter_list|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|sendShardFailure
argument_list|,
literal|"failed recovery"
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
DECL|method|failAndRemoveShard
specifier|private
name|void
name|failAndRemoveShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Exception
name|failure
parameter_list|)
block|{
try|try
block|{
name|AllocatedIndex
argument_list|<
name|?
extends|extends
name|Shard
argument_list|>
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|!=
literal|null
condition|)
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|ShardNotFoundException
name|e
parameter_list|)
block|{
comment|// the node got closed on us, ignore it
block|}
catch|catch
parameter_list|(
name|Exception
name|inner
parameter_list|)
block|{
name|inner
operator|.
name|addSuppressed
argument_list|(
name|failure
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}][{}] failed to remove shard after failure ([{}])"
argument_list|,
name|shardRouting
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sendShardFailure
condition|)
block|{
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
name|message
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sendFailShard
specifier|private
name|void
name|sendFailShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Exception
name|failure
parameter_list|)
block|{
try|try
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}] marking and sending shard failed due to [{}]"
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|,
name|failure
argument_list|)
expr_stmt|;
name|failedShardsCache
operator|.
name|put
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|localShardFailed
argument_list|(
name|shardRouting
argument_list|,
name|message
argument_list|,
name|failure
argument_list|,
name|SHARD_STATE_ACTION_LISTENER
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|inner
parameter_list|)
block|{
if|if
condition|(
name|failure
operator|!=
literal|null
condition|)
name|inner
operator|.
name|addSuppressed
argument_list|(
name|failure
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"[{}][{}] failed to mark shard as failed (because of [{}])"
argument_list|,
name|shardRouting
operator|.
name|getIndexName
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FailedShardHandler
specifier|private
class|class
name|FailedShardHandler
implements|implements
name|Callback
argument_list|<
name|IndexShard
operator|.
name|ShardFailure
argument_list|>
block|{
annotation|@
name|Override
DECL|method|handle
specifier|public
name|void
name|handle
parameter_list|(
specifier|final
name|IndexShard
operator|.
name|ShardFailure
name|shardFailure
parameter_list|)
block|{
specifier|final
name|ShardRouting
name|shardRouting
init|=
name|shardFailure
operator|.
name|routing
decl_stmt|;
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
synchronized|synchronized
init|(
name|IndicesClusterStateService
operator|.
name|this
init|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
literal|true
argument_list|,
literal|"shard failure, reason ["
operator|+
name|shardFailure
operator|.
name|reason
operator|+
literal|"]"
argument_list|,
name|shardFailure
operator|.
name|cause
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|interface|Shard
specifier|public
interface|interface
name|Shard
block|{
comment|/**          * Returns the shard id of this shard.          */
DECL|method|shardId
name|ShardId
name|shardId
parameter_list|()
function_decl|;
comment|/**          * Returns the latest cluster routing entry received with this shard.          */
DECL|method|routingEntry
name|ShardRouting
name|routingEntry
parameter_list|()
function_decl|;
comment|/**          * Returns the latest internal shard state.          */
DECL|method|state
name|IndexShardState
name|state
parameter_list|()
function_decl|;
comment|/**          * Returns the recovery state associated with this shard.          */
DECL|method|recoveryState
name|RecoveryState
name|recoveryState
parameter_list|()
function_decl|;
comment|/**          * Updates the shards routing entry. This mutate the shards internal state depending          * on the changes that get introduced by the new routing value. This method will persist shard level metadata.          *          * @throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted          * @throws IOException                  if shard state could not be persisted          */
DECL|method|updateRoutingEntry
name|void
name|updateRoutingEntry
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
throws|throws
name|IOException
function_decl|;
block|}
DECL|interface|AllocatedIndex
specifier|public
interface|interface
name|AllocatedIndex
parameter_list|<
name|T
extends|extends
name|Shard
parameter_list|>
extends|extends
name|Iterable
argument_list|<
name|T
argument_list|>
extends|,
name|IndexComponent
block|{
comment|/**          * Returns the index settings of this index.          */
DECL|method|getIndexSettings
name|IndexSettings
name|getIndexSettings
parameter_list|()
function_decl|;
comment|/**          * Updates the meta data of this index. Changes become visible through {@link #getIndexSettings()}          */
DECL|method|updateMetaData
name|void
name|updateMetaData
parameter_list|(
name|IndexMetaData
name|indexMetaData
parameter_list|)
function_decl|;
comment|/**          * Checks if index requires refresh from master.          */
DECL|method|updateMapping
name|boolean
name|updateMapping
parameter_list|(
name|IndexMetaData
name|indexMetaData
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**          * Returns shard with given id.          */
DECL|method|getShardOrNull
annotation|@
name|Nullable
name|T
name|getShardOrNull
parameter_list|(
name|int
name|shardId
parameter_list|)
function_decl|;
comment|/**          * Removes shard with given id.          */
DECL|method|removeShard
name|void
name|removeShard
parameter_list|(
name|int
name|shardId
parameter_list|,
name|String
name|message
parameter_list|)
function_decl|;
block|}
DECL|interface|AllocatedIndices
specifier|public
interface|interface
name|AllocatedIndices
parameter_list|<
name|T
extends|extends
name|Shard
parameter_list|,
name|U
extends|extends
name|AllocatedIndex
parameter_list|<
name|T
parameter_list|>
parameter_list|>
extends|extends
name|Iterable
argument_list|<
name|U
argument_list|>
block|{
comment|/**          * Creates a new {@link IndexService} for the given metadata.          * @param indexMetaData the index metadata to create the index for          * @param builtInIndexListener a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with          *                             the per-index listeners          * @throws IndexAlreadyExistsException if the index already exists.          */
DECL|method|createIndex
name|U
name|createIndex
parameter_list|(
name|NodeServicesProvider
name|nodeServicesProvider
parameter_list|,
name|IndexMetaData
name|indexMetaData
parameter_list|,
name|List
argument_list|<
name|IndexEventListener
argument_list|>
name|builtInIndexListener
parameter_list|,
name|Consumer
argument_list|<
name|ShardId
argument_list|>
name|globalCheckpointSyncer
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**          * Verify that the contents on disk for the given index is deleted; if not, delete the contents.          * This method assumes that an index is already deleted in the cluster state and/or explicitly          * through index tombstones.          * @param index {@code Index} to make sure its deleted from disk          * @param clusterState {@code ClusterState} to ensure the index is not part of it          * @return IndexMetaData for the index loaded from disk          */
DECL|method|verifyIndexIsDeleted
name|IndexMetaData
name|verifyIndexIsDeleted
parameter_list|(
name|Index
name|index
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|)
function_decl|;
comment|/**          * Deletes the given index. Persistent parts of the index          * like the shards files, state and transaction logs are removed once all resources are released.          *          * Equivalent to {@link #removeIndex(Index, String)} but fires          * different lifecycle events to ensure pending resources of this index are immediately removed.          * @param index the index to delete          * @param reason the high level reason causing this delete          */
DECL|method|deleteIndex
name|void
name|deleteIndex
parameter_list|(
name|Index
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
function_decl|;
comment|/**          * Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index          * but does not deal with in-memory structures. For those call {@link #deleteIndex(Index, String)}          */
DECL|method|deleteUnassignedIndex
name|void
name|deleteUnassignedIndex
parameter_list|(
name|String
name|reason
parameter_list|,
name|IndexMetaData
name|metaData
parameter_list|,
name|ClusterState
name|clusterState
parameter_list|)
function_decl|;
comment|/**          * Removes the given index from this service and releases all associated resources. Persistent parts of the index          * like the shards files, state and transaction logs are kept around in the case of a disaster recovery.          * @param index the index to remove          * @param reason  the high level reason causing this removal          */
DECL|method|removeIndex
name|void
name|removeIndex
parameter_list|(
name|Index
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
function_decl|;
comment|/**          * Returns an IndexService for the specified index if exists otherwise returns<code>null</code>.          */
DECL|method|indexService
annotation|@
name|Nullable
name|U
name|indexService
parameter_list|(
name|Index
name|index
parameter_list|)
function_decl|;
comment|/**          * Creates shard for the specified shard routing and starts recovery,          */
DECL|method|createShard
name|T
name|createShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|,
name|PeerRecoveryTargetService
name|recoveryTargetService
parameter_list|,
name|PeerRecoveryTargetService
operator|.
name|RecoveryListener
name|recoveryListener
parameter_list|,
name|RepositoriesService
name|repositoriesService
parameter_list|,
name|NodeServicesProvider
name|nodeServicesProvider
parameter_list|,
name|Callback
argument_list|<
name|IndexShard
operator|.
name|ShardFailure
argument_list|>
name|onShardFailure
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**          * Returns shard for the specified id if it exists otherwise returns<code>null</code>.          */
DECL|method|getShardOrNull
specifier|default
name|T
name|getShardOrNull
parameter_list|(
name|ShardId
name|shardId
parameter_list|)
block|{
name|U
name|indexRef
init|=
name|indexService
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexRef
operator|!=
literal|null
condition|)
block|{
return|return
name|indexRef
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|processPendingDeletes
name|void
name|processPendingDeletes
parameter_list|(
name|Index
name|index
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|,
name|TimeValue
name|timeValue
parameter_list|)
throws|throws
name|IOException
throws|,
name|InterruptedException
throws|,
name|ShardLockObtainFailedException
function_decl|;
block|}
block|}
end_class

end_unit

