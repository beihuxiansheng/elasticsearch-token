begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.shard
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CheckIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|KeepOnlyLastCommitDeletionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SnapshotDeletionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryCachingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|UsageTrackingQueryCachingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ActionListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|flush
operator|.
name|FlushRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|forcemerge
operator|.
name|ForceMergeRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|upgrade
operator|.
name|post
operator|.
name|UpgradeRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|index
operator|.
name|IndexRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MappingMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RecoverySource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RecoverySource
operator|.
name|SnapshotRecoverySource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Booleans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lease
operator|.
name|Releasable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lease
operator|.
name|Releasables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|LoggerMessageFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|metrics
operator|.
name|MeanMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|BigArrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|Callback
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AsyncIOProcessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|Index
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|VersionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|IndexCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|bitset
operator|.
name|ShardBitsetFilterCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|request
operator|.
name|ShardRequestCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|codec
operator|.
name|CodecService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|CommitStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|Engine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|EngineClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|EngineConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|EngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|EngineFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|InternalEngineFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|RefreshFailedEngineException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|Segment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|SegmentsStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|FieldDataStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldDataService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|ShardFieldData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|flush
operator|.
name|FlushStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|get
operator|.
name|GetStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|get
operator|.
name|ShardGetService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|DocumentMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|DocumentMapperForType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MappedFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperParsingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|ParsedDocument
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|SourceToParse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|Uid
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|merge
operator|.
name|MergeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|recovery
operator|.
name|RecoveryStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|refresh
operator|.
name|RefreshStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|search
operator|.
name|stats
operator|.
name|SearchStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|search
operator|.
name|stats
operator|.
name|ShardSearchStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|similarity
operator|.
name|SimilarityService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
operator|.
name|MetadataSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|Translog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|warmer
operator|.
name|ShardIndexWarmerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|warmer
operator|.
name|WarmerStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndexingMemoryController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|cluster
operator|.
name|IndicesClusterStateService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|PeerRecoveryTargetService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoriesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|Repository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|suggest
operator|.
name|completion
operator|.
name|CompletionFieldStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|suggest
operator|.
name|completion
operator|.
name|CompletionStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|suggest
operator|.
name|completion2x
operator|.
name|Completion090PostingsFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FileNotFoundException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedByInterruptException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|NoSuchFileException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|EnumSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_class
DECL|class|IndexShard
specifier|public
class|class
name|IndexShard
extends|extends
name|AbstractIndexShardComponent
implements|implements
name|IndicesClusterStateService
operator|.
name|Shard
block|{
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|mapperService
specifier|private
specifier|final
name|MapperService
name|mapperService
decl_stmt|;
DECL|field|indexCache
specifier|private
specifier|final
name|IndexCache
name|indexCache
decl_stmt|;
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|internalIndexingStats
specifier|private
specifier|final
name|InternalIndexingStats
name|internalIndexingStats
decl_stmt|;
DECL|field|searchStats
specifier|private
specifier|final
name|ShardSearchStats
name|searchStats
init|=
operator|new
name|ShardSearchStats
argument_list|()
decl_stmt|;
DECL|field|getService
specifier|private
specifier|final
name|ShardGetService
name|getService
decl_stmt|;
DECL|field|shardWarmerService
specifier|private
specifier|final
name|ShardIndexWarmerService
name|shardWarmerService
decl_stmt|;
DECL|field|requestCacheStats
specifier|private
specifier|final
name|ShardRequestCache
name|requestCacheStats
decl_stmt|;
DECL|field|shardFieldData
specifier|private
specifier|final
name|ShardFieldData
name|shardFieldData
decl_stmt|;
DECL|field|indexFieldDataService
specifier|private
specifier|final
name|IndexFieldDataService
name|indexFieldDataService
decl_stmt|;
DECL|field|shardBitsetFilterCache
specifier|private
specifier|final
name|ShardBitsetFilterCache
name|shardBitsetFilterCache
decl_stmt|;
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|checkIndexOnStartup
specifier|private
specifier|final
name|String
name|checkIndexOnStartup
decl_stmt|;
DECL|field|codecService
specifier|private
specifier|final
name|CodecService
name|codecService
decl_stmt|;
DECL|field|warmer
specifier|private
specifier|final
name|Engine
operator|.
name|Warmer
name|warmer
decl_stmt|;
DECL|field|deletionPolicy
specifier|private
specifier|final
name|SnapshotDeletionPolicy
name|deletionPolicy
decl_stmt|;
DECL|field|similarityService
specifier|private
specifier|final
name|SimilarityService
name|similarityService
decl_stmt|;
DECL|field|translogConfig
specifier|private
specifier|final
name|TranslogConfig
name|translogConfig
decl_stmt|;
DECL|field|indexEventListener
specifier|private
specifier|final
name|IndexEventListener
name|indexEventListener
decl_stmt|;
DECL|field|cachingPolicy
specifier|private
specifier|final
name|QueryCachingPolicy
name|cachingPolicy
decl_stmt|;
comment|/**      * How many bytes we are currently moving to disk, via either IndexWriter.flush or refresh.  IndexingMemoryController polls this      * across all shards to decide if throttling is necessary because moving bytes to disk is falling behind vs incoming documents      * being indexed/deleted.      */
DECL|field|writingBytes
specifier|private
specifier|final
name|AtomicLong
name|writingBytes
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
DECL|field|searchOperationListener
specifier|private
specifier|final
name|SearchOperationListener
name|searchOperationListener
decl_stmt|;
DECL|field|shardRouting
specifier|protected
specifier|volatile
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|field|state
specifier|protected
specifier|volatile
name|IndexShardState
name|state
decl_stmt|;
DECL|field|primaryTerm
specifier|protected
specifier|volatile
name|long
name|primaryTerm
decl_stmt|;
DECL|field|currentEngineReference
specifier|protected
specifier|final
name|AtomicReference
argument_list|<
name|Engine
argument_list|>
name|currentEngineReference
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|engineFactory
specifier|protected
specifier|final
name|EngineFactory
name|engineFactory
decl_stmt|;
DECL|field|indexingOperationListeners
specifier|private
specifier|final
name|IndexingOperationListener
name|indexingOperationListeners
decl_stmt|;
annotation|@
name|Nullable
DECL|field|recoveryState
specifier|private
name|RecoveryState
name|recoveryState
decl_stmt|;
DECL|field|recoveryStats
specifier|private
specifier|final
name|RecoveryStats
name|recoveryStats
init|=
operator|new
name|RecoveryStats
argument_list|()
decl_stmt|;
DECL|field|refreshMetric
specifier|private
specifier|final
name|MeanMetric
name|refreshMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|field|flushMetric
specifier|private
specifier|final
name|MeanMetric
name|flushMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|field|shardEventListener
specifier|private
specifier|final
name|ShardEventListener
name|shardEventListener
init|=
operator|new
name|ShardEventListener
argument_list|()
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|ShardPath
name|path
decl_stmt|;
DECL|field|indexShardOperationsLock
specifier|private
specifier|final
name|IndexShardOperationsLock
name|indexShardOperationsLock
decl_stmt|;
DECL|field|readAllowedStates
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|IndexShardState
argument_list|>
name|readAllowedStates
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|IndexShardState
operator|.
name|STARTED
argument_list|,
name|IndexShardState
operator|.
name|RELOCATED
argument_list|,
name|IndexShardState
operator|.
name|POST_RECOVERY
argument_list|)
decl_stmt|;
comment|// for primaries, we only allow to write when actually started (so the cluster has decided we started)
comment|// in case we have a relocation of a primary, we also allow to write after phase 2 completed, where the shard may be
comment|// in state RECOVERING or POST_RECOVERY. After a primary has been marked as RELOCATED, we only allow writes to the relocation target
comment|// which can be either in POST_RECOVERY or already STARTED (this prevents writing concurrently to two primaries).
DECL|field|writeAllowedStatesForPrimary
specifier|public
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|IndexShardState
argument_list|>
name|writeAllowedStatesForPrimary
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|IndexShardState
operator|.
name|RECOVERING
argument_list|,
name|IndexShardState
operator|.
name|POST_RECOVERY
argument_list|,
name|IndexShardState
operator|.
name|STARTED
argument_list|)
decl_stmt|;
comment|// replication is also allowed while recovering, since we index also during recovery to replicas and rely on version checks to make sure its consistent
comment|// a relocated shard can also be target of a replication if the relocation target has not been marked as active yet and is syncing it's changes back to the relocation source
DECL|field|writeAllowedStatesForReplica
specifier|private
specifier|static
specifier|final
name|EnumSet
argument_list|<
name|IndexShardState
argument_list|>
name|writeAllowedStatesForReplica
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|IndexShardState
operator|.
name|RECOVERING
argument_list|,
name|IndexShardState
operator|.
name|POST_RECOVERY
argument_list|,
name|IndexShardState
operator|.
name|STARTED
argument_list|,
name|IndexShardState
operator|.
name|RELOCATED
argument_list|)
decl_stmt|;
DECL|field|searcherWrapper
specifier|private
specifier|final
name|IndexSearcherWrapper
name|searcherWrapper
decl_stmt|;
comment|/**      * True if this shard is still indexing (recently) and false if we've been idle for long enough (as periodically checked by {@link      * IndexingMemoryController}).      */
DECL|field|active
specifier|private
specifier|final
name|AtomicBoolean
name|active
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|/**      * Allows for the registration of listeners that are called when a change becomes visible for search. This is nullable because      * {@linkplain ShadowIndexShard} doesn't support this.      */
annotation|@
name|Nullable
DECL|field|refreshListeners
specifier|private
specifier|final
name|RefreshListeners
name|refreshListeners
decl_stmt|;
DECL|method|IndexShard
specifier|public
name|IndexShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|,
name|ShardPath
name|path
parameter_list|,
name|Store
name|store
parameter_list|,
name|IndexCache
name|indexCache
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|SimilarityService
name|similarityService
parameter_list|,
name|IndexFieldDataService
name|indexFieldDataService
parameter_list|,
annotation|@
name|Nullable
name|EngineFactory
name|engineFactory
parameter_list|,
name|IndexEventListener
name|indexEventListener
parameter_list|,
name|IndexSearcherWrapper
name|indexSearcherWrapper
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|BigArrays
name|bigArrays
parameter_list|,
name|Engine
operator|.
name|Warmer
name|warmer
parameter_list|,
name|List
argument_list|<
name|SearchOperationListener
argument_list|>
name|searchOperationListener
parameter_list|,
name|List
argument_list|<
name|IndexingOperationListener
argument_list|>
name|listeners
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
assert|assert
name|shardRouting
operator|.
name|initializing
argument_list|()
assert|;
name|this
operator|.
name|shardRouting
operator|=
name|shardRouting
expr_stmt|;
specifier|final
name|Settings
name|settings
init|=
name|indexSettings
operator|.
name|getSettings
argument_list|()
decl_stmt|;
name|this
operator|.
name|codecService
operator|=
operator|new
name|CodecService
argument_list|(
name|mapperService
argument_list|,
name|logger
argument_list|)
expr_stmt|;
name|this
operator|.
name|warmer
operator|=
name|warmer
expr_stmt|;
name|this
operator|.
name|deletionPolicy
operator|=
operator|new
name|SnapshotDeletionPolicy
argument_list|(
operator|new
name|KeepOnlyLastCommitDeletionPolicy
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|similarityService
operator|=
name|similarityService
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|store
argument_list|,
literal|"Store must be provided to the index shard"
argument_list|)
expr_stmt|;
name|this
operator|.
name|engineFactory
operator|=
name|engineFactory
operator|==
literal|null
condition|?
operator|new
name|InternalEngineFactory
argument_list|()
else|:
name|engineFactory
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
name|this
operator|.
name|indexEventListener
operator|=
name|indexEventListener
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|mapperService
operator|=
name|mapperService
expr_stmt|;
name|this
operator|.
name|indexCache
operator|=
name|indexCache
expr_stmt|;
name|this
operator|.
name|internalIndexingStats
operator|=
operator|new
name|InternalIndexingStats
argument_list|()
expr_stmt|;
specifier|final
name|List
argument_list|<
name|IndexingOperationListener
argument_list|>
name|listenersList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|listeners
argument_list|)
decl_stmt|;
name|listenersList
operator|.
name|add
argument_list|(
name|internalIndexingStats
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexingOperationListeners
operator|=
operator|new
name|IndexingOperationListener
operator|.
name|CompositeListener
argument_list|(
name|listenersList
argument_list|,
name|logger
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|SearchOperationListener
argument_list|>
name|searchListenersList
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|searchOperationListener
argument_list|)
decl_stmt|;
name|searchListenersList
operator|.
name|add
argument_list|(
name|searchStats
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchOperationListener
operator|=
operator|new
name|SearchOperationListener
operator|.
name|CompositeListener
argument_list|(
name|searchListenersList
argument_list|,
name|logger
argument_list|)
expr_stmt|;
name|this
operator|.
name|getService
operator|=
operator|new
name|ShardGetService
argument_list|(
name|indexSettings
argument_list|,
name|this
argument_list|,
name|mapperService
argument_list|)
expr_stmt|;
name|this
operator|.
name|shardWarmerService
operator|=
operator|new
name|ShardIndexWarmerService
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|requestCacheStats
operator|=
operator|new
name|ShardRequestCache
argument_list|()
expr_stmt|;
name|this
operator|.
name|shardFieldData
operator|=
operator|new
name|ShardFieldData
argument_list|()
expr_stmt|;
name|this
operator|.
name|indexFieldDataService
operator|=
name|indexFieldDataService
expr_stmt|;
name|this
operator|.
name|shardBitsetFilterCache
operator|=
operator|new
name|ShardBitsetFilterCache
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|CREATED
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
comment|/* create engine config */
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [CREATED]"
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkIndexOnStartup
operator|=
name|indexSettings
operator|.
name|getValue
argument_list|(
name|IndexSettings
operator|.
name|INDEX_CHECK_ON_STARTUP
argument_list|)
expr_stmt|;
name|this
operator|.
name|translogConfig
operator|=
operator|new
name|TranslogConfig
argument_list|(
name|shardId
argument_list|,
name|shardPath
argument_list|()
operator|.
name|resolveTranslog
argument_list|()
argument_list|,
name|indexSettings
argument_list|,
name|bigArrays
argument_list|)
expr_stmt|;
comment|// the query cache is a node-level thing, however we want the most popular filters
comment|// to be computed on a per-shard basis
if|if
condition|(
name|IndexModule
operator|.
name|INDEX_QUERY_CACHE_EVERYTHING_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
condition|)
block|{
name|cachingPolicy
operator|=
name|QueryCachingPolicy
operator|.
name|ALWAYS_CACHE
expr_stmt|;
block|}
else|else
block|{
name|cachingPolicy
operator|=
operator|new
name|UsageTrackingQueryCachingPolicy
argument_list|()
expr_stmt|;
block|}
name|indexShardOperationsLock
operator|=
operator|new
name|IndexShardOperationsLock
argument_list|(
name|shardId
argument_list|,
name|logger
argument_list|,
name|threadPool
argument_list|)
expr_stmt|;
name|searcherWrapper
operator|=
name|indexSearcherWrapper
expr_stmt|;
name|primaryTerm
operator|=
name|indexSettings
operator|.
name|getIndexMetaData
argument_list|()
operator|.
name|primaryTerm
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
name|refreshListeners
operator|=
name|buildRefreshListeners
argument_list|()
expr_stmt|;
name|persistMetadata
argument_list|(
name|shardRouting
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|store
specifier|public
name|Store
name|store
parameter_list|()
block|{
return|return
name|this
operator|.
name|store
return|;
block|}
comment|/**      * returns true if this shard supports indexing (i.e., write) operations.      */
DECL|method|canIndex
specifier|public
name|boolean
name|canIndex
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|getService
specifier|public
name|ShardGetService
name|getService
parameter_list|()
block|{
return|return
name|this
operator|.
name|getService
return|;
block|}
DECL|method|shardBitsetFilterCache
specifier|public
name|ShardBitsetFilterCache
name|shardBitsetFilterCache
parameter_list|()
block|{
return|return
name|shardBitsetFilterCache
return|;
block|}
DECL|method|indexFieldDataService
specifier|public
name|IndexFieldDataService
name|indexFieldDataService
parameter_list|()
block|{
return|return
name|indexFieldDataService
return|;
block|}
DECL|method|mapperService
specifier|public
name|MapperService
name|mapperService
parameter_list|()
block|{
return|return
name|mapperService
return|;
block|}
DECL|method|getSearchOperationListener
specifier|public
name|SearchOperationListener
name|getSearchOperationListener
parameter_list|()
block|{
return|return
name|this
operator|.
name|searchOperationListener
return|;
block|}
DECL|method|warmerService
specifier|public
name|ShardIndexWarmerService
name|warmerService
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardWarmerService
return|;
block|}
DECL|method|requestCache
specifier|public
name|ShardRequestCache
name|requestCache
parameter_list|()
block|{
return|return
name|this
operator|.
name|requestCacheStats
return|;
block|}
DECL|method|fieldData
specifier|public
name|ShardFieldData
name|fieldData
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardFieldData
return|;
block|}
comment|/**      * Returns the primary term the index shard is on. See {@link org.elasticsearch.cluster.metadata.IndexMetaData#primaryTerm(int)}      */
DECL|method|getPrimaryTerm
specifier|public
name|long
name|getPrimaryTerm
parameter_list|()
block|{
return|return
name|this
operator|.
name|primaryTerm
return|;
block|}
comment|/**      * notifies the shard of an increase in the primary term      */
DECL|method|updatePrimaryTerm
specifier|public
name|void
name|updatePrimaryTerm
parameter_list|(
specifier|final
name|long
name|newTerm
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|newTerm
operator|!=
name|primaryTerm
condition|)
block|{
comment|// Note that due to cluster state batching an initializing primary shard term can failed and re-assigned
comment|// in one state causing it's term to be incremented. Note that if both current shard state and new
comment|// shard state are initializing, we could replace the current shard and reinitialize it. It is however
comment|// possible that this shard is being started. This can happen if:
comment|// 1) Shard is post recovery and sends shard started to the master
comment|// 2) Node gets disconnected and rejoins
comment|// 3) Master assigns the shard back to the node
comment|// 4) Master processes the shard started and starts the shard
comment|// 5) The node process the cluster state where the shard is both started and primary term is incremented.
comment|//
comment|// We could fail the shard in that case, but this will cause it to be removed from the insync allocations list
comment|// potentially preventing re-allocation.
assert|assert
name|shardRouting
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|||
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|==
literal|false
operator|:
literal|"a started primary shard should never update it's term. shard: "
operator|+
name|shardRouting
operator|+
literal|" current term ["
operator|+
name|primaryTerm
operator|+
literal|"] new term ["
operator|+
name|newTerm
operator|+
literal|"]"
assert|;
assert|assert
name|newTerm
operator|>
name|primaryTerm
operator|:
literal|"primary terms can only go up. current ["
operator|+
name|primaryTerm
operator|+
literal|"], new ["
operator|+
name|newTerm
operator|+
literal|"]"
assert|;
name|primaryTerm
operator|=
name|newTerm
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns the latest cluster routing entry received with this shard.      */
annotation|@
name|Override
DECL|method|routingEntry
specifier|public
name|ShardRouting
name|routingEntry
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardRouting
return|;
block|}
DECL|method|getQueryCachingPolicy
specifier|public
name|QueryCachingPolicy
name|getQueryCachingPolicy
parameter_list|()
block|{
return|return
name|cachingPolicy
return|;
block|}
comment|/**      * Updates the shards routing entry. This mutate the shards internal state depending      * on the changes that get introduced by the new routing value. This method will persist shard level metadata.      *      * @throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted      * @throws IOException                  if shard state could not be persisted      */
DECL|method|updateRoutingEntry
specifier|public
name|void
name|updateRoutingEntry
parameter_list|(
specifier|final
name|ShardRouting
name|newRouting
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|ShardRouting
name|currentRouting
decl_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|currentRouting
operator|=
name|this
operator|.
name|shardRouting
expr_stmt|;
if|if
condition|(
operator|!
name|newRouting
operator|.
name|shardId
argument_list|()
operator|.
name|equals
argument_list|(
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Trying to set a routing entry with shardId "
operator|+
name|newRouting
operator|.
name|shardId
argument_list|()
operator|+
literal|" on a shard with shardId "
operator|+
name|shardId
argument_list|()
operator|+
literal|""
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|currentRouting
operator|==
literal|null
operator|||
name|newRouting
operator|.
name|isSameAllocation
argument_list|(
name|currentRouting
argument_list|)
operator|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Trying to set a routing entry with a different allocation. Current "
operator|+
name|currentRouting
operator|+
literal|", new "
operator|+
name|newRouting
argument_list|)
throw|;
block|}
if|if
condition|(
name|currentRouting
operator|!=
literal|null
operator|&&
name|currentRouting
operator|.
name|primary
argument_list|()
operator|&&
name|newRouting
operator|.
name|primary
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"illegal state: trying to move shard from primary mode to replica mode. Current "
operator|+
name|currentRouting
operator|+
literal|", new "
operator|+
name|newRouting
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
operator|&&
name|newRouting
operator|.
name|active
argument_list|()
condition|)
block|{
assert|assert
name|currentRouting
operator|.
name|active
argument_list|()
operator|==
literal|false
operator|:
literal|"we are in POST_RECOVERY, but our shard routing is active "
operator|+
name|currentRouting
assert|;
comment|// we want to refresh *before* we move to internal STARTED state
try|try
block|{
name|getEngine
argument_list|()
operator|.
name|refresh
argument_list|(
literal|"cluster_state_started"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to refresh due to move to cluster wide started"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|STARTED
argument_list|,
literal|"global state is ["
operator|+
name|newRouting
operator|.
name|state
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|&&
operator|(
name|newRouting
operator|.
name|relocating
argument_list|()
operator|==
literal|false
operator|||
name|newRouting
operator|.
name|equalsIgnoringMetaData
argument_list|(
name|currentRouting
argument_list|)
operator|==
literal|false
operator|)
condition|)
block|{
comment|// if the shard is marked as RELOCATED we have to fail when any changes in shard routing occur (e.g. due to recovery
comment|// failure / cancellation). The reason is that at the moment we cannot safely move back to STARTED without risking two
comment|// active primaries.
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|()
argument_list|,
literal|"Shard is marked as relocated, cannot safely move to state "
operator|+
name|newRouting
operator|.
name|state
argument_list|()
argument_list|)
throw|;
block|}
name|this
operator|.
name|shardRouting
operator|=
name|newRouting
expr_stmt|;
name|persistMetadata
argument_list|(
name|newRouting
argument_list|,
name|currentRouting
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentRouting
operator|!=
literal|null
operator|&&
name|currentRouting
operator|.
name|active
argument_list|()
operator|==
literal|false
operator|&&
name|newRouting
operator|.
name|active
argument_list|()
condition|)
block|{
name|indexEventListener
operator|.
name|afterIndexShardStarted
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newRouting
operator|.
name|equals
argument_list|(
name|currentRouting
argument_list|)
operator|==
literal|false
condition|)
block|{
name|indexEventListener
operator|.
name|shardRoutingChanged
argument_list|(
name|this
argument_list|,
name|currentRouting
argument_list|,
name|newRouting
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Marks the shard as recovering based on a recovery state, fails with exception is recovering is not allowed to be set.      */
DECL|method|markAsRecovering
specifier|public
name|IndexShardState
name|markAsRecovering
parameter_list|(
name|String
name|reason
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardRecoveringException
throws|,
name|IndexShardClosedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardRecoveringException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IndexShardRecoveringException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
name|this
operator|.
name|recoveryState
operator|=
name|recoveryState
expr_stmt|;
return|return
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|RECOVERING
argument_list|,
name|reason
argument_list|)
return|;
block|}
block|}
DECL|method|relocated
specifier|public
name|void
name|relocated
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
throws|,
name|InterruptedException
block|{
assert|assert
name|shardRouting
operator|.
name|primary
argument_list|()
operator|:
literal|"only primaries can be marked as relocated: "
operator|+
name|shardRouting
assert|;
try|try
block|{
name|indexShardOperationsLock
operator|.
name|blockOperations
argument_list|(
literal|30
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|,
parameter_list|()
lambda|->
block|{
comment|// no shard operation locks are being held here, move state from started to relocated
assert|assert
name|indexShardOperationsLock
operator|.
name|getActiveOperationsCount
argument_list|()
operator|==
literal|0
operator|:
literal|"in-flight operations in progress while moving shard state to relocated"
assert|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
comment|// if the master cancelled the recovery, the target will be removed
comment|// and the recovery will stopped.
comment|// However, it is still possible that we concurrently end up here
comment|// and therefore have to protect we don't mark the shard as relocated when
comment|// its shard routing says otherwise.
if|if
condition|(
name|shardRouting
operator|.
name|relocating
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|IndexShardState
operator|.
name|STARTED
argument_list|,
literal|": shard is no longer relocating "
operator|+
name|shardRouting
argument_list|)
throw|;
block|}
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|RELOCATED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|TimeoutException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"timed out waiting for relocation hand-off to complete"
argument_list|)
expr_stmt|;
comment|// This is really bad as ongoing replication operations are preventing this shard from completing relocation hand-off.
comment|// Fail primary relocation source and target shards.
name|failShard
argument_list|(
literal|"timed out waiting for relocation hand-off to complete"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|()
argument_list|,
literal|"timed out waiting for relocation hand-off to complete"
argument_list|)
throw|;
block|}
block|}
DECL|method|state
specifier|public
name|IndexShardState
name|state
parameter_list|()
block|{
return|return
name|state
return|;
block|}
comment|/**      * Changes the state of the current shard      *      * @param newState the new shard state      * @param reason   the reason for the state change      * @return the previous shard state      */
DECL|method|changeState
specifier|private
name|IndexShardState
name|changeState
parameter_list|(
name|IndexShardState
name|newState
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [{}]"
argument_list|,
name|state
argument_list|,
name|newState
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|IndexShardState
name|previousState
init|=
name|state
decl_stmt|;
name|state
operator|=
name|newState
expr_stmt|;
name|this
operator|.
name|indexEventListener
operator|.
name|indexShardStateChanged
argument_list|(
name|this
argument_list|,
name|previousState
argument_list|,
name|newState
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|previousState
return|;
block|}
DECL|method|prepareIndexOnPrimary
specifier|public
name|Engine
operator|.
name|Operation
name|prepareIndexOnPrimary
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|long
name|autoGeneratedIdTimestamp
parameter_list|,
name|boolean
name|isRetry
parameter_list|)
block|{
try|try
block|{
name|verifyPrimary
argument_list|()
expr_stmt|;
return|return
name|prepareIndex
argument_list|(
name|docMapper
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
argument_list|,
name|source
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|PRIMARY
argument_list|,
name|autoGeneratedIdTimestamp
argument_list|,
name|isRetry
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MapperParsingException
decl||
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
operator|new
name|Engine
operator|.
name|Failure
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|,
name|source
operator|.
name|id
argument_list|()
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|PRIMARY
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
name|e
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|verifyNotClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|prepareIndexOnReplica
specifier|public
name|Engine
operator|.
name|Operation
name|prepareIndexOnReplica
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|long
name|autoGeneratedIdTimestamp
parameter_list|,
name|boolean
name|isRetry
parameter_list|)
block|{
try|try
block|{
name|verifyReplicationTarget
argument_list|()
expr_stmt|;
return|return
name|prepareIndex
argument_list|(
name|docMapper
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
argument_list|,
name|source
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|REPLICA
argument_list|,
name|autoGeneratedIdTimestamp
argument_list|,
name|isRetry
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|MapperParsingException
decl||
name|IllegalArgumentException
name|e
parameter_list|)
block|{
return|return
operator|new
name|Engine
operator|.
name|Failure
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|,
name|source
operator|.
name|id
argument_list|()
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|PRIMARY
argument_list|,
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|,
name|e
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|verifyNotClosed
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
block|}
DECL|method|prepareIndex
specifier|static
name|Engine
operator|.
name|Index
name|prepareIndex
parameter_list|(
name|DocumentMapperForType
name|docMapper
parameter_list|,
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|,
name|long
name|autoGeneratedIdTimestamp
parameter_list|,
name|boolean
name|isRetry
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|docMapper
operator|.
name|getMapping
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|docMapper
operator|.
name|getMapping
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|MappedFieldType
name|uidFieldType
init|=
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|uidMapper
argument_list|()
operator|.
name|fieldType
argument_list|()
decl_stmt|;
name|Query
name|uidQuery
init|=
name|uidFieldType
operator|.
name|termQuery
argument_list|(
name|doc
operator|.
name|uid
argument_list|()
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|Term
name|uid
init|=
name|MappedFieldType
operator|.
name|extractTerm
argument_list|(
name|uidQuery
argument_list|)
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|Index
argument_list|(
name|uid
argument_list|,
name|doc
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|,
name|autoGeneratedIdTimestamp
argument_list|,
name|isRetry
argument_list|)
return|;
block|}
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|Engine
operator|.
name|Operation
name|operation
parameter_list|)
block|{
name|ensureWriteAllowed
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
name|execute
argument_list|(
name|engine
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
DECL|method|execute
specifier|private
name|void
name|execute
parameter_list|(
name|Engine
name|engine
parameter_list|,
name|Engine
operator|.
name|Operation
name|operation
parameter_list|)
block|{
name|active
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|indexingOperationListeners
operator|.
name|preOperation
argument_list|(
name|operation
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
name|operation
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|operation
operator|.
name|operationType
argument_list|()
condition|)
block|{
case|case
name|INDEX
case|:
name|engine
operator|.
name|index
argument_list|(
operator|(
operator|(
name|Engine
operator|.
name|Index
operator|)
name|operation
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|engine
operator|.
name|delete
argument_list|(
operator|(
operator|(
name|Engine
operator|.
name|Delete
operator|)
name|operation
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|operation
operator|.
name|endTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|indexingOperationListeners
operator|.
name|postOperation
argument_list|(
name|operation
argument_list|,
name|e
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
if|if
condition|(
name|operation
operator|.
name|hasFailure
argument_list|()
condition|)
block|{
name|indexingOperationListeners
operator|.
name|postOperation
argument_list|(
name|operation
argument_list|,
name|operation
operator|.
name|getFailure
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexingOperationListeners
operator|.
name|postOperation
argument_list|(
name|operation
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|prepareDeleteOnPrimary
specifier|public
name|Engine
operator|.
name|Delete
name|prepareDeleteOnPrimary
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|)
block|{
name|verifyPrimary
argument_list|()
expr_stmt|;
specifier|final
name|DocumentMapper
name|documentMapper
init|=
name|docMapper
argument_list|(
name|type
argument_list|)
operator|.
name|getDocumentMapper
argument_list|()
decl_stmt|;
specifier|final
name|MappedFieldType
name|uidFieldType
init|=
name|documentMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|fieldType
argument_list|()
decl_stmt|;
specifier|final
name|Query
name|uidQuery
init|=
name|uidFieldType
operator|.
name|termQuery
argument_list|(
name|Uid
operator|.
name|createUid
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|Term
name|uid
init|=
name|MappedFieldType
operator|.
name|extractTerm
argument_list|(
name|uidQuery
argument_list|)
decl_stmt|;
return|return
name|prepareDelete
argument_list|(
name|type
argument_list|,
name|id
argument_list|,
name|uid
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|PRIMARY
argument_list|)
return|;
block|}
DECL|method|prepareDeleteOnReplica
specifier|public
name|Engine
operator|.
name|Delete
name|prepareDeleteOnReplica
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|)
block|{
specifier|final
name|DocumentMapper
name|documentMapper
init|=
name|docMapper
argument_list|(
name|type
argument_list|)
operator|.
name|getDocumentMapper
argument_list|()
decl_stmt|;
specifier|final
name|MappedFieldType
name|uidFieldType
init|=
name|documentMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|fieldType
argument_list|()
decl_stmt|;
specifier|final
name|Query
name|uidQuery
init|=
name|uidFieldType
operator|.
name|termQuery
argument_list|(
name|Uid
operator|.
name|createUid
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
argument_list|,
literal|null
argument_list|)
decl_stmt|;
specifier|final
name|Term
name|uid
init|=
name|MappedFieldType
operator|.
name|extractTerm
argument_list|(
name|uidQuery
argument_list|)
decl_stmt|;
return|return
name|prepareDelete
argument_list|(
name|type
argument_list|,
name|id
argument_list|,
name|uid
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|REPLICA
argument_list|)
return|;
block|}
DECL|method|prepareDelete
specifier|static
name|Engine
operator|.
name|Delete
name|prepareDelete
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|,
name|Term
name|uid
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|Delete
argument_list|(
name|type
argument_list|,
name|id
argument_list|,
name|uid
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|get
specifier|public
name|Engine
operator|.
name|GetResult
name|get
parameter_list|(
name|Engine
operator|.
name|Get
name|get
parameter_list|)
block|{
name|readAllowed
argument_list|()
expr_stmt|;
return|return
name|getEngine
argument_list|()
operator|.
name|get
argument_list|(
name|get
argument_list|,
name|this
operator|::
name|acquireSearcher
argument_list|)
return|;
block|}
comment|/**      * Writes all indexing changes to disk and opens a new searcher reflecting all changes.  This can throw {@link EngineClosedException}.      */
DECL|method|refresh
specifier|public
name|void
name|refresh
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|verifyNotClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|canIndex
argument_list|()
condition|)
block|{
name|long
name|bytes
init|=
name|getEngine
argument_list|()
operator|.
name|getIndexBufferRAMBytesUsed
argument_list|()
decl_stmt|;
name|writingBytes
operator|.
name|addAndGet
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"refresh with source [{}] indexBufferRAMBytesUsed [{}]"
argument_list|,
name|source
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|getEngine
argument_list|()
operator|.
name|refresh
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|refreshMetric
operator|.
name|inc
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|time
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"remove [{}] writing bytes for shard [{}]"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|bytes
argument_list|)
argument_list|,
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|writingBytes
operator|.
name|addAndGet
argument_list|(
operator|-
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"refresh with source [{}]"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|getEngine
argument_list|()
operator|.
name|refresh
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|refreshMetric
operator|.
name|inc
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|time
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns how many bytes we are currently moving from heap to disk      */
DECL|method|getWritingBytes
specifier|public
name|long
name|getWritingBytes
parameter_list|()
block|{
return|return
name|writingBytes
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|refreshStats
specifier|public
name|RefreshStats
name|refreshStats
parameter_list|()
block|{
return|return
operator|new
name|RefreshStats
argument_list|(
name|refreshMetric
operator|.
name|count
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|refreshMetric
operator|.
name|sum
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|flushStats
specifier|public
name|FlushStats
name|flushStats
parameter_list|()
block|{
return|return
operator|new
name|FlushStats
argument_list|(
name|flushMetric
operator|.
name|count
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|flushMetric
operator|.
name|sum
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|docStats
specifier|public
name|DocsStats
name|docStats
parameter_list|()
block|{
name|readAllowed
argument_list|()
expr_stmt|;
specifier|final
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
return|return
name|engine
operator|.
name|getDocStats
argument_list|()
return|;
block|}
comment|/**      * @return {@link CommitStats} if engine is open, otherwise null      */
annotation|@
name|Nullable
DECL|method|commitStats
specifier|public
name|CommitStats
name|commitStats
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
return|return
name|engine
operator|==
literal|null
condition|?
literal|null
else|:
name|engine
operator|.
name|commitStats
argument_list|()
return|;
block|}
DECL|method|indexingStats
specifier|public
name|IndexingStats
name|indexingStats
parameter_list|(
name|String
modifier|...
name|types
parameter_list|)
block|{
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|throttled
decl_stmt|;
specifier|final
name|long
name|throttleTimeInMillis
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
name|throttled
operator|=
literal|false
expr_stmt|;
name|throttleTimeInMillis
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|throttled
operator|=
name|engine
operator|.
name|isThrottled
argument_list|()
expr_stmt|;
name|throttleTimeInMillis
operator|=
name|engine
operator|.
name|getIndexThrottleTimeInMillis
argument_list|()
expr_stmt|;
block|}
return|return
name|internalIndexingStats
operator|.
name|stats
argument_list|(
name|throttled
argument_list|,
name|throttleTimeInMillis
argument_list|,
name|types
argument_list|)
return|;
block|}
DECL|method|searchStats
specifier|public
name|SearchStats
name|searchStats
parameter_list|(
name|String
modifier|...
name|groups
parameter_list|)
block|{
return|return
name|searchStats
operator|.
name|stats
argument_list|(
name|groups
argument_list|)
return|;
block|}
DECL|method|getStats
specifier|public
name|GetStats
name|getStats
parameter_list|()
block|{
return|return
name|getService
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|storeStats
specifier|public
name|StoreStats
name|storeStats
parameter_list|()
block|{
try|try
block|{
return|return
name|store
operator|.
name|stats
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"io exception while building 'store stats'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
return|return
literal|null
return|;
comment|// already closed
block|}
block|}
DECL|method|mergeStats
specifier|public
name|MergeStats
name|mergeStats
parameter_list|()
block|{
specifier|final
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|MergeStats
argument_list|()
return|;
block|}
return|return
name|engine
operator|.
name|getMergeStats
argument_list|()
return|;
block|}
DECL|method|segmentStats
specifier|public
name|SegmentsStats
name|segmentStats
parameter_list|(
name|boolean
name|includeSegmentFileSizes
parameter_list|)
block|{
name|SegmentsStats
name|segmentsStats
init|=
name|getEngine
argument_list|()
operator|.
name|segmentsStats
argument_list|(
name|includeSegmentFileSizes
argument_list|)
decl_stmt|;
name|segmentsStats
operator|.
name|addBitsetMemoryInBytes
argument_list|(
name|shardBitsetFilterCache
operator|.
name|getMemorySizeInBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|segmentsStats
return|;
block|}
DECL|method|warmerStats
specifier|public
name|WarmerStats
name|warmerStats
parameter_list|()
block|{
return|return
name|shardWarmerService
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|fieldDataStats
specifier|public
name|FieldDataStats
name|fieldDataStats
parameter_list|(
name|String
modifier|...
name|fields
parameter_list|)
block|{
return|return
name|shardFieldData
operator|.
name|stats
argument_list|(
name|fields
argument_list|)
return|;
block|}
DECL|method|translogStats
specifier|public
name|TranslogStats
name|translogStats
parameter_list|()
block|{
return|return
name|getEngine
argument_list|()
operator|.
name|getTranslog
argument_list|()
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|completionStats
specifier|public
name|CompletionStats
name|completionStats
parameter_list|(
name|String
modifier|...
name|fields
parameter_list|)
block|{
name|CompletionStats
name|completionStats
init|=
operator|new
name|CompletionStats
argument_list|()
decl_stmt|;
try|try
init|(
specifier|final
name|Engine
operator|.
name|Searcher
name|currentSearcher
init|=
name|acquireSearcher
argument_list|(
literal|"completion_stats"
argument_list|)
init|)
block|{
name|completionStats
operator|.
name|add
argument_list|(
name|CompletionFieldStats
operator|.
name|completionStats
argument_list|(
name|currentSearcher
operator|.
name|reader
argument_list|()
argument_list|,
name|fields
argument_list|)
argument_list|)
expr_stmt|;
comment|// Necessary for 2.x shards:
name|Completion090PostingsFormat
name|postingsFormat
init|=
operator|(
operator|(
name|Completion090PostingsFormat
operator|)
name|PostingsFormat
operator|.
name|forName
argument_list|(
name|Completion090PostingsFormat
operator|.
name|CODEC_NAME
argument_list|)
operator|)
decl_stmt|;
name|completionStats
operator|.
name|add
argument_list|(
name|postingsFormat
operator|.
name|completionStats
argument_list|(
name|currentSearcher
operator|.
name|reader
argument_list|()
argument_list|,
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|completionStats
return|;
block|}
DECL|method|syncFlush
specifier|public
name|Engine
operator|.
name|SyncedFlushResult
name|syncFlush
parameter_list|(
name|String
name|syncId
parameter_list|,
name|Engine
operator|.
name|CommitId
name|expectedCommitId
parameter_list|)
block|{
name|verifyStartedOrRecovering
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"trying to sync flush. sync id [{}]. expected commit id [{}]]"
argument_list|,
name|syncId
argument_list|,
name|expectedCommitId
argument_list|)
expr_stmt|;
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|.
name|isRecovering
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|()
argument_list|,
name|state
argument_list|,
literal|"syncFlush is only allowed if the engine is not recovery"
operator|+
literal|" from translog"
argument_list|)
throw|;
block|}
return|return
name|engine
operator|.
name|syncFlush
argument_list|(
name|syncId
argument_list|,
name|expectedCommitId
argument_list|)
return|;
block|}
DECL|method|flush
specifier|public
name|Engine
operator|.
name|CommitId
name|flush
parameter_list|(
name|FlushRequest
name|request
parameter_list|)
throws|throws
name|ElasticsearchException
block|{
name|boolean
name|waitIfOngoing
init|=
name|request
operator|.
name|waitIfOngoing
argument_list|()
decl_stmt|;
name|boolean
name|force
init|=
name|request
operator|.
name|force
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"flush with {}"
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
comment|// we allows flush while recovering, since we allow for operations to happen
comment|// while recovering, and we want to keep the translog at bay (up to deletes, which
comment|// we don't gc). Yet, we don't use flush internally to clear deletes and flush the indexwriter since
comment|// we use #writeIndexingBuffer for this now.
name|verifyStartedOrRecovering
argument_list|()
expr_stmt|;
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|.
name|isRecovering
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|()
argument_list|,
name|state
argument_list|,
literal|"flush is only allowed if the engine is not recovery"
operator|+
literal|" from translog"
argument_list|)
throw|;
block|}
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|Engine
operator|.
name|CommitId
name|commitId
init|=
name|engine
operator|.
name|flush
argument_list|(
name|force
argument_list|,
name|waitIfOngoing
argument_list|)
decl_stmt|;
name|flushMetric
operator|.
name|inc
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|time
argument_list|)
expr_stmt|;
return|return
name|commitId
return|;
block|}
DECL|method|forceMerge
specifier|public
name|void
name|forceMerge
parameter_list|(
name|ForceMergeRequest
name|forceMerge
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyStarted
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"force merge with {}"
argument_list|,
name|forceMerge
argument_list|)
expr_stmt|;
block|}
name|getEngine
argument_list|()
operator|.
name|forceMerge
argument_list|(
name|forceMerge
operator|.
name|flush
argument_list|()
argument_list|,
name|forceMerge
operator|.
name|maxNumSegments
argument_list|()
argument_list|,
name|forceMerge
operator|.
name|onlyExpungeDeletes
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Upgrades the shard to the current version of Lucene and returns the minimum segment version      */
DECL|method|upgrade
specifier|public
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|upgrade
parameter_list|(
name|UpgradeRequest
name|upgrade
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyStarted
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"upgrade with {}"
argument_list|,
name|upgrade
argument_list|)
expr_stmt|;
block|}
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|previousVersion
init|=
name|minimumCompatibleVersion
argument_list|()
decl_stmt|;
comment|// we just want to upgrade the segments, not actually forge merge to a single segment
name|getEngine
argument_list|()
operator|.
name|forceMerge
argument_list|(
literal|true
argument_list|,
comment|// we need to flush at the end to make sure the upgrade is durable
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
comment|// we just want to upgrade the segments, not actually optimize to a single segment
literal|false
argument_list|,
literal|true
argument_list|,
name|upgrade
operator|.
name|upgradeOnlyAncientSegments
argument_list|()
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|version
init|=
name|minimumCompatibleVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"upgraded segments for {} from version {} to version {}"
argument_list|,
name|shardId
argument_list|,
name|previousVersion
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
return|return
name|version
return|;
block|}
DECL|method|minimumCompatibleVersion
specifier|public
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|minimumCompatibleVersion
parameter_list|()
block|{
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|luceneVersion
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Segment
name|segment
range|:
name|getEngine
argument_list|()
operator|.
name|segments
argument_list|(
literal|false
argument_list|)
control|)
block|{
if|if
condition|(
name|luceneVersion
operator|==
literal|null
operator|||
name|luceneVersion
operator|.
name|onOrAfter
argument_list|(
name|segment
operator|.
name|getVersion
argument_list|()
argument_list|)
condition|)
block|{
name|luceneVersion
operator|=
name|segment
operator|.
name|getVersion
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|luceneVersion
operator|==
literal|null
condition|?
name|indexSettings
operator|.
name|getIndexVersionCreated
argument_list|()
operator|.
name|luceneVersion
else|:
name|luceneVersion
return|;
block|}
comment|/**      * Creates a new {@link IndexCommit} snapshot form the currently running engine. All resources referenced by this      * commit won't be freed until the commit / snapshot is released via {@link #releaseIndexCommit(IndexCommit)}.      *      * @param flushFirst<code>true</code> if the index should first be flushed to disk / a low level lucene commit should be executed      */
DECL|method|acquireIndexCommit
specifier|public
name|IndexCommit
name|acquireIndexCommit
parameter_list|(
name|boolean
name|flushFirst
parameter_list|)
throws|throws
name|EngineException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
comment|// we allow snapshot on closed index shard, since we want to do one after we close the shard and before we close the engine
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
return|return
name|getEngine
argument_list|()
operator|.
name|acquireIndexCommit
argument_list|(
name|flushFirst
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"snapshot is not allowed"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Releases a snapshot taken from {@link #acquireIndexCommit(boolean)} this must be called to release the resources      * referenced by the given snapshot {@link IndexCommit}.      */
DECL|method|releaseIndexCommit
specifier|public
name|void
name|releaseIndexCommit
parameter_list|(
name|IndexCommit
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|deletionPolicy
operator|.
name|release
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
block|}
comment|/**      * gets a {@link Store.MetadataSnapshot} for the current directory. This method is safe to call in all lifecycle of the index shard,      * without having to worry about the current state of the engine and concurrent flushes.      *      * @throws org.apache.lucene.index.IndexNotFoundException     if no index is found in the current directory      * @throws CorruptIndexException      if the lucene index is corrupted. This can be caused by a checksum mismatch or an      *                                    unexpected exception when opening the index reading the segments file.      * @throws IndexFormatTooOldException if the lucene index is too old to be opened.      * @throws IndexFormatTooNewException if the lucene index is too new to be opened.      * @throws FileNotFoundException      if one or more files referenced by a commit are not present.      * @throws NoSuchFileException        if one or more files referenced by a commit are not present.      */
DECL|method|snapshotStoreMetadata
specifier|public
name|Store
operator|.
name|MetadataSnapshot
name|snapshotStoreMetadata
parameter_list|()
throws|throws
name|IOException
block|{
name|IndexCommit
name|indexCommit
init|=
literal|null
decl_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
comment|// if the engine is not running, we can access the store directly, but we need to make sure no one starts
comment|// the engine on us. If the engine is running, we can get a snapshot via the deletion policy which is initialized.
comment|// That can be done out of mutex, since the engine can be closed half way.
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
try|try
init|(
name|Lock
name|ignored
init|=
name|store
operator|.
name|directory
argument_list|()
operator|.
name|obtainLock
argument_list|(
name|IndexWriter
operator|.
name|WRITE_LOCK_NAME
argument_list|)
init|)
block|{
return|return
name|store
operator|.
name|getMetadata
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
block|}
name|indexCommit
operator|=
name|deletionPolicy
operator|.
name|snapshot
argument_list|()
expr_stmt|;
return|return
name|store
operator|.
name|getMetadata
argument_list|(
name|indexCommit
argument_list|)
return|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
if|if
condition|(
name|indexCommit
operator|!=
literal|null
condition|)
block|{
name|deletionPolicy
operator|.
name|release
argument_list|(
name|indexCommit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Fails the shard and marks the shard store as corrupted if      *<code>e</code> is caused by index corruption      */
DECL|method|failShard
specifier|public
name|void
name|failShard
parameter_list|(
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Exception
name|e
parameter_list|)
block|{
comment|// fail the engine. This will cause this shard to also be removed from the node's index service.
name|getEngine
argument_list|()
operator|.
name|failEngine
argument_list|(
name|reason
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|acquireSearcher
specifier|public
name|Engine
operator|.
name|Searcher
name|acquireSearcher
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|readAllowed
argument_list|()
expr_stmt|;
specifier|final
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
specifier|final
name|Engine
operator|.
name|Searcher
name|searcher
init|=
name|engine
operator|.
name|acquireSearcher
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
block|{
specifier|final
name|Engine
operator|.
name|Searcher
name|wrappedSearcher
init|=
name|searcherWrapper
operator|==
literal|null
condition|?
name|searcher
else|:
name|searcherWrapper
operator|.
name|wrap
argument_list|(
name|searcher
argument_list|)
decl_stmt|;
assert|assert
name|wrappedSearcher
operator|!=
literal|null
assert|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|wrappedSearcher
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to wrap searcher"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|Releasables
operator|.
name|close
argument_list|(
name|success
argument_list|,
name|searcher
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|String
name|reason
parameter_list|,
name|boolean
name|flushEngine
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
try|try
block|{
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|CLOSED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
specifier|final
name|Engine
name|engine
init|=
name|this
operator|.
name|currentEngineReference
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|engine
operator|!=
literal|null
operator|&&
name|flushEngine
condition|)
block|{
name|engine
operator|.
name|flushAndClose
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// playing safe here and close the engine even if the above succeeds - close can be called multiple times
name|IOUtils
operator|.
name|close
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|indexShardOperationsLock
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|postRecovery
specifier|public
name|IndexShard
name|postRecovery
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardClosedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|POST_RECOVERY
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/**      * called before starting to copy index files over      */
DECL|method|prepareForIndexRecovery
specifier|public
name|void
name|prepareForIndexRecovery
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|INDEX
argument_list|)
expr_stmt|;
assert|assert
name|currentEngineReference
operator|.
name|get
argument_list|()
operator|==
literal|null
assert|;
block|}
comment|/**      * Applies all operations in the iterable to the current engine and returns the number of operations applied.      * This operation will stop applying operations once an operation failed to apply.      * Note: This method is typically used in peer recovery to replay remote transaction log entries.      */
DECL|method|performBatchRecovery
specifier|public
name|int
name|performBatchRecovery
parameter_list|(
name|Iterable
argument_list|<
name|Translog
operator|.
name|Operation
argument_list|>
name|operations
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
comment|// We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,
comment|// we still invoke any onShardInactive listeners ... we won't sync'd flush in this case because we only do that on primary and this
comment|// is a replica
name|active
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
return|return
name|engine
operator|.
name|config
argument_list|()
operator|.
name|getTranslogRecoveryPerformer
argument_list|()
operator|.
name|performBatchRecovery
argument_list|(
name|engine
argument_list|,
name|operations
argument_list|)
return|;
block|}
comment|/**      * After the store has been recovered, we need to start the engine in order to apply operations      */
DECL|method|performTranslogRecovery
specifier|public
name|void
name|performTranslogRecovery
parameter_list|(
name|boolean
name|indexExists
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|indexExists
operator|==
literal|false
condition|)
block|{
comment|// note: these are set when recovering from the translog
specifier|final
name|RecoveryState
operator|.
name|Translog
name|translogStats
init|=
name|recoveryState
argument_list|()
operator|.
name|getTranslog
argument_list|()
decl_stmt|;
name|translogStats
operator|.
name|totalOperations
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|translogStats
operator|.
name|totalOperationsOnStart
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|internalPerformTranslogRecovery
argument_list|(
literal|false
argument_list|,
name|indexExists
argument_list|,
name|IndexRequest
operator|.
name|UNSET_AUTO_GENERATED_TIMESTAMP
argument_list|)
expr_stmt|;
assert|assert
name|recoveryState
operator|.
name|getStage
argument_list|()
operator|==
name|RecoveryState
operator|.
name|Stage
operator|.
name|TRANSLOG
operator|:
literal|"TRANSLOG stage expected but was: "
operator|+
name|recoveryState
operator|.
name|getStage
argument_list|()
assert|;
block|}
DECL|method|internalPerformTranslogRecovery
specifier|private
name|void
name|internalPerformTranslogRecovery
parameter_list|(
name|boolean
name|skipTranslogRecovery
parameter_list|,
name|boolean
name|indexExists
parameter_list|,
name|long
name|maxUnsafeAutoIdTimestamp
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|VERIFY_INDEX
argument_list|)
expr_stmt|;
comment|// also check here, before we apply the translog
if|if
condition|(
name|Booleans
operator|.
name|parseBoolean
argument_list|(
name|checkIndexOnStartup
argument_list|,
literal|false
argument_list|)
condition|)
block|{
try|try
block|{
name|checkIndex
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RecoveryFailedException
argument_list|(
name|recoveryState
argument_list|,
literal|"check index failed"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|TRANSLOG
argument_list|)
expr_stmt|;
specifier|final
name|EngineConfig
operator|.
name|OpenMode
name|openMode
decl_stmt|;
comment|/* by default we recover and index and replay the translog but if the index          * doesn't exist we create everything from the scratch. Yet, if the index          * doesn't exist we don't need to worry about the skipTranslogRecovery since          * there is no translog on a non-existing index.          * The skipTranslogRecovery invariant is used if we do remote recovery since          * there the translog isn't local but on the remote host, hence we can skip it.          */
if|if
condition|(
name|indexExists
operator|==
literal|false
condition|)
block|{
name|openMode
operator|=
name|EngineConfig
operator|.
name|OpenMode
operator|.
name|CREATE_INDEX_AND_TRANSLOG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skipTranslogRecovery
condition|)
block|{
name|openMode
operator|=
name|EngineConfig
operator|.
name|OpenMode
operator|.
name|OPEN_INDEX_CREATE_TRANSLOG
expr_stmt|;
block|}
else|else
block|{
name|openMode
operator|=
name|EngineConfig
operator|.
name|OpenMode
operator|.
name|OPEN_INDEX_AND_TRANSLOG
expr_stmt|;
block|}
specifier|final
name|EngineConfig
name|config
init|=
name|newEngineConfig
argument_list|(
name|openMode
argument_list|,
name|maxUnsafeAutoIdTimestamp
argument_list|)
decl_stmt|;
comment|// we disable deletes since we allow for operations to be executed against the shard while recovering
comment|// but we need to make sure we don't loose deletes until we are done recovering
name|config
operator|.
name|setEnableGcDeletes
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Engine
name|newEngine
init|=
name|createNewEngine
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|verifyNotClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|openMode
operator|==
name|EngineConfig
operator|.
name|OpenMode
operator|.
name|OPEN_INDEX_AND_TRANSLOG
condition|)
block|{
comment|// We set active because we are now writing operations to the engine; this way, if we go idle after some time and become inactive,
comment|// we still give sync'd flush a chance to run:
name|active
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|newEngine
operator|.
name|recoverFromTranslog
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|onNewEngine
specifier|protected
name|void
name|onNewEngine
parameter_list|(
name|Engine
name|newEngine
parameter_list|)
block|{
name|refreshListeners
operator|.
name|setTranslog
argument_list|(
name|newEngine
operator|.
name|getTranslog
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * After the store has been recovered, we need to start the engine. This method starts a new engine but skips      * the replay of the transaction log which is required in cases where we restore a previous index or recover from      * a remote peer.      */
DECL|method|skipTranslogRecovery
specifier|public
name|void
name|skipTranslogRecovery
parameter_list|(
name|long
name|maxUnsafeAutoIdTimestamp
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|getEngineOrNull
argument_list|()
operator|==
literal|null
operator|:
literal|"engine was already created"
assert|;
name|internalPerformTranslogRecovery
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|,
name|maxUnsafeAutoIdTimestamp
argument_list|)
expr_stmt|;
assert|assert
name|recoveryState
operator|.
name|getTranslog
argument_list|()
operator|.
name|recoveredOperations
argument_list|()
operator|==
literal|0
assert|;
block|}
comment|/**      * called if recovery has to be restarted after network error / delay **      */
DECL|method|performRecoveryRestart
specifier|public
name|void
name|performRecoveryRestart
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
specifier|final
name|Engine
name|engine
init|=
name|this
operator|.
name|currentEngineReference
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|recoveryState
argument_list|()
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|INIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * returns stats about ongoing recoveries, both source and target      */
DECL|method|recoveryStats
specifier|public
name|RecoveryStats
name|recoveryStats
parameter_list|()
block|{
return|return
name|recoveryStats
return|;
block|}
comment|/**      * Returns the current {@link RecoveryState} if this shard is recovering or has been recovering.      * Returns null if the recovery has not yet started or shard was not recovered (created via an API).      */
DECL|method|recoveryState
specifier|public
name|RecoveryState
name|recoveryState
parameter_list|()
block|{
return|return
name|this
operator|.
name|recoveryState
return|;
block|}
comment|/**      * perform the last stages of recovery once all translog operations are done.      * note that you should still call {@link #postRecovery(String)}.      */
DECL|method|finalizeRecovery
specifier|public
name|void
name|finalizeRecovery
parameter_list|()
block|{
name|recoveryState
argument_list|()
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|FINALIZE
argument_list|)
expr_stmt|;
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
name|engine
operator|.
name|refresh
argument_list|(
literal|"recovery_finalization"
argument_list|)
expr_stmt|;
name|engine
operator|.
name|config
argument_list|()
operator|.
name|setEnableGcDeletes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<tt>true</tt> if this shard can ignore a recovery attempt made to it (since the already doing/done it)      */
DECL|method|ignoreRecoveryAttempt
specifier|public
name|boolean
name|ignoreRecoveryAttempt
parameter_list|()
block|{
name|IndexShardState
name|state
init|=
name|state
argument_list|()
decl_stmt|;
comment|// one time volatile read
return|return
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
return|;
block|}
DECL|method|readAllowed
specifier|public
name|void
name|readAllowed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|readAllowedStates
operator|.
name|contains
argument_list|(
name|state
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operations only allowed when shard state is one of "
operator|+
name|readAllowedStates
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
DECL|method|ensureWriteAllowed
specifier|private
name|void
name|ensureWriteAllowed
parameter_list|(
name|Engine
operator|.
name|Operation
name|op
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
block|{
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
init|=
name|op
operator|.
name|origin
argument_list|()
decl_stmt|;
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|origin
operator|==
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|PRIMARY
condition|)
block|{
if|if
condition|(
name|writeAllowedStatesForPrimary
operator|.
name|contains
argument_list|(
name|state
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when shard state is one of "
operator|+
name|writeAllowedStatesForPrimary
operator|+
literal|", origin ["
operator|+
name|origin
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|origin
operator|.
name|isRecovery
argument_list|()
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when recovering, origin ["
operator|+
name|origin
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
assert|assert
name|origin
operator|==
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|REPLICA
assert|;
if|if
condition|(
name|writeAllowedStatesForReplica
operator|.
name|contains
argument_list|(
name|state
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when shard state is one of "
operator|+
name|writeAllowedStatesForReplica
operator|+
literal|", origin ["
operator|+
name|origin
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|verifyPrimary
specifier|private
name|void
name|verifyPrimary
parameter_list|()
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// TODO throw a more appropriate exception
throw|throw
operator|new
name|ShardNotFoundException
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"shard is not a primary anymore"
argument_list|)
throw|;
block|}
block|}
DECL|method|verifyReplicationTarget
specifier|private
name|void
name|verifyReplicationTarget
parameter_list|()
block|{
specifier|final
name|IndexShardState
name|state
init|=
name|state
argument_list|()
decl_stmt|;
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|shardRouting
operator|.
name|active
argument_list|()
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
comment|// must use exception that is not ignored by replication logic. See TransportActions.isShardNotAvailableException
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"active primary shard cannot be a replication target before "
operator|+
literal|" relocation hand off "
operator|+
name|shardRouting
operator|+
literal|", state is ["
operator|+
name|state
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
DECL|method|verifyStartedOrRecovering
specifier|protected
specifier|final
name|void
name|verifyStartedOrRecovering
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when started/recovering"
argument_list|)
throw|;
block|}
block|}
DECL|method|verifyNotClosed
specifier|private
name|void
name|verifyNotClosed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|verifyNotClosed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyNotClosed
specifier|private
name|void
name|verifyNotClosed
parameter_list|(
name|Exception
name|suppressed
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
specifier|final
name|IllegalIndexShardStateException
name|exc
init|=
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|,
literal|"operation only allowed when not closed"
argument_list|)
decl_stmt|;
if|if
condition|(
name|suppressed
operator|!=
literal|null
condition|)
block|{
name|exc
operator|.
name|addSuppressed
argument_list|(
name|suppressed
argument_list|)
expr_stmt|;
block|}
throw|throw
name|exc
throw|;
block|}
block|}
DECL|method|verifyStarted
specifier|protected
specifier|final
name|void
name|verifyStarted
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns number of heap bytes used by the indexing buffer for this shard, or 0 if the shard is closed      */
DECL|method|getIndexBufferRAMBytesUsed
specifier|public
name|long
name|getIndexBufferRAMBytesUsed
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
return|return
literal|0
return|;
block|}
try|try
block|{
return|return
name|engine
operator|.
name|getIndexBufferRAMBytesUsed
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
block|}
DECL|method|addShardFailureCallback
specifier|public
name|void
name|addShardFailureCallback
parameter_list|(
name|Callback
argument_list|<
name|ShardFailure
argument_list|>
name|onShardFailure
parameter_list|)
block|{
name|this
operator|.
name|shardEventListener
operator|.
name|delegates
operator|.
name|add
argument_list|(
name|onShardFailure
argument_list|)
expr_stmt|;
block|}
comment|/**      * Called by {@link IndexingMemoryController} to check whether more than {@code inactiveTimeNS} has passed since the last      * indexing operation, and notify listeners that we are now inactive so e.g. sync'd flush can happen.      */
DECL|method|checkIdle
specifier|public
name|void
name|checkIdle
parameter_list|(
name|long
name|inactiveTimeNS
parameter_list|)
block|{
name|Engine
name|engineOrNull
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|engineOrNull
operator|!=
literal|null
operator|&&
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|engineOrNull
operator|.
name|getLastWriteNanos
argument_list|()
operator|>=
name|inactiveTimeNS
condition|)
block|{
name|boolean
name|wasActive
init|=
name|active
operator|.
name|getAndSet
argument_list|(
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|wasActive
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"shard is now inactive"
argument_list|)
expr_stmt|;
try|try
block|{
name|indexEventListener
operator|.
name|onShardInactive
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to notify index event listener"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|isActive
specifier|public
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|active
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|shardPath
specifier|public
name|ShardPath
name|shardPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
DECL|method|recoverFromLocalShards
specifier|public
name|boolean
name|recoverFromLocalShards
parameter_list|(
name|BiConsumer
argument_list|<
name|String
argument_list|,
name|MappingMetaData
argument_list|>
name|mappingUpdateConsumer
parameter_list|,
name|List
argument_list|<
name|IndexShard
argument_list|>
name|localShards
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|shardRouting
operator|.
name|primary
argument_list|()
operator|:
literal|"recover from local shards only makes sense if the shard is a primary shard"
assert|;
assert|assert
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|RecoverySource
operator|.
name|Type
operator|.
name|LOCAL_SHARDS
operator|:
literal|"invalid recovery type: "
operator|+
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
assert|;
specifier|final
name|List
argument_list|<
name|LocalShardSnapshot
argument_list|>
name|snapshots
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|IndexShard
name|shard
range|:
name|localShards
control|)
block|{
name|snapshots
operator|.
name|add
argument_list|(
operator|new
name|LocalShardSnapshot
argument_list|(
name|shard
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// we are the first primary, recover from the gateway
comment|// if its post api allocation, the index should exists
assert|assert
name|shardRouting
operator|.
name|primary
argument_list|()
operator|:
literal|"recover from local shards only makes sense if the shard is a primary shard"
assert|;
name|StoreRecovery
name|storeRecovery
init|=
operator|new
name|StoreRecovery
argument_list|(
name|shardId
argument_list|,
name|logger
argument_list|)
decl_stmt|;
return|return
name|storeRecovery
operator|.
name|recoverFromLocalShards
argument_list|(
name|mappingUpdateConsumer
argument_list|,
name|this
argument_list|,
name|snapshots
argument_list|)
return|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|snapshots
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|recoverFromStore
specifier|public
name|boolean
name|recoverFromStore
parameter_list|()
block|{
comment|// we are the first primary, recover from the gateway
comment|// if its post api allocation, the index should exists
assert|assert
name|shardRouting
operator|.
name|primary
argument_list|()
operator|:
literal|"recover from store only makes sense if the shard is a primary shard"
assert|;
assert|assert
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|:
literal|"can only start recovery on initializing shard"
assert|;
name|StoreRecovery
name|storeRecovery
init|=
operator|new
name|StoreRecovery
argument_list|(
name|shardId
argument_list|,
name|logger
argument_list|)
decl_stmt|;
return|return
name|storeRecovery
operator|.
name|recoverFromStore
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|method|restoreFromRepository
specifier|public
name|boolean
name|restoreFromRepository
parameter_list|(
name|Repository
name|repository
parameter_list|)
block|{
assert|assert
name|shardRouting
operator|.
name|primary
argument_list|()
operator|:
literal|"recover from store only makes sense if the shard is a primary shard"
assert|;
assert|assert
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
operator|.
name|getType
argument_list|()
operator|==
name|RecoverySource
operator|.
name|Type
operator|.
name|SNAPSHOT
operator|:
literal|"invalid recovery type: "
operator|+
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
assert|;
name|StoreRecovery
name|storeRecovery
init|=
operator|new
name|StoreRecovery
argument_list|(
name|shardId
argument_list|,
name|logger
argument_list|)
decl_stmt|;
return|return
name|storeRecovery
operator|.
name|recoverFromRepository
argument_list|(
name|this
argument_list|,
name|repository
argument_list|)
return|;
block|}
comment|/**      * Returns<code>true</code> iff this shard needs to be flushed due to too many translog operation or a too large transaction log.      * Otherwise<code>false</code>.      */
DECL|method|shouldFlush
name|boolean
name|shouldFlush
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Translog
name|translog
init|=
name|engine
operator|.
name|getTranslog
argument_list|()
decl_stmt|;
return|return
name|translog
operator|.
name|sizeInBytes
argument_list|()
operator|>
name|indexSettings
operator|.
name|getFlushThresholdSize
argument_list|()
operator|.
name|getBytes
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
decl||
name|EngineClosedException
name|ex
parameter_list|)
block|{
comment|// that's fine we are already close - no need to flush
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|onSettingsChanged
specifier|public
name|void
name|onSettingsChanged
parameter_list|()
block|{
name|Engine
name|engineOrNull
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|engineOrNull
operator|!=
literal|null
condition|)
block|{
name|engineOrNull
operator|.
name|onSettingsChanged
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|acquireTranslogView
specifier|public
name|Translog
operator|.
name|View
name|acquireTranslogView
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
assert|assert
name|engine
operator|.
name|getTranslog
argument_list|()
operator|!=
literal|null
operator|:
literal|"translog must not be null"
assert|;
return|return
name|engine
operator|.
name|getTranslog
argument_list|()
operator|.
name|newView
argument_list|()
return|;
block|}
DECL|method|segments
specifier|public
name|List
argument_list|<
name|Segment
argument_list|>
name|segments
parameter_list|(
name|boolean
name|verbose
parameter_list|)
block|{
return|return
name|getEngine
argument_list|()
operator|.
name|segments
argument_list|(
name|verbose
argument_list|)
return|;
block|}
DECL|method|flushAndCloseEngine
specifier|public
name|void
name|flushAndCloseEngine
parameter_list|()
throws|throws
name|IOException
block|{
name|getEngine
argument_list|()
operator|.
name|flushAndClose
argument_list|()
expr_stmt|;
block|}
DECL|method|getTranslog
specifier|public
name|Translog
name|getTranslog
parameter_list|()
block|{
return|return
name|getEngine
argument_list|()
operator|.
name|getTranslog
argument_list|()
return|;
block|}
DECL|method|getIndexEventListener
specifier|public
name|IndexEventListener
name|getIndexEventListener
parameter_list|()
block|{
return|return
name|indexEventListener
return|;
block|}
DECL|method|activateThrottling
specifier|public
name|void
name|activateThrottling
parameter_list|()
block|{
try|try
block|{
name|getEngine
argument_list|()
operator|.
name|activateThrottling
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|ex
parameter_list|)
block|{
comment|// ignore
block|}
block|}
DECL|method|deactivateThrottling
specifier|public
name|void
name|deactivateThrottling
parameter_list|()
block|{
try|try
block|{
name|getEngine
argument_list|()
operator|.
name|deactivateThrottling
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|ex
parameter_list|)
block|{
comment|// ignore
block|}
block|}
DECL|method|handleRefreshException
specifier|private
name|void
name|handleRefreshException
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|EngineClosedException
condition|)
block|{
comment|// ignore
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|RefreshFailedEngineException
condition|)
block|{
name|RefreshFailedEngineException
name|rfee
init|=
operator|(
name|RefreshFailedEngineException
operator|)
name|e
decl_stmt|;
if|if
condition|(
name|rfee
operator|.
name|getCause
argument_list|()
operator|instanceof
name|InterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|rfee
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ClosedByInterruptException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|rfee
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ThreadInterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
else|else
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Called when our shard is using too much heap and should move buffered indexed/deleted documents to disk.      */
DECL|method|writeIndexingBuffer
specifier|public
name|void
name|writeIndexingBuffer
parameter_list|()
block|{
if|if
condition|(
name|canIndex
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
try|try
block|{
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
name|long
name|bytes
init|=
name|engine
operator|.
name|getIndexBufferRAMBytesUsed
argument_list|()
decl_stmt|;
comment|// NOTE: this can be an overestimate by up to 20%, if engine uses IW.flush not refresh, because version map
comment|// memory is low enough, but this is fine because after the writes finish, IMC will poll again and see that
comment|// there's still up to the 20% being used and continue writing if necessary:
name|logger
operator|.
name|debug
argument_list|(
literal|"add [{}] writing bytes for shard [{}]"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|bytes
argument_list|)
argument_list|,
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
name|writingBytes
operator|.
name|addAndGet
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
try|try
block|{
name|engine
operator|.
name|writeIndexingBuffer
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|writingBytes
operator|.
name|addAndGet
argument_list|(
operator|-
name|bytes
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"remove [{}] writing bytes for shard [{}]"
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|bytes
argument_list|)
argument_list|,
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|handleRefreshException
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Should be called for each no-op update operation to increment relevant statistics.      *      * @param type the doc type of the update      */
DECL|method|noopUpdate
specifier|public
name|void
name|noopUpdate
parameter_list|(
name|String
name|type
parameter_list|)
block|{
name|internalIndexingStats
operator|.
name|noopUpdate
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
DECL|method|checkIndex
specifier|private
name|void
name|checkIndex
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|store
operator|.
name|tryIncRef
argument_list|()
condition|)
block|{
try|try
block|{
name|doCheckIndex
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|doCheckIndex
specifier|private
name|void
name|doCheckIndex
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|timeNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Lucene
operator|.
name|indexExists
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|BytesStreamOutput
name|os
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|,
literal|false
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"checksum"
operator|.
name|equals
argument_list|(
name|checkIndexOnStartup
argument_list|)
condition|)
block|{
comment|// physical verification only: verify all checksums for the latest commit
name|IOException
name|corrupt
init|=
literal|null
decl_stmt|;
name|MetadataSnapshot
name|metadata
init|=
name|snapshotStoreMetadata
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|StoreFileMetaData
argument_list|>
name|entry
range|:
name|metadata
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|Store
operator|.
name|checkIntegrity
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|store
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"checksum passed: "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exc
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"checksum failed: "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|exc
operator|.
name|printStackTrace
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|corrupt
operator|=
name|exc
expr_stmt|;
block|}
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|corrupt
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
name|corrupt
throw|;
block|}
block|}
else|else
block|{
comment|// full checkindex
try|try
init|(
name|CheckIndex
name|checkIndex
init|=
operator|new
name|CheckIndex
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
init|)
block|{
name|checkIndex
operator|.
name|setInfoStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|status
init|=
name|checkIndex
operator|.
name|checkIndex
argument_list|()
decl_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|clean
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// ignore if closed....
return|return;
block|}
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"fix"
operator|.
name|equals
argument_list|(
name|checkIndexOnStartup
argument_list|)
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"fixing index, writing new segments file ..."
argument_list|)
expr_stmt|;
block|}
name|checkIndex
operator|.
name|exorciseIndex
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"index fixed, wrote new segments file \"{}\""
argument_list|,
name|status
operator|.
name|segmentsFileName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// only throw a failure if we are not going to fix the index
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"index check failure but can't fix it"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"check index [success]\n{}"
argument_list|,
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|utf8ToString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recoveryState
operator|.
name|getVerifyIndex
argument_list|()
operator|.
name|checkIndexTime
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|TimeValue
operator|.
name|nsecToMSec
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|timeNS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|getEngine
name|Engine
name|getEngine
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EngineClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
return|return
name|engine
return|;
block|}
comment|/**      * NOTE: returns null if engine is not yet started (e.g. recovery phase 1, copying over index files, is still running), or if engine is      * closed.      */
DECL|method|getEngineOrNull
specifier|protected
name|Engine
name|getEngineOrNull
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentEngineReference
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|startRecovery
specifier|public
name|void
name|startRecovery
parameter_list|(
name|RecoveryState
name|recoveryState
parameter_list|,
name|PeerRecoveryTargetService
name|recoveryTargetService
parameter_list|,
name|PeerRecoveryTargetService
operator|.
name|RecoveryListener
name|recoveryListener
parameter_list|,
name|RepositoriesService
name|repositoriesService
parameter_list|,
name|BiConsumer
argument_list|<
name|String
argument_list|,
name|MappingMetaData
argument_list|>
name|mappingUpdateConsumer
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|)
block|{
comment|// TODO: Create a proper object to encapsulate the recovery context
comment|// all of the current methods here follow a pattern of:
comment|// resolve context which isn't really dependent on the local shards and then async
comment|// call some external method with this pointer.
comment|// with a proper recovery context object we can simply change this to:
comment|// startRecovery(RecoveryState recoveryState, ShardRecoverySource source ) {
comment|//     markAsRecovery("from " + source.getShortDescription(), recoveryState);
comment|//     threadPool.generic().execute()  {
comment|//           onFailure () { listener.failure() };
comment|//           doRun() {
comment|//                if (source.recover(this)) {
comment|//                  recoveryListener.onRecoveryDone(recoveryState);
comment|//                }
comment|//           }
comment|//     }}
comment|// }
assert|assert
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
operator|.
name|equals
argument_list|(
name|shardRouting
operator|.
name|recoverySource
argument_list|()
argument_list|)
assert|;
switch|switch
condition|(
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
operator|.
name|getType
argument_list|()
condition|)
block|{
case|case
name|EMPTY_STORE
case|:
case|case
name|EXISTING_STORE
case|:
name|markAsRecovering
argument_list|(
literal|"from store"
argument_list|,
name|recoveryState
argument_list|)
expr_stmt|;
comment|// mark the shard as recovering on the cluster state thread
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
if|if
condition|(
name|recoverFromStore
argument_list|()
condition|)
block|{
name|recoveryListener
operator|.
name|onRecoveryDone
argument_list|(
name|recoveryState
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|recoveryListener
operator|.
name|onRecoveryFailure
argument_list|(
name|recoveryState
argument_list|,
operator|new
name|RecoveryFailedException
argument_list|(
name|recoveryState
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
break|break;
case|case
name|PEER
case|:
try|try
block|{
name|markAsRecovering
argument_list|(
literal|"from "
operator|+
name|recoveryState
operator|.
name|getSourceNode
argument_list|()
argument_list|,
name|recoveryState
argument_list|)
expr_stmt|;
name|recoveryTargetService
operator|.
name|startRecovery
argument_list|(
name|this
argument_list|,
name|recoveryState
operator|.
name|getSourceNode
argument_list|()
argument_list|,
name|recoveryListener
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|failShard
argument_list|(
literal|"corrupted preexisting index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|recoveryListener
operator|.
name|onRecoveryFailure
argument_list|(
name|recoveryState
argument_list|,
operator|new
name|RecoveryFailedException
argument_list|(
name|recoveryState
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SNAPSHOT
case|:
name|markAsRecovering
argument_list|(
literal|"from snapshot"
argument_list|,
name|recoveryState
argument_list|)
expr_stmt|;
comment|// mark the shard as recovering on the cluster state thread
name|SnapshotRecoverySource
name|recoverySource
init|=
operator|(
name|SnapshotRecoverySource
operator|)
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
decl_stmt|;
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
specifier|final
name|Repository
name|repository
init|=
name|repositoriesService
operator|.
name|repository
argument_list|(
name|recoverySource
operator|.
name|snapshot
argument_list|()
operator|.
name|getRepository
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|restoreFromRepository
argument_list|(
name|repository
argument_list|)
condition|)
block|{
name|recoveryListener
operator|.
name|onRecoveryDone
argument_list|(
name|recoveryState
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|recoveryListener
operator|.
name|onRecoveryFailure
argument_list|(
name|recoveryState
argument_list|,
operator|new
name|RecoveryFailedException
argument_list|(
name|recoveryState
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_SHARDS
case|:
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|indexSettings
argument_list|()
operator|.
name|getIndexMetaData
argument_list|()
decl_stmt|;
specifier|final
name|Index
name|mergeSourceIndex
init|=
name|indexMetaData
operator|.
name|getMergeSourceIndex
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|IndexShard
argument_list|>
name|startedShards
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|IndexService
name|sourceIndexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|mergeSourceIndex
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numShards
init|=
name|sourceIndexService
operator|!=
literal|null
condition|?
name|sourceIndexService
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getNumberOfShards
argument_list|()
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|sourceIndexService
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|IndexShard
name|shard
range|:
name|sourceIndexService
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
name|startedShards
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|numShards
operator|==
name|startedShards
operator|.
name|size
argument_list|()
condition|)
block|{
name|markAsRecovering
argument_list|(
literal|"from local shards"
argument_list|,
name|recoveryState
argument_list|)
expr_stmt|;
comment|// mark the shard as recovering on the cluster state thread
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
parameter_list|()
lambda|->
block|{
try|try
block|{
specifier|final
name|Set
argument_list|<
name|ShardId
argument_list|>
name|shards
init|=
name|IndexMetaData
operator|.
name|selectShrinkShards
argument_list|(
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|,
name|sourceIndexService
operator|.
name|getMetaData
argument_list|()
argument_list|,
operator|+
name|indexMetaData
operator|.
name|getNumberOfShards
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|recoverFromLocalShards
argument_list|(
name|mappingUpdateConsumer
argument_list|,
name|startedShards
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
parameter_list|(
lambda|s
argument_list|)
operator|->
name|shards
operator|.
name|contains
argument_list|(
name|s
operator|.
name|shardId
argument_list|()
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
condition|)
argument_list|)
block|{
name|recoveryListener
operator|.
name|onRecoveryDone
argument_list|(
name|recoveryState
argument_list|)
block|;                             }
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|recoveryListener
operator|.
name|onRecoveryFailure
argument_list|(
name|recoveryState
argument_list|,
operator|new
name|RecoveryFailedException
argument_list|(
name|recoveryState
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|)
function|;
block|}
end_class

begin_else
else|else
block|{
specifier|final
name|Exception
name|e
decl_stmt|;
if|if
condition|(
name|numShards
operator|==
operator|-
literal|1
condition|)
block|{
name|e
operator|=
operator|new
name|IndexNotFoundException
argument_list|(
name|mergeSourceIndex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
operator|new
name|IllegalStateException
argument_list|(
literal|"not all shards from index "
operator|+
name|mergeSourceIndex
operator|+
literal|" are started yet, expected "
operator|+
name|numShards
operator|+
literal|" found "
operator|+
name|startedShards
operator|.
name|size
argument_list|()
operator|+
literal|" can't recover shard "
operator|+
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|recoveryListener
operator|.
name|onRecoveryFailure
argument_list|(
name|recoveryState
argument_list|,
operator|new
name|RecoveryFailedException
argument_list|(
name|recoveryState
argument_list|,
literal|null
argument_list|,
name|e
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_else

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_throw
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown recovery source "
operator|+
name|recoveryState
operator|.
name|getRecoverySource
argument_list|()
argument_list|)
throw|;
end_throw

begin_class
unit|}     }
DECL|class|ShardEventListener
class|class
name|ShardEventListener
implements|implements
name|Engine
operator|.
name|EventListener
block|{
DECL|field|delegates
specifier|private
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|Callback
argument_list|<
name|ShardFailure
argument_list|>
argument_list|>
name|delegates
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// called by the current engine
annotation|@
name|Override
DECL|method|onFailedEngine
specifier|public
name|void
name|onFailedEngine
parameter_list|(
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Exception
name|failure
parameter_list|)
block|{
specifier|final
name|ShardFailure
name|shardFailure
init|=
operator|new
name|ShardFailure
argument_list|(
name|shardRouting
argument_list|,
name|reason
argument_list|,
name|failure
argument_list|)
decl_stmt|;
for|for
control|(
name|Callback
argument_list|<
name|ShardFailure
argument_list|>
name|listener
range|:
name|delegates
control|)
block|{
try|try
block|{
name|listener
operator|.
name|handle
argument_list|(
name|shardFailure
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|inner
parameter_list|)
block|{
name|inner
operator|.
name|addSuppressed
argument_list|(
name|failure
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"exception while notifying engine failure"
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

begin_function
DECL|method|createNewEngine
specifier|private
name|Engine
name|createNewEngine
parameter_list|(
name|EngineConfig
name|config
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|EngineClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
assert|assert
name|this
operator|.
name|currentEngineReference
operator|.
name|get
argument_list|()
operator|==
literal|null
assert|;
name|Engine
name|engine
init|=
name|newEngine
argument_list|(
name|config
argument_list|)
decl_stmt|;
name|onNewEngine
argument_list|(
name|engine
argument_list|)
expr_stmt|;
comment|// call this before we pass the memory barrier otherwise actions that happen
comment|// inside the callback are not visible. This one enforces happens-before
name|this
operator|.
name|currentEngineReference
operator|.
name|set
argument_list|(
name|engine
argument_list|)
expr_stmt|;
block|}
comment|// time elapses after the engine is created above (pulling the config settings) until we set the engine reference, during which
comment|// settings changes could possibly have happened, so here we forcefully push any config changes to the new engine:
name|Engine
name|engine
init|=
name|getEngineOrNull
argument_list|()
decl_stmt|;
comment|// engine could perhaps be null if we were e.g. concurrently closed:
if|if
condition|(
name|engine
operator|!=
literal|null
condition|)
block|{
name|engine
operator|.
name|onSettingsChanged
argument_list|()
expr_stmt|;
block|}
return|return
name|engine
return|;
block|}
end_function

begin_function
DECL|method|newEngine
specifier|protected
name|Engine
name|newEngine
parameter_list|(
name|EngineConfig
name|config
parameter_list|)
block|{
return|return
name|engineFactory
operator|.
name|newReadWriteEngine
argument_list|(
name|config
argument_list|)
return|;
block|}
end_function

begin_comment
comment|// pkg private for testing
end_comment

begin_function
DECL|method|persistMetadata
name|void
name|persistMetadata
parameter_list|(
name|ShardRouting
name|newRouting
parameter_list|,
annotation|@
name|Nullable
name|ShardRouting
name|currentRouting
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|newRouting
operator|!=
literal|null
operator|:
literal|"newRouting must not be null"
assert|;
comment|// only persist metadata if routing information that is persisted in shard state metadata actually changed
if|if
condition|(
name|currentRouting
operator|==
literal|null
operator|||
name|currentRouting
operator|.
name|primary
argument_list|()
operator|!=
name|newRouting
operator|.
name|primary
argument_list|()
operator|||
name|currentRouting
operator|.
name|allocationId
argument_list|()
operator|.
name|equals
argument_list|(
name|newRouting
operator|.
name|allocationId
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
assert|assert
name|currentRouting
operator|==
literal|null
operator|||
name|currentRouting
operator|.
name|isSameAllocation
argument_list|(
name|newRouting
argument_list|)
assert|;
specifier|final
name|String
name|writeReason
decl_stmt|;
if|if
condition|(
name|currentRouting
operator|==
literal|null
condition|)
block|{
name|writeReason
operator|=
literal|"initial state with allocation id ["
operator|+
name|newRouting
operator|.
name|allocationId
argument_list|()
operator|+
literal|"]"
expr_stmt|;
block|}
else|else
block|{
name|writeReason
operator|=
literal|"routing changed from "
operator|+
name|currentRouting
operator|+
literal|" to "
operator|+
name|newRouting
expr_stmt|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"{} writing shard state, reason [{}]"
argument_list|,
name|shardId
argument_list|,
name|writeReason
argument_list|)
expr_stmt|;
specifier|final
name|ShardStateMetaData
name|newShardStateMetadata
init|=
operator|new
name|ShardStateMetaData
argument_list|(
name|newRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|getIndexUUID
argument_list|()
argument_list|,
name|newRouting
operator|.
name|allocationId
argument_list|()
argument_list|)
decl_stmt|;
name|ShardStateMetaData
operator|.
name|FORMAT
operator|.
name|write
argument_list|(
name|newShardStateMetadata
argument_list|,
name|shardPath
argument_list|()
operator|.
name|getShardStatePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"{} skip writing shard state, has been written before"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
DECL|method|getIndexUUID
specifier|private
name|String
name|getIndexUUID
parameter_list|()
block|{
return|return
name|indexSettings
operator|.
name|getUUID
argument_list|()
return|;
block|}
end_function

begin_function
DECL|method|docMapper
specifier|private
name|DocumentMapperForType
name|docMapper
parameter_list|(
name|String
name|type
parameter_list|)
block|{
return|return
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_function
DECL|method|newEngineConfig
specifier|private
name|EngineConfig
name|newEngineConfig
parameter_list|(
name|EngineConfig
operator|.
name|OpenMode
name|openMode
parameter_list|,
name|long
name|maxUnsafeAutoIdTimestamp
parameter_list|)
block|{
specifier|final
name|IndexShardRecoveryPerformer
name|translogRecoveryPerformer
init|=
operator|new
name|IndexShardRecoveryPerformer
argument_list|(
name|shardId
argument_list|,
name|mapperService
argument_list|,
name|logger
argument_list|)
decl_stmt|;
return|return
operator|new
name|EngineConfig
argument_list|(
name|openMode
argument_list|,
name|shardId
argument_list|,
name|threadPool
argument_list|,
name|indexSettings
argument_list|,
name|warmer
argument_list|,
name|store
argument_list|,
name|deletionPolicy
argument_list|,
name|indexSettings
operator|.
name|getMergePolicy
argument_list|()
argument_list|,
name|mapperService
operator|.
name|indexAnalyzer
argument_list|()
argument_list|,
name|similarityService
operator|.
name|similarity
argument_list|(
name|mapperService
argument_list|)
argument_list|,
name|codecService
argument_list|,
name|shardEventListener
argument_list|,
name|translogRecoveryPerformer
argument_list|,
name|indexCache
operator|.
name|query
argument_list|()
argument_list|,
name|cachingPolicy
argument_list|,
name|translogConfig
argument_list|,
name|IndexingMemoryController
operator|.
name|SHARD_INACTIVE_TIME_SETTING
operator|.
name|get
argument_list|(
name|indexSettings
operator|.
name|getSettings
argument_list|()
argument_list|)
argument_list|,
name|refreshListeners
argument_list|,
name|maxUnsafeAutoIdTimestamp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      * Acquire a primary operation lock whenever the shard is ready for indexing. If the lock is directly available, the provided      * ActionListener will be called on the calling thread. During relocation hand-off, lock acquisition can be delayed. The provided      * ActionListener will then be called using the provided executor.      */
end_comment

begin_function
DECL|method|acquirePrimaryOperationLock
specifier|public
name|void
name|acquirePrimaryOperationLock
parameter_list|(
name|ActionListener
argument_list|<
name|Releasable
argument_list|>
name|onLockAcquired
parameter_list|,
name|String
name|executorOnDelay
parameter_list|)
block|{
name|verifyNotClosed
argument_list|()
expr_stmt|;
name|verifyPrimary
argument_list|()
expr_stmt|;
name|indexShardOperationsLock
operator|.
name|acquire
argument_list|(
name|onLockAcquired
argument_list|,
name|executorOnDelay
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Acquire a replica operation lock whenever the shard is ready for indexing (see acquirePrimaryOperationLock). If the given primary      * term is lower then the one in {@link #shardRouting} an {@link IllegalArgumentException} is thrown.      */
end_comment

begin_function
DECL|method|acquireReplicaOperationLock
specifier|public
name|void
name|acquireReplicaOperationLock
parameter_list|(
name|long
name|opPrimaryTerm
parameter_list|,
name|ActionListener
argument_list|<
name|Releasable
argument_list|>
name|onLockAcquired
parameter_list|,
name|String
name|executorOnDelay
parameter_list|)
block|{
name|verifyNotClosed
argument_list|()
expr_stmt|;
name|verifyReplicationTarget
argument_list|()
expr_stmt|;
if|if
condition|(
name|primaryTerm
operator|>
name|opPrimaryTerm
condition|)
block|{
comment|// must use exception that is not ignored by replication logic. See TransportActions.isShardNotAvailableException
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|LoggerMessageFormat
operator|.
name|format
argument_list|(
literal|"{} operation term [{}] is too old (current [{}])"
argument_list|,
name|shardId
argument_list|,
name|opPrimaryTerm
argument_list|,
name|primaryTerm
argument_list|)
argument_list|)
throw|;
block|}
name|indexShardOperationsLock
operator|.
name|acquire
argument_list|(
name|onLockAcquired
argument_list|,
name|executorOnDelay
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
DECL|method|getActiveOperationsCount
specifier|public
name|int
name|getActiveOperationsCount
parameter_list|()
block|{
return|return
name|indexShardOperationsLock
operator|.
name|getActiveOperationsCount
argument_list|()
return|;
comment|// refCount is incremented on successful acquire and decremented on close
block|}
end_function

begin_decl_stmt
DECL|field|translogSyncProcessor
specifier|private
specifier|final
name|AsyncIOProcessor
argument_list|<
name|Translog
operator|.
name|Location
argument_list|>
name|translogSyncProcessor
init|=
operator|new
name|AsyncIOProcessor
argument_list|<
name|Translog
operator|.
name|Location
argument_list|>
argument_list|(
name|logger
argument_list|,
literal|1024
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|write
parameter_list|(
name|List
argument_list|<
name|Tuple
argument_list|<
name|Translog
operator|.
name|Location
argument_list|,
name|Consumer
argument_list|<
name|Exception
argument_list|>
argument_list|>
argument_list|>
name|candidates
parameter_list|)
throws|throws
name|IOException
block|{
try|try
block|{
specifier|final
name|Engine
name|engine
init|=
name|getEngine
argument_list|()
decl_stmt|;
name|engine
operator|.
name|getTranslog
argument_list|()
operator|.
name|ensureSynced
argument_list|(
name|candidates
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|ex
parameter_list|)
block|{
comment|// that's fine since we already synced everything on engine close - this also is conform with the methods
comment|// documentation
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// if this fails we are in deep shit - fail the request
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to sync translog"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**      * Syncs the given location with the underlying storage unless already synced. This method might return immediately without      * actually fsyncing the location until the sync listener is called. Yet, unless there is already another thread fsyncing      * the transaction log the caller thread will be hijacked to run the fsync for all pending fsync operations.      * This method allows indexing threads to continue indexing without blocking on fsync calls. We ensure that there is only      * one thread blocking on the sync an all others can continue indexing.      * NOTE: if the syncListener throws an exception when it's processed the exception will only be logged. Users should make sure that the      * listener handles all exception cases internally.      */
end_comment

begin_function
DECL|method|sync
specifier|public
specifier|final
name|void
name|sync
parameter_list|(
name|Translog
operator|.
name|Location
name|location
parameter_list|,
name|Consumer
argument_list|<
name|Exception
argument_list|>
name|syncListener
parameter_list|)
block|{
name|verifyNotClosed
argument_list|()
expr_stmt|;
name|translogSyncProcessor
operator|.
name|put
argument_list|(
name|location
argument_list|,
name|syncListener
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**      * Returns the current translog durability mode      */
end_comment

begin_function
DECL|method|getTranslogDurability
specifier|public
name|Translog
operator|.
name|Durability
name|getTranslogDurability
parameter_list|()
block|{
return|return
name|indexSettings
operator|.
name|getTranslogDurability
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
DECL|field|asyncFlushRunning
specifier|private
specifier|final
name|AtomicBoolean
name|asyncFlushRunning
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**      * Schedules a flush if needed but won't schedule more than one flush concurrently. The flush will be executed on the      * Flush thread-pool asynchronously.      *      * @return<code>true</code> if a new flush is scheduled otherwise<code>false</code>.      */
end_comment

begin_function
DECL|method|maybeFlush
specifier|public
name|boolean
name|maybeFlush
parameter_list|()
block|{
if|if
condition|(
name|shouldFlush
argument_list|()
condition|)
block|{
if|if
condition|(
name|asyncFlushRunning
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
comment|// we can't use a lock here since we "release" in a different thread
if|if
condition|(
name|shouldFlush
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// we have to check again since otherwise there is a race when a thread passes
comment|// the first shouldFlush() check next to another thread which flushes fast enough
comment|// to finish before the current thread could flip the asyncFlushRunning flag.
comment|// in that situation we have an extra unexpected flush.
name|asyncFlushRunning
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"submitting async flush request"
argument_list|)
expr_stmt|;
specifier|final
name|AbstractRunnable
name|abstractRunnable
init|=
operator|new
name|AbstractRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to flush index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
name|flush
argument_list|(
operator|new
name|FlushRequest
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onAfter
parameter_list|()
block|{
name|asyncFlushRunning
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|maybeFlush
argument_list|()
expr_stmt|;
comment|// fire a flush up again if we have filled up the limits such that shouldFlush() returns true
block|}
block|}
decl_stmt|;
name|threadPool
operator|.
name|executor
argument_list|(
name|ThreadPool
operator|.
name|Names
operator|.
name|FLUSH
argument_list|)
operator|.
name|execute
argument_list|(
name|abstractRunnable
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function

begin_comment
comment|/**      * Build {@linkplain RefreshListeners} for this shard. Protected so {@linkplain ShadowIndexShard} can override it to return null.      */
end_comment

begin_function
DECL|method|buildRefreshListeners
specifier|protected
name|RefreshListeners
name|buildRefreshListeners
parameter_list|()
block|{
return|return
operator|new
name|RefreshListeners
argument_list|(
name|indexSettings
operator|::
name|getMaxRefreshListeners
argument_list|,
parameter_list|()
lambda|->
name|refresh
argument_list|(
literal|"too_many_listeners"
argument_list|)
argument_list|,
name|threadPool
operator|.
name|executor
argument_list|(
name|ThreadPool
operator|.
name|Names
operator|.
name|LISTENER
argument_list|)
operator|::
name|execute
argument_list|,
name|logger
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**      * Simple struct encapsulating a shard failure      *      * @see IndexShard#addShardFailureCallback(Callback)      */
end_comment

begin_class
DECL|class|ShardFailure
specifier|public
specifier|static
specifier|final
class|class
name|ShardFailure
block|{
DECL|field|routing
specifier|public
specifier|final
name|ShardRouting
name|routing
decl_stmt|;
DECL|field|reason
specifier|public
specifier|final
name|String
name|reason
decl_stmt|;
annotation|@
name|Nullable
DECL|field|cause
specifier|public
specifier|final
name|Exception
name|cause
decl_stmt|;
DECL|method|ShardFailure
specifier|public
name|ShardFailure
parameter_list|(
name|ShardRouting
name|routing
parameter_list|,
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Exception
name|cause
parameter_list|)
block|{
name|this
operator|.
name|routing
operator|=
name|routing
expr_stmt|;
name|this
operator|.
name|reason
operator|=
name|reason
expr_stmt|;
name|this
operator|.
name|cause
operator|=
name|cause
expr_stmt|;
block|}
block|}
end_class

begin_function
DECL|method|getEngineFactory
name|EngineFactory
name|getEngineFactory
parameter_list|()
block|{
return|return
name|engineFactory
return|;
block|}
end_function

begin_comment
comment|/**      * Returns<code>true</code> iff one or more changes to the engine are not visible to via the current searcher *or* there are pending      * refresh listeners.      * Otherwise<code>false</code>.      *      * @throws EngineClosedException  if the engine is already closed      * @throws AlreadyClosedException if the internal indexwriter in the engine is already closed      */
end_comment

begin_function
DECL|method|isRefreshNeeded
specifier|public
name|boolean
name|isRefreshNeeded
parameter_list|()
block|{
return|return
name|getEngine
argument_list|()
operator|.
name|refreshNeeded
argument_list|()
operator|||
operator|(
name|refreshListeners
operator|!=
literal|null
operator|&&
name|refreshListeners
operator|.
name|refreshNeeded
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/**      * Add a listener for refreshes.      *      * @param location the location to listen for      * @param listener for the refresh. Called with true if registering the listener ran it out of slots and forced a refresh. Called with      *        false otherwise.      */
end_comment

begin_function
DECL|method|addRefreshListener
specifier|public
name|void
name|addRefreshListener
parameter_list|(
name|Translog
operator|.
name|Location
name|location
parameter_list|,
name|Consumer
argument_list|<
name|Boolean
argument_list|>
name|listener
parameter_list|)
block|{
name|refreshListeners
operator|.
name|addOrNotify
argument_list|(
name|location
argument_list|,
name|listener
argument_list|)
expr_stmt|;
block|}
end_function

begin_class
DECL|class|IndexShardRecoveryPerformer
specifier|private
class|class
name|IndexShardRecoveryPerformer
extends|extends
name|TranslogRecoveryPerformer
block|{
DECL|method|IndexShardRecoveryPerformer
specifier|protected
name|IndexShardRecoveryPerformer
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|Logger
name|logger
parameter_list|)
block|{
name|super
argument_list|(
name|shardId
argument_list|,
name|mapperService
argument_list|,
name|logger
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|operationProcessed
specifier|protected
name|void
name|operationProcessed
parameter_list|()
block|{
assert|assert
name|recoveryState
operator|!=
literal|null
assert|;
name|recoveryState
operator|.
name|getTranslog
argument_list|()
operator|.
name|incrementRecoveredOperations
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|recoveryFromSnapshot
specifier|public
name|int
name|recoveryFromSnapshot
parameter_list|(
name|Engine
name|engine
parameter_list|,
name|Translog
operator|.
name|Snapshot
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|recoveryState
operator|!=
literal|null
assert|;
name|RecoveryState
operator|.
name|Translog
name|translogStats
init|=
name|recoveryState
operator|.
name|getTranslog
argument_list|()
decl_stmt|;
name|translogStats
operator|.
name|totalOperations
argument_list|(
name|snapshot
operator|.
name|totalOperations
argument_list|()
argument_list|)
expr_stmt|;
name|translogStats
operator|.
name|totalOperationsOnStart
argument_list|(
name|snapshot
operator|.
name|totalOperations
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|super
operator|.
name|recoveryFromSnapshot
argument_list|(
name|engine
argument_list|,
name|snapshot
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|index
specifier|protected
name|void
name|index
parameter_list|(
name|Engine
name|engine
parameter_list|,
name|Engine
operator|.
name|Index
name|engineIndex
parameter_list|)
block|{
name|IndexShard
operator|.
name|this
operator|.
name|execute
argument_list|(
name|engine
argument_list|,
name|engineIndex
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|delete
specifier|protected
name|void
name|delete
parameter_list|(
name|Engine
name|engine
parameter_list|,
name|Engine
operator|.
name|Delete
name|engineDelete
parameter_list|)
block|{
name|IndexShard
operator|.
name|this
operator|.
name|execute
argument_list|(
name|engine
argument_list|,
name|engineDelete
argument_list|)
expr_stmt|;
block|}
block|}
end_class

unit|}
end_unit

