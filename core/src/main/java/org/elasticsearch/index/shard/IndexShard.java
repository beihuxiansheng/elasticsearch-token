begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.shard
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CheckIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|KeepOnlyLastCommitDeletionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SnapshotDeletionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|QueryCachingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|UsageTrackingQueryCachingPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|flush
operator|.
name|FlushRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|optimize
operator|.
name|OptimizeRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|upgrade
operator|.
name|post
operator|.
name|UpgradeRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|termvectors
operator|.
name|TermVectorsRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|termvectors
operator|.
name|TermVectorsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Booleans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|metrics
operator|.
name|MeanMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|BigArrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRefCounted
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|MetaDataStateFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|VersionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|aliases
operator|.
name|IndexAliasesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|IndexCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|IndexCacheModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|bitset
operator|.
name|ShardBitsetFilterCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|query
operator|.
name|QueryCacheStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|request
operator|.
name|ShardRequestCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|codec
operator|.
name|CodecService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|FieldDataStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldDataService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|ShardFieldData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|flush
operator|.
name|FlushStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|get
operator|.
name|GetStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|get
operator|.
name|ShardGetService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|indexing
operator|.
name|IndexingStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|indexing
operator|.
name|ShardIndexingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|merge
operator|.
name|MergeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|percolator
operator|.
name|PercolatorQueriesRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|percolator
operator|.
name|stats
operator|.
name|ShardPercolateService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|IndexQueryParserService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|recovery
operator|.
name|RecoveryStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|refresh
operator|.
name|RefreshStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|search
operator|.
name|stats
operator|.
name|SearchStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|search
operator|.
name|stats
operator|.
name|ShardSearchStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|settings
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|settings
operator|.
name|IndexSettingsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|similarity
operator|.
name|SimilarityService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|IndexShardRepository
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
operator|.
name|MetadataSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|suggest
operator|.
name|stats
operator|.
name|ShardSuggestMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|suggest
operator|.
name|stats
operator|.
name|SuggestStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|termvectors
operator|.
name|TermVectorsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|Translog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|warmer
operator|.
name|ShardIndexWarmerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|warmer
operator|.
name|WarmerStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesLifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesWarmer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|InternalIndicesLifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|cache
operator|.
name|query
operator|.
name|IndicesQueryCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|memory
operator|.
name|IndexingMemoryController
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|suggest
operator|.
name|completion
operator|.
name|Completion090PostingsFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|suggest
operator|.
name|completion
operator|.
name|CompletionStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedByInterruptException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_class
DECL|class|IndexShard
specifier|public
class|class
name|IndexShard
extends|extends
name|AbstractIndexShardComponent
implements|implements
name|IndexSettingsService
operator|.
name|Listener
block|{
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|mapperService
specifier|private
specifier|final
name|MapperService
name|mapperService
decl_stmt|;
DECL|field|queryParserService
specifier|private
specifier|final
name|IndexQueryParserService
name|queryParserService
decl_stmt|;
DECL|field|indexCache
specifier|private
specifier|final
name|IndexCache
name|indexCache
decl_stmt|;
DECL|field|indicesLifecycle
specifier|private
specifier|final
name|InternalIndicesLifecycle
name|indicesLifecycle
decl_stmt|;
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|mergeSchedulerConfig
specifier|private
specifier|final
name|MergeSchedulerConfig
name|mergeSchedulerConfig
decl_stmt|;
DECL|field|indexAliasesService
specifier|private
specifier|final
name|IndexAliasesService
name|indexAliasesService
decl_stmt|;
DECL|field|indexingService
specifier|private
specifier|final
name|ShardIndexingService
name|indexingService
decl_stmt|;
DECL|field|searchService
specifier|private
specifier|final
name|ShardSearchStats
name|searchService
decl_stmt|;
DECL|field|getService
specifier|private
specifier|final
name|ShardGetService
name|getService
decl_stmt|;
DECL|field|shardWarmerService
specifier|private
specifier|final
name|ShardIndexWarmerService
name|shardWarmerService
decl_stmt|;
DECL|field|shardQueryCache
specifier|private
specifier|final
name|ShardRequestCache
name|shardQueryCache
decl_stmt|;
DECL|field|shardFieldData
specifier|private
specifier|final
name|ShardFieldData
name|shardFieldData
decl_stmt|;
DECL|field|percolatorQueriesRegistry
specifier|private
specifier|final
name|PercolatorQueriesRegistry
name|percolatorQueriesRegistry
decl_stmt|;
DECL|field|shardPercolateService
specifier|private
specifier|final
name|ShardPercolateService
name|shardPercolateService
decl_stmt|;
DECL|field|termVectorsService
specifier|private
specifier|final
name|TermVectorsService
name|termVectorsService
decl_stmt|;
DECL|field|indexFieldDataService
specifier|private
specifier|final
name|IndexFieldDataService
name|indexFieldDataService
decl_stmt|;
DECL|field|shardSuggestMetric
specifier|private
specifier|final
name|ShardSuggestMetric
name|shardSuggestMetric
init|=
operator|new
name|ShardSuggestMetric
argument_list|()
decl_stmt|;
DECL|field|shardBitsetFilterCache
specifier|private
specifier|final
name|ShardBitsetFilterCache
name|shardBitsetFilterCache
decl_stmt|;
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|checkIndexOnStartup
specifier|private
specifier|final
name|String
name|checkIndexOnStartup
decl_stmt|;
DECL|field|codecService
specifier|private
specifier|final
name|CodecService
name|codecService
decl_stmt|;
DECL|field|warmer
specifier|private
specifier|final
name|IndicesWarmer
name|warmer
decl_stmt|;
DECL|field|deletionPolicy
specifier|private
specifier|final
name|SnapshotDeletionPolicy
name|deletionPolicy
decl_stmt|;
DECL|field|similarityService
specifier|private
specifier|final
name|SimilarityService
name|similarityService
decl_stmt|;
DECL|field|engineConfig
specifier|private
specifier|final
name|EngineConfig
name|engineConfig
decl_stmt|;
DECL|field|translogConfig
specifier|private
specifier|final
name|TranslogConfig
name|translogConfig
decl_stmt|;
DECL|field|mergePolicyConfig
specifier|private
specifier|final
name|MergePolicyConfig
name|mergePolicyConfig
decl_stmt|;
DECL|field|indicesQueryCache
specifier|private
specifier|final
name|IndicesQueryCache
name|indicesQueryCache
decl_stmt|;
DECL|field|refreshInterval
specifier|private
name|TimeValue
name|refreshInterval
decl_stmt|;
DECL|field|refreshScheduledFuture
specifier|private
specifier|volatile
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|refreshScheduledFuture
decl_stmt|;
DECL|field|mergeScheduleFuture
specifier|private
specifier|volatile
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|mergeScheduleFuture
decl_stmt|;
DECL|field|shardRouting
specifier|protected
specifier|volatile
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|field|state
specifier|protected
specifier|volatile
name|IndexShardState
name|state
decl_stmt|;
DECL|field|currentEngineReference
specifier|protected
specifier|final
name|AtomicReference
argument_list|<
name|Engine
argument_list|>
name|currentEngineReference
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|engineFactory
specifier|protected
specifier|final
name|EngineFactory
name|engineFactory
decl_stmt|;
DECL|field|wrappingService
specifier|private
specifier|final
name|IndexSearcherWrappingService
name|wrappingService
decl_stmt|;
annotation|@
name|Nullable
DECL|field|recoveryState
specifier|private
name|RecoveryState
name|recoveryState
decl_stmt|;
DECL|field|recoveryStats
specifier|private
specifier|final
name|RecoveryStats
name|recoveryStats
init|=
operator|new
name|RecoveryStats
argument_list|()
decl_stmt|;
DECL|field|refreshMetric
specifier|private
specifier|final
name|MeanMetric
name|refreshMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|field|flushMetric
specifier|private
specifier|final
name|MeanMetric
name|flushMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|field|failedEngineListener
specifier|private
specifier|final
name|ShardEngineFailListener
name|failedEngineListener
init|=
operator|new
name|ShardEngineFailListener
argument_list|()
decl_stmt|;
DECL|field|flushOnClose
specifier|private
specifier|volatile
name|boolean
name|flushOnClose
init|=
literal|true
decl_stmt|;
DECL|field|flushThresholdOperations
specifier|private
specifier|volatile
name|int
name|flushThresholdOperations
decl_stmt|;
DECL|field|flushThresholdSize
specifier|private
specifier|volatile
name|ByteSizeValue
name|flushThresholdSize
decl_stmt|;
DECL|field|disableFlush
specifier|private
specifier|volatile
name|boolean
name|disableFlush
decl_stmt|;
comment|/**      * Index setting to control if a flush is executed before engine is closed      * This setting is realtime updateable.      */
DECL|field|INDEX_FLUSH_ON_CLOSE
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_FLUSH_ON_CLOSE
init|=
literal|"index.flush_on_close"
decl_stmt|;
DECL|field|INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS
init|=
literal|"index.translog.flush_threshold_ops"
decl_stmt|;
DECL|field|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
init|=
literal|"index.translog.flush_threshold_size"
decl_stmt|;
DECL|field|INDEX_TRANSLOG_DISABLE_FLUSH
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_TRANSLOG_DISABLE_FLUSH
init|=
literal|"index.translog.disable_flush"
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|ShardPath
name|path
decl_stmt|;
DECL|field|indexShardOperationCounter
specifier|private
specifier|final
name|IndexShardOperationCounter
name|indexShardOperationCounter
decl_stmt|;
DECL|field|readAllowedStates
specifier|private
name|EnumSet
argument_list|<
name|IndexShardState
argument_list|>
name|readAllowedStates
init|=
name|EnumSet
operator|.
name|of
argument_list|(
name|IndexShardState
operator|.
name|STARTED
argument_list|,
name|IndexShardState
operator|.
name|RELOCATED
argument_list|,
name|IndexShardState
operator|.
name|POST_RECOVERY
argument_list|)
decl_stmt|;
DECL|field|active
specifier|private
specifier|final
name|AtomicBoolean
name|active
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|field|lastWriteNS
specifier|private
specifier|volatile
name|long
name|lastWriteNS
decl_stmt|;
DECL|field|indexingMemoryController
specifier|private
specifier|final
name|IndexingMemoryController
name|indexingMemoryController
decl_stmt|;
annotation|@
name|Inject
DECL|method|IndexShard
specifier|public
name|IndexShard
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|,
name|IndicesLifecycle
name|indicesLifecycle
parameter_list|,
name|Store
name|store
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|IndexQueryParserService
name|queryParserService
parameter_list|,
name|IndexCache
name|indexCache
parameter_list|,
name|IndexAliasesService
name|indexAliasesService
parameter_list|,
name|IndicesQueryCache
name|indicesQueryCache
parameter_list|,
name|CodecService
name|codecService
parameter_list|,
name|TermVectorsService
name|termVectorsService
parameter_list|,
name|IndexFieldDataService
name|indexFieldDataService
parameter_list|,
annotation|@
name|Nullable
name|IndicesWarmer
name|warmer
parameter_list|,
name|SimilarityService
name|similarityService
parameter_list|,
name|EngineFactory
name|factory
parameter_list|,
name|ShardPath
name|path
parameter_list|,
name|BigArrays
name|bigArrays
parameter_list|,
name|IndexSearcherWrappingService
name|wrappingService
parameter_list|,
name|IndexingMemoryController
name|indexingMemoryController
parameter_list|)
block|{
name|super
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|codecService
operator|=
name|codecService
expr_stmt|;
name|this
operator|.
name|warmer
operator|=
name|warmer
expr_stmt|;
name|this
operator|.
name|deletionPolicy
operator|=
operator|new
name|SnapshotDeletionPolicy
argument_list|(
operator|new
name|KeepOnlyLastCommitDeletionPolicy
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|similarityService
operator|=
name|similarityService
expr_stmt|;
name|this
operator|.
name|wrappingService
operator|=
name|wrappingService
expr_stmt|;
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|store
argument_list|,
literal|"Store must be provided to the index shard"
argument_list|)
expr_stmt|;
name|this
operator|.
name|engineFactory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|indicesLifecycle
operator|=
operator|(
name|InternalIndicesLifecycle
operator|)
name|indicesLifecycle
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
name|this
operator|.
name|mergeSchedulerConfig
operator|=
operator|new
name|MergeSchedulerConfig
argument_list|(
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|mapperService
operator|=
name|mapperService
expr_stmt|;
name|this
operator|.
name|queryParserService
operator|=
name|queryParserService
expr_stmt|;
name|this
operator|.
name|indexCache
operator|=
name|indexCache
expr_stmt|;
name|this
operator|.
name|indexAliasesService
operator|=
name|indexAliasesService
expr_stmt|;
name|this
operator|.
name|indexingService
operator|=
operator|new
name|ShardIndexingService
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|getService
operator|=
operator|new
name|ShardGetService
argument_list|(
name|this
argument_list|,
name|mapperService
argument_list|)
expr_stmt|;
name|this
operator|.
name|termVectorsService
operator|=
name|termVectorsService
expr_stmt|;
name|this
operator|.
name|searchService
operator|=
operator|new
name|ShardSearchStats
argument_list|(
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|shardWarmerService
operator|=
operator|new
name|ShardIndexWarmerService
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicesQueryCache
operator|=
name|indicesQueryCache
expr_stmt|;
name|this
operator|.
name|shardQueryCache
operator|=
operator|new
name|ShardRequestCache
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|shardFieldData
operator|=
operator|new
name|ShardFieldData
argument_list|()
expr_stmt|;
name|this
operator|.
name|shardPercolateService
operator|=
operator|new
name|ShardPercolateService
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|percolatorQueriesRegistry
operator|=
operator|new
name|PercolatorQueriesRegistry
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|,
name|queryParserService
argument_list|,
name|indexingService
argument_list|,
name|indicesLifecycle
argument_list|,
name|mapperService
argument_list|,
name|indexFieldDataService
argument_list|,
name|shardPercolateService
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexFieldDataService
operator|=
name|indexFieldDataService
expr_stmt|;
name|this
operator|.
name|shardBitsetFilterCache
operator|=
operator|new
name|ShardBitsetFilterCache
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|CREATED
expr_stmt|;
name|this
operator|.
name|refreshInterval
operator|=
name|indexSettings
operator|.
name|getAsTime
argument_list|(
name|INDEX_REFRESH_INTERVAL
argument_list|,
name|EngineConfig
operator|.
name|DEFAULT_REFRESH_INTERVAL
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushOnClose
operator|=
name|indexSettings
operator|.
name|getAsBoolean
argument_list|(
name|INDEX_FLUSH_ON_CLOSE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|this
operator|.
name|mergePolicyConfig
operator|=
operator|new
name|MergePolicyConfig
argument_list|(
name|logger
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
comment|/* create engine config */
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [CREATED]"
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkIndexOnStartup
operator|=
name|indexSettings
operator|.
name|get
argument_list|(
literal|"index.shard.check_on_startup"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|this
operator|.
name|translogConfig
operator|=
operator|new
name|TranslogConfig
argument_list|(
name|shardId
argument_list|,
name|shardPath
argument_list|()
operator|.
name|resolveTranslog
argument_list|()
argument_list|,
name|indexSettings
argument_list|,
name|getFromSettings
argument_list|(
name|logger
argument_list|,
name|indexSettings
argument_list|,
name|Translog
operator|.
name|Durabilty
operator|.
name|REQUEST
argument_list|)
argument_list|,
name|bigArrays
argument_list|,
name|threadPool
argument_list|)
expr_stmt|;
specifier|final
name|QueryCachingPolicy
name|cachingPolicy
decl_stmt|;
comment|// the query cache is a node-level thing, however we want the most popular filters
comment|// to be computed on a per-shard basis
if|if
condition|(
name|indexSettings
operator|.
name|getAsBoolean
argument_list|(
name|IndexCacheModule
operator|.
name|QUERY_CACHE_EVERYTHING
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|cachingPolicy
operator|=
name|QueryCachingPolicy
operator|.
name|ALWAYS_CACHE
expr_stmt|;
block|}
else|else
block|{
name|cachingPolicy
operator|=
operator|new
name|UsageTrackingQueryCachingPolicy
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|engineConfig
operator|=
name|newEngineConfig
argument_list|(
name|translogConfig
argument_list|,
name|cachingPolicy
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushThresholdOperations
operator|=
name|indexSettings
operator|.
name|getAsInt
argument_list|(
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS
argument_list|,
name|indexSettings
operator|.
name|getAsInt
argument_list|(
literal|"index.translog.flush_threshold"
argument_list|,
name|Integer
operator|.
name|MAX_VALUE
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushThresholdSize
operator|=
name|indexSettings
operator|.
name|getAsBytesSize
argument_list|(
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|512
argument_list|,
name|ByteSizeUnit
operator|.
name|MB
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|disableFlush
operator|=
name|indexSettings
operator|.
name|getAsBoolean
argument_list|(
name|INDEX_TRANSLOG_DISABLE_FLUSH
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexShardOperationCounter
operator|=
operator|new
name|IndexShardOperationCounter
argument_list|(
name|logger
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexingMemoryController
operator|=
name|indexingMemoryController
expr_stmt|;
comment|// TODO: can we somehow call IMC.forceCheck here?  Since we just became active, it can divvy up the RAM
name|active
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|store
specifier|public
name|Store
name|store
parameter_list|()
block|{
return|return
name|this
operator|.
name|store
return|;
block|}
comment|/** returns true if this shard supports indexing (i.e., write) operations. */
DECL|method|canIndex
specifier|public
name|boolean
name|canIndex
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|indexingService
specifier|public
name|ShardIndexingService
name|indexingService
parameter_list|()
block|{
return|return
name|this
operator|.
name|indexingService
return|;
block|}
DECL|method|getService
specifier|public
name|ShardGetService
name|getService
parameter_list|()
block|{
return|return
name|this
operator|.
name|getService
return|;
block|}
DECL|method|getSuggestMetric
specifier|public
name|ShardSuggestMetric
name|getSuggestMetric
parameter_list|()
block|{
return|return
name|shardSuggestMetric
return|;
block|}
DECL|method|shardBitsetFilterCache
specifier|public
name|ShardBitsetFilterCache
name|shardBitsetFilterCache
parameter_list|()
block|{
return|return
name|shardBitsetFilterCache
return|;
block|}
DECL|method|indexFieldDataService
specifier|public
name|IndexFieldDataService
name|indexFieldDataService
parameter_list|()
block|{
return|return
name|indexFieldDataService
return|;
block|}
DECL|method|mapperService
specifier|public
name|MapperService
name|mapperService
parameter_list|()
block|{
return|return
name|mapperService
return|;
block|}
DECL|method|searchService
specifier|public
name|ShardSearchStats
name|searchService
parameter_list|()
block|{
return|return
name|this
operator|.
name|searchService
return|;
block|}
DECL|method|warmerService
specifier|public
name|ShardIndexWarmerService
name|warmerService
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardWarmerService
return|;
block|}
DECL|method|requestCache
specifier|public
name|ShardRequestCache
name|requestCache
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardQueryCache
return|;
block|}
DECL|method|fieldData
specifier|public
name|ShardFieldData
name|fieldData
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardFieldData
return|;
block|}
comment|/**      * Returns the latest cluster routing entry received with this shard. Might be null if the      * shard was just created.      */
DECL|method|routingEntry
specifier|public
name|ShardRouting
name|routingEntry
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardRouting
return|;
block|}
DECL|method|getQueryCachingPolicy
specifier|public
name|QueryCachingPolicy
name|getQueryCachingPolicy
parameter_list|()
block|{
return|return
name|this
operator|.
name|engineConfig
operator|.
name|getQueryCachingPolicy
argument_list|()
return|;
block|}
comment|/**      * Updates the shards routing entry. This mutate the shards internal state depending      * on the changes that get introduced by the new routing value. This method will persist shard level metadata      * unless explicitly disabled.      */
DECL|method|updateRoutingEntry
specifier|public
name|void
name|updateRoutingEntry
parameter_list|(
specifier|final
name|ShardRouting
name|newRouting
parameter_list|,
specifier|final
name|boolean
name|persistState
parameter_list|)
block|{
specifier|final
name|ShardRouting
name|currentRouting
init|=
name|this
operator|.
name|shardRouting
decl_stmt|;
if|if
condition|(
operator|!
name|newRouting
operator|.
name|shardId
argument_list|()
operator|.
name|equals
argument_list|(
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Trying to set a routing entry with shardId ["
operator|+
name|newRouting
operator|.
name|shardId
argument_list|()
operator|+
literal|"] on a shard with shardId ["
operator|+
name|shardId
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|currentRouting
operator|==
literal|null
operator|||
name|newRouting
operator|.
name|isSameAllocation
argument_list|(
name|currentRouting
argument_list|)
operator|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Trying to set a routing entry with a different allocation. Current "
operator|+
name|currentRouting
operator|+
literal|", new "
operator|+
name|newRouting
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|currentRouting
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|newRouting
operator|.
name|primary
argument_list|()
operator|&&
name|currentRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"suspect illegal state: trying to move shard from primary mode to replica mode"
argument_list|)
expr_stmt|;
block|}
comment|// if its the same routing except for some metadata info, return
if|if
condition|(
name|currentRouting
operator|.
name|equalsIgnoringMetaData
argument_list|(
name|newRouting
argument_list|)
condition|)
block|{
name|this
operator|.
name|shardRouting
operator|=
name|newRouting
expr_stmt|;
comment|// might have a new version
return|return;
block|}
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
comment|// if the state is started or relocating (cause it might move right away from started to relocating)
comment|// then move to STARTED
if|if
condition|(
name|newRouting
operator|.
name|state
argument_list|()
operator|==
name|ShardRoutingState
operator|.
name|STARTED
operator|||
name|newRouting
operator|.
name|state
argument_list|()
operator|==
name|ShardRoutingState
operator|.
name|RELOCATING
condition|)
block|{
comment|// we want to refresh *before* we move to internal STARTED state
try|try
block|{
name|engine
argument_list|()
operator|.
name|refresh
argument_list|(
literal|"cluster_state_started"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to refresh due to move to cluster wide started"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|boolean
name|movedToStarted
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
comment|// do the check under a mutex, so we make sure to only change to STARTED if in POST_RECOVERY
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|STARTED
argument_list|,
literal|"global state is ["
operator|+
name|newRouting
operator|.
name|state
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|movedToStarted
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"state [{}] not changed, not in POST_RECOVERY, global state is [{}]"
argument_list|,
name|state
argument_list|,
name|newRouting
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|movedToStarted
condition|)
block|{
name|indicesLifecycle
operator|.
name|afterIndexShardStarted
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|shardRouting
operator|=
name|newRouting
expr_stmt|;
name|indicesLifecycle
operator|.
name|shardRoutingChanged
argument_list|(
name|this
argument_list|,
name|currentRouting
argument_list|,
name|newRouting
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|persistState
condition|)
block|{
name|persistMetadata
argument_list|(
name|newRouting
argument_list|,
name|currentRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Marks the shard as recovering based on a recovery state, fails with exception is recovering is not allowed to be set.      */
DECL|method|recovering
specifier|public
name|IndexShardState
name|recovering
parameter_list|(
name|String
name|reason
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardRecoveringException
throws|,
name|IndexShardClosedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardRecoveringException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IndexShardRecoveringException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
name|this
operator|.
name|recoveryState
operator|=
name|recoveryState
expr_stmt|;
return|return
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|RECOVERING
argument_list|,
name|reason
argument_list|)
return|;
block|}
block|}
DECL|method|relocated
specifier|public
name|IndexShard
name|relocated
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardNotStartedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|RELOCATED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|state
specifier|public
name|IndexShardState
name|state
parameter_list|()
block|{
return|return
name|state
return|;
block|}
comment|/**      * Changes the state of the current shard      *      * @param newState the new shard state      * @param reason   the reason for the state change      * @return the previous shard state      */
DECL|method|changeState
specifier|private
name|IndexShardState
name|changeState
parameter_list|(
name|IndexShardState
name|newState
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [{}]"
argument_list|,
name|state
argument_list|,
name|newState
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|IndexShardState
name|previousState
init|=
name|state
decl_stmt|;
name|state
operator|=
name|newState
expr_stmt|;
name|this
operator|.
name|indicesLifecycle
operator|.
name|indexShardStateChanged
argument_list|(
name|this
argument_list|,
name|previousState
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|previousState
return|;
block|}
DECL|method|prepareCreate
specifier|public
name|Engine
operator|.
name|Create
name|prepareCreate
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
block|{
try|try
block|{
return|return
name|prepareCreate
argument_list|(
name|docMapper
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
argument_list|,
name|source
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|verifyNotClosed
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
DECL|method|prepareCreate
specifier|static
name|Engine
operator|.
name|Create
name|prepareCreate
parameter_list|(
name|DocumentMapperForType
name|docMapper
parameter_list|,
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|docMapper
operator|.
name|getMapping
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|docMapper
operator|.
name|getMapping
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Engine
operator|.
name|Create
argument_list|(
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|doc
operator|.
name|uid
argument_list|()
operator|.
name|stringValue
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|)
return|;
block|}
DECL|method|create
specifier|public
name|void
name|create
parameter_list|(
name|Engine
operator|.
name|Create
name|create
parameter_list|)
block|{
name|ensureWriteAllowed
argument_list|(
name|create
argument_list|)
expr_stmt|;
name|create
operator|=
name|indexingService
operator|.
name|preCreate
argument_list|(
name|create
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"index [{}][{}]{}"
argument_list|,
name|create
operator|.
name|type
argument_list|()
argument_list|,
name|create
operator|.
name|id
argument_list|()
argument_list|,
name|create
operator|.
name|docs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
argument_list|()
operator|.
name|create
argument_list|(
name|create
argument_list|)
expr_stmt|;
name|create
operator|.
name|endTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|indexingService
operator|.
name|postCreate
argument_list|(
name|create
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|indexingService
operator|.
name|postCreate
argument_list|(
name|create
argument_list|)
expr_stmt|;
block|}
DECL|method|prepareIndex
specifier|public
name|Engine
operator|.
name|Index
name|prepareIndex
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
block|{
try|try
block|{
return|return
name|prepareIndex
argument_list|(
name|docMapper
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
argument_list|,
name|source
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|verifyNotClosed
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
DECL|method|prepareIndex
specifier|static
name|Engine
operator|.
name|Index
name|prepareIndex
parameter_list|(
name|DocumentMapperForType
name|docMapper
parameter_list|,
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|docMapper
operator|.
name|getMapping
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|docMapper
operator|.
name|getMapping
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Engine
operator|.
name|Index
argument_list|(
name|docMapper
operator|.
name|getDocumentMapper
argument_list|()
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|doc
operator|.
name|uid
argument_list|()
operator|.
name|stringValue
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|)
return|;
block|}
comment|/**      * Index a document and return whether it was created, as opposed to just      * updated.      */
DECL|method|index
specifier|public
name|boolean
name|index
parameter_list|(
name|Engine
operator|.
name|Index
name|index
parameter_list|)
block|{
name|ensureWriteAllowed
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|index
operator|=
name|indexingService
operator|.
name|preIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|created
decl_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"index [{}][{}]{}"
argument_list|,
name|index
operator|.
name|type
argument_list|()
argument_list|,
name|index
operator|.
name|id
argument_list|()
argument_list|,
name|index
operator|.
name|docs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|created
operator|=
name|engine
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|index
operator|.
name|endTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|indexingService
operator|.
name|postIndex
argument_list|(
name|index
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|indexingService
operator|.
name|postIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|created
return|;
block|}
DECL|method|prepareDelete
specifier|public
name|Engine
operator|.
name|Delete
name|prepareDelete
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
specifier|final
name|DocumentMapper
name|documentMapper
init|=
name|docMapper
argument_list|(
name|type
argument_list|)
operator|.
name|getDocumentMapper
argument_list|()
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|Delete
argument_list|(
name|type
argument_list|,
name|id
argument_list|,
name|documentMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|Uid
operator|.
name|createUid
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
argument_list|)
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|Engine
operator|.
name|Delete
name|delete
parameter_list|)
block|{
name|ensureWriteAllowed
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|delete
operator|=
name|indexingService
operator|.
name|preDelete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"delete [{}]"
argument_list|,
name|delete
operator|.
name|uid
argument_list|()
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
argument_list|()
operator|.
name|delete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|delete
operator|.
name|endTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|indexingService
operator|.
name|postDelete
argument_list|(
name|delete
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|indexingService
operator|.
name|postDelete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
DECL|method|get
specifier|public
name|Engine
operator|.
name|GetResult
name|get
parameter_list|(
name|Engine
operator|.
name|Get
name|get
parameter_list|)
block|{
name|readAllowed
argument_list|()
expr_stmt|;
return|return
name|engine
argument_list|()
operator|.
name|get
argument_list|(
name|get
argument_list|)
return|;
block|}
DECL|method|refresh
specifier|public
name|void
name|refresh
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|verifyNotClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"refresh with source: {}"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|engine
argument_list|()
operator|.
name|refresh
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|refreshMetric
operator|.
name|inc
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|time
argument_list|)
expr_stmt|;
block|}
DECL|method|refreshStats
specifier|public
name|RefreshStats
name|refreshStats
parameter_list|()
block|{
return|return
operator|new
name|RefreshStats
argument_list|(
name|refreshMetric
operator|.
name|count
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|refreshMetric
operator|.
name|sum
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|flushStats
specifier|public
name|FlushStats
name|flushStats
parameter_list|()
block|{
return|return
operator|new
name|FlushStats
argument_list|(
name|flushMetric
operator|.
name|count
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|flushMetric
operator|.
name|sum
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|docStats
specifier|public
name|DocsStats
name|docStats
parameter_list|()
block|{
specifier|final
name|Engine
operator|.
name|Searcher
name|searcher
init|=
name|acquireSearcher
argument_list|(
literal|"doc_stats"
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|new
name|DocsStats
argument_list|(
name|searcher
operator|.
name|reader
argument_list|()
operator|.
name|numDocs
argument_list|()
argument_list|,
name|searcher
operator|.
name|reader
argument_list|()
operator|.
name|numDeletedDocs
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|searcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @return {@link CommitStats} if engine is open, otherwise null      */
annotation|@
name|Nullable
DECL|method|commitStats
specifier|public
name|CommitStats
name|commitStats
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
return|return
name|engine
operator|==
literal|null
condition|?
literal|null
else|:
name|engine
operator|.
name|commitStats
argument_list|()
return|;
block|}
DECL|method|indexingStats
specifier|public
name|IndexingStats
name|indexingStats
parameter_list|(
name|String
modifier|...
name|types
parameter_list|)
block|{
return|return
name|indexingService
operator|.
name|stats
argument_list|(
name|types
argument_list|)
return|;
block|}
DECL|method|searchStats
specifier|public
name|SearchStats
name|searchStats
parameter_list|(
name|String
modifier|...
name|groups
parameter_list|)
block|{
return|return
name|searchService
operator|.
name|stats
argument_list|(
name|groups
argument_list|)
return|;
block|}
DECL|method|getStats
specifier|public
name|GetStats
name|getStats
parameter_list|()
block|{
return|return
name|getService
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|storeStats
specifier|public
name|StoreStats
name|storeStats
parameter_list|()
block|{
try|try
block|{
return|return
name|store
operator|.
name|stats
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"io exception while building 'store stats'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
return|return
literal|null
return|;
comment|// already closed
block|}
block|}
DECL|method|mergeStats
specifier|public
name|MergeStats
name|mergeStats
parameter_list|()
block|{
specifier|final
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|MergeStats
argument_list|()
return|;
block|}
return|return
name|engine
operator|.
name|getMergeStats
argument_list|()
return|;
block|}
DECL|method|segmentStats
specifier|public
name|SegmentsStats
name|segmentStats
parameter_list|()
block|{
name|SegmentsStats
name|segmentsStats
init|=
name|engine
argument_list|()
operator|.
name|segmentsStats
argument_list|()
decl_stmt|;
name|segmentsStats
operator|.
name|addBitsetMemoryInBytes
argument_list|(
name|shardBitsetFilterCache
operator|.
name|getMemorySizeInBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|segmentsStats
return|;
block|}
DECL|method|getTermVectors
specifier|public
name|TermVectorsResponse
name|getTermVectors
parameter_list|(
name|TermVectorsRequest
name|request
parameter_list|)
block|{
return|return
name|this
operator|.
name|termVectorsService
operator|.
name|getTermVectors
argument_list|(
name|this
argument_list|,
name|request
argument_list|)
return|;
block|}
DECL|method|warmerStats
specifier|public
name|WarmerStats
name|warmerStats
parameter_list|()
block|{
return|return
name|shardWarmerService
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|queryCacheStats
specifier|public
name|QueryCacheStats
name|queryCacheStats
parameter_list|()
block|{
return|return
name|indicesQueryCache
operator|.
name|getStats
argument_list|(
name|shardId
argument_list|)
return|;
block|}
DECL|method|fieldDataStats
specifier|public
name|FieldDataStats
name|fieldDataStats
parameter_list|(
name|String
modifier|...
name|fields
parameter_list|)
block|{
return|return
name|shardFieldData
operator|.
name|stats
argument_list|(
name|fields
argument_list|)
return|;
block|}
DECL|method|percolateRegistry
specifier|public
name|PercolatorQueriesRegistry
name|percolateRegistry
parameter_list|()
block|{
return|return
name|percolatorQueriesRegistry
return|;
block|}
DECL|method|shardPercolateService
specifier|public
name|ShardPercolateService
name|shardPercolateService
parameter_list|()
block|{
return|return
name|shardPercolateService
return|;
block|}
DECL|method|translogStats
specifier|public
name|TranslogStats
name|translogStats
parameter_list|()
block|{
return|return
name|engine
argument_list|()
operator|.
name|getTranslog
argument_list|()
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|suggestStats
specifier|public
name|SuggestStats
name|suggestStats
parameter_list|()
block|{
return|return
name|shardSuggestMetric
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|completionStats
specifier|public
name|CompletionStats
name|completionStats
parameter_list|(
name|String
modifier|...
name|fields
parameter_list|)
block|{
name|CompletionStats
name|completionStats
init|=
operator|new
name|CompletionStats
argument_list|()
decl_stmt|;
specifier|final
name|Engine
operator|.
name|Searcher
name|currentSearcher
init|=
name|acquireSearcher
argument_list|(
literal|"completion_stats"
argument_list|)
decl_stmt|;
try|try
block|{
name|PostingsFormat
name|postingsFormat
init|=
name|PostingsFormat
operator|.
name|forName
argument_list|(
name|Completion090PostingsFormat
operator|.
name|CODEC_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|postingsFormat
operator|instanceof
name|Completion090PostingsFormat
condition|)
block|{
name|Completion090PostingsFormat
name|completionPostingsFormat
init|=
operator|(
name|Completion090PostingsFormat
operator|)
name|postingsFormat
decl_stmt|;
name|completionStats
operator|.
name|add
argument_list|(
name|completionPostingsFormat
operator|.
name|completionStats
argument_list|(
name|currentSearcher
operator|.
name|reader
argument_list|()
argument_list|,
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|currentSearcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|completionStats
return|;
block|}
DECL|method|syncFlush
specifier|public
name|Engine
operator|.
name|SyncedFlushResult
name|syncFlush
parameter_list|(
name|String
name|syncId
parameter_list|,
name|Engine
operator|.
name|CommitId
name|expectedCommitId
parameter_list|)
block|{
name|verifyStartedOrRecovering
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"trying to sync flush. sync id [{}]. expected commit id [{}]]"
argument_list|,
name|syncId
argument_list|,
name|expectedCommitId
argument_list|)
expr_stmt|;
return|return
name|engine
argument_list|()
operator|.
name|syncFlush
argument_list|(
name|syncId
argument_list|,
name|expectedCommitId
argument_list|)
return|;
block|}
DECL|method|flush
specifier|public
name|Engine
operator|.
name|CommitId
name|flush
parameter_list|(
name|FlushRequest
name|request
parameter_list|)
throws|throws
name|ElasticsearchException
block|{
name|boolean
name|waitIfOngoing
init|=
name|request
operator|.
name|waitIfOngoing
argument_list|()
decl_stmt|;
name|boolean
name|force
init|=
name|request
operator|.
name|force
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"flush with {}"
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
comment|// we allows flush while recovering, since we allow for operations to happen
comment|// while recovering, and we want to keep the translog at bay (up to deletes, which
comment|// we don't gc).
name|verifyStartedOrRecovering
argument_list|()
expr_stmt|;
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|Engine
operator|.
name|CommitId
name|commitId
init|=
name|engine
argument_list|()
operator|.
name|flush
argument_list|(
name|force
argument_list|,
name|waitIfOngoing
argument_list|)
decl_stmt|;
name|flushMetric
operator|.
name|inc
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|time
argument_list|)
expr_stmt|;
return|return
name|commitId
return|;
block|}
DECL|method|optimize
specifier|public
name|void
name|optimize
parameter_list|(
name|OptimizeRequest
name|optimize
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyStarted
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"optimize with {}"
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
block|}
name|engine
argument_list|()
operator|.
name|forceMerge
argument_list|(
name|optimize
operator|.
name|flush
argument_list|()
argument_list|,
name|optimize
operator|.
name|maxNumSegments
argument_list|()
argument_list|,
name|optimize
operator|.
name|onlyExpungeDeletes
argument_list|()
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Upgrades the shard to the current version of Lucene and returns the minimum segment version      */
DECL|method|upgrade
specifier|public
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|upgrade
parameter_list|(
name|UpgradeRequest
name|upgrade
parameter_list|)
throws|throws
name|IOException
block|{
name|verifyStarted
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"upgrade with {}"
argument_list|,
name|upgrade
argument_list|)
expr_stmt|;
block|}
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|previousVersion
init|=
name|minimumCompatibleVersion
argument_list|()
decl_stmt|;
comment|// we just want to upgrade the segments, not actually optimize to a single segment
name|engine
argument_list|()
operator|.
name|forceMerge
argument_list|(
literal|true
argument_list|,
comment|// we need to flush at the end to make sure the upgrade is durable
name|Integer
operator|.
name|MAX_VALUE
argument_list|,
comment|// we just want to upgrade the segments, not actually optimize to a single segment
literal|false
argument_list|,
literal|true
argument_list|,
name|upgrade
operator|.
name|upgradeOnlyAncientSegments
argument_list|()
argument_list|)
expr_stmt|;
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|version
init|=
name|minimumCompatibleVersion
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"upgraded segment {} from version {} to version {}"
argument_list|,
name|previousVersion
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
return|return
name|version
return|;
block|}
DECL|method|minimumCompatibleVersion
specifier|public
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|minimumCompatibleVersion
parameter_list|()
block|{
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
name|luceneVersion
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Segment
name|segment
range|:
name|engine
argument_list|()
operator|.
name|segments
argument_list|(
literal|false
argument_list|)
control|)
block|{
if|if
condition|(
name|luceneVersion
operator|==
literal|null
operator|||
name|luceneVersion
operator|.
name|onOrAfter
argument_list|(
name|segment
operator|.
name|getVersion
argument_list|()
argument_list|)
condition|)
block|{
name|luceneVersion
operator|=
name|segment
operator|.
name|getVersion
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|luceneVersion
operator|==
literal|null
condition|?
name|Version
operator|.
name|indexCreated
argument_list|(
name|indexSettings
argument_list|)
operator|.
name|luceneVersion
else|:
name|luceneVersion
return|;
block|}
comment|/**      * Creates a new {@link IndexCommit} snapshot form the currently running engine. All resources referenced by this      * commit won't be freed until the commit / snapshot is released via {@link #releaseSnapshot(IndexCommit)}.      *      * @param flushFirst<code>true</code> if the index should first be flushed to disk / a low level lucene commit should be executed      */
DECL|method|snapshotIndex
specifier|public
name|IndexCommit
name|snapshotIndex
parameter_list|(
name|boolean
name|flushFirst
parameter_list|)
throws|throws
name|EngineException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
comment|// we allow snapshot on closed index shard, since we want to do one after we close the shard and before we close the engine
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
return|return
name|engine
argument_list|()
operator|.
name|snapshotIndex
argument_list|(
name|flushFirst
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"snapshot is not allowed"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Releases a snapshot taken from {@link #snapshotIndex(boolean)} this must be called to release the resources      * referenced by the given snapshot {@link IndexCommit}.      */
DECL|method|releaseSnapshot
specifier|public
name|void
name|releaseSnapshot
parameter_list|(
name|IndexCommit
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|deletionPolicy
operator|.
name|release
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fails the shard and marks the shard store as corrupted if      *<code>e</code> is caused by index corruption      */
DECL|method|failShard
specifier|public
name|void
name|failShard
parameter_list|(
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|e
parameter_list|)
block|{
comment|// fail the engine. This will cause this shard to also be removed from the node's index service.
name|engine
argument_list|()
operator|.
name|failEngine
argument_list|(
name|reason
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|acquireSearcher
specifier|public
name|Engine
operator|.
name|Searcher
name|acquireSearcher
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|readAllowed
argument_list|()
expr_stmt|;
return|return
name|engine
argument_list|()
operator|.
name|acquireSearcher
argument_list|(
name|source
argument_list|)
return|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|String
name|reason
parameter_list|,
name|boolean
name|flushEngine
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
try|try
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|refreshScheduledFuture
argument_list|)
expr_stmt|;
name|refreshScheduledFuture
operator|=
literal|null
expr_stmt|;
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|mergeScheduleFuture
argument_list|)
expr_stmt|;
name|mergeScheduleFuture
operator|=
literal|null
expr_stmt|;
block|}
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|CLOSED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|indexShardOperationCounter
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
specifier|final
name|Engine
name|engine
init|=
name|this
operator|.
name|currentEngineReference
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|engine
operator|!=
literal|null
operator|&&
name|flushEngine
operator|&&
name|this
operator|.
name|flushOnClose
condition|)
block|{
name|engine
operator|.
name|flushAndClose
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// playing safe here and close the engine even if the above succeeds - close can be called multiple times
name|IOUtils
operator|.
name|close
argument_list|(
name|engine
argument_list|,
name|percolatorQueriesRegistry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|postRecovery
specifier|public
name|IndexShard
name|postRecovery
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardClosedException
block|{
name|indicesLifecycle
operator|.
name|beforeIndexShardPostRecovery
argument_list|(
name|this
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|POST_RECOVERY
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
name|indicesLifecycle
operator|.
name|afterIndexShardPostRecovery
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * called before starting to copy index files over      */
DECL|method|prepareForIndexRecovery
specifier|public
name|void
name|prepareForIndexRecovery
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|INDEX
argument_list|)
expr_stmt|;
assert|assert
name|currentEngineReference
operator|.
name|get
argument_list|()
operator|==
literal|null
assert|;
block|}
comment|/**      * Applies all operations in the iterable to the current engine and returns the number of operations applied.      * This operation will stop applying operations once an operation failed to apply.      * Note: This method is typically used in peer recovery to replay remote transaction log entries.      */
DECL|method|performBatchRecovery
specifier|public
name|int
name|performBatchRecovery
parameter_list|(
name|Iterable
argument_list|<
name|Translog
operator|.
name|Operation
argument_list|>
name|operations
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
return|return
name|engineConfig
operator|.
name|getTranslogRecoveryPerformer
argument_list|()
operator|.
name|performBatchRecovery
argument_list|(
name|engine
argument_list|()
argument_list|,
name|operations
argument_list|)
return|;
block|}
comment|/**      * After the store has been recovered, we need to start the engine in order to apply operations      */
DECL|method|performTranslogRecovery
specifier|public
name|void
name|performTranslogRecovery
parameter_list|(
name|boolean
name|indexExists
parameter_list|)
block|{
name|internalPerformTranslogRecovery
argument_list|(
literal|false
argument_list|,
name|indexExists
argument_list|)
expr_stmt|;
assert|assert
name|recoveryState
operator|.
name|getStage
argument_list|()
operator|==
name|RecoveryState
operator|.
name|Stage
operator|.
name|TRANSLOG
operator|:
literal|"TRANSLOG stage expected but was: "
operator|+
name|recoveryState
operator|.
name|getStage
argument_list|()
assert|;
block|}
DECL|method|internalPerformTranslogRecovery
specifier|private
name|void
name|internalPerformTranslogRecovery
parameter_list|(
name|boolean
name|skipTranslogRecovery
parameter_list|,
name|boolean
name|indexExists
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|VERIFY_INDEX
argument_list|)
expr_stmt|;
comment|// also check here, before we apply the translog
if|if
condition|(
name|Booleans
operator|.
name|parseBoolean
argument_list|(
name|checkIndexOnStartup
argument_list|,
literal|false
argument_list|)
condition|)
block|{
try|try
block|{
name|checkIndex
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RecoveryFailedException
argument_list|(
name|recoveryState
argument_list|,
literal|"check index failed"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|TRANSLOG
argument_list|)
expr_stmt|;
comment|// we disable deletes since we allow for operations to be executed against the shard while recovering
comment|// but we need to make sure we don't loose deletes until we are done recovering
name|engineConfig
operator|.
name|setEnableGcDeletes
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|engineConfig
operator|.
name|setCreate
argument_list|(
name|indexExists
operator|==
literal|false
argument_list|)
expr_stmt|;
name|createNewEngine
argument_list|(
name|skipTranslogRecovery
argument_list|,
name|engineConfig
argument_list|)
expr_stmt|;
block|}
comment|/**      * After the store has been recovered, we need to start the engine. This method starts a new engine but skips      * the replay of the transaction log which is required in cases where we restore a previous index or recover from      * a remote peer.      */
DECL|method|skipTranslogRecovery
specifier|public
name|void
name|skipTranslogRecovery
parameter_list|()
throws|throws
name|IOException
block|{
assert|assert
name|engineUnsafe
argument_list|()
operator|==
literal|null
operator|:
literal|"engine was already created"
assert|;
name|internalPerformTranslogRecovery
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
assert|assert
name|recoveryState
operator|.
name|getTranslog
argument_list|()
operator|.
name|recoveredOperations
argument_list|()
operator|==
literal|0
assert|;
block|}
comment|/**      * called if recovery has to be restarted after network error / delay **      */
DECL|method|performRecoveryRestart
specifier|public
name|void
name|performRecoveryRestart
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
specifier|final
name|Engine
name|engine
init|=
name|this
operator|.
name|currentEngineReference
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|recoveryState
argument_list|()
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|INIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * returns stats about ongoing recoveries, both source and target      */
DECL|method|recoveryStats
specifier|public
name|RecoveryStats
name|recoveryStats
parameter_list|()
block|{
return|return
name|recoveryStats
return|;
block|}
comment|/**      * Returns the current {@link RecoveryState} if this shard is recovering or has been recovering.      * Returns null if the recovery has not yet started or shard was not recovered (created via an API).      */
DECL|method|recoveryState
specifier|public
name|RecoveryState
name|recoveryState
parameter_list|()
block|{
return|return
name|this
operator|.
name|recoveryState
return|;
block|}
comment|/**      * perform the last stages of recovery once all translog operations are done.      * note that you should still call {@link #postRecovery(String)}.      */
DECL|method|finalizeRecovery
specifier|public
name|void
name|finalizeRecovery
parameter_list|()
block|{
name|recoveryState
argument_list|()
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|FINALIZE
argument_list|)
expr_stmt|;
name|engine
argument_list|()
operator|.
name|refresh
argument_list|(
literal|"recovery_finalization"
argument_list|)
expr_stmt|;
name|startScheduledTasksIfNeeded
argument_list|()
expr_stmt|;
name|engineConfig
operator|.
name|setEnableGcDeletes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<tt>true</tt> if this shard can ignore a recovery attempt made to it (since the already doing/done it)      */
DECL|method|ignoreRecoveryAttempt
specifier|public
name|boolean
name|ignoreRecoveryAttempt
parameter_list|()
block|{
name|IndexShardState
name|state
init|=
name|state
argument_list|()
decl_stmt|;
comment|// one time volatile read
return|return
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
return|;
block|}
DECL|method|readAllowed
specifier|public
name|void
name|readAllowed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|readAllowedStates
operator|.
name|contains
argument_list|(
name|state
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operations only allowed when shard state is one of "
operator|+
name|readAllowedStates
operator|.
name|toString
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|/** Returns timestamp of last indexing operation */
DECL|method|getLastWriteNS
specifier|public
name|long
name|getLastWriteNS
parameter_list|()
block|{
return|return
name|lastWriteNS
return|;
block|}
DECL|method|ensureWriteAllowed
specifier|private
name|void
name|ensureWriteAllowed
parameter_list|(
name|Engine
operator|.
name|Operation
name|op
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
block|{
name|lastWriteNS
operator|=
name|op
operator|.
name|startTime
argument_list|()
expr_stmt|;
if|if
condition|(
name|active
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// We are currently inactive, but a new write operation just showed up, so we now notify IMC
comment|// to wake up and fix our indexing buffer.  We could do this async instead, but cost should
comment|// be low, and it's rare this happens.
name|indexingMemoryController
operator|.
name|forceCheck
argument_list|()
expr_stmt|;
block|}
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
init|=
name|op
operator|.
name|origin
argument_list|()
decl_stmt|;
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|origin
operator|==
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|PRIMARY
condition|)
block|{
comment|// for primaries, we only allow to write when actually started (so the cluster has decided we started)
comment|// otherwise, we need to retry, we also want to still allow to index if we are relocated in case it fails
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when started/recovering, origin ["
operator|+
name|origin
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// for replicas, we allow to write also while recovering, since we index also during recovery to replicas
comment|// and rely on version checks to make sure its consistent
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when started/recovering, origin ["
operator|+
name|origin
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|verifyStartedOrRecovering
specifier|protected
specifier|final
name|void
name|verifyStartedOrRecovering
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when started/recovering"
argument_list|)
throw|;
block|}
block|}
DECL|method|verifyNotClosed
specifier|private
name|void
name|verifyNotClosed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|verifyNotClosed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyNotClosed
specifier|private
name|void
name|verifyNotClosed
parameter_list|(
name|Throwable
name|suppressed
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
specifier|final
name|IllegalIndexShardStateException
name|exc
init|=
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when not closed"
argument_list|)
decl_stmt|;
if|if
condition|(
name|suppressed
operator|!=
literal|null
condition|)
block|{
name|exc
operator|.
name|addSuppressed
argument_list|(
name|suppressed
argument_list|)
expr_stmt|;
block|}
throw|throw
name|exc
throw|;
block|}
block|}
DECL|method|verifyStarted
specifier|protected
specifier|final
name|void
name|verifyStarted
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
block|}
DECL|method|startScheduledTasksIfNeeded
specifier|private
name|void
name|startScheduledTasksIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|refreshInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
operator|new
name|EngineRefresher
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduling refresher every {}"
argument_list|,
name|refreshInterval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduled refresher disabled"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|INDEX_REFRESH_INTERVAL
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_REFRESH_INTERVAL
init|=
literal|"index.refresh_interval"
decl_stmt|;
DECL|method|addFailedEngineListener
specifier|public
name|void
name|addFailedEngineListener
parameter_list|(
name|Engine
operator|.
name|FailedEngineListener
name|failedEngineListener
parameter_list|)
block|{
name|this
operator|.
name|failedEngineListener
operator|.
name|delegates
operator|.
name|add
argument_list|(
name|failedEngineListener
argument_list|)
expr_stmt|;
block|}
comment|/** Change the indexing and translog buffer sizes.  If {@code IndexWriter} is currently using more than      *  the new buffering indexing size then we do a refresh to free up the heap. */
DECL|method|updateBufferSize
specifier|public
name|void
name|updateBufferSize
parameter_list|(
name|ByteSizeValue
name|shardIndexingBufferSize
parameter_list|,
name|ByteSizeValue
name|shardTranslogBufferSize
parameter_list|)
block|{
specifier|final
name|EngineConfig
name|config
init|=
name|engineConfig
decl_stmt|;
specifier|final
name|ByteSizeValue
name|preValue
init|=
name|config
operator|.
name|getIndexingBufferSize
argument_list|()
decl_stmt|;
name|config
operator|.
name|setIndexingBufferSize
argument_list|(
name|shardIndexingBufferSize
argument_list|)
expr_stmt|;
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updateBufferSize: engine is closed; skipping"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// update engine if it is already started.
if|if
condition|(
name|preValue
operator|.
name|bytes
argument_list|()
operator|!=
name|shardIndexingBufferSize
operator|.
name|bytes
argument_list|()
condition|)
block|{
comment|// so we push changes these changes down to IndexWriter:
name|engine
operator|.
name|onSettingsChanged
argument_list|()
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"updating index_buffer_size from [{}] to [{}]"
argument_list|,
name|preValue
argument_list|,
name|shardIndexingBufferSize
argument_list|)
expr_stmt|;
name|long
name|iwBytesUsed
init|=
name|engine
operator|.
name|indexWriterRAMBytesUsed
argument_list|()
decl_stmt|;
if|if
condition|(
name|shardIndexingBufferSize
operator|.
name|bytes
argument_list|()
operator|<
name|iwBytesUsed
condition|)
block|{
comment|// our allowed buffer was changed to less than we are currently using; we ask IW to refresh
comment|// so it clears its buffers (otherwise it won't clear until the next indexing/delete op)
name|logger
operator|.
name|debug
argument_list|(
literal|"refresh because index buffer decreased to [{}] and IndexWriter is now using [{}] bytes"
argument_list|,
name|shardIndexingBufferSize
argument_list|,
name|iwBytesUsed
argument_list|)
expr_stmt|;
comment|// TODO: should IW have an API to move segments to disk, but not refresh?
try|try
block|{
name|refresh
argument_list|(
literal|"update index buffer"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to refresh after decreasing index buffer"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|engine
operator|.
name|getTranslog
argument_list|()
operator|.
name|updateBuffer
argument_list|(
name|shardTranslogBufferSize
argument_list|)
expr_stmt|;
block|}
DECL|method|markAsInactive
specifier|public
name|void
name|markAsInactive
parameter_list|()
block|{
if|if
condition|(
name|active
operator|.
name|getAndSet
argument_list|(
literal|false
argument_list|)
condition|)
block|{
name|updateBufferSize
argument_list|(
name|EngineConfig
operator|.
name|INACTIVE_SHARD_INDEXING_BUFFER
argument_list|,
name|TranslogConfig
operator|.
name|INACTIVE_SHARD_TRANSLOG_BUFFER
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"shard is now inactive"
argument_list|)
expr_stmt|;
name|indicesLifecycle
operator|.
name|onShardInactive
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns {@code true} if this shard is active (has seen indexing ops in the last {@link      *  IndexingMemoryController#SHARD_INACTIVE_TIME_SETTING} (default 5 minutes), else {@code false}. */
DECL|method|getActive
specifier|public
name|boolean
name|getActive
parameter_list|()
block|{
return|return
name|active
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|isFlushOnClose
specifier|public
specifier|final
name|boolean
name|isFlushOnClose
parameter_list|()
block|{
return|return
name|flushOnClose
return|;
block|}
comment|/**      * Deletes the shards metadata state. This method can only be executed if the shard is not active.      *      * @throws IOException if the delete fails      */
DECL|method|deleteShardState
specifier|public
name|void
name|deleteShardState
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|routingEntry
argument_list|()
operator|!=
literal|null
operator|&&
name|this
operator|.
name|routingEntry
argument_list|()
operator|.
name|active
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't delete shard state on an active shard"
argument_list|)
throw|;
block|}
name|MetaDataStateFormat
operator|.
name|deleteMetaState
argument_list|(
name|shardPath
argument_list|()
operator|.
name|getDataPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|shardPath
specifier|public
name|ShardPath
name|shardPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
DECL|method|recoverFromStore
specifier|public
name|boolean
name|recoverFromStore
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|DiscoveryNode
name|localNode
parameter_list|)
block|{
comment|// we are the first primary, recover from the gateway
comment|// if its post api allocation, the index should exists
assert|assert
name|shard
operator|.
name|primary
argument_list|()
operator|:
literal|"recover from store only makes sense if the shard is a primary shard"
assert|;
specifier|final
name|boolean
name|shouldExist
init|=
name|shard
operator|.
name|allocatedPostIndexCreate
argument_list|()
decl_stmt|;
name|StoreRecovery
name|storeRecovery
init|=
operator|new
name|StoreRecovery
argument_list|(
name|shardId
argument_list|,
name|logger
argument_list|)
decl_stmt|;
return|return
name|storeRecovery
operator|.
name|recoverFromStore
argument_list|(
name|this
argument_list|,
name|shouldExist
argument_list|,
name|localNode
argument_list|)
return|;
block|}
DECL|method|restoreFromRepository
specifier|public
name|boolean
name|restoreFromRepository
parameter_list|(
name|ShardRouting
name|shard
parameter_list|,
name|IndexShardRepository
name|repository
parameter_list|,
name|DiscoveryNode
name|locaNode
parameter_list|)
block|{
assert|assert
name|shard
operator|.
name|primary
argument_list|()
operator|:
literal|"recover from store only makes sense if the shard is a primary shard"
assert|;
name|StoreRecovery
name|storeRecovery
init|=
operator|new
name|StoreRecovery
argument_list|(
name|shardId
argument_list|,
name|logger
argument_list|)
decl_stmt|;
return|return
name|storeRecovery
operator|.
name|recoverFromRepository
argument_list|(
name|this
argument_list|,
name|repository
argument_list|,
name|locaNode
argument_list|)
return|;
block|}
comment|/**      * Returns<code>true</code> iff this shard needs to be flushed due to too many translog operation or a too large transaction log.      * Otherwise<code>false</code>.      */
DECL|method|shouldFlush
name|boolean
name|shouldFlush
parameter_list|()
block|{
if|if
condition|(
name|disableFlush
operator|==
literal|false
condition|)
block|{
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|Translog
name|translog
init|=
name|engine
operator|.
name|getTranslog
argument_list|()
decl_stmt|;
return|return
name|translog
operator|.
name|totalOperations
argument_list|()
operator|>
name|flushThresholdOperations
operator|||
name|translog
operator|.
name|sizeInBytes
argument_list|()
operator|>
name|flushThresholdSize
operator|.
name|bytes
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
comment|// that's fine we are already close - no need to flush
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|onRefreshSettings
specifier|public
name|void
name|onRefreshSettings
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|boolean
name|change
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// no need to update anything if we are closed
return|return;
block|}
name|int
name|flushThresholdOperations
init|=
name|settings
operator|.
name|getAsInt
argument_list|(
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_OPS
argument_list|,
name|this
operator|.
name|flushThresholdOperations
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushThresholdOperations
operator|!=
name|this
operator|.
name|flushThresholdOperations
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating flush_threshold_ops from [{}] to [{}]"
argument_list|,
name|this
operator|.
name|flushThresholdOperations
argument_list|,
name|flushThresholdOperations
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushThresholdOperations
operator|=
name|flushThresholdOperations
expr_stmt|;
block|}
name|ByteSizeValue
name|flushThresholdSize
init|=
name|settings
operator|.
name|getAsBytesSize
argument_list|(
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
argument_list|,
name|this
operator|.
name|flushThresholdSize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flushThresholdSize
operator|.
name|equals
argument_list|(
name|this
operator|.
name|flushThresholdSize
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating flush_threshold_size from [{}] to [{}]"
argument_list|,
name|this
operator|.
name|flushThresholdSize
argument_list|,
name|flushThresholdSize
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushThresholdSize
operator|=
name|flushThresholdSize
expr_stmt|;
block|}
name|boolean
name|disableFlush
init|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|INDEX_TRANSLOG_DISABLE_FLUSH
argument_list|,
name|this
operator|.
name|disableFlush
argument_list|)
decl_stmt|;
if|if
condition|(
name|disableFlush
operator|!=
name|this
operator|.
name|disableFlush
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating disable_flush from [{}] to [{}]"
argument_list|,
name|this
operator|.
name|disableFlush
argument_list|,
name|disableFlush
argument_list|)
expr_stmt|;
name|this
operator|.
name|disableFlush
operator|=
name|disableFlush
expr_stmt|;
block|}
specifier|final
name|EngineConfig
name|config
init|=
name|engineConfig
decl_stmt|;
specifier|final
name|boolean
name|flushOnClose
init|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|INDEX_FLUSH_ON_CLOSE
argument_list|,
name|this
operator|.
name|flushOnClose
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushOnClose
operator|!=
name|this
operator|.
name|flushOnClose
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating {} from [{}] to [{}]"
argument_list|,
name|INDEX_FLUSH_ON_CLOSE
argument_list|,
name|this
operator|.
name|flushOnClose
argument_list|,
name|flushOnClose
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushOnClose
operator|=
name|flushOnClose
expr_stmt|;
block|}
name|TranslogWriter
operator|.
name|Type
name|type
init|=
name|TranslogWriter
operator|.
name|Type
operator|.
name|fromString
argument_list|(
name|settings
operator|.
name|get
argument_list|(
name|TranslogConfig
operator|.
name|INDEX_TRANSLOG_FS_TYPE
argument_list|,
name|translogConfig
operator|.
name|getType
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|translogConfig
operator|.
name|getType
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating type from [{}] to [{}]"
argument_list|,
name|translogConfig
operator|.
name|getType
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|translogConfig
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Translog
operator|.
name|Durabilty
name|durabilty
init|=
name|getFromSettings
argument_list|(
name|logger
argument_list|,
name|settings
argument_list|,
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|durabilty
operator|!=
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating durability from [{}] to [{}]"
argument_list|,
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
argument_list|,
name|durabilty
argument_list|)
expr_stmt|;
name|translogConfig
operator|.
name|setDurabilty
argument_list|(
name|durabilty
argument_list|)
expr_stmt|;
block|}
name|TimeValue
name|refreshInterval
init|=
name|settings
operator|.
name|getAsTime
argument_list|(
name|INDEX_REFRESH_INTERVAL
argument_list|,
name|this
operator|.
name|refreshInterval
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|refreshInterval
operator|.
name|equals
argument_list|(
name|this
operator|.
name|refreshInterval
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating refresh_interval from [{}] to [{}]"
argument_list|,
name|this
operator|.
name|refreshInterval
argument_list|,
name|refreshInterval
argument_list|)
expr_stmt|;
if|if
condition|(
name|refreshScheduledFuture
operator|!=
literal|null
condition|)
block|{
comment|// NOTE: we pass false here so we do NOT attempt Thread.interrupt if EngineRefresher.run is currently running.  This is
comment|// very important, because doing so can cause files to suddenly be closed if they were doing IO when the interrupt
comment|// hit.  See https://issues.apache.org/jira/browse/LUCENE-2239
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|refreshScheduledFuture
argument_list|)
expr_stmt|;
name|refreshScheduledFuture
operator|=
literal|null
expr_stmt|;
block|}
name|this
operator|.
name|refreshInterval
operator|=
name|refreshInterval
expr_stmt|;
if|if
condition|(
name|refreshInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
operator|new
name|EngineRefresher
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|gcDeletesInMillis
init|=
name|settings
operator|.
name|getAsTime
argument_list|(
name|EngineConfig
operator|.
name|INDEX_GC_DELETES_SETTING
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|config
operator|.
name|getGcDeletesInMillis
argument_list|()
argument_list|)
argument_list|)
operator|.
name|millis
argument_list|()
decl_stmt|;
if|if
condition|(
name|gcDeletesInMillis
operator|!=
name|config
operator|.
name|getGcDeletesInMillis
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating {} from [{}] to [{}]"
argument_list|,
name|EngineConfig
operator|.
name|INDEX_GC_DELETES_SETTING
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|config
operator|.
name|getGcDeletesInMillis
argument_list|()
argument_list|)
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|gcDeletesInMillis
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|setGcDeletesInMillis
argument_list|(
name|gcDeletesInMillis
argument_list|)
expr_stmt|;
name|change
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|boolean
name|compoundOnFlush
init|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|EngineConfig
operator|.
name|INDEX_COMPOUND_ON_FLUSH
argument_list|,
name|config
operator|.
name|isCompoundOnFlush
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|compoundOnFlush
operator|!=
name|config
operator|.
name|isCompoundOnFlush
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating {} from [{}] to [{}]"
argument_list|,
name|EngineConfig
operator|.
name|INDEX_COMPOUND_ON_FLUSH
argument_list|,
name|config
operator|.
name|isCompoundOnFlush
argument_list|()
argument_list|,
name|compoundOnFlush
argument_list|)
expr_stmt|;
name|config
operator|.
name|setCompoundOnFlush
argument_list|(
name|compoundOnFlush
argument_list|)
expr_stmt|;
name|change
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|String
name|versionMapSize
init|=
name|settings
operator|.
name|get
argument_list|(
name|EngineConfig
operator|.
name|INDEX_VERSION_MAP_SIZE
argument_list|,
name|config
operator|.
name|getVersionMapSizeSetting
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|getVersionMapSizeSetting
argument_list|()
operator|.
name|equals
argument_list|(
name|versionMapSize
argument_list|)
operator|==
literal|false
condition|)
block|{
name|config
operator|.
name|setVersionMapSizeSetting
argument_list|(
name|versionMapSize
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|maxThreadCount
init|=
name|settings
operator|.
name|getAsInt
argument_list|(
name|MergeSchedulerConfig
operator|.
name|MAX_THREAD_COUNT
argument_list|,
name|mergeSchedulerConfig
operator|.
name|getMaxThreadCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxThreadCount
operator|!=
name|mergeSchedulerConfig
operator|.
name|getMaxThreadCount
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating [{}] from [{}] to [{}]"
argument_list|,
name|MergeSchedulerConfig
operator|.
name|MAX_THREAD_COUNT
argument_list|,
name|mergeSchedulerConfig
operator|.
name|getMaxMergeCount
argument_list|()
argument_list|,
name|maxThreadCount
argument_list|)
expr_stmt|;
name|mergeSchedulerConfig
operator|.
name|setMaxThreadCount
argument_list|(
name|maxThreadCount
argument_list|)
expr_stmt|;
name|change
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|int
name|maxMergeCount
init|=
name|settings
operator|.
name|getAsInt
argument_list|(
name|MergeSchedulerConfig
operator|.
name|MAX_MERGE_COUNT
argument_list|,
name|mergeSchedulerConfig
operator|.
name|getMaxMergeCount
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|maxMergeCount
operator|!=
name|mergeSchedulerConfig
operator|.
name|getMaxMergeCount
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating [{}] from [{}] to [{}]"
argument_list|,
name|MergeSchedulerConfig
operator|.
name|MAX_MERGE_COUNT
argument_list|,
name|mergeSchedulerConfig
operator|.
name|getMaxMergeCount
argument_list|()
argument_list|,
name|maxMergeCount
argument_list|)
expr_stmt|;
name|mergeSchedulerConfig
operator|.
name|setMaxMergeCount
argument_list|(
name|maxMergeCount
argument_list|)
expr_stmt|;
name|change
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|boolean
name|autoThrottle
init|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|MergeSchedulerConfig
operator|.
name|AUTO_THROTTLE
argument_list|,
name|mergeSchedulerConfig
operator|.
name|isAutoThrottle
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|autoThrottle
operator|!=
name|mergeSchedulerConfig
operator|.
name|isAutoThrottle
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating [{}] from [{}] to [{}]"
argument_list|,
name|MergeSchedulerConfig
operator|.
name|AUTO_THROTTLE
argument_list|,
name|mergeSchedulerConfig
operator|.
name|isAutoThrottle
argument_list|()
argument_list|,
name|autoThrottle
argument_list|)
expr_stmt|;
name|mergeSchedulerConfig
operator|.
name|setAutoThrottle
argument_list|(
name|autoThrottle
argument_list|)
expr_stmt|;
name|change
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|mergePolicyConfig
operator|.
name|onRefreshSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|searchService
operator|.
name|onRefreshSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|indexingService
operator|.
name|onRefreshSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
condition|)
block|{
name|engine
argument_list|()
operator|.
name|onSettingsChanged
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EngineRefresher
class|class
name|EngineRefresher
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// we check before if a refresh is needed, if not, we reschedule, otherwise, we fork, refresh, and then reschedule
if|if
condition|(
operator|!
name|engine
argument_list|()
operator|.
name|refreshNeeded
argument_list|()
condition|)
block|{
name|reschedule
argument_list|()
expr_stmt|;
return|return;
block|}
name|threadPool
operator|.
name|executor
argument_list|(
name|ThreadPool
operator|.
name|Names
operator|.
name|REFRESH
argument_list|)
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|engine
argument_list|()
operator|.
name|refreshNeeded
argument_list|()
condition|)
block|{
name|refresh
argument_list|(
literal|"schedule"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|e
parameter_list|)
block|{
comment|// we are being closed, ignore
block|}
catch|catch
parameter_list|(
name|RefreshFailedEngineException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|InterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ClosedByInterruptException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ThreadInterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
else|else
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|reschedule
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**          * Schedules another (future) refresh, if refresh_interval is still enabled.          */
DECL|method|reschedule
specifier|private
name|void
name|reschedule
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
operator|&&
name|refreshInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|checkIndex
specifier|private
name|void
name|checkIndex
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|store
operator|.
name|tryIncRef
argument_list|()
condition|)
block|{
try|try
block|{
name|doCheckIndex
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|doCheckIndex
specifier|private
name|void
name|doCheckIndex
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|timeNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Lucene
operator|.
name|indexExists
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|BytesStreamOutput
name|os
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|,
literal|false
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"checksum"
operator|.
name|equalsIgnoreCase
argument_list|(
name|checkIndexOnStartup
argument_list|)
condition|)
block|{
comment|// physical verification only: verify all checksums for the latest commit
name|IOException
name|corrupt
init|=
literal|null
decl_stmt|;
name|MetadataSnapshot
name|metadata
init|=
name|store
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|StoreFileMetaData
argument_list|>
name|entry
range|:
name|metadata
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|Store
operator|.
name|checkIntegrity
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|store
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"checksum passed: "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exc
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"checksum failed: "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|exc
operator|.
name|printStackTrace
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|corrupt
operator|=
name|exc
expr_stmt|;
block|}
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|corrupt
operator|!=
literal|null
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
name|corrupt
throw|;
block|}
block|}
else|else
block|{
comment|// full checkindex
try|try
init|(
name|CheckIndex
name|checkIndex
init|=
operator|new
name|CheckIndex
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
init|)
block|{
name|checkIndex
operator|.
name|setInfoStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|status
init|=
name|checkIndex
operator|.
name|checkIndex
argument_list|()
decl_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|clean
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// ignore if closed....
return|return;
block|}
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"fix"
operator|.
name|equalsIgnoreCase
argument_list|(
name|checkIndexOnStartup
argument_list|)
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"fixing index, writing new segments file ..."
argument_list|)
expr_stmt|;
block|}
name|checkIndex
operator|.
name|exorciseIndex
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"index fixed, wrote new segments file \"{}\""
argument_list|,
name|status
operator|.
name|segmentsFileName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// only throw a failure if we are not going to fix the index
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"index check failure but can't fix it"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"check index [success]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|recoveryState
operator|.
name|getVerifyIndex
argument_list|()
operator|.
name|checkIndexTime
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|TimeValue
operator|.
name|nsecToMSec
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|timeNS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|engine
specifier|public
name|Engine
name|engine
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EngineClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
return|return
name|engine
return|;
block|}
comment|/** NOTE: returns null if engine is not yet started (e.g. recovery phase 1, copying over index files, is still running), or if engine is      *  closed. */
DECL|method|engineUnsafe
specifier|protected
name|Engine
name|engineUnsafe
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentEngineReference
operator|.
name|get
argument_list|()
return|;
block|}
DECL|class|ShardEngineFailListener
class|class
name|ShardEngineFailListener
implements|implements
name|Engine
operator|.
name|FailedEngineListener
block|{
DECL|field|delegates
specifier|private
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|Engine
operator|.
name|FailedEngineListener
argument_list|>
name|delegates
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// called by the current engine
annotation|@
name|Override
DECL|method|onFailedEngine
specifier|public
name|void
name|onFailedEngine
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
for|for
control|(
name|Engine
operator|.
name|FailedEngineListener
name|listener
range|:
name|delegates
control|)
block|{
try|try
block|{
name|listener
operator|.
name|onFailedEngine
argument_list|(
name|shardId
argument_list|,
name|reason
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"exception while notifying engine failure"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|createNewEngine
specifier|private
name|void
name|createNewEngine
parameter_list|(
name|boolean
name|skipTranslogRecovery
parameter_list|,
name|EngineConfig
name|config
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|EngineClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
assert|assert
name|this
operator|.
name|currentEngineReference
operator|.
name|get
argument_list|()
operator|==
literal|null
assert|;
name|this
operator|.
name|currentEngineReference
operator|.
name|set
argument_list|(
name|newEngine
argument_list|(
name|skipTranslogRecovery
argument_list|,
name|config
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newEngine
specifier|protected
name|Engine
name|newEngine
parameter_list|(
name|boolean
name|skipTranslogRecovery
parameter_list|,
name|EngineConfig
name|config
parameter_list|)
block|{
return|return
name|engineFactory
operator|.
name|newReadWriteEngine
argument_list|(
name|config
argument_list|,
name|skipTranslogRecovery
argument_list|)
return|;
block|}
comment|/**      * Returns<code>true</code> iff this shard allows primary promotion, otherwise<code>false</code>      */
DECL|method|allowsPrimaryPromotion
specifier|public
name|boolean
name|allowsPrimaryPromotion
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|// pkg private for testing
DECL|method|persistMetadata
name|void
name|persistMetadata
parameter_list|(
name|ShardRouting
name|newRouting
parameter_list|,
name|ShardRouting
name|currentRouting
parameter_list|)
block|{
assert|assert
name|newRouting
operator|!=
literal|null
operator|:
literal|"newRouting must not be null"
assert|;
if|if
condition|(
name|newRouting
operator|.
name|active
argument_list|()
condition|)
block|{
try|try
block|{
specifier|final
name|String
name|writeReason
decl_stmt|;
if|if
condition|(
name|currentRouting
operator|==
literal|null
condition|)
block|{
name|writeReason
operator|=
literal|"freshly started, version ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentRouting
operator|.
name|version
argument_list|()
operator|<
name|newRouting
operator|.
name|version
argument_list|()
condition|)
block|{
name|writeReason
operator|=
literal|"version changed from ["
operator|+
name|currentRouting
operator|.
name|version
argument_list|()
operator|+
literal|"] to ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentRouting
operator|.
name|equals
argument_list|(
name|newRouting
argument_list|)
operator|==
literal|false
condition|)
block|{
name|writeReason
operator|=
literal|"routing changed from "
operator|+
name|currentRouting
operator|+
literal|" to "
operator|+
name|newRouting
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"skip writing shard state, has been written before; previous version:  ["
operator|+
name|currentRouting
operator|.
name|version
argument_list|()
operator|+
literal|"] current version ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
assert|assert
name|currentRouting
operator|.
name|version
argument_list|()
operator|<=
name|newRouting
operator|.
name|version
argument_list|()
operator|:
literal|"version should not go backwards for shardID: "
operator|+
name|shardId
operator|+
literal|" previous version:  ["
operator|+
name|currentRouting
operator|.
name|version
argument_list|()
operator|+
literal|"] current version ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
assert|;
return|return;
block|}
specifier|final
name|ShardStateMetaData
name|newShardStateMetadata
init|=
operator|new
name|ShardStateMetaData
argument_list|(
name|newRouting
operator|.
name|version
argument_list|()
argument_list|,
name|newRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|getIndexUUID
argument_list|()
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} writing shard state, reason [{}]"
argument_list|,
name|shardId
argument_list|,
name|writeReason
argument_list|)
expr_stmt|;
name|ShardStateMetaData
operator|.
name|FORMAT
operator|.
name|write
argument_list|(
name|newShardStateMetadata
argument_list|,
name|newShardStateMetadata
operator|.
name|version
argument_list|,
name|shardPath
argument_list|()
operator|.
name|getShardStatePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// this is how we used to handle it.... :(
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to write shard state"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// we failed to write the shard state, we will try and write
comment|// it next time...
block|}
block|}
block|}
DECL|method|getIndexUUID
specifier|private
name|String
name|getIndexUUID
parameter_list|()
block|{
assert|assert
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_INDEX_UUID
argument_list|)
operator|!=
literal|null
operator|||
name|indexSettings
operator|.
name|getAsVersion
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_VERSION_CREATED
argument_list|,
name|Version
operator|.
name|CURRENT
argument_list|)
operator|.
name|before
argument_list|(
name|Version
operator|.
name|V_0_90_6
argument_list|)
operator|:
literal|"version: "
operator|+
name|indexSettings
operator|.
name|getAsVersion
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_VERSION_CREATED
argument_list|,
literal|null
argument_list|)
operator|+
literal|" uuid: "
operator|+
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_INDEX_UUID
argument_list|)
assert|;
return|return
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_INDEX_UUID
argument_list|,
name|IndexMetaData
operator|.
name|INDEX_UUID_NA_VALUE
argument_list|)
return|;
block|}
DECL|method|docMapper
specifier|private
name|DocumentMapperForType
name|docMapper
parameter_list|(
name|String
name|type
parameter_list|)
block|{
return|return
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|method|newEngineConfig
specifier|private
specifier|final
name|EngineConfig
name|newEngineConfig
parameter_list|(
name|TranslogConfig
name|translogConfig
parameter_list|,
name|QueryCachingPolicy
name|cachingPolicy
parameter_list|)
block|{
specifier|final
name|TranslogRecoveryPerformer
name|translogRecoveryPerformer
init|=
operator|new
name|TranslogRecoveryPerformer
argument_list|(
name|shardId
argument_list|,
name|mapperService
argument_list|,
name|queryParserService
argument_list|,
name|indexAliasesService
argument_list|,
name|indexCache
argument_list|,
name|logger
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|operationProcessed
parameter_list|()
block|{
assert|assert
name|recoveryState
operator|!=
literal|null
assert|;
name|recoveryState
operator|.
name|getTranslog
argument_list|()
operator|.
name|incrementRecoveredOperations
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|EngineConfig
argument_list|(
name|shardId
argument_list|,
name|threadPool
argument_list|,
name|indexingService
argument_list|,
name|indexSettings
argument_list|,
name|warmer
argument_list|,
name|store
argument_list|,
name|deletionPolicy
argument_list|,
name|mergePolicyConfig
operator|.
name|getMergePolicy
argument_list|()
argument_list|,
name|mergeSchedulerConfig
argument_list|,
name|mapperService
operator|.
name|indexAnalyzer
argument_list|()
argument_list|,
name|similarityService
operator|.
name|similarity
argument_list|()
argument_list|,
name|codecService
argument_list|,
name|failedEngineListener
argument_list|,
name|translogRecoveryPerformer
argument_list|,
name|indexCache
operator|.
name|query
argument_list|()
argument_list|,
name|cachingPolicy
argument_list|,
name|wrappingService
argument_list|,
name|translogConfig
argument_list|)
return|;
block|}
DECL|class|IndexShardOperationCounter
specifier|private
specifier|static
class|class
name|IndexShardOperationCounter
extends|extends
name|AbstractRefCounted
block|{
DECL|field|logger
specifier|final
specifier|private
name|ESLogger
name|logger
decl_stmt|;
DECL|field|shardId
specifier|private
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|method|IndexShardOperationCounter
specifier|public
name|IndexShardOperationCounter
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|super
argument_list|(
literal|"index-shard-operations-counter"
argument_list|)
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|closeInternal
specifier|protected
name|void
name|closeInternal
parameter_list|()
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"operations counter reached 0, will not accept any further writes"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|alreadyClosed
specifier|protected
name|void
name|alreadyClosed
parameter_list|()
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|,
literal|"could not increment operation counter. shard is closed."
argument_list|)
throw|;
block|}
block|}
DECL|method|incrementOperationCounter
specifier|public
name|void
name|incrementOperationCounter
parameter_list|()
block|{
name|indexShardOperationCounter
operator|.
name|incRef
argument_list|()
expr_stmt|;
block|}
DECL|method|decrementOperationCounter
specifier|public
name|void
name|decrementOperationCounter
parameter_list|()
block|{
name|indexShardOperationCounter
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
DECL|method|getOperationsCount
specifier|public
name|int
name|getOperationsCount
parameter_list|()
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|indexShardOperationCounter
operator|.
name|refCount
argument_list|()
operator|-
literal|1
argument_list|)
return|;
comment|// refCount is incremented on creation and decremented on close
block|}
comment|/**      * Syncs the given location with the underlying storage unless already synced.      */
DECL|method|sync
specifier|public
name|void
name|sync
parameter_list|(
name|Translog
operator|.
name|Location
name|location
parameter_list|)
block|{
try|try
block|{
specifier|final
name|Engine
name|engine
init|=
name|engine
argument_list|()
decl_stmt|;
name|engine
operator|.
name|getTranslog
argument_list|()
operator|.
name|ensureSynced
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|ex
parameter_list|)
block|{
comment|// that's fine since we already synced everything on engine close - this also is conform with the methods documentation
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// if this fails we are in deep shit - fail the request
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to sync translog"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to sync translog"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns the current translog durability mode      */
DECL|method|getTranslogDurability
specifier|public
name|Translog
operator|.
name|Durabilty
name|getTranslogDurability
parameter_list|()
block|{
return|return
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
return|;
block|}
DECL|method|getFromSettings
specifier|private
specifier|static
name|Translog
operator|.
name|Durabilty
name|getFromSettings
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|Settings
name|settings
parameter_list|,
name|Translog
operator|.
name|Durabilty
name|defaultValue
parameter_list|)
block|{
specifier|final
name|String
name|value
init|=
name|settings
operator|.
name|get
argument_list|(
name|TranslogConfig
operator|.
name|INDEX_TRANSLOG_DURABILITY
argument_list|,
name|defaultValue
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|Translog
operator|.
name|Durabilty
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Can't apply {} illegal value: {} using {} instead, use one of: {}"
argument_list|,
name|TranslogConfig
operator|.
name|INDEX_TRANSLOG_DURABILITY
argument_list|,
name|value
argument_list|,
name|defaultValue
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|Translog
operator|.
name|Durabilty
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|defaultValue
return|;
block|}
block|}
DECL|field|asyncFlushRunning
specifier|private
specifier|final
name|AtomicBoolean
name|asyncFlushRunning
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
comment|/**      * Schedules a flush if needed but won't schedule more than one flush concurrently. The flush will be executed on the      * Flush thread-pool asynchronously.      * @return<code>true</code> if a new flush is scheduled otherwise<code>false</code>.      */
DECL|method|maybeFlush
specifier|public
name|boolean
name|maybeFlush
parameter_list|()
block|{
if|if
condition|(
name|shouldFlush
argument_list|()
condition|)
block|{
if|if
condition|(
name|asyncFlushRunning
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
comment|// we can't use a lock here since we "release" in a different thread
if|if
condition|(
name|shouldFlush
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// we have to check again since otherwise there is a race when a thread passes
comment|// the first shouldFlush() check next to another thread which flushes fast enough
comment|// to finish before the current thread could flip the asyncFlushRunning flag.
comment|// in that situation we have an extra unexpected flush.
name|asyncFlushRunning
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"submitting async flush request"
argument_list|)
expr_stmt|;
specifier|final
name|AbstractRunnable
name|abstractRunnable
init|=
operator|new
name|AbstractRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to flush index"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
name|flush
argument_list|(
operator|new
name|FlushRequest
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onAfter
parameter_list|()
block|{
name|asyncFlushRunning
operator|.
name|compareAndSet
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|maybeFlush
argument_list|()
expr_stmt|;
comment|// fire a flush up again if we have filled up the limits such that shouldFlush() returns true
block|}
block|}
decl_stmt|;
name|threadPool
operator|.
name|executor
argument_list|(
name|ThreadPool
operator|.
name|Names
operator|.
name|FLUSH
argument_list|)
operator|.
name|execute
argument_list|(
name|abstractRunnable
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

