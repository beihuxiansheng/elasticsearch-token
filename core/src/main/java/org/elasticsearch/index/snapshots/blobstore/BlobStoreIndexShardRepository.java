begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.snapshots.blobstore
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|io
operator|.
name|ByteStreams
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CorruptIndexException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooNewException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFormatTooOldException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|SegmentInfos
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimiter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRefBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|SnapshotId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseFieldMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobContainer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|BlobStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|deletionpolicy
operator|.
name|SnapshotIndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryVerificationException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|blobstore
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|blobstore
operator|.
name|BlobStoreRepository
operator|.
name|testBlobPrefix
import|;
end_import

begin_comment
comment|/**  * Blob store based implementation of IndexShardRepository  */
end_comment

begin_class
DECL|class|BlobStoreIndexShardRepository
specifier|public
class|class
name|BlobStoreIndexShardRepository
extends|extends
name|AbstractComponent
implements|implements
name|IndexShardRepository
block|{
DECL|field|BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|BUFFER_SIZE
init|=
literal|4096
decl_stmt|;
DECL|field|blobStore
specifier|private
name|BlobStore
name|blobStore
decl_stmt|;
DECL|field|basePath
specifier|private
name|BlobPath
name|basePath
decl_stmt|;
DECL|field|repositoryName
specifier|private
specifier|final
name|String
name|repositoryName
decl_stmt|;
DECL|field|chunkSize
specifier|private
name|ByteSizeValue
name|chunkSize
decl_stmt|;
DECL|field|indicesService
specifier|private
specifier|final
name|IndicesService
name|indicesService
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|snapshotRateLimiter
specifier|private
name|RateLimiter
name|snapshotRateLimiter
decl_stmt|;
DECL|field|restoreRateLimiter
specifier|private
name|RateLimiter
name|restoreRateLimiter
decl_stmt|;
DECL|field|rateLimiterListener
specifier|private
name|RateLimiterListener
name|rateLimiterListener
decl_stmt|;
DECL|field|snapshotThrottleListener
specifier|private
name|RateLimitingInputStream
operator|.
name|Listener
name|snapshotThrottleListener
decl_stmt|;
DECL|field|compress
specifier|private
name|boolean
name|compress
decl_stmt|;
DECL|field|parseFieldMatcher
specifier|private
specifier|final
name|ParseFieldMatcher
name|parseFieldMatcher
decl_stmt|;
DECL|field|LEGACY_SNAPSHOT_PREFIX
specifier|protected
specifier|static
specifier|final
name|String
name|LEGACY_SNAPSHOT_PREFIX
init|=
literal|"snapshot-"
decl_stmt|;
DECL|field|LEGACY_SNAPSHOT_NAME_FORMAT
specifier|protected
specifier|static
specifier|final
name|String
name|LEGACY_SNAPSHOT_NAME_FORMAT
init|=
name|LEGACY_SNAPSHOT_PREFIX
operator|+
literal|"%s"
decl_stmt|;
DECL|field|SNAPSHOT_PREFIX
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_PREFIX
init|=
literal|"snap-"
decl_stmt|;
DECL|field|SNAPSHOT_NAME_FORMAT
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_NAME_FORMAT
init|=
name|SNAPSHOT_PREFIX
operator|+
literal|"%s.dat"
decl_stmt|;
DECL|field|SNAPSHOT_CODEC
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_CODEC
init|=
literal|"snapshot"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_PREFIX
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_PREFIX
init|=
literal|"index-"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_NAME_FORMAT
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_NAME_FORMAT
init|=
name|SNAPSHOT_INDEX_PREFIX
operator|+
literal|"%s"
decl_stmt|;
DECL|field|SNAPSHOT_INDEX_CODEC
specifier|protected
specifier|static
specifier|final
name|String
name|SNAPSHOT_INDEX_CODEC
init|=
literal|"snapshots"
decl_stmt|;
DECL|field|DATA_BLOB_PREFIX
specifier|protected
specifier|static
specifier|final
name|String
name|DATA_BLOB_PREFIX
init|=
literal|"__"
decl_stmt|;
DECL|field|indexShardSnapshotFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotFormat
decl_stmt|;
DECL|field|indexShardSnapshotLegacyFormat
specifier|private
name|LegacyBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotLegacyFormat
decl_stmt|;
DECL|field|indexShardSnapshotsFormat
specifier|private
name|ChecksumBlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|>
name|indexShardSnapshotsFormat
decl_stmt|;
annotation|@
name|Inject
DECL|method|BlobStoreIndexShardRepository
specifier|public
name|BlobStoreIndexShardRepository
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|RepositoryName
name|repositoryName
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|parseFieldMatcher
operator|=
operator|new
name|ParseFieldMatcher
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|repositoryName
operator|=
name|repositoryName
operator|.
name|name
argument_list|()
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
block|}
comment|/**      * Called by {@link org.elasticsearch.repositories.blobstore.BlobStoreRepository} on repository startup      *      * @param blobStore blob store      * @param basePath  base path to blob store      * @param chunkSize chunk size      */
DECL|method|initialize
specifier|public
name|void
name|initialize
parameter_list|(
name|BlobStore
name|blobStore
parameter_list|,
name|BlobPath
name|basePath
parameter_list|,
name|ByteSizeValue
name|chunkSize
parameter_list|,
name|RateLimiter
name|snapshotRateLimiter
parameter_list|,
name|RateLimiter
name|restoreRateLimiter
parameter_list|,
specifier|final
name|RateLimiterListener
name|rateLimiterListener
parameter_list|,
name|boolean
name|compress
parameter_list|)
block|{
name|this
operator|.
name|blobStore
operator|=
name|blobStore
expr_stmt|;
name|this
operator|.
name|basePath
operator|=
name|basePath
expr_stmt|;
name|this
operator|.
name|chunkSize
operator|=
name|chunkSize
expr_stmt|;
name|this
operator|.
name|snapshotRateLimiter
operator|=
name|snapshotRateLimiter
expr_stmt|;
name|this
operator|.
name|restoreRateLimiter
operator|=
name|restoreRateLimiter
expr_stmt|;
name|this
operator|.
name|rateLimiterListener
operator|=
name|rateLimiterListener
expr_stmt|;
name|this
operator|.
name|snapshotThrottleListener
operator|=
operator|new
name|RateLimitingInputStream
operator|.
name|Listener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onPause
parameter_list|(
name|long
name|nanos
parameter_list|)
block|{
name|rateLimiterListener
operator|.
name|onSnapshotPause
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
name|this
operator|.
name|compress
operator|=
name|compress
expr_stmt|;
name|indexShardSnapshotFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_CODEC
argument_list|,
name|SNAPSHOT_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
name|indexShardSnapshotLegacyFormat
operator|=
operator|new
name|LegacyBlobStoreFormat
argument_list|<>
argument_list|(
name|LEGACY_SNAPSHOT_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshot
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|)
expr_stmt|;
name|indexShardSnapshotsFormat
operator|=
operator|new
name|ChecksumBlobStoreFormat
argument_list|<>
argument_list|(
name|SNAPSHOT_INDEX_CODEC
argument_list|,
name|SNAPSHOT_INDEX_NAME_FORMAT
argument_list|,
name|BlobStoreIndexShardSnapshots
operator|.
name|PROTO
argument_list|,
name|parseFieldMatcher
argument_list|,
name|isCompress
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|snapshot
specifier|public
name|void
name|snapshot
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|SnapshotIndexCommit
name|snapshotIndexCommit
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|SnapshotContext
name|snapshotContext
init|=
operator|new
name|SnapshotContext
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|snapshotStatus
argument_list|)
decl_stmt|;
name|snapshotStatus
operator|.
name|startTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|snapshotContext
operator|.
name|snapshot
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|failure
argument_list|(
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|IndexShardSnapshotFailedException
condition|)
block|{
throw|throw
operator|(
name|IndexShardSnapshotFailedException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|restore
specifier|public
name|void
name|restore
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
block|{
specifier|final
name|RestoreContext
name|snapshotContext
init|=
operator|new
name|RestoreContext
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|,
name|snapshotShardId
argument_list|,
name|recoveryState
argument_list|)
decl_stmt|;
try|try
block|{
name|snapshotContext
operator|.
name|restore
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to restore snapshot ["
operator|+
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|snapshotStatus
specifier|public
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|context
operator|.
name|loadSnapshot
argument_list|()
decl_stmt|;
name|IndexShardSnapshotStatus
name|status
init|=
operator|new
name|IndexShardSnapshotStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
name|status
operator|.
name|startTime
argument_list|(
name|snapshot
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|files
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// The snapshot is done which means the number of processed files is the same as total
name|status
operator|.
name|processedFiles
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|time
argument_list|(
name|snapshot
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
annotation|@
name|Override
DECL|method|verify
specifier|public
name|void
name|verify
parameter_list|(
name|String
name|seed
parameter_list|)
block|{
name|BlobContainer
name|testBlobContainer
init|=
name|blobStore
operator|.
name|blobContainer
argument_list|(
name|basePath
argument_list|)
decl_stmt|;
name|DiscoveryNode
name|localNode
init|=
name|clusterService
operator|.
name|localNode
argument_list|()
decl_stmt|;
if|if
condition|(
name|testBlobContainer
operator|.
name|blobExists
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
operator|+
literal|"-master"
argument_list|)
condition|)
block|{
try|try
init|(
name|OutputStream
name|outputStream
init|=
name|testBlobContainer
operator|.
name|createOutput
argument_list|(
name|testBlobPrefix
argument_list|(
name|seed
argument_list|)
operator|+
literal|"-"
operator|+
name|localNode
operator|.
name|getId
argument_list|()
argument_list|)
init|)
block|{
name|outputStream
operator|.
name|write
argument_list|(
name|Strings
operator|.
name|toUTF8Bytes
argument_list|(
name|seed
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exp
parameter_list|)
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|repositoryName
argument_list|,
literal|"store location ["
operator|+
name|blobStore
operator|+
literal|"] is not accessible on the node ["
operator|+
name|localNode
operator|+
literal|"]"
argument_list|,
name|exp
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|RepositoryVerificationException
argument_list|(
name|repositoryName
argument_list|,
literal|"a file written by master to the store ["
operator|+
name|blobStore
operator|+
literal|"] cannot be accessed on the node ["
operator|+
name|localNode
operator|+
literal|"]. "
operator|+
literal|"This might indicate that the store ["
operator|+
name|blobStore
operator|+
literal|"] is not shared between this node and the master node or "
operator|+
literal|"that permissions on the store don't allow reading files written by the master node"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Delete shard snapshot      *      * @param snapshotId snapshot id      * @param shardId    shard id      */
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|context
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BlobStoreIndexShardRepository["
operator|+
literal|"["
operator|+
name|repositoryName
operator|+
literal|"], ["
operator|+
name|blobStore
operator|+
literal|']'
operator|+
literal|']'
return|;
block|}
comment|/**      * Returns true if metadata files should be compressed      *      * @return true if compression is needed      */
DECL|method|isCompress
specifier|protected
name|boolean
name|isCompress
parameter_list|()
block|{
return|return
name|compress
return|;
block|}
DECL|method|indexShardSnapshotFormat
name|BlobStoreFormat
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|indexShardSnapshotFormat
parameter_list|(
name|Version
name|version
parameter_list|)
block|{
if|if
condition|(
name|BlobStoreRepository
operator|.
name|legacyMetaData
argument_list|(
name|version
argument_list|)
condition|)
block|{
return|return
name|indexShardSnapshotLegacyFormat
return|;
block|}
else|else
block|{
return|return
name|indexShardSnapshotFormat
return|;
block|}
block|}
comment|/**      * Context for snapshot/restore operations      */
DECL|class|Context
specifier|private
class|class
name|Context
block|{
DECL|field|snapshotId
specifier|protected
specifier|final
name|SnapshotId
name|snapshotId
decl_stmt|;
DECL|field|shardId
specifier|protected
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|field|blobContainer
specifier|protected
specifier|final
name|BlobContainer
name|blobContainer
decl_stmt|;
DECL|field|version
specifier|protected
specifier|final
name|Version
name|version
decl_stmt|;
DECL|method|Context
specifier|public
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|this
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
DECL|method|Context
specifier|public
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|)
block|{
name|this
operator|.
name|snapshotId
operator|=
name|snapshotId
expr_stmt|;
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|blobContainer
operator|=
name|blobStore
operator|.
name|blobContainer
argument_list|(
name|basePath
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|snapshotShardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|snapshotShardId
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**          * Delete shard snapshot          */
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to list content of gateway"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|tuple
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|tuple
operator|.
name|v1
argument_list|()
decl_stmt|;
name|int
name|fileListGeneration
init|=
name|tuple
operator|.
name|v2
argument_list|()
decl_stmt|;
try|try
block|{
name|indexShardSnapshotFormat
argument_list|(
name|version
argument_list|)
operator|.
name|delete
argument_list|(
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] failed to delete shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
comment|// Build a list of snapshots that should be preserved
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|newSnapshotsList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|SnapshotFiles
name|point
range|:
name|snapshots
control|)
block|{
if|if
condition|(
operator|!
name|point
operator|.
name|snapshot
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
argument_list|)
condition|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
comment|// finalize the snapshot and rewrite the snapshot index with the next sequential snapshot index
name|finalize
argument_list|(
name|newSnapshotsList
argument_list|,
name|fileListGeneration
operator|+
literal|1
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
block|}
comment|/**          * Loads information about shard snapshot          */
DECL|method|loadSnapshot
specifier|public
name|BlobStoreIndexShardSnapshot
name|loadSnapshot
parameter_list|()
block|{
try|try
block|{
return|return
name|indexShardSnapshotFormat
argument_list|(
name|version
argument_list|)
operator|.
name|read
argument_list|(
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to read shard snapshot file"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**          * Removes all unreferenced files from the repository and writes new index file          *          * We need to be really careful in handling index files in case of failures to make sure we have index file that          * points to files that were deleted.          *          *          * @param snapshots list of active snapshots in the container          * @param fileListGeneration the generation number of the snapshot index file          * @param blobs     list of blobs in the container          */
DECL|method|finalize
specifier|protected
name|void
name|finalize
parameter_list|(
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|snapshots
parameter_list|,
name|int
name|fileListGeneration
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobStoreIndexShardSnapshots
name|newSnapshots
init|=
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
decl_stmt|;
comment|// delete old index files first
for|for
control|(
name|String
name|blobName
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// delete old file lists
if|if
condition|(
name|indexShardSnapshotsFormat
operator|.
name|isTempBlobName
argument_list|(
name|blobName
argument_list|)
operator|||
name|blobName
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// We cannot delete index file - this is fatal, we cannot continue, otherwise we might end up
comment|// with references to non-existing files
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"error deleting index file [{}] during cleanup"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// now go over all the blobs, and if they don't exists in a snapshot, delete them
for|for
control|(
name|String
name|blobName
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
comment|// delete old file lists
if|if
condition|(
name|blobName
operator|.
name|startsWith
argument_list|(
name|DATA_BLOB_PREFIX
argument_list|)
condition|)
block|{
if|if
condition|(
name|newSnapshots
operator|.
name|findNameFile
argument_list|(
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|blobName
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] error deleting blob [{}] during cleanup"
argument_list|,
name|e
argument_list|,
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// If we deleted all snapshots - we don't need to create the index file
if|if
condition|(
name|snapshots
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
try|try
block|{
name|indexShardSnapshotsFormat
operator|.
name|writeAtomic
argument_list|(
name|newSnapshots
argument_list|,
name|blobContainer
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|fileListGeneration
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to write file list"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**          * Generates blob name          *          * @param generation the blob number          * @return the blob name          */
DECL|method|fileNameFromGeneration
specifier|protected
name|String
name|fileNameFromGeneration
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
return|return
name|DATA_BLOB_PREFIX
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|generation
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
comment|/**          * Finds the next available blob number          *          * @param blobs list of blobs in the repository          * @return next available blob number          */
DECL|method|findLatestFileNameGeneration
specifier|protected
name|long
name|findLatestFileNameGeneration
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|long
name|generation
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
name|DATA_BLOB_PREFIX
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|currentGen
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|DATA_BLOB_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentGen
operator|>
name|generation
condition|)
block|{
name|generation
operator|=
name|currentGen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"file [{}] does not conform to the '{}' schema"
argument_list|,
name|name
argument_list|,
name|DATA_BLOB_PREFIX
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|generation
return|;
block|}
comment|/**          * Loads all available snapshots in the repository          *          * @param blobs list of blobs in repository          * @return tuple of BlobStoreIndexShardSnapshots and the last snapshot index generation          */
DECL|method|buildBlobStoreIndexShardSnapshots
specifier|protected
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|buildBlobStoreIndexShardSnapshots
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|int
name|latest
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|int
name|gen
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
operator|.
name|substring
argument_list|(
name|SNAPSHOT_INDEX_PREFIX
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|gen
operator|>
name|latest
condition|)
block|{
name|latest
operator|=
name|gen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to parse index file name [{}]"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|latest
operator|>=
literal|0
condition|)
block|{
try|try
block|{
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|indexShardSnapshotsFormat
operator|.
name|read
argument_list|(
name|blobContainer
argument_list|,
name|Integer
operator|.
name|toString
argument_list|(
name|latest
argument_list|)
argument_list|)
argument_list|,
name|latest
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to read index file  [{}]"
argument_list|,
name|e
argument_list|,
name|SNAPSHOT_INDEX_PREFIX
operator|+
name|latest
argument_list|)
expr_stmt|;
block|}
block|}
comment|// We couldn't load the index file - falling back to loading individual snapshots
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|snapshots
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
try|try
block|{
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_PREFIX
argument_list|)
condition|)
block|{
name|snapshot
operator|=
name|indexShardSnapshotFormat
operator|.
name|readBlob
argument_list|(
name|blobContainer
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|LEGACY_SNAPSHOT_PREFIX
argument_list|)
condition|)
block|{
name|snapshot
operator|=
name|indexShardSnapshotLegacyFormat
operator|.
name|readBlob
argument_list|(
name|blobContainer
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snapshot
operator|!=
literal|null
condition|)
block|{
name|snapshots
operator|.
name|add
argument_list|(
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to read commit point [{}]"
argument_list|,
name|e
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
block|}
comment|/**      * Context for snapshot operations      */
DECL|class|SnapshotContext
specifier|private
class|class
name|SnapshotContext
extends|extends
name|Context
block|{
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|snapshotStatus
specifier|private
specifier|final
name|IndexShardSnapshotStatus
name|snapshotStatus
decl_stmt|;
comment|/**          * Constructs new context          *          * @param snapshotId     snapshot id          * @param shardId        shard to be snapshotted          * @param snapshotStatus snapshot status to report progress          */
DECL|method|SnapshotContext
specifier|public
name|SnapshotContext
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|Version
operator|.
name|CURRENT
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexServiceSafe
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
name|store
operator|=
name|indexService
operator|.
name|shardInjectorSafe
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|getInstance
argument_list|(
name|Store
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotStatus
operator|=
name|snapshotStatus
expr_stmt|;
block|}
comment|/**          * Create snapshot from index commit point          *          * @param snapshotIndexCommit snapshot commit point          */
DECL|method|snapshot
specifier|public
name|void
name|snapshot
parameter_list|(
name|SnapshotIndexCommit
name|snapshotIndexCommit
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] snapshot to [{}] ..."
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|repositoryName
argument_list|)
expr_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to list blobs"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|generation
init|=
name|findLatestFileNameGeneration
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|Tuple
argument_list|<
name|BlobStoreIndexShardSnapshots
argument_list|,
name|Integer
argument_list|>
name|tuple
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|tuple
operator|.
name|v1
argument_list|()
decl_stmt|;
name|int
name|fileListGeneration
init|=
name|tuple
operator|.
name|v2
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|indexCommitPointFiles
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|indexNumberOfFiles
init|=
literal|0
decl_stmt|;
name|long
name|indexTotalFilesSize
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|FileInfo
argument_list|>
name|filesToSnapshot
init|=
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|metadata
decl_stmt|;
comment|// TODO apparently we don't use the MetadataSnapshot#.recoveryDiff(...) here but we should
try|try
block|{
name|metadata
operator|=
name|store
operator|.
name|getMetadata
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to get store file metadata"
argument_list|,
name|e
argument_list|)
throw|;
block|}
for|for
control|(
name|String
name|fileName
range|:
name|snapshotIndexCommit
operator|.
name|getFiles
argument_list|()
control|)
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] Processing [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
specifier|final
name|StoreFileMetaData
name|md
init|=
name|metadata
operator|.
name|get
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
name|FileInfo
name|existingFileInfo
init|=
literal|null
decl_stmt|;
name|List
argument_list|<
name|FileInfo
argument_list|>
name|filesInfo
init|=
name|snapshots
operator|.
name|findPhysicalIndexFiles
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|filesInfo
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|FileInfo
name|fileInfo
range|:
name|filesInfo
control|)
block|{
try|try
block|{
comment|// in 1.3.3 we added additional hashes for .si / segments_N files
comment|// to ensure we don't double the space in the repo since old snapshots
comment|// don't have this hash we try to read that hash from the blob store
comment|// in a bwc compatible way.
name|maybeRecalculateMetadataHash
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|,
name|metadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Can't calculate hash from blob for file [{}] [{}]"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fileInfo
operator|.
name|isSame
argument_list|(
name|md
argument_list|)
operator|&&
name|snapshotFileExistsInBlobs
argument_list|(
name|fileInfo
argument_list|,
name|blobs
argument_list|)
condition|)
block|{
comment|// a commit point file with the same name, size and checksum was already copied to repository
comment|// we will reuse it for this snapshot
name|existingFileInfo
operator|=
name|fileInfo
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|existingFileInfo
operator|==
literal|null
condition|)
block|{
name|indexNumberOfFiles
operator|++
expr_stmt|;
name|indexTotalFilesSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// create a new FileInfo
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|snapshotFileInfo
init|=
operator|new
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|(
name|fileNameFromGeneration
argument_list|(
operator|++
name|generation
argument_list|)
argument_list|,
name|md
argument_list|,
name|chunkSize
argument_list|)
decl_stmt|;
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
name|filesToSnapshot
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|existingFileInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|snapshotStatus
operator|.
name|files
argument_list|(
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted during initialization"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|STARTED
argument_list|)
expr_stmt|;
for|for
control|(
name|FileInfo
name|snapshotFileInfo
range|:
name|filesToSnapshot
control|)
block|{
try|try
block|{
name|snapshotFile
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to perform snapshot (index files)"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|snapshotStatus
operator|.
name|indexVersion
argument_list|(
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
comment|// now create and write the commit point
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FINALIZE
argument_list|)
expr_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
operator|new
name|BlobStoreIndexShardSnapshot
argument_list|(
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
argument_list|,
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|indexCommitPointFiles
argument_list|,
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
comment|// snapshotStatus.startTime() is assigned on the same machine, so it's safe to use with VLong
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
decl_stmt|;
comment|//TODO: The time stored in snapshot doesn't include cleanup time.
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] writing shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexShardSnapshotFormat
operator|.
name|write
argument_list|(
name|snapshot
argument_list|,
name|blobContainer
argument_list|,
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to write commit point"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// delete all files that are not referenced by any commit point
comment|// build a new BlobStoreIndexShardSnapshot, that includes this one and all the saved ones
name|List
argument_list|<
name|SnapshotFiles
argument_list|>
name|newSnapshotsList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|newSnapshotsList
operator|.
name|add
argument_list|(
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SnapshotFiles
name|point
range|:
name|snapshots
control|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
comment|// finalize the snapshot and rewrite the snapshot index with the next sequential snapshot index
name|finalize
argument_list|(
name|newSnapshotsList
argument_list|,
name|fileListGeneration
operator|+
literal|1
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Snapshot individual file          *<p/>          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be snapshotted          * @throws IOException          */
DECL|method|snapshotFile
specifier|private
name|void
name|snapshotFile
parameter_list|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|String
name|file
init|=
name|fileInfo
operator|.
name|physicalName
argument_list|()
decl_stmt|;
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
try|try
init|(
name|IndexInput
name|indexInput
init|=
name|store
operator|.
name|openVerifyingInput
argument_list|(
name|file
argument_list|,
name|IOContext
operator|.
name|READONCE
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
init|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileInfo
operator|.
name|numberOfParts
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|InputStreamIndexInput
name|inputStreamIndexInput
init|=
operator|new
name|InputStreamIndexInput
argument_list|(
name|indexInput
argument_list|,
name|fileInfo
operator|.
name|partBytes
argument_list|()
argument_list|)
decl_stmt|;
name|InputStream
name|inputStream
init|=
name|snapshotRateLimiter
operator|==
literal|null
condition|?
name|inputStreamIndexInput
else|:
operator|new
name|RateLimitingInputStream
argument_list|(
name|inputStreamIndexInput
argument_list|,
name|snapshotRateLimiter
argument_list|,
name|snapshotThrottleListener
argument_list|)
decl_stmt|;
name|inputStream
operator|=
operator|new
name|AbortableInputStream
argument_list|(
name|inputStream
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
try|try
init|(
name|OutputStream
name|output
init|=
name|blobContainer
operator|.
name|createOutput
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|i
argument_list|)
argument_list|)
init|)
block|{
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|inputStream
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|output
operator|.
name|write
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Store
operator|.
name|verify
argument_list|(
name|indexInput
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failStoreIfCorrupted
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
DECL|method|failStoreIfCorrupted
specifier|private
name|void
name|failStoreIfCorrupted
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|CorruptIndexException
operator|||
name|t
operator|instanceof
name|IndexFormatTooOldException
operator|||
name|t
operator|instanceof
name|IndexFormatTooNewException
condition|)
block|{
try|try
block|{
name|store
operator|.
name|markStoreCorrupted
argument_list|(
operator|(
name|IOException
operator|)
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"store cannot be marked as corrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Checks if snapshot file already exists in the list of blobs          *          * @param fileInfo file to check          * @param blobs    list of blobs          * @return true if file exists in the list of blobs          */
DECL|method|snapshotFileExistsInBlobs
specifier|private
name|boolean
name|snapshotFileExistsInBlobs
parameter_list|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobMetaData
name|blobMetaData
init|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blobMetaData
operator|!=
literal|null
condition|)
block|{
return|return
name|blobMetaData
operator|.
name|length
argument_list|()
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|blobs
operator|.
name|containsKey
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|// multi part file sum up the size and check
name|int
name|part
init|=
literal|0
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|blobMetaData
operator|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|part
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobMetaData
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|totalSize
operator|+=
name|blobMetaData
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|totalSize
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
comment|// no file, not exact and not multipart
return|return
literal|false
return|;
block|}
DECL|class|AbortableInputStream
specifier|private
class|class
name|AbortableInputStream
extends|extends
name|FilterInputStream
block|{
DECL|field|fileName
specifier|private
specifier|final
name|String
name|fileName
decl_stmt|;
DECL|method|AbortableInputStream
specifier|public
name|AbortableInputStream
parameter_list|(
name|InputStream
name|delegate
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
DECL|method|checkAborted
specifier|private
name|void
name|checkAborted
parameter_list|()
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * This is a BWC layer to ensure we update the snapshots metdata with the corresponding hashes before we compare them.      * The new logic for StoreFileMetaData reads the entire<tt>.si</tt> and<tt>segments.n</tt> files to strengthen the      * comparison of the files on a per-segment / per-commit level.      */
DECL|method|maybeRecalculateMetadataHash
specifier|private
specifier|static
name|void
name|maybeRecalculateMetadataHash
parameter_list|(
specifier|final
name|BlobContainer
name|blobContainer
parameter_list|,
specifier|final
name|FileInfo
name|fileInfo
parameter_list|,
name|Store
operator|.
name|MetadataSnapshot
name|snapshot
parameter_list|)
throws|throws
name|Throwable
block|{
specifier|final
name|StoreFileMetaData
name|metadata
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|!=
literal|null
operator|&&
operator|(
name|metadata
operator|=
name|snapshot
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|metadata
operator|.
name|hash
argument_list|()
operator|.
name|length
operator|>
literal|0
operator|&&
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|hash
argument_list|()
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// we have a hash - check if our repo has a hash too otherwise we have
comment|// to calculate it.
comment|// we might have multiple parts even though the file is small... make sure we read all of it.
try|try
init|(
specifier|final
name|InputStream
name|stream
init|=
operator|new
name|PartSliceStream
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|)
init|)
block|{
name|BytesRefBuilder
name|builder
init|=
operator|new
name|BytesRefBuilder
argument_list|()
decl_stmt|;
name|Store
operator|.
name|MetadataSnapshot
operator|.
name|hashFile
argument_list|(
name|builder
argument_list|,
name|stream
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
name|BytesRef
name|hash
init|=
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|hash
argument_list|()
decl_stmt|;
comment|// reset the file infos metadata hash
assert|assert
name|hash
operator|.
name|length
operator|==
literal|0
assert|;
name|hash
operator|.
name|bytes
operator|=
name|builder
operator|.
name|bytes
argument_list|()
expr_stmt|;
name|hash
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|hash
operator|.
name|length
operator|=
name|builder
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|PartSliceStream
specifier|private
specifier|static
specifier|final
class|class
name|PartSliceStream
extends|extends
name|SlicedInputStream
block|{
DECL|field|container
specifier|private
specifier|final
name|BlobContainer
name|container
decl_stmt|;
DECL|field|info
specifier|private
specifier|final
name|FileInfo
name|info
decl_stmt|;
DECL|method|PartSliceStream
specifier|public
name|PartSliceStream
parameter_list|(
name|BlobContainer
name|container
parameter_list|,
name|FileInfo
name|info
parameter_list|)
block|{
name|super
argument_list|(
name|info
operator|.
name|numberOfParts
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|info
operator|=
name|info
expr_stmt|;
name|this
operator|.
name|container
operator|=
name|container
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|openSlice
specifier|protected
name|InputStream
name|openSlice
parameter_list|(
name|long
name|slice
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|container
operator|.
name|openInput
argument_list|(
name|info
operator|.
name|partName
argument_list|(
name|slice
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Context for restore operations      */
DECL|class|RestoreContext
specifier|private
class|class
name|RestoreContext
extends|extends
name|Context
block|{
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|recoveryState
specifier|private
specifier|final
name|RecoveryState
name|recoveryState
decl_stmt|;
comment|/**          * Constructs new restore context          *          * @param snapshotId      snapshot id          * @param shardId         shard to be restored          * @param snapshotShardId shard in the snapshot that data should be restored from          * @param recoveryState   recovery state to report progress          */
DECL|method|RestoreContext
specifier|public
name|RestoreContext
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|Version
name|version
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|version
argument_list|,
name|shardId
argument_list|,
name|snapshotShardId
argument_list|)
expr_stmt|;
name|store
operator|=
name|indicesService
operator|.
name|indexServiceSafe
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|shardInjectorSafe
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|getInstance
argument_list|(
name|Store
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|recoveryState
operator|=
name|recoveryState
expr_stmt|;
block|}
comment|/**          * Performs restore operation          */
DECL|method|restore
specifier|public
name|void
name|restore
parameter_list|()
throws|throws
name|IOException
block|{
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] restoring to [{}] ..."
argument_list|,
name|snapshotId
argument_list|,
name|repositoryName
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|loadSnapshot
argument_list|()
decl_stmt|;
name|SnapshotFiles
name|snapshotFiles
init|=
operator|new
name|SnapshotFiles
argument_list|(
name|snapshot
operator|.
name|snapshot
argument_list|()
argument_list|,
name|snapshot
operator|.
name|indexFiles
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|recoveryTargetMetadata
decl_stmt|;
try|try
block|{
name|recoveryTargetMetadata
operator|=
name|store
operator|.
name|getMetadataOrEmpty
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Can't read metadata from store"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Can't restore corrupted shard"
argument_list|,
name|e
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|FileInfo
argument_list|>
name|filesToRecover
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|StoreFileMetaData
argument_list|>
name|snapshotMetaData
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|FileInfo
argument_list|>
name|fileInfos
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|FileInfo
name|fileInfo
range|:
name|snapshot
operator|.
name|indexFiles
argument_list|()
control|)
block|{
try|try
block|{
comment|// in 1.3.3 we added additional hashes for .si / segments_N files
comment|// to ensure we don't double the space in the repo since old snapshots
comment|// don't have this hash we try to read that hash from the blob store
comment|// in a bwc compatible way.
name|maybeRecalculateMetadataHash
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|,
name|recoveryTargetMetadata
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
comment|// if the index is broken we might not be able to read it
name|logger
operator|.
name|warn
argument_list|(
literal|"{} Can't calculate hash from blog for file [{}] [{}]"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|snapshotMetaData
operator|.
name|put
argument_list|(
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
name|fileInfos
operator|.
name|put
argument_list|(
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Store
operator|.
name|MetadataSnapshot
name|sourceMetaData
init|=
operator|new
name|Store
operator|.
name|MetadataSnapshot
argument_list|(
name|snapshotMetaData
argument_list|,
name|Collections
operator|.
name|EMPTY_MAP
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Store
operator|.
name|RecoveryDiff
name|diff
init|=
name|sourceMetaData
operator|.
name|recoveryDiff
argument_list|(
name|recoveryTargetMetadata
argument_list|)
decl_stmt|;
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|diff
operator|.
name|identical
control|)
block|{
name|FileInfo
name|fileInfo
init|=
name|fileInfos
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addFileDetail
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] not_recovering [{}] from [{}], exists in local store and is same"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|StoreFileMetaData
name|md
range|:
name|Iterables
operator|.
name|concat
argument_list|(
name|diff
operator|.
name|different
argument_list|,
name|diff
operator|.
name|missing
argument_list|)
control|)
block|{
name|FileInfo
name|fileInfo
init|=
name|fileInfos
operator|.
name|get
argument_list|(
name|md
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|filesToRecover
operator|.
name|add
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addFileDetail
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering [{}] from [{}], does not exists in local store"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering [{}] from [{}], exists in local store but is different"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|RecoveryState
operator|.
name|Index
name|index
init|=
name|recoveryState
operator|.
name|getIndex
argument_list|()
decl_stmt|;
if|if
condition|(
name|filesToRecover
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"no files to recover, all exists within the local store"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering_files [{}] with total_size [{}], reusing_files [{}] with reused_size [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|index
operator|.
name|totalRecoverFiles
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|index
operator|.
name|totalRecoverBytes
argument_list|()
argument_list|)
argument_list|,
name|index
operator|.
name|reusedFileCount
argument_list|()
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|index
operator|.
name|reusedFileCount
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
try|try
block|{
for|for
control|(
specifier|final
name|FileInfo
name|fileToRecover
range|:
name|filesToRecover
control|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] restoring file [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileToRecover
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|restoreFile
argument_list|(
name|fileToRecover
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to recover index"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
specifier|final
name|StoreFileMetaData
name|restoredSegmentsFile
init|=
name|sourceMetaData
operator|.
name|getSegmentsFile
argument_list|()
decl_stmt|;
if|if
condition|(
name|recoveryTargetMetadata
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Snapshot has no segments file"
argument_list|)
throw|;
block|}
assert|assert
name|restoredSegmentsFile
operator|!=
literal|null
assert|;
comment|// read the snapshot data persisted
specifier|final
name|SegmentInfos
name|segmentCommitInfos
decl_stmt|;
try|try
block|{
name|segmentCommitInfos
operator|=
name|Lucene
operator|.
name|pruneUnreferencedFiles
argument_list|(
name|restoredSegmentsFile
operator|.
name|name
argument_list|()
argument_list|,
name|store
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to fetch index version after copying it over"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|updateVersion
argument_list|(
name|segmentCommitInfos
operator|.
name|getVersion
argument_list|()
argument_list|)
expr_stmt|;
comment|/// now, go over and clean files that are in the store, but were not in the snapshot
try|try
block|{
for|for
control|(
name|String
name|storeFile
range|:
name|store
operator|.
name|directory
argument_list|()
operator|.
name|listAll
argument_list|()
control|)
block|{
if|if
condition|(
name|Store
operator|.
name|isAutogenerated
argument_list|(
name|storeFile
argument_list|)
operator|||
name|snapshotFiles
operator|.
name|containPhysicalIndexFile
argument_list|(
name|storeFile
argument_list|)
condition|)
block|{
continue|continue;
comment|//skip write.lock, checksum files and files that exist in the snapshot
block|}
try|try
block|{
name|store
operator|.
name|deleteQuiet
argument_list|(
literal|"restore"
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
name|store
operator|.
name|directory
argument_list|()
operator|.
name|deleteFile
argument_list|(
name|storeFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to delete file [{}] during snapshot cleanup"
argument_list|,
name|snapshotId
argument_list|,
name|storeFile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to list directory - some of files might not be deleted"
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Restores a file          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be restored          */
DECL|method|restoreFile
specifier|private
name|void
name|restoreFile
parameter_list|(
specifier|final
name|FileInfo
name|fileInfo
parameter_list|)
throws|throws
name|IOException
block|{
name|boolean
name|success
init|=
literal|false
decl_stmt|;
try|try
init|(
name|InputStream
name|stream
init|=
operator|new
name|PartSliceStream
argument_list|(
name|blobContainer
argument_list|,
name|fileInfo
argument_list|)
init|)
block|{
try|try
init|(
specifier|final
name|IndexOutput
name|indexOutput
init|=
name|store
operator|.
name|createVerifyingOutput
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|,
name|IOContext
operator|.
name|DEFAULT
argument_list|)
init|)
block|{
specifier|final
name|byte
index|[]
name|buffer
init|=
operator|new
name|byte
index|[
name|BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
while|while
condition|(
operator|(
name|length
operator|=
name|stream
operator|.
name|read
argument_list|(
name|buffer
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|indexOutput
operator|.
name|writeBytes
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|recoveryState
operator|.
name|getIndex
argument_list|()
operator|.
name|addRecoveredBytesToFile
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|restoreRateLimiter
operator|!=
literal|null
condition|)
block|{
name|rateLimiterListener
operator|.
name|onRestorePause
argument_list|(
name|restoreRateLimiter
operator|.
name|pause
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|Store
operator|.
name|verify
argument_list|(
name|indexOutput
argument_list|)
expr_stmt|;
name|indexOutput
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// write the checksum
if|if
condition|(
name|fileInfo
operator|.
name|metadata
argument_list|()
operator|.
name|hasLegacyChecksum
argument_list|()
condition|)
block|{
name|Store
operator|.
name|LegacyChecksums
name|legacyChecksums
init|=
operator|new
name|Store
operator|.
name|LegacyChecksums
argument_list|()
decl_stmt|;
name|legacyChecksums
operator|.
name|add
argument_list|(
name|fileInfo
operator|.
name|metadata
argument_list|()
argument_list|)
expr_stmt|;
name|legacyChecksums
operator|.
name|write
argument_list|(
name|store
argument_list|)
expr_stmt|;
block|}
name|store
operator|.
name|directory
argument_list|()
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CorruptIndexException
decl||
name|IndexFormatTooOldException
decl||
name|IndexFormatTooNewException
name|ex
parameter_list|)
block|{
try|try
block|{
name|store
operator|.
name|markStoreCorrupted
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"store cannot be marked as corrupted"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
throw|throw
name|ex
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|store
operator|.
name|deleteQuiet
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|interface|RateLimiterListener
specifier|public
interface|interface
name|RateLimiterListener
block|{
DECL|method|onRestorePause
name|void
name|onRestorePause
parameter_list|(
name|long
name|nanos
parameter_list|)
function_decl|;
DECL|method|onSnapshotPause
name|void
name|onSnapshotPause
parameter_list|(
name|long
name|nanos
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

