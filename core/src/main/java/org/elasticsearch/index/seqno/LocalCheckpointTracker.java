begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.seqno
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|seqno
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|FixedBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|SuppressForbidden
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_comment
comment|/**  * This class generates sequences numbers and keeps track of the so-called "local checkpoint" which is the highest number for which all  * previous sequence numbers have been processed (inclusive).  */
end_comment

begin_class
DECL|class|LocalCheckpointTracker
specifier|public
class|class
name|LocalCheckpointTracker
block|{
comment|/**      * We keep a bit for each sequence number that is still pending. To optimize allocation, we do so in multiple arrays allocating them on      * demand and cleaning up while completed. This setting controls the size of the arrays.      */
DECL|field|SETTINGS_BIT_ARRAYS_SIZE
specifier|public
specifier|static
name|Setting
argument_list|<
name|Integer
argument_list|>
name|SETTINGS_BIT_ARRAYS_SIZE
init|=
name|Setting
operator|.
name|intSetting
argument_list|(
literal|"index.seq_no.checkpoint.bit_arrays_size"
argument_list|,
literal|1024
argument_list|,
literal|4
argument_list|,
name|Setting
operator|.
name|Property
operator|.
name|IndexScope
argument_list|)
decl_stmt|;
comment|/**      * An ordered list of bit arrays representing pending sequence numbers. The list is "anchored" in {@link #firstProcessedSeqNo} which      * marks the sequence number the fist bit in the first array corresponds to.      */
DECL|field|processedSeqNo
specifier|final
name|LinkedList
argument_list|<
name|FixedBitSet
argument_list|>
name|processedSeqNo
init|=
operator|new
name|LinkedList
argument_list|<>
argument_list|()
decl_stmt|;
comment|/**      * The size of each bit set representing processed sequence numbers.      */
DECL|field|bitArraysSize
specifier|private
specifier|final
name|int
name|bitArraysSize
decl_stmt|;
comment|/**      * The sequence number that the first bit in the first array corresponds to.      */
DECL|field|firstProcessedSeqNo
name|long
name|firstProcessedSeqNo
decl_stmt|;
comment|/**      * The current local checkpoint, i.e., all sequence numbers no more than this number have been completed.      */
DECL|field|checkpoint
specifier|volatile
name|long
name|checkpoint
decl_stmt|;
comment|/**      * The next available sequence number.      */
DECL|field|nextSeqNo
specifier|private
specifier|volatile
name|long
name|nextSeqNo
decl_stmt|;
comment|/**      * Initialize the local checkpoint service. The {@code maxSeqNo} should be set to the last sequence number assigned, or      * {@link SequenceNumbersService#NO_OPS_PERFORMED} and {@code localCheckpoint} should be set to the last known local checkpoint,      * or {@link SequenceNumbersService#NO_OPS_PERFORMED}.      *      * @param indexSettings   the index settings      * @param maxSeqNo        the last sequence number assigned, or {@link SequenceNumbersService#NO_OPS_PERFORMED}      * @param localCheckpoint the last known local checkpoint, or {@link SequenceNumbersService#NO_OPS_PERFORMED}      */
DECL|method|LocalCheckpointTracker
specifier|public
name|LocalCheckpointTracker
parameter_list|(
specifier|final
name|IndexSettings
name|indexSettings
parameter_list|,
specifier|final
name|long
name|maxSeqNo
parameter_list|,
specifier|final
name|long
name|localCheckpoint
parameter_list|)
block|{
if|if
condition|(
name|localCheckpoint
operator|<
literal|0
operator|&&
name|localCheckpoint
operator|!=
name|SequenceNumbersService
operator|.
name|NO_OPS_PERFORMED
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"local checkpoint must be non-negative or ["
operator|+
name|SequenceNumbersService
operator|.
name|NO_OPS_PERFORMED
operator|+
literal|"] "
operator|+
literal|"but was ["
operator|+
name|localCheckpoint
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|maxSeqNo
operator|<
literal|0
operator|&&
name|maxSeqNo
operator|!=
name|SequenceNumbersService
operator|.
name|NO_OPS_PERFORMED
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"max seq. no. must be non-negative or ["
operator|+
name|SequenceNumbersService
operator|.
name|NO_OPS_PERFORMED
operator|+
literal|"] but was ["
operator|+
name|maxSeqNo
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|bitArraysSize
operator|=
name|SETTINGS_BIT_ARRAYS_SIZE
operator|.
name|get
argument_list|(
name|indexSettings
operator|.
name|getSettings
argument_list|()
argument_list|)
expr_stmt|;
name|firstProcessedSeqNo
operator|=
name|localCheckpoint
operator|==
name|SequenceNumbersService
operator|.
name|NO_OPS_PERFORMED
condition|?
literal|0
else|:
name|localCheckpoint
operator|+
literal|1
expr_stmt|;
name|nextSeqNo
operator|=
name|maxSeqNo
operator|==
name|SequenceNumbersService
operator|.
name|NO_OPS_PERFORMED
condition|?
literal|0
else|:
name|maxSeqNo
operator|+
literal|1
expr_stmt|;
name|checkpoint
operator|=
name|localCheckpoint
expr_stmt|;
block|}
comment|/**      * Issue the next sequence number.      *      * @return the next assigned sequence number      */
DECL|method|generateSeqNo
specifier|synchronized
name|long
name|generateSeqNo
parameter_list|()
block|{
return|return
name|nextSeqNo
operator|++
return|;
block|}
comment|/**      * Marks the processing of the provided sequence number as completed as updates the checkpoint if possible.      *      * @param seqNo the sequence number to mark as completed      */
DECL|method|markSeqNoAsCompleted
specifier|public
specifier|synchronized
name|void
name|markSeqNoAsCompleted
parameter_list|(
specifier|final
name|long
name|seqNo
parameter_list|)
block|{
comment|// make sure we track highest seen sequence number
if|if
condition|(
name|seqNo
operator|>=
name|nextSeqNo
condition|)
block|{
name|nextSeqNo
operator|=
name|seqNo
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|seqNo
operator|<=
name|checkpoint
condition|)
block|{
comment|// this is possible during recovery where we might replay an operation that was also replicated
return|return;
block|}
specifier|final
name|FixedBitSet
name|bitSet
init|=
name|getBitSetForSeqNo
argument_list|(
name|seqNo
argument_list|)
decl_stmt|;
specifier|final
name|int
name|offset
init|=
name|seqNoToBitSetOffset
argument_list|(
name|seqNo
argument_list|)
decl_stmt|;
name|bitSet
operator|.
name|set
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|seqNo
operator|==
name|checkpoint
operator|+
literal|1
condition|)
block|{
name|updateCheckpoint
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * The current checkpoint which can be advanced by {@link #markSeqNoAsCompleted(long)}.      *      * @return the current checkpoint      */
DECL|method|getCheckpoint
specifier|public
name|long
name|getCheckpoint
parameter_list|()
block|{
return|return
name|checkpoint
return|;
block|}
comment|/**      * The maximum sequence number issued so far.      *      * @return the maximum sequence number      */
DECL|method|getMaxSeqNo
name|long
name|getMaxSeqNo
parameter_list|()
block|{
return|return
name|nextSeqNo
operator|-
literal|1
return|;
block|}
comment|/**      * constructs a {@link SeqNoStats} object, using local state and the supplied global checkpoint      *      * @implNote this is needed to make sure the local checkpoint and max seq no are consistent      */
DECL|method|getStats
specifier|synchronized
name|SeqNoStats
name|getStats
parameter_list|(
specifier|final
name|long
name|globalCheckpoint
parameter_list|)
block|{
return|return
operator|new
name|SeqNoStats
argument_list|(
name|getMaxSeqNo
argument_list|()
argument_list|,
name|getCheckpoint
argument_list|()
argument_list|,
name|globalCheckpoint
argument_list|)
return|;
block|}
comment|/**      * Waits for all operations up to the provided sequence number to complete.      *      * @param seqNo the sequence number that the checkpoint must advance to before this method returns      * @throws InterruptedException if the thread was interrupted while blocking on the condition      */
annotation|@
name|SuppressForbidden
argument_list|(
name|reason
operator|=
literal|"Object#wait"
argument_list|)
DECL|method|waitForOpsToComplete
specifier|synchronized
name|void
name|waitForOpsToComplete
parameter_list|(
specifier|final
name|long
name|seqNo
parameter_list|)
throws|throws
name|InterruptedException
block|{
while|while
condition|(
name|checkpoint
operator|<
name|seqNo
condition|)
block|{
comment|// notified by updateCheckpoint
name|this
operator|.
name|wait
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Moves the checkpoint to the last consecutively processed sequence number. This method assumes that the sequence number following the      * current checkpoint is processed.      */
annotation|@
name|SuppressForbidden
argument_list|(
name|reason
operator|=
literal|"Object#notifyAll"
argument_list|)
DECL|method|updateCheckpoint
specifier|private
name|void
name|updateCheckpoint
parameter_list|()
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
assert|assert
name|checkpoint
operator|<
name|firstProcessedSeqNo
operator|+
name|bitArraysSize
operator|-
literal|1
operator|:
literal|"checkpoint should be below the end of the first bit set (o.w. current bit set is completed and shouldn't be there)"
assert|;
assert|assert
name|getBitSetForSeqNo
argument_list|(
name|checkpoint
operator|+
literal|1
argument_list|)
operator|==
name|processedSeqNo
operator|.
name|getFirst
argument_list|()
operator|:
literal|"checkpoint + 1 doesn't point to the first bit set (o.w. current bit set is completed and shouldn't be there)"
assert|;
assert|assert
name|getBitSetForSeqNo
argument_list|(
name|checkpoint
operator|+
literal|1
argument_list|)
operator|.
name|get
argument_list|(
name|seqNoToBitSetOffset
argument_list|(
name|checkpoint
operator|+
literal|1
argument_list|)
argument_list|)
operator|:
literal|"updateCheckpoint is called but the bit following the checkpoint is not set"
assert|;
try|try
block|{
comment|// keep it simple for now, get the checkpoint one by one; in the future we can optimize and read words
name|FixedBitSet
name|current
init|=
name|processedSeqNo
operator|.
name|getFirst
argument_list|()
decl_stmt|;
do|do
block|{
name|checkpoint
operator|++
expr_stmt|;
comment|// the checkpoint always falls in the first bit set or just before. If it falls
comment|// on the last bit of the current bit set, we can clean it.
if|if
condition|(
name|checkpoint
operator|==
name|firstProcessedSeqNo
operator|+
name|bitArraysSize
operator|-
literal|1
condition|)
block|{
name|processedSeqNo
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
name|firstProcessedSeqNo
operator|+=
name|bitArraysSize
expr_stmt|;
assert|assert
name|checkpoint
operator|-
name|firstProcessedSeqNo
operator|<
name|bitArraysSize
assert|;
name|current
operator|=
name|processedSeqNo
operator|.
name|peekFirst
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|current
operator|!=
literal|null
operator|&&
name|current
operator|.
name|get
argument_list|(
name|seqNoToBitSetOffset
argument_list|(
name|checkpoint
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
do|;
block|}
finally|finally
block|{
comment|// notifies waiters in waitForOpsToComplete
name|this
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Return the bit array for the provided sequence number, possibly allocating a new array if needed.      *      * @param seqNo the sequence number to obtain the bit array for      * @return the bit array corresponding to the provided sequence number      */
DECL|method|getBitSetForSeqNo
specifier|private
name|FixedBitSet
name|getBitSetForSeqNo
parameter_list|(
specifier|final
name|long
name|seqNo
parameter_list|)
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
assert|assert
name|seqNo
operator|>=
name|firstProcessedSeqNo
operator|:
literal|"seqNo: "
operator|+
name|seqNo
operator|+
literal|" firstProcessedSeqNo: "
operator|+
name|firstProcessedSeqNo
assert|;
specifier|final
name|long
name|bitSetOffset
init|=
operator|(
name|seqNo
operator|-
name|firstProcessedSeqNo
operator|)
operator|/
name|bitArraysSize
decl_stmt|;
if|if
condition|(
name|bitSetOffset
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"sequence number too high; got ["
operator|+
name|seqNo
operator|+
literal|"], firstProcessedSeqNo ["
operator|+
name|firstProcessedSeqNo
operator|+
literal|"]"
argument_list|)
throw|;
block|}
while|while
condition|(
name|bitSetOffset
operator|>=
name|processedSeqNo
operator|.
name|size
argument_list|()
condition|)
block|{
name|processedSeqNo
operator|.
name|add
argument_list|(
operator|new
name|FixedBitSet
argument_list|(
name|bitArraysSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|processedSeqNo
operator|.
name|get
argument_list|(
operator|(
name|int
operator|)
name|bitSetOffset
argument_list|)
return|;
block|}
comment|/**      * Obtain the position in the bit array corresponding to the provided sequence number. The bit array corresponding to the sequence      * number can be obtained via {@link #getBitSetForSeqNo(long)}.      *      * @param seqNo the sequence number to obtain the position for      * @return the position in the bit array corresponding to the provided sequence number      */
DECL|method|seqNoToBitSetOffset
specifier|private
name|int
name|seqNoToBitSetOffset
parameter_list|(
specifier|final
name|long
name|seqNo
parameter_list|)
block|{
assert|assert
name|Thread
operator|.
name|holdsLock
argument_list|(
name|this
argument_list|)
assert|;
assert|assert
name|seqNo
operator|>=
name|firstProcessedSeqNo
assert|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|seqNo
operator|-
name|firstProcessedSeqNo
argument_list|)
operator|)
operator|%
name|bitArraysSize
return|;
block|}
block|}
end_class

end_unit

