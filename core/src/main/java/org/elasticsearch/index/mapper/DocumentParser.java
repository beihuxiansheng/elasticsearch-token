begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.mapper
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CloseableThreadLocal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|joda
operator|.
name|FormatDateTimeFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|BinaryFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|BooleanFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|DateFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|DateFieldMapper
operator|.
name|DateFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|DoubleFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|FloatFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|IntegerFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|KeywordFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|KeywordFieldMapper
operator|.
name|KeywordFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|LongFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|StringFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|StringFieldMapper
operator|.
name|StringFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|TextFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|TextFieldMapper
operator|.
name|TextFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|internal
operator|.
name|TypeFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|internal
operator|.
name|UidFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|object
operator|.
name|ArrayValueMapperParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|object
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|object
operator|.
name|RootObjectMapper
import|;
end_import

begin_comment
comment|/** A parser for documents, given mappings from a DocumentMapper */
end_comment

begin_class
DECL|class|DocumentParser
specifier|final
class|class
name|DocumentParser
implements|implements
name|Closeable
block|{
DECL|field|cache
specifier|private
name|CloseableThreadLocal
argument_list|<
name|ParseContext
operator|.
name|InternalParseContext
argument_list|>
name|cache
init|=
operator|new
name|CloseableThreadLocal
argument_list|<
name|ParseContext
operator|.
name|InternalParseContext
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|ParseContext
operator|.
name|InternalParseContext
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|ParseContext
operator|.
name|InternalParseContext
argument_list|(
name|indexSettings
operator|.
name|getSettings
argument_list|()
argument_list|,
name|docMapperParser
argument_list|,
name|docMapper
argument_list|,
operator|new
name|ContentPath
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|indexSettings
specifier|private
specifier|final
name|IndexSettings
name|indexSettings
decl_stmt|;
DECL|field|docMapperParser
specifier|private
specifier|final
name|DocumentMapperParser
name|docMapperParser
decl_stmt|;
DECL|field|docMapper
specifier|private
specifier|final
name|DocumentMapper
name|docMapper
decl_stmt|;
DECL|method|DocumentParser
specifier|public
name|DocumentParser
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|,
name|DocumentMapperParser
name|docMapperParser
parameter_list|,
name|DocumentMapper
name|docMapper
parameter_list|)
block|{
name|this
operator|.
name|indexSettings
operator|=
name|indexSettings
expr_stmt|;
name|this
operator|.
name|docMapperParser
operator|=
name|docMapperParser
expr_stmt|;
name|this
operator|.
name|docMapper
operator|=
name|docMapper
expr_stmt|;
block|}
DECL|method|parseDocument
specifier|final
name|ParsedDocument
name|parseDocument
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
throws|throws
name|MapperParsingException
block|{
name|validateType
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|source
operator|.
name|type
argument_list|(
name|docMapper
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Mapping
name|mapping
init|=
name|docMapper
operator|.
name|mapping
argument_list|()
decl_stmt|;
specifier|final
name|ParseContext
operator|.
name|InternalParseContext
name|context
init|=
name|cache
operator|.
name|get
argument_list|()
decl_stmt|;
name|XContentParser
name|parser
init|=
literal|null
decl_stmt|;
try|try
block|{
name|parser
operator|=
name|parser
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|context
operator|.
name|reset
argument_list|(
name|parser
argument_list|,
operator|new
name|ParseContext
operator|.
name|Document
argument_list|()
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|validateStart
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|internalParseDocument
argument_list|(
name|mapping
argument_list|,
name|context
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|validateEnd
argument_list|(
name|source
argument_list|,
name|parser
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|wrapInMapperParsingException
argument_list|(
name|source
argument_list|,
name|t
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// only close the parser when its not provided externally
if|if
condition|(
name|internalParser
argument_list|(
name|source
argument_list|,
name|parser
argument_list|)
condition|)
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|reverseOrder
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ParsedDocument
name|doc
init|=
name|parsedDocument
argument_list|(
name|source
argument_list|,
name|context
argument_list|,
name|createDynamicUpdate
argument_list|(
name|mapping
argument_list|,
name|docMapper
argument_list|,
name|context
operator|.
name|getDynamicMappers
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// reset the context to free up memory
name|context
operator|.
name|reset
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
DECL|method|internalParseDocument
specifier|private
specifier|static
name|void
name|internalParseDocument
parameter_list|(
name|Mapping
name|mapping
parameter_list|,
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|emptyDoc
init|=
name|isEmptyDoc
argument_list|(
name|mapping
argument_list|,
name|parser
argument_list|)
decl_stmt|;
for|for
control|(
name|MetadataFieldMapper
name|metadataMapper
range|:
name|mapping
operator|.
name|metadataMappers
control|)
block|{
name|metadataMapper
operator|.
name|preParse
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapping
operator|.
name|root
operator|.
name|isEnabled
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// entire type is disabled
name|parser
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|emptyDoc
operator|==
literal|false
condition|)
block|{
name|parseObjectOrNested
argument_list|(
name|context
argument_list|,
name|mapping
operator|.
name|root
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|MetadataFieldMapper
name|metadataMapper
range|:
name|mapping
operator|.
name|metadataMappers
control|)
block|{
name|metadataMapper
operator|.
name|postParse
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|validateType
specifier|private
name|void
name|validateType
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
block|{
if|if
condition|(
name|docMapper
operator|.
name|type
argument_list|()
operator|.
name|equals
argument_list|(
name|MapperService
operator|.
name|DEFAULT_MAPPING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"It is forbidden to index into the default mapping ["
operator|+
name|MapperService
operator|.
name|DEFAULT_MAPPING
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|source
operator|.
name|type
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|source
operator|.
name|type
argument_list|()
operator|.
name|equals
argument_list|(
name|docMapper
operator|.
name|type
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Type mismatch, provide type ["
operator|+
name|source
operator|.
name|type
argument_list|()
operator|+
literal|"] but mapper is of type ["
operator|+
name|docMapper
operator|.
name|type
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
DECL|method|parser
specifier|private
specifier|static
name|XContentParser
name|parser
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|source
operator|.
name|parser
argument_list|()
operator|==
literal|null
condition|?
name|XContentHelper
operator|.
name|createParser
argument_list|(
name|source
operator|.
name|source
argument_list|()
argument_list|)
else|:
name|source
operator|.
name|parser
argument_list|()
return|;
block|}
DECL|method|internalParser
specifier|private
specifier|static
name|boolean
name|internalParser
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
block|{
return|return
name|source
operator|.
name|parser
argument_list|()
operator|==
literal|null
operator|&&
name|parser
operator|!=
literal|null
return|;
block|}
DECL|method|validateStart
specifier|private
specifier|static
name|void
name|validateStart
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
comment|// will result in START_OBJECT
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Malformed content, must start with an object"
argument_list|)
throw|;
block|}
block|}
DECL|method|validateEnd
specifier|private
specifier|static
name|void
name|validateEnd
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
comment|// only check for end of tokens if we created the parser here
if|if
condition|(
name|internalParser
argument_list|(
name|source
argument_list|,
name|parser
argument_list|)
condition|)
block|{
comment|// try to parse the next token, this should be null if the object is ended properly
comment|// but will throw a JSON exception if the extra tokens is not valid JSON (this will be handled by the catch)
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed content, found extra data after parsing: "
operator|+
name|token
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|isEmptyDoc
specifier|private
specifier|static
name|boolean
name|isEmptyDoc
parameter_list|(
name|Mapping
name|mapping
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mapping
operator|.
name|root
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
specifier|final
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
comment|// empty doc, we can handle it...
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Malformed content, after first object, either the type field or the actual properties should exist"
argument_list|)
throw|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|reverseOrder
specifier|private
specifier|static
name|void
name|reverseOrder
parameter_list|(
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|)
block|{
comment|// reverse the order of docs for nested docs support, parent should be last
if|if
condition|(
name|context
operator|.
name|docs
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|reverse
argument_list|(
name|context
operator|.
name|docs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parsedDocument
specifier|private
specifier|static
name|ParsedDocument
name|parsedDocument
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|,
name|Mapping
name|update
parameter_list|)
block|{
return|return
operator|new
name|ParsedDocument
argument_list|(
name|context
operator|.
name|uid
argument_list|()
argument_list|,
name|context
operator|.
name|version
argument_list|()
argument_list|,
name|context
operator|.
name|id
argument_list|()
argument_list|,
name|context
operator|.
name|type
argument_list|()
argument_list|,
name|source
operator|.
name|routing
argument_list|()
argument_list|,
name|source
operator|.
name|timestamp
argument_list|()
argument_list|,
name|source
operator|.
name|ttl
argument_list|()
argument_list|,
name|context
operator|.
name|docs
argument_list|()
argument_list|,
name|context
operator|.
name|source
argument_list|()
argument_list|,
name|update
argument_list|)
operator|.
name|parent
argument_list|(
name|source
operator|.
name|parent
argument_list|()
argument_list|)
return|;
block|}
DECL|method|wrapInMapperParsingException
specifier|private
specifier|static
name|MapperParsingException
name|wrapInMapperParsingException
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
comment|// if its already a mapper parsing exception, no need to wrap it...
if|if
condition|(
name|e
operator|instanceof
name|MapperParsingException
condition|)
block|{
return|return
operator|(
name|MapperParsingException
operator|)
name|e
return|;
block|}
comment|// Throw a more meaningful message if the document is empty.
if|if
condition|(
name|source
operator|.
name|source
argument_list|()
operator|!=
literal|null
operator|&&
name|source
operator|.
name|source
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|MapperParsingException
argument_list|(
literal|"failed to parse, document is empty"
argument_list|)
return|;
block|}
return|return
operator|new
name|MapperParsingException
argument_list|(
literal|"failed to parse"
argument_list|,
name|e
argument_list|)
return|;
block|}
comment|/** Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings. */
DECL|method|createDynamicUpdate
specifier|static
name|Mapping
name|createDynamicUpdate
parameter_list|(
name|Mapping
name|mapping
parameter_list|,
name|DocumentMapper
name|docMapper
parameter_list|,
name|List
argument_list|<
name|Mapper
argument_list|>
name|dynamicMappers
parameter_list|)
block|{
if|if
condition|(
name|dynamicMappers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// We build a mapping by first sorting the mappers, so that all mappers containing a common prefix
comment|// will be processed in a contiguous block. When the prefix is no longer seen, we pop the extra elements
comment|// off the stack, merging them upwards into the existing mappers.
name|Collections
operator|.
name|sort
argument_list|(
name|dynamicMappers
argument_list|,
parameter_list|(
name|Mapper
name|o1
parameter_list|,
name|Mapper
name|o2
parameter_list|)
lambda|->
name|o1
operator|.
name|name
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Mapper
argument_list|>
name|dynamicMapperItr
init|=
name|dynamicMappers
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ObjectMapper
argument_list|>
name|parentMappers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|Mapper
name|firstUpdate
init|=
name|dynamicMapperItr
operator|.
name|next
argument_list|()
decl_stmt|;
name|parentMappers
operator|.
name|add
argument_list|(
name|createUpdate
argument_list|(
name|mapping
operator|.
name|root
argument_list|()
argument_list|,
name|firstUpdate
operator|.
name|name
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
argument_list|,
literal|0
argument_list|,
name|firstUpdate
argument_list|)
argument_list|)
expr_stmt|;
name|Mapper
name|previousMapper
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|dynamicMapperItr
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Mapper
name|newMapper
init|=
name|dynamicMapperItr
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|previousMapper
operator|!=
literal|null
operator|&&
name|newMapper
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|previousMapper
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
comment|// We can see the same mapper more than once, for example, if we had foo.bar and foo.baz, where
comment|// foo did not yet exist. This will create 2 copies in dynamic mappings, which should be identical.
comment|// Here we just skip over the duplicates, but we merge them to ensure there are no conflicts.
name|newMapper
operator|.
name|merge
argument_list|(
name|previousMapper
argument_list|,
literal|false
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|previousMapper
operator|=
name|newMapper
expr_stmt|;
name|String
index|[]
name|nameParts
init|=
name|newMapper
operator|.
name|name
argument_list|()
operator|.
name|split
argument_list|(
literal|"\\."
argument_list|)
decl_stmt|;
comment|// We first need the stack to only contain mappers in common with the previously processed mapper
comment|// For example, if the first mapper processed was a.b.c, and we now have a.d, the stack will contain
comment|// a.b, and we want to merge b back into the stack so it just contains a
name|int
name|i
init|=
name|removeUncommonMappers
argument_list|(
name|parentMappers
argument_list|,
name|nameParts
argument_list|)
decl_stmt|;
comment|// Then we need to add back mappers that may already exist within the stack, but are not on it.
comment|// For example, if we processed a.b, followed by an object mapper a.c.d, and now are adding a.c.d.e
comment|// then the stack will only have a on it because we will have already merged a.c.d into the stack.
comment|// So we need to pull a.c, followed by a.c.d, onto the stack so e can be added to the end.
name|i
operator|=
name|expandCommonMappers
argument_list|(
name|parentMappers
argument_list|,
name|nameParts
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|// If there are still parents of the new mapper which are not on the stack, we need to pull them
comment|// from the existing mappings. In order to maintain the invariant that the stack only contains
comment|// fields which are updated, we cannot simply add the existing mappers to the stack, since they
comment|// may have other subfields which will not be updated. Instead, we pull the mapper from the existing
comment|// mappings, and build an update with only the new mapper and its parents. This then becomes our
comment|// "new mapper", and can be added to the stack.
if|if
condition|(
name|i
operator|<
name|nameParts
operator|.
name|length
operator|-
literal|1
condition|)
block|{
name|newMapper
operator|=
name|createExistingMapperUpdate
argument_list|(
name|parentMappers
argument_list|,
name|nameParts
argument_list|,
name|i
argument_list|,
name|docMapper
argument_list|,
name|newMapper
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newMapper
operator|instanceof
name|ObjectMapper
condition|)
block|{
name|parentMappers
operator|.
name|add
argument_list|(
operator|(
name|ObjectMapper
operator|)
name|newMapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addToLastMapper
argument_list|(
name|parentMappers
argument_list|,
name|newMapper
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
name|popMappers
argument_list|(
name|parentMappers
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|)
expr_stmt|;
assert|assert
name|parentMappers
operator|.
name|size
argument_list|()
operator|==
literal|1
assert|;
return|return
name|mapping
operator|.
name|mappingUpdate
argument_list|(
name|parentMappers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
DECL|method|popMappers
specifier|private
specifier|static
name|void
name|popMappers
parameter_list|(
name|List
argument_list|<
name|ObjectMapper
argument_list|>
name|parentMappers
parameter_list|,
name|int
name|keepBefore
parameter_list|,
name|boolean
name|merge
parameter_list|)
block|{
assert|assert
name|keepBefore
operator|>=
literal|1
assert|;
comment|// never remove the root mapper
comment|// pop off parent mappers not needed by the current mapper,
comment|// merging them backwards since they are immutable
for|for
control|(
name|int
name|i
init|=
name|parentMappers
operator|.
name|size
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
name|keepBefore
condition|;
operator|--
name|i
control|)
block|{
name|addToLastMapper
argument_list|(
name|parentMappers
argument_list|,
name|parentMappers
operator|.
name|remove
argument_list|(
name|i
argument_list|)
argument_list|,
name|merge
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Adds a mapper as an update into the last mapper. If merge is true, the new mapper      * will be merged in with other child mappers of the last parent, otherwise it will be a new update.      */
DECL|method|addToLastMapper
specifier|private
specifier|static
name|void
name|addToLastMapper
parameter_list|(
name|List
argument_list|<
name|ObjectMapper
argument_list|>
name|parentMappers
parameter_list|,
name|Mapper
name|mapper
parameter_list|,
name|boolean
name|merge
parameter_list|)
block|{
assert|assert
name|parentMappers
operator|.
name|size
argument_list|()
operator|>=
literal|1
assert|;
name|int
name|lastIndex
init|=
name|parentMappers
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
name|ObjectMapper
name|withNewMapper
init|=
name|parentMappers
operator|.
name|get
argument_list|(
name|lastIndex
argument_list|)
operator|.
name|mappingUpdate
argument_list|(
name|mapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|merge
condition|)
block|{
name|withNewMapper
operator|=
name|parentMappers
operator|.
name|get
argument_list|(
name|lastIndex
argument_list|)
operator|.
name|merge
argument_list|(
name|withNewMapper
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|parentMappers
operator|.
name|set
argument_list|(
name|lastIndex
argument_list|,
name|withNewMapper
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes mappers that exist on the stack, but are not part of the path of the current nameParts,      * Returns the next unprocessed index from nameParts.      */
DECL|method|removeUncommonMappers
specifier|private
specifier|static
name|int
name|removeUncommonMappers
parameter_list|(
name|List
argument_list|<
name|ObjectMapper
argument_list|>
name|parentMappers
parameter_list|,
name|String
index|[]
name|nameParts
parameter_list|)
block|{
name|int
name|keepBefore
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|keepBefore
operator|<
name|parentMappers
operator|.
name|size
argument_list|()
operator|&&
name|parentMappers
operator|.
name|get
argument_list|(
name|keepBefore
argument_list|)
operator|.
name|simpleName
argument_list|()
operator|.
name|equals
argument_list|(
name|nameParts
index|[
name|keepBefore
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
operator|++
name|keepBefore
expr_stmt|;
block|}
name|popMappers
argument_list|(
name|parentMappers
argument_list|,
name|keepBefore
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|keepBefore
operator|-
literal|1
return|;
block|}
comment|/**      * Adds mappers from the end of the stack that exist as updates within those mappers.      * Returns the next unprocessed index from nameParts.      */
DECL|method|expandCommonMappers
specifier|private
specifier|static
name|int
name|expandCommonMappers
parameter_list|(
name|List
argument_list|<
name|ObjectMapper
argument_list|>
name|parentMappers
parameter_list|,
name|String
index|[]
name|nameParts
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|ObjectMapper
name|last
init|=
name|parentMappers
operator|.
name|get
argument_list|(
name|parentMappers
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|nameParts
operator|.
name|length
operator|-
literal|1
operator|&&
name|last
operator|.
name|getMapper
argument_list|(
name|nameParts
index|[
name|i
index|]
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|Mapper
name|newLast
init|=
name|last
operator|.
name|getMapper
argument_list|(
name|nameParts
index|[
name|i
index|]
argument_list|)
decl_stmt|;
assert|assert
name|newLast
operator|instanceof
name|ObjectMapper
assert|;
name|parentMappers
operator|.
name|add
argument_list|(
operator|(
name|ObjectMapper
operator|)
name|newLast
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
comment|/** Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper. */
DECL|method|createExistingMapperUpdate
specifier|private
specifier|static
name|ObjectMapper
name|createExistingMapperUpdate
parameter_list|(
name|List
argument_list|<
name|ObjectMapper
argument_list|>
name|parentMappers
parameter_list|,
name|String
index|[]
name|nameParts
parameter_list|,
name|int
name|i
parameter_list|,
name|DocumentMapper
name|docMapper
parameter_list|,
name|Mapper
name|newMapper
parameter_list|)
block|{
name|String
name|updateParentName
init|=
name|nameParts
index|[
name|i
index|]
decl_stmt|;
specifier|final
name|ObjectMapper
name|lastParent
init|=
name|parentMappers
operator|.
name|get
argument_list|(
name|parentMappers
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|parentMappers
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|// only prefix with parent mapper if the parent mapper isn't the root (which has a fake name)
name|updateParentName
operator|=
name|lastParent
operator|.
name|name
argument_list|()
operator|+
literal|'.'
operator|+
name|nameParts
index|[
name|i
index|]
expr_stmt|;
block|}
name|ObjectMapper
name|updateParent
init|=
name|docMapper
operator|.
name|objectMappers
argument_list|()
operator|.
name|get
argument_list|(
name|updateParentName
argument_list|)
decl_stmt|;
assert|assert
name|updateParent
operator|!=
literal|null
operator|:
name|updateParentName
operator|+
literal|" doesn't exist"
assert|;
return|return
name|createUpdate
argument_list|(
name|updateParent
argument_list|,
name|nameParts
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|newMapper
argument_list|)
return|;
block|}
comment|/** Build an update for the parent which will contain the given mapper and any intermediate fields. */
DECL|method|createUpdate
specifier|private
specifier|static
name|ObjectMapper
name|createUpdate
parameter_list|(
name|ObjectMapper
name|parent
parameter_list|,
name|String
index|[]
name|nameParts
parameter_list|,
name|int
name|i
parameter_list|,
name|Mapper
name|mapper
parameter_list|)
block|{
name|List
argument_list|<
name|ObjectMapper
argument_list|>
name|parentMappers
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|ObjectMapper
name|previousIntermediate
init|=
name|parent
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|nameParts
operator|.
name|length
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|Mapper
name|intermediate
init|=
name|previousIntermediate
operator|.
name|getMapper
argument_list|(
name|nameParts
index|[
name|i
index|]
argument_list|)
decl_stmt|;
assert|assert
name|intermediate
operator|!=
literal|null
operator|:
literal|"Field "
operator|+
name|previousIntermediate
operator|.
name|name
argument_list|()
operator|+
literal|" does not have a subfield "
operator|+
name|nameParts
index|[
name|i
index|]
assert|;
assert|assert
name|intermediate
operator|instanceof
name|ObjectMapper
assert|;
name|parentMappers
operator|.
name|add
argument_list|(
operator|(
name|ObjectMapper
operator|)
name|intermediate
argument_list|)
expr_stmt|;
name|previousIntermediate
operator|=
operator|(
name|ObjectMapper
operator|)
name|intermediate
expr_stmt|;
block|}
if|if
condition|(
name|parentMappers
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// add the new mapper to the stack, and pop down to the original parent level
name|addToLastMapper
argument_list|(
name|parentMappers
argument_list|,
name|mapper
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|popMappers
argument_list|(
name|parentMappers
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|mapper
operator|=
name|parentMappers
operator|.
name|get
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|parent
operator|.
name|mappingUpdate
argument_list|(
name|mapper
argument_list|)
return|;
block|}
DECL|method|parseObjectOrNested
specifier|static
name|void
name|parseObjectOrNested
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|,
name|boolean
name|atRoot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mapper
operator|.
name|isEnabled
argument_list|()
operator|==
literal|false
condition|)
block|{
name|context
operator|.
name|parser
argument_list|()
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
return|return;
block|}
name|XContentParser
name|parser
init|=
name|context
operator|.
name|parser
argument_list|()
decl_stmt|;
name|String
name|currentFieldName
init|=
name|parser
operator|.
name|currentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|atRoot
operator|&&
name|MapperService
operator|.
name|isMetadataField
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Field ["
operator|+
name|currentFieldName
operator|+
literal|"] is a metadata field and cannot be added inside a document. Use the index API request parameters."
argument_list|)
throw|;
block|}
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|currentToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
comment|// the object is null ("obj1" : null), simply bail
return|return;
block|}
if|if
condition|(
name|token
operator|.
name|isValue
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping for ["
operator|+
name|mapper
operator|.
name|name
argument_list|()
operator|+
literal|"] tried to parse field ["
operator|+
name|currentFieldName
operator|+
literal|"] as object, but found a concrete value"
argument_list|)
throw|;
block|}
name|ObjectMapper
operator|.
name|Nested
name|nested
init|=
name|mapper
operator|.
name|nested
argument_list|()
decl_stmt|;
if|if
condition|(
name|nested
operator|.
name|isNested
argument_list|()
condition|)
block|{
name|context
operator|=
name|nestedContext
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
comment|// if we are at the end of the previous object, advance
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
comment|// if we are just starting an OBJECT, advance, this is the object we are parsing, we need the name first
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
name|ObjectMapper
name|update
init|=
literal|null
decl_stmt|;
name|innerParseObject
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|parser
argument_list|,
name|currentFieldName
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|// restore the enable path flag
if|if
condition|(
name|nested
operator|.
name|isNested
argument_list|()
condition|)
block|{
name|nested
argument_list|(
name|context
argument_list|,
name|nested
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|innerParseObject
specifier|private
specifier|static
name|void
name|innerParseObject
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|,
name|XContentParser
name|parser
parameter_list|,
name|String
name|currentFieldName
parameter_list|,
name|XContentParser
operator|.
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
while|while
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
name|parseObject
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
name|parseArray
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
name|parseNullValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping for ["
operator|+
name|mapper
operator|.
name|name
argument_list|()
operator|+
literal|"] tried to parse field ["
operator|+
name|currentFieldName
operator|+
literal|"] as object, but got EOF, has a concrete value been provided to it?"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|isValue
argument_list|()
condition|)
block|{
name|parseValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|nested
specifier|private
specifier|static
name|void
name|nested
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
operator|.
name|Nested
name|nested
parameter_list|)
block|{
name|ParseContext
operator|.
name|Document
name|nestedDoc
init|=
name|context
operator|.
name|doc
argument_list|()
decl_stmt|;
name|ParseContext
operator|.
name|Document
name|parentDoc
init|=
name|nestedDoc
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|nested
operator|.
name|isIncludeInParent
argument_list|()
condition|)
block|{
name|addFields
argument_list|(
name|nestedDoc
argument_list|,
name|parentDoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nested
operator|.
name|isIncludeInRoot
argument_list|()
condition|)
block|{
name|ParseContext
operator|.
name|Document
name|rootDoc
init|=
name|context
operator|.
name|rootDoc
argument_list|()
decl_stmt|;
comment|// don't add it twice, if its included in parent, and we are handling the master doc...
if|if
condition|(
operator|!
name|nested
operator|.
name|isIncludeInParent
argument_list|()
operator|||
name|parentDoc
operator|!=
name|rootDoc
condition|)
block|{
name|addFields
argument_list|(
name|nestedDoc
argument_list|,
name|rootDoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|addFields
specifier|private
specifier|static
name|void
name|addFields
parameter_list|(
name|ParseContext
operator|.
name|Document
name|nestedDoc
parameter_list|,
name|ParseContext
operator|.
name|Document
name|rootDoc
parameter_list|)
block|{
for|for
control|(
name|IndexableField
name|field
range|:
name|nestedDoc
operator|.
name|getFields
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|field
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|)
operator|&&
operator|!
name|field
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|TypeFieldMapper
operator|.
name|NAME
argument_list|)
condition|)
block|{
name|rootDoc
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|nestedContext
specifier|private
specifier|static
name|ParseContext
name|nestedContext
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|)
block|{
name|context
operator|=
name|context
operator|.
name|createNestedContext
argument_list|(
name|mapper
operator|.
name|fullPath
argument_list|()
argument_list|)
expr_stmt|;
name|ParseContext
operator|.
name|Document
name|nestedDoc
init|=
name|context
operator|.
name|doc
argument_list|()
decl_stmt|;
name|ParseContext
operator|.
name|Document
name|parentDoc
init|=
name|nestedDoc
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|// pre add the uid field if possible (id was already provided)
name|IndexableField
name|uidField
init|=
name|parentDoc
operator|.
name|getField
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|uidField
operator|!=
literal|null
condition|)
block|{
comment|// we don't need to add it as a full uid field in nested docs, since we don't need versioning
comment|// we also rely on this for UidField#loadVersion
comment|// this is a deeply nested field
name|nestedDoc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|,
name|uidField
operator|.
name|stringValue
argument_list|()
argument_list|,
name|UidFieldMapper
operator|.
name|Defaults
operator|.
name|NESTED_FIELD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// the type of the nested doc starts with __, so we can identify that its a nested one in filters
comment|// note, we don't prefix it with the type of the doc since it allows us to execute a nested query
comment|// across types (for example, with similar nested objects)
name|nestedDoc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|TypeFieldMapper
operator|.
name|NAME
argument_list|,
name|mapper
operator|.
name|nestedTypePathAsString
argument_list|()
argument_list|,
name|TypeFieldMapper
operator|.
name|Defaults
operator|.
name|FIELD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|context
return|;
block|}
DECL|method|parseObjectOrField
specifier|private
specifier|static
name|void
name|parseObjectOrField
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|Mapper
name|mapper
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mapper
operator|instanceof
name|ObjectMapper
condition|)
block|{
name|parseObjectOrNested
argument_list|(
name|context
argument_list|,
operator|(
name|ObjectMapper
operator|)
name|mapper
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FieldMapper
name|fieldMapper
init|=
operator|(
name|FieldMapper
operator|)
name|mapper
decl_stmt|;
name|Mapper
name|update
init|=
name|fieldMapper
operator|.
name|parse
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|addDynamicMapper
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fieldMapper
operator|.
name|copyTo
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|parseCopyFields
argument_list|(
name|context
argument_list|,
name|fieldMapper
argument_list|,
name|fieldMapper
operator|.
name|copyTo
argument_list|()
operator|.
name|copyToFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseObject
specifier|private
specifier|static
name|ObjectMapper
name|parseObject
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|,
name|String
name|currentFieldName
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|currentFieldName
operator|!=
literal|null
assert|;
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
name|ObjectMapper
name|update
init|=
literal|null
decl_stmt|;
name|Mapper
name|objectMapper
init|=
name|mapper
operator|.
name|getMapper
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectMapper
operator|!=
literal|null
condition|)
block|{
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|objectMapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|mapper
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|mapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|currentFieldName
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|TRUE
condition|)
block|{
comment|// remove the current field name from path, since template search and the object builder add it as well...
name|context
operator|.
name|path
argument_list|()
operator|.
name|remove
argument_list|()
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"object"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|ObjectMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
operator|.
name|enabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// if this is a non root object, then explicitly set the dynamic behavior if set
if|if
condition|(
operator|!
operator|(
name|mapper
operator|instanceof
name|RootObjectMapper
operator|)
operator|&&
name|mapper
operator|.
name|dynamic
argument_list|()
operator|!=
name|ObjectMapper
operator|.
name|Defaults
operator|.
name|DYNAMIC
condition|)
block|{
operator|(
operator|(
name|ObjectMapper
operator|.
name|Builder
operator|)
name|builder
operator|)
operator|.
name|dynamic
argument_list|(
name|mapper
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|objectMapper
operator|=
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
expr_stmt|;
name|context
operator|.
name|addDynamicMapper
argument_list|(
name|objectMapper
argument_list|)
expr_stmt|;
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|objectMapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// not dynamic, read everything up to end object
name|context
operator|.
name|parser
argument_list|()
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
block|}
name|context
operator|.
name|path
argument_list|()
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|update
return|;
block|}
DECL|method|parseArray
specifier|private
specifier|static
name|void
name|parseArray
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|lastFieldName
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|arrayFieldName
init|=
name|lastFieldName
decl_stmt|;
name|Mapper
name|mapper
init|=
name|parentMapper
operator|.
name|getMapper
argument_list|(
name|lastFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
comment|// There is a concrete mapper for this field already. Need to check if the mapper
comment|// expects an array, if so we pass the context straight to the mapper and if not
comment|// we serialize the array components
if|if
condition|(
name|mapper
operator|instanceof
name|ArrayValueMapperParser
condition|)
block|{
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|parentMapper
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parentMapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|arrayFieldName
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|TRUE
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|arrayFieldName
argument_list|,
literal|"object"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
expr_stmt|;
return|return;
block|}
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|mapper
operator|=
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
expr_stmt|;
assert|assert
name|mapper
operator|!=
literal|null
assert|;
if|if
condition|(
name|mapper
operator|instanceof
name|ArrayValueMapperParser
condition|)
block|{
name|context
operator|.
name|addDynamicMapper
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|arrayFieldName
argument_list|)
expr_stmt|;
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// TODO: shouldn't this skip, not parse?
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseNonDynamicArray
specifier|private
specifier|static
name|void
name|parseNonDynamicArray
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|,
name|String
name|lastFieldName
parameter_list|,
name|String
name|arrayFieldName
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|context
operator|.
name|parser
argument_list|()
decl_stmt|;
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
name|parseObject
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
name|parseArray
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|lastFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
name|parseNullValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping for ["
operator|+
name|mapper
operator|.
name|name
argument_list|()
operator|+
literal|"] with array for ["
operator|+
name|arrayFieldName
operator|+
literal|"] tried to parse as array, but got EOF, is there a mismatch in types for the same field?"
argument_list|)
throw|;
block|}
else|else
block|{
name|parseValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseValue
specifier|private
specifier|static
name|void
name|parseValue
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|currentFieldName
parameter_list|,
name|XContentParser
operator|.
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentFieldName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping ["
operator|+
name|parentMapper
operator|.
name|name
argument_list|()
operator|+
literal|"] trying to serialize a value with no field associated with it, current value ["
operator|+
name|context
operator|.
name|parser
argument_list|()
operator|.
name|textOrNull
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|Mapper
name|mapper
init|=
name|parentMapper
operator|.
name|getMapper
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parseDynamicValue
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|currentFieldName
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseNullValue
specifier|private
specifier|static
name|void
name|parseNullValue
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|lastFieldName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we can only handle null values if we have mappings for them
name|Mapper
name|mapper
init|=
name|parentMapper
operator|.
name|getMapper
argument_list|(
name|lastFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
comment|// TODO: passing null to an object seems bogus?
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parentMapper
operator|.
name|dynamic
argument_list|()
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parentMapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|lastFieldName
argument_list|)
throw|;
block|}
block|}
DECL|method|createBuilderFromFieldType
specifier|private
specifier|static
name|Mapper
operator|.
name|Builder
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|createBuilderFromFieldType
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|MappedFieldType
name|fieldType
parameter_list|,
name|String
name|currentFieldName
parameter_list|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fieldType
operator|instanceof
name|StringFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"string"
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|StringFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|TextFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"text"
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|TextFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|KeywordFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"keyword"
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|KeywordFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|DateFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"date"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DateFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|.
name|numericType
argument_list|()
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|fieldType
operator|.
name|numericType
argument_list|()
condition|)
block|{
case|case
name|LONG
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|LongFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DOUBLE
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DoubleFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INT
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"integer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|IntegerFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|FloatFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected numeric type "
operator|+
name|fieldType
operator|.
name|numericType
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|builder
return|;
block|}
DECL|method|createBuilderFromDynamicValue
specifier|private
specifier|static
name|Mapper
operator|.
name|Builder
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|createBuilderFromDynamicValue
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|XContentParser
operator|.
name|Token
name|token
parameter_list|,
name|String
name|currentFieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_STRING
condition|)
block|{
comment|// do a quick test to see if its fits a dynamic template, if so, use it.
comment|// we need to do it here so we can handle things like attachment templates, where calling
comment|// text (to see if its a date) causes the binary value to be cleared
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"text"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|!=
literal|null
condition|)
block|{
return|return
name|builder
return|;
block|}
block|}
if|if
condition|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dateDetection
argument_list|()
condition|)
block|{
name|String
name|text
init|=
name|context
operator|.
name|parser
argument_list|()
operator|.
name|text
argument_list|()
decl_stmt|;
comment|// a safe check since "1" gets parsed as well
if|if
condition|(
name|Strings
operator|.
name|countOccurrencesOf
argument_list|(
name|text
argument_list|,
literal|":"
argument_list|)
operator|>
literal|1
operator|||
name|Strings
operator|.
name|countOccurrencesOf
argument_list|(
name|text
argument_list|,
literal|"-"
argument_list|)
operator|>
literal|1
operator|||
name|Strings
operator|.
name|countOccurrencesOf
argument_list|(
name|text
argument_list|,
literal|"/"
argument_list|)
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|FormatDateTimeFormatter
name|dateTimeFormatter
range|:
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamicDateTimeFormatters
argument_list|()
control|)
block|{
try|try
block|{
name|dateTimeFormatter
operator|.
name|parser
argument_list|()
operator|.
name|parseMillis
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"date"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DateFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
operator|.
name|dateTimeFormatter
argument_list|(
name|dateTimeFormatter
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// failure to parse this, continue
block|}
block|}
block|}
block|}
if|if
condition|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|numericDetection
argument_list|()
condition|)
block|{
name|String
name|text
init|=
name|context
operator|.
name|parser
argument_list|()
operator|.
name|text
argument_list|()
decl_stmt|;
try|try
block|{
name|Long
operator|.
name|parseLong
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"long"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|LongFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// not a long number
block|}
try|try
block|{
name|Double
operator|.
name|parseDouble
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"double"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DoubleFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// not a long number
block|}
block|}
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"string"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|TextFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NUMBER
condition|)
block|{
name|XContentParser
operator|.
name|NumberType
name|numberType
init|=
name|context
operator|.
name|parser
argument_list|()
operator|.
name|numberType
argument_list|()
decl_stmt|;
if|if
condition|(
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|INT
operator|||
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|LONG
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"long"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|LongFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
elseif|else
if|if
condition|(
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|FLOAT
operator|||
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|DOUBLE
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"double"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
comment|// no templates are defined, we use float by default instead of double
comment|// since this is much more space-efficient and should be enough most of
comment|// the time
name|builder
operator|=
operator|new
name|FloatFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_BOOLEAN
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"boolean"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|BooleanFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_EMBEDDED_OBJECT
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"binary"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|BinaryFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
else|else
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|!=
literal|null
condition|)
block|{
return|return
name|builder
return|;
block|}
block|}
comment|// TODO how do we identify dynamically that its a binary value?
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't handle serializing a dynamic type with content token ["
operator|+
name|token
operator|+
literal|"] and field name ["
operator|+
name|currentFieldName
operator|+
literal|"]"
argument_list|)
throw|;
block|}
DECL|method|parseDynamicValue
specifier|private
specifier|static
name|void
name|parseDynamicValue
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|currentFieldName
parameter_list|,
name|XContentParser
operator|.
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|parentMapper
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parentMapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|currentFieldName
argument_list|)
throw|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|FALSE
condition|)
block|{
return|return;
block|}
specifier|final
name|String
name|path
init|=
name|context
operator|.
name|path
argument_list|()
operator|.
name|pathAsText
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
specifier|final
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|MappedFieldType
name|existingFieldType
init|=
name|context
operator|.
name|mapperService
argument_list|()
operator|.
name|fullName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|existingFieldType
operator|!=
literal|null
condition|)
block|{
comment|// create a builder of the same type
name|builder
operator|=
name|createBuilderFromFieldType
argument_list|(
name|context
argument_list|,
name|existingFieldType
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
name|createBuilderFromDynamicValue
argument_list|(
name|context
argument_list|,
name|token
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
name|Mapper
name|mapper
init|=
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingFieldType
operator|!=
literal|null
condition|)
block|{
comment|// try to not introduce a conflict
name|mapper
operator|=
name|mapper
operator|.
name|updateFieldType
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|path
argument_list|,
name|existingFieldType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|addDynamicMapper
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
comment|/** Creates instances of the fields that the current field should be copied to */
DECL|method|parseCopyFields
specifier|private
specifier|static
name|void
name|parseCopyFields
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|copyToFields
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|context
operator|.
name|isWithinCopyTo
argument_list|()
operator|&&
name|copyToFields
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|context
operator|=
name|context
operator|.
name|createCopyToContext
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|field
range|:
name|copyToFields
control|)
block|{
comment|// In case of a hierarchy of nested documents, we need to figure out
comment|// which document the field should go to
name|ParseContext
operator|.
name|Document
name|targetDoc
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ParseContext
operator|.
name|Document
name|doc
init|=
name|context
operator|.
name|doc
argument_list|()
init|;
name|doc
operator|!=
literal|null
condition|;
name|doc
operator|=
name|doc
operator|.
name|getParent
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
name|doc
operator|.
name|getPrefix
argument_list|()
argument_list|)
condition|)
block|{
name|targetDoc
operator|=
name|doc
expr_stmt|;
break|break;
block|}
block|}
assert|assert
name|targetDoc
operator|!=
literal|null
assert|;
specifier|final
name|ParseContext
name|copyToContext
decl_stmt|;
if|if
condition|(
name|targetDoc
operator|==
name|context
operator|.
name|doc
argument_list|()
condition|)
block|{
name|copyToContext
operator|=
name|context
expr_stmt|;
block|}
else|else
block|{
name|copyToContext
operator|=
name|context
operator|.
name|switchDoc
argument_list|(
name|targetDoc
argument_list|)
expr_stmt|;
block|}
name|parseCopy
argument_list|(
name|field
argument_list|,
name|copyToContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Creates an copy of the current field with given field name and boost */
DECL|method|parseCopy
specifier|private
specifier|static
name|void
name|parseCopy
parameter_list|(
name|String
name|field
parameter_list|,
name|ParseContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldMapper
name|fieldMapper
init|=
name|context
operator|.
name|docMapper
argument_list|()
operator|.
name|mappers
argument_list|()
operator|.
name|getMapper
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldMapper
operator|!=
literal|null
condition|)
block|{
name|fieldMapper
operator|.
name|parse
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The path of the dest field might be completely different from the current one so we need to reset it
name|context
operator|=
name|context
operator|.
name|overridePath
argument_list|(
operator|new
name|ContentPath
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|// TODO: why Strings.splitStringToArray instead of String.split?
specifier|final
name|String
index|[]
name|paths
init|=
name|Strings
operator|.
name|splitStringToArray
argument_list|(
name|field
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
specifier|final
name|String
name|fieldName
init|=
name|paths
index|[
name|paths
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|ObjectMapper
name|mapper
init|=
name|context
operator|.
name|root
argument_list|()
decl_stmt|;
name|ObjectMapper
index|[]
name|mappers
init|=
operator|new
name|ObjectMapper
index|[
name|paths
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|ObjectMapper
name|parent
init|=
name|context
operator|.
name|root
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mapper
operator|=
name|context
operator|.
name|docMapper
argument_list|()
operator|.
name|objectMappers
argument_list|()
operator|.
name|get
argument_list|(
name|context
operator|.
name|path
argument_list|()
operator|.
name|pathAsText
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapper
operator|==
literal|null
condition|)
block|{
comment|// One mapping is missing, check if we are allowed to create a dynamic one.
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|parent
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dynamic
condition|)
block|{
case|case
name|STRICT
case|:
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parent
operator|.
name|fullPath
argument_list|()
argument_list|,
name|paths
index|[
name|i
index|]
argument_list|)
throw|;
case|case
name|TRUE
case|:
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|paths
index|[
name|i
index|]
argument_list|,
literal|"object"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
comment|// if this is a non root object, then explicitly set the dynamic behavior if set
if|if
condition|(
operator|!
operator|(
name|parent
operator|instanceof
name|RootObjectMapper
operator|)
operator|&&
name|parent
operator|.
name|dynamic
argument_list|()
operator|!=
name|ObjectMapper
operator|.
name|Defaults
operator|.
name|DYNAMIC
condition|)
block|{
operator|(
operator|(
name|ObjectMapper
operator|.
name|Builder
operator|)
name|builder
operator|)
operator|.
name|dynamic
argument_list|(
name|parent
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|=
operator|new
name|ObjectMapper
operator|.
name|Builder
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
operator|.
name|enabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|mapper
operator|=
operator|(
name|ObjectMapper
operator|)
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapper
operator|.
name|nested
argument_list|()
operator|!=
name|ObjectMapper
operator|.
name|Nested
operator|.
name|NO
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"It is forbidden to create dynamic nested objects (["
operator|+
name|context
operator|.
name|path
argument_list|()
operator|.
name|pathAsText
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
operator|+
literal|"]) through `copy_to`"
argument_list|)
throw|;
block|}
name|context
operator|.
name|addDynamicMapper
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
break|break;
case|case
name|FALSE
case|:
comment|// Maybe we should log something to tell the user that the copy_to is ignored in this case.
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected dynamic type "
operator|+
name|dynamic
argument_list|)
throw|;
block|}
block|}
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mappers
index|[
name|i
index|]
operator|=
name|mapper
expr_stmt|;
name|parent
operator|=
name|mapper
expr_stmt|;
block|}
block|}
name|parseDynamicValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|fieldName
argument_list|,
name|context
operator|.
name|parser
argument_list|()
operator|.
name|currentToken
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|dynamicOrDefault
specifier|private
specifier|static
name|ObjectMapper
operator|.
name|Dynamic
name|dynamicOrDefault
parameter_list|(
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
parameter_list|)
block|{
return|return
name|dynamic
operator|==
literal|null
condition|?
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|TRUE
else|:
name|dynamic
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|cache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

