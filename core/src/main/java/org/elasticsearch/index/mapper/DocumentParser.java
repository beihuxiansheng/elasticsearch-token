begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.mapper
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexableField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|CloseableThreadLocal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|joda
operator|.
name|FormatDateTimeFormatter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|BinaryFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|BooleanFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|DateFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|DateFieldMapper
operator|.
name|DateFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|DoubleFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|FloatFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|IntegerFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|KeywordFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|KeywordFieldMapper
operator|.
name|KeywordFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|LongFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|StringFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|StringFieldMapper
operator|.
name|StringFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|TextFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|core
operator|.
name|TextFieldMapper
operator|.
name|TextFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|internal
operator|.
name|TypeFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|internal
operator|.
name|UidFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|object
operator|.
name|ArrayValueMapperParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|object
operator|.
name|ObjectMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|object
operator|.
name|RootObjectMapper
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/** A parser for documents, given mappings from a DocumentMapper */
end_comment

begin_class
DECL|class|DocumentParser
class|class
name|DocumentParser
implements|implements
name|Closeable
block|{
DECL|field|cache
specifier|private
name|CloseableThreadLocal
argument_list|<
name|ParseContext
operator|.
name|InternalParseContext
argument_list|>
name|cache
init|=
operator|new
name|CloseableThreadLocal
argument_list|<
name|ParseContext
operator|.
name|InternalParseContext
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|ParseContext
operator|.
name|InternalParseContext
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|ParseContext
operator|.
name|InternalParseContext
argument_list|(
name|indexSettings
operator|.
name|getSettings
argument_list|()
argument_list|,
name|docMapperParser
argument_list|,
name|docMapper
argument_list|,
operator|new
name|ContentPath
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
block|}
block|}
decl_stmt|;
DECL|field|indexSettings
specifier|private
specifier|final
name|IndexSettings
name|indexSettings
decl_stmt|;
DECL|field|docMapperParser
specifier|private
specifier|final
name|DocumentMapperParser
name|docMapperParser
decl_stmt|;
DECL|field|docMapper
specifier|private
specifier|final
name|DocumentMapper
name|docMapper
decl_stmt|;
DECL|method|DocumentParser
specifier|public
name|DocumentParser
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|,
name|DocumentMapperParser
name|docMapperParser
parameter_list|,
name|DocumentMapper
name|docMapper
parameter_list|)
block|{
name|this
operator|.
name|indexSettings
operator|=
name|indexSettings
expr_stmt|;
name|this
operator|.
name|docMapperParser
operator|=
name|docMapperParser
expr_stmt|;
name|this
operator|.
name|docMapper
operator|=
name|docMapper
expr_stmt|;
block|}
DECL|method|parseDocument
specifier|final
name|ParsedDocument
name|parseDocument
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
throws|throws
name|MapperParsingException
block|{
name|validateType
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|source
operator|.
name|type
argument_list|(
name|docMapper
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|Mapping
name|mapping
init|=
name|docMapper
operator|.
name|mapping
argument_list|()
decl_stmt|;
specifier|final
name|ParseContext
operator|.
name|InternalParseContext
name|context
init|=
name|cache
operator|.
name|get
argument_list|()
decl_stmt|;
name|XContentParser
name|parser
init|=
literal|null
decl_stmt|;
try|try
block|{
name|parser
operator|=
name|parser
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|context
operator|.
name|reset
argument_list|(
name|parser
argument_list|,
operator|new
name|ParseContext
operator|.
name|Document
argument_list|()
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|validateStart
argument_list|(
name|parser
argument_list|)
expr_stmt|;
name|internalParseDocument
argument_list|(
name|mapping
argument_list|,
name|context
argument_list|,
name|parser
argument_list|)
expr_stmt|;
name|validateEnd
argument_list|(
name|source
argument_list|,
name|parser
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
throw|throw
name|wrapInMapperParsingException
argument_list|(
name|source
argument_list|,
name|t
argument_list|)
throw|;
block|}
finally|finally
block|{
comment|// only close the parser when its not provided externally
if|if
condition|(
name|internalParser
argument_list|(
name|source
argument_list|,
name|parser
argument_list|)
condition|)
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
name|reverseOrder
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|applyDocBoost
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|ParsedDocument
name|doc
init|=
name|parsedDocument
argument_list|(
name|source
argument_list|,
name|context
argument_list|,
name|update
argument_list|(
name|context
argument_list|,
name|mapping
argument_list|)
argument_list|)
decl_stmt|;
comment|// reset the context to free up memory
name|context
operator|.
name|reset
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
return|return
name|doc
return|;
block|}
DECL|method|internalParseDocument
specifier|private
specifier|static
name|void
name|internalParseDocument
parameter_list|(
name|Mapping
name|mapping
parameter_list|,
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|emptyDoc
init|=
name|isEmptyDoc
argument_list|(
name|mapping
argument_list|,
name|parser
argument_list|)
decl_stmt|;
for|for
control|(
name|MetadataFieldMapper
name|metadataMapper
range|:
name|mapping
operator|.
name|metadataMappers
control|)
block|{
name|metadataMapper
operator|.
name|preParse
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mapping
operator|.
name|root
operator|.
name|isEnabled
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// entire type is disabled
name|parser
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|emptyDoc
operator|==
literal|false
condition|)
block|{
name|Mapper
name|update
init|=
name|parseObject
argument_list|(
name|context
argument_list|,
name|mapping
operator|.
name|root
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
operator|!=
literal|null
condition|)
block|{
name|context
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|MetadataFieldMapper
name|metadataMapper
range|:
name|mapping
operator|.
name|metadataMappers
control|)
block|{
name|metadataMapper
operator|.
name|postParse
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|validateType
specifier|private
name|void
name|validateType
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
block|{
if|if
condition|(
name|docMapper
operator|.
name|type
argument_list|()
operator|.
name|equals
argument_list|(
name|MapperService
operator|.
name|DEFAULT_MAPPING
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"It is forbidden to index into the default mapping ["
operator|+
name|MapperService
operator|.
name|DEFAULT_MAPPING
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|source
operator|.
name|type
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|source
operator|.
name|type
argument_list|()
operator|.
name|equals
argument_list|(
name|docMapper
operator|.
name|type
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Type mismatch, provide type ["
operator|+
name|source
operator|.
name|type
argument_list|()
operator|+
literal|"] but mapper is of type ["
operator|+
name|docMapper
operator|.
name|type
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
DECL|method|parser
specifier|private
specifier|static
name|XContentParser
name|parser
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|source
operator|.
name|parser
argument_list|()
operator|==
literal|null
condition|?
name|XContentHelper
operator|.
name|createParser
argument_list|(
name|source
operator|.
name|source
argument_list|()
argument_list|)
else|:
name|source
operator|.
name|parser
argument_list|()
return|;
block|}
DECL|method|internalParser
specifier|private
specifier|static
name|boolean
name|internalParser
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
block|{
return|return
name|source
operator|.
name|parser
argument_list|()
operator|==
literal|null
operator|&&
name|parser
operator|!=
literal|null
return|;
block|}
DECL|method|validateStart
specifier|private
specifier|static
name|void
name|validateStart
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
comment|// will result in START_OBJECT
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Malformed content, must start with an object"
argument_list|)
throw|;
block|}
block|}
DECL|method|validateEnd
specifier|private
specifier|static
name|void
name|validateEnd
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
comment|// only check for end of tokens if we created the parser here
if|if
condition|(
name|internalParser
argument_list|(
name|source
argument_list|,
name|parser
argument_list|)
condition|)
block|{
comment|// try to parse the next token, this should be null if the object is ended properly
comment|// but will throw a JSON exception if the extra tokens is not valid JSON (this will be handled by the catch)
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed content, found extra data after parsing: "
operator|+
name|token
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|isEmptyDoc
specifier|private
specifier|static
name|boolean
name|isEmptyDoc
parameter_list|(
name|Mapping
name|mapping
parameter_list|,
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mapping
operator|.
name|root
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
specifier|final
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
comment|// empty doc, we can handle it...
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Malformed content, after first object, either the type field or the actual properties should exist"
argument_list|)
throw|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|reverseOrder
specifier|private
specifier|static
name|void
name|reverseOrder
parameter_list|(
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|)
block|{
comment|// reverse the order of docs for nested docs support, parent should be last
if|if
condition|(
name|context
operator|.
name|docs
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Collections
operator|.
name|reverse
argument_list|(
name|context
operator|.
name|docs
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyDocBoost
specifier|private
specifier|static
name|void
name|applyDocBoost
parameter_list|(
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|)
block|{
comment|// apply doc boost
if|if
condition|(
name|context
operator|.
name|docBoost
argument_list|()
operator|!=
literal|1.0f
condition|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|encounteredFields
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ParseContext
operator|.
name|Document
name|doc
range|:
name|context
operator|.
name|docs
argument_list|()
control|)
block|{
name|encounteredFields
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|IndexableField
name|field
range|:
name|doc
control|)
block|{
if|if
condition|(
name|field
operator|.
name|fieldType
argument_list|()
operator|.
name|indexOptions
argument_list|()
operator|!=
name|IndexOptions
operator|.
name|NONE
operator|&&
operator|!
name|field
operator|.
name|fieldType
argument_list|()
operator|.
name|omitNorms
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|encounteredFields
operator|.
name|contains
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
condition|)
block|{
operator|(
operator|(
name|Field
operator|)
name|field
operator|)
operator|.
name|setBoost
argument_list|(
name|context
operator|.
name|docBoost
argument_list|()
operator|*
name|field
operator|.
name|boost
argument_list|()
argument_list|)
expr_stmt|;
name|encounteredFields
operator|.
name|add
argument_list|(
name|field
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|parsedDocument
specifier|private
specifier|static
name|ParsedDocument
name|parsedDocument
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|,
name|Mapping
name|update
parameter_list|)
block|{
return|return
operator|new
name|ParsedDocument
argument_list|(
name|context
operator|.
name|uid
argument_list|()
argument_list|,
name|context
operator|.
name|version
argument_list|()
argument_list|,
name|context
operator|.
name|id
argument_list|()
argument_list|,
name|context
operator|.
name|type
argument_list|()
argument_list|,
name|source
operator|.
name|routing
argument_list|()
argument_list|,
name|source
operator|.
name|timestamp
argument_list|()
argument_list|,
name|source
operator|.
name|ttl
argument_list|()
argument_list|,
name|context
operator|.
name|docs
argument_list|()
argument_list|,
name|context
operator|.
name|source
argument_list|()
argument_list|,
name|update
argument_list|)
operator|.
name|parent
argument_list|(
name|source
operator|.
name|parent
argument_list|()
argument_list|)
return|;
block|}
DECL|method|update
specifier|private
specifier|static
name|Mapping
name|update
parameter_list|(
name|ParseContext
operator|.
name|InternalParseContext
name|context
parameter_list|,
name|Mapping
name|mapping
parameter_list|)
block|{
name|Mapper
name|rootDynamicUpdate
init|=
name|context
operator|.
name|dynamicMappingsUpdate
argument_list|()
decl_stmt|;
return|return
name|rootDynamicUpdate
operator|!=
literal|null
condition|?
name|mapping
operator|.
name|mappingUpdate
argument_list|(
name|rootDynamicUpdate
argument_list|)
else|:
literal|null
return|;
block|}
DECL|method|wrapInMapperParsingException
specifier|private
specifier|static
name|MapperParsingException
name|wrapInMapperParsingException
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
comment|// if its already a mapper parsing exception, no need to wrap it...
if|if
condition|(
name|e
operator|instanceof
name|MapperParsingException
condition|)
block|{
return|return
operator|(
name|MapperParsingException
operator|)
name|e
return|;
block|}
comment|// Throw a more meaningful message if the document is empty.
if|if
condition|(
name|source
operator|.
name|source
argument_list|()
operator|!=
literal|null
operator|&&
name|source
operator|.
name|source
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
operator|new
name|MapperParsingException
argument_list|(
literal|"failed to parse, document is empty"
argument_list|)
return|;
block|}
return|return
operator|new
name|MapperParsingException
argument_list|(
literal|"failed to parse"
argument_list|,
name|e
argument_list|)
return|;
block|}
DECL|method|parseObject
specifier|static
name|ObjectMapper
name|parseObject
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|,
name|boolean
name|atRoot
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mapper
operator|.
name|isEnabled
argument_list|()
operator|==
literal|false
condition|)
block|{
name|context
operator|.
name|parser
argument_list|()
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
name|XContentParser
name|parser
init|=
name|context
operator|.
name|parser
argument_list|()
decl_stmt|;
name|String
name|currentFieldName
init|=
name|parser
operator|.
name|currentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|atRoot
operator|&&
name|MapperService
operator|.
name|isMetadataField
argument_list|(
name|currentFieldName
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"Field ["
operator|+
name|currentFieldName
operator|+
literal|"] is a metadata field and cannot be added inside a document. Use the index API request parameters."
argument_list|)
throw|;
block|}
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|currentToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
comment|// the object is null ("obj1" : null), simply bail
return|return
literal|null
return|;
block|}
if|if
condition|(
name|token
operator|.
name|isValue
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping for ["
operator|+
name|mapper
operator|.
name|name
argument_list|()
operator|+
literal|"] tried to parse field ["
operator|+
name|currentFieldName
operator|+
literal|"] as object, but found a concrete value"
argument_list|)
throw|;
block|}
name|ObjectMapper
operator|.
name|Nested
name|nested
init|=
name|mapper
operator|.
name|nested
argument_list|()
decl_stmt|;
if|if
condition|(
name|nested
operator|.
name|isNested
argument_list|()
condition|)
block|{
name|context
operator|=
name|context
operator|.
name|createNestedContext
argument_list|(
name|mapper
operator|.
name|fullPath
argument_list|()
argument_list|)
expr_stmt|;
name|ParseContext
operator|.
name|Document
name|nestedDoc
init|=
name|context
operator|.
name|doc
argument_list|()
decl_stmt|;
name|ParseContext
operator|.
name|Document
name|parentDoc
init|=
name|nestedDoc
operator|.
name|getParent
argument_list|()
decl_stmt|;
comment|// pre add the uid field if possible (id was already provided)
name|IndexableField
name|uidField
init|=
name|parentDoc
operator|.
name|getField
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|uidField
operator|!=
literal|null
condition|)
block|{
comment|// we don't need to add it as a full uid field in nested docs, since we don't need versioning
comment|// we also rely on this for UidField#loadVersion
comment|// this is a deeply nested field
name|nestedDoc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|,
name|uidField
operator|.
name|stringValue
argument_list|()
argument_list|,
name|UidFieldMapper
operator|.
name|Defaults
operator|.
name|NESTED_FIELD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// the type of the nested doc starts with __, so we can identify that its a nested one in filters
comment|// note, we don't prefix it with the type of the doc since it allows us to execute a nested query
comment|// across types (for example, with similar nested objects)
name|nestedDoc
operator|.
name|add
argument_list|(
operator|new
name|Field
argument_list|(
name|TypeFieldMapper
operator|.
name|NAME
argument_list|,
name|mapper
operator|.
name|nestedTypePathAsString
argument_list|()
argument_list|,
name|TypeFieldMapper
operator|.
name|Defaults
operator|.
name|FIELD_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// if we are at the end of the previous object, advance
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
comment|// if we are just starting an OBJECT, advance, this is the object we are parsing, we need the name first
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
name|ObjectMapper
name|update
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
name|ObjectMapper
name|newUpdate
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
name|newUpdate
operator|=
name|parseObject
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
name|newUpdate
operator|=
name|parseArray
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|currentFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
name|parseNullValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping for ["
operator|+
name|mapper
operator|.
name|name
argument_list|()
operator|+
literal|"] tried to parse field ["
operator|+
name|currentFieldName
operator|+
literal|"] as object, but got EOF, has a concrete value been provided to it?"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|isValue
argument_list|()
condition|)
block|{
name|newUpdate
operator|=
name|parseValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|currentFieldName
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|newUpdate
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|update
operator|==
literal|null
condition|)
block|{
name|update
operator|=
name|newUpdate
expr_stmt|;
block|}
else|else
block|{
name|update
operator|=
name|update
operator|.
name|merge
argument_list|(
name|newUpdate
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// restore the enable path flag
if|if
condition|(
name|nested
operator|.
name|isNested
argument_list|()
condition|)
block|{
name|ParseContext
operator|.
name|Document
name|nestedDoc
init|=
name|context
operator|.
name|doc
argument_list|()
decl_stmt|;
name|ParseContext
operator|.
name|Document
name|parentDoc
init|=
name|nestedDoc
operator|.
name|getParent
argument_list|()
decl_stmt|;
if|if
condition|(
name|nested
operator|.
name|isIncludeInParent
argument_list|()
condition|)
block|{
for|for
control|(
name|IndexableField
name|field
range|:
name|nestedDoc
operator|.
name|getFields
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|)
operator|||
name|field
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|TypeFieldMapper
operator|.
name|NAME
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|parentDoc
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nested
operator|.
name|isIncludeInRoot
argument_list|()
condition|)
block|{
name|ParseContext
operator|.
name|Document
name|rootDoc
init|=
name|context
operator|.
name|rootDoc
argument_list|()
decl_stmt|;
comment|// don't add it twice, if its included in parent, and we are handling the master doc...
if|if
condition|(
operator|!
name|nested
operator|.
name|isIncludeInParent
argument_list|()
operator|||
name|parentDoc
operator|!=
name|rootDoc
condition|)
block|{
for|for
control|(
name|IndexableField
name|field
range|:
name|nestedDoc
operator|.
name|getFields
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|UidFieldMapper
operator|.
name|NAME
argument_list|)
operator|||
name|field
operator|.
name|name
argument_list|()
operator|.
name|equals
argument_list|(
name|TypeFieldMapper
operator|.
name|NAME
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|rootDoc
operator|.
name|add
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|update
return|;
block|}
DECL|method|parseObjectOrField
specifier|private
specifier|static
name|Mapper
name|parseObjectOrField
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|Mapper
name|mapper
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|mapper
operator|instanceof
name|ObjectMapper
condition|)
block|{
return|return
name|parseObject
argument_list|(
name|context
argument_list|,
operator|(
name|ObjectMapper
operator|)
name|mapper
argument_list|,
literal|false
argument_list|)
return|;
block|}
else|else
block|{
name|FieldMapper
name|fieldMapper
init|=
operator|(
name|FieldMapper
operator|)
name|mapper
decl_stmt|;
name|Mapper
name|update
init|=
name|fieldMapper
operator|.
name|parse
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldMapper
operator|.
name|copyTo
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|parseCopyFields
argument_list|(
name|context
argument_list|,
name|fieldMapper
argument_list|,
name|fieldMapper
operator|.
name|copyTo
argument_list|()
operator|.
name|copyToFields
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|update
return|;
block|}
block|}
DECL|method|parseObject
specifier|private
specifier|static
name|ObjectMapper
name|parseObject
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|,
name|String
name|currentFieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentFieldName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping ["
operator|+
name|mapper
operator|.
name|name
argument_list|()
operator|+
literal|"] trying to serialize an object with no field associated with it, current value ["
operator|+
name|context
operator|.
name|parser
argument_list|()
operator|.
name|textOrNull
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
name|ObjectMapper
name|update
init|=
literal|null
decl_stmt|;
name|Mapper
name|objectMapper
init|=
name|mapper
operator|.
name|getMapper
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectMapper
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Mapper
name|subUpdate
init|=
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|objectMapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|subUpdate
operator|!=
literal|null
condition|)
block|{
comment|// propagate mapping update
name|update
operator|=
name|mapper
operator|.
name|mappingUpdate
argument_list|(
name|subUpdate
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|mapper
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|mapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|currentFieldName
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|TRUE
condition|)
block|{
comment|// remove the current field name from path, since template search and the object builder add it as well...
name|context
operator|.
name|path
argument_list|()
operator|.
name|remove
argument_list|()
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"object"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|ObjectMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
operator|.
name|enabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
comment|// if this is a non root object, then explicitly set the dynamic behavior if set
if|if
condition|(
operator|!
operator|(
name|mapper
operator|instanceof
name|RootObjectMapper
operator|)
operator|&&
name|mapper
operator|.
name|dynamic
argument_list|()
operator|!=
name|ObjectMapper
operator|.
name|Defaults
operator|.
name|DYNAMIC
condition|)
block|{
operator|(
operator|(
name|ObjectMapper
operator|.
name|Builder
operator|)
name|builder
operator|)
operator|.
name|dynamic
argument_list|(
name|mapper
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|objectMapper
operator|=
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
expr_stmt|;
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
name|update
operator|=
name|mapper
operator|.
name|mappingUpdate
argument_list|(
name|parseAndMergeUpdate
argument_list|(
name|objectMapper
argument_list|,
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// not dynamic, read everything up to end object
name|context
operator|.
name|parser
argument_list|()
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
block|}
name|context
operator|.
name|path
argument_list|()
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
name|update
return|;
block|}
DECL|method|parseArray
specifier|private
specifier|static
name|ObjectMapper
name|parseArray
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|lastFieldName
parameter_list|)
throws|throws
name|IOException
block|{
name|String
name|arrayFieldName
init|=
name|lastFieldName
decl_stmt|;
name|Mapper
name|mapper
init|=
name|parentMapper
operator|.
name|getMapper
argument_list|(
name|lastFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
comment|// There is a concrete mapper for this field already. Need to check if the mapper
comment|// expects an array, if so we pass the context straight to the mapper and if not
comment|// we serialize the array components
if|if
condition|(
name|mapper
operator|instanceof
name|ArrayValueMapperParser
condition|)
block|{
specifier|final
name|Mapper
name|subUpdate
init|=
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|subUpdate
operator|!=
literal|null
condition|)
block|{
comment|// propagate the mapping update
return|return
name|parentMapper
operator|.
name|mappingUpdate
argument_list|(
name|subUpdate
argument_list|)
return|;
block|}
else|else
block|{
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
return|return
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|parentMapper
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parentMapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|arrayFieldName
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|TRUE
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|arrayFieldName
argument_list|,
literal|"object"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
return|return
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
return|;
block|}
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|mapper
operator|=
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
operator|&&
name|mapper
operator|instanceof
name|ArrayValueMapperParser
condition|)
block|{
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|arrayFieldName
argument_list|)
expr_stmt|;
name|mapper
operator|=
name|parseAndMergeUpdate
argument_list|(
name|mapper
argument_list|,
name|context
argument_list|)
expr_stmt|;
return|return
name|parentMapper
operator|.
name|mappingUpdate
argument_list|(
name|mapper
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
return|;
block|}
block|}
else|else
block|{
return|return
name|parseNonDynamicArray
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|lastFieldName
argument_list|,
name|arrayFieldName
argument_list|)
return|;
block|}
block|}
block|}
DECL|method|parseNonDynamicArray
specifier|private
specifier|static
name|ObjectMapper
name|parseNonDynamicArray
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|mapper
parameter_list|,
name|String
name|lastFieldName
parameter_list|,
name|String
name|arrayFieldName
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|context
operator|.
name|parser
argument_list|()
decl_stmt|;
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
return|return
name|parseObject
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
return|return
name|parseArray
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|lastFieldName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
name|parseNullValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping for ["
operator|+
name|mapper
operator|.
name|name
argument_list|()
operator|+
literal|"] with array for ["
operator|+
name|arrayFieldName
operator|+
literal|"] tried to parse as array, but got EOF, is there a mismatch in types for the same field?"
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|parseValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|lastFieldName
argument_list|,
name|token
argument_list|)
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|parseValue
specifier|private
specifier|static
name|ObjectMapper
name|parseValue
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|currentFieldName
parameter_list|,
name|XContentParser
operator|.
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|currentFieldName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"object mapping ["
operator|+
name|parentMapper
operator|.
name|name
argument_list|()
operator|+
literal|"] trying to serialize a value with no field associated with it, current value ["
operator|+
name|context
operator|.
name|parser
argument_list|()
operator|.
name|textOrNull
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|Mapper
name|mapper
init|=
name|parentMapper
operator|.
name|getMapper
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
name|Mapper
name|subUpdate
init|=
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|subUpdate
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|parentMapper
operator|.
name|mappingUpdate
argument_list|(
name|subUpdate
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|parseDynamicValue
argument_list|(
name|context
argument_list|,
name|parentMapper
argument_list|,
name|currentFieldName
argument_list|,
name|token
argument_list|)
return|;
block|}
block|}
DECL|method|parseNullValue
specifier|private
specifier|static
name|void
name|parseNullValue
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|lastFieldName
parameter_list|)
throws|throws
name|IOException
block|{
comment|// we can only handle null values if we have mappings for them
name|Mapper
name|mapper
init|=
name|parentMapper
operator|.
name|getMapper
argument_list|(
name|lastFieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
comment|// TODO: passing null to an object seems bogus?
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parentMapper
operator|.
name|dynamic
argument_list|()
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parentMapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|lastFieldName
argument_list|)
throw|;
block|}
block|}
DECL|method|createBuilderFromFieldType
specifier|private
specifier|static
name|Mapper
operator|.
name|Builder
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|createBuilderFromFieldType
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|MappedFieldType
name|fieldType
parameter_list|,
name|String
name|currentFieldName
parameter_list|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|fieldType
operator|instanceof
name|StringFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|StringFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|TextFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|TextFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|KeywordFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|KeywordFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|DateFieldType
condition|)
block|{
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"date"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DateFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|.
name|numericType
argument_list|()
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|fieldType
operator|.
name|numericType
argument_list|()
condition|)
block|{
case|case
name|LONG
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|LongFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DOUBLE
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DoubleFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INT
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"integer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|IntegerFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FLOAT
case|:
name|builder
operator|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|FloatFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected numeric type "
operator|+
name|fieldType
operator|.
name|numericType
argument_list|()
argument_list|)
throw|;
block|}
block|}
return|return
name|builder
return|;
block|}
DECL|method|createBuilderFromDynamicValue
specifier|private
specifier|static
name|Mapper
operator|.
name|Builder
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|createBuilderFromDynamicValue
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|XContentParser
operator|.
name|Token
name|token
parameter_list|,
name|String
name|currentFieldName
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_STRING
condition|)
block|{
comment|// do a quick test to see if its fits a dynamic template, if so, use it.
comment|// we need to do it here so we can handle things like attachment templates, where calling
comment|// text (to see if its a date) causes the binary value to be cleared
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"string"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|!=
literal|null
condition|)
block|{
return|return
name|builder
return|;
block|}
block|}
if|if
condition|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dateDetection
argument_list|()
condition|)
block|{
name|String
name|text
init|=
name|context
operator|.
name|parser
argument_list|()
operator|.
name|text
argument_list|()
decl_stmt|;
comment|// a safe check since "1" gets parsed as well
if|if
condition|(
name|Strings
operator|.
name|countOccurrencesOf
argument_list|(
name|text
argument_list|,
literal|":"
argument_list|)
operator|>
literal|1
operator|||
name|Strings
operator|.
name|countOccurrencesOf
argument_list|(
name|text
argument_list|,
literal|"-"
argument_list|)
operator|>
literal|1
operator|||
name|Strings
operator|.
name|countOccurrencesOf
argument_list|(
name|text
argument_list|,
literal|"/"
argument_list|)
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|FormatDateTimeFormatter
name|dateTimeFormatter
range|:
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamicDateTimeFormatters
argument_list|()
control|)
block|{
try|try
block|{
name|dateTimeFormatter
operator|.
name|parser
argument_list|()
operator|.
name|parseMillis
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"date"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DateFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
operator|.
name|dateTimeFormatter
argument_list|(
name|dateTimeFormatter
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// failure to parse this, continue
block|}
block|}
block|}
block|}
if|if
condition|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|numericDetection
argument_list|()
condition|)
block|{
name|String
name|text
init|=
name|context
operator|.
name|parser
argument_list|()
operator|.
name|text
argument_list|()
decl_stmt|;
try|try
block|{
name|Long
operator|.
name|parseLong
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"long"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|LongFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// not a long number
block|}
try|try
block|{
name|Double
operator|.
name|parseDouble
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"double"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|DoubleFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
comment|// not a long number
block|}
block|}
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"string"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|StringFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NUMBER
condition|)
block|{
name|XContentParser
operator|.
name|NumberType
name|numberType
init|=
name|context
operator|.
name|parser
argument_list|()
operator|.
name|numberType
argument_list|()
decl_stmt|;
if|if
condition|(
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|INT
operator|||
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|LONG
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"long"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|LongFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
elseif|else
if|if
condition|(
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|FLOAT
operator|||
name|numberType
operator|==
name|XContentParser
operator|.
name|NumberType
operator|.
name|DOUBLE
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"double"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
comment|// no templates are defined, we use float by default instead of double
comment|// since this is much more space-efficient and should be enough most of
comment|// the time
name|builder
operator|=
operator|new
name|FloatFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_BOOLEAN
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"boolean"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|BooleanFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_EMBEDDED_OBJECT
condition|)
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|"binary"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
operator|new
name|BinaryFieldMapper
operator|.
name|Builder
argument_list|(
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
else|else
block|{
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|currentFieldName
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|!=
literal|null
condition|)
block|{
return|return
name|builder
return|;
block|}
block|}
comment|// TODO how do we identify dynamically that its a binary value?
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't handle serializing a dynamic type with content token ["
operator|+
name|token
operator|+
literal|"] and field name ["
operator|+
name|currentFieldName
operator|+
literal|"]"
argument_list|)
throw|;
block|}
DECL|method|parseDynamicValue
specifier|private
specifier|static
name|ObjectMapper
name|parseDynamicValue
parameter_list|(
specifier|final
name|ParseContext
name|context
parameter_list|,
name|ObjectMapper
name|parentMapper
parameter_list|,
name|String
name|currentFieldName
parameter_list|,
name|XContentParser
operator|.
name|Token
name|token
parameter_list|)
throws|throws
name|IOException
block|{
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|parentMapper
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|STRICT
condition|)
block|{
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parentMapper
operator|.
name|fullPath
argument_list|()
argument_list|,
name|currentFieldName
argument_list|)
throw|;
block|}
if|if
condition|(
name|dynamic
operator|==
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|FALSE
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|String
name|path
init|=
name|context
operator|.
name|path
argument_list|()
operator|.
name|pathAsText
argument_list|(
name|currentFieldName
argument_list|)
decl_stmt|;
specifier|final
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|MappedFieldType
name|existingFieldType
init|=
name|context
operator|.
name|mapperService
argument_list|()
operator|.
name|fullName
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|Mapper
operator|.
name|Builder
name|builder
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|existingFieldType
operator|!=
literal|null
condition|)
block|{
comment|// create a builder of the same type
name|builder
operator|=
name|createBuilderFromFieldType
argument_list|(
name|context
argument_list|,
name|existingFieldType
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
name|builder
operator|=
name|createBuilderFromDynamicValue
argument_list|(
name|context
argument_list|,
name|token
argument_list|,
name|currentFieldName
argument_list|)
expr_stmt|;
block|}
name|Mapper
name|mapper
init|=
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
decl_stmt|;
if|if
condition|(
name|existingFieldType
operator|!=
literal|null
condition|)
block|{
comment|// try to not introduce a conflict
name|mapper
operator|=
name|mapper
operator|.
name|updateFieldType
argument_list|(
name|Collections
operator|.
name|singletonMap
argument_list|(
name|path
argument_list|,
name|existingFieldType
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mapper
operator|=
name|parseAndMergeUpdate
argument_list|(
name|mapper
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|ObjectMapper
name|update
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|mapper
operator|!=
literal|null
condition|)
block|{
name|update
operator|=
name|parentMapper
operator|.
name|mappingUpdate
argument_list|(
name|mapper
argument_list|)
expr_stmt|;
block|}
return|return
name|update
return|;
block|}
comment|/** Creates instances of the fields that the current field should be copied to */
DECL|method|parseCopyFields
specifier|private
specifier|static
name|void
name|parseCopyFields
parameter_list|(
name|ParseContext
name|context
parameter_list|,
name|FieldMapper
name|fieldMapper
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|copyToFields
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|context
operator|.
name|isWithinCopyTo
argument_list|()
operator|&&
name|copyToFields
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
name|context
operator|=
name|context
operator|.
name|createCopyToContext
argument_list|()
expr_stmt|;
for|for
control|(
name|String
name|field
range|:
name|copyToFields
control|)
block|{
comment|// In case of a hierarchy of nested documents, we need to figure out
comment|// which document the field should go to
name|ParseContext
operator|.
name|Document
name|targetDoc
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ParseContext
operator|.
name|Document
name|doc
init|=
name|context
operator|.
name|doc
argument_list|()
init|;
name|doc
operator|!=
literal|null
condition|;
name|doc
operator|=
name|doc
operator|.
name|getParent
argument_list|()
control|)
block|{
if|if
condition|(
name|field
operator|.
name|startsWith
argument_list|(
name|doc
operator|.
name|getPrefix
argument_list|()
argument_list|)
condition|)
block|{
name|targetDoc
operator|=
name|doc
expr_stmt|;
break|break;
block|}
block|}
assert|assert
name|targetDoc
operator|!=
literal|null
assert|;
specifier|final
name|ParseContext
name|copyToContext
decl_stmt|;
if|if
condition|(
name|targetDoc
operator|==
name|context
operator|.
name|doc
argument_list|()
condition|)
block|{
name|copyToContext
operator|=
name|context
expr_stmt|;
block|}
else|else
block|{
name|copyToContext
operator|=
name|context
operator|.
name|switchDoc
argument_list|(
name|targetDoc
argument_list|)
expr_stmt|;
block|}
name|parseCopy
argument_list|(
name|field
argument_list|,
name|copyToContext
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** Creates an copy of the current field with given field name and boost */
DECL|method|parseCopy
specifier|private
specifier|static
name|void
name|parseCopy
parameter_list|(
name|String
name|field
parameter_list|,
name|ParseContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|FieldMapper
name|fieldMapper
init|=
name|context
operator|.
name|docMapper
argument_list|()
operator|.
name|mappers
argument_list|()
operator|.
name|getMapper
argument_list|(
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldMapper
operator|!=
literal|null
condition|)
block|{
name|fieldMapper
operator|.
name|parse
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The path of the dest field might be completely different from the current one so we need to reset it
name|context
operator|=
name|context
operator|.
name|overridePath
argument_list|(
operator|new
name|ContentPath
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|String
index|[]
name|paths
init|=
name|Strings
operator|.
name|splitStringToArray
argument_list|(
name|field
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|String
name|fieldName
init|=
name|paths
index|[
name|paths
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
name|ObjectMapper
name|mapper
init|=
name|context
operator|.
name|root
argument_list|()
decl_stmt|;
name|ObjectMapper
index|[]
name|mappers
init|=
operator|new
name|ObjectMapper
index|[
name|paths
operator|.
name|length
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|paths
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|ObjectMapper
name|parent
init|=
name|context
operator|.
name|root
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|paths
operator|.
name|length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|mapper
operator|=
name|context
operator|.
name|docMapper
argument_list|()
operator|.
name|objectMappers
argument_list|()
operator|.
name|get
argument_list|(
name|context
operator|.
name|path
argument_list|()
operator|.
name|pathAsText
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapper
operator|==
literal|null
condition|)
block|{
comment|// One mapping is missing, check if we are allowed to create a dynamic one.
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
init|=
name|parent
operator|.
name|dynamic
argument_list|()
decl_stmt|;
if|if
condition|(
name|dynamic
operator|==
literal|null
condition|)
block|{
name|dynamic
operator|=
name|dynamicOrDefault
argument_list|(
name|context
operator|.
name|root
argument_list|()
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dynamic
condition|)
block|{
case|case
name|STRICT
case|:
throw|throw
operator|new
name|StrictDynamicMappingException
argument_list|(
name|parent
operator|.
name|fullPath
argument_list|()
argument_list|,
name|paths
index|[
name|i
index|]
argument_list|)
throw|;
case|case
name|TRUE
case|:
name|Mapper
operator|.
name|Builder
name|builder
init|=
name|context
operator|.
name|root
argument_list|()
operator|.
name|findTemplateBuilder
argument_list|(
name|context
argument_list|,
name|paths
index|[
name|i
index|]
argument_list|,
literal|"object"
argument_list|)
decl_stmt|;
if|if
condition|(
name|builder
operator|==
literal|null
condition|)
block|{
comment|// if this is a non root object, then explicitly set the dynamic behavior if set
if|if
condition|(
operator|!
operator|(
name|parent
operator|instanceof
name|RootObjectMapper
operator|)
operator|&&
name|parent
operator|.
name|dynamic
argument_list|()
operator|!=
name|ObjectMapper
operator|.
name|Defaults
operator|.
name|DYNAMIC
condition|)
block|{
operator|(
operator|(
name|ObjectMapper
operator|.
name|Builder
operator|)
name|builder
operator|)
operator|.
name|dynamic
argument_list|(
name|parent
operator|.
name|dynamic
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|builder
operator|=
operator|new
name|ObjectMapper
operator|.
name|Builder
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
operator|.
name|enabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|Mapper
operator|.
name|BuilderContext
name|builderContext
init|=
operator|new
name|Mapper
operator|.
name|BuilderContext
argument_list|(
name|context
operator|.
name|indexSettings
argument_list|()
argument_list|,
name|context
operator|.
name|path
argument_list|()
argument_list|)
decl_stmt|;
name|mapper
operator|=
operator|(
name|ObjectMapper
operator|)
name|builder
operator|.
name|build
argument_list|(
name|builderContext
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapper
operator|.
name|nested
argument_list|()
operator|!=
name|ObjectMapper
operator|.
name|Nested
operator|.
name|NO
condition|)
block|{
throw|throw
operator|new
name|MapperParsingException
argument_list|(
literal|"It is forbidden to create dynamic nested objects (["
operator|+
name|context
operator|.
name|path
argument_list|()
operator|.
name|pathAsText
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
operator|+
literal|"]) through `copy_to`"
argument_list|)
throw|;
block|}
break|break;
case|case
name|FALSE
case|:
comment|// Maybe we should log something to tell the user that the copy_to is ignored in this case.
break|break;
default|default:
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"Unexpected dynamic type "
operator|+
name|dynamic
argument_list|)
throw|;
block|}
block|}
name|context
operator|.
name|path
argument_list|()
operator|.
name|add
argument_list|(
name|paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mappers
index|[
name|i
index|]
operator|=
name|mapper
expr_stmt|;
name|parent
operator|=
name|mapper
expr_stmt|;
block|}
block|}
name|ObjectMapper
name|update
init|=
name|parseDynamicValue
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|,
name|fieldName
argument_list|,
name|context
operator|.
name|parser
argument_list|()
operator|.
name|currentToken
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|update
operator|!=
literal|null
assert|;
comment|// we are parsing a dynamic value so we necessarily created a new mapping
if|if
condition|(
name|paths
operator|.
name|length
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|paths
operator|.
name|length
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ObjectMapper
name|parent
init|=
name|context
operator|.
name|root
argument_list|()
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
name|mappers
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
assert|assert
name|parent
operator|!=
literal|null
assert|;
name|update
operator|=
name|parent
operator|.
name|mappingUpdate
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
block|}
name|context
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|update
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Parse the given {@code context} with the given {@code mapper} and apply      * the potential mapping update in-place. This method is useful when      * composing mapping updates.      */
DECL|method|parseAndMergeUpdate
specifier|private
specifier|static
parameter_list|<
name|M
extends|extends
name|Mapper
parameter_list|>
name|M
name|parseAndMergeUpdate
parameter_list|(
name|M
name|mapper
parameter_list|,
name|ParseContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|Mapper
name|update
init|=
name|parseObjectOrField
argument_list|(
name|context
argument_list|,
name|mapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|update
operator|!=
literal|null
condition|)
block|{
name|mapper
operator|=
operator|(
name|M
operator|)
name|mapper
operator|.
name|merge
argument_list|(
name|update
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
return|return
name|mapper
return|;
block|}
DECL|method|dynamicOrDefault
specifier|private
specifier|static
name|ObjectMapper
operator|.
name|Dynamic
name|dynamicOrDefault
parameter_list|(
name|ObjectMapper
operator|.
name|Dynamic
name|dynamic
parameter_list|)
block|{
return|return
name|dynamic
operator|==
literal|null
condition|?
name|ObjectMapper
operator|.
name|Dynamic
operator|.
name|TRUE
else|:
name|dynamic
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
name|void
name|close
parameter_list|()
block|{
name|cache
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

