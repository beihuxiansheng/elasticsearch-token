begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.engine
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|ReferenceManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|BytesRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_comment
comment|/** Maps _uid value to its version information. */
end_comment

begin_class
DECL|class|LiveVersionMap
class|class
name|LiveVersionMap
implements|implements
name|ReferenceManager
operator|.
name|RefreshListener
implements|,
name|Accountable
block|{
DECL|class|Maps
specifier|private
specifier|static
class|class
name|Maps
block|{
comment|// All writes (adds and deletes) go into here:
DECL|field|current
specifier|final
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|VersionValue
argument_list|>
name|current
decl_stmt|;
comment|// Used while refresh is running, and to hold adds/deletes until refresh finishes.  We read from both current and old on lookup:
DECL|field|old
specifier|final
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|VersionValue
argument_list|>
name|old
decl_stmt|;
DECL|method|Maps
specifier|public
name|Maps
parameter_list|(
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|VersionValue
argument_list|>
name|current
parameter_list|,
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|VersionValue
argument_list|>
name|old
parameter_list|)
block|{
name|this
operator|.
name|current
operator|=
name|current
expr_stmt|;
name|this
operator|.
name|old
operator|=
name|old
expr_stmt|;
block|}
DECL|method|Maps
specifier|public
name|Maps
parameter_list|()
block|{
name|this
argument_list|(
name|ConcurrentCollections
operator|.
expr|<
name|BytesRef
argument_list|,
name|VersionValue
operator|>
name|newConcurrentMapWithAggressiveConcurrency
argument_list|()
argument_list|,
name|ConcurrentCollections
operator|.
expr|<
name|BytesRef
argument_list|,
name|VersionValue
operator|>
name|newConcurrentMapWithAggressiveConcurrency
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// All deletes also go here, and delete "tombstones" are retained after refresh:
DECL|field|tombstones
specifier|private
specifier|final
name|Map
argument_list|<
name|BytesRef
argument_list|,
name|VersionValue
argument_list|>
name|tombstones
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMapWithAggressiveConcurrency
argument_list|()
decl_stmt|;
DECL|field|maps
specifier|private
specifier|volatile
name|Maps
name|maps
init|=
operator|new
name|Maps
argument_list|()
decl_stmt|;
DECL|field|mgr
specifier|private
name|ReferenceManager
argument_list|<
name|?
argument_list|>
name|mgr
decl_stmt|;
comment|/** Bytes consumed for each BytesRef UID:      * In this base value, we account for the {@link BytesRef} object itself as      * well as the header of the byte[] array it holds, and some lost bytes due      * to object alignment. So consumers of this constant just have to add the      * length of the byte[] (assuming it is not shared between multiple      * instances). */
DECL|field|BASE_BYTES_PER_BYTESREF
specifier|private
specifier|static
specifier|final
name|long
name|BASE_BYTES_PER_BYTESREF
init|=
comment|// shallow memory usage of the BytesRef object
name|RamUsageEstimator
operator|.
name|shallowSizeOfInstance
argument_list|(
name|BytesRef
operator|.
name|class
argument_list|)
operator|+
comment|// header of the byte[] array
name|RamUsageEstimator
operator|.
name|NUM_BYTES_ARRAY_HEADER
operator|+
comment|// with an alignment size (-XX:ObjectAlignmentInBytes) of 8 (default),
comment|// there could be between 0 and 7 lost bytes, so we account for 3
comment|// lost bytes on average
literal|3
decl_stmt|;
comment|/** Bytes used by having CHM point to a key/value. */
DECL|field|BASE_BYTES_PER_CHM_ENTRY
specifier|private
specifier|static
specifier|final
name|long
name|BASE_BYTES_PER_CHM_ENTRY
decl_stmt|;
static|static
block|{
comment|// use the same impl as the Maps does
name|Map
argument_list|<
name|Integer
argument_list|,
name|Integer
argument_list|>
name|map
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMapWithAggressiveConcurrency
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|long
name|chmEntryShallowSize
init|=
name|RamUsageEstimator
operator|.
name|shallowSizeOf
argument_list|(
name|map
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
operator|.
name|next
argument_list|()
argument_list|)
decl_stmt|;
comment|// assume a load factor of 50%
comment|// for each entry, we need two object refs, one for the entry itself
comment|// and one for the free space that is due to the fact hash tables can
comment|// not be fully loaded
name|BASE_BYTES_PER_CHM_ENTRY
operator|=
name|chmEntryShallowSize
operator|+
literal|2
operator|*
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
expr_stmt|;
block|}
comment|/** Tracks bytes used by current map, i.e. what is freed on refresh. For deletes, which are also added to tombstones, we only account      *  for the CHM entry here, and account for BytesRef/VersionValue against the tombstones, since refresh would not clear this RAM. */
DECL|field|ramBytesUsedCurrent
specifier|final
name|AtomicLong
name|ramBytesUsedCurrent
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|/** Tracks bytes used by tombstones (deletes) */
DECL|field|ramBytesUsedTombstones
specifier|final
name|AtomicLong
name|ramBytesUsedTombstones
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|/** Sync'd because we replace old mgr. */
DECL|method|setManager
specifier|synchronized
name|void
name|setManager
parameter_list|(
name|ReferenceManager
argument_list|<
name|?
argument_list|>
name|newMgr
parameter_list|)
block|{
if|if
condition|(
name|mgr
operator|!=
literal|null
condition|)
block|{
name|mgr
operator|.
name|removeListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|mgr
operator|=
name|newMgr
expr_stmt|;
comment|// In case InternalEngine closes& opens a new IndexWriter/SearcherManager, all deletes are made visible, so we clear old and
comment|// current here.  This is safe because caller holds writeLock here (so no concurrent adds/deletes can be happeninge):
name|maps
operator|=
operator|new
name|Maps
argument_list|()
expr_stmt|;
comment|// So we are notified when reopen starts and finishes
name|mgr
operator|.
name|addListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|beforeRefresh
specifier|public
name|void
name|beforeRefresh
parameter_list|()
throws|throws
name|IOException
block|{
comment|// Start sending all updates after this point to the new
comment|// map.  While reopen is running, any lookup will first
comment|// try this new map, then fallback to old, then to the
comment|// current searcher:
name|maps
operator|=
operator|new
name|Maps
argument_list|(
name|ConcurrentCollections
operator|.
expr|<
name|BytesRef
argument_list|,
name|VersionValue
operator|>
name|newConcurrentMapWithAggressiveConcurrency
argument_list|()
argument_list|,
name|maps
operator|.
name|current
argument_list|)
expr_stmt|;
comment|// This is not 100% correct, since concurrent indexing ops can change these counters in between our execution of the previous
comment|// line and this one, but that should be minor, and the error won't accumulate over time:
name|ramBytesUsedCurrent
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|afterRefresh
specifier|public
name|void
name|afterRefresh
parameter_list|(
name|boolean
name|didRefresh
parameter_list|)
throws|throws
name|IOException
block|{
comment|// We can now drop old because these operations are now visible via the newly opened searcher.  Even if didRefresh is false, which
comment|// means Lucene did not actually open a new reader because it detected no changes, it's possible old has some entries in it, which
comment|// is fine: it means they were actually already included in the previously opened reader, so we can still safely drop them in that
comment|// case.  This is because we assign new maps (in beforeRefresh) slightly before Lucene actually flushes any segments for the
comment|// reopen, and so any concurrent indexing requests can still sneak in a few additions to that current map that are in fact reflected
comment|// in the previous reader.   We don't touch tombstones here: they expire on their own index.gc_deletes timeframe:
name|maps
operator|=
operator|new
name|Maps
argument_list|(
name|maps
operator|.
name|current
argument_list|,
name|ConcurrentCollections
operator|.
expr|<
name|BytesRef
argument_list|,
name|VersionValue
operator|>
name|newConcurrentMapWithAggressiveConcurrency
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/** Returns the live version (add or delete) for this uid. */
DECL|method|getUnderLock
name|VersionValue
name|getUnderLock
parameter_list|(
specifier|final
name|Term
name|uid
parameter_list|)
block|{
name|Maps
name|currentMaps
init|=
name|maps
decl_stmt|;
comment|// First try to get the "live" value:
name|VersionValue
name|value
init|=
name|currentMaps
operator|.
name|current
operator|.
name|get
argument_list|(
name|uid
operator|.
name|bytes
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
name|value
operator|=
name|currentMaps
operator|.
name|old
operator|.
name|get
argument_list|(
name|uid
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
return|return
name|tombstones
operator|.
name|get
argument_list|(
name|uid
operator|.
name|bytes
argument_list|()
argument_list|)
return|;
block|}
comment|/** Adds this uid/version to the pending adds map. */
DECL|method|putUnderLock
name|void
name|putUnderLock
parameter_list|(
name|BytesRef
name|uid
parameter_list|,
name|VersionValue
name|version
parameter_list|)
block|{
assert|assert
name|uid
operator|.
name|bytes
operator|.
name|length
operator|==
name|uid
operator|.
name|length
operator|:
literal|"Oversized _uid! UID length: "
operator|+
name|uid
operator|.
name|length
operator|+
literal|", bytes length: "
operator|+
name|uid
operator|.
name|bytes
operator|.
name|length
assert|;
name|long
name|uidRAMBytesUsed
init|=
name|BASE_BYTES_PER_BYTESREF
operator|+
name|uid
operator|.
name|bytes
operator|.
name|length
decl_stmt|;
specifier|final
name|VersionValue
name|prev
init|=
name|maps
operator|.
name|current
operator|.
name|put
argument_list|(
name|uid
argument_list|,
name|version
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
comment|// Deduct RAM for the version we just replaced:
name|long
name|prevBytes
init|=
name|BASE_BYTES_PER_CHM_ENTRY
decl_stmt|;
if|if
condition|(
name|prev
operator|.
name|delete
argument_list|()
operator|==
literal|false
condition|)
block|{
name|prevBytes
operator|+=
name|prev
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|uidRAMBytesUsed
expr_stmt|;
block|}
name|ramBytesUsedCurrent
operator|.
name|addAndGet
argument_list|(
operator|-
name|prevBytes
argument_list|)
expr_stmt|;
block|}
comment|// Add RAM for the new version:
name|long
name|newBytes
init|=
name|BASE_BYTES_PER_CHM_ENTRY
decl_stmt|;
if|if
condition|(
name|version
operator|.
name|delete
argument_list|()
operator|==
literal|false
condition|)
block|{
name|newBytes
operator|+=
name|version
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|uidRAMBytesUsed
expr_stmt|;
block|}
name|ramBytesUsedCurrent
operator|.
name|addAndGet
argument_list|(
name|newBytes
argument_list|)
expr_stmt|;
specifier|final
name|VersionValue
name|prevTombstone
decl_stmt|;
if|if
condition|(
name|version
operator|.
name|delete
argument_list|()
condition|)
block|{
comment|// Also enroll the delete into tombstones, and account for its RAM too:
name|prevTombstone
operator|=
name|tombstones
operator|.
name|put
argument_list|(
name|uid
argument_list|,
name|version
argument_list|)
expr_stmt|;
comment|// We initially account for BytesRef/VersionValue RAM for a delete against the tombstones, because this RAM will not be freed up
comment|// on refresh. Later, in removeTombstoneUnderLock, if we clear the tombstone entry but the delete remains in current, we shift
comment|// the accounting to current:
name|ramBytesUsedTombstones
operator|.
name|addAndGet
argument_list|(
name|BASE_BYTES_PER_CHM_ENTRY
operator|+
name|version
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|uidRAMBytesUsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevTombstone
operator|==
literal|null
operator|&&
name|prev
operator|!=
literal|null
operator|&&
name|prev
operator|.
name|delete
argument_list|()
condition|)
block|{
comment|// If prev was a delete that had already been removed from tombstones, then current was already accounting for the
comment|// BytesRef/VersionValue RAM, so we now deduct that as well:
name|ramBytesUsedCurrent
operator|.
name|addAndGet
argument_list|(
operator|-
operator|(
name|prev
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|uidRAMBytesUsed
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// UID came back to life so we remove the tombstone:
name|prevTombstone
operator|=
name|tombstones
operator|.
name|remove
argument_list|(
name|uid
argument_list|)
expr_stmt|;
block|}
comment|// Deduct tombstones bytes used for the version we just removed or replaced:
if|if
condition|(
name|prevTombstone
operator|!=
literal|null
condition|)
block|{
name|long
name|v
init|=
name|ramBytesUsedTombstones
operator|.
name|addAndGet
argument_list|(
operator|-
operator|(
name|BASE_BYTES_PER_CHM_ENTRY
operator|+
name|prevTombstone
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|uidRAMBytesUsed
operator|)
argument_list|)
decl_stmt|;
assert|assert
name|v
operator|>=
literal|0
operator|:
literal|"bytes="
operator|+
name|v
assert|;
block|}
block|}
comment|/** Removes this uid from the pending deletes map. */
DECL|method|removeTombstoneUnderLock
name|void
name|removeTombstoneUnderLock
parameter_list|(
name|BytesRef
name|uid
parameter_list|)
block|{
name|long
name|uidRAMBytesUsed
init|=
name|BASE_BYTES_PER_BYTESREF
operator|+
name|uid
operator|.
name|bytes
operator|.
name|length
decl_stmt|;
specifier|final
name|VersionValue
name|prev
init|=
name|tombstones
operator|.
name|remove
argument_list|(
name|uid
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|!=
literal|null
condition|)
block|{
assert|assert
name|prev
operator|.
name|delete
argument_list|()
assert|;
name|long
name|v
init|=
name|ramBytesUsedTombstones
operator|.
name|addAndGet
argument_list|(
operator|-
operator|(
name|BASE_BYTES_PER_CHM_ENTRY
operator|+
name|prev
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|uidRAMBytesUsed
operator|)
argument_list|)
decl_stmt|;
assert|assert
name|v
operator|>=
literal|0
operator|:
literal|"bytes="
operator|+
name|v
assert|;
block|}
specifier|final
name|VersionValue
name|curVersion
init|=
name|maps
operator|.
name|current
operator|.
name|get
argument_list|(
name|uid
argument_list|)
decl_stmt|;
if|if
condition|(
name|curVersion
operator|!=
literal|null
operator|&&
name|curVersion
operator|.
name|delete
argument_list|()
condition|)
block|{
comment|// We now shift accounting of the BytesRef from tombstones to current, because a refresh would clear this RAM.  This should be
comment|// uncommon, because with the default refresh=1s and gc_deletes=60s, deletes should be cleared from current long before we drop
comment|// them from tombstones:
name|ramBytesUsedCurrent
operator|.
name|addAndGet
argument_list|(
name|curVersion
operator|.
name|ramBytesUsed
argument_list|()
operator|+
name|uidRAMBytesUsed
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Caller has a lock, so that this uid will not be concurrently added/deleted by another thread. */
DECL|method|getTombstoneUnderLock
name|VersionValue
name|getTombstoneUnderLock
parameter_list|(
name|BytesRef
name|uid
parameter_list|)
block|{
return|return
name|tombstones
operator|.
name|get
argument_list|(
name|uid
argument_list|)
return|;
block|}
comment|/** Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones (exposed via reader but not yet GC'd). */
DECL|method|getAllTombstones
name|Iterable
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|BytesRef
argument_list|,
name|VersionValue
argument_list|>
argument_list|>
name|getAllTombstones
parameter_list|()
block|{
return|return
name|tombstones
operator|.
name|entrySet
argument_list|()
return|;
block|}
comment|/** Called when this index is closed. */
DECL|method|clear
specifier|synchronized
name|void
name|clear
parameter_list|()
block|{
name|maps
operator|=
operator|new
name|Maps
argument_list|()
expr_stmt|;
name|tombstones
operator|.
name|clear
argument_list|()
expr_stmt|;
name|ramBytesUsedCurrent
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// NOTE: we can't zero this here, because a refresh thread could be calling InternalEngine.pruneDeletedTombstones at the same time,
comment|// and this will lead to an assert trip.  Presumably it's fine if our ramBytesUsedTombstones is non-zero after clear since the index
comment|// is being closed:
comment|//ramBytesUsedTombstones.set(0);
if|if
condition|(
name|mgr
operator|!=
literal|null
condition|)
block|{
name|mgr
operator|.
name|removeListener
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|mgr
operator|=
literal|null
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|ramBytesUsed
specifier|public
name|long
name|ramBytesUsed
parameter_list|()
block|{
return|return
name|ramBytesUsedCurrent
operator|.
name|get
argument_list|()
operator|+
name|ramBytesUsedTombstones
operator|.
name|get
argument_list|()
return|;
block|}
comment|/** Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they      *  don't clear on refresh. */
DECL|method|ramBytesUsedForRefresh
name|long
name|ramBytesUsedForRefresh
parameter_list|()
block|{
return|return
name|ramBytesUsedCurrent
operator|.
name|get
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getChildResources
specifier|public
name|Collection
argument_list|<
name|Accountable
argument_list|>
name|getChildResources
parameter_list|()
block|{
comment|// TODO: useful to break down RAM usage here?
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
block|}
end_class

end_unit

