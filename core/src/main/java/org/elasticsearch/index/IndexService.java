begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|AliasMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableOpenMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|BigArrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|NodeEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|ShardLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|analysis
operator|.
name|AnalysisRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|analysis
operator|.
name|AnalysisService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|IndexCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|bitset
operator|.
name|BitsetFilterCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|query
operator|.
name|QueryCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|Engine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|EngineClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|EngineFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldDataCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldDataService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|ParsedQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryShardContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexSearcherWrapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexingOperationListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|SearchOperationListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShadowIndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardNotFoundException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardPath
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|similarity
operator|.
name|SimilarityService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|IndexStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|Translog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|AliasFilterParsingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|InvalidAliasNameException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|fielddata
operator|.
name|cache
operator|.
name|IndicesFieldDataCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|mapper
operator|.
name|MapperRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|MapBuilder
operator|.
name|newMapBuilder
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|IndexService
specifier|public
specifier|final
class|class
name|IndexService
extends|extends
name|AbstractIndexComponent
implements|implements
name|IndexComponent
implements|,
name|Iterable
argument_list|<
name|IndexShard
argument_list|>
block|{
DECL|field|eventListener
specifier|private
specifier|final
name|IndexEventListener
name|eventListener
decl_stmt|;
DECL|field|analysisService
specifier|private
specifier|final
name|AnalysisService
name|analysisService
decl_stmt|;
DECL|field|indexFieldData
specifier|private
specifier|final
name|IndexFieldDataService
name|indexFieldData
decl_stmt|;
DECL|field|bitsetFilterCache
specifier|private
specifier|final
name|BitsetFilterCache
name|bitsetFilterCache
decl_stmt|;
DECL|field|nodeEnv
specifier|private
specifier|final
name|NodeEnvironment
name|nodeEnv
decl_stmt|;
DECL|field|shardStoreDeleter
specifier|private
specifier|final
name|ShardStoreDeleter
name|shardStoreDeleter
decl_stmt|;
DECL|field|nodeServicesProvider
specifier|private
specifier|final
name|NodeServicesProvider
name|nodeServicesProvider
decl_stmt|;
DECL|field|indexStore
specifier|private
specifier|final
name|IndexStore
name|indexStore
decl_stmt|;
DECL|field|searcherWrapper
specifier|private
specifier|final
name|IndexSearcherWrapper
name|searcherWrapper
decl_stmt|;
DECL|field|indexCache
specifier|private
specifier|final
name|IndexCache
name|indexCache
decl_stmt|;
DECL|field|mapperService
specifier|private
specifier|final
name|MapperService
name|mapperService
decl_stmt|;
DECL|field|similarityService
specifier|private
specifier|final
name|SimilarityService
name|similarityService
decl_stmt|;
DECL|field|engineFactory
specifier|private
specifier|final
name|EngineFactory
name|engineFactory
decl_stmt|;
DECL|field|warmer
specifier|private
specifier|final
name|IndexWarmer
name|warmer
decl_stmt|;
DECL|field|globalCheckpointSyncer
specifier|private
specifier|final
name|Consumer
argument_list|<
name|ShardId
argument_list|>
name|globalCheckpointSyncer
decl_stmt|;
DECL|field|shards
specifier|private
specifier|volatile
name|Map
argument_list|<
name|Integer
argument_list|,
name|IndexShard
argument_list|>
name|shards
init|=
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|deleted
specifier|private
specifier|final
name|AtomicBoolean
name|deleted
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|indexSettings
specifier|private
specifier|final
name|IndexSettings
name|indexSettings
decl_stmt|;
DECL|field|indexingOperationListeners
specifier|private
specifier|final
name|List
argument_list|<
name|IndexingOperationListener
argument_list|>
name|indexingOperationListeners
decl_stmt|;
DECL|field|searchOperationListeners
specifier|private
specifier|final
name|List
argument_list|<
name|SearchOperationListener
argument_list|>
name|searchOperationListeners
decl_stmt|;
DECL|field|refreshTask
specifier|private
specifier|volatile
name|AsyncRefreshTask
name|refreshTask
decl_stmt|;
DECL|field|fsyncTask
specifier|private
specifier|volatile
name|AsyncTranslogFSync
name|fsyncTask
decl_stmt|;
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|bigArrays
specifier|private
specifier|final
name|BigArrays
name|bigArrays
decl_stmt|;
DECL|field|globalCheckpointTask
specifier|private
specifier|final
name|AsyncGlobalCheckpointTask
name|globalCheckpointTask
decl_stmt|;
DECL|method|IndexService
specifier|public
name|IndexService
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|,
name|NodeEnvironment
name|nodeEnv
parameter_list|,
name|SimilarityService
name|similarityService
parameter_list|,
name|ShardStoreDeleter
name|shardStoreDeleter
parameter_list|,
name|AnalysisRegistry
name|registry
parameter_list|,
annotation|@
name|Nullable
name|EngineFactory
name|engineFactory
parameter_list|,
name|NodeServicesProvider
name|nodeServicesProvider
parameter_list|,
name|QueryCache
name|queryCache
parameter_list|,
name|IndexStore
name|indexStore
parameter_list|,
name|IndexEventListener
name|eventListener
parameter_list|,
name|IndexModule
operator|.
name|IndexSearcherWrapperFactory
name|wrapperFactory
parameter_list|,
name|MapperRegistry
name|mapperRegistry
parameter_list|,
name|IndicesFieldDataCache
name|indicesFieldDataCache
parameter_list|,
name|Consumer
argument_list|<
name|ShardId
argument_list|>
name|globalCheckpointSyncer
parameter_list|,
name|List
argument_list|<
name|SearchOperationListener
argument_list|>
name|searchOperationListeners
parameter_list|,
name|List
argument_list|<
name|IndexingOperationListener
argument_list|>
name|indexingOperationListeners
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexSettings
operator|=
name|indexSettings
expr_stmt|;
name|this
operator|.
name|globalCheckpointSyncer
operator|=
name|globalCheckpointSyncer
expr_stmt|;
name|this
operator|.
name|analysisService
operator|=
name|registry
operator|.
name|build
argument_list|(
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|similarityService
operator|=
name|similarityService
expr_stmt|;
name|this
operator|.
name|mapperService
operator|=
operator|new
name|MapperService
argument_list|(
name|indexSettings
argument_list|,
name|analysisService
argument_list|,
name|similarityService
argument_list|,
name|mapperRegistry
argument_list|,
name|IndexService
operator|.
name|this
operator|::
name|newQueryShardContext
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexFieldData
operator|=
operator|new
name|IndexFieldDataService
argument_list|(
name|indexSettings
argument_list|,
name|indicesFieldDataCache
argument_list|,
name|nodeServicesProvider
operator|.
name|getCircuitBreakerService
argument_list|()
argument_list|,
name|mapperService
argument_list|)
expr_stmt|;
name|this
operator|.
name|shardStoreDeleter
operator|=
name|shardStoreDeleter
expr_stmt|;
name|this
operator|.
name|bigArrays
operator|=
name|nodeServicesProvider
operator|.
name|getBigArrays
argument_list|()
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|nodeServicesProvider
operator|.
name|getThreadPool
argument_list|()
expr_stmt|;
name|this
operator|.
name|eventListener
operator|=
name|eventListener
expr_stmt|;
name|this
operator|.
name|nodeEnv
operator|=
name|nodeEnv
expr_stmt|;
name|this
operator|.
name|nodeServicesProvider
operator|=
name|nodeServicesProvider
expr_stmt|;
name|this
operator|.
name|indexStore
operator|=
name|indexStore
expr_stmt|;
name|indexFieldData
operator|.
name|setListener
argument_list|(
operator|new
name|FieldDataCacheListener
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|bitsetFilterCache
operator|=
operator|new
name|BitsetFilterCache
argument_list|(
name|indexSettings
argument_list|,
operator|new
name|BitsetCacheListener
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|warmer
operator|=
operator|new
name|IndexWarmer
argument_list|(
name|indexSettings
operator|.
name|getSettings
argument_list|()
argument_list|,
name|threadPool
argument_list|,
name|bitsetFilterCache
operator|.
name|createListener
argument_list|(
name|threadPool
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexCache
operator|=
operator|new
name|IndexCache
argument_list|(
name|indexSettings
argument_list|,
name|queryCache
argument_list|,
name|bitsetFilterCache
argument_list|)
expr_stmt|;
name|this
operator|.
name|engineFactory
operator|=
name|engineFactory
expr_stmt|;
comment|// initialize this last -- otherwise if the wrapper requires any other member to be non-null we fail with an NPE
name|this
operator|.
name|searcherWrapper
operator|=
name|wrapperFactory
operator|.
name|newWrapper
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|globalCheckpointTask
operator|=
operator|new
name|AsyncGlobalCheckpointTask
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexingOperationListeners
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|indexingOperationListeners
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchOperationListeners
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|searchOperationListeners
argument_list|)
expr_stmt|;
comment|// kick off async ops for the first shard in this index
name|this
operator|.
name|refreshTask
operator|=
operator|new
name|AsyncRefreshTask
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|rescheduleFsyncTask
argument_list|(
name|indexSettings
operator|.
name|getTranslogDurability
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|numberOfShards
specifier|public
name|int
name|numberOfShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getIndexEventListener
specifier|public
name|IndexEventListener
name|getIndexEventListener
parameter_list|()
block|{
return|return
name|this
operator|.
name|eventListener
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|IndexShard
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|shards
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|hasShard
specifier|public
name|boolean
name|hasShard
parameter_list|(
name|int
name|shardId
parameter_list|)
block|{
return|return
name|shards
operator|.
name|containsKey
argument_list|(
name|shardId
argument_list|)
return|;
block|}
comment|/**      * Return the shard with the provided id, or null if there is no such shard.      */
annotation|@
name|Nullable
DECL|method|getShardOrNull
specifier|public
name|IndexShard
name|getShardOrNull
parameter_list|(
name|int
name|shardId
parameter_list|)
block|{
return|return
name|shards
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
return|;
block|}
comment|/**      * Return the shard with the provided id, or throw an exception if it doesn't exist.      */
DECL|method|getShard
specifier|public
name|IndexShard
name|getShard
parameter_list|(
name|int
name|shardId
parameter_list|)
block|{
name|IndexShard
name|indexShard
init|=
name|getShardOrNull
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ShardNotFoundException
argument_list|(
operator|new
name|ShardId
argument_list|(
name|index
argument_list|()
argument_list|,
name|shardId
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|indexShard
return|;
block|}
DECL|method|shardIds
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|shardIds
parameter_list|()
block|{
return|return
name|shards
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|cache
specifier|public
name|IndexCache
name|cache
parameter_list|()
block|{
return|return
name|indexCache
return|;
block|}
DECL|method|fieldData
specifier|public
name|IndexFieldDataService
name|fieldData
parameter_list|()
block|{
return|return
name|indexFieldData
return|;
block|}
DECL|method|analysisService
specifier|public
name|AnalysisService
name|analysisService
parameter_list|()
block|{
return|return
name|this
operator|.
name|analysisService
return|;
block|}
DECL|method|mapperService
specifier|public
name|MapperService
name|mapperService
parameter_list|()
block|{
return|return
name|mapperService
return|;
block|}
DECL|method|similarityService
specifier|public
name|SimilarityService
name|similarityService
parameter_list|()
block|{
return|return
name|similarityService
return|;
block|}
DECL|method|close
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|(
specifier|final
name|String
name|reason
parameter_list|,
name|boolean
name|delete
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|deleted
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
name|delete
argument_list|)
expr_stmt|;
try|try
block|{
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|shardIds
init|=
name|shardIds
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|shardId
range|:
name|shardIds
control|)
block|{
try|try
block|{
name|removeShard
argument_list|(
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to close shard"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|bitsetFilterCache
argument_list|,
name|indexCache
argument_list|,
name|indexFieldData
argument_list|,
name|analysisService
argument_list|,
name|refreshTask
argument_list|,
name|fsyncTask
argument_list|,
name|globalCheckpointTask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|indexUUID
specifier|public
name|String
name|indexUUID
parameter_list|()
block|{
return|return
name|indexSettings
operator|.
name|getUUID
argument_list|()
return|;
block|}
comment|// NOTE: O(numShards) cost, but numShards should be smallish?
DECL|method|getAvgShardSizeInBytes
specifier|private
name|long
name|getAvgShardSizeInBytes
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|IndexShard
name|indexShard
range|:
name|this
control|)
block|{
name|sum
operator|+=
name|indexShard
operator|.
name|store
argument_list|()
operator|.
name|stats
argument_list|()
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1L
return|;
block|}
else|else
block|{
return|return
name|sum
operator|/
name|count
return|;
block|}
block|}
DECL|method|createShard
specifier|public
specifier|synchronized
name|IndexShard
name|createShard
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|primary
init|=
name|routing
operator|.
name|primary
argument_list|()
decl_stmt|;
comment|/*          * TODO: we execute this in parallel but it's a synced method. Yet, we might          * be able to serialize the execution via the cluster state in the future. for now we just          * keep it synced.          */
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't create shard "
operator|+
name|routing
operator|.
name|shardId
argument_list|()
operator|+
literal|", closed"
argument_list|)
throw|;
block|}
specifier|final
name|Settings
name|indexSettings
init|=
name|this
operator|.
name|indexSettings
operator|.
name|getSettings
argument_list|()
decl_stmt|;
specifier|final
name|ShardId
name|shardId
init|=
name|routing
operator|.
name|shardId
argument_list|()
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Store
name|store
init|=
literal|null
decl_stmt|;
name|IndexShard
name|indexShard
init|=
literal|null
decl_stmt|;
specifier|final
name|ShardLock
name|lock
init|=
name|nodeEnv
operator|.
name|shardLock
argument_list|(
name|shardId
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|eventListener
operator|.
name|beforeIndexShardCreated
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|ShardPath
name|path
decl_stmt|;
try|try
block|{
name|path
operator|=
name|ShardPath
operator|.
name|loadShardPath
argument_list|(
name|logger
argument_list|,
name|nodeEnv
argument_list|,
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} failed to load shard path, trying to remove leftover"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|ShardPath
operator|.
name|deleteLeftoverShardDirectory
argument_list|(
name|logger
argument_list|,
name|nodeEnv
argument_list|,
name|lock
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|)
expr_stmt|;
name|path
operator|=
name|ShardPath
operator|.
name|loadShardPath
argument_list|(
name|logger
argument_list|,
name|nodeEnv
argument_list|,
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|t
operator|.
name|addSuppressed
argument_list|(
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
comment|// TODO: we should, instead, hold a "bytes reserved" of how large we anticipate this shard will be, e.g. for a shard
comment|// that's being relocated/replicated we know how large it will become once it's done copying:
comment|// Count up how many shards are currently on each data path:
name|Map
argument_list|<
name|Path
argument_list|,
name|Integer
argument_list|>
name|dataPathToShardCount
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexShard
name|shard
range|:
name|this
control|)
block|{
name|Path
name|dataPath
init|=
name|shard
operator|.
name|shardPath
argument_list|()
operator|.
name|getRootStatePath
argument_list|()
decl_stmt|;
name|Integer
name|curCount
init|=
name|dataPathToShardCount
operator|.
name|get
argument_list|(
name|dataPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|curCount
operator|==
literal|null
condition|)
block|{
name|curCount
operator|=
literal|0
expr_stmt|;
block|}
name|dataPathToShardCount
operator|.
name|put
argument_list|(
name|dataPath
argument_list|,
name|curCount
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|ShardPath
operator|.
name|selectNewPathForShard
argument_list|(
name|nodeEnv
argument_list|,
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|routing
operator|.
name|getExpectedShardSize
argument_list|()
operator|==
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
condition|?
name|getAvgShardSizeInBytes
argument_list|()
else|:
name|routing
operator|.
name|getExpectedShardSize
argument_list|()
argument_list|,
name|dataPathToShardCount
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"{} creating using a new path [{}]"
argument_list|,
name|shardId
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} creating using an existing path [{}]"
argument_list|,
name|shardId
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shards
operator|.
name|containsKey
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IndexShardAlreadyExistsException
argument_list|(
name|shardId
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"creating shard_id {}"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
comment|// if we are on a shared FS we only own the shard (ie. we can safely delete it) if we are the primary.
specifier|final
name|boolean
name|canDeleteShardContent
init|=
name|IndexMetaData
operator|.
name|isOnSharedFilesystem
argument_list|(
name|indexSettings
argument_list|)
operator|==
literal|false
operator|||
operator|(
name|primary
operator|&&
name|IndexMetaData
operator|.
name|isOnSharedFilesystem
argument_list|(
name|indexSettings
argument_list|)
operator|)
decl_stmt|;
specifier|final
name|Engine
operator|.
name|Warmer
name|engineWarmer
init|=
parameter_list|(
name|searcher
parameter_list|)
lambda|->
block|{
name|IndexShard
name|shard
init|=
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|warmer
operator|.
name|warm
argument_list|(
name|searcher
argument_list|,
name|shard
argument_list|,
name|IndexService
operator|.
name|this
operator|.
name|indexSettings
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|store
operator|=
operator|new
name|Store
argument_list|(
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|indexStore
operator|.
name|newDirectoryService
argument_list|(
name|path
argument_list|)
argument_list|,
name|lock
argument_list|,
operator|new
name|StoreCloseListener
argument_list|(
name|shardId
argument_list|,
name|canDeleteShardContent
argument_list|,
parameter_list|()
lambda|->
name|eventListener
operator|.
name|onStoreClosed
argument_list|(
name|shardId
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|useShadowEngine
argument_list|(
name|primary
argument_list|,
name|indexSettings
argument_list|)
condition|)
block|{
name|indexShard
operator|=
operator|new
name|ShadowIndexShard
argument_list|(
name|routing
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|path
argument_list|,
name|store
argument_list|,
name|indexCache
argument_list|,
name|mapperService
argument_list|,
name|similarityService
argument_list|,
name|indexFieldData
argument_list|,
name|engineFactory
argument_list|,
name|eventListener
argument_list|,
name|searcherWrapper
argument_list|,
name|threadPool
argument_list|,
name|bigArrays
argument_list|,
name|engineWarmer
argument_list|,
name|searchOperationListeners
argument_list|)
expr_stmt|;
comment|// no indexing listeners - shadow  engines don't index
block|}
else|else
block|{
name|indexShard
operator|=
operator|new
name|IndexShard
argument_list|(
name|routing
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|path
argument_list|,
name|store
argument_list|,
name|indexCache
argument_list|,
name|mapperService
argument_list|,
name|similarityService
argument_list|,
name|indexFieldData
argument_list|,
name|engineFactory
argument_list|,
name|eventListener
argument_list|,
name|searcherWrapper
argument_list|,
name|threadPool
argument_list|,
name|bigArrays
argument_list|,
name|engineWarmer
argument_list|,
parameter_list|()
lambda|->
name|globalCheckpointSyncer
operator|.
name|accept
argument_list|(
name|shardId
argument_list|)
argument_list|,
name|searchOperationListeners
argument_list|,
name|indexingOperationListeners
argument_list|)
expr_stmt|;
block|}
name|eventListener
operator|.
name|indexShardStateChanged
argument_list|(
name|indexShard
argument_list|,
literal|null
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|,
literal|"shard created"
argument_list|)
expr_stmt|;
name|eventListener
operator|.
name|afterIndexShardCreated
argument_list|(
name|indexShard
argument_list|)
expr_stmt|;
name|shards
operator|=
name|newMapBuilder
argument_list|(
name|shards
argument_list|)
operator|.
name|put
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|,
name|indexShard
argument_list|)
operator|.
name|immutableMap
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|indexShard
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|closeShard
argument_list|(
literal|"initialization failed"
argument_list|,
name|shardId
argument_list|,
name|indexShard
argument_list|,
name|store
argument_list|,
name|eventListener
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|useShadowEngine
specifier|static
name|boolean
name|useShadowEngine
parameter_list|(
name|boolean
name|primary
parameter_list|,
name|Settings
name|indexSettings
parameter_list|)
block|{
return|return
name|primary
operator|==
literal|false
operator|&&
name|IndexMetaData
operator|.
name|isIndexUsingShadowReplicas
argument_list|(
name|indexSettings
argument_list|)
return|;
block|}
DECL|method|removeShard
specifier|public
specifier|synchronized
name|void
name|removeShard
parameter_list|(
name|int
name|shardId
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
specifier|final
name|ShardId
name|sId
init|=
operator|new
name|ShardId
argument_list|(
name|index
argument_list|()
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
specifier|final
name|IndexShard
name|indexShard
decl_stmt|;
if|if
condition|(
name|shards
operator|.
name|containsKey
argument_list|(
name|shardId
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] closing... (reason: [{}])"
argument_list|,
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|IndexShard
argument_list|>
name|newShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|shards
argument_list|)
decl_stmt|;
name|indexShard
operator|=
name|newShards
operator|.
name|remove
argument_list|(
name|shardId
argument_list|)
expr_stmt|;
name|shards
operator|=
name|unmodifiableMap
argument_list|(
name|newShards
argument_list|)
expr_stmt|;
name|closeShard
argument_list|(
name|reason
argument_list|,
name|sId
argument_list|,
name|indexShard
argument_list|,
name|indexShard
operator|.
name|store
argument_list|()
argument_list|,
name|indexShard
operator|.
name|getIndexEventListener
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] closed (reason: [{}])"
argument_list|,
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
DECL|method|closeShard
specifier|private
name|void
name|closeShard
parameter_list|(
name|String
name|reason
parameter_list|,
name|ShardId
name|sId
parameter_list|,
name|IndexShard
name|indexShard
parameter_list|,
name|Store
name|store
parameter_list|,
name|IndexEventListener
name|listener
parameter_list|)
block|{
specifier|final
name|int
name|shardId
init|=
name|sId
operator|.
name|id
argument_list|()
decl_stmt|;
specifier|final
name|Settings
name|indexSettings
init|=
name|this
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getSettings
argument_list|()
decl_stmt|;
try|try
block|{
try|try
block|{
name|listener
operator|.
name|beforeIndexShardClosed
argument_list|(
name|sId
argument_list|,
name|indexShard
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// this logic is tricky, we want to close the engine so we rollback the changes done to it
comment|// and close the shard so no operations are allowed to it
if|if
condition|(
name|indexShard
operator|!=
literal|null
condition|)
block|{
try|try
block|{
comment|// only flush we are we closed (closed index or shutdown) and if we are not deleted
specifier|final
name|boolean
name|flushEngine
init|=
name|deleted
operator|.
name|get
argument_list|()
operator|==
literal|false
operator|&&
name|closed
operator|.
name|get
argument_list|()
decl_stmt|;
name|indexShard
operator|.
name|close
argument_list|(
name|reason
argument_list|,
name|flushEngine
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] failed to close index shard"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
comment|// ignore
block|}
block|}
comment|// call this before we close the store, so we can release resources for it
name|listener
operator|.
name|afterIndexShardClosed
argument_list|(
name|sId
argument_list|,
name|indexShard
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
try|try
block|{
name|store
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to close store on shard removal (reason: [{}])"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|onShardClose
specifier|private
name|void
name|onShardClose
parameter_list|(
name|ShardLock
name|lock
parameter_list|,
name|boolean
name|ownsShard
parameter_list|)
block|{
if|if
condition|(
name|deleted
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// we remove that shards content if this index has been deleted
try|try
block|{
if|if
condition|(
name|ownsShard
condition|)
block|{
try|try
block|{
name|eventListener
operator|.
name|beforeIndexShardDeleted
argument_list|(
name|lock
operator|.
name|getShardId
argument_list|()
argument_list|,
name|indexSettings
operator|.
name|getSettings
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|shardStoreDeleter
operator|.
name|deleteShardStore
argument_list|(
literal|"delete index"
argument_list|,
name|lock
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|eventListener
operator|.
name|afterIndexShardDeleted
argument_list|(
name|lock
operator|.
name|getShardId
argument_list|()
argument_list|,
name|indexSettings
operator|.
name|getSettings
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|shardStoreDeleter
operator|.
name|addPendingDelete
argument_list|(
name|lock
operator|.
name|getShardId
argument_list|()
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] failed to delete shard content - scheduled a retry"
argument_list|,
name|e
argument_list|,
name|lock
operator|.
name|getShardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getIndexServices
specifier|public
name|NodeServicesProvider
name|getIndexServices
parameter_list|()
block|{
return|return
name|nodeServicesProvider
return|;
block|}
annotation|@
name|Override
DECL|method|getIndexSettings
specifier|public
name|IndexSettings
name|getIndexSettings
parameter_list|()
block|{
return|return
name|indexSettings
return|;
block|}
comment|/**      * Creates a new QueryShardContext. The context has not types set yet, if types are required set them via      * {@link QueryShardContext#setTypes(String...)}      */
DECL|method|newQueryShardContext
specifier|public
name|QueryShardContext
name|newQueryShardContext
parameter_list|(
name|IndexReader
name|indexReader
parameter_list|)
block|{
return|return
operator|new
name|QueryShardContext
argument_list|(
name|indexSettings
argument_list|,
name|indexCache
operator|.
name|bitsetFilterCache
argument_list|()
argument_list|,
name|indexFieldData
argument_list|,
name|mapperService
argument_list|()
argument_list|,
name|similarityService
argument_list|()
argument_list|,
name|nodeServicesProvider
operator|.
name|getScriptService
argument_list|()
argument_list|,
name|nodeServicesProvider
operator|.
name|getIndicesQueriesRegistry
argument_list|()
argument_list|,
name|nodeServicesProvider
operator|.
name|getClient
argument_list|()
argument_list|,
name|indexReader
argument_list|,
name|nodeServicesProvider
operator|.
name|getClusterService
argument_list|()
operator|.
name|state
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates a new QueryShardContext. The context has not types set yet, if types are required set them via      * {@link QueryShardContext#setTypes(String...)}. This context may be used for query parsing but cannot be      * used for rewriting since it does not know about the current {@link IndexReader}.      */
DECL|method|newQueryShardContext
specifier|public
name|QueryShardContext
name|newQueryShardContext
parameter_list|()
block|{
return|return
name|newQueryShardContext
argument_list|(
literal|null
argument_list|)
return|;
block|}
DECL|method|getThreadPool
specifier|public
name|ThreadPool
name|getThreadPool
parameter_list|()
block|{
return|return
name|threadPool
return|;
block|}
DECL|method|getBigArrays
specifier|public
name|BigArrays
name|getBigArrays
parameter_list|()
block|{
return|return
name|bigArrays
return|;
block|}
DECL|method|getIndexOperationListeners
name|List
argument_list|<
name|IndexingOperationListener
argument_list|>
name|getIndexOperationListeners
parameter_list|()
block|{
comment|// pkg private for testing
return|return
name|indexingOperationListeners
return|;
block|}
DECL|method|getSearchOperationListener
name|List
argument_list|<
name|SearchOperationListener
argument_list|>
name|getSearchOperationListener
parameter_list|()
block|{
comment|// pkg private for testing
return|return
name|searchOperationListeners
return|;
block|}
DECL|class|StoreCloseListener
specifier|private
class|class
name|StoreCloseListener
implements|implements
name|Store
operator|.
name|OnClose
block|{
DECL|field|shardId
specifier|private
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|field|ownsShard
specifier|private
specifier|final
name|boolean
name|ownsShard
decl_stmt|;
DECL|field|toClose
specifier|private
specifier|final
name|Closeable
index|[]
name|toClose
decl_stmt|;
DECL|method|StoreCloseListener
specifier|public
name|StoreCloseListener
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|boolean
name|ownsShard
parameter_list|,
name|Closeable
modifier|...
name|toClose
parameter_list|)
block|{
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|this
operator|.
name|ownsShard
operator|=
name|ownsShard
expr_stmt|;
name|this
operator|.
name|toClose
operator|=
name|toClose
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|handle
specifier|public
name|void
name|handle
parameter_list|(
name|ShardLock
name|lock
parameter_list|)
block|{
try|try
block|{
assert|assert
name|lock
operator|.
name|getShardId
argument_list|()
operator|.
name|equals
argument_list|(
name|shardId
argument_list|)
operator|:
literal|"shard id mismatch, expected: "
operator|+
name|shardId
operator|+
literal|" but got: "
operator|+
name|lock
operator|.
name|getShardId
argument_list|()
assert|;
name|onShardClose
argument_list|(
name|lock
argument_list|,
name|ownsShard
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|toClose
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to close resource"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|BitsetCacheListener
specifier|private
specifier|static
specifier|final
class|class
name|BitsetCacheListener
implements|implements
name|BitsetFilterCache
operator|.
name|Listener
block|{
DECL|field|indexService
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|method|BitsetCacheListener
specifier|private
name|BitsetCacheListener
parameter_list|(
name|IndexService
name|indexService
parameter_list|)
block|{
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onCache
specifier|public
name|void
name|onCache
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|Accountable
name|accountable
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|long
name|ramBytesUsed
init|=
name|accountable
operator|!=
literal|null
condition|?
name|accountable
operator|.
name|ramBytesUsed
argument_list|()
else|:
literal|0L
decl_stmt|;
name|shard
operator|.
name|shardBitsetFilterCache
argument_list|()
operator|.
name|onCached
argument_list|(
name|ramBytesUsed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onRemoval
specifier|public
name|void
name|onRemoval
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|Accountable
name|accountable
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|long
name|ramBytesUsed
init|=
name|accountable
operator|!=
literal|null
condition|?
name|accountable
operator|.
name|ramBytesUsed
argument_list|()
else|:
literal|0L
decl_stmt|;
name|shard
operator|.
name|shardBitsetFilterCache
argument_list|()
operator|.
name|onRemoval
argument_list|(
name|ramBytesUsed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|FieldDataCacheListener
specifier|private
specifier|final
class|class
name|FieldDataCacheListener
implements|implements
name|IndexFieldDataCache
operator|.
name|Listener
block|{
DECL|field|indexService
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|method|FieldDataCacheListener
specifier|public
name|FieldDataCacheListener
parameter_list|(
name|IndexService
name|indexService
parameter_list|)
block|{
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onCache
specifier|public
name|void
name|onCache
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|Accountable
name|ramUsage
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|shard
operator|.
name|fieldData
argument_list|()
operator|.
name|onCache
argument_list|(
name|shardId
argument_list|,
name|fieldName
argument_list|,
name|ramUsage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onRemoval
specifier|public
name|void
name|onRemoval
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|String
name|fieldName
parameter_list|,
name|boolean
name|wasEvicted
parameter_list|,
name|long
name|sizeInBytes
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|shard
operator|.
name|fieldData
argument_list|()
operator|.
name|onRemoval
argument_list|(
name|shardId
argument_list|,
name|fieldName
argument_list|,
name|wasEvicted
argument_list|,
name|sizeInBytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Returns the filter associated with listed filtering aliases.      *<p>      * The list of filtering aliases should be obtained by calling MetaData.filteringAliases.      * Returns<tt>null</tt> if no filtering is required.</p>      */
DECL|method|aliasFilter
specifier|public
name|Query
name|aliasFilter
parameter_list|(
name|QueryShardContext
name|context
parameter_list|,
name|String
modifier|...
name|aliasNames
parameter_list|)
block|{
if|if
condition|(
name|aliasNames
operator|==
literal|null
operator|||
name|aliasNames
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|ImmutableOpenMap
argument_list|<
name|String
argument_list|,
name|AliasMetaData
argument_list|>
name|aliases
init|=
name|indexSettings
operator|.
name|getIndexMetaData
argument_list|()
operator|.
name|getAliases
argument_list|()
decl_stmt|;
if|if
condition|(
name|aliasNames
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|AliasMetaData
name|alias
init|=
name|aliases
operator|.
name|get
argument_list|(
name|aliasNames
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
comment|// This shouldn't happen unless alias disappeared after filteringAliases was called.
throw|throw
operator|new
name|InvalidAliasNameException
argument_list|(
name|index
argument_list|()
argument_list|,
name|aliasNames
index|[
literal|0
index|]
argument_list|,
literal|"Unknown alias name was passed to alias Filter"
argument_list|)
throw|;
block|}
return|return
name|parse
argument_list|(
name|alias
argument_list|,
name|context
argument_list|)
return|;
block|}
else|else
block|{
comment|// we need to bench here a bit, to see maybe it makes sense to use OrFilter
name|BooleanQuery
operator|.
name|Builder
name|combined
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|aliasName
range|:
name|aliasNames
control|)
block|{
name|AliasMetaData
name|alias
init|=
name|aliases
operator|.
name|get
argument_list|(
name|aliasName
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
comment|// This shouldn't happen unless alias disappeared after filteringAliases was called.
throw|throw
operator|new
name|InvalidAliasNameException
argument_list|(
name|indexSettings
operator|.
name|getIndex
argument_list|()
argument_list|,
name|aliasNames
index|[
literal|0
index|]
argument_list|,
literal|"Unknown alias name was passed to alias Filter"
argument_list|)
throw|;
block|}
name|Query
name|parsedFilter
init|=
name|parse
argument_list|(
name|alias
argument_list|,
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsedFilter
operator|!=
literal|null
condition|)
block|{
name|combined
operator|.
name|add
argument_list|(
name|parsedFilter
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The filter might be null only if filter was removed after filteringAliases was called
return|return
literal|null
return|;
block|}
block|}
return|return
name|combined
operator|.
name|build
argument_list|()
return|;
block|}
block|}
DECL|method|parse
specifier|private
name|Query
name|parse
parameter_list|(
name|AliasMetaData
name|alias
parameter_list|,
name|QueryShardContext
name|shardContext
parameter_list|)
block|{
if|if
condition|(
name|alias
operator|.
name|filter
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
name|byte
index|[]
name|filterSource
init|=
name|alias
operator|.
name|filter
argument_list|()
operator|.
name|uncompressed
argument_list|()
decl_stmt|;
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|filterSource
argument_list|)
operator|.
name|createParser
argument_list|(
name|filterSource
argument_list|)
init|)
block|{
name|ParsedQuery
name|parsedFilter
init|=
name|shardContext
operator|.
name|toFilter
argument_list|(
name|shardContext
operator|.
name|newParseContext
argument_list|(
name|parser
argument_list|)
operator|.
name|parseInnerQueryBuilder
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|parsedFilter
operator|==
literal|null
condition|?
literal|null
else|:
name|parsedFilter
operator|.
name|query
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|AliasFilterParsingException
argument_list|(
name|shardContext
operator|.
name|index
argument_list|()
argument_list|,
name|alias
operator|.
name|getAlias
argument_list|()
argument_list|,
literal|"Invalid alias filter"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|getMetaData
specifier|public
name|IndexMetaData
name|getMetaData
parameter_list|()
block|{
return|return
name|indexSettings
operator|.
name|getIndexMetaData
argument_list|()
return|;
block|}
DECL|method|updateMetaData
specifier|public
specifier|synchronized
name|void
name|updateMetaData
parameter_list|(
specifier|final
name|IndexMetaData
name|metadata
parameter_list|)
block|{
specifier|final
name|Translog
operator|.
name|Durability
name|oldTranslogDurability
init|=
name|indexSettings
operator|.
name|getTranslogDurability
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexSettings
operator|.
name|updateIndexMetaData
argument_list|(
name|metadata
argument_list|)
condition|)
block|{
for|for
control|(
specifier|final
name|IndexShard
name|shard
range|:
name|this
operator|.
name|shards
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|shard
operator|.
name|onSettingsChanged
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to notify shard about setting change"
argument_list|,
name|e
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|refreshTask
operator|.
name|getInterval
argument_list|()
operator|.
name|equals
argument_list|(
name|indexSettings
operator|.
name|getRefreshInterval
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
name|rescheduleRefreshTasks
argument_list|()
expr_stmt|;
block|}
specifier|final
name|Translog
operator|.
name|Durability
name|durability
init|=
name|indexSettings
operator|.
name|getTranslogDurability
argument_list|()
decl_stmt|;
if|if
condition|(
name|durability
operator|!=
name|oldTranslogDurability
condition|)
block|{
name|rescheduleFsyncTask
argument_list|(
name|durability
argument_list|)
expr_stmt|;
block|}
block|}
comment|// update primary terms
for|for
control|(
specifier|final
name|IndexShard
name|shard
range|:
name|this
operator|.
name|shards
operator|.
name|values
argument_list|()
control|)
block|{
name|shard
operator|.
name|updatePrimaryTerm
argument_list|(
name|metadata
operator|.
name|primaryTerm
argument_list|(
name|shard
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|rescheduleFsyncTask
specifier|private
name|void
name|rescheduleFsyncTask
parameter_list|(
name|Translog
operator|.
name|Durability
name|durability
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|fsyncTask
operator|!=
literal|null
condition|)
block|{
name|fsyncTask
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|fsyncTask
operator|=
name|durability
operator|==
name|Translog
operator|.
name|Durability
operator|.
name|REQUEST
condition|?
literal|null
else|:
operator|new
name|AsyncTranslogFSync
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|rescheduleRefreshTasks
specifier|private
name|void
name|rescheduleRefreshTasks
parameter_list|()
block|{
try|try
block|{
name|refreshTask
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|refreshTask
operator|=
operator|new
name|AsyncRefreshTask
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
DECL|interface|ShardStoreDeleter
specifier|public
interface|interface
name|ShardStoreDeleter
block|{
DECL|method|deleteShardStore
name|void
name|deleteShardStore
parameter_list|(
name|String
name|reason
parameter_list|,
name|ShardLock
name|lock
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|)
throws|throws
name|IOException
function_decl|;
DECL|method|addPendingDelete
name|void
name|addPendingDelete
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|IndexSettings
name|indexSettings
parameter_list|)
function_decl|;
block|}
DECL|method|getEngineFactory
specifier|final
name|EngineFactory
name|getEngineFactory
parameter_list|()
block|{
return|return
name|engineFactory
return|;
block|}
comment|// pkg private for testing
DECL|method|getSearcherWrapper
specifier|final
name|IndexSearcherWrapper
name|getSearcherWrapper
parameter_list|()
block|{
return|return
name|searcherWrapper
return|;
block|}
comment|// pkg private for testing
DECL|method|getIndexStore
specifier|final
name|IndexStore
name|getIndexStore
parameter_list|()
block|{
return|return
name|indexStore
return|;
block|}
comment|// pkg private for testing
DECL|method|maybeFSyncTranslogs
specifier|private
name|void
name|maybeFSyncTranslogs
parameter_list|()
block|{
if|if
condition|(
name|indexSettings
operator|.
name|getTranslogDurability
argument_list|()
operator|==
name|Translog
operator|.
name|Durability
operator|.
name|ASYNC
condition|)
block|{
for|for
control|(
name|IndexShard
name|shard
range|:
name|this
operator|.
name|shards
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|Translog
name|translog
init|=
name|shard
operator|.
name|getTranslog
argument_list|()
decl_stmt|;
if|if
condition|(
name|translog
operator|.
name|syncNeeded
argument_list|()
condition|)
block|{
name|translog
operator|.
name|sync
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EngineClosedException
decl||
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
comment|// fine - continue;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to sync translog"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|maybeRefreshEngine
specifier|private
name|void
name|maybeRefreshEngine
parameter_list|()
block|{
if|if
condition|(
name|indexSettings
operator|.
name|getRefreshInterval
argument_list|()
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|IndexShard
name|shard
range|:
name|this
operator|.
name|shards
operator|.
name|values
argument_list|()
control|)
block|{
switch|switch
condition|(
name|shard
operator|.
name|state
argument_list|()
condition|)
block|{
case|case
name|CREATED
case|:
case|case
name|RECOVERING
case|:
case|case
name|CLOSED
case|:
continue|continue;
case|case
name|POST_RECOVERY
case|:
case|case
name|STARTED
case|:
case|case
name|RELOCATED
case|:
try|try
block|{
if|if
condition|(
name|shard
operator|.
name|isRefreshNeeded
argument_list|()
condition|)
block|{
name|shard
operator|.
name|refresh
argument_list|(
literal|"schedule"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EngineClosedException
decl||
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
comment|// fine - continue;
block|}
continue|continue;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unknown state: "
operator|+
name|shard
operator|.
name|state
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|method|maybeUpdateGlobalCheckpoints
specifier|private
name|void
name|maybeUpdateGlobalCheckpoints
parameter_list|()
block|{
for|for
control|(
name|IndexShard
name|shard
range|:
name|this
operator|.
name|shards
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|routingEntry
argument_list|()
operator|.
name|primary
argument_list|()
condition|)
block|{
switch|switch
condition|(
name|shard
operator|.
name|state
argument_list|()
condition|)
block|{
case|case
name|CREATED
case|:
case|case
name|RECOVERING
case|:
case|case
name|CLOSED
case|:
case|case
name|RELOCATED
case|:
continue|continue;
case|case
name|POST_RECOVERY
case|:
case|case
name|STARTED
case|:
try|try
block|{
name|shard
operator|.
name|updateGlobalCheckpointOnPrimary
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EngineClosedException
decl||
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
comment|// fine - continue, the shard was concurrently closed on us.
block|}
continue|continue;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unknown state: "
operator|+
name|shard
operator|.
name|state
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
DECL|class|BaseAsyncTask
specifier|static
specifier|abstract
class|class
name|BaseAsyncTask
implements|implements
name|Runnable
implements|,
name|Closeable
block|{
DECL|field|indexService
specifier|protected
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|field|threadPool
specifier|protected
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|interval
specifier|private
specifier|final
name|TimeValue
name|interval
decl_stmt|;
DECL|field|scheduledFuture
specifier|private
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|scheduledFuture
decl_stmt|;
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|lastThrownException
specifier|private
specifier|volatile
name|Exception
name|lastThrownException
decl_stmt|;
DECL|method|BaseAsyncTask
name|BaseAsyncTask
parameter_list|(
name|IndexService
name|indexService
parameter_list|,
name|TimeValue
name|interval
parameter_list|)
block|{
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|indexService
operator|.
name|getThreadPool
argument_list|()
expr_stmt|;
name|this
operator|.
name|interval
operator|=
name|interval
expr_stmt|;
name|onTaskCompletion
argument_list|()
expr_stmt|;
block|}
DECL|method|mustReschedule
name|boolean
name|mustReschedule
parameter_list|()
block|{
comment|// don't re-schedule if its closed or if we don't have a single shard here..., we are done
return|return
name|indexService
operator|.
name|closed
operator|.
name|get
argument_list|()
operator|==
literal|false
operator|&&
name|closed
operator|.
name|get
argument_list|()
operator|==
literal|false
operator|&&
name|interval
operator|.
name|millis
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|method|onTaskCompletion
specifier|private
specifier|synchronized
name|void
name|onTaskCompletion
parameter_list|()
block|{
if|if
condition|(
name|mustReschedule
argument_list|()
condition|)
block|{
if|if
condition|(
name|indexService
operator|.
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|indexService
operator|.
name|logger
operator|.
name|trace
argument_list|(
literal|"scheduling {} every {}"
argument_list|,
name|toString
argument_list|()
argument_list|,
name|interval
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|scheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|interval
argument_list|,
name|getThreadPool
argument_list|()
argument_list|,
name|BaseAsyncTask
operator|.
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexService
operator|.
name|logger
operator|.
name|trace
argument_list|(
literal|"scheduled {} disabled"
argument_list|,
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|scheduledFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|isScheduled
name|boolean
name|isScheduled
parameter_list|()
block|{
return|return
name|scheduledFuture
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|runInternal
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
if|if
condition|(
name|lastThrownException
operator|==
literal|null
operator|||
name|sameException
argument_list|(
name|lastThrownException
argument_list|,
name|ex
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// prevent the annoying fact of logging the same stuff all the time with an interval of 1 sec will spam all your logs
name|indexService
operator|.
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to run task {} - suppressing re-occurring exceptions unless the exception changes"
argument_list|,
name|ex
argument_list|,
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|lastThrownException
operator|=
name|ex
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|onTaskCompletion
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|sameException
specifier|private
specifier|static
name|boolean
name|sameException
parameter_list|(
name|Exception
name|left
parameter_list|,
name|Exception
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|.
name|getClass
argument_list|()
operator|==
name|right
operator|.
name|getClass
argument_list|()
condition|)
block|{
if|if
condition|(
name|Objects
operator|.
name|equals
argument_list|(
name|left
operator|.
name|getMessage
argument_list|()
argument_list|,
name|right
operator|.
name|getMessage
argument_list|()
argument_list|)
condition|)
block|{
name|StackTraceElement
index|[]
name|stackTraceLeft
init|=
name|left
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
name|StackTraceElement
index|[]
name|stackTraceRight
init|=
name|right
operator|.
name|getStackTrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|stackTraceLeft
operator|.
name|length
operator|==
name|stackTraceRight
operator|.
name|length
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|stackTraceLeft
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stackTraceLeft
index|[
name|i
index|]
operator|.
name|equals
argument_list|(
name|stackTraceRight
index|[
name|i
index|]
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|runInternal
specifier|protected
specifier|abstract
name|void
name|runInternal
parameter_list|()
function_decl|;
DECL|method|getThreadPool
specifier|protected
name|String
name|getThreadPool
parameter_list|()
block|{
return|return
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
return|;
block|}
annotation|@
name|Override
DECL|method|close
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|()
block|{
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|scheduledFuture
argument_list|)
expr_stmt|;
name|scheduledFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|getInterval
name|TimeValue
name|getInterval
parameter_list|()
block|{
return|return
name|interval
return|;
block|}
DECL|method|isClosed
name|boolean
name|isClosed
parameter_list|()
block|{
return|return
name|this
operator|.
name|closed
operator|.
name|get
argument_list|()
return|;
block|}
block|}
comment|/**      * FSyncs the translog for all shards of this index in a defined interval.      */
DECL|class|AsyncTranslogFSync
specifier|final
specifier|static
class|class
name|AsyncTranslogFSync
extends|extends
name|BaseAsyncTask
block|{
DECL|method|AsyncTranslogFSync
name|AsyncTranslogFSync
parameter_list|(
name|IndexService
name|indexService
parameter_list|)
block|{
name|super
argument_list|(
name|indexService
argument_list|,
name|indexService
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getTranslogSyncInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getThreadPool
specifier|protected
name|String
name|getThreadPool
parameter_list|()
block|{
return|return
name|ThreadPool
operator|.
name|Names
operator|.
name|FLUSH
return|;
block|}
annotation|@
name|Override
DECL|method|runInternal
specifier|protected
name|void
name|runInternal
parameter_list|()
block|{
name|indexService
operator|.
name|maybeFSyncTranslogs
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"translog_sync"
return|;
block|}
block|}
DECL|class|AsyncRefreshTask
specifier|final
class|class
name|AsyncRefreshTask
extends|extends
name|BaseAsyncTask
block|{
DECL|method|AsyncRefreshTask
name|AsyncRefreshTask
parameter_list|(
name|IndexService
name|indexService
parameter_list|)
block|{
name|super
argument_list|(
name|indexService
argument_list|,
name|indexService
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getRefreshInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|runInternal
specifier|protected
name|void
name|runInternal
parameter_list|()
block|{
name|indexService
operator|.
name|maybeRefreshEngine
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getThreadPool
specifier|protected
name|String
name|getThreadPool
parameter_list|()
block|{
return|return
name|ThreadPool
operator|.
name|Names
operator|.
name|REFRESH
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"refresh"
return|;
block|}
block|}
DECL|class|AsyncGlobalCheckpointTask
specifier|final
class|class
name|AsyncGlobalCheckpointTask
extends|extends
name|BaseAsyncTask
block|{
DECL|method|AsyncGlobalCheckpointTask
name|AsyncGlobalCheckpointTask
parameter_list|(
name|IndexService
name|indexService
parameter_list|)
block|{
name|super
argument_list|(
name|indexService
argument_list|,
name|indexService
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getGlobalCheckpointInterval
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|runInternal
specifier|protected
name|void
name|runInternal
parameter_list|()
block|{
name|indexService
operator|.
name|maybeUpdateGlobalCheckpoints
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"global_checkpoint"
return|;
block|}
block|}
DECL|method|getRefreshTask
name|AsyncRefreshTask
name|getRefreshTask
parameter_list|()
block|{
comment|// for tests
return|return
name|refreshTask
return|;
block|}
DECL|method|getFsyncTask
name|AsyncTranslogFSync
name|getFsyncTask
parameter_list|()
block|{
comment|// for tests
return|return
name|fsyncTask
return|;
block|}
DECL|method|getGlobalCheckpointTask
name|AsyncGlobalCheckpointTask
name|getGlobalCheckpointTask
parameter_list|()
block|{
comment|// for tests
return|return
name|globalCheckpointTask
return|;
block|}
block|}
end_class

end_unit

