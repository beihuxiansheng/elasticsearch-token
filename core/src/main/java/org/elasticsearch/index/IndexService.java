begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanClause
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|BooleanQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Accountable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|AliasMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableOpenMap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|NodeEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|ShardLock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|analysis
operator|.
name|AnalysisService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|IndexCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|bitset
operator|.
name|BitsetFilterCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|FieldDataType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldDataCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldDataService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MappedFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|IndexQueryParserService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|ParsedQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|similarity
operator|.
name|SimilarityService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|IndexStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Closeable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|MapBuilder
operator|.
name|newMapBuilder
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|IndexService
specifier|public
class|class
name|IndexService
extends|extends
name|AbstractIndexComponent
implements|implements
name|IndexComponent
implements|,
name|Iterable
argument_list|<
name|IndexShard
argument_list|>
block|{
DECL|field|eventListener
specifier|private
specifier|final
name|IndexEventListener
name|eventListener
decl_stmt|;
DECL|field|analysisService
specifier|private
specifier|final
name|AnalysisService
name|analysisService
decl_stmt|;
DECL|field|indexFieldData
specifier|private
specifier|final
name|IndexFieldDataService
name|indexFieldData
decl_stmt|;
DECL|field|bitsetFilterCache
specifier|private
specifier|final
name|BitsetFilterCache
name|bitsetFilterCache
decl_stmt|;
DECL|field|nodeEnv
specifier|private
specifier|final
name|NodeEnvironment
name|nodeEnv
decl_stmt|;
DECL|field|indicesServices
specifier|private
specifier|final
name|IndicesService
name|indicesServices
decl_stmt|;
DECL|field|indexServicesProvider
specifier|private
specifier|final
name|IndexServicesProvider
name|indexServicesProvider
decl_stmt|;
DECL|field|indexStore
specifier|private
specifier|final
name|IndexStore
name|indexStore
decl_stmt|;
DECL|field|shards
specifier|private
specifier|volatile
name|Map
argument_list|<
name|Integer
argument_list|,
name|IndexShard
argument_list|>
name|shards
init|=
name|emptyMap
argument_list|()
decl_stmt|;
DECL|field|closed
specifier|private
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|deleted
specifier|private
specifier|final
name|AtomicBoolean
name|deleted
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|indexMetaData
specifier|private
specifier|volatile
name|IndexMetaData
name|indexMetaData
decl_stmt|;
DECL|field|indexSettings
specifier|private
specifier|final
name|IndexSettings
name|indexSettings
decl_stmt|;
annotation|@
name|Inject
DECL|method|IndexService
specifier|public
name|IndexService
parameter_list|(
name|IndexSettings
name|indexSettings
parameter_list|,
name|IndexMetaData
name|indexMetaData
parameter_list|,
name|NodeEnvironment
name|nodeEnv
parameter_list|,
name|AnalysisService
name|analysisService
parameter_list|,
name|IndexFieldDataService
name|indexFieldData
parameter_list|,
name|BitsetFilterCache
name|bitSetFilterCache
parameter_list|,
name|IndicesService
name|indicesServices
parameter_list|,
name|IndexServicesProvider
name|indexServicesProvider
parameter_list|,
name|IndexStore
name|indexStore
parameter_list|,
name|IndexEventListener
name|eventListener
parameter_list|)
block|{
name|super
argument_list|(
name|indexSettings
argument_list|)
expr_stmt|;
assert|assert
name|indexMetaData
operator|!=
literal|null
assert|;
name|this
operator|.
name|indexSettings
operator|=
name|indexSettings
expr_stmt|;
name|this
operator|.
name|analysisService
operator|=
name|analysisService
expr_stmt|;
name|this
operator|.
name|indexFieldData
operator|=
name|indexFieldData
expr_stmt|;
name|this
operator|.
name|bitsetFilterCache
operator|=
name|bitSetFilterCache
expr_stmt|;
name|this
operator|.
name|indicesServices
operator|=
name|indicesServices
expr_stmt|;
name|this
operator|.
name|eventListener
operator|=
name|eventListener
expr_stmt|;
name|this
operator|.
name|nodeEnv
operator|=
name|nodeEnv
expr_stmt|;
name|this
operator|.
name|indexServicesProvider
operator|=
name|indexServicesProvider
expr_stmt|;
name|this
operator|.
name|indexStore
operator|=
name|indexStore
expr_stmt|;
name|this
operator|.
name|indexMetaData
operator|=
name|indexMetaData
expr_stmt|;
name|indexFieldData
operator|.
name|setListener
argument_list|(
operator|new
name|FieldDataCacheListener
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|bitSetFilterCache
operator|.
name|setListener
argument_list|(
operator|new
name|BitsetCacheListener
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|numberOfShards
specifier|public
name|int
name|numberOfShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getIndexEventListener
specifier|public
name|IndexEventListener
name|getIndexEventListener
parameter_list|()
block|{
return|return
name|this
operator|.
name|eventListener
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|IndexShard
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|shards
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|hasShard
specifier|public
name|boolean
name|hasShard
parameter_list|(
name|int
name|shardId
parameter_list|)
block|{
return|return
name|shards
operator|.
name|containsKey
argument_list|(
name|shardId
argument_list|)
return|;
block|}
comment|/**      * Return the shard with the provided id, or null if there is no such shard.      */
annotation|@
name|Nullable
DECL|method|getShardOrNull
specifier|public
name|IndexShard
name|getShardOrNull
parameter_list|(
name|int
name|shardId
parameter_list|)
block|{
return|return
name|shards
operator|.
name|get
argument_list|(
name|shardId
argument_list|)
return|;
block|}
comment|/**      * Return the shard with the provided id, or throw an exception if it doesn't exist.      */
DECL|method|getShard
specifier|public
name|IndexShard
name|getShard
parameter_list|(
name|int
name|shardId
parameter_list|)
block|{
name|IndexShard
name|indexShard
init|=
name|getShardOrNull
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ShardNotFoundException
argument_list|(
operator|new
name|ShardId
argument_list|(
name|index
argument_list|()
argument_list|,
name|shardId
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|indexShard
return|;
block|}
DECL|method|shardIds
specifier|public
name|Set
argument_list|<
name|Integer
argument_list|>
name|shardIds
parameter_list|()
block|{
return|return
name|shards
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|cache
specifier|public
name|IndexCache
name|cache
parameter_list|()
block|{
return|return
name|indexServicesProvider
operator|.
name|getIndexCache
argument_list|()
return|;
block|}
DECL|method|fieldData
specifier|public
name|IndexFieldDataService
name|fieldData
parameter_list|()
block|{
return|return
name|indexFieldData
return|;
block|}
DECL|method|bitsetFilterCache
specifier|public
name|BitsetFilterCache
name|bitsetFilterCache
parameter_list|()
block|{
return|return
name|bitsetFilterCache
return|;
block|}
DECL|method|analysisService
specifier|public
name|AnalysisService
name|analysisService
parameter_list|()
block|{
return|return
name|this
operator|.
name|analysisService
return|;
block|}
DECL|method|mapperService
specifier|public
name|MapperService
name|mapperService
parameter_list|()
block|{
return|return
name|indexServicesProvider
operator|.
name|getMapperService
argument_list|()
return|;
block|}
DECL|method|queryParserService
specifier|public
name|IndexQueryParserService
name|queryParserService
parameter_list|()
block|{
return|return
name|indexServicesProvider
operator|.
name|getQueryParserService
argument_list|()
return|;
block|}
DECL|method|similarityService
specifier|public
name|SimilarityService
name|similarityService
parameter_list|()
block|{
return|return
name|indexServicesProvider
operator|.
name|getSimilarityService
argument_list|()
return|;
block|}
DECL|method|close
specifier|public
specifier|synchronized
name|void
name|close
parameter_list|(
specifier|final
name|String
name|reason
parameter_list|,
name|boolean
name|delete
parameter_list|)
block|{
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|deleted
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
name|delete
argument_list|)
expr_stmt|;
specifier|final
name|Set
argument_list|<
name|Integer
argument_list|>
name|shardIds
init|=
name|shardIds
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|int
name|shardId
range|:
name|shardIds
control|)
block|{
try|try
block|{
name|removeShard
argument_list|(
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to close shard"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|indexUUID
specifier|public
name|String
name|indexUUID
parameter_list|()
block|{
return|return
name|indexSettings
operator|.
name|getUUID
argument_list|()
return|;
block|}
comment|// NOTE: O(numShards) cost, but numShards should be smallish?
DECL|method|getAvgShardSizeInBytes
specifier|private
name|long
name|getAvgShardSizeInBytes
parameter_list|()
throws|throws
name|IOException
block|{
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|IndexShard
name|indexShard
range|:
name|this
control|)
block|{
name|sum
operator|+=
name|indexShard
operator|.
name|store
argument_list|()
operator|.
name|stats
argument_list|()
operator|.
name|sizeInBytes
argument_list|()
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|1L
return|;
block|}
else|else
block|{
return|return
name|sum
operator|/
name|count
return|;
block|}
block|}
DECL|method|createShard
specifier|public
specifier|synchronized
name|IndexShard
name|createShard
parameter_list|(
name|int
name|sShardId
parameter_list|,
name|ShardRouting
name|routing
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|boolean
name|primary
init|=
name|routing
operator|.
name|primary
argument_list|()
decl_stmt|;
comment|/*          * TODO: we execute this in parallel but it's a synced method. Yet, we might          * be able to serialize the execution via the cluster state in the future. for now we just          * keep it synced.          */
if|if
condition|(
name|closed
operator|.
name|get
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't create shard ["
operator|+
name|index
argument_list|()
operator|.
name|name
argument_list|()
operator|+
literal|"]["
operator|+
name|sShardId
operator|+
literal|"], closed"
argument_list|)
throw|;
block|}
specifier|final
name|Settings
name|indexSettings
init|=
name|this
operator|.
name|indexSettings
operator|.
name|getSettings
argument_list|()
decl_stmt|;
specifier|final
name|ShardId
name|shardId
init|=
operator|new
name|ShardId
argument_list|(
name|index
argument_list|()
argument_list|,
name|sShardId
argument_list|)
decl_stmt|;
name|boolean
name|success
init|=
literal|false
decl_stmt|;
name|Store
name|store
init|=
literal|null
decl_stmt|;
name|IndexShard
name|indexShard
init|=
literal|null
decl_stmt|;
specifier|final
name|ShardLock
name|lock
init|=
name|nodeEnv
operator|.
name|shardLock
argument_list|(
name|shardId
argument_list|,
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toMillis
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|eventListener
operator|.
name|beforeIndexShardCreated
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|ShardPath
name|path
decl_stmt|;
try|try
block|{
name|path
operator|=
name|ShardPath
operator|.
name|loadShardPath
argument_list|(
name|logger
argument_list|,
name|nodeEnv
argument_list|,
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IllegalStateException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"{} failed to load shard path, trying to remove leftover"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|ShardPath
operator|.
name|deleteLeftoverShardDirectory
argument_list|(
name|logger
argument_list|,
name|nodeEnv
argument_list|,
name|lock
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|)
expr_stmt|;
name|path
operator|=
name|ShardPath
operator|.
name|loadShardPath
argument_list|(
name|logger
argument_list|,
name|nodeEnv
argument_list|,
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|t
operator|.
name|addSuppressed
argument_list|(
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
comment|// TODO: we should, instead, hold a "bytes reserved" of how large we anticipate this shard will be, e.g. for a shard
comment|// that's being relocated/replicated we know how large it will become once it's done copying:
comment|// Count up how many shards are currently on each data path:
name|Map
argument_list|<
name|Path
argument_list|,
name|Integer
argument_list|>
name|dataPathToShardCount
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexShard
name|shard
range|:
name|this
control|)
block|{
name|Path
name|dataPath
init|=
name|shard
operator|.
name|shardPath
argument_list|()
operator|.
name|getRootStatePath
argument_list|()
decl_stmt|;
name|Integer
name|curCount
init|=
name|dataPathToShardCount
operator|.
name|get
argument_list|(
name|dataPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|curCount
operator|==
literal|null
condition|)
block|{
name|curCount
operator|=
literal|0
expr_stmt|;
block|}
name|dataPathToShardCount
operator|.
name|put
argument_list|(
name|dataPath
argument_list|,
name|curCount
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|ShardPath
operator|.
name|selectNewPathForShard
argument_list|(
name|nodeEnv
argument_list|,
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|routing
operator|.
name|getExpectedShardSize
argument_list|()
operator|==
name|ShardRouting
operator|.
name|UNAVAILABLE_EXPECTED_SHARD_SIZE
condition|?
name|getAvgShardSizeInBytes
argument_list|()
else|:
name|routing
operator|.
name|getExpectedShardSize
argument_list|()
argument_list|,
name|dataPathToShardCount
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"{} creating using a new path [{}]"
argument_list|,
name|shardId
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} creating using an existing path [{}]"
argument_list|,
name|shardId
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shards
operator|.
name|containsKey
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IndexShardAlreadyExistsException
argument_list|(
name|shardId
operator|+
literal|" already exists"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"creating shard_id {}"
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
comment|// if we are on a shared FS we only own the shard (ie. we can safely delete it) if we are the primary.
specifier|final
name|boolean
name|canDeleteShardContent
init|=
name|IndexMetaData
operator|.
name|isOnSharedFilesystem
argument_list|(
name|indexSettings
argument_list|)
operator|==
literal|false
operator|||
operator|(
name|primary
operator|&&
name|IndexMetaData
operator|.
name|isOnSharedFilesystem
argument_list|(
name|indexSettings
argument_list|)
operator|)
decl_stmt|;
name|store
operator|=
operator|new
name|Store
argument_list|(
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|indexStore
operator|.
name|newDirectoryService
argument_list|(
name|path
argument_list|)
argument_list|,
name|lock
argument_list|,
operator|new
name|StoreCloseListener
argument_list|(
name|shardId
argument_list|,
name|canDeleteShardContent
argument_list|,
parameter_list|()
lambda|->
name|indexServicesProvider
operator|.
name|getIndicesQueryCache
argument_list|()
operator|.
name|onClose
argument_list|(
name|shardId
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|useShadowEngine
argument_list|(
name|primary
argument_list|,
name|indexSettings
argument_list|)
condition|)
block|{
name|indexShard
operator|=
operator|new
name|ShadowIndexShard
argument_list|(
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|path
argument_list|,
name|store
argument_list|,
name|indexServicesProvider
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexShard
operator|=
operator|new
name|IndexShard
argument_list|(
name|shardId
argument_list|,
name|this
operator|.
name|indexSettings
argument_list|,
name|path
argument_list|,
name|store
argument_list|,
name|indexServicesProvider
argument_list|)
expr_stmt|;
block|}
name|eventListener
operator|.
name|indexShardStateChanged
argument_list|(
name|indexShard
argument_list|,
literal|null
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|,
literal|"shard created"
argument_list|)
expr_stmt|;
name|eventListener
operator|.
name|afterIndexShardCreated
argument_list|(
name|indexShard
argument_list|)
expr_stmt|;
name|shards
operator|=
name|newMapBuilder
argument_list|(
name|shards
argument_list|)
operator|.
name|put
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|,
name|indexShard
argument_list|)
operator|.
name|immutableMap
argument_list|()
expr_stmt|;
name|success
operator|=
literal|true
expr_stmt|;
return|return
name|indexShard
return|;
block|}
finally|finally
block|{
if|if
condition|(
name|success
operator|==
literal|false
condition|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|closeShard
argument_list|(
literal|"initialization failed"
argument_list|,
name|shardId
argument_list|,
name|indexShard
argument_list|,
name|store
argument_list|,
name|eventListener
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|useShadowEngine
specifier|static
name|boolean
name|useShadowEngine
parameter_list|(
name|boolean
name|primary
parameter_list|,
name|Settings
name|indexSettings
parameter_list|)
block|{
return|return
name|primary
operator|==
literal|false
operator|&&
name|IndexMetaData
operator|.
name|isIndexUsingShadowReplicas
argument_list|(
name|indexSettings
argument_list|)
return|;
block|}
DECL|method|removeShard
specifier|public
specifier|synchronized
name|void
name|removeShard
parameter_list|(
name|int
name|shardId
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
specifier|final
name|ShardId
name|sId
init|=
operator|new
name|ShardId
argument_list|(
name|index
argument_list|()
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
specifier|final
name|IndexShard
name|indexShard
decl_stmt|;
if|if
condition|(
name|shards
operator|.
name|containsKey
argument_list|(
name|shardId
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] closing... (reason: [{}])"
argument_list|,
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|HashMap
argument_list|<
name|Integer
argument_list|,
name|IndexShard
argument_list|>
name|newShards
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|(
name|shards
argument_list|)
decl_stmt|;
name|indexShard
operator|=
name|newShards
operator|.
name|remove
argument_list|(
name|shardId
argument_list|)
expr_stmt|;
name|shards
operator|=
name|unmodifiableMap
argument_list|(
name|newShards
argument_list|)
expr_stmt|;
name|closeShard
argument_list|(
name|reason
argument_list|,
name|sId
argument_list|,
name|indexShard
argument_list|,
name|indexShard
operator|.
name|store
argument_list|()
argument_list|,
name|indexShard
operator|.
name|getIndexEventListener
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] closed (reason: [{}])"
argument_list|,
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
DECL|method|closeShard
specifier|private
name|void
name|closeShard
parameter_list|(
name|String
name|reason
parameter_list|,
name|ShardId
name|sId
parameter_list|,
name|IndexShard
name|indexShard
parameter_list|,
name|Store
name|store
parameter_list|,
name|IndexEventListener
name|listener
parameter_list|)
block|{
specifier|final
name|int
name|shardId
init|=
name|sId
operator|.
name|id
argument_list|()
decl_stmt|;
specifier|final
name|Settings
name|indexSettings
init|=
name|this
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getSettings
argument_list|()
decl_stmt|;
try|try
block|{
try|try
block|{
name|listener
operator|.
name|beforeIndexShardClosed
argument_list|(
name|sId
argument_list|,
name|indexShard
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// this logic is tricky, we want to close the engine so we rollback the changes done to it
comment|// and close the shard so no operations are allowed to it
if|if
condition|(
name|indexShard
operator|!=
literal|null
condition|)
block|{
try|try
block|{
specifier|final
name|boolean
name|flushEngine
init|=
name|deleted
operator|.
name|get
argument_list|()
operator|==
literal|false
operator|&&
name|closed
operator|.
name|get
argument_list|()
decl_stmt|;
comment|// only flush we are we closed (closed index or shutdown) and if we are not deleted
name|indexShard
operator|.
name|close
argument_list|(
name|reason
argument_list|,
name|flushEngine
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] failed to close index shard"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
comment|// ignore
block|}
block|}
comment|// call this before we close the store, so we can release resources for it
name|listener
operator|.
name|afterIndexShardClosed
argument_list|(
name|sId
argument_list|,
name|indexShard
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
try|try
block|{
name|store
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to close store on shard removal (reason: [{}])"
argument_list|,
name|e
argument_list|,
name|shardId
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|onShardClose
specifier|private
name|void
name|onShardClose
parameter_list|(
name|ShardLock
name|lock
parameter_list|,
name|boolean
name|ownsShard
parameter_list|)
block|{
if|if
condition|(
name|deleted
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// we remove that shards content if this index has been deleted
specifier|final
name|Settings
name|indexSettings
init|=
name|this
operator|.
name|getIndexSettings
argument_list|()
operator|.
name|getSettings
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|ownsShard
condition|)
block|{
try|try
block|{
name|eventListener
operator|.
name|beforeIndexShardDeleted
argument_list|(
name|lock
operator|.
name|getShardId
argument_list|()
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|indicesServices
operator|.
name|deleteShardStore
argument_list|(
literal|"delete index"
argument_list|,
name|lock
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|eventListener
operator|.
name|afterIndexShardDeleted
argument_list|(
name|lock
operator|.
name|getShardId
argument_list|()
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|indicesServices
operator|.
name|addPendingDelete
argument_list|(
name|lock
operator|.
name|getShardId
argument_list|()
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] failed to delete shard content - scheduled a retry"
argument_list|,
name|e
argument_list|,
name|lock
operator|.
name|getShardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getIndexServices
specifier|public
name|IndexServicesProvider
name|getIndexServices
parameter_list|()
block|{
return|return
name|indexServicesProvider
return|;
block|}
DECL|method|getIndexSettings
specifier|public
name|IndexSettings
name|getIndexSettings
parameter_list|()
block|{
return|return
name|indexSettings
return|;
block|}
DECL|class|StoreCloseListener
specifier|private
class|class
name|StoreCloseListener
implements|implements
name|Store
operator|.
name|OnClose
block|{
DECL|field|shardId
specifier|private
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|field|ownsShard
specifier|private
specifier|final
name|boolean
name|ownsShard
decl_stmt|;
DECL|field|toClose
specifier|private
specifier|final
name|Closeable
index|[]
name|toClose
decl_stmt|;
DECL|method|StoreCloseListener
specifier|public
name|StoreCloseListener
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|boolean
name|ownsShard
parameter_list|,
name|Closeable
modifier|...
name|toClose
parameter_list|)
block|{
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|this
operator|.
name|ownsShard
operator|=
name|ownsShard
expr_stmt|;
name|this
operator|.
name|toClose
operator|=
name|toClose
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|handle
specifier|public
name|void
name|handle
parameter_list|(
name|ShardLock
name|lock
parameter_list|)
block|{
try|try
block|{
assert|assert
name|lock
operator|.
name|getShardId
argument_list|()
operator|.
name|equals
argument_list|(
name|shardId
argument_list|)
operator|:
literal|"shard id mismatch, expected: "
operator|+
name|shardId
operator|+
literal|" but got: "
operator|+
name|lock
operator|.
name|getShardId
argument_list|()
assert|;
name|onShardClose
argument_list|(
name|lock
argument_list|,
name|ownsShard
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
try|try
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|toClose
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to close resource"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|BitsetCacheListener
specifier|private
specifier|static
specifier|final
class|class
name|BitsetCacheListener
implements|implements
name|BitsetFilterCache
operator|.
name|Listener
block|{
DECL|field|indexService
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|method|BitsetCacheListener
specifier|private
name|BitsetCacheListener
parameter_list|(
name|IndexService
name|indexService
parameter_list|)
block|{
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onCache
specifier|public
name|void
name|onCache
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|Accountable
name|accountable
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|long
name|ramBytesUsed
init|=
name|accountable
operator|!=
literal|null
condition|?
name|accountable
operator|.
name|ramBytesUsed
argument_list|()
else|:
literal|0l
decl_stmt|;
name|shard
operator|.
name|shardBitsetFilterCache
argument_list|()
operator|.
name|onCached
argument_list|(
name|ramBytesUsed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onRemoval
specifier|public
name|void
name|onRemoval
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|Accountable
name|accountable
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|long
name|ramBytesUsed
init|=
name|accountable
operator|!=
literal|null
condition|?
name|accountable
operator|.
name|ramBytesUsed
argument_list|()
else|:
literal|0l
decl_stmt|;
name|shard
operator|.
name|shardBitsetFilterCache
argument_list|()
operator|.
name|onRemoval
argument_list|(
name|ramBytesUsed
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|FieldDataCacheListener
specifier|private
specifier|final
class|class
name|FieldDataCacheListener
implements|implements
name|IndexFieldDataCache
operator|.
name|Listener
block|{
DECL|field|indexService
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|method|FieldDataCacheListener
specifier|public
name|FieldDataCacheListener
parameter_list|(
name|IndexService
name|indexService
parameter_list|)
block|{
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onCache
specifier|public
name|void
name|onCache
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|MappedFieldType
operator|.
name|Names
name|fieldNames
parameter_list|,
name|FieldDataType
name|fieldDataType
parameter_list|,
name|Accountable
name|ramUsage
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|shard
operator|.
name|fieldData
argument_list|()
operator|.
name|onCache
argument_list|(
name|shardId
argument_list|,
name|fieldNames
argument_list|,
name|fieldDataType
argument_list|,
name|ramUsage
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onRemoval
specifier|public
name|void
name|onRemoval
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|MappedFieldType
operator|.
name|Names
name|fieldNames
parameter_list|,
name|FieldDataType
name|fieldDataType
parameter_list|,
name|boolean
name|wasEvicted
parameter_list|,
name|long
name|sizeInBytes
parameter_list|)
block|{
if|if
condition|(
name|shardId
operator|!=
literal|null
condition|)
block|{
specifier|final
name|IndexShard
name|shard
init|=
name|indexService
operator|.
name|getShardOrNull
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shard
operator|!=
literal|null
condition|)
block|{
name|shard
operator|.
name|fieldData
argument_list|()
operator|.
name|onRemoval
argument_list|(
name|shardId
argument_list|,
name|fieldNames
argument_list|,
name|fieldDataType
argument_list|,
name|wasEvicted
argument_list|,
name|sizeInBytes
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Returns the filter associated with listed filtering aliases.      *<p>      * The list of filtering aliases should be obtained by calling MetaData.filteringAliases.      * Returns<tt>null</tt> if no filtering is required.</p>      */
DECL|method|aliasFilter
specifier|public
name|Query
name|aliasFilter
parameter_list|(
name|String
modifier|...
name|aliasNames
parameter_list|)
block|{
if|if
condition|(
name|aliasNames
operator|==
literal|null
operator|||
name|aliasNames
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
specifier|final
name|IndexQueryParserService
name|indexQueryParser
init|=
name|queryParserService
argument_list|()
decl_stmt|;
specifier|final
name|ImmutableOpenMap
argument_list|<
name|String
argument_list|,
name|AliasMetaData
argument_list|>
name|aliases
init|=
name|this
operator|.
name|indexMetaData
operator|.
name|getAliases
argument_list|()
decl_stmt|;
if|if
condition|(
name|aliasNames
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|AliasMetaData
name|alias
init|=
name|aliases
operator|.
name|get
argument_list|(
name|aliasNames
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
comment|// This shouldn't happen unless alias disappeared after filteringAliases was called.
throw|throw
operator|new
name|InvalidAliasNameException
argument_list|(
name|index
argument_list|()
argument_list|,
name|aliasNames
index|[
literal|0
index|]
argument_list|,
literal|"Unknown alias name was passed to alias Filter"
argument_list|)
throw|;
block|}
return|return
name|parse
argument_list|(
name|alias
argument_list|,
name|indexQueryParser
argument_list|)
return|;
block|}
else|else
block|{
comment|// we need to bench here a bit, to see maybe it makes sense to use OrFilter
name|BooleanQuery
operator|.
name|Builder
name|combined
init|=
operator|new
name|BooleanQuery
operator|.
name|Builder
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|aliasName
range|:
name|aliasNames
control|)
block|{
name|AliasMetaData
name|alias
init|=
name|aliases
operator|.
name|get
argument_list|(
name|aliasName
argument_list|)
decl_stmt|;
if|if
condition|(
name|alias
operator|==
literal|null
condition|)
block|{
comment|// This shouldn't happen unless alias disappeared after filteringAliases was called.
throw|throw
operator|new
name|InvalidAliasNameException
argument_list|(
name|indexQueryParser
operator|.
name|index
argument_list|()
argument_list|,
name|aliasNames
index|[
literal|0
index|]
argument_list|,
literal|"Unknown alias name was passed to alias Filter"
argument_list|)
throw|;
block|}
name|Query
name|parsedFilter
init|=
name|parse
argument_list|(
name|alias
argument_list|,
name|indexQueryParser
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsedFilter
operator|!=
literal|null
condition|)
block|{
name|combined
operator|.
name|add
argument_list|(
name|parsedFilter
argument_list|,
name|BooleanClause
operator|.
name|Occur
operator|.
name|SHOULD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The filter might be null only if filter was removed after filteringAliases was called
return|return
literal|null
return|;
block|}
block|}
return|return
name|combined
operator|.
name|build
argument_list|()
return|;
block|}
block|}
DECL|method|parse
specifier|private
name|Query
name|parse
parameter_list|(
name|AliasMetaData
name|alias
parameter_list|,
name|IndexQueryParserService
name|indexQueryParser
parameter_list|)
block|{
if|if
condition|(
name|alias
operator|.
name|filter
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
try|try
block|{
name|byte
index|[]
name|filterSource
init|=
name|alias
operator|.
name|filter
argument_list|()
operator|.
name|uncompressed
argument_list|()
decl_stmt|;
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|filterSource
argument_list|)
operator|.
name|createParser
argument_list|(
name|filterSource
argument_list|)
init|)
block|{
name|ParsedQuery
name|parsedFilter
init|=
name|indexQueryParser
operator|.
name|parseInnerFilter
argument_list|(
name|parser
argument_list|)
decl_stmt|;
return|return
name|parsedFilter
operator|==
literal|null
condition|?
literal|null
else|:
name|parsedFilter
operator|.
name|query
argument_list|()
return|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|AliasFilterParsingException
argument_list|(
name|indexQueryParser
operator|.
name|index
argument_list|()
argument_list|,
name|alias
operator|.
name|getAlias
argument_list|()
argument_list|,
literal|"Invalid alias filter"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|getMetaData
specifier|public
name|IndexMetaData
name|getMetaData
parameter_list|()
block|{
return|return
name|indexMetaData
return|;
block|}
DECL|method|updateMetaData
specifier|public
specifier|synchronized
name|void
name|updateMetaData
parameter_list|(
specifier|final
name|IndexMetaData
name|metadata
parameter_list|)
block|{
name|this
operator|.
name|indexMetaData
operator|=
name|metadata
expr_stmt|;
name|Settings
name|settings
init|=
name|metadata
operator|.
name|getSettings
argument_list|()
decl_stmt|;
if|if
condition|(
name|this
operator|.
name|indexSettings
operator|.
name|updateIndexSettings
argument_list|(
name|metadata
operator|.
name|getSettings
argument_list|()
argument_list|)
condition|)
block|{
for|for
control|(
specifier|final
name|IndexShard
name|shard
range|:
name|this
operator|.
name|shards
operator|.
name|values
argument_list|()
control|)
block|{
try|try
block|{
name|shard
operator|.
name|onRefreshSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to refresh shard settings"
argument_list|,
name|e
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
try|try
block|{
name|indexStore
operator|.
name|onRefreshSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to refresh index store settings"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

