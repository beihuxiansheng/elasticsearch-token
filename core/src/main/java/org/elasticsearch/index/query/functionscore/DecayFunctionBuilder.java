begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.query.functionscore
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|functionscore
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|LeafReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Explanation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParsingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|GeoDistance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|GeoPoint
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|GeoUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|search
operator|.
name|function
operator|.
name|CombineFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|search
operator|.
name|function
operator|.
name|LeafScoreFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|search
operator|.
name|function
operator|.
name|ScoreFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|DistanceUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|NamedXContentRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexGeoPointFieldData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexNumericFieldData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|MultiGeoPointValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|NumericDoubleValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|SortedNumericDoubleValues
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|BaseGeoPointFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|DateFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MappedFieldType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|NumberFieldMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryShardContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|MultiValueMode
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_class
DECL|class|DecayFunctionBuilder
specifier|public
specifier|abstract
class|class
name|DecayFunctionBuilder
parameter_list|<
name|DFB
extends|extends
name|DecayFunctionBuilder
parameter_list|<
name|DFB
parameter_list|>
parameter_list|>
extends|extends
name|ScoreFunctionBuilder
argument_list|<
name|DFB
argument_list|>
block|{
DECL|field|ORIGIN
specifier|protected
specifier|static
specifier|final
name|String
name|ORIGIN
init|=
literal|"origin"
decl_stmt|;
DECL|field|SCALE
specifier|protected
specifier|static
specifier|final
name|String
name|SCALE
init|=
literal|"scale"
decl_stmt|;
DECL|field|DECAY
specifier|protected
specifier|static
specifier|final
name|String
name|DECAY
init|=
literal|"decay"
decl_stmt|;
DECL|field|OFFSET
specifier|protected
specifier|static
specifier|final
name|String
name|OFFSET
init|=
literal|"offset"
decl_stmt|;
DECL|field|DEFAULT_DECAY
specifier|public
specifier|static
name|double
name|DEFAULT_DECAY
init|=
literal|0.5
decl_stmt|;
DECL|field|DEFAULT_MULTI_VALUE_MODE
specifier|public
specifier|static
name|MultiValueMode
name|DEFAULT_MULTI_VALUE_MODE
init|=
name|MultiValueMode
operator|.
name|MIN
decl_stmt|;
DECL|field|fieldName
specifier|private
specifier|final
name|String
name|fieldName
decl_stmt|;
comment|//parsing of origin, scale, offset and decay depends on the field type, delayed to the data node that has the mapping for it
DECL|field|functionBytes
specifier|private
specifier|final
name|BytesReference
name|functionBytes
decl_stmt|;
DECL|field|multiValueMode
specifier|private
name|MultiValueMode
name|multiValueMode
init|=
name|DEFAULT_MULTI_VALUE_MODE
decl_stmt|;
comment|/**      * Convenience constructor that converts its parameters into json to parse on the data nodes.      */
DECL|method|DecayFunctionBuilder
specifier|protected
name|DecayFunctionBuilder
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Object
name|origin
parameter_list|,
name|Object
name|scale
parameter_list|,
name|Object
name|offset
parameter_list|)
block|{
name|this
argument_list|(
name|fieldName
argument_list|,
name|origin
argument_list|,
name|scale
argument_list|,
name|offset
argument_list|,
name|DEFAULT_DECAY
argument_list|)
expr_stmt|;
block|}
comment|/**      * Convenience constructor that converts its parameters into json to parse on the data nodes.      */
DECL|method|DecayFunctionBuilder
specifier|protected
name|DecayFunctionBuilder
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|Object
name|origin
parameter_list|,
name|Object
name|scale
parameter_list|,
name|Object
name|offset
parameter_list|,
name|double
name|decay
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"decay function: field name must not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|scale
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"decay function: scale must not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|decay
operator|<=
literal|0
operator|||
name|decay
operator|>=
literal|1.0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"decay function: decay must be in range 0..1!"
argument_list|)
throw|;
block|}
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
try|try
block|{
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|jsonBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
name|ORIGIN
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|field
argument_list|(
name|SCALE
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
name|OFFSET
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|field
argument_list|(
name|DECAY
argument_list|,
name|decay
argument_list|)
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
name|this
operator|.
name|functionBytes
operator|=
name|builder
operator|.
name|bytes
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"unable to build inner function object"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|DecayFunctionBuilder
specifier|protected
name|DecayFunctionBuilder
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|BytesReference
name|functionBytes
parameter_list|)
block|{
if|if
condition|(
name|fieldName
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"decay function: field name must not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|functionBytes
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"decay function: function must not be null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|functionBytes
operator|=
name|functionBytes
expr_stmt|;
block|}
comment|/**      * Read from a stream.      */
DECL|method|DecayFunctionBuilder
specifier|protected
name|DecayFunctionBuilder
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fieldName
operator|=
name|in
operator|.
name|readString
argument_list|()
expr_stmt|;
name|functionBytes
operator|=
name|in
operator|.
name|readBytesReference
argument_list|()
expr_stmt|;
name|multiValueMode
operator|=
name|MultiValueMode
operator|.
name|readMultiValueModeFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doWriteTo
specifier|protected
name|void
name|doWriteTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|out
operator|.
name|writeString
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeBytesReference
argument_list|(
name|functionBytes
argument_list|)
expr_stmt|;
name|multiValueMode
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
DECL|method|getFieldName
specifier|public
name|String
name|getFieldName
parameter_list|()
block|{
return|return
name|this
operator|.
name|fieldName
return|;
block|}
DECL|method|getFunctionBytes
specifier|public
name|BytesReference
name|getFunctionBytes
parameter_list|()
block|{
return|return
name|this
operator|.
name|functionBytes
return|;
block|}
annotation|@
name|Override
DECL|method|doXContent
specifier|public
name|void
name|doXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|builder
operator|.
name|startObject
argument_list|(
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|rawField
argument_list|(
name|fieldName
argument_list|,
name|functionBytes
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
name|DecayFunctionParser
operator|.
name|MULTI_VALUE_MODE
operator|.
name|getPreferredName
argument_list|()
argument_list|,
name|multiValueMode
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|setMultiValueMode
specifier|public
name|DFB
name|setMultiValueMode
parameter_list|(
name|MultiValueMode
name|multiValueMode
parameter_list|)
block|{
if|if
condition|(
name|multiValueMode
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"decay function: multi_value_mode must not be null"
argument_list|)
throw|;
block|}
name|this
operator|.
name|multiValueMode
operator|=
name|multiValueMode
expr_stmt|;
return|return
operator|(
name|DFB
operator|)
name|this
return|;
block|}
DECL|method|getMultiValueMode
specifier|public
name|MultiValueMode
name|getMultiValueMode
parameter_list|()
block|{
return|return
name|this
operator|.
name|multiValueMode
return|;
block|}
annotation|@
name|Override
DECL|method|doEquals
specifier|protected
name|boolean
name|doEquals
parameter_list|(
name|DFB
name|functionBuilder
parameter_list|)
block|{
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|fieldName
argument_list|,
name|functionBuilder
operator|.
name|getFieldName
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|functionBytes
argument_list|,
name|functionBuilder
operator|.
name|getFunctionBytes
argument_list|()
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|multiValueMode
argument_list|,
name|functionBuilder
operator|.
name|getMultiValueMode
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doHashCode
specifier|protected
name|int
name|doHashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|this
operator|.
name|fieldName
argument_list|,
name|this
operator|.
name|functionBytes
argument_list|,
name|this
operator|.
name|multiValueMode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doToFunction
specifier|protected
name|ScoreFunction
name|doToFunction
parameter_list|(
name|QueryShardContext
name|context
parameter_list|)
throws|throws
name|IOException
block|{
name|AbstractDistanceScoreFunction
name|scoreFunction
decl_stmt|;
comment|// EMPTY is safe because parseVariable doesn't use namedObject
try|try
init|(
name|XContentParser
name|parser
init|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|functionBytes
argument_list|)
operator|.
name|createParser
argument_list|(
name|NamedXContentRegistry
operator|.
name|EMPTY
argument_list|,
name|functionBytes
argument_list|)
init|)
block|{
name|scoreFunction
operator|=
name|parseVariable
argument_list|(
name|fieldName
argument_list|,
name|parser
argument_list|,
name|context
argument_list|,
name|multiValueMode
argument_list|)
expr_stmt|;
block|}
return|return
name|scoreFunction
return|;
block|}
comment|/**      * Override this function if you want to produce your own scorer.      * */
DECL|method|getDecayFunction
specifier|protected
specifier|abstract
name|DecayFunction
name|getDecayFunction
parameter_list|()
function_decl|;
DECL|method|parseVariable
specifier|private
name|AbstractDistanceScoreFunction
name|parseVariable
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|XContentParser
name|parser
parameter_list|,
name|QueryShardContext
name|context
parameter_list|,
name|MultiValueMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
comment|//the field must exist, else we cannot read the value for the doc later
name|MappedFieldType
name|fieldType
init|=
name|context
operator|.
name|fieldMapper
argument_list|(
name|fieldName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fieldType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ParsingException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
literal|"unknown field [{}]"
argument_list|,
name|fieldName
argument_list|)
throw|;
block|}
comment|// dates and time and geo need special handling
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldType
operator|instanceof
name|DateFieldMapper
operator|.
name|DateFieldType
condition|)
block|{
return|return
name|parseDateVariable
argument_list|(
name|parser
argument_list|,
name|context
argument_list|,
name|fieldType
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|BaseGeoPointFieldMapper
operator|.
name|GeoPointFieldType
condition|)
block|{
return|return
name|parseGeoVariable
argument_list|(
name|parser
argument_list|,
name|context
argument_list|,
name|fieldType
argument_list|,
name|mode
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|fieldType
operator|instanceof
name|NumberFieldMapper
operator|.
name|NumberFieldType
condition|)
block|{
return|return
name|parseNumberVariable
argument_list|(
name|parser
argument_list|,
name|context
argument_list|,
name|fieldType
argument_list|,
name|mode
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|ParsingException
argument_list|(
name|parser
operator|.
name|getTokenLocation
argument_list|()
argument_list|,
literal|"field [{}] is of type [{}], but only numeric types are supported."
argument_list|,
name|fieldName
argument_list|,
name|fieldType
argument_list|)
throw|;
block|}
block|}
DECL|method|parseNumberVariable
specifier|private
name|AbstractDistanceScoreFunction
name|parseNumberVariable
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|QueryShardContext
name|context
parameter_list|,
name|MappedFieldType
name|fieldType
parameter_list|,
name|MultiValueMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
name|String
name|parameterName
init|=
literal|null
decl_stmt|;
name|double
name|scale
init|=
literal|0
decl_stmt|;
name|double
name|origin
init|=
literal|0
decl_stmt|;
name|double
name|decay
init|=
literal|0.5
decl_stmt|;
name|double
name|offset
init|=
literal|0.0d
decl_stmt|;
name|boolean
name|scaleFound
init|=
literal|false
decl_stmt|;
name|boolean
name|refFound
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|parameterName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|SCALE
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|scale
operator|=
name|parser
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
name|scaleFound
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|DECAY
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|decay
operator|=
name|parser
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|ORIGIN
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|origin
operator|=
name|parser
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
name|refFound
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|OFFSET
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|offset
operator|=
name|parser
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"parameter [{}] not supported!"
argument_list|,
name|parameterName
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|!
name|scaleFound
operator|||
operator|!
name|refFound
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"both [{}] and [{}] must be set for numeric fields."
argument_list|,
name|DecayFunctionBuilder
operator|.
name|SCALE
argument_list|,
name|DecayFunctionBuilder
operator|.
name|ORIGIN
argument_list|)
throw|;
block|}
name|IndexNumericFieldData
name|numericFieldData
init|=
name|context
operator|.
name|getForField
argument_list|(
name|fieldType
argument_list|)
decl_stmt|;
return|return
operator|new
name|NumericFieldDataScoreFunction
argument_list|(
name|origin
argument_list|,
name|scale
argument_list|,
name|decay
argument_list|,
name|offset
argument_list|,
name|getDecayFunction
argument_list|()
argument_list|,
name|numericFieldData
argument_list|,
name|mode
argument_list|)
return|;
block|}
DECL|method|parseGeoVariable
specifier|private
name|AbstractDistanceScoreFunction
name|parseGeoVariable
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|QueryShardContext
name|context
parameter_list|,
name|MappedFieldType
name|fieldType
parameter_list|,
name|MultiValueMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
name|String
name|parameterName
init|=
literal|null
decl_stmt|;
name|GeoPoint
name|origin
init|=
operator|new
name|GeoPoint
argument_list|()
decl_stmt|;
name|String
name|scaleString
init|=
literal|null
decl_stmt|;
name|String
name|offsetString
init|=
literal|"0km"
decl_stmt|;
name|double
name|decay
init|=
literal|0.5
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|parameterName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|SCALE
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|scaleString
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|ORIGIN
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|origin
operator|=
name|GeoUtils
operator|.
name|parseGeoPoint
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|DECAY
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|decay
operator|=
name|parser
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|OFFSET
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|offsetString
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"parameter [{}] not supported!"
argument_list|,
name|parameterName
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|origin
operator|==
literal|null
operator|||
name|scaleString
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"[{}] and [{}] must be set for geo fields."
argument_list|,
name|DecayFunctionBuilder
operator|.
name|ORIGIN
argument_list|,
name|DecayFunctionBuilder
operator|.
name|SCALE
argument_list|)
throw|;
block|}
name|double
name|scale
init|=
name|DistanceUnit
operator|.
name|DEFAULT
operator|.
name|parse
argument_list|(
name|scaleString
argument_list|,
name|DistanceUnit
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|double
name|offset
init|=
name|DistanceUnit
operator|.
name|DEFAULT
operator|.
name|parse
argument_list|(
name|offsetString
argument_list|,
name|DistanceUnit
operator|.
name|DEFAULT
argument_list|)
decl_stmt|;
name|IndexGeoPointFieldData
name|indexFieldData
init|=
name|context
operator|.
name|getForField
argument_list|(
name|fieldType
argument_list|)
decl_stmt|;
return|return
operator|new
name|GeoFieldDataScoreFunction
argument_list|(
name|origin
argument_list|,
name|scale
argument_list|,
name|decay
argument_list|,
name|offset
argument_list|,
name|getDecayFunction
argument_list|()
argument_list|,
name|indexFieldData
argument_list|,
name|mode
argument_list|)
return|;
block|}
DECL|method|parseDateVariable
specifier|private
name|AbstractDistanceScoreFunction
name|parseDateVariable
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|QueryShardContext
name|context
parameter_list|,
name|MappedFieldType
name|dateFieldType
parameter_list|,
name|MultiValueMode
name|mode
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
name|String
name|parameterName
init|=
literal|null
decl_stmt|;
name|String
name|scaleString
init|=
literal|null
decl_stmt|;
name|String
name|originString
init|=
literal|null
decl_stmt|;
name|String
name|offsetString
init|=
literal|"0d"
decl_stmt|;
name|double
name|decay
init|=
literal|0.5
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|parameterName
operator|=
name|parser
operator|.
name|currentName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|SCALE
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|scaleString
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|ORIGIN
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|originString
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|DECAY
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|decay
operator|=
name|parser
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DecayFunctionBuilder
operator|.
name|OFFSET
operator|.
name|equals
argument_list|(
name|parameterName
argument_list|)
condition|)
block|{
name|offsetString
operator|=
name|parser
operator|.
name|text
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"parameter [{}] not supported!"
argument_list|,
name|parameterName
argument_list|)
throw|;
block|}
block|}
name|long
name|origin
decl_stmt|;
if|if
condition|(
name|originString
operator|==
literal|null
condition|)
block|{
name|origin
operator|=
name|context
operator|.
name|nowInMillis
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|origin
operator|=
operator|(
operator|(
name|DateFieldMapper
operator|.
name|DateFieldType
operator|)
name|dateFieldType
operator|)
operator|.
name|parseToMilliseconds
argument_list|(
name|originString
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|context
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scaleString
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"[{}] must be set for date fields."
argument_list|,
name|DecayFunctionBuilder
operator|.
name|SCALE
argument_list|)
throw|;
block|}
name|TimeValue
name|val
init|=
name|TimeValue
operator|.
name|parseTimeValue
argument_list|(
name|scaleString
argument_list|,
name|TimeValue
operator|.
name|timeValueHours
argument_list|(
literal|24
argument_list|)
argument_list|,
name|DecayFunctionParser
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".scale"
argument_list|)
decl_stmt|;
name|double
name|scale
init|=
name|val
operator|.
name|getMillis
argument_list|()
decl_stmt|;
name|val
operator|=
name|TimeValue
operator|.
name|parseTimeValue
argument_list|(
name|offsetString
argument_list|,
name|TimeValue
operator|.
name|timeValueHours
argument_list|(
literal|24
argument_list|)
argument_list|,
name|DecayFunctionParser
operator|.
name|class
operator|.
name|getSimpleName
argument_list|()
operator|+
literal|".offset"
argument_list|)
expr_stmt|;
name|double
name|offset
init|=
name|val
operator|.
name|getMillis
argument_list|()
decl_stmt|;
name|IndexNumericFieldData
name|numericFieldData
init|=
name|context
operator|.
name|getForField
argument_list|(
name|dateFieldType
argument_list|)
decl_stmt|;
return|return
operator|new
name|NumericFieldDataScoreFunction
argument_list|(
name|origin
argument_list|,
name|scale
argument_list|,
name|decay
argument_list|,
name|offset
argument_list|,
name|getDecayFunction
argument_list|()
argument_list|,
name|numericFieldData
argument_list|,
name|mode
argument_list|)
return|;
block|}
DECL|class|GeoFieldDataScoreFunction
specifier|static
class|class
name|GeoFieldDataScoreFunction
extends|extends
name|AbstractDistanceScoreFunction
block|{
DECL|field|origin
specifier|private
specifier|final
name|GeoPoint
name|origin
decl_stmt|;
DECL|field|fieldData
specifier|private
specifier|final
name|IndexGeoPointFieldData
name|fieldData
decl_stmt|;
DECL|field|distFunction
specifier|private
specifier|static
specifier|final
name|GeoDistance
name|distFunction
init|=
name|GeoDistance
operator|.
name|ARC
decl_stmt|;
DECL|method|GeoFieldDataScoreFunction
specifier|public
name|GeoFieldDataScoreFunction
parameter_list|(
name|GeoPoint
name|origin
parameter_list|,
name|double
name|scale
parameter_list|,
name|double
name|decay
parameter_list|,
name|double
name|offset
parameter_list|,
name|DecayFunction
name|func
parameter_list|,
name|IndexGeoPointFieldData
name|fieldData
parameter_list|,
name|MultiValueMode
name|mode
parameter_list|)
block|{
name|super
argument_list|(
name|scale
argument_list|,
name|decay
argument_list|,
name|offset
argument_list|,
name|func
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|this
operator|.
name|origin
operator|=
name|origin
expr_stmt|;
name|this
operator|.
name|fieldData
operator|=
name|fieldData
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|needsScores
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|distance
specifier|protected
name|NumericDoubleValues
name|distance
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
block|{
specifier|final
name|MultiGeoPointValues
name|geoPointValues
init|=
name|fieldData
operator|.
name|load
argument_list|(
name|context
argument_list|)
operator|.
name|getGeoPointValues
argument_list|()
decl_stmt|;
return|return
name|mode
operator|.
name|select
argument_list|(
operator|new
name|MultiValueMode
operator|.
name|UnsortedNumericDoubleValues
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|count
parameter_list|()
block|{
return|return
name|geoPointValues
operator|.
name|count
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setDocument
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|geoPointValues
operator|.
name|setDocument
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|valueAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|GeoPoint
name|other
init|=
name|geoPointValues
operator|.
name|valueAt
argument_list|(
name|index
argument_list|)
decl_stmt|;
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0.0d
argument_list|,
name|distFunction
operator|.
name|calculate
argument_list|(
name|origin
operator|.
name|lat
argument_list|()
argument_list|,
name|origin
operator|.
name|lon
argument_list|()
argument_list|,
name|other
operator|.
name|lat
argument_list|()
argument_list|,
name|other
operator|.
name|lon
argument_list|()
argument_list|,
name|DistanceUnit
operator|.
name|METERS
argument_list|)
operator|-
name|offset
argument_list|)
return|;
block|}
block|}
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getDistanceString
specifier|protected
name|String
name|getDistanceString
parameter_list|(
name|LeafReaderContext
name|ctx
parameter_list|,
name|int
name|docId
parameter_list|)
block|{
name|StringBuilder
name|values
init|=
operator|new
name|StringBuilder
argument_list|(
name|mode
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|values
operator|.
name|append
argument_list|(
literal|" of: ["
argument_list|)
expr_stmt|;
specifier|final
name|MultiGeoPointValues
name|geoPointValues
init|=
name|fieldData
operator|.
name|load
argument_list|(
name|ctx
argument_list|)
operator|.
name|getGeoPointValues
argument_list|()
decl_stmt|;
name|geoPointValues
operator|.
name|setDocument
argument_list|(
name|docId
argument_list|)
expr_stmt|;
specifier|final
name|int
name|num
init|=
name|geoPointValues
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|GeoPoint
name|value
init|=
name|geoPointValues
operator|.
name|valueAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|values
operator|.
name|append
argument_list|(
literal|"Math.max(arcDistance("
argument_list|)
expr_stmt|;
name|values
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"(=doc value),"
argument_list|)
expr_stmt|;
name|values
operator|.
name|append
argument_list|(
name|origin
argument_list|)
operator|.
name|append
argument_list|(
literal|"(=origin)) - "
argument_list|)
operator|.
name|append
argument_list|(
name|offset
argument_list|)
operator|.
name|append
argument_list|(
literal|"(=offset), 0)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|num
operator|-
literal|1
condition|)
block|{
name|values
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|values
operator|.
name|append
argument_list|(
literal|"0.0"
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|values
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getFieldName
specifier|protected
name|String
name|getFieldName
parameter_list|()
block|{
return|return
name|fieldData
operator|.
name|getFieldName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|doEquals
specifier|protected
name|boolean
name|doEquals
parameter_list|(
name|ScoreFunction
name|other
parameter_list|)
block|{
name|GeoFieldDataScoreFunction
name|geoFieldDataScoreFunction
init|=
operator|(
name|GeoFieldDataScoreFunction
operator|)
name|other
decl_stmt|;
return|return
name|super
operator|.
name|doEquals
argument_list|(
name|other
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|origin
argument_list|,
name|geoFieldDataScoreFunction
operator|.
name|origin
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doHashCode
specifier|protected
name|int
name|doHashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|super
operator|.
name|doHashCode
argument_list|()
argument_list|,
name|origin
argument_list|)
return|;
block|}
block|}
DECL|class|NumericFieldDataScoreFunction
specifier|static
class|class
name|NumericFieldDataScoreFunction
extends|extends
name|AbstractDistanceScoreFunction
block|{
DECL|field|fieldData
specifier|private
specifier|final
name|IndexNumericFieldData
name|fieldData
decl_stmt|;
DECL|field|origin
specifier|private
specifier|final
name|double
name|origin
decl_stmt|;
DECL|method|NumericFieldDataScoreFunction
specifier|public
name|NumericFieldDataScoreFunction
parameter_list|(
name|double
name|origin
parameter_list|,
name|double
name|scale
parameter_list|,
name|double
name|decay
parameter_list|,
name|double
name|offset
parameter_list|,
name|DecayFunction
name|func
parameter_list|,
name|IndexNumericFieldData
name|fieldData
parameter_list|,
name|MultiValueMode
name|mode
parameter_list|)
block|{
name|super
argument_list|(
name|scale
argument_list|,
name|decay
argument_list|,
name|offset
argument_list|,
name|func
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|this
operator|.
name|fieldData
operator|=
name|fieldData
expr_stmt|;
name|this
operator|.
name|origin
operator|=
name|origin
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|needsScores
specifier|public
name|boolean
name|needsScores
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
DECL|method|distance
specifier|protected
name|NumericDoubleValues
name|distance
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
block|{
specifier|final
name|SortedNumericDoubleValues
name|doubleValues
init|=
name|fieldData
operator|.
name|load
argument_list|(
name|context
argument_list|)
operator|.
name|getDoubleValues
argument_list|()
decl_stmt|;
return|return
name|mode
operator|.
name|select
argument_list|(
operator|new
name|MultiValueMode
operator|.
name|UnsortedNumericDoubleValues
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|count
parameter_list|()
block|{
return|return
name|doubleValues
operator|.
name|count
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|setDocument
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
name|doubleValues
operator|.
name|setDocument
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|double
name|valueAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|Math
operator|.
name|max
argument_list|(
literal|0.0d
argument_list|,
name|Math
operator|.
name|abs
argument_list|(
name|doubleValues
operator|.
name|valueAt
argument_list|(
name|index
argument_list|)
operator|-
name|origin
argument_list|)
operator|-
name|offset
argument_list|)
return|;
block|}
block|}
argument_list|,
literal|0.0
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getDistanceString
specifier|protected
name|String
name|getDistanceString
parameter_list|(
name|LeafReaderContext
name|ctx
parameter_list|,
name|int
name|docId
parameter_list|)
block|{
name|StringBuilder
name|values
init|=
operator|new
name|StringBuilder
argument_list|(
name|mode
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|values
operator|.
name|append
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
specifier|final
name|SortedNumericDoubleValues
name|doubleValues
init|=
name|fieldData
operator|.
name|load
argument_list|(
name|ctx
argument_list|)
operator|.
name|getDoubleValues
argument_list|()
decl_stmt|;
name|doubleValues
operator|.
name|setDocument
argument_list|(
name|docId
argument_list|)
expr_stmt|;
specifier|final
name|int
name|num
init|=
name|doubleValues
operator|.
name|count
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|double
name|value
init|=
name|doubleValues
operator|.
name|valueAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|values
operator|.
name|append
argument_list|(
literal|"Math.max(Math.abs("
argument_list|)
expr_stmt|;
name|values
operator|.
name|append
argument_list|(
name|value
argument_list|)
operator|.
name|append
argument_list|(
literal|"(=doc value) - "
argument_list|)
expr_stmt|;
name|values
operator|.
name|append
argument_list|(
name|origin
argument_list|)
operator|.
name|append
argument_list|(
literal|"(=origin))) - "
argument_list|)
expr_stmt|;
name|values
operator|.
name|append
argument_list|(
name|offset
argument_list|)
operator|.
name|append
argument_list|(
literal|"(=offset), 0)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|num
operator|-
literal|1
condition|)
block|{
name|values
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|values
operator|.
name|append
argument_list|(
literal|"0.0"
argument_list|)
expr_stmt|;
block|}
name|values
operator|.
name|append
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return
name|values
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|getFieldName
specifier|protected
name|String
name|getFieldName
parameter_list|()
block|{
return|return
name|fieldData
operator|.
name|getFieldName
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|doEquals
specifier|protected
name|boolean
name|doEquals
parameter_list|(
name|ScoreFunction
name|other
parameter_list|)
block|{
name|NumericFieldDataScoreFunction
name|numericFieldDataScoreFunction
init|=
operator|(
name|NumericFieldDataScoreFunction
operator|)
name|other
decl_stmt|;
if|if
condition|(
name|super
operator|.
name|doEquals
argument_list|(
name|other
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|origin
argument_list|,
name|numericFieldDataScoreFunction
operator|.
name|origin
argument_list|)
return|;
block|}
block|}
comment|/**      * This is the base class for scoring a single field.      *      * */
DECL|class|AbstractDistanceScoreFunction
specifier|public
specifier|abstract
specifier|static
class|class
name|AbstractDistanceScoreFunction
extends|extends
name|ScoreFunction
block|{
DECL|field|scale
specifier|private
specifier|final
name|double
name|scale
decl_stmt|;
DECL|field|offset
specifier|protected
specifier|final
name|double
name|offset
decl_stmt|;
DECL|field|func
specifier|private
specifier|final
name|DecayFunction
name|func
decl_stmt|;
DECL|field|mode
specifier|protected
specifier|final
name|MultiValueMode
name|mode
decl_stmt|;
DECL|method|AbstractDistanceScoreFunction
specifier|public
name|AbstractDistanceScoreFunction
parameter_list|(
name|double
name|userSuppiedScale
parameter_list|,
name|double
name|decay
parameter_list|,
name|double
name|offset
parameter_list|,
name|DecayFunction
name|func
parameter_list|,
name|MultiValueMode
name|mode
parameter_list|)
block|{
name|super
argument_list|(
name|CombineFunction
operator|.
name|MULTIPLY
argument_list|)
expr_stmt|;
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|userSuppiedScale
operator|<=
literal|0.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|FunctionScoreQueryBuilder
operator|.
name|NAME
operator|+
literal|" : scale must be> 0.0."
argument_list|)
throw|;
block|}
if|if
condition|(
name|decay
operator|<=
literal|0.0
operator|||
name|decay
operator|>=
literal|1.0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|FunctionScoreQueryBuilder
operator|.
name|NAME
operator|+
literal|" : decay must be in the range [0..1]."
argument_list|)
throw|;
block|}
name|this
operator|.
name|scale
operator|=
name|func
operator|.
name|processScale
argument_list|(
name|userSuppiedScale
argument_list|,
name|decay
argument_list|)
expr_stmt|;
name|this
operator|.
name|func
operator|=
name|func
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0.0d
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|FunctionScoreQueryBuilder
operator|.
name|NAME
operator|+
literal|" : offset must be> 0.0"
argument_list|)
throw|;
block|}
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
comment|/**          * This function computes the distance from a defined origin. Since          * the value of the document is read from the index, it cannot be          * guaranteed that the value actually exists. If it does not, we assume          * the user handles this case in the query and return 0.          * */
DECL|method|distance
specifier|protected
specifier|abstract
name|NumericDoubleValues
name|distance
parameter_list|(
name|LeafReaderContext
name|context
parameter_list|)
function_decl|;
annotation|@
name|Override
DECL|method|getLeafScoreFunction
specifier|public
specifier|final
name|LeafScoreFunction
name|getLeafScoreFunction
parameter_list|(
specifier|final
name|LeafReaderContext
name|ctx
parameter_list|)
block|{
specifier|final
name|NumericDoubleValues
name|distance
init|=
name|distance
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
return|return
operator|new
name|LeafScoreFunction
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|double
name|score
parameter_list|(
name|int
name|docId
parameter_list|,
name|float
name|subQueryScore
parameter_list|)
block|{
return|return
name|func
operator|.
name|evaluate
argument_list|(
name|distance
operator|.
name|get
argument_list|(
name|docId
argument_list|)
argument_list|,
name|scale
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Explanation
name|explainScore
parameter_list|(
name|int
name|docId
parameter_list|,
name|Explanation
name|subQueryScore
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|Explanation
operator|.
name|match
argument_list|(
name|CombineFunction
operator|.
name|toFloat
argument_list|(
name|score
argument_list|(
name|docId
argument_list|,
name|subQueryScore
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
argument_list|,
literal|"Function for field "
operator|+
name|getFieldName
argument_list|()
operator|+
literal|":"
argument_list|,
name|func
operator|.
name|explainFunction
argument_list|(
name|getDistanceString
argument_list|(
name|ctx
argument_list|,
name|docId
argument_list|)
argument_list|,
name|distance
operator|.
name|get
argument_list|(
name|docId
argument_list|)
argument_list|,
name|scale
argument_list|)
argument_list|)
return|;
block|}
block|}
return|;
block|}
DECL|method|getDistanceString
specifier|protected
specifier|abstract
name|String
name|getDistanceString
parameter_list|(
name|LeafReaderContext
name|ctx
parameter_list|,
name|int
name|docId
parameter_list|)
function_decl|;
DECL|method|getFieldName
specifier|protected
specifier|abstract
name|String
name|getFieldName
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|doEquals
specifier|protected
name|boolean
name|doEquals
parameter_list|(
name|ScoreFunction
name|other
parameter_list|)
block|{
name|AbstractDistanceScoreFunction
name|distanceScoreFunction
init|=
operator|(
name|AbstractDistanceScoreFunction
operator|)
name|other
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|scale
argument_list|,
name|distanceScoreFunction
operator|.
name|scale
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|offset
argument_list|,
name|distanceScoreFunction
operator|.
name|offset
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|mode
argument_list|,
name|distanceScoreFunction
operator|.
name|mode
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|func
argument_list|,
name|distanceScoreFunction
operator|.
name|func
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|this
operator|.
name|getFieldName
argument_list|()
argument_list|,
name|distanceScoreFunction
operator|.
name|getFieldName
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|doHashCode
specifier|protected
name|int
name|doHashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|scale
argument_list|,
name|offset
argument_list|,
name|mode
argument_list|,
name|func
argument_list|,
name|getFieldName
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

