begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.discovery.zen
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|zen
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|util
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateTaskConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateTaskExecutor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateTaskListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|LocalClusterUpdateTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|NotMasterException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|AllocationService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|service
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|Lifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|internal
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|NamedWriteableRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lease
operator|.
name|Releasables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Setting
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|Discovery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|DiscoverySettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|DiscoveryStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|EmptyTransportResponseHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportChannel
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequestHandler
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CompletableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
operator|.
name|timeValueSeconds
import|;
end_import

begin_class
DECL|class|ZenDiscovery
specifier|public
class|class
name|ZenDiscovery
extends|extends
name|AbstractLifecycleComponent
implements|implements
name|Discovery
implements|,
name|PingContextProvider
block|{
DECL|field|PING_TIMEOUT_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|TimeValue
argument_list|>
name|PING_TIMEOUT_SETTING
init|=
name|Setting
operator|.
name|positiveTimeSetting
argument_list|(
literal|"discovery.zen.ping_timeout"
argument_list|,
name|timeValueSeconds
argument_list|(
literal|3
argument_list|)
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|JOIN_TIMEOUT_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|TimeValue
argument_list|>
name|JOIN_TIMEOUT_SETTING
init|=
name|Setting
operator|.
name|timeSetting
argument_list|(
literal|"discovery.zen.join_timeout"
argument_list|,
name|settings
lambda|->
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|PING_TIMEOUT_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
operator|.
name|millis
argument_list|()
operator|*
literal|20
argument_list|)
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|JOIN_RETRY_ATTEMPTS_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|JOIN_RETRY_ATTEMPTS_SETTING
init|=
name|Setting
operator|.
name|intSetting
argument_list|(
literal|"discovery.zen.join_retry_attempts"
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|JOIN_RETRY_DELAY_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|TimeValue
argument_list|>
name|JOIN_RETRY_DELAY_SETTING
init|=
name|Setting
operator|.
name|positiveTimeSetting
argument_list|(
literal|"discovery.zen.join_retry_delay"
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
literal|100
argument_list|)
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|MAX_PINGS_FROM_ANOTHER_MASTER_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Integer
argument_list|>
name|MAX_PINGS_FROM_ANOTHER_MASTER_SETTING
init|=
name|Setting
operator|.
name|intSetting
argument_list|(
literal|"discovery.zen.max_pings_from_another_master"
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|SEND_LEAVE_REQUEST_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Boolean
argument_list|>
name|SEND_LEAVE_REQUEST_SETTING
init|=
name|Setting
operator|.
name|boolSetting
argument_list|(
literal|"discovery.zen.send_leave_request"
argument_list|,
literal|true
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|TimeValue
argument_list|>
name|MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT_SETTING
init|=
name|Setting
operator|.
name|timeSetting
argument_list|(
literal|"discovery.zen.master_election.wait_for_joins_timeout"
argument_list|,
name|settings
lambda|->
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|JOIN_TIMEOUT_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
operator|.
name|millis
argument_list|()
operator|/
literal|2
argument_list|)
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
literal|0
argument_list|)
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|MASTER_ELECTION_IGNORE_NON_MASTER_PINGS_SETTING
specifier|public
specifier|static
specifier|final
name|Setting
argument_list|<
name|Boolean
argument_list|>
name|MASTER_ELECTION_IGNORE_NON_MASTER_PINGS_SETTING
init|=
name|Setting
operator|.
name|boolSetting
argument_list|(
literal|"discovery.zen.master_election.ignore_non_master_pings"
argument_list|,
literal|false
argument_list|,
name|Property
operator|.
name|NodeScope
argument_list|)
decl_stmt|;
DECL|field|DISCOVERY_REJOIN_ACTION_NAME
specifier|public
specifier|static
specifier|final
name|String
name|DISCOVERY_REJOIN_ACTION_NAME
init|=
literal|"internal:discovery/zen/rejoin"
decl_stmt|;
DECL|field|transportService
specifier|private
specifier|final
name|TransportService
name|transportService
decl_stmt|;
DECL|field|namedWriteableRegistry
specifier|private
specifier|final
name|NamedWriteableRegistry
name|namedWriteableRegistry
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|allocationService
specifier|private
name|AllocationService
name|allocationService
decl_stmt|;
DECL|field|clusterName
specifier|private
specifier|final
name|ClusterName
name|clusterName
decl_stmt|;
DECL|field|discoverySettings
specifier|private
specifier|final
name|DiscoverySettings
name|discoverySettings
decl_stmt|;
DECL|field|zenPing
specifier|protected
specifier|final
name|ZenPing
name|zenPing
decl_stmt|;
comment|// protected to allow tests access
DECL|field|masterFD
specifier|private
specifier|final
name|MasterFaultDetection
name|masterFD
decl_stmt|;
DECL|field|nodesFD
specifier|private
specifier|final
name|NodesFaultDetection
name|nodesFD
decl_stmt|;
DECL|field|publishClusterState
specifier|private
specifier|final
name|PublishClusterStateAction
name|publishClusterState
decl_stmt|;
DECL|field|membership
specifier|private
specifier|final
name|MembershipAction
name|membership
decl_stmt|;
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|pingTimeout
specifier|private
specifier|final
name|TimeValue
name|pingTimeout
decl_stmt|;
DECL|field|joinTimeout
specifier|private
specifier|final
name|TimeValue
name|joinTimeout
decl_stmt|;
comment|/** how many retry attempts to perform if join request failed with an retriable error */
DECL|field|joinRetryAttempts
specifier|private
specifier|final
name|int
name|joinRetryAttempts
decl_stmt|;
comment|/** how long to wait before performing another join attempt after a join request failed with an retriable error */
DECL|field|joinRetryDelay
specifier|private
specifier|final
name|TimeValue
name|joinRetryDelay
decl_stmt|;
comment|/** how many pings from *another* master to tolerate before forcing a rejoin on other or local master */
DECL|field|maxPingsFromAnotherMaster
specifier|private
specifier|final
name|int
name|maxPingsFromAnotherMaster
decl_stmt|;
comment|// a flag that should be used only for testing
DECL|field|sendLeaveRequest
specifier|private
specifier|final
name|boolean
name|sendLeaveRequest
decl_stmt|;
DECL|field|electMaster
specifier|private
specifier|final
name|ElectMasterService
name|electMaster
decl_stmt|;
DECL|field|masterElectionIgnoreNonMasters
specifier|private
specifier|final
name|boolean
name|masterElectionIgnoreNonMasters
decl_stmt|;
DECL|field|masterElectionWaitForJoinsTimeout
specifier|private
specifier|final
name|TimeValue
name|masterElectionWaitForJoinsTimeout
decl_stmt|;
DECL|field|joinThreadControl
specifier|private
specifier|final
name|JoinThreadControl
name|joinThreadControl
decl_stmt|;
comment|// must initialized in doStart(), when we have the allocationService set
DECL|field|nodeJoinController
specifier|private
specifier|volatile
name|NodeJoinController
name|nodeJoinController
decl_stmt|;
DECL|field|nodeRemovalExecutor
specifier|private
specifier|volatile
name|NodeRemovalClusterStateTaskExecutor
name|nodeRemovalExecutor
decl_stmt|;
DECL|method|ZenDiscovery
specifier|public
name|ZenDiscovery
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|TransportService
name|transportService
parameter_list|,
name|NamedWriteableRegistry
name|namedWriteableRegistry
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|UnicastHostsProvider
name|hostsProvider
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|clusterName
operator|=
name|clusterService
operator|.
name|getClusterName
argument_list|()
expr_stmt|;
name|this
operator|.
name|transportService
operator|=
name|transportService
expr_stmt|;
name|this
operator|.
name|namedWriteableRegistry
operator|=
name|namedWriteableRegistry
expr_stmt|;
name|this
operator|.
name|discoverySettings
operator|=
operator|new
name|DiscoverySettings
argument_list|(
name|settings
argument_list|,
name|clusterService
operator|.
name|getClusterSettings
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|zenPing
operator|=
name|newZenPing
argument_list|(
name|settings
argument_list|,
name|threadPool
argument_list|,
name|transportService
argument_list|,
name|hostsProvider
argument_list|)
expr_stmt|;
name|this
operator|.
name|electMaster
operator|=
operator|new
name|ElectMasterService
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|pingTimeout
operator|=
name|PING_TIMEOUT_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|joinTimeout
operator|=
name|JOIN_TIMEOUT_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|joinRetryAttempts
operator|=
name|JOIN_RETRY_ATTEMPTS_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|joinRetryDelay
operator|=
name|JOIN_RETRY_DELAY_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|maxPingsFromAnotherMaster
operator|=
name|MAX_PINGS_FROM_ANOTHER_MASTER_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|sendLeaveRequest
operator|=
name|SEND_LEAVE_REQUEST_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|masterElectionIgnoreNonMasters
operator|=
name|MASTER_ELECTION_IGNORE_NON_MASTER_PINGS_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterElectionWaitForJoinsTimeout
operator|=
name|MASTER_ELECTION_WAIT_FOR_JOINS_TIMEOUT_SETTING
operator|.
name|get
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"using ping_timeout [{}], join.timeout [{}], master_election.ignore_non_master [{}]"
argument_list|,
name|this
operator|.
name|pingTimeout
argument_list|,
name|joinTimeout
argument_list|,
name|masterElectionIgnoreNonMasters
argument_list|)
expr_stmt|;
name|clusterService
operator|.
name|getClusterSettings
argument_list|()
operator|.
name|addSettingsUpdateConsumer
argument_list|(
name|ElectMasterService
operator|.
name|DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING
argument_list|,
name|this
operator|::
name|handleMinimumMasterNodesChanged
argument_list|,
parameter_list|(
name|value
parameter_list|)
lambda|->
block|{
specifier|final
name|ClusterState
name|clusterState
init|=
name|clusterService
operator|.
name|state
argument_list|()
decl_stmt|;
name|int
name|masterNodes
init|=
name|clusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodes
argument_list|()
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|>
name|masterNodes
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"cannot set "
operator|+
name|ElectMasterService
operator|.
name|DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING
operator|.
name|getKey
argument_list|()
operator|+
literal|" to more than the current"
operator|+
literal|" master nodes count ["
operator|+
name|masterNodes
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterFD
operator|=
operator|new
name|MasterFaultDetection
argument_list|(
name|settings
argument_list|,
name|threadPool
argument_list|,
name|transportService
argument_list|,
name|clusterService
argument_list|)
expr_stmt|;
name|this
operator|.
name|masterFD
operator|.
name|addListener
argument_list|(
operator|new
name|MasterNodeFailureListener
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodesFD
operator|=
operator|new
name|NodesFaultDetection
argument_list|(
name|settings
argument_list|,
name|threadPool
argument_list|,
name|transportService
argument_list|,
name|clusterService
operator|.
name|getClusterName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodesFD
operator|.
name|addListener
argument_list|(
operator|new
name|NodeFaultDetectionListener
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|publishClusterState
operator|=
operator|new
name|PublishClusterStateAction
argument_list|(
name|settings
argument_list|,
name|transportService
argument_list|,
name|namedWriteableRegistry
argument_list|,
name|clusterService
operator|::
name|state
argument_list|,
operator|new
name|NewPendingClusterStateListener
argument_list|()
argument_list|,
name|discoverySettings
argument_list|,
name|clusterService
operator|.
name|getClusterName
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|membership
operator|=
operator|new
name|MembershipAction
argument_list|(
name|settings
argument_list|,
name|transportService
argument_list|,
name|this
operator|::
name|localNode
argument_list|,
operator|new
name|MembershipListener
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|joinThreadControl
operator|=
operator|new
name|JoinThreadControl
argument_list|()
expr_stmt|;
name|transportService
operator|.
name|registerRequestHandler
argument_list|(
name|DISCOVERY_REJOIN_ACTION_NAME
argument_list|,
name|RejoinClusterRequest
operator|::
operator|new
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
operator|new
name|RejoinClusterRequestHandler
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// protected to allow overriding in tests
DECL|method|newZenPing
specifier|protected
name|ZenPing
name|newZenPing
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|TransportService
name|transportService
parameter_list|,
name|UnicastHostsProvider
name|hostsProvider
parameter_list|)
block|{
return|return
operator|new
name|UnicastZenPing
argument_list|(
name|settings
argument_list|,
name|threadPool
argument_list|,
name|transportService
argument_list|,
name|hostsProvider
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setAllocationService
specifier|public
name|void
name|setAllocationService
parameter_list|(
name|AllocationService
name|allocationService
parameter_list|)
block|{
name|this
operator|.
name|allocationService
operator|=
name|allocationService
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
block|{
name|nodesFD
operator|.
name|setLocalNode
argument_list|(
name|clusterService
operator|.
name|localNode
argument_list|()
argument_list|)
expr_stmt|;
name|joinThreadControl
operator|.
name|start
argument_list|()
expr_stmt|;
name|zenPing
operator|.
name|start
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeJoinController
operator|=
operator|new
name|NodeJoinController
argument_list|(
name|clusterService
argument_list|,
name|allocationService
argument_list|,
name|electMaster
argument_list|,
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeRemovalExecutor
operator|=
operator|new
name|NodeRemovalClusterStateTaskExecutor
argument_list|(
name|allocationService
argument_list|,
name|electMaster
argument_list|,
name|this
operator|::
name|submitRejoin
argument_list|,
name|logger
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|startInitialJoin
specifier|public
name|void
name|startInitialJoin
parameter_list|()
block|{
comment|// start the join thread from a cluster state update. See {@link JoinThreadControl} for details.
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"initial_join"
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
throws|throws
name|Exception
block|{
comment|// do the join on a different thread, the DiscoveryService waits for 30s anyhow till it is discovered
name|joinThreadControl
operator|.
name|startNewThreadIfNotRunning
argument_list|()
expr_stmt|;
return|return
name|unchanged
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
annotation|@
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to start initial join process"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
block|{
name|joinThreadControl
operator|.
name|stop
argument_list|()
expr_stmt|;
name|masterFD
operator|.
name|stop
argument_list|(
literal|"zen disco stop"
argument_list|)
expr_stmt|;
name|nodesFD
operator|.
name|stop
argument_list|()
expr_stmt|;
name|Releasables
operator|.
name|close
argument_list|(
name|zenPing
argument_list|)
expr_stmt|;
comment|// stop any ongoing pinging
name|DiscoveryNodes
name|nodes
init|=
name|nodes
argument_list|()
decl_stmt|;
if|if
condition|(
name|sendLeaveRequest
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|getMasterNode
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// if we don't know who the master is, nothing to do here
block|}
elseif|else
if|if
condition|(
operator|!
name|nodes
operator|.
name|isLocalNodeElectedMaster
argument_list|()
condition|)
block|{
try|try
block|{
name|membership
operator|.
name|sendLeaveRequestBlocking
argument_list|(
name|nodes
operator|.
name|getMasterNode
argument_list|()
argument_list|,
name|nodes
operator|.
name|getLocalNode
argument_list|()
argument_list|,
name|TimeValue
operator|.
name|timeValueSeconds
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to send leave request to master [{}]"
argument_list|,
name|nodes
operator|.
name|getMasterNode
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we're master -> let other potential master we left and start a master election now rather then wait for masterFD
name|DiscoveryNode
index|[]
name|possibleMasters
init|=
name|electMaster
operator|.
name|nextPossibleMasters
argument_list|(
name|nodes
operator|.
name|getNodes
argument_list|()
operator|.
name|values
argument_list|()
argument_list|,
literal|5
argument_list|)
decl_stmt|;
for|for
control|(
name|DiscoveryNode
name|possibleMaster
range|:
name|possibleMasters
control|)
block|{
if|if
condition|(
name|nodes
operator|.
name|getLocalNode
argument_list|()
operator|.
name|equals
argument_list|(
name|possibleMaster
argument_list|)
condition|)
block|{
continue|continue;
block|}
try|try
block|{
name|membership
operator|.
name|sendLeaveRequest
argument_list|(
name|nodes
operator|.
name|getLocalNode
argument_list|()
argument_list|,
name|possibleMaster
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to send leave request from master [{}] to possible master [{}]"
argument_list|,
name|nodes
operator|.
name|getMasterNode
argument_list|()
argument_list|,
name|possibleMaster
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
throws|throws
name|IOException
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|masterFD
argument_list|,
name|nodesFD
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|localNode
specifier|public
name|DiscoveryNode
name|localNode
parameter_list|()
block|{
return|return
name|clusterService
operator|.
name|localNode
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nodeDescription
specifier|public
name|String
name|nodeDescription
parameter_list|()
block|{
return|return
name|clusterName
operator|.
name|value
argument_list|()
operator|+
literal|"/"
operator|+
name|clusterService
operator|.
name|localNode
argument_list|()
operator|.
name|getId
argument_list|()
return|;
block|}
comment|/** start of {@link PingContextProvider } implementation */
annotation|@
name|Override
DECL|method|nodes
specifier|public
name|DiscoveryNodes
name|nodes
parameter_list|()
block|{
return|return
name|clusterService
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clusterState
specifier|public
name|ClusterState
name|clusterState
parameter_list|()
block|{
return|return
name|clusterService
operator|.
name|state
argument_list|()
return|;
block|}
comment|/** end of {@link PingContextProvider } implementation */
annotation|@
name|Override
DECL|method|publish
specifier|public
name|void
name|publish
parameter_list|(
name|ClusterChangedEvent
name|clusterChangedEvent
parameter_list|,
name|AckListener
name|ackListener
parameter_list|)
block|{
if|if
condition|(
operator|!
name|clusterChangedEvent
operator|.
name|state
argument_list|()
operator|.
name|getNodes
argument_list|()
operator|.
name|isLocalNodeElectedMaster
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Shouldn't publish state when not master"
argument_list|)
throw|;
block|}
try|try
block|{
name|publishClusterState
operator|.
name|publish
argument_list|(
name|clusterChangedEvent
argument_list|,
name|electMaster
operator|.
name|minimumMasterNodes
argument_list|()
argument_list|,
name|ackListener
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|FailedToCommitClusterStateException
name|t
parameter_list|)
block|{
comment|// cluster service logs a WARN message
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to publish cluster state version [{}] (not enough nodes acknowledged, min master nodes [{}])"
argument_list|,
name|clusterChangedEvent
operator|.
name|state
argument_list|()
operator|.
name|version
argument_list|()
argument_list|,
name|electMaster
operator|.
name|minimumMasterNodes
argument_list|()
argument_list|)
expr_stmt|;
name|submitRejoin
argument_list|(
literal|"zen-disco-failed-to-publish"
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
comment|// update the set of nodes to ping after the new cluster state has been published
name|nodesFD
operator|.
name|updateNodesAndPing
argument_list|(
name|clusterChangedEvent
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
comment|// clean the pending cluster queue - we are currently master, so any pending cluster state should be failed
comment|// note that we also clean the queue on master failure (see handleMasterGone) but a delayed cluster state publish
comment|// from a stale master can still make it in the queue during the election (but not be committed)
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
operator|.
name|failAllStatesAndClear
argument_list|(
operator|new
name|ElasticsearchException
argument_list|(
literal|"elected as master"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Gets the current set of nodes involved in the node fault detection.      * NB: for testing purposes      */
DECL|method|getFaultDetectionNodes
specifier|public
name|Set
argument_list|<
name|DiscoveryNode
argument_list|>
name|getFaultDetectionNodes
parameter_list|()
block|{
return|return
name|nodesFD
operator|.
name|getNodes
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|stats
specifier|public
name|DiscoveryStats
name|stats
parameter_list|()
block|{
name|PendingClusterStateStats
name|queueStats
init|=
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
operator|.
name|stats
argument_list|()
decl_stmt|;
return|return
operator|new
name|DiscoveryStats
argument_list|(
name|queueStats
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getDiscoverySettings
specifier|public
name|DiscoverySettings
name|getDiscoverySettings
parameter_list|()
block|{
return|return
name|discoverySettings
return|;
block|}
annotation|@
name|Override
DECL|method|getMinimumMasterNodes
specifier|public
name|int
name|getMinimumMasterNodes
parameter_list|()
block|{
return|return
name|electMaster
operator|.
name|minimumMasterNodes
argument_list|()
return|;
block|}
comment|/**      * returns true if zen discovery is started and there is a currently a background thread active for (re)joining      * the cluster used for testing.      */
DECL|method|joiningCluster
specifier|public
name|boolean
name|joiningCluster
parameter_list|()
block|{
return|return
name|joinThreadControl
operator|.
name|joinThreadActive
argument_list|()
return|;
block|}
comment|// used for testing
DECL|method|pendingClusterStates
specifier|public
name|ClusterState
index|[]
name|pendingClusterStates
parameter_list|()
block|{
return|return
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
operator|.
name|pendingClusterStates
argument_list|()
return|;
block|}
DECL|method|pendingClusterStatesQueue
name|PendingClusterStatesQueue
name|pendingClusterStatesQueue
parameter_list|()
block|{
return|return
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
return|;
block|}
comment|/**      * the main function of a join thread. This function is guaranteed to join the cluster      * or spawn a new join thread upon failure to do so.      */
DECL|method|innerJoinCluster
specifier|private
name|void
name|innerJoinCluster
parameter_list|()
block|{
name|DiscoveryNode
name|masterNode
init|=
literal|null
decl_stmt|;
specifier|final
name|Thread
name|currentThread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|nodeJoinController
operator|.
name|startElectionContext
argument_list|()
expr_stmt|;
while|while
condition|(
name|masterNode
operator|==
literal|null
operator|&&
name|joinThreadControl
operator|.
name|joinThreadActive
argument_list|(
name|currentThread
argument_list|)
condition|)
block|{
name|masterNode
operator|=
name|findMaster
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|joinThreadControl
operator|.
name|joinThreadActive
argument_list|(
name|currentThread
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"thread is no longer in currentJoinThread. Stopping."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|clusterService
operator|.
name|localNode
argument_list|()
operator|.
name|equals
argument_list|(
name|masterNode
argument_list|)
condition|)
block|{
specifier|final
name|int
name|requiredJoins
init|=
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|electMaster
operator|.
name|minimumMasterNodes
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
comment|// we count as one
name|logger
operator|.
name|debug
argument_list|(
literal|"elected as master, waiting for incoming joins ([{}] needed)"
argument_list|,
name|requiredJoins
argument_list|)
expr_stmt|;
name|nodeJoinController
operator|.
name|waitToBeElectedAsMaster
argument_list|(
name|requiredJoins
argument_list|,
name|masterElectionWaitForJoinsTimeout
argument_list|,
operator|new
name|NodeJoinController
operator|.
name|ElectionCallback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onElectedAsMaster
parameter_list|(
name|ClusterState
name|state
parameter_list|)
block|{
name|joinThreadControl
operator|.
name|markThreadAsDone
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
comment|// we only starts nodesFD if we are master (it may be that we received a cluster state while pinging)
name|nodesFD
operator|.
name|updateNodesAndPing
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|// start the nodes FD
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"failed while waiting for nodes to join, rejoining"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|joinThreadControl
operator|.
name|markThreadAsDoneAndStartNew
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// process any incoming joins (they will fail because we are not the master)
name|nodeJoinController
operator|.
name|stopElectionContext
argument_list|(
name|masterNode
operator|+
literal|" elected"
argument_list|)
expr_stmt|;
comment|// send join request
specifier|final
name|boolean
name|success
init|=
name|joinElectedMaster
argument_list|(
name|masterNode
argument_list|)
decl_stmt|;
comment|// finalize join through the cluster state update thread
specifier|final
name|DiscoveryNode
name|finalMasterNode
init|=
name|masterNode
decl_stmt|;
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"finalize_join ("
operator|+
name|masterNode
operator|+
literal|")"
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
operator|!
name|success
condition|)
block|{
comment|// failed to join. Try again...
name|joinThreadControl
operator|.
name|markThreadAsDoneAndStartNew
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
return|return
name|unchanged
argument_list|()
return|;
block|}
if|if
condition|(
name|currentState
operator|.
name|getNodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
operator|==
literal|null
condition|)
block|{
comment|// Post 1.3.0, the master should publish a new cluster state before acking our join request. we now should have
comment|// a valid master.
name|logger
operator|.
name|debug
argument_list|(
literal|"no master node is set, despite of join request completing. retrying pings."
argument_list|)
expr_stmt|;
name|joinThreadControl
operator|.
name|markThreadAsDoneAndStartNew
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
return|return
name|unchanged
argument_list|()
return|;
block|}
if|if
condition|(
operator|!
name|currentState
operator|.
name|getNodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
operator|.
name|equals
argument_list|(
name|finalMasterNode
argument_list|)
condition|)
block|{
return|return
name|joinThreadControl
operator|.
name|stopRunningThreadAndRejoin
argument_list|(
name|currentState
argument_list|,
literal|"master_switched_while_finalizing_join"
argument_list|)
return|;
block|}
comment|// Note: we do not have to start master fault detection here because it's set at {@link #processNextPendingClusterState }
comment|// when the first cluster state arrives.
name|joinThreadControl
operator|.
name|markThreadAsDone
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
return|return
name|unchanged
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
annotation|@
name|Nullable
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"unexpected error while trying to finalize cluster join"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|joinThreadControl
operator|.
name|markThreadAsDoneAndStartNew
argument_list|(
name|currentThread
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Join a newly elected master.      *      * @return true if successful      */
DECL|method|joinElectedMaster
specifier|private
name|boolean
name|joinElectedMaster
parameter_list|(
name|DiscoveryNode
name|masterNode
parameter_list|)
block|{
try|try
block|{
comment|// first, make sure we can connect to the master
name|transportService
operator|.
name|connectToNode
argument_list|(
name|masterNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to connect to master [{}], retrying..."
argument_list|,
name|masterNode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|joinAttempt
init|=
literal|0
decl_stmt|;
comment|// we retry on illegal state if the master is not yet ready
while|while
condition|(
literal|true
condition|)
block|{
try|try
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"joining master {}"
argument_list|,
name|masterNode
argument_list|)
expr_stmt|;
name|membership
operator|.
name|sendJoinRequestBlocking
argument_list|(
name|masterNode
argument_list|,
name|clusterService
operator|.
name|localNode
argument_list|()
argument_list|,
name|joinTimeout
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
specifier|final
name|Throwable
name|unwrap
init|=
name|ExceptionsHelper
operator|.
name|unwrapCause
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|unwrap
operator|instanceof
name|NotMasterException
condition|)
block|{
if|if
condition|(
operator|++
name|joinAttempt
operator|==
name|this
operator|.
name|joinRetryAttempts
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"failed to send join request to master [{}], reason [{}], tried [{}] times"
argument_list|,
name|masterNode
argument_list|,
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|,
name|joinAttempt
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"master {} failed with [{}]. retrying... (attempts done: [{}])"
argument_list|,
name|masterNode
argument_list|,
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|,
name|joinAttempt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to send join request to master [{}]"
argument_list|,
name|masterNode
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"failed to send join request to master [{}], reason [{}]"
argument_list|,
name|masterNode
argument_list|,
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|this
operator|.
name|joinRetryDelay
operator|.
name|millis
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|submitRejoin
specifier|private
name|void
name|submitRejoin
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
name|source
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
return|return
name|rejoin
argument_list|(
name|currentState
argument_list|,
name|source
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"unexpected failure during [{}]"
argument_list|,
name|source
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|// visible for testing
DECL|class|NodeRemovalClusterStateTaskExecutor
specifier|static
class|class
name|NodeRemovalClusterStateTaskExecutor
implements|implements
name|ClusterStateTaskExecutor
argument_list|<
name|NodeRemovalClusterStateTaskExecutor
operator|.
name|Task
argument_list|>
implements|,
name|ClusterStateTaskListener
block|{
DECL|field|allocationService
specifier|private
specifier|final
name|AllocationService
name|allocationService
decl_stmt|;
DECL|field|electMasterService
specifier|private
specifier|final
name|ElectMasterService
name|electMasterService
decl_stmt|;
DECL|field|rejoin
specifier|private
specifier|final
name|Consumer
argument_list|<
name|String
argument_list|>
name|rejoin
decl_stmt|;
DECL|field|logger
specifier|private
specifier|final
name|Logger
name|logger
decl_stmt|;
DECL|class|Task
specifier|static
class|class
name|Task
block|{
DECL|field|node
specifier|private
specifier|final
name|DiscoveryNode
name|node
decl_stmt|;
DECL|field|reason
specifier|private
specifier|final
name|String
name|reason
decl_stmt|;
DECL|method|Task
name|Task
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|,
specifier|final
name|String
name|reason
parameter_list|)
block|{
name|this
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|this
operator|.
name|reason
operator|=
name|reason
expr_stmt|;
block|}
DECL|method|node
specifier|public
name|DiscoveryNode
name|node
parameter_list|()
block|{
return|return
name|node
return|;
block|}
DECL|method|reason
specifier|public
name|String
name|reason
parameter_list|()
block|{
return|return
name|reason
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|node
operator|+
literal|" "
operator|+
name|reason
return|;
block|}
block|}
DECL|method|NodeRemovalClusterStateTaskExecutor
name|NodeRemovalClusterStateTaskExecutor
parameter_list|(
specifier|final
name|AllocationService
name|allocationService
parameter_list|,
specifier|final
name|ElectMasterService
name|electMasterService
parameter_list|,
specifier|final
name|Consumer
argument_list|<
name|String
argument_list|>
name|rejoin
parameter_list|,
specifier|final
name|Logger
name|logger
parameter_list|)
block|{
name|this
operator|.
name|allocationService
operator|=
name|allocationService
expr_stmt|;
name|this
operator|.
name|electMasterService
operator|=
name|electMasterService
expr_stmt|;
name|this
operator|.
name|rejoin
operator|=
name|rejoin
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|execute
specifier|public
name|ClusterTasksResult
argument_list|<
name|Task
argument_list|>
name|execute
parameter_list|(
specifier|final
name|ClusterState
name|currentState
parameter_list|,
specifier|final
name|List
argument_list|<
name|Task
argument_list|>
name|tasks
parameter_list|)
throws|throws
name|Exception
block|{
specifier|final
name|DiscoveryNodes
operator|.
name|Builder
name|remainingNodesBuilder
init|=
name|DiscoveryNodes
operator|.
name|builder
argument_list|(
name|currentState
operator|.
name|nodes
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
for|for
control|(
specifier|final
name|Task
name|task
range|:
name|tasks
control|)
block|{
if|if
condition|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|nodeExists
argument_list|(
name|task
operator|.
name|node
argument_list|()
argument_list|)
condition|)
block|{
name|remainingNodesBuilder
operator|.
name|remove
argument_list|(
name|task
operator|.
name|node
argument_list|()
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"node [{}] does not exist in cluster state, ignoring"
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|removed
condition|)
block|{
comment|// no nodes to remove, keep the current cluster state
return|return
name|ClusterTasksResult
operator|.
expr|<
name|Task
operator|>
name|builder
argument_list|()
operator|.
name|successes
argument_list|(
name|tasks
argument_list|)
operator|.
name|build
argument_list|(
name|currentState
argument_list|)
return|;
block|}
specifier|final
name|ClusterState
name|remainingNodesClusterState
init|=
name|remainingNodesClusterState
argument_list|(
name|currentState
argument_list|,
name|remainingNodesBuilder
argument_list|)
decl_stmt|;
specifier|final
name|ClusterTasksResult
operator|.
name|Builder
argument_list|<
name|Task
argument_list|>
name|resultBuilder
init|=
name|ClusterTasksResult
operator|.
expr|<
name|Task
operator|>
name|builder
argument_list|()
operator|.
name|successes
argument_list|(
name|tasks
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|electMasterService
operator|.
name|hasEnoughMasterNodes
argument_list|(
name|remainingNodesClusterState
operator|.
name|nodes
argument_list|()
argument_list|)
condition|)
block|{
name|rejoin
operator|.
name|accept
argument_list|(
literal|"not enough master nodes"
argument_list|)
expr_stmt|;
return|return
name|resultBuilder
operator|.
name|build
argument_list|(
name|currentState
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|resultBuilder
operator|.
name|build
argument_list|(
name|allocationService
operator|.
name|deassociateDeadNodes
argument_list|(
name|remainingNodesClusterState
argument_list|,
literal|true
argument_list|,
name|describeTasks
argument_list|(
name|tasks
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|// visible for testing
comment|// hook is used in testing to ensure that correct cluster state is used to test whether a
comment|// rejoin or reroute is needed
DECL|method|remainingNodesClusterState
name|ClusterState
name|remainingNodesClusterState
parameter_list|(
specifier|final
name|ClusterState
name|currentState
parameter_list|,
name|DiscoveryNodes
operator|.
name|Builder
name|remainingNodesBuilder
parameter_list|)
block|{
return|return
name|ClusterState
operator|.
name|builder
argument_list|(
name|currentState
argument_list|)
operator|.
name|nodes
argument_list|(
name|remainingNodesBuilder
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|onFailure
specifier|public
name|void
name|onFailure
parameter_list|(
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"unexpected failure during [{}]"
argument_list|,
name|source
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onNoLongerMaster
specifier|public
name|void
name|onNoLongerMaster
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"no longer master while processing node removal [{}]"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeNode
specifier|private
name|void
name|removeNode
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|,
specifier|final
name|String
name|source
parameter_list|,
specifier|final
name|String
name|reason
parameter_list|)
block|{
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
name|source
operator|+
literal|"("
operator|+
name|node
operator|+
literal|"), reason("
operator|+
name|reason
operator|+
literal|")"
argument_list|,
operator|new
name|NodeRemovalClusterStateTaskExecutor
operator|.
name|Task
argument_list|(
name|node
argument_list|,
name|reason
argument_list|)
argument_list|,
name|ClusterStateTaskConfig
operator|.
name|build
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
argument_list|,
name|nodeRemovalExecutor
argument_list|,
name|nodeRemovalExecutor
argument_list|)
expr_stmt|;
block|}
DECL|method|handleLeaveRequest
specifier|private
name|void
name|handleLeaveRequest
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|lifecycleState
argument_list|()
operator|!=
name|Lifecycle
operator|.
name|State
operator|.
name|STARTED
condition|)
block|{
comment|// not started, ignore a node failure
return|return;
block|}
if|if
condition|(
name|localNodeMaster
argument_list|()
condition|)
block|{
name|removeNode
argument_list|(
name|node
argument_list|,
literal|"zen-disco-node-left"
argument_list|,
literal|"left"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|equals
argument_list|(
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|)
condition|)
block|{
name|handleMasterGone
argument_list|(
name|node
argument_list|,
literal|null
argument_list|,
literal|"shut_down"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|handleNodeFailure
specifier|private
name|void
name|handleNodeFailure
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|,
specifier|final
name|String
name|reason
parameter_list|)
block|{
if|if
condition|(
name|lifecycleState
argument_list|()
operator|!=
name|Lifecycle
operator|.
name|State
operator|.
name|STARTED
condition|)
block|{
comment|// not started, ignore a node failure
return|return;
block|}
if|if
condition|(
operator|!
name|localNodeMaster
argument_list|()
condition|)
block|{
comment|// nothing to do here...
return|return;
block|}
name|removeNode
argument_list|(
name|node
argument_list|,
literal|"zen-disco-node-failed"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
DECL|method|handleMinimumMasterNodesChanged
specifier|private
name|void
name|handleMinimumMasterNodesChanged
parameter_list|(
specifier|final
name|int
name|minimumMasterNodes
parameter_list|)
block|{
if|if
condition|(
name|lifecycleState
argument_list|()
operator|!=
name|Lifecycle
operator|.
name|State
operator|.
name|STARTED
condition|)
block|{
comment|// not started, ignore a node failure
return|return;
block|}
specifier|final
name|int
name|prevMinimumMasterNode
init|=
name|ZenDiscovery
operator|.
name|this
operator|.
name|electMaster
operator|.
name|minimumMasterNodes
argument_list|()
decl_stmt|;
name|ZenDiscovery
operator|.
name|this
operator|.
name|electMaster
operator|.
name|minimumMasterNodes
argument_list|(
name|minimumMasterNodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|localNodeMaster
argument_list|()
condition|)
block|{
comment|// We only set the new value. If the master doesn't see enough nodes it will revoke it's mastership.
return|return;
block|}
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"zen-disco-min-master-nodes-changed"
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
comment|// check if we have enough master nodes, if not, we need to move into joining the cluster again
if|if
condition|(
operator|!
name|electMaster
operator|.
name|hasEnoughMasterNodes
argument_list|(
name|currentState
operator|.
name|nodes
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|rejoin
argument_list|(
name|currentState
argument_list|,
literal|"not enough master nodes on change of minimum_master_nodes from ["
operator|+
name|prevMinimumMasterNode
operator|+
literal|"] to ["
operator|+
name|minimumMasterNodes
operator|+
literal|"]"
argument_list|)
return|;
block|}
return|return
name|unchanged
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onNoLongerMaster
parameter_list|(
name|String
name|source
parameter_list|)
block|{
comment|// ignoring (already logged)
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"unexpected failure during [{}]"
argument_list|,
name|source
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clusterStateProcessed
parameter_list|(
name|String
name|source
parameter_list|,
name|ClusterState
name|oldState
parameter_list|,
name|ClusterState
name|newState
parameter_list|)
block|{
name|electMaster
operator|.
name|logMinimumMasterNodesWarningIfNecessary
argument_list|(
name|oldState
argument_list|,
name|newState
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|handleMasterGone
specifier|private
name|void
name|handleMasterGone
parameter_list|(
specifier|final
name|DiscoveryNode
name|masterNode
parameter_list|,
specifier|final
name|Throwable
name|cause
parameter_list|,
specifier|final
name|String
name|reason
parameter_list|)
block|{
if|if
condition|(
name|lifecycleState
argument_list|()
operator|!=
name|Lifecycle
operator|.
name|State
operator|.
name|STARTED
condition|)
block|{
comment|// not started, ignore a master failure
return|return;
block|}
if|if
condition|(
name|localNodeMaster
argument_list|()
condition|)
block|{
comment|// we might get this on both a master telling us shutting down, and then the disconnect failure
return|return;
block|}
name|logger
operator|.
name|info
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"master_left [{}], reason [{}]"
argument_list|,
name|masterNode
argument_list|,
name|reason
argument_list|)
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"master_failed ("
operator|+
name|masterNode
operator|+
literal|")"
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
if|if
condition|(
operator|!
name|masterNode
operator|.
name|equals
argument_list|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|)
condition|)
block|{
comment|// master got switched on us, no need to send anything
return|return
name|unchanged
argument_list|()
return|;
block|}
comment|// flush any pending cluster states from old master, so it will not be set as master again
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
operator|.
name|failAllStatesAndClear
argument_list|(
operator|new
name|ElasticsearchException
argument_list|(
literal|"master left [{}]"
argument_list|,
name|reason
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rejoin
argument_list|(
name|currentState
argument_list|,
literal|"master left (reason = "
operator|+
name|reason
operator|+
literal|")"
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"unexpected failure during [{}]"
argument_list|,
name|source
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|processNextPendingClusterState
name|void
name|processNextPendingClusterState
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"zen-disco-receive(from master ["
operator|+
name|reason
operator|+
literal|"])"
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|(
name|Priority
operator|.
name|URGENT
argument_list|)
block|{
name|ClusterState
name|newClusterState
init|=
literal|null
decl_stmt|;
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
name|newClusterState
operator|=
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
operator|.
name|getNextClusterStateToProcess
argument_list|()
expr_stmt|;
comment|// all pending states have been processed
if|if
condition|(
name|newClusterState
operator|==
literal|null
condition|)
block|{
return|return
name|unchanged
argument_list|()
return|;
block|}
assert|assert
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
operator|!=
literal|null
operator|:
literal|"received a cluster state without a master"
assert|;
assert|assert
operator|!
name|newClusterState
operator|.
name|blocks
argument_list|()
operator|.
name|hasGlobalBlock
argument_list|(
name|discoverySettings
operator|.
name|getNoMasterBlock
argument_list|()
argument_list|)
operator|:
literal|"received a cluster state with a master block"
assert|;
if|if
condition|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|isLocalNodeElectedMaster
argument_list|()
condition|)
block|{
return|return
name|handleAnotherMaster
argument_list|(
name|currentState
argument_list|,
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|,
name|newClusterState
operator|.
name|version
argument_list|()
argument_list|,
literal|"via a new cluster state"
argument_list|)
return|;
block|}
if|if
condition|(
name|shouldIgnoreOrRejectNewClusterState
argument_list|(
name|logger
argument_list|,
name|currentState
argument_list|,
name|newClusterState
argument_list|)
condition|)
block|{
return|return
name|unchanged
argument_list|()
return|;
block|}
comment|// check to see that we monitor the correct master of the cluster
if|if
condition|(
name|masterFD
operator|.
name|masterNode
argument_list|()
operator|==
literal|null
operator|||
operator|!
name|masterFD
operator|.
name|masterNode
argument_list|()
operator|.
name|equals
argument_list|(
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|)
condition|)
block|{
name|masterFD
operator|.
name|restart
argument_list|(
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|,
literal|"new cluster state received and we are monitoring the wrong master ["
operator|+
name|masterFD
operator|.
name|masterNode
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|currentState
operator|.
name|blocks
argument_list|()
operator|.
name|hasGlobalBlock
argument_list|(
name|discoverySettings
operator|.
name|getNoMasterBlock
argument_list|()
argument_list|)
condition|)
block|{
comment|// its a fresh update from the master as we transition from a start of not having a master to having one
name|logger
operator|.
name|debug
argument_list|(
literal|"got first state from fresh master [{}]"
argument_list|,
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodeId
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|newState
argument_list|(
name|newClusterState
argument_list|)
return|;
block|}
comment|// some optimizations to make sure we keep old objects where possible
name|ClusterState
operator|.
name|Builder
name|builder
init|=
name|ClusterState
operator|.
name|builder
argument_list|(
name|newClusterState
argument_list|)
decl_stmt|;
comment|// if the routing table did not change, use the original one
if|if
condition|(
name|newClusterState
operator|.
name|routingTable
argument_list|()
operator|.
name|version
argument_list|()
operator|==
name|currentState
operator|.
name|routingTable
argument_list|()
operator|.
name|version
argument_list|()
condition|)
block|{
name|builder
operator|.
name|routingTable
argument_list|(
name|currentState
operator|.
name|routingTable
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// same for metadata
if|if
condition|(
name|newClusterState
operator|.
name|metaData
argument_list|()
operator|.
name|version
argument_list|()
operator|==
name|currentState
operator|.
name|metaData
argument_list|()
operator|.
name|version
argument_list|()
condition|)
block|{
name|builder
operator|.
name|metaData
argument_list|(
name|currentState
operator|.
name|metaData
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if its not the same version, only copy over new indices or ones that changed the version
name|MetaData
operator|.
name|Builder
name|metaDataBuilder
init|=
name|MetaData
operator|.
name|builder
argument_list|(
name|newClusterState
operator|.
name|metaData
argument_list|()
argument_list|)
operator|.
name|removeAllIndices
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|newClusterState
operator|.
name|metaData
argument_list|()
control|)
block|{
name|IndexMetaData
name|currentIndexMetaData
init|=
name|currentState
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|indexMetaData
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentIndexMetaData
operator|!=
literal|null
operator|&&
name|currentIndexMetaData
operator|.
name|isSameUUID
argument_list|(
name|indexMetaData
operator|.
name|getIndexUUID
argument_list|()
argument_list|)
operator|&&
name|currentIndexMetaData
operator|.
name|getVersion
argument_list|()
operator|==
name|indexMetaData
operator|.
name|getVersion
argument_list|()
condition|)
block|{
comment|// safe to reuse
name|metaDataBuilder
operator|.
name|put
argument_list|(
name|currentIndexMetaData
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|metaDataBuilder
operator|.
name|put
argument_list|(
name|indexMetaData
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|metaData
argument_list|(
name|metaDataBuilder
argument_list|)
expr_stmt|;
block|}
return|return
name|newState
argument_list|(
name|builder
operator|.
name|build
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"unexpected failure during [{}]"
argument_list|,
name|source
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|newClusterState
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
operator|.
name|markAsFailed
argument_list|(
name|newClusterState
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|inner
parameter_list|)
block|{
name|inner
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"unexpected exception while failing [{}]"
argument_list|,
name|source
argument_list|)
argument_list|,
name|inner
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|clusterStateProcessed
parameter_list|(
name|String
name|source
parameter_list|,
name|ClusterState
name|oldState
parameter_list|,
name|ClusterState
name|newState
parameter_list|)
block|{
try|try
block|{
if|if
condition|(
name|newClusterState
operator|!=
literal|null
condition|)
block|{
name|publishClusterState
operator|.
name|pendingStatesQueue
argument_list|()
operator|.
name|markAsProcessed
argument_list|(
name|newClusterState
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|onFailure
argument_list|(
name|source
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * In the case we follow an elected master the new cluster state needs to have the same elected master and      * the new cluster state version needs to be equal or higher than our cluster state version.      * If the first condition fails we reject the cluster state and throw an error.      * If the second condition fails we ignore the cluster state.      */
DECL|method|shouldIgnoreOrRejectNewClusterState
specifier|public
specifier|static
name|boolean
name|shouldIgnoreOrRejectNewClusterState
parameter_list|(
name|Logger
name|logger
parameter_list|,
name|ClusterState
name|currentState
parameter_list|,
name|ClusterState
name|newClusterState
parameter_list|)
block|{
name|validateStateIsFromCurrentMaster
argument_list|(
name|logger
argument_list|,
name|currentState
operator|.
name|nodes
argument_list|()
argument_list|,
name|newClusterState
argument_list|)
expr_stmt|;
comment|// reject cluster states that are not new from the same master
if|if
condition|(
name|currentState
operator|.
name|supersedes
argument_list|(
name|newClusterState
argument_list|)
operator|||
operator|(
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodeId
argument_list|()
argument_list|)
operator|&&
name|currentState
operator|.
name|version
argument_list|()
operator|==
name|newClusterState
operator|.
name|version
argument_list|()
operator|)
condition|)
block|{
comment|// if the new state has a smaller version, and it has the same master node, then no need to process it
name|logger
operator|.
name|debug
argument_list|(
literal|"received a cluster state that is not newer than the current one, ignoring (received {}, current {})"
argument_list|,
name|newClusterState
operator|.
name|version
argument_list|()
argument_list|,
name|currentState
operator|.
name|version
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// reject older cluster states if we are following a master
if|if
condition|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodeId
argument_list|()
operator|!=
literal|null
operator|&&
name|newClusterState
operator|.
name|version
argument_list|()
operator|<
name|currentState
operator|.
name|version
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"received a cluster state that has a lower version than the current one, ignoring (received {}, current {})"
argument_list|,
name|newClusterState
operator|.
name|version
argument_list|()
argument_list|,
name|currentState
operator|.
name|version
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * In the case we follow an elected master the new cluster state needs to have the same elected master      * This method checks for this and throws an exception if needed      */
DECL|method|validateStateIsFromCurrentMaster
specifier|public
specifier|static
name|void
name|validateStateIsFromCurrentMaster
parameter_list|(
name|Logger
name|logger
parameter_list|,
name|DiscoveryNodes
name|currentNodes
parameter_list|,
name|ClusterState
name|newClusterState
parameter_list|)
block|{
if|if
condition|(
name|currentNodes
operator|.
name|getMasterNodeId
argument_list|()
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|currentNodes
operator|.
name|getMasterNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNodeId
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"received a cluster state from a different master than the current one, rejecting (received {}, current {})"
argument_list|,
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|,
name|currentNodes
operator|.
name|getMasterNode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cluster state from a different master than the current one, rejecting (received "
operator|+
name|newClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
operator|+
literal|", current "
operator|+
name|currentNodes
operator|.
name|getMasterNode
argument_list|()
operator|+
literal|")"
argument_list|)
throw|;
block|}
block|}
DECL|method|handleJoinRequest
name|void
name|handleJoinRequest
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|,
specifier|final
name|ClusterState
name|state
parameter_list|,
specifier|final
name|MembershipAction
operator|.
name|JoinCallback
name|callback
parameter_list|)
block|{
if|if
condition|(
name|nodeJoinController
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"discovery module is not yet started"
argument_list|)
throw|;
block|}
else|else
block|{
comment|// we do this in a couple of places including the cluster update thread. This one here is really just best effort
comment|// to ensure we fail as fast as possible.
name|MembershipAction
operator|.
name|ensureIndexCompatibility
argument_list|(
name|node
operator|.
name|getVersion
argument_list|()
operator|.
name|minimumIndexCompatibilityVersion
argument_list|()
argument_list|,
name|state
operator|.
name|getMetaData
argument_list|()
argument_list|)
expr_stmt|;
comment|// try and connect to the node, if it fails, we can raise an exception back to the client...
name|transportService
operator|.
name|connectToNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|// validate the join request, will throw a failure if it fails, which will get back to the
comment|// node calling the join request
try|try
block|{
name|membership
operator|.
name|sendValidateJoinRequestBlocking
argument_list|(
name|node
argument_list|,
name|state
argument_list|,
name|joinTimeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to validate incoming join request from node [{}]"
argument_list|,
name|node
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|callback
operator|.
name|onFailure
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"failure when sending a validation request to node"
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nodeJoinController
operator|.
name|handleJoinRequest
argument_list|(
name|node
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|findMaster
specifier|private
name|DiscoveryNode
name|findMaster
parameter_list|()
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"starting to ping"
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|ZenPing
operator|.
name|PingResponse
argument_list|>
name|fullPingResponses
init|=
name|pingAndWait
argument_list|(
name|pingTimeout
argument_list|)
operator|.
name|toList
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullPingResponses
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No full ping responses"
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|fullPingResponses
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" {none}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ZenPing
operator|.
name|PingResponse
name|pingResponse
range|:
name|fullPingResponses
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\t--> "
argument_list|)
operator|.
name|append
argument_list|(
name|pingResponse
argument_list|)
expr_stmt|;
block|}
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"full ping responses:{}"
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
specifier|final
name|DiscoveryNode
name|localNode
init|=
name|clusterService
operator|.
name|localNode
argument_list|()
decl_stmt|;
comment|// add our selves
assert|assert
name|fullPingResponses
operator|.
name|stream
argument_list|()
operator|.
name|map
argument_list|(
name|ZenPing
operator|.
name|PingResponse
operator|::
name|node
argument_list|)
operator|.
name|filter
argument_list|(
name|n
lambda|->
name|n
operator|.
name|equals
argument_list|(
name|localNode
argument_list|)
argument_list|)
operator|.
name|findAny
argument_list|()
operator|.
name|isPresent
argument_list|()
operator|==
literal|false
assert|;
name|fullPingResponses
operator|.
name|add
argument_list|(
operator|new
name|ZenPing
operator|.
name|PingResponse
argument_list|(
name|localNode
argument_list|,
literal|null
argument_list|,
name|clusterService
operator|.
name|state
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// filter responses
specifier|final
name|List
argument_list|<
name|ZenPing
operator|.
name|PingResponse
argument_list|>
name|pingResponses
init|=
name|filterPingResponses
argument_list|(
name|fullPingResponses
argument_list|,
name|masterElectionIgnoreNonMasters
argument_list|,
name|logger
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|DiscoveryNode
argument_list|>
name|activeMasters
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ZenPing
operator|.
name|PingResponse
name|pingResponse
range|:
name|pingResponses
control|)
block|{
comment|// We can't include the local node in pingMasters list, otherwise we may up electing ourselves without
comment|// any check / verifications from other nodes in ZenDiscover#innerJoinCluster()
if|if
condition|(
name|pingResponse
operator|.
name|master
argument_list|()
operator|!=
literal|null
operator|&&
operator|!
name|localNode
operator|.
name|equals
argument_list|(
name|pingResponse
operator|.
name|master
argument_list|()
argument_list|)
condition|)
block|{
name|activeMasters
operator|.
name|add
argument_list|(
name|pingResponse
operator|.
name|master
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// nodes discovered during pinging
name|List
argument_list|<
name|ElectMasterService
operator|.
name|MasterCandidate
argument_list|>
name|masterCandidates
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ZenPing
operator|.
name|PingResponse
name|pingResponse
range|:
name|pingResponses
control|)
block|{
if|if
condition|(
name|pingResponse
operator|.
name|node
argument_list|()
operator|.
name|isMasterNode
argument_list|()
condition|)
block|{
name|masterCandidates
operator|.
name|add
argument_list|(
operator|new
name|ElectMasterService
operator|.
name|MasterCandidate
argument_list|(
name|pingResponse
operator|.
name|node
argument_list|()
argument_list|,
name|pingResponse
operator|.
name|getClusterStateVersion
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|activeMasters
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|electMaster
operator|.
name|hasEnoughCandidates
argument_list|(
name|masterCandidates
argument_list|)
condition|)
block|{
specifier|final
name|ElectMasterService
operator|.
name|MasterCandidate
name|winner
init|=
name|electMaster
operator|.
name|electMaster
argument_list|(
name|masterCandidates
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"candidate {} won election"
argument_list|,
name|winner
argument_list|)
expr_stmt|;
return|return
name|winner
operator|.
name|getNode
argument_list|()
return|;
block|}
else|else
block|{
comment|// if we don't have enough master nodes, we bail, because there are not enough master to elect from
name|logger
operator|.
name|trace
argument_list|(
literal|"not enough master nodes [{}]"
argument_list|,
name|masterCandidates
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
else|else
block|{
assert|assert
operator|!
name|activeMasters
operator|.
name|contains
argument_list|(
name|localNode
argument_list|)
operator|:
literal|"local node should never be elected as master when other nodes indicate an active master"
assert|;
comment|// lets tie break between discovered nodes
return|return
name|electMaster
operator|.
name|tieBreakActiveMasters
argument_list|(
name|activeMasters
argument_list|)
return|;
block|}
block|}
DECL|method|filterPingResponses
specifier|static
name|List
argument_list|<
name|ZenPing
operator|.
name|PingResponse
argument_list|>
name|filterPingResponses
parameter_list|(
name|List
argument_list|<
name|ZenPing
operator|.
name|PingResponse
argument_list|>
name|fullPingResponses
parameter_list|,
name|boolean
name|masterElectionIgnoreNonMasters
parameter_list|,
name|Logger
name|logger
parameter_list|)
block|{
name|List
argument_list|<
name|ZenPing
operator|.
name|PingResponse
argument_list|>
name|pingResponses
decl_stmt|;
if|if
condition|(
name|masterElectionIgnoreNonMasters
condition|)
block|{
name|pingResponses
operator|=
name|fullPingResponses
operator|.
name|stream
argument_list|()
operator|.
name|filter
argument_list|(
name|ping
lambda|->
name|ping
operator|.
name|node
argument_list|()
operator|.
name|isMasterNode
argument_list|()
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pingResponses
operator|=
name|fullPingResponses
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
if|if
condition|(
name|pingResponses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|" {none}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ZenPing
operator|.
name|PingResponse
name|pingResponse
range|:
name|pingResponses
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
literal|"\n\t--> "
argument_list|)
operator|.
name|append
argument_list|(
name|pingResponse
argument_list|)
expr_stmt|;
block|}
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"filtered ping responses: (ignore_non_masters [{}]){}"
argument_list|,
name|masterElectionIgnoreNonMasters
argument_list|,
name|sb
argument_list|)
expr_stmt|;
block|}
return|return
name|pingResponses
return|;
block|}
DECL|method|rejoin
specifier|protected
name|ClusterStateTaskExecutor
operator|.
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|rejoin
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
comment|// *** called from within an cluster state update task *** //
assert|assert
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|contains
argument_list|(
name|ClusterService
operator|.
name|UPDATE_THREAD_NAME
argument_list|)
assert|;
name|logger
operator|.
name|warn
argument_list|(
literal|"{}, current nodes: {}"
argument_list|,
name|reason
argument_list|,
name|clusterState
operator|.
name|nodes
argument_list|()
argument_list|)
expr_stmt|;
name|nodesFD
operator|.
name|stop
argument_list|()
expr_stmt|;
name|masterFD
operator|.
name|stop
argument_list|(
name|reason
argument_list|)
expr_stmt|;
comment|// TODO: do we want to force a new thread if we actively removed the master? this is to give a full pinging cycle
comment|// before a decision is made.
name|joinThreadControl
operator|.
name|startNewThreadIfNotRunning
argument_list|()
expr_stmt|;
return|return
name|LocalClusterUpdateTask
operator|.
name|noMaster
argument_list|()
return|;
block|}
DECL|method|localNodeMaster
specifier|private
name|boolean
name|localNodeMaster
parameter_list|()
block|{
return|return
name|nodes
argument_list|()
operator|.
name|isLocalNodeElectedMaster
argument_list|()
return|;
block|}
DECL|method|handleAnotherMaster
specifier|private
name|ClusterStateTaskExecutor
operator|.
name|ClusterTasksResult
name|handleAnotherMaster
parameter_list|(
name|ClusterState
name|localClusterState
parameter_list|,
specifier|final
name|DiscoveryNode
name|otherMaster
parameter_list|,
name|long
name|otherClusterStateVersion
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
assert|assert
name|localClusterState
operator|.
name|nodes
argument_list|()
operator|.
name|isLocalNodeElectedMaster
argument_list|()
operator|:
literal|"handleAnotherMaster called but current node is not a master"
assert|;
assert|assert
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|contains
argument_list|(
name|ClusterService
operator|.
name|UPDATE_THREAD_NAME
argument_list|)
operator|:
literal|"not called from the cluster state update thread"
assert|;
if|if
condition|(
name|otherClusterStateVersion
operator|>
name|localClusterState
operator|.
name|version
argument_list|()
condition|)
block|{
return|return
name|rejoin
argument_list|(
name|localClusterState
argument_list|,
literal|"zen-disco-discovered another master with a new cluster_state ["
operator|+
name|otherMaster
operator|+
literal|"]["
operator|+
name|reason
operator|+
literal|"]"
argument_list|)
return|;
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"discovered [{}] which is also master but with an older cluster_state, telling [{}] to rejoin the cluster ([{}])"
argument_list|,
name|otherMaster
argument_list|,
name|otherMaster
argument_list|,
name|reason
argument_list|)
expr_stmt|;
comment|// spawn to a background thread to not do blocking operations on the cluster state thread
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
operator|new
name|AbstractRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to send rejoin request to [{}]"
argument_list|,
name|otherMaster
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
comment|// make sure we're connected to this node (connect to node does nothing if we're already connected)
comment|// since the network connections are asymmetric, it may be that we received a state but have disconnected from the node
comment|// in the past (after a master failure, for example)
name|transportService
operator|.
name|connectToNode
argument_list|(
name|otherMaster
argument_list|)
expr_stmt|;
name|transportService
operator|.
name|sendRequest
argument_list|(
name|otherMaster
argument_list|,
name|DISCOVERY_REJOIN_ACTION_NAME
argument_list|,
operator|new
name|RejoinClusterRequest
argument_list|(
name|localNode
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|,
operator|new
name|EmptyTransportResponseHandler
argument_list|(
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|handleException
parameter_list|(
name|TransportException
name|exp
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"failed to send rejoin request to [{}]"
argument_list|,
name|otherMaster
argument_list|)
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
return|return
name|LocalClusterUpdateTask
operator|.
name|unchanged
argument_list|()
return|;
block|}
block|}
DECL|method|pingAndWait
specifier|private
name|ZenPing
operator|.
name|PingCollection
name|pingAndWait
parameter_list|(
name|TimeValue
name|timeout
parameter_list|)
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|ZenPing
operator|.
name|PingCollection
argument_list|>
name|response
init|=
operator|new
name|CompletableFuture
argument_list|<>
argument_list|()
decl_stmt|;
try|try
block|{
name|zenPing
operator|.
name|ping
argument_list|(
name|response
operator|::
name|complete
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
comment|// logged later
name|response
operator|.
name|completeExceptionally
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
try|try
block|{
return|return
name|response
operator|.
name|get
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"pingAndWait interrupted"
argument_list|)
expr_stmt|;
return|return
operator|new
name|ZenPing
operator|.
name|PingCollection
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|ExecutionException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Ping execution failed"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
operator|new
name|ZenPing
operator|.
name|PingCollection
argument_list|()
return|;
block|}
block|}
DECL|class|NewPendingClusterStateListener
specifier|private
class|class
name|NewPendingClusterStateListener
implements|implements
name|PublishClusterStateAction
operator|.
name|NewPendingClusterStateListener
block|{
annotation|@
name|Override
DECL|method|onNewClusterState
specifier|public
name|void
name|onNewClusterState
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|processNextPendingClusterState
argument_list|(
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MembershipListener
specifier|private
class|class
name|MembershipListener
implements|implements
name|MembershipAction
operator|.
name|MembershipListener
block|{
annotation|@
name|Override
DECL|method|onJoin
specifier|public
name|void
name|onJoin
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|MembershipAction
operator|.
name|JoinCallback
name|callback
parameter_list|)
block|{
name|handleJoinRequest
argument_list|(
name|node
argument_list|,
name|clusterService
operator|.
name|state
argument_list|()
argument_list|,
name|callback
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onLeave
specifier|public
name|void
name|onLeave
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|)
block|{
name|handleLeaveRequest
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|NodeFaultDetectionListener
specifier|private
class|class
name|NodeFaultDetectionListener
extends|extends
name|NodesFaultDetection
operator|.
name|Listener
block|{
DECL|field|pingsWhileMaster
specifier|private
specifier|final
name|AtomicInteger
name|pingsWhileMaster
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
annotation|@
name|Override
DECL|method|onNodeFailure
specifier|public
name|void
name|onNodeFailure
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|handleNodeFailure
argument_list|(
name|node
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onPingReceived
specifier|public
name|void
name|onPingReceived
parameter_list|(
specifier|final
name|NodesFaultDetection
operator|.
name|PingRequest
name|pingRequest
parameter_list|)
block|{
comment|// if we are master, we don't expect any fault detection from another node. If we get it
comment|// means we potentially have two masters in the cluster.
if|if
condition|(
operator|!
name|localNodeMaster
argument_list|()
condition|)
block|{
name|pingsWhileMaster
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pingsWhileMaster
operator|.
name|incrementAndGet
argument_list|()
operator|<
name|maxPingsFromAnotherMaster
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"got a ping from another master {}. current ping count: [{}]"
argument_list|,
name|pingRequest
operator|.
name|masterNode
argument_list|()
argument_list|,
name|pingsWhileMaster
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"got a ping from another master {}. resolving who should rejoin. current ping count: [{}]"
argument_list|,
name|pingRequest
operator|.
name|masterNode
argument_list|()
argument_list|,
name|pingsWhileMaster
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"ping from another master"
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|isLocalNodeElectedMaster
argument_list|()
condition|)
block|{
name|pingsWhileMaster
operator|.
name|set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|handleAnotherMaster
argument_list|(
name|currentState
argument_list|,
name|pingRequest
operator|.
name|masterNode
argument_list|()
argument_list|,
name|pingRequest
operator|.
name|clusterStateVersion
argument_list|()
argument_list|,
literal|"node fd ping"
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|unchanged
argument_list|()
return|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"unexpected error during cluster state update task after pings from another master"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|MasterNodeFailureListener
specifier|private
class|class
name|MasterNodeFailureListener
implements|implements
name|MasterFaultDetection
operator|.
name|Listener
block|{
annotation|@
name|Override
DECL|method|onMasterFailure
specifier|public
name|void
name|onMasterFailure
parameter_list|(
name|DiscoveryNode
name|masterNode
parameter_list|,
name|Throwable
name|cause
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|handleMasterGone
argument_list|(
name|masterNode
argument_list|,
name|cause
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|RejoinClusterRequest
specifier|public
specifier|static
class|class
name|RejoinClusterRequest
extends|extends
name|TransportRequest
block|{
DECL|field|fromNodeId
specifier|private
name|String
name|fromNodeId
decl_stmt|;
DECL|method|RejoinClusterRequest
name|RejoinClusterRequest
parameter_list|(
name|String
name|fromNodeId
parameter_list|)
block|{
name|this
operator|.
name|fromNodeId
operator|=
name|fromNodeId
expr_stmt|;
block|}
DECL|method|RejoinClusterRequest
specifier|public
name|RejoinClusterRequest
parameter_list|()
block|{         }
annotation|@
name|Override
DECL|method|readFrom
specifier|public
name|void
name|readFrom
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|readFrom
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|fromNodeId
operator|=
name|in
operator|.
name|readOptionalString
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|super
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalString
argument_list|(
name|fromNodeId
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|RejoinClusterRequestHandler
class|class
name|RejoinClusterRequestHandler
implements|implements
name|TransportRequestHandler
argument_list|<
name|RejoinClusterRequest
argument_list|>
block|{
annotation|@
name|Override
DECL|method|messageReceived
specifier|public
name|void
name|messageReceived
parameter_list|(
specifier|final
name|RejoinClusterRequest
name|request
parameter_list|,
specifier|final
name|TransportChannel
name|channel
parameter_list|)
throws|throws
name|Exception
block|{
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"received a request to rejoin the cluster from ["
operator|+
name|request
operator|.
name|fromNodeId
operator|+
literal|"]"
argument_list|,
operator|new
name|LocalClusterUpdateTask
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
try|try
block|{
name|channel
operator|.
name|sendResponse
argument_list|(
name|TransportResponse
operator|.
name|Empty
operator|.
name|INSTANCE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to send response on rejoin cluster request handling"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
name|rejoin
argument_list|(
name|currentState
argument_list|,
literal|"received a request to rejoin the cluster from ["
operator|+
name|request
operator|.
name|fromNodeId
operator|+
literal|"]"
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
call|(
name|Supplier
argument_list|<
name|?
argument_list|>
call|)
argument_list|()
operator|->
operator|new
name|ParameterizedMessage
argument_list|(
literal|"unexpected failure during [{}]"
argument_list|,
name|source
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * All control of the join thread should happen under the cluster state update task thread.      * This is important to make sure that the background joining process is always in sync with any cluster state updates      * like master loss, failure to join, received cluster state while joining etc.      */
DECL|class|JoinThreadControl
specifier|private
class|class
name|JoinThreadControl
block|{
DECL|field|running
specifier|private
specifier|final
name|AtomicBoolean
name|running
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|currentJoinThread
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|Thread
argument_list|>
name|currentJoinThread
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
comment|/** returns true if join thread control is started and there is currently an active join thread */
DECL|method|joinThreadActive
specifier|public
name|boolean
name|joinThreadActive
parameter_list|()
block|{
name|Thread
name|currentThread
init|=
name|currentJoinThread
operator|.
name|get
argument_list|()
decl_stmt|;
return|return
name|running
operator|.
name|get
argument_list|()
operator|&&
name|currentThread
operator|!=
literal|null
operator|&&
name|currentThread
operator|.
name|isAlive
argument_list|()
return|;
block|}
comment|/** returns true if join thread control is started and the supplied thread is the currently active joinThread */
DECL|method|joinThreadActive
specifier|public
name|boolean
name|joinThreadActive
parameter_list|(
name|Thread
name|joinThread
parameter_list|)
block|{
return|return
name|running
operator|.
name|get
argument_list|()
operator|&&
name|joinThread
operator|.
name|equals
argument_list|(
name|currentJoinThread
operator|.
name|get
argument_list|()
argument_list|)
return|;
block|}
comment|/** cleans any running joining thread and calls {@link #rejoin} */
DECL|method|stopRunningThreadAndRejoin
specifier|public
name|ClusterStateTaskExecutor
operator|.
name|ClusterTasksResult
argument_list|<
name|LocalClusterUpdateTask
argument_list|>
name|stopRunningThreadAndRejoin
parameter_list|(
name|ClusterState
name|clusterState
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|ClusterService
operator|.
name|assertClusterStateThread
argument_list|()
expr_stmt|;
name|currentJoinThread
operator|.
name|set
argument_list|(
literal|null
argument_list|)
expr_stmt|;
return|return
name|rejoin
argument_list|(
name|clusterState
argument_list|,
name|reason
argument_list|)
return|;
block|}
comment|/** starts a new joining thread if there is no currently active one and join thread controlling is started */
DECL|method|startNewThreadIfNotRunning
specifier|public
name|void
name|startNewThreadIfNotRunning
parameter_list|()
block|{
name|ClusterService
operator|.
name|assertClusterStateThread
argument_list|()
expr_stmt|;
if|if
condition|(
name|joinThreadActive
argument_list|()
condition|)
block|{
return|return;
block|}
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Thread
name|currentThread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|currentJoinThread
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|currentThread
argument_list|)
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|running
operator|.
name|get
argument_list|()
operator|&&
name|joinThreadActive
argument_list|(
name|currentThread
argument_list|)
condition|)
block|{
try|try
block|{
name|innerJoinCluster
argument_list|()
expr_stmt|;
return|return;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"unexpected error while joining cluster, trying again"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// Because we catch any exception here, we want to know in
comment|// tests if an uncaught exception got to this point and the test infra uncaught exception
comment|// leak detection can catch this. In practise no uncaught exception should leak
assert|assert
name|ExceptionsHelper
operator|.
name|reThrowIfNotNull
argument_list|(
name|e
argument_list|)
assert|;
block|}
block|}
comment|// cleaning the current thread from currentJoinThread is done by explicit calls.
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**          * marks the given joinThread as completed and makes sure another thread is running (starting one if needed)          * If the given thread is not the currently running join thread, the command is ignored.          */
DECL|method|markThreadAsDoneAndStartNew
specifier|public
name|void
name|markThreadAsDoneAndStartNew
parameter_list|(
name|Thread
name|joinThread
parameter_list|)
block|{
name|ClusterService
operator|.
name|assertClusterStateThread
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|markThreadAsDone
argument_list|(
name|joinThread
argument_list|)
condition|)
block|{
return|return;
block|}
name|startNewThreadIfNotRunning
argument_list|()
expr_stmt|;
block|}
comment|/** marks the given joinThread as completed. Returns false if the supplied thread is not the currently active join thread */
DECL|method|markThreadAsDone
specifier|public
name|boolean
name|markThreadAsDone
parameter_list|(
name|Thread
name|joinThread
parameter_list|)
block|{
name|ClusterService
operator|.
name|assertClusterStateThread
argument_list|()
expr_stmt|;
return|return
name|currentJoinThread
operator|.
name|compareAndSet
argument_list|(
name|joinThread
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|stop
specifier|public
name|void
name|stop
parameter_list|()
block|{
name|running
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Thread
name|joinThread
init|=
name|currentJoinThread
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|joinThread
operator|!=
literal|null
condition|)
block|{
name|joinThread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|start
specifier|public
name|void
name|start
parameter_list|()
block|{
name|running
operator|.
name|set
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

