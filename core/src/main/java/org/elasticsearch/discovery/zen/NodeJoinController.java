begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.discovery.zen
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|zen
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchTimeoutException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateUpdateTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|NotMasterException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|block
operator|.
name|ClusterBlocks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RoutingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|RoutingAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|service
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Priority
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|DiscoverySettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|zen
operator|.
name|membership
operator|.
name|MembershipAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_comment
comment|/**  * This class processes incoming join request (passed zia {@link ZenDiscovery}). Incoming nodes  * are directly added to the cluster state or are accumulated during master election.  */
end_comment

begin_class
DECL|class|NodeJoinController
specifier|public
class|class
name|NodeJoinController
extends|extends
name|AbstractComponent
block|{
DECL|field|clusterService
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|routingService
specifier|final
name|RoutingService
name|routingService
decl_stmt|;
DECL|field|discoverySettings
specifier|final
name|DiscoverySettings
name|discoverySettings
decl_stmt|;
DECL|field|accumulateJoins
specifier|final
name|AtomicBoolean
name|accumulateJoins
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// this is site while trying to become a master
DECL|field|electionContext
specifier|final
name|AtomicReference
argument_list|<
name|ElectionContext
argument_list|>
name|electionContext
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|pendingJoinRequests
specifier|protected
specifier|final
name|Map
argument_list|<
name|DiscoveryNode
argument_list|,
name|List
argument_list|<
name|MembershipAction
operator|.
name|JoinCallback
argument_list|>
argument_list|>
name|pendingJoinRequests
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|NodeJoinController
specifier|public
name|NodeJoinController
parameter_list|(
name|ClusterService
name|clusterService
parameter_list|,
name|RoutingService
name|routingService
parameter_list|,
name|DiscoverySettings
name|discoverySettings
parameter_list|,
name|Settings
name|settings
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|routingService
operator|=
name|routingService
expr_stmt|;
name|this
operator|.
name|discoverySettings
operator|=
name|discoverySettings
expr_stmt|;
block|}
comment|/**      * waits for enough incoming joins from master eligible nodes to complete the master election      *<p>      * You must start accumulating joins before calling this method. See {@link #startAccumulatingJoins()}      *<p>      * The method will return once the local node has been elected as master or some failure/timeout has happened.      * The exact outcome is communicated via the callback parameter, which is guaranteed to be called.      *      * @param requiredMasterJoins the number of joins from master eligible needed to complete the election      * @param timeValue           how long to wait before failing. a timeout is communicated via the callback's onFailure method.      * @param callback            the result of the election (success or failure) will be communicated by calling methods on this      *                            object      **/
DECL|method|waitToBeElectedAsMaster
specifier|public
name|void
name|waitToBeElectedAsMaster
parameter_list|(
name|int
name|requiredMasterJoins
parameter_list|,
name|TimeValue
name|timeValue
parameter_list|,
specifier|final
name|ElectionCallback
name|callback
parameter_list|)
block|{
assert|assert
name|accumulateJoins
operator|.
name|get
argument_list|()
operator|:
literal|"waitToBeElectedAsMaster is called we are not accumulating joins"
assert|;
specifier|final
name|CountDownLatch
name|done
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ElectionContext
name|newContext
init|=
operator|new
name|ElectionContext
argument_list|(
name|callback
argument_list|,
name|requiredMasterJoins
argument_list|,
name|clusterService
argument_list|)
block|{
annotation|@
name|Override
name|void
name|onClose
parameter_list|()
block|{
if|if
condition|(
name|electionContext
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|stopAccumulatingJoins
argument_list|(
literal|"election closed"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
literal|false
operator|:
literal|"failed to remove current election context"
assert|;
block|}
name|done
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
if|if
condition|(
name|electionContext
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|newContext
argument_list|)
operator|==
literal|false
condition|)
block|{
comment|// should never happen, but be conservative
name|failContext
argument_list|(
name|newContext
argument_list|,
operator|new
name|IllegalStateException
argument_list|(
literal|"double waiting for election"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
try|try
block|{
comment|// check what we have so far..
name|checkPendingJoinsAndElectIfNeeded
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
name|done
operator|.
name|await
argument_list|(
name|timeValue
operator|.
name|millis
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|MILLISECONDS
argument_list|)
condition|)
block|{
comment|// callback handles everything
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{              }
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
specifier|final
name|int
name|pendingNodes
decl_stmt|;
synchronized|synchronized
init|(
name|pendingJoinRequests
init|)
block|{
name|pendingNodes
operator|=
name|pendingJoinRequests
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"timed out waiting to be elected. waited [{}]. pending node joins [{}]"
argument_list|,
name|timeValue
argument_list|,
name|pendingNodes
argument_list|)
expr_stmt|;
block|}
comment|// callback will clear the context, if it's active
name|failContext
argument_list|(
name|newContext
argument_list|,
operator|new
name|ElasticsearchTimeoutException
argument_list|(
literal|"timed out waiting to be elected"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"unexpected failure while waiting for incoming joins"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|failContext
argument_list|(
name|newContext
argument_list|,
literal|"unexpected failure while waiting for pending joins"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|failContext
specifier|private
name|void
name|failContext
parameter_list|(
specifier|final
name|ElectionContext
name|context
parameter_list|,
specifier|final
name|Throwable
name|throwable
parameter_list|)
block|{
name|failContext
argument_list|(
name|context
argument_list|,
name|throwable
operator|.
name|getMessage
argument_list|()
argument_list|,
name|throwable
argument_list|)
expr_stmt|;
block|}
comment|/** utility method to fail the given election context under the cluster state thread */
DECL|method|failContext
specifier|private
name|void
name|failContext
parameter_list|(
specifier|final
name|ElectionContext
name|context
parameter_list|,
specifier|final
name|String
name|reason
parameter_list|,
specifier|final
name|Throwable
name|throwable
parameter_list|)
block|{
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"zen-disco-join(failure ["
operator|+
name|reason
operator|+
literal|"])"
argument_list|,
operator|new
name|ClusterStateUpdateTask
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|runOnlyOnMaster
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|ClusterState
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
throws|throws
name|Exception
block|{
name|context
operator|.
name|onFailure
argument_list|(
name|throwable
argument_list|)
expr_stmt|;
return|return
name|currentState
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Throwable
name|updateFailure
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"unexpected error while trying to fail election context due to [{}]. original exception [{}]"
argument_list|,
name|updateFailure
argument_list|,
name|reason
argument_list|,
name|throwable
argument_list|)
expr_stmt|;
name|context
operator|.
name|onFailure
argument_list|(
name|updateFailure
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Accumulates any future incoming join request. Pending join requests will be processed in the final steps of becoming a      * master or when {@link #stopAccumulatingJoins(String)} is called.      */
DECL|method|startAccumulatingJoins
specifier|public
name|void
name|startAccumulatingJoins
parameter_list|()
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"starting to accumulate joins"
argument_list|)
expr_stmt|;
name|boolean
name|b
init|=
name|accumulateJoins
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
decl_stmt|;
assert|assert
name|b
operator|==
literal|false
operator|:
literal|"double startAccumulatingJoins() calls"
assert|;
assert|assert
name|electionContext
operator|.
name|get
argument_list|()
operator|==
literal|null
operator|:
literal|"startAccumulatingJoins() called, but there is an ongoing election context"
assert|;
block|}
comment|/** Stopped accumulating joins. All pending joins will be processed. Future joins will be processed immediately */
DECL|method|stopAccumulatingJoins
specifier|public
name|void
name|stopAccumulatingJoins
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"stopping join accumulation ([{}])"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
assert|assert
name|electionContext
operator|.
name|get
argument_list|()
operator|==
literal|null
operator|:
literal|"stopAccumulatingJoins() called, but there is an ongoing election context"
assert|;
name|boolean
name|b
init|=
name|accumulateJoins
operator|.
name|getAndSet
argument_list|(
literal|false
argument_list|)
decl_stmt|;
assert|assert
name|b
operator|:
literal|"stopAccumulatingJoins() called but not accumulating"
assert|;
synchronized|synchronized
init|(
name|pendingJoinRequests
init|)
block|{
if|if
condition|(
name|pendingJoinRequests
operator|.
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|processJoins
argument_list|(
literal|"pending joins after accumulation stop ["
operator|+
name|reason
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * processes or queues an incoming join request.      *<p>      * Note: doesn't do any validation. This should have been done before.      */
DECL|method|handleJoinRequest
specifier|public
name|void
name|handleJoinRequest
parameter_list|(
specifier|final
name|DiscoveryNode
name|node
parameter_list|,
specifier|final
name|MembershipAction
operator|.
name|JoinCallback
name|callback
parameter_list|)
block|{
synchronized|synchronized
init|(
name|pendingJoinRequests
init|)
block|{
name|List
argument_list|<
name|MembershipAction
operator|.
name|JoinCallback
argument_list|>
name|nodeCallbacks
init|=
name|pendingJoinRequests
operator|.
name|get
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeCallbacks
operator|==
literal|null
condition|)
block|{
name|nodeCallbacks
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|pendingJoinRequests
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|nodeCallbacks
argument_list|)
expr_stmt|;
block|}
name|nodeCallbacks
operator|.
name|add
argument_list|(
name|callback
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accumulateJoins
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
name|processJoins
argument_list|(
literal|"join from node["
operator|+
name|node
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkPendingJoinsAndElectIfNeeded
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * checks if there is an on going request to become master and if it has enough pending joins. If so, the node will      * become master via a ClusterState update task.      */
DECL|method|checkPendingJoinsAndElectIfNeeded
specifier|private
name|void
name|checkPendingJoinsAndElectIfNeeded
parameter_list|()
block|{
assert|assert
name|accumulateJoins
operator|.
name|get
argument_list|()
operator|:
literal|"election check requested but we are not accumulating joins"
assert|;
specifier|final
name|ElectionContext
name|context
init|=
name|electionContext
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|context
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|int
name|pendingMasterJoins
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|pendingJoinRequests
init|)
block|{
for|for
control|(
name|DiscoveryNode
name|node
range|:
name|pendingJoinRequests
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|.
name|isMasterNode
argument_list|()
condition|)
block|{
name|pendingMasterJoins
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pendingMasterJoins
operator|<
name|context
operator|.
name|requiredMasterJoins
condition|)
block|{
if|if
condition|(
name|context
operator|.
name|pendingSetAsMasterTask
operator|.
name|get
argument_list|()
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"not enough joins for election. Got [{}], required [{}]"
argument_list|,
name|pendingMasterJoins
argument_list|,
name|context
operator|.
name|requiredMasterJoins
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|context
operator|.
name|pendingSetAsMasterTask
operator|.
name|getAndSet
argument_list|(
literal|true
argument_list|)
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"elected as master task already submitted, ignoring..."
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|String
name|source
init|=
literal|"zen-disco-join(elected_as_master, ["
operator|+
name|pendingMasterJoins
operator|+
literal|"] joins received)"
decl_stmt|;
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
name|source
argument_list|,
operator|new
name|ProcessJoinsTask
argument_list|(
name|Priority
operator|.
name|IMMEDIATE
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|ClusterState
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
comment|// Take into account the previous known nodes, if they happen not to be available
comment|// then fault detection will remove these nodes.
if|if
condition|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// TODO can we tie break here? we don't have a remote master cluster state version to decide on
name|logger
operator|.
name|trace
argument_list|(
literal|"join thread elected local node as master, but there is already a master in place: {}"
argument_list|,
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|getMasterNode
argument_list|()
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|NotMasterException
argument_list|(
literal|"Node ["
operator|+
name|clusterService
operator|.
name|localNode
argument_list|()
operator|+
literal|"] not master for join request"
argument_list|)
throw|;
block|}
name|DiscoveryNodes
operator|.
name|Builder
name|builder
init|=
operator|new
name|DiscoveryNodes
operator|.
name|Builder
argument_list|(
name|currentState
operator|.
name|nodes
argument_list|()
argument_list|)
operator|.
name|masterNodeId
argument_list|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|getLocalNode
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
comment|// update the fact that we are the master...
name|ClusterBlocks
name|clusterBlocks
init|=
name|ClusterBlocks
operator|.
name|builder
argument_list|()
operator|.
name|blocks
argument_list|(
name|currentState
operator|.
name|blocks
argument_list|()
argument_list|)
operator|.
name|removeGlobalBlock
argument_list|(
name|discoverySettings
operator|.
name|getNoMasterBlock
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|currentState
operator|=
name|ClusterState
operator|.
name|builder
argument_list|(
name|currentState
argument_list|)
operator|.
name|nodes
argument_list|(
name|builder
argument_list|)
operator|.
name|blocks
argument_list|(
name|clusterBlocks
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
comment|// reroute now to remove any dead nodes (master may have stepped down when they left and didn't update the routing table)
name|RoutingAllocation
operator|.
name|Result
name|result
init|=
name|routingService
operator|.
name|getAllocationService
argument_list|()
operator|.
name|reroute
argument_list|(
name|currentState
argument_list|,
literal|"nodes joined"
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|changed
argument_list|()
condition|)
block|{
name|currentState
operator|=
name|ClusterState
operator|.
name|builder
argument_list|(
name|currentState
argument_list|)
operator|.
name|routingResult
argument_list|(
name|result
argument_list|)
operator|.
name|build
argument_list|()
expr_stmt|;
block|}
comment|// Add the incoming join requests.
comment|// Note: we only do this now (after the reroute) to avoid assigning shards to these nodes.
return|return
name|super
operator|.
name|execute
argument_list|(
name|currentState
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|runOnlyOnMaster
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|super
operator|.
name|onFailure
argument_list|(
name|source
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|context
operator|.
name|onFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|clusterStateProcessed
parameter_list|(
name|String
name|source
parameter_list|,
name|ClusterState
name|oldState
parameter_list|,
name|ClusterState
name|newState
parameter_list|)
block|{
name|super
operator|.
name|clusterStateProcessed
argument_list|(
name|source
argument_list|,
name|oldState
argument_list|,
name|newState
argument_list|)
expr_stmt|;
name|context
operator|.
name|onElectedAsMaster
argument_list|(
name|newState
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/** process all pending joins */
DECL|method|processJoins
specifier|private
name|void
name|processJoins
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
name|clusterService
operator|.
name|submitStateUpdateTask
argument_list|(
literal|"zen-disco-join("
operator|+
name|reason
operator|+
literal|")"
argument_list|,
operator|new
name|ProcessJoinsTask
argument_list|(
name|Priority
operator|.
name|URGENT
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|ElectionCallback
specifier|public
interface|interface
name|ElectionCallback
block|{
comment|/**          * called when the local node is successfully elected as master          * Guaranteed to be called on the cluster state update thread          **/
DECL|method|onElectedAsMaster
name|void
name|onElectedAsMaster
parameter_list|(
name|ClusterState
name|state
parameter_list|)
function_decl|;
comment|/**          * called when the local node failed to be elected as master          * Guaranteed to be called on the cluster state update thread          **/
DECL|method|onFailure
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
function_decl|;
block|}
DECL|class|ElectionContext
specifier|static
specifier|abstract
class|class
name|ElectionContext
implements|implements
name|ElectionCallback
block|{
DECL|field|callback
specifier|private
specifier|final
name|ElectionCallback
name|callback
decl_stmt|;
DECL|field|requiredMasterJoins
specifier|private
specifier|final
name|int
name|requiredMasterJoins
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
comment|/** set to true after enough joins have been seen and a cluster update task is submitted to become master */
DECL|field|pendingSetAsMasterTask
specifier|final
name|AtomicBoolean
name|pendingSetAsMasterTask
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|field|closed
specifier|final
name|AtomicBoolean
name|closed
init|=
operator|new
name|AtomicBoolean
argument_list|()
decl_stmt|;
DECL|method|ElectionContext
name|ElectionContext
parameter_list|(
name|ElectionCallback
name|callback
parameter_list|,
name|int
name|requiredMasterJoins
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|)
block|{
name|this
operator|.
name|callback
operator|=
name|callback
expr_stmt|;
name|this
operator|.
name|requiredMasterJoins
operator|=
name|requiredMasterJoins
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
block|}
DECL|method|onClose
specifier|abstract
name|void
name|onClose
parameter_list|()
function_decl|;
annotation|@
name|Override
DECL|method|onElectedAsMaster
specifier|public
name|void
name|onElectedAsMaster
parameter_list|(
name|ClusterState
name|state
parameter_list|)
block|{
assert|assert
name|pendingSetAsMasterTask
operator|.
name|get
argument_list|()
operator|:
literal|"onElectedAsMaster called but pendingSetAsMasterTask is not set"
assert|;
name|assertClusterStateThread
argument_list|()
expr_stmt|;
assert|assert
name|state
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeMaster
argument_list|()
operator|:
literal|"onElectedAsMaster called but local node is not master"
assert|;
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
try|try
block|{
name|onClose
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|callback
operator|.
name|onElectedAsMaster
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onFailure
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|assertClusterStateThread
argument_list|()
expr_stmt|;
if|if
condition|(
name|closed
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
try|try
block|{
name|onClose
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|assertClusterStateThread
specifier|private
name|void
name|assertClusterStateThread
parameter_list|()
block|{
assert|assert
name|clusterService
operator|instanceof
name|ClusterService
operator|==
literal|false
operator|||
operator|(
operator|(
name|ClusterService
operator|)
name|clusterService
operator|)
operator|.
name|assertClusterStateThread
argument_list|()
assert|;
block|}
block|}
comment|/**      * Processes any pending joins via a ClusterState update task.      * Note: this task automatically fails (and fails all pending joins) if the current node is not marked as master      */
DECL|class|ProcessJoinsTask
class|class
name|ProcessJoinsTask
extends|extends
name|ClusterStateUpdateTask
block|{
DECL|field|joinCallbacksToRespondTo
specifier|private
specifier|final
name|List
argument_list|<
name|MembershipAction
operator|.
name|JoinCallback
argument_list|>
name|joinCallbacksToRespondTo
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|nodeAdded
specifier|private
name|boolean
name|nodeAdded
init|=
literal|false
decl_stmt|;
DECL|method|ProcessJoinsTask
specifier|public
name|ProcessJoinsTask
parameter_list|(
name|Priority
name|priority
parameter_list|)
block|{
name|super
argument_list|(
name|priority
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|execute
specifier|public
name|ClusterState
name|execute
parameter_list|(
name|ClusterState
name|currentState
parameter_list|)
block|{
name|DiscoveryNodes
operator|.
name|Builder
name|nodesBuilder
decl_stmt|;
synchronized|synchronized
init|(
name|pendingJoinRequests
init|)
block|{
if|if
condition|(
name|pendingJoinRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|currentState
return|;
block|}
name|nodesBuilder
operator|=
name|DiscoveryNodes
operator|.
name|builder
argument_list|(
name|currentState
operator|.
name|nodes
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|DiscoveryNode
argument_list|,
name|List
argument_list|<
name|MembershipAction
operator|.
name|JoinCallback
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|pendingJoinRequests
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|DiscoveryNode
argument_list|,
name|List
argument_list|<
name|MembershipAction
operator|.
name|JoinCallback
argument_list|>
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
specifier|final
name|DiscoveryNode
name|node
init|=
name|entry
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|joinCallbacksToRespondTo
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentState
operator|.
name|nodes
argument_list|()
operator|.
name|nodeExists
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"received a join request for an existing node [{}]"
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeAdded
operator|=
literal|true
expr_stmt|;
name|nodesBuilder
operator|.
name|put
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|DiscoveryNode
name|existingNode
range|:
name|currentState
operator|.
name|nodes
argument_list|()
control|)
block|{
if|if
condition|(
name|node
operator|.
name|getAddress
argument_list|()
operator|.
name|equals
argument_list|(
name|existingNode
operator|.
name|getAddress
argument_list|()
argument_list|)
condition|)
block|{
name|nodesBuilder
operator|.
name|remove
argument_list|(
name|existingNode
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|warn
argument_list|(
literal|"received join request from node [{}], but found existing node {} with same address, removing existing node"
argument_list|,
name|node
argument_list|,
name|existingNode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// we must return a new cluster state instance to force publishing. This is important
comment|// for the joining node to finalize it's join and set us as a master
specifier|final
name|ClusterState
operator|.
name|Builder
name|newState
init|=
name|ClusterState
operator|.
name|builder
argument_list|(
name|currentState
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeAdded
condition|)
block|{
name|newState
operator|.
name|nodes
argument_list|(
name|nodesBuilder
argument_list|)
expr_stmt|;
block|}
return|return
name|newState
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|onNoLongerMaster
specifier|public
name|void
name|onNoLongerMaster
parameter_list|(
name|String
name|source
parameter_list|)
block|{
comment|// we are rejected, so drain all pending task (execute never run)
synchronized|synchronized
init|(
name|pendingJoinRequests
init|)
block|{
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|DiscoveryNode
argument_list|,
name|List
argument_list|<
name|MembershipAction
operator|.
name|JoinCallback
argument_list|>
argument_list|>
argument_list|>
name|iterator
init|=
name|pendingJoinRequests
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|DiscoveryNode
argument_list|,
name|List
argument_list|<
name|MembershipAction
operator|.
name|JoinCallback
argument_list|>
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|joinCallbacksToRespondTo
operator|.
name|addAll
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|Exception
name|e
init|=
operator|new
name|NotMasterException
argument_list|(
literal|"Node ["
operator|+
name|clusterService
operator|.
name|localNode
argument_list|()
operator|+
literal|"] not master for join request"
argument_list|)
decl_stmt|;
name|innerOnFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|innerOnFailure
name|void
name|innerOnFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
for|for
control|(
name|MembershipAction
operator|.
name|JoinCallback
name|callback
range|:
name|joinCallbacksToRespondTo
control|)
block|{
try|try
block|{
name|callback
operator|.
name|onFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"error during task failure"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|onFailure
specifier|public
name|void
name|onFailure
parameter_list|(
name|String
name|source
parameter_list|,
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"unexpected failure during [{}]"
argument_list|,
name|t
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|innerOnFailure
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|clusterStateProcessed
specifier|public
name|void
name|clusterStateProcessed
parameter_list|(
name|String
name|source
parameter_list|,
name|ClusterState
name|oldState
parameter_list|,
name|ClusterState
name|newState
parameter_list|)
block|{
if|if
condition|(
name|nodeAdded
condition|)
block|{
comment|// we reroute not in the same cluster state update since in certain areas we rely on
comment|// the node to be in the cluster state (sampled from ClusterService#state) to be there, also
comment|// shard transitions need to better be handled in such cases
name|routingService
operator|.
name|reroute
argument_list|(
literal|"post_node_add"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|MembershipAction
operator|.
name|JoinCallback
name|callback
range|:
name|joinCallbacksToRespondTo
control|)
block|{
try|try
block|{
name|callback
operator|.
name|onSuccess
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"unexpected error during [{}]"
argument_list|,
name|e
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

