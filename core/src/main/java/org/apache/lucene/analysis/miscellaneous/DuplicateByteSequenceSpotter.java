begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.apache.lucene.analysis.miscellaneous
package|package
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|miscellaneous
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import

begin_comment
comment|/**  * A Trie structure for analysing byte streams for duplicate sequences. Bytes  * from a stream are added one at a time using the addByte method and the number  * of times it has been seen as part of a sequence is returned.  *   * The minimum required length for a duplicate sequence detected is 6 bytes.  *   * The design goals are to maximize speed of lookup while minimizing the space  * required to do so. This has led to a hybrid solution for representing the  * bytes that make up a sequence in the trie.  *   * If we have 6 bytes in sequence e.g. abcdef then they are represented as  * object nodes in the tree as follows:  *<p>  * (a)-(b)-(c)-(def as an int)  *<p>  *   *   * {@link RootTreeNode} objects are used for the first two levels of the tree  * (representing bytes a and b in the example sequence). The combinations of  * objects at these 2 levels are few so internally these objects allocate an  * array of 256 child node objects to quickly address children by indexing  * directly into the densely packed array using a byte value. The third level in  * the tree holds {@link LightweightTreeNode} nodes that have few children  * (typically much less than 256) and so use a dynamically-grown array to hold  * child nodes as simple int primitives. These ints represent the final 3 bytes   * of a sequence and also hold a count of the number of times the entire sequence   * path has been visited (count is a single byte).  *<p>  * The Trie grows indefinitely as more content is added and while theoretically  * it could be massive (a 6-depth tree could produce 256^6 nodes) non-random  * content e.g English text contains fewer variations.  *<p>  * In future we may look at using one of these strategies when memory is tight:  *<ol>  *<li>auto-pruning methods to remove less-visited parts of the tree  *<li>auto-reset to wipe the whole tree and restart when a memory threshold is  * reached  *<li>halting any growth of the tree  *</ol>  *   * Tests on real-world-text show that the size of the tree is a multiple of the  * input text where that multiplier varies between 10 and 5 times as the content  * size increased from 10 to 100 megabytes of content.  *   */
end_comment

begin_class
DECL|class|DuplicateByteSequenceSpotter
specifier|public
class|class
name|DuplicateByteSequenceSpotter
block|{
DECL|field|TREE_DEPTH
specifier|public
specifier|static
specifier|final
name|int
name|TREE_DEPTH
init|=
literal|6
decl_stmt|;
comment|// The maximum number of repetitions that are counted
DECL|field|MAX_HIT_COUNT
specifier|public
specifier|static
specifier|final
name|int
name|MAX_HIT_COUNT
init|=
literal|255
decl_stmt|;
DECL|field|root
specifier|private
specifier|final
name|TreeNode
name|root
decl_stmt|;
DECL|field|sequenceBufferFilled
specifier|private
name|boolean
name|sequenceBufferFilled
init|=
literal|false
decl_stmt|;
DECL|field|sequenceBuffer
specifier|private
specifier|final
name|byte
index|[]
name|sequenceBuffer
init|=
operator|new
name|byte
index|[
name|TREE_DEPTH
index|]
decl_stmt|;
DECL|field|nextFreePos
specifier|private
name|int
name|nextFreePos
init|=
literal|0
decl_stmt|;
comment|// ==Performance info
DECL|field|nodesAllocatedByDepth
specifier|private
specifier|final
name|int
index|[]
name|nodesAllocatedByDepth
decl_stmt|;
DECL|field|nodesResizedByDepth
specifier|private
name|int
name|nodesResizedByDepth
decl_stmt|;
comment|// ==== RAM usage estimation settings ====
DECL|field|bytesAllocated
specifier|private
name|long
name|bytesAllocated
decl_stmt|;
comment|// Root node object plus inner-class reference to containing "this"
comment|// (profiler suggested this was a cost)
DECL|field|TREE_NODE_OBJECT_SIZE
specifier|static
specifier|final
name|long
name|TREE_NODE_OBJECT_SIZE
init|=
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_HEADER
operator|+
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
decl_stmt|;
comment|// A TreeNode specialization with an array ref (dynamically allocated and
comment|// fixed-size)
DECL|field|ROOT_TREE_NODE_OBJECT_SIZE
specifier|static
specifier|final
name|long
name|ROOT_TREE_NODE_OBJECT_SIZE
init|=
name|TREE_NODE_OBJECT_SIZE
operator|+
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
decl_stmt|;
comment|// A KeyedTreeNode specialization with an array ref (dynamically allocated
comment|// and grown)
DECL|field|LIGHTWEIGHT_TREE_NODE_OBJECT_SIZE
specifier|static
specifier|final
name|long
name|LIGHTWEIGHT_TREE_NODE_OBJECT_SIZE
init|=
name|TREE_NODE_OBJECT_SIZE
operator|+
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
decl_stmt|;
comment|// A KeyedTreeNode specialization with a short-based hit count and a
comment|// sequence of bytes encoded as an int
DECL|field|LEAF_NODE_OBJECT_SIZE
specifier|static
specifier|final
name|long
name|LEAF_NODE_OBJECT_SIZE
init|=
name|TREE_NODE_OBJECT_SIZE
operator|+
name|Short
operator|.
name|BYTES
operator|+
name|Integer
operator|.
name|BYTES
decl_stmt|;
DECL|method|DuplicateByteSequenceSpotter
specifier|public
name|DuplicateByteSequenceSpotter
parameter_list|()
block|{
name|this
operator|.
name|nodesAllocatedByDepth
operator|=
operator|new
name|int
index|[
literal|4
index|]
expr_stmt|;
name|this
operator|.
name|bytesAllocated
operator|=
literal|0
expr_stmt|;
name|root
operator|=
operator|new
name|RootTreeNode
argument_list|(
operator|(
name|byte
operator|)
literal|1
argument_list|,
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reset the sequence detection logic to avoid any continuation of the      * immediately previous bytes. A minimum of dupSequenceSize bytes need to be      * added before any new duplicate sequences will be reported.      * Hit counts are not reset by calling this method.       */
DECL|method|startNewSequence
specifier|public
name|void
name|startNewSequence
parameter_list|()
block|{
name|sequenceBufferFilled
operator|=
literal|false
expr_stmt|;
name|nextFreePos
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Add a byte to the sequence.      * @param b      *            the next byte in a sequence      * @return number of times this byte and the preceding 6 bytes have been      *         seen before as a sequence (only counts up to 255)       *       */
DECL|method|addByte
specifier|public
name|short
name|addByte
parameter_list|(
name|byte
name|b
parameter_list|)
block|{
comment|// Add latest byte to circular buffer
name|sequenceBuffer
index|[
name|nextFreePos
index|]
operator|=
name|b
expr_stmt|;
name|nextFreePos
operator|++
expr_stmt|;
if|if
condition|(
name|nextFreePos
operator|>=
name|sequenceBuffer
operator|.
name|length
condition|)
block|{
name|nextFreePos
operator|=
literal|0
expr_stmt|;
name|sequenceBufferFilled
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|sequenceBufferFilled
operator|==
literal|false
condition|)
block|{
return|return
literal|0
return|;
block|}
name|TreeNode
name|node
init|=
name|root
decl_stmt|;
comment|// replay updated sequence of bytes represented in the circular
comment|// buffer starting from the tail
name|int
name|p
init|=
name|nextFreePos
decl_stmt|;
comment|// The first tier of nodes are addressed using individual bytes from the
comment|// sequence
name|node
operator|=
name|node
operator|.
name|add
argument_list|(
name|sequenceBuffer
index|[
name|p
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|nextBufferPos
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|add
argument_list|(
name|sequenceBuffer
index|[
name|p
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|nextBufferPos
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|.
name|add
argument_list|(
name|sequenceBuffer
index|[
name|p
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|// The final 3 bytes in the sequence are represented in an int
comment|// where the 4th byte will contain a hit count.
name|p
operator|=
name|nextBufferPos
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|int
name|sequence
init|=
literal|0xFF
operator|&
name|sequenceBuffer
index|[
name|p
index|]
decl_stmt|;
name|p
operator|=
name|nextBufferPos
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|sequence
operator|<<
literal|8
operator||
operator|(
literal|0xFF
operator|&
name|sequenceBuffer
index|[
name|p
index|]
operator|)
expr_stmt|;
name|p
operator|=
name|nextBufferPos
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sequence
operator|=
name|sequence
operator|<<
literal|8
operator||
operator|(
literal|0xFF
operator|&
name|sequenceBuffer
index|[
name|p
index|]
operator|)
expr_stmt|;
return|return
call|(
name|short
call|)
argument_list|(
name|node
operator|.
name|add
argument_list|(
name|sequence
operator|<<
literal|8
argument_list|)
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|nextBufferPos
specifier|private
name|int
name|nextBufferPos
parameter_list|(
name|int
name|p
parameter_list|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|sequenceBuffer
operator|.
name|length
condition|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
comment|/**      * Base class for nodes in the tree. Subclasses are optimised for use at      * different locations in the tree - speed-optimized nodes represent      * branches near the root while space-optimized nodes are used for deeper      * leaves/branches.      */
DECL|class|TreeNode
specifier|abstract
class|class
name|TreeNode
block|{
DECL|method|TreeNode
name|TreeNode
parameter_list|(
name|byte
name|key
parameter_list|,
name|TreeNode
name|parentNode
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|nodesAllocatedByDepth
index|[
name|depth
index|]
operator|++
expr_stmt|;
block|}
DECL|method|add
specifier|public
specifier|abstract
name|TreeNode
name|add
parameter_list|(
name|byte
name|b
parameter_list|,
name|int
name|depth
parameter_list|)
function_decl|;
comment|/**          *           * @param byteSequence          *            a sequence of bytes encoded as an int          * @return the number of times the full sequence has been seen (counting          *         up to a maximum of 32767).          */
DECL|method|add
specifier|public
specifier|abstract
name|short
name|add
parameter_list|(
name|int
name|byteSequence
parameter_list|)
function_decl|;
block|}
comment|// Node implementation for use at the root of the tree that sacrifices space
comment|// for speed.
DECL|class|RootTreeNode
class|class
name|RootTreeNode
extends|extends
name|TreeNode
block|{
comment|// A null-or-256 sized array that can be indexed into using a byte for
comment|// fast access.
comment|// Being near the root of the tree it is expected that this is a
comment|// non-sparse array.
DECL|field|children
name|TreeNode
index|[]
name|children
decl_stmt|;
DECL|method|RootTreeNode
name|RootTreeNode
parameter_list|(
name|byte
name|key
parameter_list|,
name|TreeNode
name|parentNode
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|parentNode
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|bytesAllocated
operator|+=
name|ROOT_TREE_NODE_OBJECT_SIZE
expr_stmt|;
block|}
DECL|method|add
specifier|public
name|TreeNode
name|add
parameter_list|(
name|byte
name|b
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|children
operator|=
operator|new
name|TreeNode
index|[
literal|256
index|]
expr_stmt|;
name|bytesAllocated
operator|+=
operator|(
name|RamUsageEstimator
operator|.
name|NUM_BYTES_OBJECT_REF
operator|*
literal|256
operator|)
expr_stmt|;
block|}
name|int
name|bIndex
init|=
literal|0xFF
operator|&
name|b
decl_stmt|;
name|TreeNode
name|node
init|=
name|children
index|[
name|bIndex
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|depth
operator|<=
literal|1
condition|)
block|{
comment|// Depths 0 and 1 use RootTreeNode impl and create
comment|// RootTreeNodeImpl children
name|node
operator|=
operator|new
name|RootTreeNode
argument_list|(
name|b
argument_list|,
name|this
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Deeper-level nodes are less visited but more numerous
comment|// so use a more space-friendly data structure
name|node
operator|=
operator|new
name|LightweightTreeNode
argument_list|(
name|b
argument_list|,
name|this
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
name|children
index|[
name|bIndex
index|]
operator|=
name|node
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
annotation|@
name|Override
DECL|method|add
specifier|public
name|short
name|add
parameter_list|(
name|int
name|byteSequence
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Root nodes do not support byte sequences encoded as integers"
argument_list|)
throw|;
block|}
block|}
comment|// Node implementation for use by the depth 3 branches of the tree that
comment|// sacrifices speed for space.
DECL|class|LightweightTreeNode
specifier|final
class|class
name|LightweightTreeNode
extends|extends
name|TreeNode
block|{
comment|// An array dynamically resized but frequently only sized 1 as most
comment|// sequences leading to end leaves are one-off paths.
comment|// It is scanned for matches sequentially and benchmarks showed
comment|// that sorting contents on insertion didn't improve performance.
DECL|field|children
name|int
index|[]
name|children
init|=
literal|null
decl_stmt|;
DECL|method|LightweightTreeNode
name|LightweightTreeNode
parameter_list|(
name|byte
name|key
parameter_list|,
name|TreeNode
name|parentNode
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|parentNode
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|bytesAllocated
operator|+=
name|LIGHTWEIGHT_TREE_NODE_OBJECT_SIZE
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|add
specifier|public
name|short
name|add
parameter_list|(
name|int
name|byteSequence
parameter_list|)
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
comment|// Create array adding new child with the byte sequence combined with hitcount of 1.
comment|// Most nodes at this level we expect to have only 1 child so we start with the
comment|// smallest possible child array.
name|children
operator|=
operator|new
name|int
index|[
literal|1
index|]
expr_stmt|;
name|bytesAllocated
operator|+=
name|RamUsageEstimator
operator|.
name|NUM_BYTES_ARRAY_HEADER
operator|+
name|Integer
operator|.
name|BYTES
expr_stmt|;
name|children
index|[
literal|0
index|]
operator|=
name|byteSequence
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|// Find existing child and if discovered increment count
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|children
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|child
init|=
name|children
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|byteSequence
operator|==
operator|(
name|child
operator|&
literal|0xFFFFFF00
operator|)
condition|)
block|{
name|int
name|hitCount
init|=
name|child
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|hitCount
operator|<
name|MAX_HIT_COUNT
condition|)
block|{
name|children
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
return|return
call|(
name|short
call|)
argument_list|(
name|hitCount
operator|+
literal|1
argument_list|)
return|;
block|}
block|}
comment|// Grow array adding new child
name|int
index|[]
name|newChildren
init|=
operator|new
name|int
index|[
name|children
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|bytesAllocated
operator|+=
name|Integer
operator|.
name|BYTES
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|children
argument_list|,
literal|0
argument_list|,
name|newChildren
argument_list|,
literal|0
argument_list|,
name|children
operator|.
name|length
argument_list|)
expr_stmt|;
name|children
operator|=
name|newChildren
expr_stmt|;
comment|// Combine the byte sequence with a hit count of 1 into an int.
name|children
index|[
name|newChildren
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|byteSequence
operator|+
literal|1
expr_stmt|;
name|nodesResizedByDepth
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
annotation|@
name|Override
DECL|method|add
specifier|public
name|TreeNode
name|add
parameter_list|(
name|byte
name|b
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Leaf nodes do not take byte sequences"
argument_list|)
throw|;
block|}
block|}
DECL|method|getEstimatedSizeInBytes
specifier|public
specifier|final
name|long
name|getEstimatedSizeInBytes
parameter_list|()
block|{
return|return
name|bytesAllocated
return|;
block|}
comment|/**      * @return Performance info - the number of nodes allocated at each depth      */
DECL|method|getNodesAllocatedByDepth
specifier|public
name|int
index|[]
name|getNodesAllocatedByDepth
parameter_list|()
block|{
return|return
name|nodesAllocatedByDepth
operator|.
name|clone
argument_list|()
return|;
block|}
comment|/**      * @return Performance info - the number of resizing of children arrays, at      *         each depth      */
DECL|method|getNodesResizedByDepth
specifier|public
name|int
name|getNodesResizedByDepth
parameter_list|()
block|{
return|return
name|nodesResizedByDepth
return|;
block|}
block|}
end_class

end_unit

