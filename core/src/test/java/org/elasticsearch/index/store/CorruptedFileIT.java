begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.store
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|generators
operator|.
name|RandomPicks
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CheckIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexFileNames
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|health
operator|.
name|ClusterHealthResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|node
operator|.
name|stats
operator|.
name|NodeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|node
operator|.
name|stats
operator|.
name|NodesStatsResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|snapshots
operator|.
name|create
operator|.
name|CreateSnapshotResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|state
operator|.
name|ClusterStateResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|index
operator|.
name|IndexRequestBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|search
operator|.
name|SearchResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|client
operator|.
name|Requests
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|health
operator|.
name|ClusterHealthStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|GroupShardsIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|IndexShardRoutingTable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|EnableAllocationDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|ThrottlingAllocationDecider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeUnit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|PrimaryShardAllocator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|MergePolicyConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryFileChunkRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoverySettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryTarget
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|monitor
operator|.
name|fs
operator|.
name|FsInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|plugins
operator|.
name|Plugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|snapshots
operator|.
name|SnapshotState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|CorruptionUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|ESIntegTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|InternalTestCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|MockIndexEventListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|store
operator|.
name|MockFSIndexStore
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|transport
operator|.
name|MockTransportService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportRequestOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|DirectoryStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
operator|.
name|settingsBuilder
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|CollectionUtils
operator|.
name|iterableAsArrayList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|hamcrest
operator|.
name|ElasticsearchAssertions
operator|.
name|assertAcked
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|hamcrest
operator|.
name|ElasticsearchAssertions
operator|.
name|assertAllSuccessful
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|hamcrest
operator|.
name|ElasticsearchAssertions
operator|.
name|assertHitCount
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|anyOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|empty
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|greaterThanOrEqualTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|is
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|notNullValue
import|;
end_import

begin_class
annotation|@
name|ESIntegTestCase
operator|.
name|ClusterScope
argument_list|(
name|scope
operator|=
name|ESIntegTestCase
operator|.
name|Scope
operator|.
name|SUITE
argument_list|)
DECL|class|CorruptedFileIT
specifier|public
class|class
name|CorruptedFileIT
extends|extends
name|ESIntegTestCase
block|{
annotation|@
name|Override
DECL|method|nodeSettings
specifier|protected
name|Settings
name|nodeSettings
parameter_list|(
name|int
name|nodeOrdinal
parameter_list|)
block|{
return|return
name|Settings
operator|.
name|builder
argument_list|()
comment|// we really need local GW here since this also checks for corruption etc.
comment|// and we need to make sure primaries are not just trashed if we don't have replicas
operator|.
name|put
argument_list|(
name|super
operator|.
name|nodeSettings
argument_list|(
name|nodeOrdinal
argument_list|)
argument_list|)
comment|// speed up recoveries
operator|.
name|put
argument_list|(
name|RecoverySettings
operator|.
name|INDICES_RECOVERY_CONCURRENT_STREAMS_SETTING
operator|.
name|getKey
argument_list|()
argument_list|,
literal|10
argument_list|)
operator|.
name|put
argument_list|(
name|RecoverySettings
operator|.
name|INDICES_RECOVERY_CONCURRENT_SMALL_FILE_STREAMS_SETTING
operator|.
name|getKey
argument_list|()
argument_list|,
literal|10
argument_list|)
operator|.
name|put
argument_list|(
name|ThrottlingAllocationDecider
operator|.
name|CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING
operator|.
name|getKey
argument_list|()
argument_list|,
literal|5
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nodePlugins
specifier|protected
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Plugin
argument_list|>
argument_list|>
name|nodePlugins
parameter_list|()
block|{
return|return
name|pluginList
argument_list|(
name|MockTransportService
operator|.
name|TestPlugin
operator|.
name|class
argument_list|,
name|MockIndexEventListener
operator|.
name|TestPlugin
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Tests that we can actually recover from a corruption on the primary given that we have replica shards around.      */
DECL|method|testCorruptFileAndRecover
specifier|public
name|void
name|testCorruptFileAndRecover
parameter_list|()
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
throws|,
name|IOException
block|{
name|int
name|numDocs
init|=
name|scaledRandomIntBetween
argument_list|(
literal|100
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
comment|// have enough space for 3 copies
name|internalCluster
argument_list|()
operator|.
name|ensureAtLeastNumDataNodes
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|cluster
argument_list|()
operator|.
name|numDataNodes
argument_list|()
operator|==
literal|3
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"--> cluster has [3] data nodes, corrupted primary will be overwritten"
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|cluster
argument_list|()
operator|.
name|numDataNodes
argument_list|()
argument_list|,
name|greaterThanOrEqualTo
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|assertAcked
argument_list|(
name|prepareCreate
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_SHARDS
argument_list|,
literal|"1"
argument_list|)
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"1"
argument_list|)
operator|.
name|put
argument_list|(
name|MergePolicyConfig
operator|.
name|INDEX_MERGE_ENABLED
argument_list|,
literal|false
argument_list|)
operator|.
name|put
argument_list|(
name|MockFSIndexStore
operator|.
name|CHECK_INDEX_ON_CLOSE
argument_list|,
literal|false
argument_list|)
comment|// no checkindex - we corrupt shards on purpose
operator|.
name|put
argument_list|(
name|IndexShard
operator|.
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|1
argument_list|,
name|ByteSizeUnit
operator|.
name|PB
argument_list|)
argument_list|)
comment|// no translog based flush - it might change the .liv / segments.N files
operator|.
name|put
argument_list|(
literal|"indices.recovery.concurrent_streams"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|disableAllocation
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|IndexRequestBuilder
index|[]
name|builders
init|=
operator|new
name|IndexRequestBuilder
index|[
name|numDocs
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|builders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|builders
index|[
name|i
index|]
operator|=
name|client
argument_list|()
operator|.
name|prepareIndex
argument_list|(
literal|"test"
argument_list|,
literal|"type"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"field"
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
block|}
name|indexRandom
argument_list|(
literal|true
argument_list|,
name|builders
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|assertAllSuccessful
argument_list|(
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareFlush
argument_list|()
operator|.
name|setForce
argument_list|(
literal|true
argument_list|)
operator|.
name|setWaitIfOngoing
argument_list|(
literal|true
argument_list|)
operator|.
name|execute
argument_list|()
operator|.
name|actionGet
argument_list|()
argument_list|)
expr_stmt|;
comment|// we have to flush at least once here since we don't corrupt the translog
name|SearchResponse
name|countResponse
init|=
name|client
argument_list|()
operator|.
name|prepareSearch
argument_list|()
operator|.
name|setSize
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertHitCount
argument_list|(
name|countResponse
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numShards
init|=
name|numShards
argument_list|(
literal|"test"
argument_list|)
decl_stmt|;
name|ShardRouting
name|corruptedShardRouting
init|=
name|corruptRandomPrimaryFile
argument_list|()
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"--> {} corrupted"
argument_list|,
name|corruptedShardRouting
argument_list|)
expr_stmt|;
name|enableAllocation
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
comment|/*          * we corrupted the primary shard - now lets make sure we never recover from it successfully          */
name|Settings
name|build
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"2"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareUpdateSettings
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|build
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|ClusterHealthResponse
name|health
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|health
argument_list|(
name|Requests
operator|.
name|clusterHealthRequest
argument_list|(
literal|"test"
argument_list|)
operator|.
name|waitForGreenStatus
argument_list|()
operator|.
name|timeout
argument_list|(
literal|"5m"
argument_list|)
comment|// sometimes due to cluster rebalacing and random settings default timeout is just not enough.
operator|.
name|waitForRelocatingShards
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|.
name|actionGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|health
operator|.
name|isTimedOut
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"cluster state:\n{}\n{}"
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|prettyPrint
argument_list|()
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|preparePendingClusterTasks
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|prettyPrint
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|"timed out waiting for green state"
argument_list|,
name|health
operator|.
name|isTimedOut
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|health
operator|.
name|getStatus
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|ClusterHealthStatus
operator|.
name|GREEN
argument_list|)
argument_list|)
expr_stmt|;
specifier|final
name|int
name|numIterations
init|=
name|scaledRandomIntBetween
argument_list|(
literal|5
argument_list|,
literal|20
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
name|SearchResponse
name|response
init|=
name|client
argument_list|()
operator|.
name|prepareSearch
argument_list|()
operator|.
name|setSize
argument_list|(
name|numDocs
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertHitCount
argument_list|(
name|response
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
block|}
comment|/*          * now hook into the IndicesService and register a close listener to          * run the checkindex. if the corruption is still there we will catch it.          */
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
name|numShards
operator|*
literal|3
argument_list|)
decl_stmt|;
comment|// primary + 2 replicas
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|Throwable
argument_list|>
name|exception
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|IndexEventListener
name|listener
init|=
operator|new
name|IndexEventListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|afterIndexShardClosed
parameter_list|(
name|ShardId
name|sid
parameter_list|,
annotation|@
name|Nullable
name|IndexShard
name|indexShard
parameter_list|,
name|Settings
name|indexSettings
parameter_list|)
block|{
if|if
condition|(
name|indexShard
operator|!=
literal|null
condition|)
block|{
name|Store
name|store
init|=
name|indexShard
operator|.
name|store
argument_list|()
decl_stmt|;
name|store
operator|.
name|incRef
argument_list|()
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|Lucene
operator|.
name|indexExists
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
operator|&&
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
return|return;
block|}
try|try
init|(
name|CheckIndex
name|checkIndex
init|=
operator|new
name|CheckIndex
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
init|)
block|{
name|BytesStreamOutput
name|os
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|,
literal|false
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
name|checkIndex
operator|.
name|setInfoStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|status
init|=
name|checkIndex
operator|.
name|checkIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|clean
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IOException
argument_list|(
literal|"index check failure"
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|exception
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
decl_stmt|;
for|for
control|(
name|MockIndexEventListener
operator|.
name|TestEventListener
name|eventListener
range|:
name|internalCluster
argument_list|()
operator|.
name|getDataNodeInstances
argument_list|(
name|MockIndexEventListener
operator|.
name|TestEventListener
operator|.
name|class
argument_list|)
control|)
block|{
name|eventListener
operator|.
name|setNewDelegate
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareDelete
argument_list|(
literal|"test"
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|exception
argument_list|,
name|empty
argument_list|()
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
for|for
control|(
name|MockIndexEventListener
operator|.
name|TestEventListener
name|eventListener
range|:
name|internalCluster
argument_list|()
operator|.
name|getDataNodeInstances
argument_list|(
name|MockIndexEventListener
operator|.
name|TestEventListener
operator|.
name|class
argument_list|)
control|)
block|{
name|eventListener
operator|.
name|setNewDelegate
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned      * and all other replicas for the healthy shards happens      */
DECL|method|testCorruptPrimaryNoReplica
specifier|public
name|void
name|testCorruptPrimaryNoReplica
parameter_list|()
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
throws|,
name|IOException
block|{
name|int
name|numDocs
init|=
name|scaledRandomIntBetween
argument_list|(
literal|100
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|internalCluster
argument_list|()
operator|.
name|ensureAtLeastNumDataNodes
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|assertAcked
argument_list|(
name|prepareCreate
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"0"
argument_list|)
operator|.
name|put
argument_list|(
name|MergePolicyConfig
operator|.
name|INDEX_MERGE_ENABLED
argument_list|,
literal|false
argument_list|)
operator|.
name|put
argument_list|(
name|MockFSIndexStore
operator|.
name|CHECK_INDEX_ON_CLOSE
argument_list|,
literal|false
argument_list|)
comment|// no checkindex - we corrupt shards on purpose
operator|.
name|put
argument_list|(
name|IndexShard
operator|.
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|1
argument_list|,
name|ByteSizeUnit
operator|.
name|PB
argument_list|)
argument_list|)
comment|// no translog based flush - it might change the .liv / segments.N files
operator|.
name|put
argument_list|(
literal|"indices.recovery.concurrent_streams"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|IndexRequestBuilder
index|[]
name|builders
init|=
operator|new
name|IndexRequestBuilder
index|[
name|numDocs
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|builders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|builders
index|[
name|i
index|]
operator|=
name|client
argument_list|()
operator|.
name|prepareIndex
argument_list|(
literal|"test"
argument_list|,
literal|"type"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"field"
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
block|}
name|indexRandom
argument_list|(
literal|true
argument_list|,
name|builders
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|assertAllSuccessful
argument_list|(
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareFlush
argument_list|()
operator|.
name|setForce
argument_list|(
literal|true
argument_list|)
operator|.
name|setWaitIfOngoing
argument_list|(
literal|true
argument_list|)
operator|.
name|execute
argument_list|()
operator|.
name|actionGet
argument_list|()
argument_list|)
expr_stmt|;
comment|// we have to flush at least once here since we don't corrupt the translog
name|SearchResponse
name|countResponse
init|=
name|client
argument_list|()
operator|.
name|prepareSearch
argument_list|()
operator|.
name|setSize
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertHitCount
argument_list|(
name|countResponse
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
name|ShardRouting
name|shardRouting
init|=
name|corruptRandomPrimaryFile
argument_list|()
decl_stmt|;
comment|/*          * we corrupted the primary shard - now lets make sure we never recover from it successfully          */
name|Settings
name|build
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"1"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareUpdateSettings
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|build
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareReroute
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
name|boolean
name|didClusterTurnRed
init|=
name|awaitBusy
argument_list|(
parameter_list|()
lambda|->
block|{
name|ClusterHealthStatus
name|test
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|health
argument_list|(
name|Requests
operator|.
name|clusterHealthRequest
argument_list|(
literal|"test"
argument_list|)
argument_list|)
operator|.
name|actionGet
argument_list|()
operator|.
name|getStatus
argument_list|()
decl_stmt|;
return|return
name|test
operator|==
name|ClusterHealthStatus
operator|.
name|RED
return|;
block|}
argument_list|,
literal|5
argument_list|,
name|TimeUnit
operator|.
name|MINUTES
argument_list|)
decl_stmt|;
comment|// sometimes on slow nodes the replication / recovery is just dead slow
specifier|final
name|ClusterHealthResponse
name|response
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|health
argument_list|(
name|Requests
operator|.
name|clusterHealthRequest
argument_list|(
literal|"test"
argument_list|)
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|response
operator|.
name|getStatus
argument_list|()
operator|!=
name|ClusterHealthStatus
operator|.
name|RED
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"Cluster turned red in busy loop: {}"
argument_list|,
name|didClusterTurnRed
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"cluster state:\n{}\n{}"
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|prettyPrint
argument_list|()
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|preparePendingClusterTasks
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|prettyPrint
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|response
operator|.
name|getStatus
argument_list|()
argument_list|,
name|is
argument_list|(
name|ClusterHealthStatus
operator|.
name|RED
argument_list|)
argument_list|)
expr_stmt|;
name|ClusterState
name|state
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getState
argument_list|()
decl_stmt|;
name|GroupShardsIterator
name|shardIterators
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|getRoutingTable
argument_list|()
operator|.
name|activePrimaryShardsGrouped
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"test"
block|}
argument_list|,
literal|false
argument_list|)
decl_stmt|;
for|for
control|(
name|ShardIterator
name|iterator
range|:
name|shardIterators
control|)
block|{
name|ShardRouting
name|routing
decl_stmt|;
while|while
condition|(
operator|(
name|routing
operator|=
name|iterator
operator|.
name|nextOrNull
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|routing
operator|.
name|getId
argument_list|()
operator|==
name|shardRouting
operator|.
name|getId
argument_list|()
condition|)
block|{
name|assertThat
argument_list|(
name|routing
operator|.
name|state
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|ShardRoutingState
operator|.
name|UNASSIGNED
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertThat
argument_list|(
name|routing
operator|.
name|state
argument_list|()
argument_list|,
name|anyOf
argument_list|(
name|equalTo
argument_list|(
name|ShardRoutingState
operator|.
name|RELOCATING
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|ShardRoutingState
operator|.
name|STARTED
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|files
init|=
name|listShardFiles
argument_list|(
name|shardRouting
argument_list|)
decl_stmt|;
name|Path
name|corruptedFile
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Path
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"corrupted_"
argument_list|)
condition|)
block|{
name|corruptedFile
operator|=
name|file
expr_stmt|;
break|break;
block|}
block|}
name|assertThat
argument_list|(
name|corruptedFile
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * This test triggers a corrupt index exception during finalization size if an empty commit point is transferred      * during recovery we don't know the version of the segments_N file because it has no segments we can take it from.      * This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization      * we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster      */
DECL|method|testCorruptionOnNetworkLayerFinalizingRecovery
specifier|public
name|void
name|testCorruptionOnNetworkLayerFinalizingRecovery
parameter_list|()
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
throws|,
name|IOException
block|{
name|internalCluster
argument_list|()
operator|.
name|ensureAtLeastNumDataNodes
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|NodesStatsResponse
name|nodeStats
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareNodesStats
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|NodeStats
argument_list|>
name|dataNodeStats
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeStats
name|stat
range|:
name|nodeStats
operator|.
name|getNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|stat
operator|.
name|getNode
argument_list|()
operator|.
name|isDataNode
argument_list|()
condition|)
block|{
name|dataNodeStats
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
name|assertThat
argument_list|(
name|dataNodeStats
operator|.
name|size
argument_list|()
argument_list|,
name|greaterThanOrEqualTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|dataNodeStats
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|NodeStats
name|primariesNode
init|=
name|dataNodeStats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeStats
name|unluckyNode
init|=
name|dataNodeStats
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertAcked
argument_list|(
name|prepareCreate
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"0"
argument_list|)
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_SHARDS
argument_list|,
literal|1
argument_list|)
operator|.
name|put
argument_list|(
literal|"index.routing.allocation.include._name"
argument_list|,
name|primariesNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
name|EnableAllocationDecider
operator|.
name|INDEX_ROUTING_REBALANCE_ENABLE
argument_list|,
name|EnableAllocationDecider
operator|.
name|Rebalance
operator|.
name|NONE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
comment|// allocated with empty commit
specifier|final
name|AtomicBoolean
name|corrupt
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|true
argument_list|)
decl_stmt|;
specifier|final
name|CountDownLatch
name|hasCorrupted
init|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|NodeStats
name|dataNode
range|:
name|dataNodeStats
control|)
block|{
name|MockTransportService
name|mockTransportService
init|=
operator|(
operator|(
name|MockTransportService
operator|)
name|internalCluster
argument_list|()
operator|.
name|getInstance
argument_list|(
name|TransportService
operator|.
name|class
argument_list|,
name|dataNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|mockTransportService
operator|.
name|addDelegate
argument_list|(
name|internalCluster
argument_list|()
operator|.
name|getInstance
argument_list|(
name|TransportService
operator|.
name|class
argument_list|,
name|unluckyNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
operator|new
name|MockTransportService
operator|.
name|DelegateTransport
argument_list|(
name|mockTransportService
operator|.
name|original
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|sendRequest
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|long
name|requestId
parameter_list|,
name|String
name|action
parameter_list|,
name|TransportRequest
name|request
parameter_list|,
name|TransportRequestOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransportException
block|{
if|if
condition|(
name|corrupt
operator|.
name|get
argument_list|()
operator|&&
name|action
operator|.
name|equals
argument_list|(
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|FILE_CHUNK
argument_list|)
condition|)
block|{
name|RecoveryFileChunkRequest
name|req
init|=
operator|(
name|RecoveryFileChunkRequest
operator|)
name|request
decl_stmt|;
name|byte
index|[]
name|array
init|=
name|req
operator|.
name|content
argument_list|()
operator|.
name|array
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
name|req
operator|.
name|content
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|array
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
operator|~
name|array
index|[
name|i
index|]
expr_stmt|;
comment|// flip one byte in the content
name|hasCorrupted
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
name|super
operator|.
name|sendRequest
argument_list|(
name|node
argument_list|,
name|requestId
argument_list|,
name|action
argument_list|,
name|request
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|Settings
name|build
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"1"
argument_list|)
operator|.
name|put
argument_list|(
literal|"index.routing.allocation.include._name"
argument_list|,
name|primariesNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
operator|+
literal|","
operator|+
name|unluckyNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareUpdateSettings
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|build
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareReroute
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
name|hasCorrupted
operator|.
name|await
argument_list|()
expr_stmt|;
name|corrupt
operator|.
name|set
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
block|}
comment|/**      * Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way      * to the replica. The file on disk stays uncorrupted      */
DECL|method|testCorruptionOnNetworkLayer
specifier|public
name|void
name|testCorruptionOnNetworkLayer
parameter_list|()
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
block|{
name|int
name|numDocs
init|=
name|scaledRandomIntBetween
argument_list|(
literal|100
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|internalCluster
argument_list|()
operator|.
name|ensureAtLeastNumDataNodes
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cluster
argument_list|()
operator|.
name|numDataNodes
argument_list|()
operator|<
literal|3
condition|)
block|{
name|internalCluster
argument_list|()
operator|.
name|startNode
argument_list|(
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
literal|"node.data"
argument_list|,
literal|true
argument_list|)
operator|.
name|put
argument_list|(
literal|"node.client"
argument_list|,
literal|false
argument_list|)
operator|.
name|put
argument_list|(
literal|"node.master"
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NodesStatsResponse
name|nodeStats
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareNodesStats
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|NodeStats
argument_list|>
name|dataNodeStats
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeStats
name|stat
range|:
name|nodeStats
operator|.
name|getNodes
argument_list|()
control|)
block|{
if|if
condition|(
name|stat
operator|.
name|getNode
argument_list|()
operator|.
name|isDataNode
argument_list|()
condition|)
block|{
name|dataNodeStats
operator|.
name|add
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
name|assertThat
argument_list|(
name|dataNodeStats
operator|.
name|size
argument_list|()
argument_list|,
name|greaterThanOrEqualTo
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|dataNodeStats
argument_list|,
name|random
argument_list|()
argument_list|)
expr_stmt|;
name|NodeStats
name|primariesNode
init|=
name|dataNodeStats
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|NodeStats
name|unluckyNode
init|=
name|dataNodeStats
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|assertAcked
argument_list|(
name|prepareCreate
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"0"
argument_list|)
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_SHARDS
argument_list|,
name|between
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|)
argument_list|)
comment|// don't go crazy here it must recovery fast
comment|// This does corrupt files on the replica, so we can't check:
operator|.
name|put
argument_list|(
name|MockFSIndexStore
operator|.
name|CHECK_INDEX_ON_CLOSE
argument_list|,
literal|false
argument_list|)
operator|.
name|put
argument_list|(
literal|"index.routing.allocation.include._name"
argument_list|,
name|primariesNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
name|EnableAllocationDecider
operator|.
name|INDEX_ROUTING_REBALANCE_ENABLE
argument_list|,
name|EnableAllocationDecider
operator|.
name|Rebalance
operator|.
name|NONE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|IndexRequestBuilder
index|[]
name|builders
init|=
operator|new
name|IndexRequestBuilder
index|[
name|numDocs
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|builders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|builders
index|[
name|i
index|]
operator|=
name|client
argument_list|()
operator|.
name|prepareIndex
argument_list|(
literal|"test"
argument_list|,
literal|"type"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"field"
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
block|}
name|indexRandom
argument_list|(
literal|true
argument_list|,
name|builders
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|assertAllSuccessful
argument_list|(
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareFlush
argument_list|()
operator|.
name|setForce
argument_list|(
literal|true
argument_list|)
operator|.
name|setWaitIfOngoing
argument_list|(
literal|true
argument_list|)
operator|.
name|execute
argument_list|()
operator|.
name|actionGet
argument_list|()
argument_list|)
expr_stmt|;
comment|// we have to flush at least once here since we don't corrupt the translog
name|SearchResponse
name|countResponse
init|=
name|client
argument_list|()
operator|.
name|prepareSearch
argument_list|()
operator|.
name|setSize
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertHitCount
argument_list|(
name|countResponse
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|truncate
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeStats
name|dataNode
range|:
name|dataNodeStats
control|)
block|{
name|MockTransportService
name|mockTransportService
init|=
operator|(
operator|(
name|MockTransportService
operator|)
name|internalCluster
argument_list|()
operator|.
name|getInstance
argument_list|(
name|TransportService
operator|.
name|class
argument_list|,
name|dataNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
operator|)
decl_stmt|;
name|mockTransportService
operator|.
name|addDelegate
argument_list|(
name|internalCluster
argument_list|()
operator|.
name|getInstance
argument_list|(
name|TransportService
operator|.
name|class
argument_list|,
name|unluckyNode
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
argument_list|,
operator|new
name|MockTransportService
operator|.
name|DelegateTransport
argument_list|(
name|mockTransportService
operator|.
name|original
argument_list|()
argument_list|)
block|{
annotation|@
name|Override
specifier|public
name|void
name|sendRequest
parameter_list|(
name|DiscoveryNode
name|node
parameter_list|,
name|long
name|requestId
parameter_list|,
name|String
name|action
parameter_list|,
name|TransportRequest
name|request
parameter_list|,
name|TransportRequestOptions
name|options
parameter_list|)
throws|throws
name|IOException
throws|,
name|TransportException
block|{
if|if
condition|(
name|action
operator|.
name|equals
argument_list|(
name|RecoveryTarget
operator|.
name|Actions
operator|.
name|FILE_CHUNK
argument_list|)
condition|)
block|{
name|RecoveryFileChunkRequest
name|req
init|=
operator|(
name|RecoveryFileChunkRequest
operator|)
name|request
decl_stmt|;
if|if
condition|(
name|truncate
operator|&&
name|req
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|BytesArray
name|array
init|=
operator|new
name|BytesArray
argument_list|(
name|req
operator|.
name|content
argument_list|()
operator|.
name|array
argument_list|()
argument_list|,
name|req
operator|.
name|content
argument_list|()
operator|.
name|arrayOffset
argument_list|()
argument_list|,
operator|(
name|int
operator|)
name|req
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|request
operator|=
operator|new
name|RecoveryFileChunkRequest
argument_list|(
name|req
operator|.
name|recoveryId
argument_list|()
argument_list|,
name|req
operator|.
name|shardId
argument_list|()
argument_list|,
name|req
operator|.
name|metadata
argument_list|()
argument_list|,
name|req
operator|.
name|position
argument_list|()
argument_list|,
name|array
argument_list|,
name|req
operator|.
name|lastChunk
argument_list|()
argument_list|,
name|req
operator|.
name|totalTranslogOps
argument_list|()
argument_list|,
name|req
operator|.
name|sourceThrottleTimeInNanos
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|byte
index|[]
name|array
init|=
name|req
operator|.
name|content
argument_list|()
operator|.
name|array
argument_list|()
decl_stmt|;
name|int
name|i
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
name|req
operator|.
name|content
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|array
index|[
name|i
index|]
operator|=
operator|(
name|byte
operator|)
operator|~
name|array
index|[
name|i
index|]
expr_stmt|;
comment|// flip one byte in the content
block|}
block|}
name|super
operator|.
name|sendRequest
argument_list|(
name|node
argument_list|,
name|requestId
argument_list|,
name|action
argument_list|,
name|request
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|Settings
name|build
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"1"
argument_list|)
operator|.
name|put
argument_list|(
literal|"index.routing.allocation.include._name"
argument_list|,
literal|"*"
argument_list|)
operator|.
name|build
argument_list|()
decl_stmt|;
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareUpdateSettings
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|build
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareReroute
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
name|ClusterHealthResponse
name|actionGet
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|health
argument_list|(
name|Requests
operator|.
name|clusterHealthRequest
argument_list|(
literal|"test"
argument_list|)
operator|.
name|waitForGreenStatus
argument_list|()
argument_list|)
operator|.
name|actionGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|actionGet
operator|.
name|isTimedOut
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"ensureGreen timed out, cluster state:\n{}\n{}"
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getState
argument_list|()
operator|.
name|prettyPrint
argument_list|()
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|preparePendingClusterTasks
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|prettyPrint
argument_list|()
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
literal|"timed out waiting for green state"
argument_list|,
name|actionGet
operator|.
name|isTimedOut
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// we are green so primaries got not corrupted.
comment|// ensure that no shard is actually allocated on the unlucky node
name|ClusterStateResponse
name|clusterStateResponse
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexShardRoutingTable
name|table
range|:
name|clusterStateResponse
operator|.
name|getState
argument_list|()
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|getRoutingTable
argument_list|()
operator|.
name|index
argument_list|(
literal|"test"
argument_list|)
control|)
block|{
for|for
control|(
name|ShardRouting
name|routing
range|:
name|table
control|)
block|{
if|if
condition|(
name|unluckyNode
operator|.
name|getNode
argument_list|()
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|routing
operator|.
name|currentNodeId
argument_list|()
argument_list|)
condition|)
block|{
name|assertThat
argument_list|(
name|routing
operator|.
name|state
argument_list|()
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
name|ShardRoutingState
operator|.
name|STARTED
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|routing
operator|.
name|state
argument_list|()
argument_list|,
name|not
argument_list|(
name|equalTo
argument_list|(
name|ShardRoutingState
operator|.
name|RELOCATING
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|final
name|int
name|numIterations
init|=
name|scaledRandomIntBetween
argument_list|(
literal|5
argument_list|,
literal|20
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numIterations
condition|;
name|i
operator|++
control|)
block|{
name|SearchResponse
name|response
init|=
name|client
argument_list|()
operator|.
name|prepareSearch
argument_list|()
operator|.
name|setSize
argument_list|(
name|numDocs
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertHitCount
argument_list|(
name|response
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tests that restoring of a corrupted shard fails and we get a partial snapshot.      * TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several      * parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.      */
DECL|method|testCorruptFileThenSnapshotAndRestore
specifier|public
name|void
name|testCorruptFileThenSnapshotAndRestore
parameter_list|()
throws|throws
name|ExecutionException
throws|,
name|InterruptedException
throws|,
name|IOException
block|{
name|int
name|numDocs
init|=
name|scaledRandomIntBetween
argument_list|(
literal|100
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|internalCluster
argument_list|()
operator|.
name|ensureAtLeastNumDataNodes
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|assertAcked
argument_list|(
name|prepareCreate
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
literal|"0"
argument_list|)
comment|// no replicas for this test
operator|.
name|put
argument_list|(
name|MergePolicyConfig
operator|.
name|INDEX_MERGE_ENABLED
argument_list|,
literal|false
argument_list|)
operator|.
name|put
argument_list|(
name|MockFSIndexStore
operator|.
name|CHECK_INDEX_ON_CLOSE
argument_list|,
literal|false
argument_list|)
comment|// no checkindex - we corrupt shards on purpose
operator|.
name|put
argument_list|(
name|IndexShard
operator|.
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|1
argument_list|,
name|ByteSizeUnit
operator|.
name|PB
argument_list|)
argument_list|)
comment|// no translog based flush - it might change the .liv / segments.N files
operator|.
name|put
argument_list|(
literal|"indices.recovery.concurrent_streams"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|IndexRequestBuilder
index|[]
name|builders
init|=
operator|new
name|IndexRequestBuilder
index|[
name|numDocs
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|builders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|builders
index|[
name|i
index|]
operator|=
name|client
argument_list|()
operator|.
name|prepareIndex
argument_list|(
literal|"test"
argument_list|,
literal|"type"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"field"
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
block|}
name|indexRandom
argument_list|(
literal|true
argument_list|,
name|builders
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|assertAllSuccessful
argument_list|(
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareFlush
argument_list|()
operator|.
name|setForce
argument_list|(
literal|true
argument_list|)
operator|.
name|setWaitIfOngoing
argument_list|(
literal|true
argument_list|)
operator|.
name|execute
argument_list|()
operator|.
name|actionGet
argument_list|()
argument_list|)
expr_stmt|;
comment|// we have to flush at least once here since we don't corrupt the translog
name|SearchResponse
name|countResponse
init|=
name|client
argument_list|()
operator|.
name|prepareSearch
argument_list|()
operator|.
name|setSize
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertHitCount
argument_list|(
name|countResponse
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
name|ShardRouting
name|shardRouting
init|=
name|corruptRandomPrimaryFile
argument_list|(
literal|false
argument_list|)
decl_stmt|;
comment|// we don't corrupt segments.gen since S/R doesn't snapshot this file
comment|// the other problem here why we can't corrupt segments.X files is that the snapshot flushes again before
comment|// it snapshots and that will write a new segments.X+1 file
name|logger
operator|.
name|info
argument_list|(
literal|"-->  creating repository"
argument_list|)
expr_stmt|;
name|assertAcked
argument_list|(
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|preparePutRepository
argument_list|(
literal|"test-repo"
argument_list|)
operator|.
name|setType
argument_list|(
literal|"fs"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|settingsBuilder
argument_list|()
operator|.
name|put
argument_list|(
literal|"location"
argument_list|,
name|randomRepoPath
argument_list|()
operator|.
name|toAbsolutePath
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"compress"
argument_list|,
name|randomBoolean
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
literal|"chunk_size"
argument_list|,
name|randomIntBetween
argument_list|(
literal|100
argument_list|,
literal|1000
argument_list|)
argument_list|,
name|ByteSizeUnit
operator|.
name|BYTES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"--> snapshot"
argument_list|)
expr_stmt|;
name|CreateSnapshotResponse
name|createSnapshotResponse
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareCreateSnapshot
argument_list|(
literal|"test-repo"
argument_list|,
literal|"test-snap"
argument_list|)
operator|.
name|setWaitForCompletion
argument_list|(
literal|true
argument_list|)
operator|.
name|setIndices
argument_list|(
literal|"test"
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|createSnapshotResponse
operator|.
name|getSnapshotInfo
argument_list|()
operator|.
name|state
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|SnapshotState
operator|.
name|PARTIAL
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"failed during snapshot -- maybe SI file got corrupted"
argument_list|)
expr_stmt|;
specifier|final
name|List
argument_list|<
name|Path
argument_list|>
name|files
init|=
name|listShardFiles
argument_list|(
name|shardRouting
argument_list|)
decl_stmt|;
name|Path
name|corruptedFile
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Path
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"corrupted_"
argument_list|)
condition|)
block|{
name|corruptedFile
operator|=
name|file
expr_stmt|;
break|break;
block|}
block|}
name|assertThat
argument_list|(
name|corruptedFile
argument_list|,
name|notNullValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * This test verifies that if we corrupt a replica, we can still get to green, even though      * listing its store fails. Note, we need to make sure that replicas are allocated on all data      * nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted      * replica.      */
DECL|method|testReplicaCorruption
specifier|public
name|void
name|testReplicaCorruption
parameter_list|()
throws|throws
name|Exception
block|{
name|int
name|numDocs
init|=
name|scaledRandomIntBetween
argument_list|(
literal|100
argument_list|,
literal|1000
argument_list|)
decl_stmt|;
name|internalCluster
argument_list|()
operator|.
name|ensureAtLeastNumDataNodes
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|assertAcked
argument_list|(
name|prepareCreate
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setSettings
argument_list|(
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|PrimaryShardAllocator
operator|.
name|INDEX_RECOVERY_INITIAL_SHARDS
argument_list|,
literal|"one"
argument_list|)
operator|.
name|put
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_NUMBER_OF_REPLICAS
argument_list|,
name|cluster
argument_list|()
operator|.
name|numDataNodes
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|put
argument_list|(
name|MergePolicyConfig
operator|.
name|INDEX_MERGE_ENABLED
argument_list|,
literal|false
argument_list|)
operator|.
name|put
argument_list|(
name|MockFSIndexStore
operator|.
name|CHECK_INDEX_ON_CLOSE
argument_list|,
literal|false
argument_list|)
comment|// no checkindex - we corrupt shards on purpose
operator|.
name|put
argument_list|(
name|IndexShard
operator|.
name|INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
literal|1
argument_list|,
name|ByteSizeUnit
operator|.
name|PB
argument_list|)
argument_list|)
comment|// no translog based flush - it might change the .liv / segments.N files
operator|.
name|put
argument_list|(
literal|"indices.recovery.concurrent_streams"
argument_list|,
literal|10
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|IndexRequestBuilder
index|[]
name|builders
init|=
operator|new
name|IndexRequestBuilder
index|[
name|numDocs
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|builders
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|builders
index|[
name|i
index|]
operator|=
name|client
argument_list|()
operator|.
name|prepareIndex
argument_list|(
literal|"test"
argument_list|,
literal|"type"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"field"
argument_list|,
literal|"value"
argument_list|)
expr_stmt|;
block|}
name|indexRandom
argument_list|(
literal|true
argument_list|,
name|builders
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
name|assertAllSuccessful
argument_list|(
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareFlush
argument_list|()
operator|.
name|setForce
argument_list|(
literal|true
argument_list|)
operator|.
name|setWaitIfOngoing
argument_list|(
literal|true
argument_list|)
operator|.
name|execute
argument_list|()
operator|.
name|actionGet
argument_list|()
argument_list|)
expr_stmt|;
comment|// we have to flush at least once here since we don't corrupt the translog
name|SearchResponse
name|countResponse
init|=
name|client
argument_list|()
operator|.
name|prepareSearch
argument_list|()
operator|.
name|setSize
argument_list|(
literal|0
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertHitCount
argument_list|(
name|countResponse
argument_list|,
name|numDocs
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Path
argument_list|>
argument_list|>
name|filesToCorrupt
init|=
name|findFilesToCorruptForReplica
argument_list|()
decl_stmt|;
name|internalCluster
argument_list|()
operator|.
name|fullRestart
argument_list|(
operator|new
name|InternalTestCluster
operator|.
name|RestartCallback
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Settings
name|onNodeStopped
parameter_list|(
name|String
name|nodeName
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|Path
argument_list|>
name|paths
init|=
name|filesToCorrupt
operator|.
name|get
argument_list|(
name|nodeName
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Path
name|path
range|:
name|paths
control|)
block|{
try|try
init|(
name|OutputStream
name|os
init|=
name|Files
operator|.
name|newOutputStream
argument_list|(
name|path
argument_list|)
init|)
block|{
name|os
operator|.
name|write
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"corrupting file {} on node {}"
argument_list|,
name|path
argument_list|,
name|nodeName
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|()
expr_stmt|;
block|}
DECL|method|numShards
specifier|private
name|int
name|numShards
parameter_list|(
name|String
modifier|...
name|index
parameter_list|)
block|{
name|ClusterState
name|state
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getState
argument_list|()
decl_stmt|;
name|GroupShardsIterator
name|shardIterators
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|getRoutingTable
argument_list|()
operator|.
name|activePrimaryShardsGrouped
argument_list|(
name|index
argument_list|,
literal|false
argument_list|)
decl_stmt|;
return|return
name|shardIterators
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|findFilesToCorruptForReplica
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Path
argument_list|>
argument_list|>
name|findFilesToCorruptForReplica
parameter_list|()
throws|throws
name|IOException
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|Path
argument_list|>
argument_list|>
name|filesToNodes
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|ClusterState
name|state
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getState
argument_list|()
decl_stmt|;
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|state
operator|.
name|getRoutingTable
argument_list|()
operator|.
name|allShards
argument_list|(
literal|"test"
argument_list|)
control|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
operator|==
literal|true
condition|)
block|{
continue|continue;
block|}
name|assertTrue
argument_list|(
name|shardRouting
operator|.
name|assignedToNode
argument_list|()
argument_list|)
expr_stmt|;
name|NodesStatsResponse
name|nodeStatses
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareNodesStats
argument_list|(
name|shardRouting
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|setFs
argument_list|(
literal|true
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|NodeStats
name|nodeStats
init|=
name|nodeStatses
operator|.
name|getNodes
argument_list|()
index|[
literal|0
index|]
decl_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|filesToNodes
operator|.
name|put
argument_list|(
name|nodeStats
operator|.
name|getNode
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|files
argument_list|)
expr_stmt|;
for|for
control|(
name|FsInfo
operator|.
name|Path
name|info
range|:
name|nodeStats
operator|.
name|getFs
argument_list|()
control|)
block|{
name|String
name|path
init|=
name|info
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|String
name|relativeDataLocationPath
init|=
literal|"indices/test/"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|)
operator|+
literal|"/index"
decl_stmt|;
name|Path
name|file
init|=
name|PathUtils
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|.
name|resolve
argument_list|(
name|relativeDataLocationPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|// multi data path might only have one path in use
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|file
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|item
range|:
name|stream
control|)
block|{
if|if
condition|(
name|item
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"segments_"
argument_list|)
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|filesToNodes
return|;
block|}
DECL|method|corruptRandomPrimaryFile
specifier|private
name|ShardRouting
name|corruptRandomPrimaryFile
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|corruptRandomPrimaryFile
argument_list|(
literal|true
argument_list|)
return|;
block|}
DECL|method|corruptRandomPrimaryFile
specifier|private
name|ShardRouting
name|corruptRandomPrimaryFile
parameter_list|(
specifier|final
name|boolean
name|includePerCommitFiles
parameter_list|)
throws|throws
name|IOException
block|{
name|ClusterState
name|state
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareState
argument_list|()
operator|.
name|get
argument_list|()
operator|.
name|getState
argument_list|()
decl_stmt|;
name|GroupShardsIterator
name|shardIterators
init|=
name|state
operator|.
name|getRoutingNodes
argument_list|()
operator|.
name|getRoutingTable
argument_list|()
operator|.
name|activePrimaryShardsGrouped
argument_list|(
operator|new
name|String
index|[]
block|{
literal|"test"
block|}
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ShardIterator
argument_list|>
name|iterators
init|=
name|iterableAsArrayList
argument_list|(
name|shardIterators
argument_list|)
decl_stmt|;
name|ShardIterator
name|shardIterator
init|=
name|RandomPicks
operator|.
name|randomFrom
argument_list|(
name|getRandom
argument_list|()
argument_list|,
name|iterators
argument_list|)
decl_stmt|;
name|ShardRouting
name|shardRouting
init|=
name|shardIterator
operator|.
name|nextOrNull
argument_list|()
decl_stmt|;
name|assertNotNull
argument_list|(
name|shardRouting
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|shardRouting
operator|.
name|primary
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|shardRouting
operator|.
name|assignedToNode
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|nodeId
init|=
name|shardRouting
operator|.
name|currentNodeId
argument_list|()
decl_stmt|;
name|NodesStatsResponse
name|nodeStatses
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareNodesStats
argument_list|(
name|nodeId
argument_list|)
operator|.
name|setFs
argument_list|(
literal|true
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|Set
argument_list|<
name|Path
argument_list|>
name|files
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
comment|// treeset makes sure iteration order is deterministic
for|for
control|(
name|FsInfo
operator|.
name|Path
name|info
range|:
name|nodeStatses
operator|.
name|getNodes
argument_list|()
index|[
literal|0
index|]
operator|.
name|getFs
argument_list|()
control|)
block|{
name|String
name|path
init|=
name|info
operator|.
name|getPath
argument_list|()
decl_stmt|;
specifier|final
name|String
name|relativeDataLocationPath
init|=
literal|"indices/test/"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|)
operator|+
literal|"/index"
decl_stmt|;
name|Path
name|file
init|=
name|PathUtils
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|.
name|resolve
argument_list|(
name|relativeDataLocationPath
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|// multi data path might only have one path in use
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|file
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|item
range|:
name|stream
control|)
block|{
if|if
condition|(
name|Files
operator|.
name|isRegularFile
argument_list|(
name|item
argument_list|)
operator|&&
literal|"write.lock"
operator|.
name|equals
argument_list|(
name|item
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|includePerCommitFiles
operator|||
name|isPerSegmentFile
argument_list|(
name|item
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
condition|)
block|{
name|files
operator|.
name|add
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|pruneOldDeleteGenerations
argument_list|(
name|files
argument_list|)
expr_stmt|;
name|CorruptionUtils
operator|.
name|corruptFile
argument_list|(
name|getRandom
argument_list|()
argument_list|,
name|files
operator|.
name|toArray
argument_list|(
operator|new
name|Path
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|shardRouting
return|;
block|}
DECL|method|isPerCommitFile
specifier|private
specifier|static
specifier|final
name|boolean
name|isPerCommitFile
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
comment|// .liv and segments_N are per commit files and might change after corruption
return|return
name|fileName
operator|.
name|startsWith
argument_list|(
literal|"segments"
argument_list|)
operator|||
name|fileName
operator|.
name|endsWith
argument_list|(
literal|".liv"
argument_list|)
return|;
block|}
DECL|method|isPerSegmentFile
specifier|private
specifier|static
specifier|final
name|boolean
name|isPerSegmentFile
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
return|return
name|isPerCommitFile
argument_list|(
name|fileName
argument_list|)
operator|==
literal|false
return|;
block|}
comment|/**      * prunes the list of index files such that only the latest del generation files are contained.      */
DECL|method|pruneOldDeleteGenerations
specifier|private
name|void
name|pruneOldDeleteGenerations
parameter_list|(
name|Set
argument_list|<
name|Path
argument_list|>
name|files
parameter_list|)
block|{
specifier|final
name|TreeSet
argument_list|<
name|Path
argument_list|>
name|delFiles
init|=
operator|new
name|TreeSet
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Path
name|file
range|:
name|files
control|)
block|{
if|if
condition|(
name|file
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".liv"
argument_list|)
condition|)
block|{
name|delFiles
operator|.
name|add
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
name|Path
name|last
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Path
name|current
range|:
name|delFiles
control|)
block|{
if|if
condition|(
name|last
operator|!=
literal|null
condition|)
block|{
specifier|final
name|String
name|newSegmentName
init|=
name|IndexFileNames
operator|.
name|parseSegmentName
argument_list|(
name|current
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|String
name|oldSegmentName
init|=
name|IndexFileNames
operator|.
name|parseSegmentName
argument_list|(
name|last
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|newSegmentName
operator|.
name|equals
argument_list|(
name|oldSegmentName
argument_list|)
condition|)
block|{
name|int
name|oldGen
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|IndexFileNames
operator|.
name|stripExtension
argument_list|(
name|IndexFileNames
operator|.
name|stripSegmentName
argument_list|(
name|last
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
operator|.
name|replace
argument_list|(
literal|"_"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
decl_stmt|;
name|int
name|newGen
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|IndexFileNames
operator|.
name|stripExtension
argument_list|(
name|IndexFileNames
operator|.
name|stripSegmentName
argument_list|(
name|current
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
operator|.
name|replace
argument_list|(
literal|"_"
argument_list|,
literal|""
argument_list|)
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|newGen
operator|>
name|oldGen
condition|)
block|{
name|files
operator|.
name|remove
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|files
operator|.
name|remove
argument_list|(
name|current
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|last
operator|=
name|current
expr_stmt|;
block|}
block|}
DECL|method|listShardFiles
specifier|public
name|List
argument_list|<
name|Path
argument_list|>
name|listShardFiles
parameter_list|(
name|ShardRouting
name|routing
parameter_list|)
throws|throws
name|IOException
block|{
name|NodesStatsResponse
name|nodeStatses
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareNodesStats
argument_list|(
name|routing
operator|.
name|currentNodeId
argument_list|()
argument_list|)
operator|.
name|setFs
argument_list|(
literal|true
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|routing
operator|.
name|toString
argument_list|()
argument_list|,
name|nodeStatses
operator|.
name|getNodes
argument_list|()
operator|.
name|length
argument_list|,
name|equalTo
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Path
argument_list|>
name|files
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FsInfo
operator|.
name|Path
name|info
range|:
name|nodeStatses
operator|.
name|getNodes
argument_list|()
index|[
literal|0
index|]
operator|.
name|getFs
argument_list|()
control|)
block|{
name|String
name|path
init|=
name|info
operator|.
name|getPath
argument_list|()
decl_stmt|;
name|Path
name|file
init|=
name|PathUtils
operator|.
name|get
argument_list|(
name|path
argument_list|)
operator|.
name|resolve
argument_list|(
literal|"indices/test/"
operator|+
name|Integer
operator|.
name|toString
argument_list|(
name|routing
operator|.
name|getId
argument_list|()
argument_list|)
operator|+
literal|"/index"
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|exists
argument_list|(
name|file
argument_list|)
condition|)
block|{
comment|// multi data path might only have one path in use
try|try
init|(
name|DirectoryStream
argument_list|<
name|Path
argument_list|>
name|stream
init|=
name|Files
operator|.
name|newDirectoryStream
argument_list|(
name|file
argument_list|)
init|)
block|{
for|for
control|(
name|Path
name|item
range|:
name|stream
control|)
block|{
name|files
operator|.
name|add
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|files
return|;
block|}
block|}
end_class

end_unit

