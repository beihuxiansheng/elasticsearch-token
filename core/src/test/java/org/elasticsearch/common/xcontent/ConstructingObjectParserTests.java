begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.xcontent
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseFieldMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParseFieldMatcherSupplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|ParsingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|AbstractObjectParser
operator|.
name|NoContextParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|json
operator|.
name|JsonXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|ESTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|unmodifiableList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ConstructingObjectParser
operator|.
name|constructorArg
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ConstructingObjectParser
operator|.
name|optionalConstructorArg
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|anyOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|nullValue
import|;
end_import

begin_class
DECL|class|ConstructingObjectParserTests
specifier|public
class|class
name|ConstructingObjectParserTests
extends|extends
name|ESTestCase
block|{
DECL|field|MATCHER
specifier|private
specifier|static
specifier|final
name|ParseFieldMatcherSupplier
name|MATCHER
init|=
parameter_list|()
lambda|->
name|ParseFieldMatcher
operator|.
name|STRICT
decl_stmt|;
DECL|method|testNullDeclares
specifier|public
name|void
name|testNullDeclares
parameter_list|()
block|{
name|ConstructingObjectParser
argument_list|<
name|Void
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|objectParser
init|=
operator|new
name|ConstructingObjectParser
argument_list|<>
argument_list|(
literal|"foo"
argument_list|,
name|a
lambda|->
literal|null
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|objectParser
operator|.
name|declareField
argument_list|(
literal|null
argument_list|,
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
lambda|->
literal|null
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"test"
argument_list|)
argument_list|,
name|ObjectParser
operator|.
name|ValueType
operator|.
name|STRING
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"[consumer] is required"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|objectParser
operator|.
name|declareField
argument_list|(
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{}
argument_list|,
operator|(
name|ContextParser
argument_list|<
name|ParseFieldMatcherSupplier
argument_list|,
name|Object
argument_list|>
operator|)
literal|null
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"test"
argument_list|)
argument_list|,
name|ObjectParser
operator|.
name|ValueType
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[parser] is required"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|objectParser
operator|.
name|declareField
argument_list|(
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{}
argument_list|,
operator|(
name|NoContextParser
argument_list|<
name|Object
argument_list|>
operator|)
literal|null
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"test"
argument_list|)
argument_list|,
name|ObjectParser
operator|.
name|ValueType
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[parser] is required"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|objectParser
operator|.
name|declareField
argument_list|(
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{}
argument_list|,
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
lambda|->
literal|null
argument_list|,
literal|null
argument_list|,
name|ObjectParser
operator|.
name|ValueType
operator|.
name|STRING
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[parseField] is required"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|objectParser
operator|.
name|declareField
argument_list|(
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
lambda|->
block|{}
argument_list|,
parameter_list|(
name|r
parameter_list|,
name|c
parameter_list|)
lambda|->
literal|null
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"test"
argument_list|)
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[type] is required"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Builds the object in random order and parses it.      */
DECL|method|testRandomOrder
specifier|public
name|void
name|testRandomOrder
parameter_list|()
throws|throws
name|Exception
block|{
name|HasCtorArguments
name|expected
init|=
operator|new
name|HasCtorArguments
argument_list|(
name|randomAsciiOfLength
argument_list|(
literal|5
argument_list|)
argument_list|,
name|randomInt
argument_list|()
argument_list|)
decl_stmt|;
name|expected
operator|.
name|setMineral
argument_list|(
name|randomInt
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|setFruit
argument_list|(
name|randomInt
argument_list|()
argument_list|)
expr_stmt|;
name|expected
operator|.
name|setA
argument_list|(
name|randomBoolean
argument_list|()
condition|?
literal|null
else|:
name|randomAsciiOfLength
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|setB
argument_list|(
name|randomBoolean
argument_list|()
condition|?
literal|null
else|:
name|randomAsciiOfLength
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|setC
argument_list|(
name|randomBoolean
argument_list|()
condition|?
literal|null
else|:
name|randomAsciiOfLength
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|expected
operator|.
name|setD
argument_list|(
name|randomBoolean
argument_list|()
argument_list|)
expr_stmt|;
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|jsonBuilder
argument_list|()
operator|.
name|prettyPrint
argument_list|()
decl_stmt|;
name|expected
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|ToXContent
operator|.
name|EMPTY_PARAMS
argument_list|)
expr_stmt|;
name|builder
operator|=
name|shuffleXContent
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|BytesReference
name|bytes
init|=
name|builder
operator|.
name|bytes
argument_list|()
decl_stmt|;
try|try
init|(
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
name|bytes
argument_list|)
init|)
block|{
name|HasCtorArguments
name|parsed
init|=
name|randomFrom
argument_list|(
name|HasCtorArguments
operator|.
name|ALL_PARSERS
argument_list|)
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|animal
argument_list|,
name|parsed
operator|.
name|animal
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|vegetable
argument_list|,
name|parsed
operator|.
name|vegetable
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|mineral
argument_list|,
name|parsed
operator|.
name|mineral
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|fruit
argument_list|,
name|parsed
operator|.
name|fruit
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|a
argument_list|,
name|parsed
operator|.
name|a
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|b
argument_list|,
name|parsed
operator|.
name|b
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|c
argument_list|,
name|parsed
operator|.
name|c
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|expected
operator|.
name|d
argument_list|,
name|parsed
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
comment|// It is convenient to decorate the error message with the json
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Error parsing: ["
operator|+
name|builder
operator|.
name|string
argument_list|()
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
DECL|method|testMissingAllConstructorArgs
specifier|public
name|void
name|testMissingAllConstructorArgs
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"mineral\": 1\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|ConstructingObjectParser
argument_list|<
name|HasCtorArguments
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|objectParser
init|=
name|randomBoolean
argument_list|()
condition|?
name|HasCtorArguments
operator|.
name|PARSER
else|:
name|HasCtorArguments
operator|.
name|PARSER_VEGETABLE_OPTIONAL
decl_stmt|;
name|IllegalArgumentException
name|e
init|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|objectParser
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|objectParser
operator|==
name|HasCtorArguments
operator|.
name|PARSER
condition|)
block|{
name|assertEquals
argument_list|(
literal|"Required [animal, vegetable]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertEquals
argument_list|(
literal|"Required [animal]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testMissingAllConstructorArgsButNotRequired
specifier|public
name|void
name|testMissingAllConstructorArgsButNotRequired
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"mineral\": 1\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|HasCtorArguments
name|parsed
init|=
name|HasCtorArguments
operator|.
name|PARSER_ALL_OPTIONAL
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|parsed
operator|.
name|mineral
argument_list|)
expr_stmt|;
block|}
DECL|method|testMissingSecondConstructorArg
specifier|public
name|void
name|testMissingSecondConstructorArg
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"mineral\": 1,\n"
operator|+
literal|"  \"animal\": \"cat\"\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|IllegalArgumentException
name|e
init|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|HasCtorArguments
operator|.
name|PARSER
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Required [vegetable]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMissingSecondConstructorArgButNotRequired
specifier|public
name|void
name|testMissingSecondConstructorArgButNotRequired
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"mineral\": 1,\n"
operator|+
literal|"  \"animal\": \"cat\"\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|HasCtorArguments
name|parsed
init|=
name|randomFrom
argument_list|(
name|HasCtorArguments
operator|.
name|PARSER_VEGETABLE_OPTIONAL
argument_list|,
name|HasCtorArguments
operator|.
name|PARSER_ALL_OPTIONAL
argument_list|)
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|parsed
operator|.
name|mineral
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"cat"
argument_list|,
name|parsed
operator|.
name|animal
argument_list|)
expr_stmt|;
block|}
DECL|method|testMissingFirstConstructorArg
specifier|public
name|void
name|testMissingFirstConstructorArg
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"mineral\": 1,\n"
operator|+
literal|"  \"vegetable\": 2\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|IllegalArgumentException
name|e
init|=
name|expectThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|randomFrom
argument_list|(
name|HasCtorArguments
operator|.
name|PARSER
argument_list|,
name|HasCtorArguments
operator|.
name|PARSER_VEGETABLE_OPTIONAL
argument_list|)
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Required [animal]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testMissingFirstConstructorArgButNotRequired
specifier|public
name|void
name|testMissingFirstConstructorArgButNotRequired
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"mineral\": 1,\n"
operator|+
literal|"  \"vegetable\": 2\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|HasCtorArguments
name|parsed
init|=
name|HasCtorArguments
operator|.
name|PARSER_ALL_OPTIONAL
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|parsed
operator|.
name|mineral
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|Integer
operator|)
literal|2
argument_list|,
name|parsed
operator|.
name|vegetable
argument_list|)
expr_stmt|;
block|}
DECL|method|testRepeatedConstructorParam
specifier|public
name|void
name|testRepeatedConstructorParam
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"vegetable\": 1,\n"
operator|+
literal|"  \"vegetable\": 2\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|Throwable
name|e
init|=
name|expectThrows
argument_list|(
name|ParsingException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|randomFrom
argument_list|(
name|HasCtorArguments
operator|.
name|ALL_PARSERS
argument_list|)
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"[has_required_arguments] failed to parse field [vegetable]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|e
argument_list|,
name|instanceOf
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Can't repeat param [vegetable]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testBadParam
specifier|public
name|void
name|testBadParam
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"animal\": \"cat\",\n"
operator|+
literal|"  \"vegetable\": 2,\n"
operator|+
literal|"  \"a\": \"supercalifragilisticexpialidocious\"\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|ParsingException
name|e
init|=
name|expectThrows
argument_list|(
name|ParsingException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|randomFrom
argument_list|(
name|HasCtorArguments
operator|.
name|ALL_PARSERS
argument_list|)
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"[has_required_arguments] failed to parse field [a]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|e
operator|.
name|getLineNumber
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[a] must be less than 10 characters in length but was [supercalifragilisticexpialidocious]"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testBadParamBeforeObjectBuilt
specifier|public
name|void
name|testBadParamBeforeObjectBuilt
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"a\": \"supercalifragilisticexpialidocious\",\n"
operator|+
literal|"  \"animal\": \"cat\"\n,"
operator|+
literal|"  \"vegetable\": 2\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|ParsingException
name|e
init|=
name|expectThrows
argument_list|(
name|ParsingException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|randomFrom
argument_list|(
name|HasCtorArguments
operator|.
name|ALL_PARSERS
argument_list|)
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"[has_required_arguments] failed to parse field [vegetable]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
name|e
operator|.
name|getLineNumber
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
name|ParsingException
operator|)
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"failed to build [has_required_arguments] after last required field arrived"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|e
operator|.
name|getLineNumber
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
operator|(
name|ParsingException
operator|)
name|e
operator|.
name|getCause
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[has_required_arguments] failed to parse field [a]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|e
operator|.
name|getLineNumber
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"[a] must be less than 10 characters in length but was [supercalifragilisticexpialidocious]"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testConstructorArgsMustBeConfigured
specifier|public
name|void
name|testConstructorArgsMustBeConfigured
parameter_list|()
throws|throws
name|IOException
block|{
class|class
name|NoConstructorArgs
block|{         }
name|ConstructingObjectParser
argument_list|<
name|NoConstructorArgs
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|parser
init|=
operator|new
name|ConstructingObjectParser
argument_list|<>
argument_list|(
literal|"constructor_args_required"
argument_list|,
parameter_list|(
name|a
parameter_list|)
lambda|->
operator|new
name|NoConstructorArgs
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|parser
operator|.
name|apply
argument_list|(
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{}"
argument_list|)
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|fail
argument_list|(
literal|"Expected AssertionError"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|e
parameter_list|)
block|{
name|assertEquals
argument_list|(
literal|"[constructor_args_required] must configure at least on constructor argument. If it doesn't have any it should "
operator|+
literal|"use ObjectParser instead of ConstructingObjectParser. This is a bug in the parser declaration."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Tests the non-constructor fields are only set on time.      */
DECL|method|testCalledOneTime
specifier|public
name|void
name|testCalledOneTime
parameter_list|()
throws|throws
name|IOException
block|{
name|boolean
name|ctorArgOptional
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
class|class
name|CalledOneTime
block|{
specifier|public
name|CalledOneTime
parameter_list|(
name|String
name|yeah
parameter_list|)
block|{
name|Matcher
argument_list|<
name|String
argument_list|>
name|yeahMatcher
init|=
name|equalTo
argument_list|(
literal|"!"
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctorArgOptional
condition|)
block|{
comment|// either(yeahMatcher).or(nullValue) is broken by https://github.com/hamcrest/JavaHamcrest/issues/49
name|yeahMatcher
operator|=
name|anyOf
argument_list|(
name|yeahMatcher
argument_list|,
name|nullValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertThat
argument_list|(
name|yeah
argument_list|,
name|yeahMatcher
argument_list|)
expr_stmt|;
block|}
name|boolean
name|fooSet
init|=
literal|false
decl_stmt|;
name|void
name|setFoo
parameter_list|(
name|String
name|foo
parameter_list|)
block|{
name|assertFalse
argument_list|(
name|fooSet
argument_list|)
expr_stmt|;
name|fooSet
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|ConstructingObjectParser
argument_list|<
name|CalledOneTime
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|parser
init|=
operator|new
name|ConstructingObjectParser
argument_list|<>
argument_list|(
literal|"one_time_test"
argument_list|,
parameter_list|(
name|a
parameter_list|)
lambda|->
operator|new
name|CalledOneTime
argument_list|(
operator|(
name|String
operator|)
name|a
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
name|CalledOneTime
operator|::
name|setFoo
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"foo"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
name|ctorArgOptional
condition|?
name|optionalConstructorArg
argument_list|()
else|:
name|constructorArg
argument_list|()
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"yeah"
argument_list|)
argument_list|)
expr_stmt|;
comment|// ctor arg first so we can test for the bug we found one time
name|XContentParser
name|xcontent
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"yeah\": \"!\",\n"
operator|+
literal|"  \"foo\": \"foo\"\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
name|CalledOneTime
name|result
init|=
name|parser
operator|.
name|apply
argument_list|(
name|xcontent
argument_list|,
name|MATCHER
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|fooSet
argument_list|)
expr_stmt|;
comment|// and ctor arg second just in case
name|xcontent
operator|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"foo\": \"foo\",\n"
operator|+
literal|"  \"yeah\": \"!\"\n"
operator|+
literal|"}"
argument_list|)
expr_stmt|;
name|result
operator|=
name|parser
operator|.
name|apply
argument_list|(
name|xcontent
argument_list|,
name|MATCHER
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|result
operator|.
name|fooSet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctorArgOptional
condition|)
block|{
comment|// and without the constructor arg if we've made it optional
name|xcontent
operator|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"foo\": \"foo\"\n"
operator|+
literal|"}"
argument_list|)
expr_stmt|;
name|result
operator|=
name|parser
operator|.
name|apply
argument_list|(
name|xcontent
argument_list|,
name|MATCHER
argument_list|)
expr_stmt|;
block|}
name|assertTrue
argument_list|(
name|result
operator|.
name|fooSet
argument_list|)
expr_stmt|;
block|}
DECL|method|testIgnoreUnknownFields
specifier|public
name|void
name|testIgnoreUnknownFields
parameter_list|()
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|createParser
argument_list|(
name|JsonXContent
operator|.
name|jsonXContent
argument_list|,
literal|"{\n"
operator|+
literal|"  \"test\" : \"foo\",\n"
operator|+
literal|"  \"junk\" : 2\n"
operator|+
literal|"}"
argument_list|)
decl_stmt|;
class|class
name|TestStruct
block|{
specifier|public
specifier|final
name|String
name|test
decl_stmt|;
specifier|public
name|TestStruct
parameter_list|(
name|String
name|test
parameter_list|)
block|{
name|this
operator|.
name|test
operator|=
name|test
expr_stmt|;
block|}
block|}
name|ConstructingObjectParser
argument_list|<
name|TestStruct
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|objectParser
init|=
operator|new
name|ConstructingObjectParser
argument_list|<>
argument_list|(
literal|"foo"
argument_list|,
literal|true
argument_list|,
name|a
lambda|->
operator|new
name|TestStruct
argument_list|(
operator|(
name|String
operator|)
name|a
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|objectParser
operator|.
name|declareString
argument_list|(
name|constructorArg
argument_list|()
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"test"
argument_list|)
argument_list|)
expr_stmt|;
name|TestStruct
name|s
init|=
name|objectParser
operator|.
name|apply
argument_list|(
name|parser
argument_list|,
name|MATCHER
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|s
operator|.
name|test
argument_list|,
literal|"foo"
argument_list|)
expr_stmt|;
block|}
DECL|class|HasCtorArguments
specifier|private
specifier|static
class|class
name|HasCtorArguments
implements|implements
name|ToXContent
block|{
annotation|@
name|Nullable
DECL|field|animal
specifier|final
name|String
name|animal
decl_stmt|;
annotation|@
name|Nullable
DECL|field|vegetable
specifier|final
name|Integer
name|vegetable
decl_stmt|;
DECL|field|mineral
name|int
name|mineral
decl_stmt|;
DECL|field|fruit
name|int
name|fruit
decl_stmt|;
DECL|field|a
name|String
name|a
decl_stmt|;
DECL|field|b
name|String
name|b
decl_stmt|;
DECL|field|c
name|String
name|c
decl_stmt|;
DECL|field|d
name|boolean
name|d
decl_stmt|;
DECL|method|HasCtorArguments
specifier|public
name|HasCtorArguments
parameter_list|(
annotation|@
name|Nullable
name|String
name|animal
parameter_list|,
annotation|@
name|Nullable
name|Integer
name|vegetable
parameter_list|)
block|{
name|this
operator|.
name|animal
operator|=
name|animal
expr_stmt|;
name|this
operator|.
name|vegetable
operator|=
name|vegetable
expr_stmt|;
block|}
DECL|method|setMineral
specifier|public
name|void
name|setMineral
parameter_list|(
name|int
name|mineral
parameter_list|)
block|{
name|this
operator|.
name|mineral
operator|=
name|mineral
expr_stmt|;
block|}
DECL|method|setFruit
specifier|public
name|void
name|setFruit
parameter_list|(
name|int
name|fruit
parameter_list|)
block|{
name|this
operator|.
name|fruit
operator|=
name|fruit
expr_stmt|;
block|}
DECL|method|setA
specifier|public
name|void
name|setA
parameter_list|(
name|String
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|!=
literal|null
operator|&&
name|a
operator|.
name|length
argument_list|()
operator|>
literal|9
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"[a] must be less than 10 characters in length but was ["
operator|+
name|a
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|this
operator|.
name|a
operator|=
name|a
expr_stmt|;
block|}
DECL|method|setB
specifier|public
name|void
name|setB
parameter_list|(
name|String
name|b
parameter_list|)
block|{
name|this
operator|.
name|b
operator|=
name|b
expr_stmt|;
block|}
DECL|method|setC
specifier|public
name|void
name|setC
parameter_list|(
name|String
name|c
parameter_list|)
block|{
name|this
operator|.
name|c
operator|=
name|c
expr_stmt|;
block|}
DECL|method|setD
specifier|public
name|void
name|setD
parameter_list|(
name|boolean
name|d
parameter_list|)
block|{
name|this
operator|.
name|d
operator|=
name|d
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"animal"
argument_list|,
name|animal
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"vegetable"
argument_list|,
name|vegetable
argument_list|)
expr_stmt|;
if|if
condition|(
name|mineral
operator|!=
literal|0
condition|)
block|{
comment|// We're just using 0 as the default because it is easy for testing
name|builder
operator|.
name|field
argument_list|(
literal|"mineral"
argument_list|,
name|mineral
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fruit
operator|!=
literal|0
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"fruit"
argument_list|,
name|fruit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"a"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"b"
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"d"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
return|return
name|builder
return|;
block|}
comment|/*          * It is normal just to declare a single PARSER but we use a couple of different parsers for testing so we have all of these. Don't          * this this style is normal just because it is in the test.          */
DECL|field|PARSER
specifier|public
specifier|static
specifier|final
name|ConstructingObjectParser
argument_list|<
name|HasCtorArguments
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|PARSER
init|=
name|buildParser
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
decl_stmt|;
DECL|field|PARSER_VEGETABLE_OPTIONAL
specifier|public
specifier|static
specifier|final
name|ConstructingObjectParser
argument_list|<
name|HasCtorArguments
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|PARSER_VEGETABLE_OPTIONAL
init|=
name|buildParser
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
decl_stmt|;
DECL|field|PARSER_ALL_OPTIONAL
specifier|public
specifier|static
specifier|final
name|ConstructingObjectParser
argument_list|<
name|HasCtorArguments
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|PARSER_ALL_OPTIONAL
init|=
name|buildParser
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
DECL|field|ALL_PARSERS
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|ConstructingObjectParser
argument_list|<
name|HasCtorArguments
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
argument_list|>
name|ALL_PARSERS
init|=
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|PARSER
argument_list|,
name|PARSER_VEGETABLE_OPTIONAL
argument_list|,
name|PARSER_ALL_OPTIONAL
argument_list|)
argument_list|)
decl_stmt|;
DECL|method|buildParser
specifier|private
specifier|static
name|ConstructingObjectParser
argument_list|<
name|HasCtorArguments
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|buildParser
parameter_list|(
name|boolean
name|animalRequired
parameter_list|,
name|boolean
name|vegetableRequired
parameter_list|)
block|{
name|ConstructingObjectParser
argument_list|<
name|HasCtorArguments
argument_list|,
name|ParseFieldMatcherSupplier
argument_list|>
name|parser
init|=
operator|new
name|ConstructingObjectParser
argument_list|<>
argument_list|(
literal|"has_required_arguments"
argument_list|,
name|a
lambda|->
operator|new
name|HasCtorArguments
argument_list|(
operator|(
name|String
operator|)
name|a
index|[
literal|0
index|]
argument_list|,
operator|(
name|Integer
operator|)
name|a
index|[
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
name|animalRequired
condition|?
name|constructorArg
argument_list|()
else|:
name|optionalConstructorArg
argument_list|()
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"animal"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareInt
argument_list|(
name|vegetableRequired
condition|?
name|constructorArg
argument_list|()
else|:
name|optionalConstructorArg
argument_list|()
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"vegetable"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareInt
argument_list|(
name|HasCtorArguments
operator|::
name|setMineral
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"mineral"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareInt
argument_list|(
name|HasCtorArguments
operator|::
name|setFruit
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"fruit"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
name|HasCtorArguments
operator|::
name|setA
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"a"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
name|HasCtorArguments
operator|::
name|setB
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"b"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareString
argument_list|(
name|HasCtorArguments
operator|::
name|setC
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"c"
argument_list|)
argument_list|)
expr_stmt|;
name|parser
operator|.
name|declareBoolean
argument_list|(
name|HasCtorArguments
operator|::
name|setD
argument_list|,
operator|new
name|ParseField
argument_list|(
literal|"d"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|parser
return|;
block|}
block|}
block|}
end_class

end_unit

