begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.action.admin.cluster.node.tasks
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|node
operator|.
name|tasks
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ListenableActionFuture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|health
operator|.
name|ClusterHealthAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|node
operator|.
name|tasks
operator|.
name|cancel
operator|.
name|CancelTasksResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|node
operator|.
name|tasks
operator|.
name|list
operator|.
name|ListTasksAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|node
operator|.
name|tasks
operator|.
name|list
operator|.
name|ListTasksResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|cluster
operator|.
name|node
operator|.
name|tasks
operator|.
name|list
operator|.
name|TaskInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|refresh
operator|.
name|RefreshAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|upgrade
operator|.
name|post
operator|.
name|UpgradeAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|validate
operator|.
name|query
operator|.
name|ValidateQueryAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|index
operator|.
name|IndexAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|percolate
operator|.
name|PercolateAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|plugins
operator|.
name|Plugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|ESIntegTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|tasks
operator|.
name|MockTaskManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|tasks
operator|.
name|MockTaskManagerListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|transport
operator|.
name|MockTransportService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|emptyCollectionOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|greaterThanOrEqualTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|lessThanOrEqualTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|not
import|;
end_import

begin_comment
comment|/**  * Integration tests for task management API  *<p>  * We need at least 2 nodes so we have a master node a non-master node  */
end_comment

begin_class
annotation|@
name|ESIntegTestCase
operator|.
name|ClusterScope
argument_list|(
name|scope
operator|=
name|ESIntegTestCase
operator|.
name|Scope
operator|.
name|SUITE
argument_list|,
name|minNumDataNodes
operator|=
literal|2
argument_list|)
DECL|class|TasksIT
specifier|public
class|class
name|TasksIT
extends|extends
name|ESIntegTestCase
block|{
DECL|field|listeners
specifier|private
name|Map
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|RecordingTaskManagerListener
argument_list|>
name|listeners
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
annotation|@
name|Override
DECL|method|nodePlugins
specifier|protected
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Plugin
argument_list|>
argument_list|>
name|nodePlugins
parameter_list|()
block|{
return|return
name|pluginList
argument_list|(
name|MockTransportService
operator|.
name|TestPlugin
operator|.
name|class
argument_list|,
name|TestTaskPlugin
operator|.
name|class
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|transportClientPlugins
specifier|protected
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Plugin
argument_list|>
argument_list|>
name|transportClientPlugins
parameter_list|()
block|{
return|return
name|nodePlugins
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|nodeSettings
specifier|protected
name|Settings
name|nodeSettings
parameter_list|(
name|int
name|nodeOrdinal
parameter_list|)
block|{
return|return
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|super
operator|.
name|nodeSettings
argument_list|(
name|nodeOrdinal
argument_list|)
argument_list|)
operator|.
name|put
argument_list|(
name|MockTaskManager
operator|.
name|USE_MOCK_TASK_MANAGER_SETTING
operator|.
name|getKey
argument_list|()
argument_list|,
literal|true
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
DECL|method|testTaskCounts
specifier|public
name|void
name|testTaskCounts
parameter_list|()
block|{
comment|// Run only on data nodes
name|ListTasksResponse
name|response
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareListTasks
argument_list|(
literal|"data:true"
argument_list|)
operator|.
name|setActions
argument_list|(
name|ListTasksAction
operator|.
name|NAME
operator|+
literal|"[n]"
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|response
operator|.
name|getTasks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|,
name|greaterThanOrEqualTo
argument_list|(
name|cluster
argument_list|()
operator|.
name|numDataNodes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testMasterNodeOperationTasks
specifier|public
name|void
name|testMasterNodeOperationTasks
parameter_list|()
block|{
name|registerTaskManageListeners
argument_list|(
name|ClusterHealthAction
operator|.
name|NAME
argument_list|)
expr_stmt|;
comment|// First run the health on the master node - should produce only one task on the master node
name|internalCluster
argument_list|()
operator|.
name|masterClient
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareHealth
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numberOfEvents
argument_list|(
name|ClusterHealthAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// counting only registration events
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numberOfEvents
argument_list|(
name|ClusterHealthAction
operator|.
name|NAME
argument_list|,
name|event
lambda|->
name|event
operator|.
name|v1
argument_list|()
operator|==
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// counting only unregistration events
name|resetTaskManageListeners
argument_list|(
name|ClusterHealthAction
operator|.
name|NAME
argument_list|)
expr_stmt|;
comment|// Now run the health on a non-master node - should produce one task on master and one task on another node
name|internalCluster
argument_list|()
operator|.
name|nonMasterClient
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareHealth
argument_list|()
operator|.
name|get
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|numberOfEvents
argument_list|(
name|ClusterHealthAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// counting only registration events
name|assertEquals
argument_list|(
literal|2
argument_list|,
name|numberOfEvents
argument_list|(
name|ClusterHealthAction
operator|.
name|NAME
argument_list|,
name|event
lambda|->
name|event
operator|.
name|v1
argument_list|()
operator|==
literal|false
argument_list|)
argument_list|)
expr_stmt|;
comment|// counting only unregistration events
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|tasks
init|=
name|findEvents
argument_list|(
name|ClusterHealthAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
decl_stmt|;
comment|// Verify that one of these tasks is a parent of another task
if|if
condition|(
name|tasks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getParentNode
argument_list|()
operator|==
literal|null
condition|)
block|{
name|assertParentTask
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|tasks
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|,
name|tasks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assertParentTask
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|tasks
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|,
name|tasks
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTransportReplicationAllShardsTasks
specifier|public
name|void
name|testTransportReplicationAllShardsTasks
parameter_list|()
block|{
name|registerTaskManageListeners
argument_list|(
name|PercolateAction
operator|.
name|NAME
argument_list|)
expr_stmt|;
comment|// main task
name|registerTaskManageListeners
argument_list|(
name|PercolateAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|)
expr_stmt|;
comment|// shard level tasks
name|createIndex
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
comment|// Make sure all shards are allocated
name|client
argument_list|()
operator|.
name|preparePercolate
argument_list|()
operator|.
name|setIndices
argument_list|(
literal|"test"
argument_list|)
operator|.
name|setDocumentType
argument_list|(
literal|"foo"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"{}"
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// the percolate operation should produce one main task
name|NumShards
name|numberOfShards
init|=
name|getNumShards
argument_list|(
literal|"test"
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numberOfEvents
argument_list|(
name|PercolateAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// and then one operation per shard
name|assertEquals
argument_list|(
name|numberOfShards
operator|.
name|totalNumShards
argument_list|,
name|numberOfEvents
argument_list|(
name|PercolateAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// the shard level tasks should have the main task as a parent
name|assertParentTask
argument_list|(
name|findEvents
argument_list|(
name|PercolateAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|,
name|findEvents
argument_list|(
name|PercolateAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransportBroadcastByNodeTasks
specifier|public
name|void
name|testTransportBroadcastByNodeTasks
parameter_list|()
block|{
name|registerTaskManageListeners
argument_list|(
name|UpgradeAction
operator|.
name|NAME
argument_list|)
expr_stmt|;
comment|// main task
name|registerTaskManageListeners
argument_list|(
name|UpgradeAction
operator|.
name|NAME
operator|+
literal|"[n]"
argument_list|)
expr_stmt|;
comment|// node level tasks
name|createIndex
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
comment|// Make sure all shards are allocated
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareUpgrade
argument_list|(
literal|"test"
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// the percolate operation should produce one main task
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numberOfEvents
argument_list|(
name|UpgradeAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// and then one operation per each node where shards are located
name|assertEquals
argument_list|(
name|internalCluster
argument_list|()
operator|.
name|nodesInclude
argument_list|(
literal|"test"
argument_list|)
operator|.
name|size
argument_list|()
argument_list|,
name|numberOfEvents
argument_list|(
name|UpgradeAction
operator|.
name|NAME
operator|+
literal|"[n]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// all node level tasks should have the main task as a parent
name|assertParentTask
argument_list|(
name|findEvents
argument_list|(
name|UpgradeAction
operator|.
name|NAME
operator|+
literal|"[n]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|,
name|findEvents
argument_list|(
name|UpgradeAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransportReplicationSingleShardTasks
specifier|public
name|void
name|testTransportReplicationSingleShardTasks
parameter_list|()
block|{
name|registerTaskManageListeners
argument_list|(
name|ValidateQueryAction
operator|.
name|NAME
argument_list|)
expr_stmt|;
comment|// main task
name|registerTaskManageListeners
argument_list|(
name|ValidateQueryAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|)
expr_stmt|;
comment|// shard level tasks
name|createIndex
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
comment|// Make sure all shards are allocated
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareValidateQuery
argument_list|(
literal|"test"
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// the validate operation should produce one main task
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numberOfEvents
argument_list|(
name|ValidateQueryAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// and then one operation
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numberOfEvents
argument_list|(
name|ValidateQueryAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// the shard level operation should have the main task as its parent
name|assertParentTask
argument_list|(
name|findEvents
argument_list|(
name|ValidateQueryAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|,
name|findEvents
argument_list|(
name|ValidateQueryAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testTransportBroadcastReplicationTasks
specifier|public
name|void
name|testTransportBroadcastReplicationTasks
parameter_list|()
block|{
name|registerTaskManageListeners
argument_list|(
name|RefreshAction
operator|.
name|NAME
argument_list|)
expr_stmt|;
comment|// main task
name|registerTaskManageListeners
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|)
expr_stmt|;
comment|// shard level tasks
name|registerTaskManageListeners
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s][*]"
argument_list|)
expr_stmt|;
comment|// primary and replica shard tasks
name|createIndex
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
name|ensureGreen
argument_list|(
literal|"test"
argument_list|)
expr_stmt|;
comment|// Make sure all shards are allocated
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareRefresh
argument_list|(
literal|"test"
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
comment|// the refresh operation should produce one main task
name|NumShards
name|numberOfShards
init|=
name|getNumShards
argument_list|(
literal|"test"
argument_list|)
decl_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"number of shards, total: [{}], primaries: [{}] "
argument_list|,
name|numberOfShards
operator|.
name|totalNumShards
argument_list|,
name|numberOfShards
operator|.
name|numPrimaries
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"main events {}"
argument_list|,
name|numberOfEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"main event node {}"
argument_list|,
name|findEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|getNode
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[s] events {}"
argument_list|,
name|numberOfEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[s][*] events {}"
argument_list|,
name|numberOfEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s][*]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"nodes with the index {}"
argument_list|,
name|internalCluster
argument_list|()
operator|.
name|nodesInclude
argument_list|(
literal|"test"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|numberOfEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// Because it's broadcast replication action we will have as many [s] level requests
comment|// as we have primary shards on the coordinating node plus we will have one task per primary outside of the
comment|// coordinating node due to replication.
comment|// If all primaries are on the coordinating node, the number of tasks should be equal to the number of primaries
comment|// If all primaries are not on the coordinating node, the number of tasks should be equal to the number of primaries times 2
name|assertThat
argument_list|(
name|numberOfEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|,
name|greaterThanOrEqualTo
argument_list|(
name|numberOfShards
operator|.
name|numPrimaries
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|numberOfEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|,
name|lessThanOrEqualTo
argument_list|(
name|numberOfShards
operator|.
name|numPrimaries
operator|*
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|// Verify that all [s] events have the proper parent
comment|// This is complicated because if the shard task runs on the same node it has main task as a parent
comment|// but if it runs on non-coordinating node it would have another intermediate [s] task on the coordinating node as a parent
name|TaskInfo
name|mainTask
init|=
name|findEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|sTasks
init|=
name|findEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
decl_stmt|;
for|for
control|(
name|TaskInfo
name|taskInfo
range|:
name|sTasks
control|)
block|{
if|if
condition|(
name|mainTask
operator|.
name|getNode
argument_list|()
operator|.
name|equals
argument_list|(
name|taskInfo
operator|.
name|getNode
argument_list|()
argument_list|)
condition|)
block|{
comment|// This shard level task runs on the same node as a parent task - it should have the main task as a direct parent
name|assertParentTask
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|taskInfo
argument_list|)
argument_list|,
name|mainTask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|String
name|description
init|=
name|taskInfo
operator|.
name|getDescription
argument_list|()
decl_stmt|;
comment|// This shard level task runs on another node - it should have a corresponding shard level task on the node where main task is running
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|sTasksOnRequestingNode
init|=
name|findEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|event
lambda|->
name|event
operator|.
name|v1
argument_list|()
operator|&&
name|mainTask
operator|.
name|getNode
argument_list|()
operator|.
name|equals
argument_list|(
name|event
operator|.
name|v2
argument_list|()
operator|.
name|getNode
argument_list|()
argument_list|)
operator|&&
name|description
operator|.
name|equals
argument_list|(
name|event
operator|.
name|v2
argument_list|()
operator|.
name|getDescription
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// There should be only one parent task
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|sTasksOnRequestingNode
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertParentTask
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|taskInfo
argument_list|)
argument_list|,
name|sTasksOnRequestingNode
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// we will have as many [s][p] and [s][r] tasks as we have primary and replica shards
name|assertEquals
argument_list|(
name|numberOfShards
operator|.
name|totalNumShards
argument_list|,
name|numberOfEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s][*]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
argument_list|)
expr_stmt|;
comment|// we the [s][p] and [s][r] tasks should have a corresponding [s] task on the same node as a parent
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|spEvents
init|=
name|findEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s][*]"
argument_list|,
name|Tuple
operator|::
name|v1
argument_list|)
decl_stmt|;
for|for
control|(
name|TaskInfo
name|taskInfo
range|:
name|spEvents
control|)
block|{
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|sTask
decl_stmt|;
if|if
condition|(
name|taskInfo
operator|.
name|getAction
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|"[s][p]"
argument_list|)
condition|)
block|{
comment|// A [s][p] level task should have a corresponding [s] level task on the same node
name|sTask
operator|=
name|findEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|event
lambda|->
name|event
operator|.
name|v1
argument_list|()
operator|&&
name|taskInfo
operator|.
name|getNode
argument_list|()
operator|.
name|equals
argument_list|(
name|event
operator|.
name|v2
argument_list|()
operator|.
name|getNode
argument_list|()
argument_list|)
operator|&&
name|taskInfo
operator|.
name|getDescription
argument_list|()
operator|.
name|equals
argument_list|(
name|event
operator|.
name|v2
argument_list|()
operator|.
name|getDescription
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// A [s][r] level task should have a corresponding [s] level task on the a different node (where primary is located)
name|sTask
operator|=
name|findEvents
argument_list|(
name|RefreshAction
operator|.
name|NAME
operator|+
literal|"[s]"
argument_list|,
name|event
lambda|->
name|event
operator|.
name|v1
argument_list|()
operator|&&
name|taskInfo
operator|.
name|getParentNode
argument_list|()
operator|.
name|equals
argument_list|(
name|event
operator|.
name|v2
argument_list|()
operator|.
name|getNode
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
operator|&&
name|taskInfo
operator|.
name|getDescription
argument_list|()
operator|.
name|equals
argument_list|(
name|event
operator|.
name|v2
argument_list|()
operator|.
name|getDescription
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// There should be only one parent task
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|sTask
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|assertParentTask
argument_list|(
name|Collections
operator|.
name|singletonList
argument_list|(
name|taskInfo
argument_list|)
argument_list|,
name|sTask
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Very basic "is it plugged in" style test that indexes a document and      * makes sure that you can fetch the status of the process. The goal here is      * to verify that the large moving parts that make fetching task status work      * fit together rather than to verify any particular status results from      * indexing. For that, look at      * {@link org.elasticsearch.action.support.replication.TransportReplicationActionTests}      * . We intentionally don't use the task recording mechanism used in other      * places in this test so we can make sure that the status fetching works      * properly over the wire.      */
DECL|method|testCanFetchIndexStatus
specifier|public
name|void
name|testCanFetchIndexStatus
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|IOException
block|{
comment|/*          * We prevent any tasks from unregistering until the test is done so we          * can fetch them. This will gum up the server if we leave it enabled          * but we'll be quick so it'll be OK (TM).          */
name|ReentrantLock
name|taskFinishLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
name|taskFinishLock
operator|.
name|lock
argument_list|()
expr_stmt|;
for|for
control|(
name|ClusterService
name|clusterService
range|:
name|internalCluster
argument_list|()
operator|.
name|getInstances
argument_list|(
name|ClusterService
operator|.
name|class
argument_list|)
control|)
block|{
operator|(
operator|(
name|MockTaskManager
operator|)
name|clusterService
operator|.
name|getTaskManager
argument_list|()
operator|)
operator|.
name|addListener
argument_list|(
operator|new
name|MockTaskManagerListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onTaskRegistered
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
comment|// Intentional noop
block|}
annotation|@
name|Override
specifier|public
name|void
name|onTaskUnregistered
parameter_list|(
name|Task
name|task
parameter_list|)
block|{
comment|/*                      * We can't block all tasks here or the task listing task                      * would never return.                      */
if|if
condition|(
literal|false
operator|==
name|task
operator|.
name|getAction
argument_list|()
operator|.
name|startsWith
argument_list|(
name|IndexAction
operator|.
name|NAME
argument_list|)
condition|)
block|{
return|return;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"Blocking {} from being unregistered"
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|taskFinishLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|taskFinishLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
name|ListenableActionFuture
argument_list|<
name|?
argument_list|>
name|indexFuture
init|=
name|client
argument_list|()
operator|.
name|prepareIndex
argument_list|(
literal|"test"
argument_list|,
literal|"test"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"test"
argument_list|,
literal|"test"
argument_list|)
operator|.
name|execute
argument_list|()
decl_stmt|;
name|ListTasksResponse
name|tasks
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareListTasks
argument_list|()
operator|.
name|setActions
argument_list|(
literal|"indices:data/write/index*"
argument_list|)
operator|.
name|setDetailed
argument_list|(
literal|true
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|taskFinishLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|indexFuture
operator|.
name|get
argument_list|()
expr_stmt|;
name|assertThat
argument_list|(
name|tasks
operator|.
name|getTasks
argument_list|()
argument_list|,
name|not
argument_list|(
name|emptyCollectionOf
argument_list|(
name|TaskInfo
operator|.
name|class
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|TaskInfo
name|task
range|:
name|tasks
operator|.
name|getTasks
argument_list|()
control|)
block|{
name|assertNotNull
argument_list|(
name|task
operator|.
name|getStatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testTasksCancellation
specifier|public
name|void
name|testTasksCancellation
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Start blocking test task
comment|// Get real client (the plugin is not registered on transport nodes)
name|ListenableActionFuture
argument_list|<
name|TestTaskPlugin
operator|.
name|NodesResponse
argument_list|>
name|future
init|=
name|TestTaskPlugin
operator|.
name|TestTaskAction
operator|.
name|INSTANCE
operator|.
name|newRequestBuilder
argument_list|(
name|client
argument_list|()
argument_list|)
operator|.
name|execute
argument_list|()
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"--> started test tasks"
argument_list|)
expr_stmt|;
comment|// Wait for the task to start on all nodes
name|assertBusy
argument_list|(
parameter_list|()
lambda|->
name|assertEquals
argument_list|(
name|internalCluster
argument_list|()
operator|.
name|numDataAndMasterNodes
argument_list|()
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareListTasks
argument_list|()
operator|.
name|setActions
argument_list|(
name|TestTaskPlugin
operator|.
name|TestTaskAction
operator|.
name|NAME
operator|+
literal|"[n]"
argument_list|)
operator|.
name|get
argument_list|()
operator|.
name|getTasks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"--> cancelling the main test task"
argument_list|)
expr_stmt|;
name|CancelTasksResponse
name|cancelTasksResponse
init|=
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareCancelTasks
argument_list|()
operator|.
name|setActions
argument_list|(
name|TestTaskPlugin
operator|.
name|TestTaskAction
operator|.
name|NAME
argument_list|)
operator|.
name|get
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
name|cancelTasksResponse
operator|.
name|getTasks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"--> checking that test tasks are not running"
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareListTasks
argument_list|()
operator|.
name|setActions
argument_list|(
name|TestTaskPlugin
operator|.
name|TestTaskAction
operator|.
name|NAME
operator|+
literal|"*"
argument_list|)
operator|.
name|get
argument_list|()
operator|.
name|getTasks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|testTasksUnblocking
specifier|public
name|void
name|testTasksUnblocking
parameter_list|()
throws|throws
name|Exception
block|{
comment|// Start blocking test task
name|ListenableActionFuture
argument_list|<
name|TestTaskPlugin
operator|.
name|NodesResponse
argument_list|>
name|future
init|=
name|TestTaskPlugin
operator|.
name|TestTaskAction
operator|.
name|INSTANCE
operator|.
name|newRequestBuilder
argument_list|(
name|client
argument_list|()
argument_list|)
operator|.
name|execute
argument_list|()
decl_stmt|;
comment|// Wait for the task to start on all nodes
name|assertBusy
argument_list|(
parameter_list|()
lambda|->
name|assertEquals
argument_list|(
name|internalCluster
argument_list|()
operator|.
name|numDataAndMasterNodes
argument_list|()
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareListTasks
argument_list|()
operator|.
name|setActions
argument_list|(
name|TestTaskPlugin
operator|.
name|TestTaskAction
operator|.
name|NAME
operator|+
literal|"[n]"
argument_list|)
operator|.
name|get
argument_list|()
operator|.
name|getTasks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|TestTaskPlugin
operator|.
name|UnblockTestTasksAction
operator|.
name|INSTANCE
operator|.
name|newRequestBuilder
argument_list|(
name|client
argument_list|()
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|future
operator|.
name|get
argument_list|()
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|cluster
argument_list|()
operator|.
name|prepareListTasks
argument_list|()
operator|.
name|setActions
argument_list|(
name|TestTaskPlugin
operator|.
name|TestTaskAction
operator|.
name|NAME
operator|+
literal|"[n]"
argument_list|)
operator|.
name|get
argument_list|()
operator|.
name|getTasks
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|tearDown
specifier|public
name|void
name|tearDown
parameter_list|()
throws|throws
name|Exception
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|RecordingTaskManagerListener
argument_list|>
name|entry
range|:
name|listeners
operator|.
name|entrySet
argument_list|()
control|)
block|{
operator|(
operator|(
name|MockTaskManager
operator|)
name|internalCluster
argument_list|()
operator|.
name|getInstance
argument_list|(
name|ClusterService
operator|.
name|class
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|v1
argument_list|()
argument_list|)
operator|.
name|getTaskManager
argument_list|()
operator|)
operator|.
name|removeListener
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|listeners
operator|.
name|clear
argument_list|()
expr_stmt|;
name|super
operator|.
name|tearDown
argument_list|()
expr_stmt|;
block|}
comment|/**      * Registers recording task event listeners with the given action mask on all nodes      */
DECL|method|registerTaskManageListeners
specifier|private
name|void
name|registerTaskManageListeners
parameter_list|(
name|String
name|actionMasks
parameter_list|)
block|{
for|for
control|(
name|ClusterService
name|clusterService
range|:
name|internalCluster
argument_list|()
operator|.
name|getInstances
argument_list|(
name|ClusterService
operator|.
name|class
argument_list|)
control|)
block|{
name|DiscoveryNode
name|node
init|=
name|clusterService
operator|.
name|localNode
argument_list|()
decl_stmt|;
name|RecordingTaskManagerListener
name|listener
init|=
operator|new
name|RecordingTaskManagerListener
argument_list|(
name|node
argument_list|,
name|Strings
operator|.
name|splitStringToArray
argument_list|(
name|actionMasks
argument_list|,
literal|','
argument_list|)
argument_list|)
decl_stmt|;
operator|(
operator|(
name|MockTaskManager
operator|)
name|clusterService
operator|.
name|getTaskManager
argument_list|()
operator|)
operator|.
name|addListener
argument_list|(
name|listener
argument_list|)
expr_stmt|;
name|RecordingTaskManagerListener
name|oldListener
init|=
name|listeners
operator|.
name|put
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|node
operator|.
name|name
argument_list|()
argument_list|,
name|actionMasks
argument_list|)
argument_list|,
name|listener
argument_list|)
decl_stmt|;
name|assertNull
argument_list|(
name|oldListener
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Resets all recording task event listeners with the given action mask on all nodes      */
DECL|method|resetTaskManageListeners
specifier|private
name|void
name|resetTaskManageListeners
parameter_list|(
name|String
name|actionMasks
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|RecordingTaskManagerListener
argument_list|>
name|entry
range|:
name|listeners
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|actionMasks
operator|==
literal|null
operator|||
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|v2
argument_list|()
operator|.
name|equals
argument_list|(
name|actionMasks
argument_list|)
condition|)
block|{
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|reset
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns the number of events that satisfy the criteria across all nodes      *      * @param actionMasks action masks to match      * @return number of events that satisfy the criteria      */
DECL|method|numberOfEvents
specifier|private
name|int
name|numberOfEvents
parameter_list|(
name|String
name|actionMasks
parameter_list|,
name|Function
argument_list|<
name|Tuple
argument_list|<
name|Boolean
argument_list|,
name|TaskInfo
argument_list|>
argument_list|,
name|Boolean
argument_list|>
name|criteria
parameter_list|)
block|{
return|return
name|findEvents
argument_list|(
name|actionMasks
argument_list|,
name|criteria
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns all events that satisfy the criteria across all nodes      *      * @param actionMasks action masks to match      * @return number of events that satisfy the criteria      */
DECL|method|findEvents
specifier|private
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|findEvents
parameter_list|(
name|String
name|actionMasks
parameter_list|,
name|Function
argument_list|<
name|Tuple
argument_list|<
name|Boolean
argument_list|,
name|TaskInfo
argument_list|>
argument_list|,
name|Boolean
argument_list|>
name|criteria
parameter_list|)
block|{
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|events
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|RecordingTaskManagerListener
argument_list|>
name|entry
range|:
name|listeners
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|actionMasks
operator|==
literal|null
operator|||
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|v2
argument_list|()
operator|.
name|equals
argument_list|(
name|actionMasks
argument_list|)
condition|)
block|{
for|for
control|(
name|Tuple
argument_list|<
name|Boolean
argument_list|,
name|TaskInfo
argument_list|>
name|taskEvent
range|:
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|getEvents
argument_list|()
control|)
block|{
if|if
condition|(
name|criteria
operator|.
name|apply
argument_list|(
name|taskEvent
argument_list|)
condition|)
block|{
name|events
operator|.
name|add
argument_list|(
name|taskEvent
operator|.
name|v2
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|events
return|;
block|}
comment|/**      * Asserts that all tasks in the tasks list have the same parentTask      */
DECL|method|assertParentTask
specifier|private
name|void
name|assertParentTask
parameter_list|(
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|tasks
parameter_list|,
name|TaskInfo
name|parentTask
parameter_list|)
block|{
for|for
control|(
name|TaskInfo
name|task
range|:
name|tasks
control|)
block|{
name|assertNotNull
argument_list|(
name|task
operator|.
name|getParentNode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|parentTask
operator|.
name|getNode
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|,
name|task
operator|.
name|getParentNode
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|parentTask
operator|.
name|getId
argument_list|()
argument_list|,
name|task
operator|.
name|getParentId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

