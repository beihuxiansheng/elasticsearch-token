begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.test.test
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|test
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|client
operator|.
name|Client
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterName
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|service
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|network
operator|.
name|NetworkModule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|discovery
operator|.
name|DiscoverySettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|NodeEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|ESTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|InternalTestCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|NodeConfigurationSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|transport
operator|.
name|TransportSettings
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
operator|.
name|Role
operator|.
name|DATA
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
operator|.
name|Role
operator|.
name|INGEST
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
operator|.
name|Role
operator|.
name|MASTER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|hamcrest
operator|.
name|ElasticsearchAssertions
operator|.
name|assertFileExists
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|hamcrest
operator|.
name|ElasticsearchAssertions
operator|.
name|assertFileNotExists
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|hasEntry
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|not
import|;
end_import

begin_comment
comment|/**  * Basic test that ensure that the internal cluster reproduces the same  * configuration given the same seed / input.  */
end_comment

begin_class
annotation|@
name|LuceneTestCase
operator|.
name|SuppressFileSystems
argument_list|(
literal|"ExtrasFS"
argument_list|)
comment|// doesn't work with potential multi data path from test cluster yet
DECL|class|InternalTestClusterTests
specifier|public
class|class
name|InternalTestClusterTests
extends|extends
name|ESTestCase
block|{
DECL|method|testInitializiationIsConsistent
specifier|public
name|void
name|testInitializiationIsConsistent
parameter_list|()
block|{
name|long
name|clusterSeed
init|=
name|randomLong
argument_list|()
decl_stmt|;
name|boolean
name|masterNodes
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
name|int
name|minNumDataNodes
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
literal|9
argument_list|)
decl_stmt|;
name|int
name|maxNumDataNodes
init|=
name|randomIntBetween
argument_list|(
name|minNumDataNodes
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|String
name|clusterName
init|=
name|randomRealisticUnicodeOfCodepointLengthBetween
argument_list|(
literal|1
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|NodeConfigurationSource
name|nodeConfigurationSource
init|=
name|NodeConfigurationSource
operator|.
name|EMPTY
decl_stmt|;
name|int
name|numClientNodes
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|boolean
name|enableHttpPipelining
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
name|String
name|nodePrefix
init|=
name|randomRealisticUnicodeOfCodepointLengthBetween
argument_list|(
literal|1
argument_list|,
literal|10
argument_list|)
decl_stmt|;
name|Path
name|baseDir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|InternalTestCluster
name|cluster0
init|=
operator|new
name|InternalTestCluster
argument_list|(
literal|"local"
argument_list|,
name|clusterSeed
argument_list|,
name|baseDir
argument_list|,
name|masterNodes
argument_list|,
name|minNumDataNodes
argument_list|,
name|maxNumDataNodes
argument_list|,
name|clusterName
argument_list|,
name|nodeConfigurationSource
argument_list|,
name|numClientNodes
argument_list|,
name|enableHttpPipelining
argument_list|,
name|nodePrefix
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Function
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|InternalTestCluster
name|cluster1
init|=
operator|new
name|InternalTestCluster
argument_list|(
literal|"local"
argument_list|,
name|clusterSeed
argument_list|,
name|baseDir
argument_list|,
name|masterNodes
argument_list|,
name|minNumDataNodes
argument_list|,
name|maxNumDataNodes
argument_list|,
name|clusterName
argument_list|,
name|nodeConfigurationSource
argument_list|,
name|numClientNodes
argument_list|,
name|enableHttpPipelining
argument_list|,
name|nodePrefix
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Function
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
comment|// TODO: this is not ideal - we should have a way to make sure ports are initialized in the same way
name|assertClusters
argument_list|(
name|cluster0
argument_list|,
name|cluster1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * a set of settings that are expected to have different values betweem clusters, even they have been initialized with the same      * base settins.      */
DECL|field|clusterUniqueSettings
specifier|static
specifier|final
name|Set
argument_list|<
name|String
argument_list|>
name|clusterUniqueSettings
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
static|static
block|{
name|clusterUniqueSettings
operator|.
name|add
argument_list|(
name|ClusterName
operator|.
name|CLUSTER_NAME_SETTING
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|clusterUniqueSettings
operator|.
name|add
argument_list|(
name|TransportSettings
operator|.
name|PORT
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|clusterUniqueSettings
operator|.
name|add
argument_list|(
literal|"http.port"
argument_list|)
expr_stmt|;
block|}
DECL|method|assertClusters
specifier|public
specifier|static
name|void
name|assertClusters
parameter_list|(
name|InternalTestCluster
name|cluster0
parameter_list|,
name|InternalTestCluster
name|cluster1
parameter_list|,
name|boolean
name|checkClusterUniqueSettings
parameter_list|)
block|{
name|Settings
name|defaultSettings0
init|=
name|cluster0
operator|.
name|getDefaultSettings
argument_list|()
decl_stmt|;
name|Settings
name|defaultSettings1
init|=
name|cluster1
operator|.
name|getDefaultSettings
argument_list|()
decl_stmt|;
name|assertSettings
argument_list|(
name|defaultSettings0
argument_list|,
name|defaultSettings1
argument_list|,
name|checkClusterUniqueSettings
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|cluster0
operator|.
name|numDataNodes
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|cluster1
operator|.
name|numDataNodes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkClusterUniqueSettings
condition|)
block|{
name|assertThat
argument_list|(
name|cluster0
operator|.
name|getClusterName
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|cluster1
operator|.
name|getClusterName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|assertSettings
specifier|public
specifier|static
name|void
name|assertSettings
parameter_list|(
name|Settings
name|left
parameter_list|,
name|Settings
name|right
parameter_list|,
name|boolean
name|checkClusterUniqueSettings
parameter_list|)
block|{
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|>
name|entries0
init|=
name|left
operator|.
name|getAsMap
argument_list|()
operator|.
name|entrySet
argument_list|()
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entries1
init|=
name|right
operator|.
name|getAsMap
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|entries0
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|entries1
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|entry
range|:
name|entries0
control|)
block|{
if|if
condition|(
name|clusterUniqueSettings
operator|.
name|contains
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|checkClusterUniqueSettings
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
name|assertThat
argument_list|(
name|entries1
argument_list|,
name|hasEntry
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
argument_list|,
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testBeforeTest
specifier|public
name|void
name|testBeforeTest
parameter_list|()
throws|throws
name|Exception
block|{
name|long
name|clusterSeed
init|=
name|randomLong
argument_list|()
decl_stmt|;
name|boolean
name|masterNodes
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
name|int
name|minNumDataNodes
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|int
name|maxNumDataNodes
init|=
name|randomIntBetween
argument_list|(
name|minNumDataNodes
argument_list|,
literal|4
argument_list|)
decl_stmt|;
specifier|final
name|String
name|clusterName1
init|=
literal|"shared1"
decl_stmt|;
specifier|final
name|String
name|clusterName2
init|=
literal|"shared2"
decl_stmt|;
name|NodeConfigurationSource
name|nodeConfigurationSource
init|=
operator|new
name|NodeConfigurationSource
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Settings
name|nodeSettings
parameter_list|(
name|int
name|nodeOrdinal
parameter_list|)
block|{
return|return
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|NetworkModule
operator|.
name|HTTP_ENABLED
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|int
name|numClientNodes
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|boolean
name|enableHttpPipelining
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
name|String
name|nodePrefix
init|=
literal|"foobar"
decl_stmt|;
name|Path
name|baseDir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|InternalTestCluster
name|cluster0
init|=
operator|new
name|InternalTestCluster
argument_list|(
literal|"local"
argument_list|,
name|clusterSeed
argument_list|,
name|baseDir
argument_list|,
name|masterNodes
argument_list|,
name|minNumDataNodes
argument_list|,
name|maxNumDataNodes
argument_list|,
name|clusterName1
argument_list|,
name|nodeConfigurationSource
argument_list|,
name|numClientNodes
argument_list|,
name|enableHttpPipelining
argument_list|,
name|nodePrefix
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Function
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|InternalTestCluster
name|cluster1
init|=
operator|new
name|InternalTestCluster
argument_list|(
literal|"local"
argument_list|,
name|clusterSeed
argument_list|,
name|baseDir
argument_list|,
name|masterNodes
argument_list|,
name|minNumDataNodes
argument_list|,
name|maxNumDataNodes
argument_list|,
name|clusterName2
argument_list|,
name|nodeConfigurationSource
argument_list|,
name|numClientNodes
argument_list|,
name|enableHttpPipelining
argument_list|,
name|nodePrefix
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Function
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|assertClusters
argument_list|(
name|cluster0
argument_list|,
name|cluster1
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|long
name|seed
init|=
name|randomLong
argument_list|()
decl_stmt|;
try|try
block|{
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|cluster0
operator|.
name|beforeTest
argument_list|(
name|random
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|{
name|Random
name|random
init|=
operator|new
name|Random
argument_list|(
name|seed
argument_list|)
decl_stmt|;
name|cluster1
operator|.
name|beforeTest
argument_list|(
name|random
argument_list|,
name|random
operator|.
name|nextDouble
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|assertArrayEquals
argument_list|(
name|cluster0
operator|.
name|getNodeNames
argument_list|()
argument_list|,
name|cluster1
operator|.
name|getNodeNames
argument_list|()
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|Client
argument_list|>
name|iterator1
init|=
name|cluster1
operator|.
name|getClients
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|Client
name|client
range|:
name|cluster0
operator|.
name|getClients
argument_list|()
control|)
block|{
name|assertTrue
argument_list|(
name|iterator1
operator|.
name|hasNext
argument_list|()
argument_list|)
expr_stmt|;
name|Client
name|other
init|=
name|iterator1
operator|.
name|next
argument_list|()
decl_stmt|;
name|assertSettings
argument_list|(
name|client
operator|.
name|settings
argument_list|()
argument_list|,
name|other
operator|.
name|settings
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|assertArrayEquals
argument_list|(
name|cluster0
operator|.
name|getNodeNames
argument_list|()
argument_list|,
name|cluster1
operator|.
name|getNodeNames
argument_list|()
argument_list|)
expr_stmt|;
name|cluster0
operator|.
name|afterTest
argument_list|()
expr_stmt|;
name|cluster1
operator|.
name|afterTest
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|IOUtils
operator|.
name|close
argument_list|(
name|cluster0
argument_list|,
name|cluster1
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|testDataFolderAssignmentAndCleaning
specifier|public
name|void
name|testDataFolderAssignmentAndCleaning
parameter_list|()
throws|throws
name|IOException
throws|,
name|InterruptedException
block|{
name|long
name|clusterSeed
init|=
name|randomLong
argument_list|()
decl_stmt|;
name|boolean
name|masterNodes
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
comment|// we need one stable node
name|int
name|minNumDataNodes
init|=
literal|2
decl_stmt|;
name|int
name|maxNumDataNodes
init|=
literal|2
decl_stmt|;
specifier|final
name|String
name|clusterName1
init|=
literal|"shared1"
decl_stmt|;
name|NodeConfigurationSource
name|nodeConfigurationSource
init|=
operator|new
name|NodeConfigurationSource
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Settings
name|nodeSettings
parameter_list|(
name|int
name|nodeOrdinal
parameter_list|)
block|{
return|return
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|NetworkModule
operator|.
name|HTTP_ENABLED
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
block|}
decl_stmt|;
name|int
name|numClientNodes
init|=
name|randomIntBetween
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|boolean
name|enableHttpPipelining
init|=
name|randomBoolean
argument_list|()
decl_stmt|;
name|String
name|nodePrefix
init|=
literal|"test"
decl_stmt|;
name|Path
name|baseDir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|InternalTestCluster
name|cluster
init|=
operator|new
name|InternalTestCluster
argument_list|(
literal|"local"
argument_list|,
name|clusterSeed
argument_list|,
name|baseDir
argument_list|,
name|masterNodes
argument_list|,
name|minNumDataNodes
argument_list|,
name|maxNumDataNodes
argument_list|,
name|clusterName1
argument_list|,
name|nodeConfigurationSource
argument_list|,
name|numClientNodes
argument_list|,
name|enableHttpPipelining
argument_list|,
name|nodePrefix
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Function
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|cluster
operator|.
name|beforeTest
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Path
index|[]
argument_list|>
name|shardNodePaths
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|cluster
operator|.
name|getNodeNames
argument_list|()
control|)
block|{
name|shardNodePaths
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|String
name|poorNode
init|=
name|randomFrom
argument_list|(
name|cluster
operator|.
name|getNodeNames
argument_list|()
argument_list|)
decl_stmt|;
name|Path
name|dataPath
init|=
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|poorNode
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|Path
name|testMarker
init|=
name|dataPath
operator|.
name|resolve
argument_list|(
literal|"testMarker"
argument_list|)
decl_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|testMarker
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|stopRandomNode
argument_list|(
name|InternalTestCluster
operator|.
name|nameFilter
argument_list|(
name|poorNode
argument_list|)
argument_list|)
expr_stmt|;
name|assertFileExists
argument_list|(
name|testMarker
argument_list|)
expr_stmt|;
comment|// stopping a node half way shouldn't clean data
specifier|final
name|String
name|stableNode
init|=
name|randomFrom
argument_list|(
name|cluster
operator|.
name|getNodeNames
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Path
name|stableDataPath
init|=
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|stableNode
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|Path
name|stableTestMarker
init|=
name|stableDataPath
operator|.
name|resolve
argument_list|(
literal|"stableTestMarker"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|stableDataPath
argument_list|,
name|not
argument_list|(
name|dataPath
argument_list|)
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|stableTestMarker
argument_list|)
expr_stmt|;
specifier|final
name|String
name|newNode1
init|=
name|cluster
operator|.
name|startNode
argument_list|()
decl_stmt|;
name|assertThat
argument_list|(
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|newNode1
argument_list|)
index|[
literal|0
index|]
argument_list|,
name|equalTo
argument_list|(
name|dataPath
argument_list|)
argument_list|)
expr_stmt|;
name|assertFileExists
argument_list|(
name|testMarker
argument_list|)
expr_stmt|;
comment|// starting a node should re-use data folders and not clean it
specifier|final
name|String
name|newNode2
init|=
name|cluster
operator|.
name|startNode
argument_list|()
decl_stmt|;
specifier|final
name|Path
name|newDataPath
init|=
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|newNode2
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
specifier|final
name|Path
name|newTestMarker
init|=
name|newDataPath
operator|.
name|resolve
argument_list|(
literal|"newTestMarker"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|newDataPath
argument_list|,
name|not
argument_list|(
name|dataPath
argument_list|)
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|newTestMarker
argument_list|)
expr_stmt|;
name|cluster
operator|.
name|beforeTest
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|assertFileNotExists
argument_list|(
name|newTestMarker
argument_list|)
expr_stmt|;
comment|// the cluster should be reset for a new test, cleaning up the extra path we made
name|assertFileNotExists
argument_list|(
name|testMarker
argument_list|)
expr_stmt|;
comment|// a new unknown node used this path, it should be cleaned
name|assertFileExists
argument_list|(
name|stableTestMarker
argument_list|)
expr_stmt|;
comment|// but leaving the structure of existing, reused nodes
for|for
control|(
name|String
name|name
range|:
name|cluster
operator|.
name|getNodeNames
argument_list|()
control|)
block|{
name|assertThat
argument_list|(
literal|"data paths for "
operator|+
name|name
operator|+
literal|" changed"
argument_list|,
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|name
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|shardNodePaths
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cluster
operator|.
name|beforeTest
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|assertFileExists
argument_list|(
name|stableTestMarker
argument_list|)
expr_stmt|;
comment|// but leaving the structure of existing, reused nodes
for|for
control|(
name|String
name|name
range|:
name|cluster
operator|.
name|getNodeNames
argument_list|()
control|)
block|{
name|assertThat
argument_list|(
literal|"data paths for "
operator|+
name|name
operator|+
literal|" changed"
argument_list|,
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|name
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|shardNodePaths
operator|.
name|get
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|getNodePaths
specifier|private
name|Path
index|[]
name|getNodePaths
parameter_list|(
name|InternalTestCluster
name|cluster
parameter_list|,
name|String
name|name
parameter_list|)
block|{
specifier|final
name|NodeEnvironment
name|nodeEnvironment
init|=
name|cluster
operator|.
name|getInstance
argument_list|(
name|NodeEnvironment
operator|.
name|class
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeEnvironment
operator|.
name|hasNodeFile
argument_list|()
condition|)
block|{
return|return
name|nodeEnvironment
operator|.
name|nodeDataPaths
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|new
name|Path
index|[
literal|0
index|]
return|;
block|}
block|}
DECL|method|testDifferentRolesMaintainPathOnRestart
specifier|public
name|void
name|testDifferentRolesMaintainPathOnRestart
parameter_list|()
throws|throws
name|Exception
block|{
specifier|final
name|Path
name|baseDir
init|=
name|createTempDir
argument_list|()
decl_stmt|;
name|InternalTestCluster
name|cluster
init|=
operator|new
name|InternalTestCluster
argument_list|(
literal|"local"
argument_list|,
name|randomLong
argument_list|()
argument_list|,
name|baseDir
argument_list|,
literal|true
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"test"
argument_list|,
operator|new
name|NodeConfigurationSource
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Settings
name|nodeSettings
parameter_list|(
name|int
name|nodeOrdinal
parameter_list|)
block|{
return|return
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|NetworkModule
operator|.
name|HTTP_ENABLED
operator|.
name|getKey
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|.
name|put
argument_list|(
name|DiscoverySettings
operator|.
name|INITIAL_STATE_TIMEOUT_SETTING
operator|.
name|getKey
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|Settings
name|transportClientSettings
parameter_list|()
block|{
return|return
name|Settings
operator|.
name|EMPTY
return|;
block|}
block|}
argument_list|,
literal|0
argument_list|,
name|randomBoolean
argument_list|()
argument_list|,
literal|""
argument_list|,
name|Collections
operator|.
name|emptyList
argument_list|()
argument_list|,
name|Function
operator|.
name|identity
argument_list|()
argument_list|)
decl_stmt|;
name|cluster
operator|.
name|beforeTest
argument_list|(
name|random
argument_list|()
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
try|try
block|{
name|Map
argument_list|<
name|DiscoveryNode
operator|.
name|Role
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|pathsPerRole
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|DiscoveryNode
operator|.
name|Role
name|role
init|=
name|randomFrom
argument_list|(
name|MASTER
argument_list|,
name|DiscoveryNode
operator|.
name|Role
operator|.
name|DATA
argument_list|,
name|DiscoveryNode
operator|.
name|Role
operator|.
name|INGEST
argument_list|)
decl_stmt|;
specifier|final
name|String
name|node
decl_stmt|;
switch|switch
condition|(
name|role
condition|)
block|{
case|case
name|MASTER
case|:
name|node
operator|=
name|cluster
operator|.
name|startMasterOnlyNode
argument_list|(
name|Settings
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA
case|:
name|node
operator|=
name|cluster
operator|.
name|startDataOnlyNode
argument_list|(
name|Settings
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
break|break;
case|case
name|INGEST
case|:
name|node
operator|=
name|cluster
operator|.
name|startCoordinatingOnlyNode
argument_list|(
name|Settings
operator|.
name|EMPTY
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"get your story straight"
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|rolePaths
init|=
name|pathsPerRole
operator|.
name|computeIfAbsent
argument_list|(
name|role
argument_list|,
name|k
lambda|->
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Path
name|path
range|:
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|node
argument_list|)
control|)
block|{
name|assertTrue
argument_list|(
name|rolePaths
operator|.
name|add
argument_list|(
name|path
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cluster
operator|.
name|fullRestart
argument_list|()
expr_stmt|;
name|Map
argument_list|<
name|DiscoveryNode
operator|.
name|Role
argument_list|,
name|Set
argument_list|<
name|String
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|cluster
operator|.
name|getNodeNames
argument_list|()
control|)
block|{
name|DiscoveryNode
name|node
init|=
name|cluster
operator|.
name|getInstance
argument_list|(
name|ClusterService
operator|.
name|class
argument_list|,
name|name
argument_list|)
operator|.
name|localNode
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paths
init|=
name|Arrays
operator|.
name|stream
argument_list|(
name|getNodePaths
argument_list|(
name|cluster
argument_list|,
name|name
argument_list|)
argument_list|)
operator|.
name|map
argument_list|(
name|Path
operator|::
name|toString
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toList
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|.
name|isMasterNode
argument_list|()
condition|)
block|{
name|result
operator|.
name|computeIfAbsent
argument_list|(
name|MASTER
argument_list|,
name|k
lambda|->
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
operator|.
name|addAll
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isDataNode
argument_list|()
condition|)
block|{
name|result
operator|.
name|computeIfAbsent
argument_list|(
name|DATA
argument_list|,
name|k
lambda|->
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
operator|.
name|addAll
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|.
name|computeIfAbsent
argument_list|(
name|INGEST
argument_list|,
name|k
lambda|->
operator|new
name|HashSet
argument_list|<>
argument_list|()
argument_list|)
operator|.
name|addAll
argument_list|(
name|paths
argument_list|)
expr_stmt|;
block|}
block|}
name|assertThat
argument_list|(
name|result
operator|.
name|size
argument_list|()
argument_list|,
name|equalTo
argument_list|(
name|pathsPerRole
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|DiscoveryNode
operator|.
name|Role
name|role
range|:
name|result
operator|.
name|keySet
argument_list|()
control|)
block|{
name|assertThat
argument_list|(
literal|"path are not the same for "
operator|+
name|role
argument_list|,
name|result
operator|.
name|get
argument_list|(
name|role
argument_list|)
argument_list|,
name|equalTo
argument_list|(
name|pathsPerRole
operator|.
name|get
argument_list|(
name|role
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cluster
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

