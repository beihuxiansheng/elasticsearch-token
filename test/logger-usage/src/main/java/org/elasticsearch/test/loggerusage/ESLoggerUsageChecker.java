begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.test.loggerusage
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|loggerusage
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Marker
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|message
operator|.
name|ParameterizedMessage
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|util
operator|.
name|Supplier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|AnnotationVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|ClassReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|ClassVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|MethodVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|AbstractInsnNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|IntInsnNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|LdcInsnNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|LineNumberNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|MethodInsnNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|MethodNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|TypeInsnNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|analysis
operator|.
name|Analyzer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|analysis
operator|.
name|AnalyzerException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|analysis
operator|.
name|BasicInterpreter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|analysis
operator|.
name|BasicValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|tree
operator|.
name|analysis
operator|.
name|Frame
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|FileVisitResult
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Paths
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|SimpleFileVisitor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|attribute
operator|.
name|BasicFileAttributes
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_class
DECL|class|ESLoggerUsageChecker
specifier|public
class|class
name|ESLoggerUsageChecker
block|{
DECL|field|LOGGER_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|LOGGER_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Logger
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|THROWABLE_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|THROWABLE_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Throwable
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRING_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|STRING_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRING_ARRAY_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|STRING_ARRAY_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|String
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|PARAMETERIZED_MESSAGE_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|PARAMETERIZED_MESSAGE_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|ParameterizedMessage
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|OBJECT_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|OBJECT_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|OBJECT_ARRAY_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|OBJECT_ARRAY_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|SUPPLIER_ARRAY_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|SUPPLIER_ARRAY_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Supplier
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|MARKER_CLASS
specifier|public
specifier|static
specifier|final
name|Type
name|MARKER_CLASS
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Marker
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|LOGGER_METHODS
specifier|public
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|LOGGER_METHODS
init|=
name|Arrays
operator|.
name|asList
argument_list|(
literal|"trace"
argument_list|,
literal|"debug"
argument_list|,
literal|"info"
argument_list|,
literal|"warn"
argument_list|,
literal|"error"
argument_list|,
literal|"fatal"
argument_list|)
decl_stmt|;
DECL|field|IGNORE_CHECKS_ANNOTATION
specifier|public
specifier|static
specifier|final
name|String
name|IGNORE_CHECKS_ANNOTATION
init|=
literal|"org.elasticsearch.common.SuppressLoggerChecks"
decl_stmt|;
annotation|@
name|SuppressForbidden
argument_list|(
name|reason
operator|=
literal|"command line tool"
argument_list|)
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
modifier|...
name|args
parameter_list|)
throws|throws
name|Exception
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"checking for wrong usages of ESLogger..."
argument_list|)
expr_stmt|;
name|boolean
index|[]
name|wrongUsageFound
init|=
operator|new
name|boolean
index|[
literal|1
index|]
decl_stmt|;
name|checkLoggerUsage
argument_list|(
name|wrongLoggerUsage
lambda|->
block|{
name|System
operator|.
name|err
operator|.
name|println
argument_list|(
name|wrongLoggerUsage
operator|.
name|getErrorLines
argument_list|()
argument_list|)
expr_stmt|;
name|wrongUsageFound
index|[
literal|0
index|]
operator|=
literal|true
expr_stmt|;
block|}
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrongUsageFound
index|[
literal|0
index|]
condition|)
block|{
throw|throw
operator|new
name|Exception
argument_list|(
literal|"Wrong logger usages found"
argument_list|)
throw|;
block|}
else|else
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"No wrong usages found"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkLoggerUsage
specifier|private
specifier|static
name|void
name|checkLoggerUsage
parameter_list|(
name|Consumer
argument_list|<
name|WrongLoggerUsage
argument_list|>
name|wrongUsageCallback
parameter_list|,
name|String
modifier|...
name|classDirectories
parameter_list|)
throws|throws
name|IOException
block|{
for|for
control|(
name|String
name|classDirectory
range|:
name|classDirectories
control|)
block|{
name|Path
name|root
init|=
name|Paths
operator|.
name|get
argument_list|(
name|classDirectory
argument_list|)
decl_stmt|;
if|if
condition|(
name|Files
operator|.
name|isDirectory
argument_list|(
name|root
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|root
operator|+
literal|" should be an existing directory"
argument_list|)
throw|;
block|}
name|Files
operator|.
name|walkFileTree
argument_list|(
name|root
argument_list|,
operator|new
name|SimpleFileVisitor
argument_list|<
name|Path
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|FileVisitResult
name|visitFile
parameter_list|(
name|Path
name|file
parameter_list|,
name|BasicFileAttributes
name|attrs
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|Files
operator|.
name|isRegularFile
argument_list|(
name|file
argument_list|)
operator|&&
name|file
operator|.
name|getFileName
argument_list|()
operator|.
name|toString
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".class"
argument_list|)
condition|)
block|{
try|try
init|(
name|InputStream
name|in
init|=
name|Files
operator|.
name|newInputStream
argument_list|(
name|file
argument_list|)
init|)
block|{
name|ESLoggerUsageChecker
operator|.
name|check
argument_list|(
name|wrongUsageCallback
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|super
operator|.
name|visitFile
argument_list|(
name|file
argument_list|,
name|attrs
argument_list|)
return|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|check
specifier|public
specifier|static
name|void
name|check
parameter_list|(
name|Consumer
argument_list|<
name|WrongLoggerUsage
argument_list|>
name|wrongUsageCallback
parameter_list|,
name|InputStream
name|inputStream
parameter_list|)
throws|throws
name|IOException
block|{
name|check
argument_list|(
name|wrongUsageCallback
argument_list|,
name|inputStream
argument_list|,
name|s
lambda|->
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// used by tests
DECL|method|check
specifier|static
name|void
name|check
parameter_list|(
name|Consumer
argument_list|<
name|WrongLoggerUsage
argument_list|>
name|wrongUsageCallback
parameter_list|,
name|InputStream
name|inputStream
parameter_list|,
name|Predicate
argument_list|<
name|String
argument_list|>
name|methodsToCheck
parameter_list|)
throws|throws
name|IOException
block|{
name|ClassReader
name|cr
init|=
operator|new
name|ClassReader
argument_list|(
name|inputStream
argument_list|)
decl_stmt|;
name|cr
operator|.
name|accept
argument_list|(
operator|new
name|ClassChecker
argument_list|(
name|wrongUsageCallback
argument_list|,
name|methodsToCheck
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|class|WrongLoggerUsage
specifier|public
specifier|static
class|class
name|WrongLoggerUsage
block|{
DECL|field|className
specifier|private
specifier|final
name|String
name|className
decl_stmt|;
DECL|field|methodName
specifier|private
specifier|final
name|String
name|methodName
decl_stmt|;
DECL|field|logMethodName
specifier|private
specifier|final
name|String
name|logMethodName
decl_stmt|;
DECL|field|line
specifier|private
specifier|final
name|int
name|line
decl_stmt|;
DECL|field|errorMessage
specifier|private
specifier|final
name|String
name|errorMessage
decl_stmt|;
DECL|method|WrongLoggerUsage
specifier|public
name|WrongLoggerUsage
parameter_list|(
name|String
name|className
parameter_list|,
name|String
name|methodName
parameter_list|,
name|String
name|logMethodName
parameter_list|,
name|int
name|line
parameter_list|,
name|String
name|errorMessage
parameter_list|)
block|{
name|this
operator|.
name|className
operator|=
name|className
expr_stmt|;
name|this
operator|.
name|methodName
operator|=
name|methodName
expr_stmt|;
name|this
operator|.
name|logMethodName
operator|=
name|logMethodName
expr_stmt|;
name|this
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|this
operator|.
name|errorMessage
operator|=
name|errorMessage
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"WrongLoggerUsage{"
operator|+
literal|"className='"
operator|+
name|className
operator|+
literal|'\''
operator|+
literal|", methodName='"
operator|+
name|methodName
operator|+
literal|'\''
operator|+
literal|", logMethodName='"
operator|+
name|logMethodName
operator|+
literal|'\''
operator|+
literal|", line="
operator|+
name|line
operator|+
literal|", errorMessage='"
operator|+
name|errorMessage
operator|+
literal|'\''
operator|+
literal|'}'
return|;
block|}
comment|/**          * Returns an error message that has the form of stack traces emitted by {@link Throwable#printStackTrace}          */
DECL|method|getErrorLines
specifier|public
name|String
name|getErrorLines
parameter_list|()
block|{
name|String
name|fullClassName
init|=
name|Type
operator|.
name|getObjectType
argument_list|(
name|className
argument_list|)
operator|.
name|getClassName
argument_list|()
decl_stmt|;
name|String
name|simpleClassName
init|=
name|fullClassName
operator|.
name|substring
argument_list|(
name|fullClassName
operator|.
name|lastIndexOf
argument_list|(
literal|"."
argument_list|)
operator|+
literal|1
argument_list|,
name|fullClassName
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|innerClassIndex
init|=
name|simpleClassName
operator|.
name|indexOf
argument_list|(
literal|"$"
argument_list|)
decl_stmt|;
if|if
condition|(
name|innerClassIndex
operator|>
literal|0
condition|)
block|{
name|simpleClassName
operator|=
name|simpleClassName
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|innerClassIndex
argument_list|)
expr_stmt|;
block|}
name|simpleClassName
operator|=
name|simpleClassName
operator|+
literal|".java"
expr_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Bad usage of "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|LOGGER_CLASS
operator|.
name|getClassName
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
literal|"#"
argument_list|)
operator|.
name|append
argument_list|(
name|logMethodName
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"\n\tat "
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|fullClassName
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|methodName
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|simpleClassName
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|ClassChecker
specifier|private
specifier|static
class|class
name|ClassChecker
extends|extends
name|ClassVisitor
block|{
DECL|field|className
specifier|private
name|String
name|className
decl_stmt|;
DECL|field|ignoreChecks
specifier|private
name|boolean
name|ignoreChecks
decl_stmt|;
DECL|field|wrongUsageCallback
specifier|private
specifier|final
name|Consumer
argument_list|<
name|WrongLoggerUsage
argument_list|>
name|wrongUsageCallback
decl_stmt|;
DECL|field|methodsToCheck
specifier|private
specifier|final
name|Predicate
argument_list|<
name|String
argument_list|>
name|methodsToCheck
decl_stmt|;
DECL|method|ClassChecker
specifier|public
name|ClassChecker
parameter_list|(
name|Consumer
argument_list|<
name|WrongLoggerUsage
argument_list|>
name|wrongUsageCallback
parameter_list|,
name|Predicate
argument_list|<
name|String
argument_list|>
name|methodsToCheck
parameter_list|)
block|{
name|super
argument_list|(
name|Opcodes
operator|.
name|ASM5
argument_list|)
expr_stmt|;
name|this
operator|.
name|wrongUsageCallback
operator|=
name|wrongUsageCallback
expr_stmt|;
name|this
operator|.
name|methodsToCheck
operator|=
name|methodsToCheck
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|visit
specifier|public
name|void
name|visit
parameter_list|(
name|int
name|version
parameter_list|,
name|int
name|access
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|signature
parameter_list|,
name|String
name|superName
parameter_list|,
name|String
index|[]
name|interfaces
parameter_list|)
block|{
name|this
operator|.
name|className
operator|=
name|name
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|visitAnnotation
specifier|public
name|AnnotationVisitor
name|visitAnnotation
parameter_list|(
name|String
name|desc
parameter_list|,
name|boolean
name|visible
parameter_list|)
block|{
if|if
condition|(
name|IGNORE_CHECKS_ANNOTATION
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|getType
argument_list|(
name|desc
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
condition|)
block|{
name|ignoreChecks
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visitAnnotation
argument_list|(
name|desc
argument_list|,
name|visible
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitMethod
specifier|public
name|MethodVisitor
name|visitMethod
parameter_list|(
name|int
name|access
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|desc
parameter_list|,
name|String
name|signature
parameter_list|,
name|String
index|[]
name|exceptions
parameter_list|)
block|{
if|if
condition|(
name|ignoreChecks
operator|==
literal|false
operator|&&
name|methodsToCheck
operator|.
name|test
argument_list|(
name|name
argument_list|)
condition|)
block|{
return|return
operator|new
name|MethodChecker
argument_list|(
name|this
operator|.
name|className
argument_list|,
name|access
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|wrongUsageCallback
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|visitMethod
argument_list|(
name|access
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
name|signature
argument_list|,
name|exceptions
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|MethodChecker
specifier|private
specifier|static
class|class
name|MethodChecker
extends|extends
name|MethodVisitor
block|{
DECL|field|className
specifier|private
specifier|final
name|String
name|className
decl_stmt|;
DECL|field|wrongUsageCallback
specifier|private
specifier|final
name|Consumer
argument_list|<
name|WrongLoggerUsage
argument_list|>
name|wrongUsageCallback
decl_stmt|;
DECL|field|ignoreChecks
specifier|private
name|boolean
name|ignoreChecks
decl_stmt|;
DECL|method|MethodChecker
specifier|public
name|MethodChecker
parameter_list|(
name|String
name|className
parameter_list|,
name|int
name|access
parameter_list|,
name|String
name|name
parameter_list|,
name|String
name|desc
parameter_list|,
name|Consumer
argument_list|<
name|WrongLoggerUsage
argument_list|>
name|wrongUsageCallback
parameter_list|)
block|{
name|super
argument_list|(
name|Opcodes
operator|.
name|ASM5
argument_list|,
operator|new
name|MethodNode
argument_list|(
name|access
argument_list|,
name|name
argument_list|,
name|desc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|className
operator|=
name|className
expr_stmt|;
name|this
operator|.
name|wrongUsageCallback
operator|=
name|wrongUsageCallback
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|visitAnnotation
specifier|public
name|AnnotationVisitor
name|visitAnnotation
parameter_list|(
name|String
name|desc
parameter_list|,
name|boolean
name|visible
parameter_list|)
block|{
if|if
condition|(
name|IGNORE_CHECKS_ANNOTATION
operator|.
name|equals
argument_list|(
name|Type
operator|.
name|getType
argument_list|(
name|desc
argument_list|)
operator|.
name|getClassName
argument_list|()
argument_list|)
condition|)
block|{
name|ignoreChecks
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|super
operator|.
name|visitAnnotation
argument_list|(
name|desc
argument_list|,
name|visible
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitEnd
specifier|public
name|void
name|visitEnd
parameter_list|()
block|{
if|if
condition|(
name|ignoreChecks
operator|==
literal|false
condition|)
block|{
name|findBadLoggerUsages
argument_list|(
operator|(
name|MethodNode
operator|)
name|mv
argument_list|)
expr_stmt|;
block|}
name|super
operator|.
name|visitEnd
argument_list|()
expr_stmt|;
block|}
DECL|method|findBadLoggerUsages
specifier|public
name|void
name|findBadLoggerUsages
parameter_list|(
name|MethodNode
name|methodNode
parameter_list|)
block|{
name|Analyzer
argument_list|<
name|BasicValue
argument_list|>
name|stringPlaceHolderAnalyzer
init|=
operator|new
name|Analyzer
argument_list|<>
argument_list|(
operator|new
name|PlaceHolderStringInterpreter
argument_list|()
argument_list|)
decl_stmt|;
name|Analyzer
argument_list|<
name|BasicValue
argument_list|>
name|arraySizeAnalyzer
init|=
operator|new
name|Analyzer
argument_list|<>
argument_list|(
operator|new
name|ArraySizeInterpreter
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
name|stringPlaceHolderAnalyzer
operator|.
name|analyze
argument_list|(
name|className
argument_list|,
name|methodNode
argument_list|)
expr_stmt|;
name|arraySizeAnalyzer
operator|.
name|analyze
argument_list|(
name|className
argument_list|,
name|methodNode
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AnalyzerException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Internal error: failed in analysis step"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|Frame
argument_list|<
name|BasicValue
argument_list|>
index|[]
name|logMessageFrames
init|=
name|stringPlaceHolderAnalyzer
operator|.
name|getFrames
argument_list|()
decl_stmt|;
name|Frame
argument_list|<
name|BasicValue
argument_list|>
index|[]
name|arraySizeFrames
init|=
name|arraySizeAnalyzer
operator|.
name|getFrames
argument_list|()
decl_stmt|;
name|AbstractInsnNode
index|[]
name|insns
init|=
name|methodNode
operator|.
name|instructions
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|int
name|lineNumber
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|insns
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|AbstractInsnNode
name|insn
init|=
name|insns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|insn
operator|instanceof
name|LineNumberNode
condition|)
block|{
name|LineNumberNode
name|lineNumberNode
init|=
operator|(
name|LineNumberNode
operator|)
name|insn
decl_stmt|;
name|lineNumber
operator|=
name|lineNumberNode
operator|.
name|line
expr_stmt|;
block|}
if|if
condition|(
name|insn
operator|.
name|getOpcode
argument_list|()
operator|==
name|Opcodes
operator|.
name|INVOKEINTERFACE
condition|)
block|{
name|MethodInsnNode
name|methodInsn
init|=
operator|(
name|MethodInsnNode
operator|)
name|insn
decl_stmt|;
if|if
condition|(
name|Type
operator|.
name|getObjectType
argument_list|(
name|methodInsn
operator|.
name|owner
argument_list|)
operator|.
name|equals
argument_list|(
name|LOGGER_CLASS
argument_list|)
condition|)
block|{
if|if
condition|(
name|LOGGER_METHODS
operator|.
name|contains
argument_list|(
name|methodInsn
operator|.
name|name
argument_list|)
operator|==
literal|false
condition|)
block|{
continue|continue;
block|}
name|Type
index|[]
name|argumentTypes
init|=
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|methodInsn
operator|.
name|desc
argument_list|)
decl_stmt|;
name|int
name|markerOffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argumentTypes
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|MARKER_CLASS
argument_list|)
condition|)
block|{
name|markerOffset
operator|=
literal|1
expr_stmt|;
block|}
name|int
name|lengthWithoutMarker
init|=
name|argumentTypes
operator|.
name|length
operator|-
name|markerOffset
decl_stmt|;
if|if
condition|(
name|lengthWithoutMarker
operator|==
literal|2
operator|&&
name|argumentTypes
index|[
name|markerOffset
operator|+
literal|0
index|]
operator|.
name|equals
argument_list|(
name|STRING_CLASS
argument_list|)
operator|&&
operator|(
name|argumentTypes
index|[
name|markerOffset
operator|+
literal|1
index|]
operator|.
name|equals
argument_list|(
name|OBJECT_ARRAY_CLASS
argument_list|)
operator|||
name|argumentTypes
index|[
name|markerOffset
operator|+
literal|1
index|]
operator|.
name|equals
argument_list|(
name|SUPPLIER_ARRAY_CLASS
argument_list|)
operator|)
condition|)
block|{
comment|// VARARGS METHOD: debug(Marker?, String, (Object...|Supplier...))
name|checkArrayArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|arraySizeFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
name|markerOffset
operator|+
literal|0
argument_list|,
name|markerOffset
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lengthWithoutMarker
operator|>=
literal|2
operator|&&
name|argumentTypes
index|[
name|markerOffset
operator|+
literal|0
index|]
operator|.
name|equals
argument_list|(
name|STRING_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
name|markerOffset
operator|+
literal|1
index|]
operator|.
name|equals
argument_list|(
name|OBJECT_CLASS
argument_list|)
condition|)
block|{
comment|// MULTI-PARAM METHOD: debug(Marker?, String, Object p0, ...)
name|checkFixedArityArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
name|markerOffset
operator|+
literal|0
argument_list|,
name|lengthWithoutMarker
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lengthWithoutMarker
operator|==
literal|1
operator|||
name|lengthWithoutMarker
operator|==
literal|2
operator|)
operator|&&
name|lengthWithoutMarker
operator|==
literal|2
condition|?
name|argumentTypes
index|[
name|markerOffset
operator|+
literal|1
index|]
operator|.
name|equals
argument_list|(
name|THROWABLE_CLASS
argument_list|)
else|:
literal|true
condition|)
block|{
comment|// all the rest: debug(Marker?, (Message|MessageSupplier|CharSequence|Object|String|Supplier), Throwable?)
name|checkFixedArityArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
name|markerOffset
operator|+
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Method invoked on "
operator|+
name|LOGGER_CLASS
operator|.
name|getClassName
argument_list|()
operator|+
literal|" that is not supported by logger usage checker"
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|.
name|getOpcode
argument_list|()
operator|==
name|Opcodes
operator|.
name|INVOKESPECIAL
condition|)
block|{
comment|// constructor invocation
name|MethodInsnNode
name|methodInsn
init|=
operator|(
name|MethodInsnNode
operator|)
name|insn
decl_stmt|;
if|if
condition|(
name|Type
operator|.
name|getObjectType
argument_list|(
name|methodInsn
operator|.
name|owner
argument_list|)
operator|.
name|equals
argument_list|(
name|PARAMETERIZED_MESSAGE_CLASS
argument_list|)
condition|)
block|{
name|Type
index|[]
name|argumentTypes
init|=
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|methodInsn
operator|.
name|desc
argument_list|)
decl_stmt|;
if|if
condition|(
name|argumentTypes
operator|.
name|length
operator|==
literal|2
operator|&&
name|argumentTypes
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|STRING_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|OBJECT_ARRAY_CLASS
argument_list|)
condition|)
block|{
name|checkArrayArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|arraySizeFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argumentTypes
operator|.
name|length
operator|==
literal|2
operator|&&
name|argumentTypes
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|STRING_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|OBJECT_CLASS
argument_list|)
condition|)
block|{
name|checkFixedArityArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argumentTypes
operator|.
name|length
operator|==
literal|3
operator|&&
name|argumentTypes
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|STRING_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|OBJECT_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
name|OBJECT_CLASS
argument_list|)
condition|)
block|{
name|checkFixedArityArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argumentTypes
operator|.
name|length
operator|==
literal|3
operator|&&
name|argumentTypes
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|STRING_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|OBJECT_ARRAY_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
name|THROWABLE_CLASS
argument_list|)
condition|)
block|{
name|checkArrayArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|arraySizeFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argumentTypes
operator|.
name|length
operator|==
literal|3
operator|&&
name|argumentTypes
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|STRING_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|1
index|]
operator|.
name|equals
argument_list|(
name|STRING_ARRAY_CLASS
argument_list|)
operator|&&
name|argumentTypes
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
name|THROWABLE_CLASS
argument_list|)
condition|)
block|{
name|checkArrayArgs
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrames
index|[
name|i
index|]
argument_list|,
name|arraySizeFrames
index|[
name|i
index|]
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Constructor invoked on "
operator|+
name|PARAMETERIZED_MESSAGE_CLASS
operator|.
name|getClassName
argument_list|()
operator|+
literal|" that is not supported by logger usage checker"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
DECL|method|checkFixedArityArgs
specifier|private
name|void
name|checkFixedArityArgs
parameter_list|(
name|MethodNode
name|methodNode
parameter_list|,
name|Frame
argument_list|<
name|BasicValue
argument_list|>
name|logMessageFrame
parameter_list|,
name|int
name|lineNumber
parameter_list|,
name|MethodInsnNode
name|methodInsn
parameter_list|,
name|int
name|messageIndex
parameter_list|,
name|int
name|positionalArgsLength
parameter_list|)
block|{
name|PlaceHolderStringBasicValue
name|logMessageLength
init|=
name|checkLogMessageConsistency
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrame
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
name|messageIndex
argument_list|,
name|positionalArgsLength
argument_list|)
decl_stmt|;
if|if
condition|(
name|logMessageLength
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|logMessageLength
operator|.
name|minValue
operator|!=
name|positionalArgsLength
condition|)
block|{
name|wrongUsageCallback
operator|.
name|accept
argument_list|(
operator|new
name|WrongLoggerUsage
argument_list|(
name|className
argument_list|,
name|methodNode
operator|.
name|name
argument_list|,
name|methodInsn
operator|.
name|name
argument_list|,
name|lineNumber
argument_list|,
literal|"Expected "
operator|+
name|logMessageLength
operator|.
name|minValue
operator|+
literal|" arguments but got "
operator|+
name|positionalArgsLength
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
DECL|method|checkArrayArgs
specifier|private
name|void
name|checkArrayArgs
parameter_list|(
name|MethodNode
name|methodNode
parameter_list|,
name|Frame
argument_list|<
name|BasicValue
argument_list|>
name|logMessageFrame
parameter_list|,
name|Frame
argument_list|<
name|BasicValue
argument_list|>
name|arraySizeFrame
parameter_list|,
name|int
name|lineNumber
parameter_list|,
name|MethodInsnNode
name|methodInsn
parameter_list|,
name|int
name|messageIndex
parameter_list|,
name|int
name|arrayIndex
parameter_list|)
block|{
name|BasicValue
name|arraySizeObject
init|=
name|getStackValue
argument_list|(
name|arraySizeFrame
argument_list|,
name|methodInsn
argument_list|,
name|arrayIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|arraySizeObject
operator|instanceof
name|ArraySizeBasicValue
operator|==
literal|false
condition|)
block|{
name|wrongUsageCallback
operator|.
name|accept
argument_list|(
operator|new
name|WrongLoggerUsage
argument_list|(
name|className
argument_list|,
name|methodNode
operator|.
name|name
argument_list|,
name|methodInsn
operator|.
name|name
argument_list|,
name|lineNumber
argument_list|,
literal|"Could not determine size of array"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ArraySizeBasicValue
name|arraySize
init|=
operator|(
name|ArraySizeBasicValue
operator|)
name|arraySizeObject
decl_stmt|;
name|PlaceHolderStringBasicValue
name|logMessageLength
init|=
name|checkLogMessageConsistency
argument_list|(
name|methodNode
argument_list|,
name|logMessageFrame
argument_list|,
name|lineNumber
argument_list|,
name|methodInsn
argument_list|,
name|messageIndex
argument_list|,
name|arraySize
operator|.
name|minValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|logMessageLength
operator|==
literal|null
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|arraySize
operator|.
name|minValue
operator|!=
name|arraySize
operator|.
name|maxValue
condition|)
block|{
name|wrongUsageCallback
operator|.
name|accept
argument_list|(
operator|new
name|WrongLoggerUsage
argument_list|(
name|className
argument_list|,
name|methodNode
operator|.
name|name
argument_list|,
name|methodInsn
operator|.
name|name
argument_list|,
name|lineNumber
argument_list|,
literal|"Multiple parameter arrays with conflicting sizes"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
assert|assert
name|logMessageLength
operator|.
name|minValue
operator|==
name|logMessageLength
operator|.
name|maxValue
operator|&&
name|arraySize
operator|.
name|minValue
operator|==
name|arraySize
operator|.
name|maxValue
assert|;
if|if
condition|(
name|logMessageLength
operator|.
name|minValue
operator|!=
name|arraySize
operator|.
name|minValue
condition|)
block|{
name|wrongUsageCallback
operator|.
name|accept
argument_list|(
operator|new
name|WrongLoggerUsage
argument_list|(
name|className
argument_list|,
name|methodNode
operator|.
name|name
argument_list|,
name|methodInsn
operator|.
name|name
argument_list|,
name|lineNumber
argument_list|,
literal|"Expected "
operator|+
name|logMessageLength
operator|.
name|minValue
operator|+
literal|" arguments but got "
operator|+
name|arraySize
operator|.
name|minValue
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
DECL|method|checkLogMessageConsistency
specifier|private
name|PlaceHolderStringBasicValue
name|checkLogMessageConsistency
parameter_list|(
name|MethodNode
name|methodNode
parameter_list|,
name|Frame
argument_list|<
name|BasicValue
argument_list|>
name|logMessageFrame
parameter_list|,
name|int
name|lineNumber
parameter_list|,
name|MethodInsnNode
name|methodInsn
parameter_list|,
name|int
name|messageIndex
parameter_list|,
name|int
name|argsSize
parameter_list|)
block|{
name|BasicValue
name|logMessageLengthObject
init|=
name|getStackValue
argument_list|(
name|logMessageFrame
argument_list|,
name|methodInsn
argument_list|,
name|messageIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|logMessageLengthObject
operator|instanceof
name|PlaceHolderStringBasicValue
operator|==
literal|false
condition|)
block|{
if|if
condition|(
name|argsSize
operator|>
literal|0
condition|)
block|{
name|wrongUsageCallback
operator|.
name|accept
argument_list|(
operator|new
name|WrongLoggerUsage
argument_list|(
name|className
argument_list|,
name|methodNode
operator|.
name|name
argument_list|,
name|methodInsn
operator|.
name|name
argument_list|,
name|lineNumber
argument_list|,
literal|"First argument must be a string constant so that we can statically ensure proper place holder usage"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// don't check logger usage for logger.warn(someObject)
block|}
return|return
literal|null
return|;
block|}
name|PlaceHolderStringBasicValue
name|logMessageLength
init|=
operator|(
name|PlaceHolderStringBasicValue
operator|)
name|logMessageLengthObject
decl_stmt|;
if|if
condition|(
name|logMessageLength
operator|.
name|minValue
operator|!=
name|logMessageLength
operator|.
name|maxValue
condition|)
block|{
name|wrongUsageCallback
operator|.
name|accept
argument_list|(
operator|new
name|WrongLoggerUsage
argument_list|(
name|className
argument_list|,
name|methodNode
operator|.
name|name
argument_list|,
name|methodInsn
operator|.
name|name
argument_list|,
name|lineNumber
argument_list|,
literal|"Multiple log messages with conflicting number of place holders"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
return|return
name|logMessageLength
return|;
block|}
block|}
DECL|method|calculateNumberOfPlaceHolders
specifier|private
specifier|static
name|int
name|calculateNumberOfPlaceHolders
parameter_list|(
name|String
name|message
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|message
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|message
operator|.
name|charAt
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|==
literal|'{'
operator|&&
name|message
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|==
literal|'}'
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|method|getStackValue
specifier|private
specifier|static
name|BasicValue
name|getStackValue
parameter_list|(
name|Frame
argument_list|<
name|BasicValue
argument_list|>
name|f
parameter_list|,
name|MethodInsnNode
name|methodInsn
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|relIndex
init|=
name|Type
operator|.
name|getArgumentTypes
argument_list|(
name|methodInsn
operator|.
name|desc
argument_list|)
operator|.
name|length
operator|-
literal|1
operator|-
name|index
decl_stmt|;
name|int
name|top
init|=
name|f
operator|.
name|getStackSize
argument_list|()
operator|-
literal|1
decl_stmt|;
return|return
name|relIndex
operator|<=
name|top
condition|?
name|f
operator|.
name|getStack
argument_list|(
name|top
operator|-
name|relIndex
argument_list|)
else|:
literal|null
return|;
block|}
DECL|class|IntMinMaxTrackingBasicValue
specifier|private
specifier|static
class|class
name|IntMinMaxTrackingBasicValue
extends|extends
name|BasicValue
block|{
DECL|field|minValue
specifier|protected
specifier|final
name|int
name|minValue
decl_stmt|;
DECL|field|maxValue
specifier|protected
specifier|final
name|int
name|maxValue
decl_stmt|;
DECL|method|IntMinMaxTrackingBasicValue
specifier|public
name|IntMinMaxTrackingBasicValue
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|minValue
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|maxValue
operator|=
name|value
expr_stmt|;
block|}
DECL|method|IntMinMaxTrackingBasicValue
specifier|public
name|IntMinMaxTrackingBasicValue
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|minValue
parameter_list|,
name|int
name|maxValue
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|minValue
operator|=
name|minValue
expr_stmt|;
name|this
operator|.
name|maxValue
operator|=
name|maxValue
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|o
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|o
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|o
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|super
operator|.
name|equals
argument_list|(
name|o
argument_list|)
condition|)
return|return
literal|false
return|;
name|IntMinMaxTrackingBasicValue
name|that
init|=
operator|(
name|IntMinMaxTrackingBasicValue
operator|)
name|o
decl_stmt|;
if|if
condition|(
name|minValue
operator|!=
name|that
operator|.
name|minValue
condition|)
return|return
literal|false
return|;
return|return
name|maxValue
operator|==
name|that
operator|.
name|maxValue
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|super
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|minValue
expr_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|maxValue
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"IntMinMaxTrackingBasicValue{"
operator|+
literal|"minValue="
operator|+
name|minValue
operator|+
literal|", maxValue="
operator|+
name|maxValue
operator|+
literal|'}'
return|;
block|}
block|}
DECL|class|PlaceHolderStringBasicValue
specifier|private
specifier|static
specifier|final
class|class
name|PlaceHolderStringBasicValue
extends|extends
name|IntMinMaxTrackingBasicValue
block|{
DECL|field|STRING_OBJECT_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|STRING_OBJECT_TYPE
init|=
name|Type
operator|.
name|getObjectType
argument_list|(
literal|"java/lang/String"
argument_list|)
decl_stmt|;
DECL|method|PlaceHolderStringBasicValue
specifier|public
name|PlaceHolderStringBasicValue
parameter_list|(
name|int
name|placeHolders
parameter_list|)
block|{
name|super
argument_list|(
name|STRING_OBJECT_TYPE
argument_list|,
name|placeHolders
argument_list|)
expr_stmt|;
block|}
DECL|method|PlaceHolderStringBasicValue
specifier|public
name|PlaceHolderStringBasicValue
parameter_list|(
name|int
name|minPlaceHolders
parameter_list|,
name|int
name|maxPlaceHolders
parameter_list|)
block|{
name|super
argument_list|(
name|STRING_OBJECT_TYPE
argument_list|,
name|minPlaceHolders
argument_list|,
name|maxPlaceHolders
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|ArraySizeBasicValue
specifier|private
specifier|static
specifier|final
class|class
name|ArraySizeBasicValue
extends|extends
name|IntMinMaxTrackingBasicValue
block|{
DECL|method|ArraySizeBasicValue
specifier|public
name|ArraySizeBasicValue
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|minArraySize
parameter_list|,
name|int
name|maxArraySize
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|,
name|minArraySize
argument_list|,
name|maxArraySize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|IntegerConstantBasicValue
specifier|private
specifier|static
specifier|final
class|class
name|IntegerConstantBasicValue
extends|extends
name|IntMinMaxTrackingBasicValue
block|{
DECL|method|IntegerConstantBasicValue
specifier|public
name|IntegerConstantBasicValue
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|constant
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
DECL|method|IntegerConstantBasicValue
specifier|public
name|IntegerConstantBasicValue
parameter_list|(
name|Type
name|type
parameter_list|,
name|int
name|minConstant
parameter_list|,
name|int
name|maxConstant
parameter_list|)
block|{
name|super
argument_list|(
name|type
argument_list|,
name|minConstant
argument_list|,
name|maxConstant
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|PlaceHolderStringInterpreter
specifier|private
specifier|static
specifier|final
class|class
name|PlaceHolderStringInterpreter
extends|extends
name|BasicInterpreter
block|{
annotation|@
name|Override
DECL|method|newOperation
specifier|public
name|BasicValue
name|newOperation
parameter_list|(
name|AbstractInsnNode
name|insnNode
parameter_list|)
throws|throws
name|AnalyzerException
block|{
if|if
condition|(
name|insnNode
operator|.
name|getOpcode
argument_list|()
operator|==
name|Opcodes
operator|.
name|LDC
condition|)
block|{
name|Object
name|constant
init|=
operator|(
operator|(
name|LdcInsnNode
operator|)
name|insnNode
operator|)
operator|.
name|cst
decl_stmt|;
if|if
condition|(
name|constant
operator|instanceof
name|String
condition|)
block|{
return|return
operator|new
name|PlaceHolderStringBasicValue
argument_list|(
name|calculateNumberOfPlaceHolders
argument_list|(
operator|(
name|String
operator|)
name|constant
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|super
operator|.
name|newOperation
argument_list|(
name|insnNode
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|merge
specifier|public
name|BasicValue
name|merge
parameter_list|(
name|BasicValue
name|value1
parameter_list|,
name|BasicValue
name|value2
parameter_list|)
block|{
if|if
condition|(
name|value1
operator|instanceof
name|PlaceHolderStringBasicValue
operator|&&
name|value2
operator|instanceof
name|PlaceHolderStringBasicValue
operator|&&
name|value1
operator|.
name|equals
argument_list|(
name|value2
argument_list|)
operator|==
literal|false
condition|)
block|{
name|PlaceHolderStringBasicValue
name|c1
init|=
operator|(
name|PlaceHolderStringBasicValue
operator|)
name|value1
decl_stmt|;
name|PlaceHolderStringBasicValue
name|c2
init|=
operator|(
name|PlaceHolderStringBasicValue
operator|)
name|value2
decl_stmt|;
return|return
operator|new
name|PlaceHolderStringBasicValue
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|c1
operator|.
name|minValue
argument_list|,
name|c2
operator|.
name|minValue
argument_list|)
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|c1
operator|.
name|maxValue
argument_list|,
name|c2
operator|.
name|maxValue
argument_list|)
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|merge
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
block|}
DECL|class|ArraySizeInterpreter
specifier|private
specifier|static
specifier|final
class|class
name|ArraySizeInterpreter
extends|extends
name|BasicInterpreter
block|{
annotation|@
name|Override
DECL|method|newOperation
specifier|public
name|BasicValue
name|newOperation
parameter_list|(
name|AbstractInsnNode
name|insnNode
parameter_list|)
throws|throws
name|AnalyzerException
block|{
switch|switch
condition|(
name|insnNode
operator|.
name|getOpcode
argument_list|()
condition|)
block|{
case|case
name|ICONST_0
case|:
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|ICONST_1
case|:
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|ICONST_2
case|:
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
literal|2
argument_list|)
return|;
case|case
name|ICONST_3
case|:
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
literal|3
argument_list|)
return|;
case|case
name|ICONST_4
case|:
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
literal|4
argument_list|)
return|;
case|case
name|ICONST_5
case|:
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
literal|5
argument_list|)
return|;
case|case
name|BIPUSH
case|:
case|case
name|SIPUSH
case|:
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
operator|(
operator|(
name|IntInsnNode
operator|)
name|insnNode
operator|)
operator|.
name|operand
argument_list|)
return|;
case|case
name|Opcodes
operator|.
name|LDC
case|:
block|{
name|Object
name|constant
init|=
operator|(
operator|(
name|LdcInsnNode
operator|)
name|insnNode
operator|)
operator|.
name|cst
decl_stmt|;
if|if
condition|(
name|constant
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
operator|(
name|Integer
operator|)
name|constant
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|super
operator|.
name|newOperation
argument_list|(
name|insnNode
argument_list|)
return|;
block|}
block|}
default|default:
return|return
name|super
operator|.
name|newOperation
argument_list|(
name|insnNode
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|merge
specifier|public
name|BasicValue
name|merge
parameter_list|(
name|BasicValue
name|value1
parameter_list|,
name|BasicValue
name|value2
parameter_list|)
block|{
if|if
condition|(
name|value1
operator|instanceof
name|IntegerConstantBasicValue
operator|&&
name|value2
operator|instanceof
name|IntegerConstantBasicValue
condition|)
block|{
name|IntegerConstantBasicValue
name|c1
init|=
operator|(
name|IntegerConstantBasicValue
operator|)
name|value1
decl_stmt|;
name|IntegerConstantBasicValue
name|c2
init|=
operator|(
name|IntegerConstantBasicValue
operator|)
name|value2
decl_stmt|;
return|return
operator|new
name|IntegerConstantBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|c1
operator|.
name|minValue
argument_list|,
name|c2
operator|.
name|minValue
argument_list|)
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|c1
operator|.
name|maxValue
argument_list|,
name|c2
operator|.
name|maxValue
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|value1
operator|instanceof
name|ArraySizeBasicValue
operator|&&
name|value2
operator|instanceof
name|ArraySizeBasicValue
condition|)
block|{
name|ArraySizeBasicValue
name|c1
init|=
operator|(
name|ArraySizeBasicValue
operator|)
name|value1
decl_stmt|;
name|ArraySizeBasicValue
name|c2
init|=
operator|(
name|ArraySizeBasicValue
operator|)
name|value2
decl_stmt|;
return|return
operator|new
name|ArraySizeBasicValue
argument_list|(
name|Type
operator|.
name|INT_TYPE
argument_list|,
name|Math
operator|.
name|min
argument_list|(
name|c1
operator|.
name|minValue
argument_list|,
name|c2
operator|.
name|minValue
argument_list|)
argument_list|,
name|Math
operator|.
name|max
argument_list|(
name|c1
operator|.
name|maxValue
argument_list|,
name|c2
operator|.
name|maxValue
argument_list|)
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|merge
argument_list|(
name|value1
argument_list|,
name|value2
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|unaryOperation
specifier|public
name|BasicValue
name|unaryOperation
parameter_list|(
name|AbstractInsnNode
name|insnNode
parameter_list|,
name|BasicValue
name|value
parameter_list|)
throws|throws
name|AnalyzerException
block|{
if|if
condition|(
name|insnNode
operator|.
name|getOpcode
argument_list|()
operator|==
name|Opcodes
operator|.
name|ANEWARRAY
operator|&&
name|value
operator|instanceof
name|IntegerConstantBasicValue
condition|)
block|{
name|IntegerConstantBasicValue
name|constantBasicValue
init|=
operator|(
name|IntegerConstantBasicValue
operator|)
name|value
decl_stmt|;
name|String
name|desc
init|=
operator|(
operator|(
name|TypeInsnNode
operator|)
name|insnNode
operator|)
operator|.
name|desc
decl_stmt|;
return|return
operator|new
name|ArraySizeBasicValue
argument_list|(
name|Type
operator|.
name|getType
argument_list|(
literal|"["
operator|+
name|Type
operator|.
name|getObjectType
argument_list|(
name|desc
argument_list|)
argument_list|)
argument_list|,
name|constantBasicValue
operator|.
name|minValue
argument_list|,
name|constantBasicValue
operator|.
name|maxValue
argument_list|)
return|;
block|}
return|return
name|super
operator|.
name|unaryOperation
argument_list|(
name|insnNode
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|ternaryOperation
specifier|public
name|BasicValue
name|ternaryOperation
parameter_list|(
name|AbstractInsnNode
name|insnNode
parameter_list|,
name|BasicValue
name|value1
parameter_list|,
name|BasicValue
name|value2
parameter_list|,
name|BasicValue
name|value3
parameter_list|)
throws|throws
name|AnalyzerException
block|{
if|if
condition|(
name|insnNode
operator|.
name|getOpcode
argument_list|()
operator|==
name|Opcodes
operator|.
name|AASTORE
operator|&&
name|value1
operator|instanceof
name|ArraySizeBasicValue
condition|)
block|{
return|return
name|value1
return|;
block|}
return|return
name|super
operator|.
name|ternaryOperation
argument_list|(
name|insnNode
argument_list|,
name|value1
argument_list|,
name|value2
argument_list|,
name|value3
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

