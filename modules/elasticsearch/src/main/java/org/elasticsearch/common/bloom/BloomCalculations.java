begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.bloom
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bloom
package|;
end_package

begin_comment
comment|/**  * The following calculations are taken from:  * http://www.cs.wisc.edu/~cao/papers/summary-cache/node8.html  * "Bloom Filters - the math"  *  * This class's static methods are meant to facilitate the use of the Bloom  * Filter class by helping to choose correct values of 'bits per element' and  * 'number of hash functions, k'.  */
end_comment

begin_class
DECL|class|BloomCalculations
class|class
name|BloomCalculations
block|{
DECL|field|minBuckets
specifier|private
specifier|static
specifier|final
name|int
name|minBuckets
init|=
literal|2
decl_stmt|;
DECL|field|minK
specifier|private
specifier|static
specifier|final
name|int
name|minK
init|=
literal|1
decl_stmt|;
DECL|field|EXCESS
specifier|private
specifier|static
specifier|final
name|int
name|EXCESS
init|=
literal|20
decl_stmt|;
comment|/**      * In the following table, the row 'i' shows false positive rates if i buckets      * per element are used.  Column 'j' shows false positive rates if j hash      * functions are used.  The first row is 'i=0', the first column is 'j=0'.      * Each cell (i,j) the false positive rate determined by using i buckets per      * element and j hash functions.      */
DECL|field|probs
specifier|static
specifier|final
name|double
index|[]
index|[]
name|probs
init|=
operator|new
name|double
index|[]
index|[]
block|{
block|{
literal|1.0
block|}
block|,
comment|// dummy row representing 0 buckets per element
block|{
literal|1.0
block|,
literal|1.0
block|}
block|,
comment|// dummy row representing 1 buckets per element
block|{
literal|1.0
block|,
literal|0.393
block|,
literal|0.400
block|}
block|,
block|{
literal|1.0
block|,
literal|0.283
block|,
literal|0.237
block|,
literal|0.253
block|}
block|,
block|{
literal|1.0
block|,
literal|0.221
block|,
literal|0.155
block|,
literal|0.147
block|,
literal|0.160
block|}
block|,
block|{
literal|1.0
block|,
literal|0.181
block|,
literal|0.109
block|,
literal|0.092
block|,
literal|0.092
block|,
literal|0.101
block|}
block|,
comment|// 5
block|{
literal|1.0
block|,
literal|0.154
block|,
literal|0.0804
block|,
literal|0.0609
block|,
literal|0.0561
block|,
literal|0.0578
block|,
literal|0.0638
block|}
block|,
block|{
literal|1.0
block|,
literal|0.133
block|,
literal|0.0618
block|,
literal|0.0423
block|,
literal|0.0359
block|,
literal|0.0347
block|,
literal|0.0364
block|}
block|,
block|{
literal|1.0
block|,
literal|0.118
block|,
literal|0.0489
block|,
literal|0.0306
block|,
literal|0.024
block|,
literal|0.0217
block|,
literal|0.0216
block|,
literal|0.0229
block|}
block|,
block|{
literal|1.0
block|,
literal|0.105
block|,
literal|0.0397
block|,
literal|0.0228
block|,
literal|0.0166
block|,
literal|0.0141
block|,
literal|0.0133
block|,
literal|0.0135
block|,
literal|0.0145
block|}
block|,
block|{
literal|1.0
block|,
literal|0.0952
block|,
literal|0.0329
block|,
literal|0.0174
block|,
literal|0.0118
block|,
literal|0.00943
block|,
literal|0.00844
block|,
literal|0.00819
block|,
literal|0.00846
block|}
block|,
comment|// 10
block|{
literal|1.0
block|,
literal|0.0869
block|,
literal|0.0276
block|,
literal|0.0136
block|,
literal|0.00864
block|,
literal|0.0065
block|,
literal|0.00552
block|,
literal|0.00513
block|,
literal|0.00509
block|}
block|,
block|{
literal|1.0
block|,
literal|0.08
block|,
literal|0.0236
block|,
literal|0.0108
block|,
literal|0.00646
block|,
literal|0.00459
block|,
literal|0.00371
block|,
literal|0.00329
block|,
literal|0.00314
block|}
block|,
block|{
literal|1.0
block|,
literal|0.074
block|,
literal|0.0203
block|,
literal|0.00875
block|,
literal|0.00492
block|,
literal|0.00332
block|,
literal|0.00255
block|,
literal|0.00217
block|,
literal|0.00199
block|,
literal|0.00194
block|}
block|,
block|{
literal|1.0
block|,
literal|0.0689
block|,
literal|0.0177
block|,
literal|0.00718
block|,
literal|0.00381
block|,
literal|0.00244
block|,
literal|0.00179
block|,
literal|0.00146
block|,
literal|0.00129
block|,
literal|0.00121
block|,
literal|0.0012
block|}
block|,
block|{
literal|1.0
block|,
literal|0.0645
block|,
literal|0.0156
block|,
literal|0.00596
block|,
literal|0.003
block|,
literal|0.00183
block|,
literal|0.00128
block|,
literal|0.001
block|,
literal|0.000852
block|,
literal|0.000775
block|,
literal|0.000744
block|}
block|,
comment|// 15
block|{
literal|1.0
block|,
literal|0.0606
block|,
literal|0.0138
block|,
literal|0.005
block|,
literal|0.00239
block|,
literal|0.00139
block|,
literal|0.000935
block|,
literal|0.000702
block|,
literal|0.000574
block|,
literal|0.000505
block|,
literal|0.00047
block|,
literal|0.000459
block|}
block|,
block|{
literal|1.0
block|,
literal|0.0571
block|,
literal|0.0123
block|,
literal|0.00423
block|,
literal|0.00193
block|,
literal|0.00107
block|,
literal|0.000692
block|,
literal|0.000499
block|,
literal|0.000394
block|,
literal|0.000335
block|,
literal|0.000302
block|,
literal|0.000287
block|,
literal|0.000284
block|}
block|,
block|{
literal|1.0
block|,
literal|0.054
block|,
literal|0.0111
block|,
literal|0.00362
block|,
literal|0.00158
block|,
literal|0.000839
block|,
literal|0.000519
block|,
literal|0.00036
block|,
literal|0.000275
block|,
literal|0.000226
block|,
literal|0.000198
block|,
literal|0.000183
block|,
literal|0.000176
block|}
block|,
block|{
literal|1.0
block|,
literal|0.0513
block|,
literal|0.00998
block|,
literal|0.00312
block|,
literal|0.0013
block|,
literal|0.000663
block|,
literal|0.000394
block|,
literal|0.000264
block|,
literal|0.000194
block|,
literal|0.000155
block|,
literal|0.000132
block|,
literal|0.000118
block|,
literal|0.000111
block|,
literal|0.000109
block|}
block|,
block|{
literal|1.0
block|,
literal|0.0488
block|,
literal|0.00906
block|,
literal|0.0027
block|,
literal|0.00108
block|,
literal|0.00053
block|,
literal|0.000303
block|,
literal|0.000196
block|,
literal|0.00014
block|,
literal|0.000108
block|,
literal|8.89e-05
block|,
literal|7.77e-05
block|,
literal|7.12e-05
block|,
literal|6.79e-05
block|,
literal|6.71e-05
block|}
comment|// 20
block|}
decl_stmt|;
comment|// the first column is a dummy column representing K=0.
comment|/**      * The optimal number of hashes for a given number of bits per element.      * These values are automatically calculated from the data above.      */
DECL|field|optKPerBuckets
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|optKPerBuckets
init|=
operator|new
name|int
index|[
name|probs
operator|.
name|length
index|]
decl_stmt|;
static|static
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|probs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|double
name|min
init|=
name|Double
operator|.
name|MAX_VALUE
decl_stmt|;
name|double
index|[]
name|prob
init|=
name|probs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|prob
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|prob
index|[
name|j
index|]
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|prob
index|[
name|j
index|]
expr_stmt|;
name|optKPerBuckets
index|[
name|i
index|]
operator|=
name|Math
operator|.
name|max
argument_list|(
name|minK
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Given the number of buckets that can be used per element, return a      * specification that minimizes the false positive rate.      *      * @param bucketsPerElement The number of buckets per element for the filter.      * @return A spec that minimizes the false positive rate.      */
DECL|method|computeBloomSpec
specifier|public
specifier|static
name|BloomSpecification
name|computeBloomSpec
parameter_list|(
name|int
name|bucketsPerElement
parameter_list|)
block|{
assert|assert
name|bucketsPerElement
operator|>=
literal|1
assert|;
assert|assert
name|bucketsPerElement
operator|<=
name|probs
operator|.
name|length
operator|-
literal|1
assert|;
return|return
operator|new
name|BloomSpecification
argument_list|(
name|optKPerBuckets
index|[
name|bucketsPerElement
index|]
argument_list|,
name|bucketsPerElement
argument_list|)
return|;
block|}
comment|/**      * A wrapper class that holds two key parameters for a Bloom Filter: the      * number of hash functions used, and the number of buckets per element used.      */
DECL|class|BloomSpecification
specifier|public
specifier|static
class|class
name|BloomSpecification
block|{
DECL|field|K
specifier|final
name|int
name|K
decl_stmt|;
comment|// number of hash functions.
DECL|field|bucketsPerElement
specifier|final
name|int
name|bucketsPerElement
decl_stmt|;
DECL|method|BloomSpecification
specifier|public
name|BloomSpecification
parameter_list|(
name|int
name|k
parameter_list|,
name|int
name|bucketsPerElement
parameter_list|)
block|{
name|K
operator|=
name|k
expr_stmt|;
name|this
operator|.
name|bucketsPerElement
operator|=
name|bucketsPerElement
expr_stmt|;
block|}
block|}
comment|/**      * Given a maximum tolerable false positive probability, compute a Bloom      * specification which will give less than the specified false positive rate,      * but minimize the number of buckets per element and the number of hash      * functions used.  Because bandwidth (and therefore total bitvector size)      * is considered more expensive than computing power, preference is given      * to minimizing buckets per element rather than number of hash functions.      *      * @param maxBucketsPerElement The maximum number of buckets available for the filter.      * @param maxFalsePosProb      The maximum tolerable false positive rate.      * @return A Bloom Specification which would result in a false positive rate      *         less than specified by the function call      * @throws UnsupportedOperationException if a filter satisfying the parameters cannot be met      */
DECL|method|computeBloomSpec
specifier|public
specifier|static
name|BloomSpecification
name|computeBloomSpec
parameter_list|(
name|int
name|maxBucketsPerElement
parameter_list|,
name|double
name|maxFalsePosProb
parameter_list|)
block|{
assert|assert
name|maxBucketsPerElement
operator|>=
literal|1
assert|;
assert|assert
name|maxBucketsPerElement
operator|<=
name|probs
operator|.
name|length
operator|-
literal|1
assert|;
name|int
name|maxK
init|=
name|probs
index|[
name|maxBucketsPerElement
index|]
operator|.
name|length
operator|-
literal|1
decl_stmt|;
comment|// Handle the trivial cases
if|if
condition|(
name|maxFalsePosProb
operator|>=
name|probs
index|[
name|minBuckets
index|]
index|[
name|minK
index|]
condition|)
block|{
return|return
operator|new
name|BloomSpecification
argument_list|(
literal|2
argument_list|,
name|optKPerBuckets
index|[
literal|2
index|]
argument_list|)
return|;
block|}
if|if
condition|(
name|maxFalsePosProb
operator|<
name|probs
index|[
name|maxBucketsPerElement
index|]
index|[
name|maxK
index|]
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Unable to satisfy %s with %s buckets per element"
argument_list|,
name|maxFalsePosProb
argument_list|,
name|maxBucketsPerElement
argument_list|)
argument_list|)
throw|;
block|}
comment|// First find the minimal required number of buckets:
name|int
name|bucketsPerElement
init|=
literal|2
decl_stmt|;
name|int
name|K
init|=
name|optKPerBuckets
index|[
literal|2
index|]
decl_stmt|;
while|while
condition|(
name|probs
index|[
name|bucketsPerElement
index|]
index|[
name|K
index|]
operator|>
name|maxFalsePosProb
condition|)
block|{
name|bucketsPerElement
operator|++
expr_stmt|;
name|K
operator|=
name|optKPerBuckets
index|[
name|bucketsPerElement
index|]
expr_stmt|;
block|}
comment|// Now that the number of buckets is sufficient, see if we can relax K
comment|// without losing too much precision.
while|while
condition|(
name|probs
index|[
name|bucketsPerElement
index|]
index|[
name|K
operator|-
literal|1
index|]
operator|<=
name|maxFalsePosProb
condition|)
block|{
name|K
operator|--
expr_stmt|;
block|}
return|return
operator|new
name|BloomSpecification
argument_list|(
name|K
argument_list|,
name|bucketsPerElement
argument_list|)
return|;
block|}
comment|/**      * Calculates the maximum number of buckets per element that this implementation      * can support.  Crucially, it will lower the bucket count if necessary to meet      * BitSet's size restrictions.      */
DECL|method|maxBucketsPerElement
specifier|public
specifier|static
name|int
name|maxBucketsPerElement
parameter_list|(
name|long
name|numElements
parameter_list|)
block|{
name|numElements
operator|=
name|Math
operator|.
name|max
argument_list|(
literal|1
argument_list|,
name|numElements
argument_list|)
expr_stmt|;
name|double
name|v
init|=
operator|(
name|Long
operator|.
name|MAX_VALUE
operator|-
name|EXCESS
operator|)
operator|/
operator|(
name|double
operator|)
name|numElements
decl_stmt|;
if|if
condition|(
name|v
operator|<
literal|1.0
condition|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Cannot compute probabilities for "
operator|+
name|numElements
operator|+
literal|" elements."
argument_list|)
throw|;
block|}
return|return
name|Math
operator|.
name|min
argument_list|(
name|BloomCalculations
operator|.
name|probs
operator|.
name|length
operator|-
literal|1
argument_list|,
operator|(
name|int
operator|)
name|v
argument_list|)
return|;
block|}
block|}
end_class

end_unit

