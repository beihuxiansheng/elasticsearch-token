begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Cliff Click and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_comment
comment|/* WARNING: MACHINE GENERATED FILE!  DO NOT EDIT!*/
end_comment

begin_package
DECL|package|org.elasticsearch.common.util.concurrent.highscalelib
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|highscalelib
package|;
end_package

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|Unsafe
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLongFieldUpdater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceFieldUpdater
import|;
end_import

begin_comment
comment|/**  * A lock-free alternate implementation of {@link java.util.concurrent.ConcurrentHashMap}  * with better scaling properties and generally lower costs to mutate the Map.  * It provides identical correctness properties as ConcurrentHashMap.  All  * operations are non-blocking and multi-thread safe, including all update  * operations.  {@link NonBlockingHashtable} scales substatially better than  * {@link java.util.concurrent.ConcurrentHashMap} for high update rates, even with a  * large concurrency factor.  Scaling is linear up to 768 CPUs on a 768-CPU  * Azul box, even with 100% updates or 100% reads or any fraction in-between.  * Linear scaling up to all cpus has been observed on a 32-way Sun US2 box,  * 32-way Sun Niagra box, 8-way Intel box and a 4-way Power box.  *<p/>  * This class obeys the same functional specification as {@link  * java.util.Hashtable}, and includes versions of methods corresponding to  * each method of<tt>Hashtable</tt>. However, even though all operations are  * thread-safe, operations do<em>not</em> entail locking and there is  *<em>not</em> any support for locking the entire table in a way that  * prevents all access.  This class is fully interoperable with  *<tt>Hashtable</tt> in programs that rely on its thread safety but not on  * its synchronization details.  *<p/>  *<p> Operations (including<tt>put</tt>) generally do not block, so may  * overlap with other update operations (including other<tt>puts</tt> and  *<tt>removes</tt>).  Retrievals reflect the results of the most recently  *<em>completed</em> update operations holding upon their onset.  For  * aggregate operations such as<tt>putAll</tt>, concurrent retrievals may  * reflect insertion or removal of only some entries.  Similarly, Iterators  * and Enumerations return elements reflecting the state of the hash table at  * some point at or since the creation of the iterator/enumeration.  They do  *<em>not</em> throw {@link ConcurrentModificationException}.  However,  * iterators are designed to be used by only one thread at a time.  *<p/>  *<p> Very full tables, or tables with high reprobe rates may trigger an  * internal resize operation to move into a larger table.  Resizing is not  * terribly expensive, but it is not free either; during resize operations  * table throughput may drop somewhat.  All threads that visit the table  * during a resize will 'help' the resizing but will still be allowed to  * complete their operation before the resize is finished (i.e., a simple  * 'get' operation on a million-entry table undergoing resizing will not need  * to block until the entire million entries are copied).  *<p/>  *<p>This class and its views and iterators implement all of the  *<em>optional</em> methods of the {@link Map} and {@link Iterator}  * interfaces.  *<p/>  *<p> Like {@link Hashtable} but unlike {@link HashMap}, this class  * does<em>not</em> allow<tt>null</tt> to be used as a key or value.  *  * @author Cliff Click  * @author Prashant Deva - moved hash() function out of get_impl() so it is  *         not calculated multiple times.  * @version 1.1.2  * @param<TypeK> the type of keys maintained by this map  * @param<TypeV> the type of mapped values  * @since 1.5  */
end_comment

begin_class
DECL|class|NonBlockingHashtable
specifier|public
class|class
name|NonBlockingHashtable
parameter_list|<
name|TypeK
parameter_list|,
name|TypeV
parameter_list|>
extends|extends
name|Dictionary
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
implements|,
name|Cloneable
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1234123412341234123L
decl_stmt|;
DECL|field|REPROBE_LIMIT
specifier|private
specifier|static
specifier|final
name|int
name|REPROBE_LIMIT
init|=
literal|10
decl_stmt|;
comment|// Too many reprobes then force a table-resize
comment|// --- Bits to allow Unsafe access to arrays
DECL|field|_unsafe
specifier|private
specifier|static
specifier|final
name|Unsafe
name|_unsafe
init|=
name|UtilUnsafe
operator|.
name|getUnsafe
argument_list|()
decl_stmt|;
DECL|field|_Obase
specifier|private
specifier|static
specifier|final
name|int
name|_Obase
init|=
name|_unsafe
operator|.
name|arrayBaseOffset
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|_Oscale
specifier|private
specifier|static
specifier|final
name|int
name|_Oscale
init|=
name|_unsafe
operator|.
name|arrayIndexScale
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|rawIndex
specifier|private
specifier|static
name|long
name|rawIndex
parameter_list|(
specifier|final
name|Object
index|[]
name|ary
parameter_list|,
specifier|final
name|int
name|idx
parameter_list|)
block|{
assert|assert
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ary
operator|.
name|length
assert|;
return|return
name|_Obase
operator|+
name|idx
operator|*
name|_Oscale
return|;
block|}
comment|// --- Setup to use Unsafe
DECL|field|_kvs_offset
specifier|private
specifier|static
specifier|final
name|long
name|_kvs_offset
decl_stmt|;
static|static
block|{
comment|//<clinit>
name|Field
name|f
init|=
literal|null
decl_stmt|;
try|try
block|{
name|f
operator|=
name|NonBlockingHashtable
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"_kvs"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|NoSuchFieldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|_kvs_offset
operator|=
name|_unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|CAS_kvs
specifier|private
specifier|final
name|boolean
name|CAS_kvs
parameter_list|(
specifier|final
name|Object
index|[]
name|oldkvs
parameter_list|,
specifier|final
name|Object
index|[]
name|newkvs
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|_kvs_offset
argument_list|,
name|oldkvs
argument_list|,
name|newkvs
argument_list|)
return|;
block|}
comment|// --- Adding a 'prime' bit onto Values via wrapping with a junk wrapper class
DECL|class|Prime
specifier|private
specifier|static
specifier|final
class|class
name|Prime
block|{
DECL|field|_V
specifier|final
name|Object
name|_V
decl_stmt|;
DECL|method|Prime
name|Prime
parameter_list|(
name|Object
name|V
parameter_list|)
block|{
name|_V
operator|=
name|V
expr_stmt|;
block|}
DECL|method|unbox
specifier|static
name|Object
name|unbox
parameter_list|(
name|Object
name|V
parameter_list|)
block|{
return|return
name|V
operator|instanceof
name|Prime
condition|?
operator|(
operator|(
name|Prime
operator|)
name|V
operator|)
operator|.
name|_V
else|:
name|V
return|;
block|}
block|}
comment|// --- hash ----------------------------------------------------------------
comment|// Helper function to spread lousy hashCodes
DECL|method|hash
specifier|private
specifier|static
specifier|final
name|int
name|hash
parameter_list|(
specifier|final
name|Object
name|key
parameter_list|)
block|{
name|int
name|h
init|=
name|key
operator|.
name|hashCode
argument_list|()
decl_stmt|;
comment|// The real hashCode call
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
name|h
operator|+=
operator|(
name|h
operator|<<
literal|15
operator|)
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|10
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|3
operator|)
expr_stmt|;
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|6
operator|)
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
return|;
block|}
comment|// --- The Hash Table --------------------
comment|// Slot 0 is always used for a 'CHM' entry below to hold the interesting
comment|// bits of the hash table.  Slot 1 holds full hashes as an array of ints.
comment|// Slots {2,3}, {4,5}, etc hold {Key,Value} pairs.  The entire hash table
comment|// can be atomically replaced by CASing the _kvs field.
comment|//
comment|// Why is CHM buried inside the _kvs Object array, instead of the other way
comment|// around?  The CHM info is used during resize events and updates, but not
comment|// during standard 'get' operations.  I assume 'get' is much more frequent
comment|// than 'put'.  'get' can skip the extra indirection of skipping through the
comment|// CHM to reach the _kvs array.
DECL|field|_kvs
specifier|private
specifier|transient
name|Object
index|[]
name|_kvs
decl_stmt|;
DECL|method|chm
specifier|private
specifier|static
specifier|final
name|CHM
name|chm
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|)
block|{
return|return
operator|(
name|CHM
operator|)
name|kvs
index|[
literal|0
index|]
return|;
block|}
DECL|method|hashes
specifier|private
specifier|static
specifier|final
name|int
index|[]
name|hashes
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|)
block|{
return|return
operator|(
name|int
index|[]
operator|)
name|kvs
index|[
literal|1
index|]
return|;
block|}
comment|// Number of K,V pairs in the table
DECL|method|len
specifier|private
specifier|static
specifier|final
name|int
name|len
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|)
block|{
return|return
operator|(
name|kvs
operator|.
name|length
operator|-
literal|2
operator|)
operator|>>
literal|1
return|;
block|}
comment|// Time since last resize
DECL|field|_last_resize_milli
specifier|private
specifier|transient
name|long
name|_last_resize_milli
decl_stmt|;
comment|// --- Minimum table size ----------------
comment|// Pick size 8 K/V pairs, which turns into (8*2+2)*4+12 = 84 bytes on a
comment|// standard 32-bit HotSpot, and (8*2+2)*8+12 = 156 bytes on 64-bit Azul.
DECL|field|MIN_SIZE_LOG
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SIZE_LOG
init|=
literal|3
decl_stmt|;
comment|//
DECL|field|MIN_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SIZE
init|=
operator|(
literal|1
operator|<<
name|MIN_SIZE_LOG
operator|)
decl_stmt|;
comment|// Must be power of 2
comment|// --- Sentinels -------------------------
comment|// No-Match-Old - putIfMatch does updates only if it matches the old value,
comment|// and NO_MATCH_OLD basically counts as a wildcard match.
DECL|field|NO_MATCH_OLD
specifier|private
specifier|static
specifier|final
name|Object
name|NO_MATCH_OLD
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Sentinel
comment|// Match-Any-not-null - putIfMatch does updates only if it find a real old
comment|// value.
DECL|field|MATCH_ANY
specifier|private
specifier|static
specifier|final
name|Object
name|MATCH_ANY
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Sentinel
comment|// This K/V pair has been deleted (but the Key slot is forever claimed).
comment|// The same Key can be reinserted with a new value later.
DECL|field|TOMBSTONE
specifier|private
specifier|static
specifier|final
name|Object
name|TOMBSTONE
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Prime'd or box'd version of TOMBSTONE.  This K/V pair was deleted, then a
comment|// table resize started.  The K/V pair has been marked so that no new
comment|// updates can happen to the old table (and since the K/V pair was deleted
comment|// nothing was copied to the new table).
DECL|field|TOMBPRIME
specifier|private
specifier|static
specifier|final
name|Prime
name|TOMBPRIME
init|=
operator|new
name|Prime
argument_list|(
name|TOMBSTONE
argument_list|)
decl_stmt|;
comment|// --- key,val -------------------------------------------------------------
comment|// Access K,V for a given idx
comment|//
comment|// Note that these are static, so that the caller is forced to read the _kvs
comment|// field only once, and share that read across all key/val calls - lest the
comment|// _kvs field move out from under us and back-to-back key& val calls refer
comment|// to different _kvs arrays.
DECL|method|key
specifier|private
specifier|static
specifier|final
name|Object
name|key
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
name|kvs
index|[
operator|(
name|idx
operator|<<
literal|1
operator|)
operator|+
literal|2
index|]
return|;
block|}
DECL|method|val
specifier|private
specifier|static
specifier|final
name|Object
name|val
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
name|kvs
index|[
operator|(
name|idx
operator|<<
literal|1
operator|)
operator|+
literal|3
index|]
return|;
block|}
DECL|method|CAS_key
specifier|private
specifier|static
specifier|final
name|boolean
name|CAS_key
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|,
name|int
name|idx
parameter_list|,
name|Object
name|old
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapObject
argument_list|(
name|kvs
argument_list|,
name|rawIndex
argument_list|(
name|kvs
argument_list|,
operator|(
name|idx
operator|<<
literal|1
operator|)
operator|+
literal|2
argument_list|)
argument_list|,
name|old
argument_list|,
name|key
argument_list|)
return|;
block|}
DECL|method|CAS_val
specifier|private
specifier|static
specifier|final
name|boolean
name|CAS_val
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|,
name|int
name|idx
parameter_list|,
name|Object
name|old
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapObject
argument_list|(
name|kvs
argument_list|,
name|rawIndex
argument_list|(
name|kvs
argument_list|,
operator|(
name|idx
operator|<<
literal|1
operator|)
operator|+
literal|3
argument_list|)
argument_list|,
name|old
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|// --- dump ----------------------------------------------------------------
comment|/**      * Verbose printout of table internals, useful for debugging.      */
DECL|method|print
specifier|public
specifier|final
name|void
name|print
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"========="
argument_list|)
expr_stmt|;
name|print2
argument_list|(
name|_kvs
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"========="
argument_list|)
expr_stmt|;
block|}
comment|// print the entire state of the table
DECL|method|print
specifier|private
specifier|final
name|void
name|print
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
argument_list|(
name|kvs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|K
init|=
name|key
argument_list|(
name|kvs
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|K
operator|!=
literal|null
condition|)
block|{
name|String
name|KS
init|=
operator|(
name|K
operator|==
name|TOMBSTONE
operator|)
condition|?
literal|"XXX"
else|:
name|K
operator|.
name|toString
argument_list|()
decl_stmt|;
name|Object
name|V
init|=
name|val
argument_list|(
name|kvs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Object
name|U
init|=
name|Prime
operator|.
name|unbox
argument_list|(
name|V
argument_list|)
decl_stmt|;
name|String
name|p
init|=
operator|(
name|V
operator|==
name|U
operator|)
condition|?
literal|""
else|:
literal|"prime_"
decl_stmt|;
name|String
name|US
init|=
operator|(
name|U
operator|==
name|TOMBSTONE
operator|)
condition|?
literal|"tombstone"
else|:
name|U
operator|.
name|toString
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
operator|+
name|i
operator|+
literal|" ("
operator|+
name|KS
operator|+
literal|","
operator|+
name|p
operator|+
name|US
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|Object
index|[]
name|newkvs
init|=
name|chm
argument_list|(
name|kvs
argument_list|)
operator|.
name|_newkvs
decl_stmt|;
comment|// New table, if any
if|if
condition|(
name|newkvs
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"----"
argument_list|)
expr_stmt|;
name|print
argument_list|(
name|newkvs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// print only the live values, broken down by the table they are in
DECL|method|print2
specifier|private
specifier|final
name|void
name|print2
parameter_list|(
name|Object
index|[]
name|kvs
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
argument_list|(
name|kvs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|Object
name|key
init|=
name|key
argument_list|(
name|kvs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
name|val
argument_list|(
name|kvs
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|Object
name|U
init|=
name|Prime
operator|.
name|unbox
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|key
operator|!=
name|TOMBSTONE
operator|&&
comment|// key is sane
name|val
operator|!=
literal|null
operator|&&
name|U
operator|!=
name|TOMBSTONE
condition|)
block|{
comment|// val is sane
name|String
name|p
init|=
operator|(
name|val
operator|==
name|U
operator|)
condition|?
literal|""
else|:
literal|"prime_"
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|""
operator|+
name|i
operator|+
literal|" ("
operator|+
name|key
operator|+
literal|","
operator|+
name|p
operator|+
name|val
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
block|}
name|Object
index|[]
name|newkvs
init|=
name|chm
argument_list|(
name|kvs
argument_list|)
operator|.
name|_newkvs
decl_stmt|;
comment|// New table, if any
if|if
condition|(
name|newkvs
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"----"
argument_list|)
expr_stmt|;
name|print2
argument_list|(
name|newkvs
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Count of reprobes
DECL|field|_reprobes
specifier|private
specifier|transient
name|Counter
name|_reprobes
init|=
operator|new
name|Counter
argument_list|()
decl_stmt|;
comment|/**      * Get and clear the current count of reprobes.  Reprobes happen on key      * collisions, and a high reprobe rate may indicate a poor hash function or      * weaknesses in the table resizing function.      *      * @return the count of reprobes since the last call to {@link #reprobes}      *         or since the table was created.      */
DECL|method|reprobes
specifier|public
name|long
name|reprobes
parameter_list|()
block|{
name|long
name|r
init|=
name|_reprobes
operator|.
name|get
argument_list|()
decl_stmt|;
name|_reprobes
operator|=
operator|new
name|Counter
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
comment|// --- reprobe_limit -----------------------------------------------------
comment|// Heuristic to decide if we have reprobed toooo many times.  Running over
comment|// the reprobe limit on a 'get' call acts as a 'miss'; on a 'put' call it
comment|// can trigger a table resize.  Several places must have exact agreement on
comment|// what the reprobe_limit is, so we share it here.
DECL|method|reprobe_limit
specifier|private
specifier|static
specifier|final
name|int
name|reprobe_limit
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|REPROBE_LIMIT
operator|+
operator|(
name|len
operator|>>
literal|2
operator|)
return|;
block|}
comment|// --- NonBlockingHashtable --------------------------------------------------
comment|// Constructors
comment|/**      * Create a new NonBlockingHashtable with default minimum size (currently set      * to 8 K/V pairs or roughly 84 bytes on a standard 32-bit JVM).      */
DECL|method|NonBlockingHashtable
specifier|public
name|NonBlockingHashtable
parameter_list|()
block|{
name|this
argument_list|(
name|MIN_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new NonBlockingHashtable with initial room for the given number of      * elements, thus avoiding internal resizing operations to reach an      * appropriate size.  Large numbers here when used with a small count of      * elements will sacrifice space for a small amount of time gained.  The      * initial size will be rounded up internally to the next larger power of 2.      */
DECL|method|NonBlockingHashtable
specifier|public
name|NonBlockingHashtable
parameter_list|(
specifier|final
name|int
name|initial_sz
parameter_list|)
block|{
name|initialize
argument_list|(
name|initial_sz
argument_list|)
expr_stmt|;
block|}
DECL|method|initialize
specifier|private
specifier|final
name|void
name|initialize
parameter_list|(
name|int
name|initial_sz
parameter_list|)
block|{
if|if
condition|(
name|initial_sz
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|int
name|i
decl_stmt|;
comment|// Convert to next largest power-of-2
if|if
condition|(
name|initial_sz
operator|>
literal|1024
operator|*
literal|1024
condition|)
name|initial_sz
operator|=
literal|1024
operator|*
literal|1024
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MIN_SIZE_LOG
init|;
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<
operator|(
name|initial_sz
operator|<<
literal|2
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|// Double size for K,V pairs, add 1 for CHM and 1 for hashes
name|_kvs
operator|=
operator|new
name|Object
index|[
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|2
index|]
expr_stmt|;
name|_kvs
index|[
literal|0
index|]
operator|=
operator|new
name|CHM
argument_list|(
operator|new
name|Counter
argument_list|()
argument_list|)
expr_stmt|;
comment|// CHM in slot 0
name|_kvs
index|[
literal|1
index|]
operator|=
operator|new
name|int
index|[
literal|1
operator|<<
name|i
index|]
expr_stmt|;
comment|// Matching hash entries
name|_last_resize_milli
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|// Version for subclassed readObject calls, to be called after the defaultReadObject
DECL|method|initialize
specifier|protected
specifier|final
name|void
name|initialize
parameter_list|()
block|{
name|initialize
argument_list|(
name|MIN_SIZE
argument_list|)
expr_stmt|;
block|}
comment|// --- wrappers ------------------------------------------------------------
comment|/**      * Returns the number of key-value mappings in this map.      *      * @return the number of key-value mappings in this map      */
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|chm
argument_list|(
name|_kvs
argument_list|)
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns<tt>size() == 0</tt>.      *      * @return<tt>size() == 0</tt>      */
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
comment|/**      * Tests if the key in the table using the<tt>equals</tt> method.      *      * @return<tt>true</tt> if the key is in the table using the<tt>equals</tt> method      * @throws NullPointerException if the specified key is null      */
annotation|@
name|Override
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Legacy method testing if some key maps into the specified value in this      * table.  This method is identical in functionality to {@link      * #containsValue}, and exists solely to ensure full compatibility with      * class {@link java.util.Hashtable}, which supported this method prior to      * introduction of the Java Collections framework.      *      * @param val a value to search for      * @return<tt>true</tt> if this map maps one or more keys to the specified value      * @throws NullPointerException if the specified value is null      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|val
parameter_list|)
block|{
return|return
name|containsValue
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Maps the specified key to the specified value in the table.  Neither key      * nor value can be null.      *<p> The value can be retrieved by calling {@link #get} with a key that is      * equal to the original key.      *      * @param key key with which the specified value is to be associated      * @param val value to be associated with the specified key      * @return the previous value associated with<tt>key</tt>, or      *<tt>null</tt> if there was no mapping for<tt>key</tt>      * @throws NullPointerException if the specified key or value is null      */
annotation|@
name|Override
DECL|method|put
specifier|public
name|TypeV
name|put
parameter_list|(
name|TypeK
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|NO_MATCH_OLD
argument_list|)
return|;
block|}
comment|/**      * Atomically, do a {@link #put} if-and-only-if the key is not mapped.      * Useful to ensure that only a single mapping for the key exists, even if      * many threads are trying to create the mapping in parallel.      *      * @return the previous value associated with the specified key,      *         or<tt>null</tt> if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|putIfAbsent
specifier|public
name|TypeV
name|putIfAbsent
parameter_list|(
name|TypeK
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|TOMBSTONE
argument_list|)
return|;
block|}
comment|/**      * Removes the key (and its corresponding value) from this map.      * This method does nothing if the key is not in the map.      *      * @return the previous value associated with<tt>key</tt>, or      *<tt>null</tt> if there was no mapping for<tt>key</tt>      * @throws NullPointerException if the specified key is null      */
annotation|@
name|Override
DECL|method|remove
specifier|public
name|TypeV
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|TOMBSTONE
argument_list|,
name|NO_MATCH_OLD
argument_list|)
return|;
block|}
comment|/**      * Atomically do a {@link #remove(Object)} if-and-only-if the key is mapped      * to a value which is<code>equals</code> to the given value.      *      * @throws NullPointerException if the specified key or value is null      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|TOMBSTONE
argument_list|,
name|val
argument_list|)
operator|==
name|val
return|;
block|}
comment|/**      * Atomically do a<code>put(key,val)</code> if-and-only-if the key is      * mapped to some value already.      *      * @throws NullPointerException if the specified key or value is null      */
DECL|method|replace
specifier|public
name|TypeV
name|replace
parameter_list|(
name|TypeK
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|MATCH_ANY
argument_list|)
return|;
block|}
comment|/**      * Atomically do a<code>put(key,newValue)</code> if-and-only-if the key is      * mapped a value which is<code>equals</code> to<code>oldValue</code>.      *      * @throws NullPointerException if the specified key or value is null      */
DECL|method|replace
specifier|public
name|boolean
name|replace
parameter_list|(
name|TypeK
name|key
parameter_list|,
name|TypeV
name|oldValue
parameter_list|,
name|TypeV
name|newValue
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|,
name|oldValue
argument_list|)
operator|==
name|oldValue
return|;
block|}
DECL|method|putIfMatch
specifier|private
specifier|final
name|TypeV
name|putIfMatch
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|newVal
parameter_list|,
name|Object
name|oldVal
parameter_list|)
block|{
if|if
condition|(
name|oldVal
operator|==
literal|null
operator|||
name|newVal
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
specifier|final
name|Object
name|res
init|=
name|putIfMatch
argument_list|(
name|this
argument_list|,
name|_kvs
argument_list|,
name|key
argument_list|,
name|newVal
argument_list|,
name|oldVal
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|res
operator|instanceof
name|Prime
operator|)
assert|;
assert|assert
name|res
operator|!=
literal|null
assert|;
return|return
name|res
operator|==
name|TOMBSTONE
condition|?
literal|null
else|:
operator|(
name|TypeV
operator|)
name|res
return|;
block|}
comment|/**      * Copies all of the mappings from the specified map to this one, replacing      * any existing mappings.      *      * @param m mappings to be stored in this map      */
annotation|@
name|Override
DECL|method|putAll
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|TypeK
argument_list|,
name|?
extends|extends
name|TypeV
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|TypeK
argument_list|,
name|?
extends|extends
name|TypeV
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes all of the mappings from this map.      */
annotation|@
name|Override
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// Smack a new empty table down
name|Object
index|[]
name|newkvs
init|=
operator|new
name|NonBlockingHashtable
argument_list|(
name|MIN_SIZE
argument_list|)
operator|.
name|_kvs
decl_stmt|;
while|while
condition|(
operator|!
name|CAS_kvs
argument_list|(
name|_kvs
argument_list|,
name|newkvs
argument_list|)
condition|)
comment|// Spin until the clear works
empty_stmt|;
block|}
comment|/**      * Returns<tt>true</tt> if this Map maps one or more keys to the specified      * value.<em>Note</em>: This method requires a full internal traversal of the      * hash table and is much slower than {@link #containsKey}.      *      * @param val value whose presence in this map is to be tested      * @return<tt>true</tt> if this map maps one or more keys to the specified value      * @throws NullPointerException if the specified value is null      */
annotation|@
name|Override
DECL|method|containsValue
specifier|public
name|boolean
name|containsValue
parameter_list|(
specifier|final
name|Object
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
for|for
control|(
name|TypeV
name|V
range|:
name|values
argument_list|()
control|)
if|if
condition|(
name|V
operator|==
name|val
operator|||
name|V
operator|.
name|equals
argument_list|(
name|val
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|// This function is supposed to do something for Hashtable, and the JCK
comment|// tests hang until it gets called... by somebody ... for some reason,
comment|// any reason....
DECL|method|rehash
specifier|protected
name|void
name|rehash
parameter_list|()
block|{     }
comment|/**      * Creates a shallow copy of this hashtable. All the structure of the      * hashtable itself is copied, but the keys and values are not cloned.      * This is a relatively expensive operation.      *      * @return a clone of the hashtable.      */
annotation|@
name|Override
DECL|method|clone
specifier|public
name|Object
name|clone
parameter_list|()
block|{
try|try
block|{
comment|// Must clone, to get the class right; NBHM might have been
comment|// extended so it would be wrong to just make a new NBHM.
name|NonBlockingHashtable
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
name|t
init|=
operator|(
name|NonBlockingHashtable
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
operator|)
name|super
operator|.
name|clone
argument_list|()
decl_stmt|;
comment|// But I don't have an atomic clone operation - the underlying _kvs
comment|// structure is undergoing rapid change.  If I just clone the _kvs
comment|// field, the CHM in _kvs[0] won't be in sync.
comment|//
comment|// Wipe out the cloned array (it was shallow anyways).
name|t
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Now copy sanely
for|for
control|(
name|TypeK
name|K
range|:
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|TypeV
name|V
init|=
name|get
argument_list|(
name|K
argument_list|)
decl_stmt|;
comment|// Do an official 'get'
name|t
operator|.
name|put
argument_list|(
name|K
argument_list|,
name|V
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
comment|// this shouldn't happen, since we are Cloneable
throw|throw
operator|new
name|InternalError
argument_list|()
throw|;
block|}
block|}
comment|/**      * Returns a string representation of this map.  The string representation      * consists of a list of key-value mappings in the order returned by the      * map's<tt>entrySet</tt> view's iterator, enclosed in braces      * (<tt>"{}"</tt>).  Adjacent mappings are separated by the characters      *<tt>", "</tt> (comma and space).  Each key-value mapping is rendered as      * the key followed by an equals sign (<tt>"="</tt>) followed by the      * associated value.  Keys and values are converted to strings as by      * {@link String#valueOf(Object)}.      *      * @return a string representation of this map      */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Iterator
argument_list|<
name|Entry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
argument_list|>
name|i
init|=
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|"{}"
return|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Entry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
name|e
init|=
name|i
operator|.
name|next
argument_list|()
decl_stmt|;
name|TypeK
name|key
init|=
name|e
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|TypeV
name|value
init|=
name|e
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|key
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|key
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|value
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|.
name|hasNext
argument_list|()
condition|)
return|return
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
name|sb
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
comment|// --- keyeq ---------------------------------------------------------------
comment|// Check for key equality.  Try direct pointer compare first, then see if
comment|// the hashes are unequal (fast negative test) and finally do the full-on
comment|// 'equals' v-call.
DECL|method|keyeq
specifier|private
specifier|static
name|boolean
name|keyeq
parameter_list|(
name|Object
name|K
parameter_list|,
name|Object
name|key
parameter_list|,
name|int
index|[]
name|hashes
parameter_list|,
name|int
name|hash
parameter_list|,
name|int
name|fullhash
parameter_list|)
block|{
return|return
name|K
operator|==
name|key
operator|||
comment|// Either keys match exactly OR
comment|// hash exists and matches?  hash can be zero during the install of a
comment|// new key/value pair.
operator|(
operator|(
name|hashes
index|[
name|hash
index|]
operator|==
literal|0
operator|||
name|hashes
index|[
name|hash
index|]
operator|==
name|fullhash
operator|)
operator|&&
comment|// Do not call the users' "equals()" call with a Tombstone, as this can
comment|// surprise poorly written "equals()" calls that throw exceptions
comment|// instead of simply returning false.
name|K
operator|!=
name|TOMBSTONE
operator|&&
comment|// Do not call users' equals call with a Tombstone
comment|// Do the match the hard way - with the users' key being the loop-
comment|// invariant "this" pointer.  I could have flipped the order of
comment|// operands (since equals is commutative), but I'm making mega-morphic
comment|// v-calls in a reprobing loop and nailing down the 'this' argument
comment|// gives both the JIT and the hardware a chance to prefetch the call target.
name|key
operator|.
name|equals
argument_list|(
name|K
argument_list|)
operator|)
return|;
comment|// Finally do the hard match
block|}
comment|// --- get -----------------------------------------------------------------
comment|/**      * Returns the value to which the specified key is mapped, or {@code null}      * if this map contains no mapping for the key.      *<p>More formally, if this map contains a mapping from a key {@code k} to      * a value {@code v} such that {@code key.equals(k)}, then this method      * returns {@code v}; otherwise it returns {@code null}.  (There can be at      * most one such mapping.)      *      * @throws NullPointerException if the specified key is null      */
comment|// Never returns a Prime nor a Tombstone.
annotation|@
name|Override
DECL|method|get
specifier|public
name|TypeV
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
specifier|final
name|int
name|fullhash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// throws NullPointerException if key is null
specifier|final
name|Object
name|V
init|=
name|get_impl
argument_list|(
name|this
argument_list|,
name|_kvs
argument_list|,
name|key
argument_list|,
name|fullhash
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|V
operator|instanceof
name|Prime
operator|)
assert|;
comment|// Never return a Prime
return|return
operator|(
name|TypeV
operator|)
name|V
return|;
block|}
DECL|method|get_impl
specifier|private
specifier|static
specifier|final
name|Object
name|get_impl
parameter_list|(
specifier|final
name|NonBlockingHashtable
name|topmap
parameter_list|,
specifier|final
name|Object
index|[]
name|kvs
parameter_list|,
specifier|final
name|Object
name|key
parameter_list|,
specifier|final
name|int
name|fullhash
parameter_list|)
block|{
specifier|final
name|int
name|len
init|=
name|len
argument_list|(
name|kvs
argument_list|)
decl_stmt|;
comment|// Count of key/value pairs, reads kvs.length
specifier|final
name|CHM
name|chm
init|=
name|chm
argument_list|(
name|kvs
argument_list|)
decl_stmt|;
comment|// The CHM, for a volatile read below; reads slot 0 of kvs
specifier|final
name|int
index|[]
name|hashes
init|=
name|hashes
argument_list|(
name|kvs
argument_list|)
decl_stmt|;
comment|// The memoized hashes; reads slot 1 of kvs
name|int
name|idx
init|=
name|fullhash
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
decl_stmt|;
comment|// First key hash
comment|// Main spin/reprobe loop, looking for a Key hit
name|int
name|reprobe_cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Probe table.  Each read of 'val' probably misses in cache in a big
comment|// table; hopefully the read of 'key' then hits in cache.
specifier|final
name|Object
name|K
init|=
name|key
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|// Get key   before volatile read, could be null
specifier|final
name|Object
name|V
init|=
name|val
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|// Get value before volatile read, could be null or Tombstone or Prime
if|if
condition|(
name|K
operator|==
literal|null
condition|)
return|return
literal|null
return|;
comment|// A clear miss
comment|// We need a volatile-read here to preserve happens-before semantics on
comment|// newly inserted Keys.  If the Key body was written just before inserting
comment|// into the table a Key-compare here might read the uninitalized Key body.
comment|// Annoyingly this means we have to volatile-read before EACH key compare.
comment|// .
comment|// We also need a volatile-read between reading a newly inserted Value
comment|// and returning the Value (so the user might end up reading the stale
comment|// Value contents).  Same problem as with keys - and the one volatile
comment|// read covers both.
specifier|final
name|Object
index|[]
name|newkvs
init|=
name|chm
operator|.
name|_newkvs
decl_stmt|;
comment|// VOLATILE READ before key compare
comment|// Key-compare
if|if
condition|(
name|keyeq
argument_list|(
name|K
argument_list|,
name|key
argument_list|,
name|hashes
argument_list|,
name|idx
argument_list|,
name|fullhash
argument_list|)
condition|)
block|{
comment|// Key hit!  Check for no table-copy-in-progress
if|if
condition|(
operator|!
operator|(
name|V
operator|instanceof
name|Prime
operator|)
condition|)
comment|// No copy?
return|return
operator|(
name|V
operator|==
name|TOMBSTONE
operator|)
condition|?
literal|null
else|:
name|V
return|;
comment|// Return the value
comment|// Key hit - but slot is (possibly partially) copied to the new table.
comment|// Finish the copy& retry in the new table.
return|return
name|get_impl
argument_list|(
name|topmap
argument_list|,
name|chm
operator|.
name|copy_slot_and_check
argument_list|(
name|topmap
argument_list|,
name|kvs
argument_list|,
name|idx
argument_list|,
name|key
argument_list|)
argument_list|,
name|key
argument_list|,
name|fullhash
argument_list|)
return|;
comment|// Retry in the new table
block|}
comment|// get and put must have the same key lookup logic!  But only 'put'
comment|// needs to force a table-resize for a too-long key-reprobe sequence.
comment|// Check for too-many-reprobes on get - and flip to the new table.
if|if
condition|(
operator|++
name|reprobe_cnt
operator|>=
name|reprobe_limit
argument_list|(
name|len
argument_list|)
operator|||
comment|// too many probes
name|key
operator|==
name|TOMBSTONE
condition|)
comment|// found a TOMBSTONE key, means no more keys in this table
return|return
name|newkvs
operator|==
literal|null
condition|?
literal|null
else|:
name|get_impl
argument_list|(
name|topmap
argument_list|,
name|topmap
operator|.
name|help_copy
argument_list|(
name|newkvs
argument_list|)
argument_list|,
name|key
argument_list|,
name|fullhash
argument_list|)
return|;
comment|// Retry in the new table
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
comment|// Reprobe by 1!  (could now prefetch)
block|}
block|}
comment|// --- putIfMatch ---------------------------------------------------------
comment|// Put, Remove, PutIfAbsent, etc.  Return the old value.  If the returned
comment|// value is equal to expVal (or expVal is NO_MATCH_OLD) then the put can be
comment|// assumed to work (although might have been immediately overwritten).  Only
comment|// the path through copy_slot passes in an expected value of null, and
comment|// putIfMatch only returns a null if passed in an expected null.
DECL|method|putIfMatch
specifier|private
specifier|static
specifier|final
name|Object
name|putIfMatch
parameter_list|(
specifier|final
name|NonBlockingHashtable
name|topmap
parameter_list|,
specifier|final
name|Object
index|[]
name|kvs
parameter_list|,
specifier|final
name|Object
name|key
parameter_list|,
specifier|final
name|Object
name|putval
parameter_list|,
specifier|final
name|Object
name|expVal
parameter_list|)
block|{
assert|assert
name|putval
operator|!=
literal|null
assert|;
assert|assert
operator|!
operator|(
name|putval
operator|instanceof
name|Prime
operator|)
assert|;
assert|assert
operator|!
operator|(
name|expVal
operator|instanceof
name|Prime
operator|)
assert|;
specifier|final
name|int
name|fullhash
init|=
name|hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
comment|// throws NullPointerException if key null
specifier|final
name|int
name|len
init|=
name|len
argument_list|(
name|kvs
argument_list|)
decl_stmt|;
comment|// Count of key/value pairs, reads kvs.length
specifier|final
name|CHM
name|chm
init|=
name|chm
argument_list|(
name|kvs
argument_list|)
decl_stmt|;
comment|// Reads kvs[0]
specifier|final
name|int
index|[]
name|hashes
init|=
name|hashes
argument_list|(
name|kvs
argument_list|)
decl_stmt|;
comment|// Reads kvs[1], read before kvs[0]
name|int
name|idx
init|=
name|fullhash
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
decl_stmt|;
comment|// ---
comment|// Key-Claim stanza: spin till we can claim a Key (or force a resizing).
name|int
name|reprobe_cnt
init|=
literal|0
decl_stmt|;
name|Object
name|K
init|=
literal|null
decl_stmt|,
name|V
init|=
literal|null
decl_stmt|;
name|Object
index|[]
name|newkvs
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Spin till we get a Key slot
name|V
operator|=
name|val
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|// Get old value (before volatile read below!)
name|K
operator|=
name|key
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|// Get current key
if|if
condition|(
name|K
operator|==
literal|null
condition|)
block|{
comment|// Slot is free?
comment|// Found an empty Key slot - which means this Key has never been in
comment|// this table.  No need to put a Tombstone - the Key is not here!
if|if
condition|(
name|putval
operator|==
name|TOMBSTONE
condition|)
return|return
name|putval
return|;
comment|// Not-now& never-been in this table
comment|// Claim the null key-slot
if|if
condition|(
name|CAS_key
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|// Claim slot for Key
name|chm
operator|.
name|_slots
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Raise key-slots-used count
name|hashes
index|[
name|idx
index|]
operator|=
name|fullhash
expr_stmt|;
comment|// Memoize fullhash
break|break;
comment|// Got it!
block|}
comment|// CAS to claim the key-slot failed.
comment|//
comment|// This re-read of the Key points out an annoying short-coming of Java
comment|// CAS.  Most hardware CAS's report back the existing value - so that
comment|// if you fail you have a *witness* - the value which caused the CAS
comment|// to fail.  The Java API turns this into a boolean destroying the
comment|// witness.  Re-reading does not recover the witness because another
comment|// thread can write over the memory after the CAS.  Hence we can be in
comment|// the unfortunate situation of having a CAS fail *for cause* but
comment|// having that cause removed by a later store.  This turns a
comment|// non-spurious-failure CAS (such as Azul has) into one that can
comment|// apparently spuriously fail - and we avoid apparent spurious failure
comment|// by not allowing Keys to ever change.
name|K
operator|=
name|key
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|// CAS failed, get updated value
assert|assert
name|K
operator|!=
literal|null
assert|;
comment|// If keys[idx] is null, CAS shoulda worked
block|}
comment|// Key slot was not null, there exists a Key here
comment|// We need a volatile-read here to preserve happens-before semantics on
comment|// newly inserted Keys.  If the Key body was written just before inserting
comment|// into the table a Key-compare here might read the uninitalized Key body.
comment|// Annoyingly this means we have to volatile-read before EACH key compare.
name|newkvs
operator|=
name|chm
operator|.
name|_newkvs
expr_stmt|;
comment|// VOLATILE READ before key compare
if|if
condition|(
name|keyeq
argument_list|(
name|K
argument_list|,
name|key
argument_list|,
name|hashes
argument_list|,
name|idx
argument_list|,
name|fullhash
argument_list|)
condition|)
break|break;
comment|// Got it!
comment|// get and put must have the same key lookup logic!  Lest 'get' give
comment|// up looking too soon.
comment|//topmap._reprobes.add(1);
if|if
condition|(
operator|++
name|reprobe_cnt
operator|>=
name|reprobe_limit
argument_list|(
name|len
argument_list|)
operator|||
comment|// too many probes or
name|key
operator|==
name|TOMBSTONE
condition|)
block|{
comment|// found a TOMBSTONE key, means no more keys
comment|// We simply must have a new table to do a 'put'.  At this point a
comment|// 'get' will also go to the new table (if any).  We do not need
comment|// to claim a key slot (indeed, we cannot find a free one to claim!).
name|newkvs
operator|=
name|chm
operator|.
name|resize
argument_list|(
name|topmap
argument_list|,
name|kvs
argument_list|)
expr_stmt|;
if|if
condition|(
name|expVal
operator|!=
literal|null
condition|)
name|topmap
operator|.
name|help_copy
argument_list|(
name|newkvs
argument_list|)
expr_stmt|;
comment|// help along an existing copy
return|return
name|putIfMatch
argument_list|(
name|topmap
argument_list|,
name|newkvs
argument_list|,
name|key
argument_list|,
name|putval
argument_list|,
name|expVal
argument_list|)
return|;
block|}
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
comment|// Reprobe!
block|}
comment|// End of spinning till we get a Key slot
comment|// ---
comment|// Found the proper Key slot, now update the matching Value slot.  We
comment|// never put a null, so Value slots monotonically move from null to
comment|// not-null (deleted Values use Tombstone).  Thus if 'V' is null we
comment|// fail this fast cutout and fall into the check for table-full.
if|if
condition|(
name|putval
operator|==
name|V
condition|)
return|return
name|V
return|;
comment|// Fast cutout for no-change
comment|// See if we want to move to a new table (to avoid high average re-probe
comment|// counts).  We only check on the initial set of a Value from null to
comment|// not-null (i.e., once per key-insert).  Of course we got a 'free' check
comment|// of newkvs once per key-compare (not really free, but paid-for by the
comment|// time we get here).
if|if
condition|(
name|newkvs
operator|==
literal|null
operator|&&
comment|// New table-copy already spotted?
comment|// Once per fresh key-insert check the hard way
operator|(
operator|(
name|V
operator|==
literal|null
operator|&&
name|chm
operator|.
name|tableFull
argument_list|(
name|reprobe_cnt
argument_list|,
name|len
argument_list|)
operator|)
operator|||
comment|// Or we found a Prime, but the JMM allowed reordering such that we
comment|// did not spot the new table (very rare race here: the writing
comment|// thread did a CAS of _newkvs then a store of a Prime.  This thread
comment|// reads the Prime, then reads _newkvs - but the read of Prime was so
comment|// delayed (or the read of _newkvs was so accelerated) that they
comment|// swapped and we still read a null _newkvs.  The resize call below
comment|// will do a CAS on _newkvs forcing the read.
name|V
operator|instanceof
name|Prime
operator|)
condition|)
name|newkvs
operator|=
name|chm
operator|.
name|resize
argument_list|(
name|topmap
argument_list|,
name|kvs
argument_list|)
expr_stmt|;
comment|// Force the new table copy to start
comment|// See if we are moving to a new table.
comment|// If so, copy our slot and retry in the new table.
if|if
condition|(
name|newkvs
operator|!=
literal|null
condition|)
return|return
name|putIfMatch
argument_list|(
name|topmap
argument_list|,
name|chm
operator|.
name|copy_slot_and_check
argument_list|(
name|topmap
argument_list|,
name|kvs
argument_list|,
name|idx
argument_list|,
name|expVal
argument_list|)
argument_list|,
name|key
argument_list|,
name|putval
argument_list|,
name|expVal
argument_list|)
return|;
comment|// ---
comment|// We are finally prepared to update the existing table
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
operator|!
operator|(
name|V
operator|instanceof
name|Prime
operator|)
assert|;
comment|// Must match old, and we do not?  Then bail out now.  Note that either V
comment|// or expVal might be TOMBSTONE.  Also V can be null, if we've never
comment|// inserted a value before.  expVal can be null if we are called from
comment|// copy_slot.
if|if
condition|(
name|expVal
operator|!=
name|NO_MATCH_OLD
operator|&&
comment|// Do we care about expected-Value at all?
name|V
operator|!=
name|expVal
operator|&&
comment|// No instant match already?
operator|(
name|expVal
operator|!=
name|MATCH_ANY
operator|||
name|V
operator|==
name|TOMBSTONE
operator|||
name|V
operator|==
literal|null
operator|)
operator|&&
operator|!
operator|(
name|V
operator|==
literal|null
operator|&&
name|expVal
operator|==
name|TOMBSTONE
operator|)
operator|&&
comment|// Match on null/TOMBSTONE combo
operator|(
name|expVal
operator|==
literal|null
operator|||
operator|!
name|expVal
operator|.
name|equals
argument_list|(
name|V
argument_list|)
operator|)
condition|)
comment|// Expensive equals check at the last
return|return
name|V
return|;
comment|// Do not update!
comment|// Actually change the Value in the Key,Value pair
if|if
condition|(
name|CAS_val
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|,
name|V
argument_list|,
name|putval
argument_list|)
condition|)
block|{
comment|// CAS succeeded - we did the update!
comment|// Both normal put's and table-copy calls putIfMatch, but table-copy
comment|// does not (effectively) increase the number of live k/v pairs.
if|if
condition|(
name|expVal
operator|!=
literal|null
condition|)
block|{
comment|// Adjust sizes - a striped counter
if|if
condition|(
operator|(
name|V
operator|==
literal|null
operator|||
name|V
operator|==
name|TOMBSTONE
operator|)
operator|&&
name|putval
operator|!=
name|TOMBSTONE
condition|)
name|chm
operator|.
name|_size
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|V
operator|==
literal|null
operator|||
name|V
operator|==
name|TOMBSTONE
operator|)
operator|&&
name|putval
operator|==
name|TOMBSTONE
condition|)
name|chm
operator|.
name|_size
operator|.
name|add
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|V
operator|==
literal|null
operator|&&
name|expVal
operator|!=
literal|null
operator|)
condition|?
name|TOMBSTONE
else|:
name|V
return|;
block|}
comment|// Else CAS failed
name|V
operator|=
name|val
argument_list|(
name|kvs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|// Get new value
comment|// If a Prime'd value got installed, we need to re-run the put on the
comment|// new table.  Otherwise we lost the CAS to another racing put.
comment|// Simply retry from the start.
if|if
condition|(
name|V
operator|instanceof
name|Prime
condition|)
return|return
name|putIfMatch
argument_list|(
name|topmap
argument_list|,
name|chm
operator|.
name|copy_slot_and_check
argument_list|(
name|topmap
argument_list|,
name|kvs
argument_list|,
name|idx
argument_list|,
name|expVal
argument_list|)
argument_list|,
name|key
argument_list|,
name|putval
argument_list|,
name|expVal
argument_list|)
return|;
block|}
block|}
comment|// --- help_copy ---------------------------------------------------------
comment|// Help along an existing resize operation.  This is just a fast cut-out
comment|// wrapper, to encourage inlining for the fast no-copy-in-progress case.  We
comment|// always help the top-most table copy, even if there are nested table
comment|// copies in progress.
DECL|method|help_copy
specifier|private
specifier|final
name|Object
index|[]
name|help_copy
parameter_list|(
name|Object
index|[]
name|helper
parameter_list|)
block|{
comment|// Read the top-level KVS only once.  We'll try to help this copy along,
comment|// even if it gets promoted out from under us (i.e., the copy completes
comment|// and another KVS becomes the top-level copy).
name|Object
index|[]
name|topkvs
init|=
name|_kvs
decl_stmt|;
name|CHM
name|topchm
init|=
name|chm
argument_list|(
name|topkvs
argument_list|)
decl_stmt|;
if|if
condition|(
name|topchm
operator|.
name|_newkvs
operator|==
literal|null
condition|)
return|return
name|helper
return|;
comment|// No copy in-progress
name|topchm
operator|.
name|help_copy_impl
argument_list|(
name|this
argument_list|,
name|topkvs
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|helper
return|;
block|}
comment|// --- CHM -----------------------------------------------------------------
comment|// The control structure for the NonBlockingHashtable
DECL|class|CHM
specifier|private
specifier|static
specifier|final
class|class
name|CHM
parameter_list|<
name|TypeK
parameter_list|,
name|TypeV
parameter_list|>
block|{
comment|// Size in active K,V pairs
DECL|field|_size
specifier|private
specifier|final
name|Counter
name|_size
decl_stmt|;
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|_size
operator|.
name|get
argument_list|()
return|;
block|}
comment|// ---
comment|// These next 2 fields are used in the resizing heuristics, to judge when
comment|// it is time to resize or copy the table.  Slots is a count of used-up
comment|// key slots, and when it nears a large fraction of the table we probably
comment|// end up reprobing too much.  Last-resize-milli is the time since the
comment|// last resize; if we are running back-to-back resizes without growing
comment|// (because there are only a few live keys but many slots full of dead
comment|// keys) then we need a larger table to cut down on the churn.
comment|// Count of used slots, to tell when table is full of dead unusable slots
DECL|field|_slots
specifier|private
specifier|final
name|Counter
name|_slots
decl_stmt|;
DECL|method|slots
specifier|public
name|int
name|slots
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|_slots
operator|.
name|get
argument_list|()
return|;
block|}
comment|// ---
comment|// New mappings, used during resizing.
comment|// The 'new KVs' array - created during a resize operation.  This
comment|// represents the new table being copied from the old one.  It's the
comment|// volatile variable that is read as we cross from one table to the next,
comment|// to get the required memory orderings.  It monotonically transits from
comment|// null to set (once).
DECL|field|_newkvs
specifier|volatile
name|Object
index|[]
name|_newkvs
decl_stmt|;
DECL|field|_newkvsUpdater
specifier|private
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|CHM
argument_list|,
name|Object
index|[]
argument_list|>
name|_newkvsUpdater
init|=
name|AtomicReferenceFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|,
literal|"_newkvs"
argument_list|)
decl_stmt|;
comment|// Set the _next field if we can.
DECL|method|CAS_newkvs
name|boolean
name|CAS_newkvs
parameter_list|(
name|Object
index|[]
name|newkvs
parameter_list|)
block|{
while|while
condition|(
name|_newkvs
operator|==
literal|null
condition|)
if|if
condition|(
name|_newkvsUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|newkvs
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|// Sometimes many threads race to create a new very large table.  Only 1
comment|// wins the race, but the losers all allocate a junk large table with
comment|// hefty allocation costs.  Attempt to control the overkill here by
comment|// throttling attempts to create a new table.  I cannot really block here
comment|// (lest I lose the non-blocking property) but late-arriving threads can
comment|// give the initial resizing thread a little time to allocate the initial
comment|// new table.  The Right Long Term Fix here is to use array-lets and
comment|// incrementally create the new very large array.  In C I'd make the array
comment|// with malloc (which would mmap under the hood) which would only eat
comment|// virtual-address and not real memory - and after Somebody wins then we
comment|// could in parallel initialize the array.  Java does not allow
comment|// un-initialized array creation (especially of ref arrays!).
DECL|field|_resizers
specifier|volatile
name|long
name|_resizers
decl_stmt|;
comment|// count of threads attempting an initial resize
DECL|field|_resizerUpdater
specifier|private
specifier|static
specifier|final
name|AtomicLongFieldUpdater
argument_list|<
name|CHM
argument_list|>
name|_resizerUpdater
init|=
name|AtomicLongFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
literal|"_resizers"
argument_list|)
decl_stmt|;
comment|// ---
comment|// Simple constructor
DECL|method|CHM
name|CHM
parameter_list|(
name|Counter
name|size
parameter_list|)
block|{
name|_size
operator|=
name|size
expr_stmt|;
name|_slots
operator|=
operator|new
name|Counter
argument_list|()
expr_stmt|;
block|}
comment|// --- tableFull ---------------------------------------------------------
comment|// Heuristic to decide if this table is too full, and we should start a
comment|// new table.  Note that if a 'get' call has reprobed too many times and
comment|// decided the table must be full, then always the estimate_sum must be
comment|// high and we must report the table is full.  If we do not, then we might
comment|// end up deciding that the table is not full and inserting into the
comment|// current table, while a 'get' has decided the same key cannot be in this
comment|// table because of too many reprobes.  The invariant is:
comment|//   slots.estimate_sum>= max_reprobe_cnt>= reprobe_limit(len)
DECL|method|tableFull
specifier|private
specifier|final
name|boolean
name|tableFull
parameter_list|(
name|int
name|reprobe_cnt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
comment|// Do the cheap check first: we allow some number of reprobes always
name|reprobe_cnt
operator|>=
name|REPROBE_LIMIT
operator|&&
comment|// More expensive check: see if the table is> 1/4 full.
name|_slots
operator|.
name|estimate_get
argument_list|()
operator|>=
name|reprobe_limit
argument_list|(
name|len
argument_list|)
return|;
block|}
comment|// --- resize ------------------------------------------------------------
comment|// Resizing after too many probes.  "How Big???" heuristics are here.
comment|// Callers will (not this routine) will 'help_copy' any in-progress copy.
comment|// Since this routine has a fast cutout for copy-already-started, callers
comment|// MUST 'help_copy' lest we have a path which forever runs through
comment|// 'resize' only to discover a copy-in-progress which never progresses.
DECL|method|resize
specifier|private
specifier|final
name|Object
index|[]
name|resize
parameter_list|(
name|NonBlockingHashtable
name|topmap
parameter_list|,
name|Object
index|[]
name|kvs
parameter_list|)
block|{
assert|assert
name|chm
argument_list|(
name|kvs
argument_list|)
operator|==
name|this
assert|;
comment|// Check for resize already in progress, probably triggered by another thread
name|Object
index|[]
name|newkvs
init|=
name|_newkvs
decl_stmt|;
comment|// VOLATILE READ
if|if
condition|(
name|newkvs
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|newkvs
return|;
comment|// Use the new table already
comment|// No copy in-progress, so start one.  First up: compute new table size.
name|int
name|oldlen
init|=
name|len
argument_list|(
name|kvs
argument_list|)
decl_stmt|;
comment|// Old count of K,V pairs allowed
name|int
name|sz
init|=
name|size
argument_list|()
decl_stmt|;
comment|// Get current table count of active K,V pairs
name|int
name|newsz
init|=
name|sz
decl_stmt|;
comment|// First size estimate
comment|// Heuristic to determine new size.  We expect plenty of dead-slots-with-keys
comment|// and we need some decent padding to avoid endless reprobing.
if|if
condition|(
name|sz
operator|>=
operator|(
name|oldlen
operator|>>
literal|2
operator|)
condition|)
block|{
comment|// If we are>25% full of keys then...
name|newsz
operator|=
name|oldlen
operator|<<
literal|1
expr_stmt|;
comment|// Double size
if|if
condition|(
name|sz
operator|>=
operator|(
name|oldlen
operator|>>
literal|1
operator|)
condition|)
comment|// If we are>50% full of keys then...
name|newsz
operator|=
name|oldlen
operator|<<
literal|2
expr_stmt|;
comment|// Double double size
block|}
comment|// This heuristic in the next 2 lines leads to a much denser table
comment|// with a higher reprobe rate
comment|//if( sz>= (oldlen>>1) ) // If we are>50% full of keys then...
comment|//  newsz = oldlen<<1;    // Double size
comment|// Last (re)size operation was very recent?  Then double again; slows
comment|// down resize operations for tables subject to a high key churn rate.
name|long
name|tm
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|q
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|newsz
operator|<=
name|oldlen
operator|&&
comment|// New table would shrink or hold steady?
name|tm
operator|<=
name|topmap
operator|.
name|_last_resize_milli
operator|+
literal|10000
operator|&&
comment|// Recent resize (less than 1 sec ago)
operator|(
name|q
operator|=
name|_slots
operator|.
name|estimate_get
argument_list|()
operator|)
operator|>=
operator|(
name|sz
operator|<<
literal|1
operator|)
condition|)
comment|// 1/2 of keys are dead?
name|newsz
operator|=
name|oldlen
operator|<<
literal|1
expr_stmt|;
comment|// Double the existing size
comment|// Do not shrink, ever
if|if
condition|(
name|newsz
operator|<
name|oldlen
condition|)
name|newsz
operator|=
name|oldlen
expr_stmt|;
comment|// Convert to power-of-2
name|int
name|log2
decl_stmt|;
for|for
control|(
name|log2
operator|=
name|MIN_SIZE_LOG
init|;
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|<
name|newsz
condition|;
name|log2
operator|++
control|)
empty_stmt|;
comment|// Compute log2 of size
comment|// Now limit the number of threads actually allocating memory to a
comment|// handful - lest we have 750 threads all trying to allocate a giant
comment|// resized array.
name|long
name|r
init|=
name|_resizers
decl_stmt|;
while|while
condition|(
operator|!
name|_resizerUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|r
argument_list|,
name|r
operator|+
literal|1
argument_list|)
condition|)
name|r
operator|=
name|_resizers
expr_stmt|;
comment|// Size calculation: 2 words (K+V) per table entry, plus a handful.  We
comment|// guess at 32-bit pointers; 64-bit pointers screws up the size calc by
comment|// 2x but does not screw up the heuristic very much.
name|int
name|megs
init|=
operator|(
operator|(
operator|(
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|4
operator|)
operator|<<
literal|3
comment|/*word to bytes*/
operator|)
operator|>>
literal|20
comment|/*megs*/
decl_stmt|;
if|if
condition|(
name|r
operator|>=
literal|2
operator|&&
name|megs
operator|>
literal|0
condition|)
block|{
comment|// Already 2 guys trying; wait and see
name|newkvs
operator|=
name|_newkvs
expr_stmt|;
comment|// Between dorking around, another thread did it
if|if
condition|(
name|newkvs
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|newkvs
return|;
comment|// Use the new table already
comment|// TODO - use a wait with timeout, so we'll wakeup as soon as the new table
comment|// is ready, or after the timeout in any case.
comment|//synchronized( this ) { wait(8*megs); }         // Timeout - we always wakeup
comment|// For now, sleep a tad and see if the 2 guys already trying to make
comment|// the table actually get around to making it happen.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|8
operator|*
name|megs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{                 }
block|}
comment|// Last check, since the 'new' below is expensive and there is a chance
comment|// that another thread slipped in a new thread while we ran the heuristic.
name|newkvs
operator|=
name|_newkvs
expr_stmt|;
if|if
condition|(
name|newkvs
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|newkvs
return|;
comment|// Use the new table already
comment|// Double size for K,V pairs, add 1 for CHM
name|newkvs
operator|=
operator|new
name|Object
index|[
operator|(
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|2
index|]
expr_stmt|;
comment|// This can get expensive for big arrays
name|newkvs
index|[
literal|0
index|]
operator|=
operator|new
name|CHM
argument_list|(
name|_size
argument_list|)
expr_stmt|;
comment|// CHM in slot 0
name|newkvs
index|[
literal|1
index|]
operator|=
operator|new
name|int
index|[
literal|1
operator|<<
name|log2
index|]
expr_stmt|;
comment|// hashes in slot 1
comment|// Another check after the slow allocation
if|if
condition|(
name|_newkvs
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|_newkvs
return|;
comment|// Use the new table already
comment|// The new table must be CAS'd in so only 1 winner amongst duplicate
comment|// racing resizing threads.  Extra CHM's will be GC'd.
if|if
condition|(
name|CAS_newkvs
argument_list|(
name|newkvs
argument_list|)
condition|)
block|{
comment|// NOW a resize-is-in-progress!
comment|//notifyAll();            // Wake up any sleepers
comment|//long nano = System.nanoTime();
comment|//System.out.println(" "+nano+" Resize from "+oldlen+" to "+(1<<log2)+" and had "+(_resizers-1)+" extras" );
comment|//if( System.out != null ) System.out.print("["+log2);
name|topmap
operator|.
name|rehash
argument_list|()
expr_stmt|;
comment|// Call for Hashtable's benefit
block|}
else|else
comment|// CAS failed?
name|newkvs
operator|=
name|_newkvs
expr_stmt|;
comment|// Reread new table
return|return
name|newkvs
return|;
block|}
comment|// The next part of the table to copy.  It monotonically transits from zero
comment|// to _kvs.length.  Visitors to the table can claim 'work chunks' by
comment|// CAS'ing this field up, then copying the indicated indices from the old
comment|// table to the new table.  Workers are not required to finish any chunk;
comment|// the counter simply wraps and work is copied duplicately until somebody
comment|// somewhere completes the count.
DECL|field|_copyIdx
specifier|volatile
name|long
name|_copyIdx
init|=
literal|0
decl_stmt|;
DECL|field|_copyIdxUpdater
specifier|static
specifier|private
specifier|final
name|AtomicLongFieldUpdater
argument_list|<
name|CHM
argument_list|>
name|_copyIdxUpdater
init|=
name|AtomicLongFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
literal|"_copyIdx"
argument_list|)
decl_stmt|;
comment|// Work-done reporting.  Used to efficiently signal when we can move to
comment|// the new table.  From 0 to len(oldkvs) refers to copying from the old
comment|// table to the new.
DECL|field|_copyDone
specifier|volatile
name|long
name|_copyDone
init|=
literal|0
decl_stmt|;
DECL|field|_copyDoneUpdater
specifier|static
specifier|private
specifier|final
name|AtomicLongFieldUpdater
argument_list|<
name|CHM
argument_list|>
name|_copyDoneUpdater
init|=
name|AtomicLongFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
literal|"_copyDone"
argument_list|)
decl_stmt|;
comment|// --- help_copy_impl ----------------------------------------------------
comment|// Help along an existing resize operation.  We hope its the top-level
comment|// copy (it was when we started) but this CHM might have been promoted out
comment|// of the top position.
DECL|method|help_copy_impl
specifier|private
specifier|final
name|void
name|help_copy_impl
parameter_list|(
name|NonBlockingHashtable
name|topmap
parameter_list|,
name|Object
index|[]
name|oldkvs
parameter_list|,
name|boolean
name|copy_all
parameter_list|)
block|{
assert|assert
name|chm
argument_list|(
name|oldkvs
argument_list|)
operator|==
name|this
assert|;
name|Object
index|[]
name|newkvs
init|=
name|_newkvs
decl_stmt|;
assert|assert
name|newkvs
operator|!=
literal|null
assert|;
comment|// Already checked by caller
name|int
name|oldlen
init|=
name|len
argument_list|(
name|oldkvs
argument_list|)
decl_stmt|;
comment|// Total amount to copy
specifier|final
name|int
name|MIN_COPY_WORK
init|=
name|Math
operator|.
name|min
argument_list|(
name|oldlen
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
comment|// Limit per-thread work
comment|// ---
name|int
name|panic_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|copyidx
init|=
operator|-
literal|9999
decl_stmt|;
comment|// Fool javac to think it's initialized
while|while
condition|(
name|_copyDone
operator|<
name|oldlen
condition|)
block|{
comment|// Still needing to copy?
comment|// Carve out a chunk of work.  The counter wraps around so every
comment|// thread eventually tries to copy every slot repeatedly.
comment|// We "panic" if we have tried TWICE to copy every slot - and it still
comment|// has not happened.  i.e., twice some thread somewhere claimed they
comment|// would copy 'slot X' (by bumping _copyIdx) but they never claimed to
comment|// have finished (by bumping _copyDone).  Our choices become limited:
comment|// we can wait for the work-claimers to finish (and become a blocking
comment|// algorithm) or do the copy work ourselves.  Tiny tables with huge
comment|// thread counts trying to copy the table often 'panic'.
if|if
condition|(
name|panic_start
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No panic?
name|copyidx
operator|=
operator|(
name|int
operator|)
name|_copyIdx
expr_stmt|;
while|while
condition|(
name|copyidx
operator|<
operator|(
name|oldlen
operator|<<
literal|1
operator|)
operator|&&
comment|// 'panic' check
operator|!
name|_copyIdxUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|copyidx
argument_list|,
name|copyidx
operator|+
name|MIN_COPY_WORK
argument_list|)
condition|)
name|copyidx
operator|=
operator|(
name|int
operator|)
name|_copyIdx
expr_stmt|;
comment|// Re-read
if|if
condition|(
operator|!
operator|(
name|copyidx
operator|<
operator|(
name|oldlen
operator|<<
literal|1
operator|)
operator|)
condition|)
comment|// Panic!
name|panic_start
operator|=
name|copyidx
expr_stmt|;
comment|// Record where we started to panic-copy
block|}
comment|// We now know what to copy.  Try to copy.
name|int
name|workdone
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MIN_COPY_WORK
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|copy_slot
argument_list|(
name|topmap
argument_list|,
operator|(
name|copyidx
operator|+
name|i
operator|)
operator|&
operator|(
name|oldlen
operator|-
literal|1
operator|)
argument_list|,
name|oldkvs
argument_list|,
name|newkvs
argument_list|)
condition|)
comment|// Made an oldtable slot go dead?
name|workdone
operator|++
expr_stmt|;
comment|// Yes!
if|if
condition|(
name|workdone
operator|>
literal|0
condition|)
comment|// Report work-done occasionally
name|copy_check_and_promote
argument_list|(
name|topmap
argument_list|,
name|oldkvs
argument_list|,
name|workdone
argument_list|)
expr_stmt|;
comment|// See if we can promote
comment|//for( int i=0; i<MIN_COPY_WORK; i++ )
comment|//  if( copy_slot(topmap,(copyidx+i)&(oldlen-1),oldkvs,newkvs) ) // Made an oldtable slot go dead?
comment|//    copy_check_and_promote( topmap, oldkvs, 1 );// See if we can promote
name|copyidx
operator|+=
name|MIN_COPY_WORK
expr_stmt|;
comment|// Uncomment these next 2 lines to turn on incremental table-copy.
comment|// Otherwise this thread continues to copy until it is all done.
if|if
condition|(
operator|!
name|copy_all
operator|&&
name|panic_start
operator|==
operator|-
literal|1
condition|)
comment|// No panic?
return|return;
comment|// Then done copying after doing MIN_COPY_WORK
block|}
comment|// Extra promotion check, in case another thread finished all copying
comment|// then got stalled before promoting.
name|copy_check_and_promote
argument_list|(
name|topmap
argument_list|,
name|oldkvs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// See if we can promote
block|}
comment|// --- copy_slot_and_check -----------------------------------------------
comment|// Copy slot 'idx' from the old table to the new table.  If this thread
comment|// confirmed the copy, update the counters and check for promotion.
comment|//
comment|// Returns the result of reading the volatile _newkvs, mostly as a
comment|// convenience to callers.  We come here with 1-shot copy requests
comment|// typically because the caller has found a Prime, and has not yet read
comment|// the _newkvs volatile - which must have changed from null-to-not-null
comment|// before any Prime appears.  So the caller needs to read the _newkvs
comment|// field to retry his operation in the new table, but probably has not
comment|// read it yet.
DECL|method|copy_slot_and_check
specifier|private
specifier|final
name|Object
index|[]
name|copy_slot_and_check
parameter_list|(
name|NonBlockingHashtable
name|topmap
parameter_list|,
name|Object
index|[]
name|oldkvs
parameter_list|,
name|int
name|idx
parameter_list|,
name|Object
name|should_help
parameter_list|)
block|{
assert|assert
name|chm
argument_list|(
name|oldkvs
argument_list|)
operator|==
name|this
assert|;
name|Object
index|[]
name|newkvs
init|=
name|_newkvs
decl_stmt|;
comment|// VOLATILE READ
comment|// We're only here because the caller saw a Prime, which implies a
comment|// table-copy is in progress.
assert|assert
name|newkvs
operator|!=
literal|null
assert|;
if|if
condition|(
name|copy_slot
argument_list|(
name|topmap
argument_list|,
name|idx
argument_list|,
name|oldkvs
argument_list|,
name|_newkvs
argument_list|)
condition|)
comment|// Copy the desired slot
name|copy_check_and_promote
argument_list|(
name|topmap
argument_list|,
name|oldkvs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Record the slot copied
comment|// Generically help along any copy (except if called recursively from a helper)
return|return
operator|(
name|should_help
operator|==
literal|null
operator|)
condition|?
name|newkvs
else|:
name|topmap
operator|.
name|help_copy
argument_list|(
name|newkvs
argument_list|)
return|;
block|}
comment|// --- copy_check_and_promote --------------------------------------------
DECL|method|copy_check_and_promote
specifier|private
specifier|final
name|void
name|copy_check_and_promote
parameter_list|(
name|NonBlockingHashtable
name|topmap
parameter_list|,
name|Object
index|[]
name|oldkvs
parameter_list|,
name|int
name|workdone
parameter_list|)
block|{
assert|assert
name|chm
argument_list|(
name|oldkvs
argument_list|)
operator|==
name|this
assert|;
name|int
name|oldlen
init|=
name|len
argument_list|(
name|oldkvs
argument_list|)
decl_stmt|;
comment|// We made a slot unusable and so did some of the needed copy work
name|long
name|copyDone
init|=
name|_copyDone
decl_stmt|;
assert|assert
operator|(
name|copyDone
operator|+
name|workdone
operator|)
operator|<=
name|oldlen
assert|;
if|if
condition|(
name|workdone
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|!
name|_copyDoneUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|copyDone
argument_list|,
name|copyDone
operator|+
name|workdone
argument_list|)
condition|)
block|{
name|copyDone
operator|=
name|_copyDone
expr_stmt|;
comment|// Reload, retry
assert|assert
operator|(
name|copyDone
operator|+
name|workdone
operator|)
operator|<=
name|oldlen
assert|;
block|}
comment|//if( (10*copyDone/oldlen) != (10*(copyDone+workdone)/oldlen) )
comment|//System.out.print(" "+(copyDone+workdone)*100/oldlen+"%"+"_"+(_copyIdx*100/oldlen)+"%");
block|}
comment|// Check for copy being ALL done, and promote.  Note that we might have
comment|// nested in-progress copies and manage to finish a nested copy before
comment|// finishing the top-level copy.  We only promote top-level copies.
if|if
condition|(
name|copyDone
operator|+
name|workdone
operator|==
name|oldlen
operator|&&
comment|// Ready to promote this table?
name|topmap
operator|.
name|_kvs
operator|==
name|oldkvs
operator|&&
comment|// Looking at the top-level table?
comment|// Attempt to promote
name|topmap
operator|.
name|CAS_kvs
argument_list|(
name|oldkvs
argument_list|,
name|_newkvs
argument_list|)
condition|)
block|{
name|topmap
operator|.
name|_last_resize_milli
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// Record resize time for next check
comment|//long nano = System.nanoTime();
comment|//System.out.println(" "+nano+" Promote table to "+len(_newkvs));
comment|//if( System.out != null ) System.out.print("]");
block|}
block|}
comment|// --- copy_slot ---------------------------------------------------------
comment|// Copy one K/V pair from oldkvs[i] to newkvs.  Returns true if we can
comment|// confirm that the new table guaranteed has a value for this old-table
comment|// slot.  We need an accurate confirmed-copy count so that we know when we
comment|// can promote (if we promote the new table too soon, other threads may
comment|// 'miss' on values not-yet-copied from the old table).  We don't allow
comment|// any direct updates on the new table, unless they first happened to the
comment|// old table - so that any transition in the new table from null to
comment|// not-null must have been from a copy_slot (or other old-table overwrite)
comment|// and not from a thread directly writing in the new table.  Thus we can
comment|// count null-to-not-null transitions in the new table.
DECL|method|copy_slot
specifier|private
name|boolean
name|copy_slot
parameter_list|(
name|NonBlockingHashtable
name|topmap
parameter_list|,
name|int
name|idx
parameter_list|,
name|Object
index|[]
name|oldkvs
parameter_list|,
name|Object
index|[]
name|newkvs
parameter_list|)
block|{
comment|// Blindly set the key slot from null to TOMBSTONE, to eagerly stop
comment|// fresh put's from inserting new values in the old table when the old
comment|// table is mid-resize.  We don't need to act on the results here,
comment|// because our correctness stems from box'ing the Value field.  Slamming
comment|// the Key field is a minor speed optimization.
name|Object
name|key
decl_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|key
argument_list|(
name|oldkvs
argument_list|,
name|idx
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|CAS_key
argument_list|(
name|oldkvs
argument_list|,
name|idx
argument_list|,
literal|null
argument_list|,
name|TOMBSTONE
argument_list|)
expr_stmt|;
comment|// ---
comment|// Prevent new values from appearing in the old table.
comment|// Box what we see in the old table, to prevent further updates.
name|Object
name|oldval
init|=
name|val
argument_list|(
name|oldkvs
argument_list|,
name|idx
argument_list|)
decl_stmt|;
comment|// Read OLD table
while|while
condition|(
operator|!
operator|(
name|oldval
operator|instanceof
name|Prime
operator|)
condition|)
block|{
specifier|final
name|Prime
name|box
init|=
operator|(
name|oldval
operator|==
literal|null
operator|||
name|oldval
operator|==
name|TOMBSTONE
operator|)
condition|?
name|TOMBPRIME
else|:
operator|new
name|Prime
argument_list|(
name|oldval
argument_list|)
decl_stmt|;
if|if
condition|(
name|CAS_val
argument_list|(
name|oldkvs
argument_list|,
name|idx
argument_list|,
name|oldval
argument_list|,
name|box
argument_list|)
condition|)
block|{
comment|// CAS down a box'd version of oldval
comment|// If we made the Value slot hold a TOMBPRIME, then we both
comment|// prevented further updates here but also the (absent)
comment|// oldval is vaccuously available in the new table.  We
comment|// return with true here: any thread looking for a value for
comment|// this key can correctly go straight to the new table and
comment|// skip looking in the old table.
if|if
condition|(
name|box
operator|==
name|TOMBPRIME
condition|)
return|return
literal|true
return|;
comment|// Otherwise we boxed something, but it still needs to be
comment|// copied into the new table.
name|oldval
operator|=
name|box
expr_stmt|;
comment|// Record updated oldval
break|break;
comment|// Break loop; oldval is now boxed by us
block|}
name|oldval
operator|=
name|val
argument_list|(
name|oldkvs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|// Else try, try again
block|}
if|if
condition|(
name|oldval
operator|==
name|TOMBPRIME
condition|)
return|return
literal|false
return|;
comment|// Copy already complete here!
comment|// ---
comment|// Copy the value into the new table, but only if we overwrite a null.
comment|// If another value is already in the new table, then somebody else
comment|// wrote something there and that write is happens-after any value that
comment|// appears in the old table.  If putIfMatch does not find a null in the
comment|// new table - somebody else should have recorded the null-not_null
comment|// transition in this copy.
name|Object
name|old_unboxed
init|=
operator|(
operator|(
name|Prime
operator|)
name|oldval
operator|)
operator|.
name|_V
decl_stmt|;
assert|assert
name|old_unboxed
operator|!=
name|TOMBSTONE
assert|;
name|boolean
name|copied_into_new
init|=
operator|(
name|putIfMatch
argument_list|(
name|topmap
argument_list|,
name|newkvs
argument_list|,
name|key
argument_list|,
name|old_unboxed
argument_list|,
literal|null
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
comment|// ---
comment|// Finally, now that any old value is exposed in the new table, we can
comment|// forever hide the old-table value by slapping a TOMBPRIME down.  This
comment|// will stop other threads from uselessly attempting to copy this slot
comment|// (i.e., it's a speed optimization not a correctness issue).
while|while
condition|(
operator|!
name|CAS_val
argument_list|(
name|oldkvs
argument_list|,
name|idx
argument_list|,
name|oldval
argument_list|,
name|TOMBPRIME
argument_list|)
condition|)
name|oldval
operator|=
name|val
argument_list|(
name|oldkvs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|copied_into_new
return|;
block|}
comment|// end copy_slot
block|}
comment|// End of CHM
comment|// --- Snapshot ------------------------------------------------------------
comment|// The main class for iterating over the NBHM.  It "snapshots" a clean
comment|// view of the K/V array.
DECL|class|SnapshotV
specifier|private
class|class
name|SnapshotV
implements|implements
name|Iterator
argument_list|<
name|TypeV
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|TypeV
argument_list|>
block|{
DECL|field|_sskvs
specifier|final
name|Object
index|[]
name|_sskvs
decl_stmt|;
DECL|method|SnapshotV
specifier|public
name|SnapshotV
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
comment|// Verify no table-copy-in-progress
name|Object
index|[]
name|topkvs
init|=
name|_kvs
decl_stmt|;
name|CHM
name|topchm
init|=
name|chm
argument_list|(
name|topkvs
argument_list|)
decl_stmt|;
if|if
condition|(
name|topchm
operator|.
name|_newkvs
operator|==
literal|null
condition|)
block|{
comment|// No table-copy-in-progress
comment|// The "linearization point" for the iteration.  Every key in this
comment|// table will be visited, but keys added later might be skipped or
comment|// even be added to a following table (also not iterated over).
name|_sskvs
operator|=
name|topkvs
expr_stmt|;
break|break;
block|}
comment|// Table copy in-progress - so we cannot get a clean iteration.  We
comment|// must help finish the table copy before we can start iterating.
name|topchm
operator|.
name|help_copy_impl
argument_list|(
name|NonBlockingHashtable
operator|.
name|this
argument_list|,
name|topkvs
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Warm-up the iterator
name|next
argument_list|()
expr_stmt|;
block|}
DECL|method|length
name|int
name|length
parameter_list|()
block|{
return|return
name|len
argument_list|(
name|_sskvs
argument_list|)
return|;
block|}
DECL|method|key
name|Object
name|key
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
return|return
name|NonBlockingHashtable
operator|.
name|key
argument_list|(
name|_sskvs
argument_list|,
name|idx
argument_list|)
return|;
block|}
DECL|field|_idx
specifier|private
name|int
name|_idx
decl_stmt|;
comment|// Varies from 0-keys.length
DECL|field|_nextK
DECL|field|_prevK
specifier|private
name|Object
name|_nextK
decl_stmt|,
name|_prevK
decl_stmt|;
comment|// Last 2 keys found
DECL|field|_nextV
DECL|field|_prevV
specifier|private
name|TypeV
name|_nextV
decl_stmt|,
name|_prevV
decl_stmt|;
comment|// Last 2 values found
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_nextV
operator|!=
literal|null
return|;
block|}
DECL|method|next
specifier|public
name|TypeV
name|next
parameter_list|()
block|{
comment|// 'next' actually knows what the next value will be - it had to
comment|// figure that out last go-around lest 'hasNext' report true and
comment|// some other thread deleted the last value.  Instead, 'next'
comment|// spends all its effort finding the key that comes after the
comment|// 'next' key.
if|if
condition|(
name|_idx
operator|!=
literal|0
operator|&&
name|_nextV
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|_prevK
operator|=
name|_nextK
expr_stmt|;
comment|// This will become the previous key
name|_prevV
operator|=
name|_nextV
expr_stmt|;
comment|// This will become the previous value
name|_nextV
operator|=
literal|null
expr_stmt|;
comment|// We have no more next-key
comment|// Attempt to set<_nextK,_nextV> to the next K,V pair.
comment|// _nextV is the trigger: stop searching when it is != null
while|while
condition|(
name|_idx
operator|<
name|length
argument_list|()
condition|)
block|{
comment|// Scan array
name|_nextK
operator|=
name|key
argument_list|(
name|_idx
operator|++
argument_list|)
expr_stmt|;
comment|// Get a key that definitely is in the set (for the moment!)
if|if
condition|(
name|_nextK
operator|!=
literal|null
operator|&&
comment|// Found something?
name|_nextK
operator|!=
name|TOMBSTONE
operator|&&
operator|(
name|_nextV
operator|=
name|get
argument_list|(
name|_nextK
argument_list|)
operator|)
operator|!=
literal|null
condition|)
break|break;
comment|// Got it!  _nextK is a valid Key
block|}
comment|// Else keep scanning
return|return
name|_prevV
return|;
comment|// Return current value.
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|_prevV
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|putIfMatch
argument_list|(
name|NonBlockingHashtable
operator|.
name|this
argument_list|,
name|_sskvs
argument_list|,
name|_prevK
argument_list|,
name|TOMBSTONE
argument_list|,
name|_prevV
argument_list|)
expr_stmt|;
name|_prevV
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|nextElement
specifier|public
name|TypeV
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
DECL|method|hasMoreElements
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns an enumeration of the values in this table.      *      * @return an enumeration of the values in this table      * @see #values()      */
DECL|method|elements
specifier|public
name|Enumeration
argument_list|<
name|TypeV
argument_list|>
name|elements
parameter_list|()
block|{
return|return
operator|new
name|SnapshotV
argument_list|()
return|;
block|}
comment|// --- values --------------------------------------------------------------
comment|/**      * Returns a {@link Collection} view of the values contained in this map.      * The collection is backed by the map, so changes to the map are reflected      * in the collection, and vice-versa.  The collection supports element      * removal, which removes the corresponding mapping from this map, via the      *<tt>Iterator.remove</tt>,<tt>Collection.remove</tt>,      *<tt>removeAll</tt>,<tt>retainAll</tt>, and<tt>clear</tt> operations.      * It does not support the<tt>add</tt> or<tt>addAll</tt> operations.      *<p/>      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException}, and guarantees      * to traverse elements as they existed upon construction of the iterator,      * and may (but is not guaranteed to) reflect any modifications subsequent      * to construction.      */
annotation|@
name|Override
DECL|method|values
specifier|public
name|Collection
argument_list|<
name|TypeV
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|AbstractCollection
argument_list|<
name|TypeV
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|v
parameter_list|)
block|{
return|return
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|v
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|TypeV
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|SnapshotV
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|// --- keySet --------------------------------------------------------------
DECL|class|SnapshotK
specifier|private
class|class
name|SnapshotK
implements|implements
name|Iterator
argument_list|<
name|TypeK
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|TypeK
argument_list|>
block|{
DECL|field|_ss
specifier|final
name|SnapshotV
name|_ss
decl_stmt|;
DECL|method|SnapshotK
specifier|public
name|SnapshotK
parameter_list|()
block|{
name|_ss
operator|=
operator|new
name|SnapshotV
argument_list|()
expr_stmt|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|_ss
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|TypeK
name|next
parameter_list|()
block|{
name|_ss
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
operator|(
name|TypeK
operator|)
name|_ss
operator|.
name|_prevK
return|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_ss
operator|.
name|hasNext
argument_list|()
return|;
block|}
DECL|method|nextElement
specifier|public
name|TypeK
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
DECL|method|hasMoreElements
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns an enumeration of the keys in this table.      *      * @return an enumeration of the keys in this table      * @see #keySet()      */
DECL|method|keys
specifier|public
name|Enumeration
argument_list|<
name|TypeK
argument_list|>
name|keys
parameter_list|()
block|{
return|return
operator|new
name|SnapshotK
argument_list|()
return|;
block|}
comment|/**      * Returns a {@link Set} view of the keys contained in this map.  The set      * is backed by the map, so changes to the map are reflected in the set,      * and vice-versa.  The set supports element removal, which removes the      * corresponding mapping from this map, via the<tt>Iterator.remove</tt>,      *<tt>Set.remove</tt>,<tt>removeAll</tt>,<tt>retainAll</tt>, and      *<tt>clear</tt> operations.  It does not support the<tt>add</tt> or      *<tt>addAll</tt> operations.      *<p/>      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException}, and guarantees      * to traverse elements as they existed upon construction of the iterator,      * and may (but is not guaranteed to) reflect any modifications subsequent      * to construction.      */
annotation|@
name|Override
DECL|method|keySet
specifier|public
name|Set
argument_list|<
name|TypeK
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|TypeK
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
return|return
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|k
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
return|return
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|remove
argument_list|(
name|k
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|TypeK
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|SnapshotK
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|// --- entrySet ------------------------------------------------------------
comment|// Warning: Each call to 'next' in this iterator constructs a new NBHMEntry.
DECL|class|NBHMEntry
specifier|private
class|class
name|NBHMEntry
extends|extends
name|AbstractEntry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
block|{
DECL|method|NBHMEntry
name|NBHMEntry
parameter_list|(
specifier|final
name|TypeK
name|k
parameter_list|,
specifier|final
name|TypeV
name|v
parameter_list|)
block|{
name|super
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|method|setValue
specifier|public
name|TypeV
name|setValue
parameter_list|(
specifier|final
name|TypeV
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|_val
operator|=
name|val
expr_stmt|;
return|return
name|put
argument_list|(
name|_key
argument_list|,
name|val
argument_list|)
return|;
block|}
block|}
DECL|class|SnapshotE
specifier|private
class|class
name|SnapshotE
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
argument_list|>
block|{
DECL|field|_ss
specifier|final
name|SnapshotV
name|_ss
decl_stmt|;
DECL|method|SnapshotE
specifier|public
name|SnapshotE
parameter_list|()
block|{
name|_ss
operator|=
operator|new
name|SnapshotV
argument_list|()
expr_stmt|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|_ss
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
name|next
parameter_list|()
block|{
name|_ss
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
operator|new
name|NBHMEntry
argument_list|(
operator|(
name|TypeK
operator|)
name|_ss
operator|.
name|_prevK
argument_list|,
name|_ss
operator|.
name|_prevV
argument_list|)
return|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_ss
operator|.
name|hasNext
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns a {@link Set} view of the mappings contained in this map.  The      * set is backed by the map, so changes to the map are reflected in the      * set, and vice-versa.  The set supports element removal, which removes      * the corresponding mapping from the map, via the      *<tt>Iterator.remove</tt>,<tt>Set.remove</tt>,<tt>removeAll</tt>,      *<tt>retainAll</tt>, and<tt>clear</tt> operations.  It does not support      * the<tt>add</tt> or<tt>addAll</tt> operations.      *<p/>      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      *<p/>      *<p><strong>Warning:</strong> the iterator associated with this Set      * requires the creation of {@link java.util.Map.Entry} objects with each      * iteration.  The {@link NonBlockingHashtable} does not normally create or      * using {@link java.util.Map.Entry} objects so they will be created soley      * to support this iteration.  Iterating using {@link #keySet} or {@link      * #values} will be more efficient.      */
annotation|@
name|Override
DECL|method|entrySet
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|remove
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
condition|)
return|return
literal|false
return|;
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|NonBlockingHashtable
operator|.
name|this
operator|.
name|remove
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|contains
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
condition|)
return|return
literal|false
return|;
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|TypeV
name|v
init|=
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|v
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|TypeK
argument_list|,
name|TypeV
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|SnapshotE
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|// --- writeObject -------------------------------------------------------
comment|// Write a NBHM to a stream
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
comment|// Nothing to write
for|for
control|(
name|Object
name|K
range|:
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|Object
name|V
init|=
name|get
argument_list|(
name|K
argument_list|)
decl_stmt|;
comment|// Do an official 'get'
name|s
operator|.
name|writeObject
argument_list|(
name|K
argument_list|)
expr_stmt|;
comment|// Write the<TypeK,TypeV> pair
name|s
operator|.
name|writeObject
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// Sentinel to indicate end-of-data
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// --- readObject --------------------------------------------------------
comment|// Read a CHM from a stream
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
comment|// Read nothing
name|initialize
argument_list|(
name|MIN_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|TypeK
name|K
init|=
operator|(
name|TypeK
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
specifier|final
name|TypeV
name|V
init|=
operator|(
name|TypeV
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|K
operator|==
literal|null
condition|)
break|break;
name|put
argument_list|(
name|K
argument_list|,
name|V
argument_list|)
expr_stmt|;
comment|// Insert with an offical put
block|}
block|}
block|}
end_class

begin_comment
comment|// End NonBlockingHashtable class
end_comment

end_unit

