begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Cliff Click and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.util.concurrent.highscalelib
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|highscalelib
package|;
end_package

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|Unsafe
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_comment
comment|/**  * A multi-threaded bit-vector set, implemented as an array of primitive  * {@code longs}.  All operations are non-blocking and multi-threaded safe.  * {@link #contains(int)} calls are roughly the same speed as a {load, mask}  * sequence.  {@link #add(int)} and {@link #remove(int)} calls are a tad more  * expensive than a {load, mask, store} sequence because they must use a CAS.  * The bit-vector is auto-sizing.  *<p/>  *<p><em>General note of caution:</em> The Set API allows the use of {@link Integer}  * with silent autoboxing - which can be very expensive if many calls are  * being made.  Since autoboxing is silent you may not be aware that this is  * going on.  The built-in API takes lower-case {@code ints} and is much more  * efficient.  *<p/>  *<p>Space: space is used in proportion to the largest element, as opposed to  * the number of elements (as is the case with hash-table based Set  * implementations).  Space is approximately (largest_element/8 + 64) bytes.  *<p/>  * The implementation is a simple bit-vector using CAS for update.  *  * @author Cliff Click  * @since 1.5  */
end_comment

begin_class
DECL|class|NonBlockingSetInt
specifier|public
class|class
name|NonBlockingSetInt
extends|extends
name|AbstractSet
argument_list|<
name|Integer
argument_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1234123412341234123L
decl_stmt|;
DECL|field|_unsafe
specifier|private
specifier|static
specifier|final
name|Unsafe
name|_unsafe
init|=
name|UtilUnsafe
operator|.
name|getUnsafe
argument_list|()
decl_stmt|;
comment|// --- Bits to allow atomic update of the NBSI
DECL|field|_nbsi_offset
specifier|private
specifier|static
specifier|final
name|long
name|_nbsi_offset
decl_stmt|;
static|static
block|{
comment|//<clinit>
name|Field
name|f
init|=
literal|null
decl_stmt|;
try|try
block|{
name|f
operator|=
name|NonBlockingSetInt
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"_nbsi"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|NoSuchFieldException
name|e
parameter_list|)
block|{         }
name|_nbsi_offset
operator|=
name|_unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|CAS_nbsi
specifier|private
specifier|final
name|boolean
name|CAS_nbsi
parameter_list|(
name|NBSI
name|old
parameter_list|,
name|NBSI
name|nnn
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|_nbsi_offset
argument_list|,
name|old
argument_list|,
name|nnn
argument_list|)
return|;
block|}
comment|// The actual Set of Joy, which changes during a resize event.  The
comment|// Only Field for this class, so I can atomically change the entire
comment|// set implementation with a single CAS.
DECL|field|_nbsi
specifier|private
specifier|transient
name|NBSI
name|_nbsi
decl_stmt|;
comment|/**      * Create a new empty bit-vector      */
DECL|method|NonBlockingSetInt
specifier|public
name|NonBlockingSetInt
parameter_list|()
block|{
name|_nbsi
operator|=
operator|new
name|NBSI
argument_list|(
literal|63
argument_list|,
operator|new
name|Counter
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// The initial 1-word set
block|}
comment|/**      * Add {@code i} to the set.  Uppercase {@link Integer} version of add,      * requires auto-unboxing.  When possible use the {@code int} version of      * {@link #add(int)} for efficiency.      *      * @return<tt>true</tt> if i was added to the set.      * @throws IllegalArgumentException if i is negative.      */
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
specifier|final
name|Integer
name|i
parameter_list|)
block|{
return|return
name|add
argument_list|(
name|i
operator|.
name|intValue
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Test if {@code o} is in the set.  This is the uppercase {@link Integer}      * version of contains, requires a type-check and auto-unboxing.  When      * possible use the {@code int} version of {@link #contains(int)} for      * efficiency.      *      * @return<tt>true</tt> if i was in the set.      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|Integer
condition|?
name|contains
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
else|:
literal|false
return|;
block|}
comment|/**      * Remove {@code o} from the set.  This is the uppercase {@link Integer}      * version of remove, requires a type-check and auto-unboxing.  When      * possible use the {@code int} version of {@link #remove(int)} for      * efficiency.      *      * @return<tt>true</tt> if i was removed to the set.      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
return|return
name|o
operator|instanceof
name|Integer
condition|?
name|remove
argument_list|(
operator|(
operator|(
name|Integer
operator|)
name|o
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
else|:
literal|false
return|;
block|}
comment|/**      * Add {@code i} to the set.  This is the lower-case '{@code int}' version      * of {@link #add} - no autoboxing.  Negative values throw      * IllegalArgumentException.      *      * @return<tt>true</tt> if i was added to the set.      * @throws IllegalArgumentException if i is negative.      */
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|""
operator|+
name|i
argument_list|)
throw|;
return|return
name|_nbsi
operator|.
name|add
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Test if {@code i} is in the set.  This is the lower-case '{@code int}'      * version of {@link #contains} - no autoboxing.      *      * @return<tt>true</tt> if i was int the set.      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
return|return
name|i
operator|<
literal|0
condition|?
literal|false
else|:
name|_nbsi
operator|.
name|contains
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Remove {@code i} from the set.  This is the fast lower-case '{@code int}'      * version of {@link #remove} - no autoboxing.      *      * @return<tt>true</tt> if i was added to the set.      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
return|return
name|i
operator|<
literal|0
condition|?
literal|false
else|:
name|_nbsi
operator|.
name|remove
argument_list|(
name|i
argument_list|)
return|;
block|}
comment|/**      * Current count of elements in the set.  Due to concurrent racing updates,      * the size is only ever approximate.  Updates due to the calling thread are      * immediately visible to calling thread.      *      * @return count of elements.      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|_nbsi
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Empty the bitvector.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|NBSI
name|cleared
init|=
operator|new
name|NBSI
argument_list|(
literal|63
argument_list|,
operator|new
name|Counter
argument_list|()
argument_list|,
name|this
argument_list|)
decl_stmt|;
comment|// An empty initial NBSI
while|while
condition|(
operator|!
name|CAS_nbsi
argument_list|(
name|_nbsi
argument_list|,
name|cleared
argument_list|)
condition|)
comment|// Spin until clear works
empty_stmt|;
block|}
comment|/**      * Verbose printout of internal structure for debugging.      */
DECL|method|print
specifier|public
name|void
name|print
parameter_list|()
block|{
name|_nbsi
operator|.
name|print
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Standard Java {@link Iterator}.  Not very efficient because it      * auto-boxes the returned values.      */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|iter
argument_list|()
return|;
block|}
DECL|class|iter
specifier|private
class|class
name|iter
implements|implements
name|Iterator
argument_list|<
name|Integer
argument_list|>
block|{
DECL|field|_nbsi2
name|NBSI
name|_nbsi2
decl_stmt|;
DECL|field|_idx
name|int
name|_idx
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|_prev
name|int
name|_prev
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|iter
name|iter
parameter_list|()
block|{
name|_nbsi2
operator|=
name|_nbsi
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_idx
operator|!=
operator|-
literal|2
return|;
block|}
DECL|method|advance
specifier|private
name|void
name|advance
parameter_list|()
block|{
while|while
condition|(
literal|true
condition|)
block|{
name|_idx
operator|++
expr_stmt|;
comment|// Next index
while|while
condition|(
operator|(
name|_idx
operator|>>
literal|6
operator|)
operator|>=
name|_nbsi2
operator|.
name|_bits
operator|.
name|length
condition|)
block|{
comment|// Index out of range?
if|if
condition|(
name|_nbsi2
operator|.
name|_new
operator|==
literal|null
condition|)
block|{
comment|// New table?
name|_idx
operator|=
operator|-
literal|2
expr_stmt|;
comment|// No, so must be all done
return|return;
comment|//
block|}
name|_nbsi2
operator|=
name|_nbsi2
operator|.
name|_new
expr_stmt|;
comment|// Carry on, in the new table
block|}
if|if
condition|(
name|_nbsi2
operator|.
name|contains
argument_list|(
name|_idx
argument_list|)
condition|)
return|return;
block|}
block|}
DECL|method|next
specifier|public
name|Integer
name|next
parameter_list|()
block|{
if|if
condition|(
name|_idx
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|_prev
operator|=
name|_idx
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|_prev
return|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|_prev
operator|==
operator|-
literal|1
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|_nbsi2
operator|.
name|remove
argument_list|(
name|_prev
argument_list|)
expr_stmt|;
name|_prev
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|// --- writeObject -------------------------------------------------------
comment|// Write a NBSI to a stream
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
comment|// Nothing to write
specifier|final
name|NBSI
name|nbsi
init|=
name|_nbsi
decl_stmt|;
comment|// The One Field is transient
specifier|final
name|int
name|len
init|=
name|_nbsi
operator|.
name|_bits
operator|.
name|length
operator|<<
literal|6
decl_stmt|;
name|s
operator|.
name|writeInt
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|// Write max element
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|s
operator|.
name|writeBoolean
argument_list|(
name|_nbsi
operator|.
name|contains
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// --- readObject --------------------------------------------------------
comment|// Read a CHM from a stream
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
comment|// Read nothing
specifier|final
name|int
name|len
init|=
name|s
operator|.
name|readInt
argument_list|()
decl_stmt|;
comment|// Read max element
name|_nbsi
operator|=
operator|new
name|NBSI
argument_list|(
name|len
argument_list|,
operator|new
name|Counter
argument_list|()
argument_list|,
name|this
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
comment|// Read all bits
if|if
condition|(
name|s
operator|.
name|readBoolean
argument_list|()
condition|)
name|_nbsi
operator|.
name|add
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// --- NBSI ----------------------------------------------------------------
DECL|class|NBSI
specifier|private
specifier|static
specifier|final
class|class
name|NBSI
block|{
comment|// Back pointer to the parent wrapper; sorta like make the class non-static
DECL|field|_non_blocking_set_int
specifier|private
specifier|transient
specifier|final
name|NonBlockingSetInt
name|_non_blocking_set_int
decl_stmt|;
comment|// Used to count elements: a high-performance counter.
DECL|field|_size
specifier|private
specifier|transient
specifier|final
name|Counter
name|_size
decl_stmt|;
comment|// The Bits
DECL|field|_bits
specifier|private
specifier|final
name|long
name|_bits
index|[]
decl_stmt|;
comment|// --- Bits to allow Unsafe access to arrays
DECL|field|_Lbase
specifier|private
specifier|static
specifier|final
name|int
name|_Lbase
init|=
name|_unsafe
operator|.
name|arrayBaseOffset
argument_list|(
name|long
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|_Lscale
specifier|private
specifier|static
specifier|final
name|int
name|_Lscale
init|=
name|_unsafe
operator|.
name|arrayIndexScale
argument_list|(
name|long
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|rawIndex
specifier|private
specifier|static
name|long
name|rawIndex
parameter_list|(
specifier|final
name|long
index|[]
name|ary
parameter_list|,
specifier|final
name|int
name|idx
parameter_list|)
block|{
assert|assert
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ary
operator|.
name|length
assert|;
return|return
name|_Lbase
operator|+
name|idx
operator|*
name|_Lscale
return|;
block|}
DECL|method|CAS
specifier|private
specifier|final
name|boolean
name|CAS
parameter_list|(
name|int
name|idx
parameter_list|,
name|long
name|old
parameter_list|,
name|long
name|nnn
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapLong
argument_list|(
name|_bits
argument_list|,
name|rawIndex
argument_list|(
name|_bits
argument_list|,
name|idx
argument_list|)
argument_list|,
name|old
argument_list|,
name|nnn
argument_list|)
return|;
block|}
comment|// --- Resize
comment|// The New Table, only set once to non-zero during a resize.
comment|// Must be atomically set.
DECL|field|_new
specifier|private
name|NBSI
name|_new
decl_stmt|;
DECL|field|_new_offset
specifier|private
specifier|static
specifier|final
name|long
name|_new_offset
decl_stmt|;
static|static
block|{
comment|//<clinit>
name|Field
name|f
init|=
literal|null
decl_stmt|;
try|try
block|{
name|f
operator|=
name|NBSI
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"_new"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|NoSuchFieldException
name|e
parameter_list|)
block|{             }
name|_new_offset
operator|=
name|_unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|CAS_new
specifier|private
specifier|final
name|boolean
name|CAS_new
parameter_list|(
name|NBSI
name|nnn
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|_new_offset
argument_list|,
literal|null
argument_list|,
name|nnn
argument_list|)
return|;
block|}
DECL|field|_copyIdx
specifier|private
specifier|transient
specifier|final
name|AtomicInteger
name|_copyIdx
decl_stmt|;
comment|// Used to count bits started copying
DECL|field|_copyDone
specifier|private
specifier|transient
specifier|final
name|AtomicInteger
name|_copyDone
decl_stmt|;
comment|// Used to count words copied in a resize operation
DECL|field|_sum_bits_length
specifier|private
specifier|transient
specifier|final
name|int
name|_sum_bits_length
decl_stmt|;
comment|// Sum of all nested _bits.lengths
DECL|method|mask
specifier|private
specifier|static
specifier|final
name|long
name|mask
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
literal|1L
operator|<<
operator|(
name|i
operator|&
literal|63
operator|)
return|;
block|}
comment|// I need 1 free bit out of 64 to allow for resize.  I do this by stealing
comment|// the high order bit - but then I need to do something with adding element
comment|// number 63 (and friends).  I could use a mod63 function but it's more
comment|// efficient to handle the mod-64 case as an exception.
comment|//
comment|// Every 64th bit is put in it's own recursive bitvector.  If the low 6 bits
comment|// are all set, we shift them off and recursively operate on the _nbsi64 set.
DECL|field|_nbsi64
specifier|private
specifier|final
name|NBSI
name|_nbsi64
decl_stmt|;
DECL|method|NBSI
specifier|private
name|NBSI
parameter_list|(
name|int
name|max_elem
parameter_list|,
name|Counter
name|ctr
parameter_list|,
name|NonBlockingSetInt
name|nonb
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|_non_blocking_set_int
operator|=
name|nonb
expr_stmt|;
name|_size
operator|=
name|ctr
expr_stmt|;
name|_copyIdx
operator|=
name|ctr
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|_copyDone
operator|=
name|ctr
operator|==
literal|null
condition|?
literal|null
else|:
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
comment|// The main array of bits
name|_bits
operator|=
operator|new
name|long
index|[
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|long
operator|)
name|max_elem
operator|+
literal|63
operator|)
operator|>>>
literal|6
argument_list|)
index|]
expr_stmt|;
comment|// Every 64th bit is moved off to it's own subarray, so that the
comment|// sign-bit is free for other purposes
name|_nbsi64
operator|=
operator|(
operator|(
name|max_elem
operator|+
literal|1
operator|)
operator|>>>
literal|6
operator|)
operator|==
literal|0
condition|?
literal|null
else|:
operator|new
name|NBSI
argument_list|(
operator|(
name|max_elem
operator|+
literal|1
operator|)
operator|>>>
literal|6
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|_sum_bits_length
operator|=
name|_bits
operator|.
name|length
operator|+
operator|(
name|_nbsi64
operator|==
literal|null
condition|?
literal|0
else|:
name|_nbsi64
operator|.
name|_sum_bits_length
operator|)
expr_stmt|;
block|}
comment|// Lower-case 'int' versions - no autoboxing, very fast.
comment|// 'i' is known positive.
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
comment|// Check for out-of-range for the current size bit vector.
comment|// If so we need to grow the bit vector.
if|if
condition|(
operator|(
name|i
operator|>>
literal|6
operator|)
operator|>=
name|_bits
operator|.
name|length
condition|)
return|return
name|install_larger_new_bits
argument_list|(
name|i
argument_list|)
operator|.
comment|// Install larger pile-o-bits (duh)
name|help_copy
argument_list|()
operator|.
name|add
argument_list|(
name|i
argument_list|)
return|;
comment|// Finally, add to the new table
comment|// Handle every 64th bit via using a nested array
name|NBSI
name|nbsi
init|=
name|this
decl_stmt|;
comment|// The bit array being added into
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// The bit index being added
while|while
condition|(
operator|(
name|j
operator|&
literal|63
operator|)
operator|==
literal|63
condition|)
block|{
comment|// Bit 64? (low 6 bits are all set)
name|nbsi
operator|=
name|nbsi
operator|.
name|_nbsi64
expr_stmt|;
comment|// Recurse
name|j
operator|=
name|j
operator|>>
literal|6
expr_stmt|;
comment|// Strip off low 6 bits (all set)
block|}
specifier|final
name|long
name|mask
init|=
name|mask
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|long
name|old
decl_stmt|;
do|do
block|{
name|old
operator|=
name|nbsi
operator|.
name|_bits
index|[
name|j
operator|>>
literal|6
index|]
expr_stmt|;
comment|// Read old bits
if|if
condition|(
name|old
operator|<
literal|0
condition|)
comment|// Not mutable?
comment|// Not mutable: finish copy of word, and retry on copied word
return|return
name|help_copy_impl
argument_list|(
name|i
argument_list|)
operator|.
name|help_copy
argument_list|()
operator|.
name|add
argument_list|(
name|i
argument_list|)
return|;
if|if
condition|(
operator|(
name|old
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
comment|// Bit is already set?
block|}
do|while
condition|(
operator|!
name|nbsi
operator|.
name|CAS
argument_list|(
name|j
operator|>>
literal|6
argument_list|,
name|old
argument_list|,
name|old
operator||
name|mask
argument_list|)
condition|)
do|;
name|_size
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|(
name|i
operator|>>
literal|6
operator|)
operator|>=
name|_bits
operator|.
name|length
condition|)
comment|// Out of bounds?  Not in this array!
return|return
name|_new
operator|==
literal|null
condition|?
literal|false
else|:
name|help_copy
argument_list|()
operator|.
name|remove
argument_list|(
name|i
argument_list|)
return|;
comment|// Handle every 64th bit via using a nested array
name|NBSI
name|nbsi
init|=
name|this
decl_stmt|;
comment|// The bit array being added into
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// The bit index being added
while|while
condition|(
operator|(
name|j
operator|&
literal|63
operator|)
operator|==
literal|63
condition|)
block|{
comment|// Bit 64? (low 6 bits are all set)
name|nbsi
operator|=
name|nbsi
operator|.
name|_nbsi64
expr_stmt|;
comment|// Recurse
name|j
operator|=
name|j
operator|>>
literal|6
expr_stmt|;
comment|// Strip off low 6 bits (all set)
block|}
specifier|final
name|long
name|mask
init|=
name|mask
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|long
name|old
decl_stmt|;
do|do
block|{
name|old
operator|=
name|nbsi
operator|.
name|_bits
index|[
name|j
operator|>>
literal|6
index|]
expr_stmt|;
comment|// Read old bits
if|if
condition|(
name|old
operator|<
literal|0
condition|)
comment|// Not mutable?
comment|// Not mutable: finish copy of word, and retry on copied word
return|return
name|help_copy_impl
argument_list|(
name|i
argument_list|)
operator|.
name|help_copy
argument_list|()
operator|.
name|remove
argument_list|(
name|i
argument_list|)
return|;
if|if
condition|(
operator|(
name|old
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
return|return
literal|false
return|;
comment|// Bit is already clear?
block|}
do|while
condition|(
operator|!
name|nbsi
operator|.
name|CAS
argument_list|(
name|j
operator|>>
literal|6
argument_list|,
name|old
argument_list|,
name|old
operator|&
operator|~
name|mask
argument_list|)
condition|)
do|;
name|_size
operator|.
name|add
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|(
name|i
operator|>>
literal|6
operator|)
operator|>=
name|_bits
operator|.
name|length
condition|)
comment|// Out of bounds?  Not in this array!
return|return
name|_new
operator|==
literal|null
condition|?
literal|false
else|:
name|help_copy
argument_list|()
operator|.
name|contains
argument_list|(
name|i
argument_list|)
return|;
comment|// Handle every 64th bit via using a nested array
name|NBSI
name|nbsi
init|=
name|this
decl_stmt|;
comment|// The bit array being added into
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// The bit index being added
while|while
condition|(
operator|(
name|j
operator|&
literal|63
operator|)
operator|==
literal|63
condition|)
block|{
comment|// Bit 64? (low 6 bits are all set)
name|nbsi
operator|=
name|nbsi
operator|.
name|_nbsi64
expr_stmt|;
comment|// Recurse
name|j
operator|=
name|j
operator|>>
literal|6
expr_stmt|;
comment|// Strip off low 6 bits (all set)
block|}
specifier|final
name|long
name|mask
init|=
name|mask
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|long
name|old
init|=
name|nbsi
operator|.
name|_bits
index|[
name|j
operator|>>
literal|6
index|]
decl_stmt|;
comment|// Read old bits
if|if
condition|(
name|old
operator|<
literal|0
condition|)
comment|// Not mutable?
comment|// Not mutable: finish copy of word, and retry on copied word
return|return
name|help_copy_impl
argument_list|(
name|i
argument_list|)
operator|.
name|help_copy
argument_list|()
operator|.
name|contains
argument_list|(
name|i
argument_list|)
return|;
comment|// Yes mutable: test& return bit
return|return
operator|(
name|old
operator|&
name|mask
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|_size
operator|.
name|get
argument_list|()
return|;
block|}
comment|// Must grow the current array to hold an element of size i
DECL|method|install_larger_new_bits
specifier|private
name|NBSI
name|install_larger_new_bits
parameter_list|(
specifier|final
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|_new
operator|==
literal|null
condition|)
block|{
comment|// Grow by powers of 2, to avoid minor grow-by-1's.
comment|// Note: must grow by exact powers-of-2 or the by-64-bit trick doesn't work right
name|int
name|sz
init|=
operator|(
name|_bits
operator|.
name|length
operator|<<
literal|6
operator|)
operator|<<
literal|1
decl_stmt|;
comment|// CAS to install a new larger size.  Did it work?  Did it fail?  We
comment|// don't know and don't care.  Only One can be installed, so if
comment|// another thread installed a too-small size, we can't help it - we
comment|// must simply install our new larger size as a nested-resize table.
name|CAS_new
argument_list|(
operator|new
name|NBSI
argument_list|(
name|sz
argument_list|,
name|_size
argument_list|,
name|_non_blocking_set_int
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Return self for 'fluid' programming style
return|return
name|this
return|;
block|}
comment|// Help any top-level NBSI to copy until completed.
comment|// Always return the _new version of *this* NBSI, in case we're nested.
DECL|method|help_copy
specifier|private
name|NBSI
name|help_copy
parameter_list|()
block|{
comment|// Pick some words to help with - but only help copy the top-level NBSI.
comment|// Nested NBSI waits until the top is done before we start helping.
name|NBSI
name|top_nbsi
init|=
name|_non_blocking_set_int
operator|.
name|_nbsi
decl_stmt|;
specifier|final
name|int
name|HELP
init|=
literal|8
decl_stmt|;
comment|// Tuning number: how much copy pain are we willing to inflict?
comment|// We "help" by forcing individual bit indices to copy.  However, bits
comment|// come in lumps of 64 per word, so we just advance the bit counter by 64's.
name|int
name|idx
init|=
name|top_nbsi
operator|.
name|_copyIdx
operator|.
name|getAndAdd
argument_list|(
literal|64
operator|*
name|HELP
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|HELP
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
init|=
name|idx
operator|+
name|i
operator|*
literal|64
decl_stmt|;
name|j
operator|%=
operator|(
name|top_nbsi
operator|.
name|_bits
operator|.
name|length
operator|<<
literal|6
operator|)
expr_stmt|;
comment|// Limit, wrap to array size; means we retry indices
name|top_nbsi
operator|.
name|help_copy_impl
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|top_nbsi
operator|.
name|help_copy_impl
argument_list|(
name|j
operator|+
literal|63
argument_list|)
expr_stmt|;
comment|// Also force the nested-by-64 bit
block|}
comment|// Top level guy ready to promote?
comment|// Note: WE may not be the top-level guy!
if|if
condition|(
name|top_nbsi
operator|.
name|_copyDone
operator|.
name|get
argument_list|()
operator|==
name|top_nbsi
operator|.
name|_sum_bits_length
condition|)
comment|// One shot CAS to promote - it may fail since we are racing; others
comment|// may promote as well
if|if
condition|(
name|_non_blocking_set_int
operator|.
name|CAS_nbsi
argument_list|(
name|top_nbsi
argument_list|,
name|top_nbsi
operator|.
name|_new
argument_list|)
condition|)
block|{
comment|//System.out.println("Promote at top level to size "+(_non_blocking_set_int._nbsi._bits.length<<6));
block|}
comment|// Return the new bitvector for 'fluid' programming style
return|return
name|_new
return|;
block|}
comment|// Help copy this one word.  State Machine.
comment|// (1) If not "made immutable" in the old array, set the sign bit to make
comment|//     it immutable.
comment|// (2) If non-zero in old array& zero in new, CAS new from 0 to copy-of-old
comment|// (3) If non-zero in old array& non-zero in new, CAS old to zero
comment|// (4) Zero in old, new is valid
comment|// At this point, old should be immutable-zero& new has a copy of bits
DECL|method|help_copy_impl
specifier|private
name|NBSI
name|help_copy_impl
parameter_list|(
name|int
name|i
parameter_list|)
block|{
comment|// Handle every 64th bit via using a nested array
name|NBSI
name|old
init|=
name|this
decl_stmt|;
comment|// The bit array being copied from
name|NBSI
name|nnn
init|=
name|_new
decl_stmt|;
comment|// The bit array being copied to
if|if
condition|(
name|nnn
operator|==
literal|null
condition|)
return|return
name|this
return|;
comment|// Promoted already
name|int
name|j
init|=
name|i
decl_stmt|;
comment|// The bit index being added
while|while
condition|(
operator|(
name|j
operator|&
literal|63
operator|)
operator|==
literal|63
condition|)
block|{
comment|// Bit 64? (low 6 bits are all set)
name|old
operator|=
name|old
operator|.
name|_nbsi64
expr_stmt|;
comment|// Recurse
name|nnn
operator|=
name|nnn
operator|.
name|_nbsi64
expr_stmt|;
comment|// Recurse
name|j
operator|=
name|j
operator|>>
literal|6
expr_stmt|;
comment|// Strip off low 6 bits (all set)
block|}
comment|// Transit from state 1: word is not immutable yet
comment|// Immutable is in bit 63, the sign bit.
name|long
name|bits
init|=
name|old
operator|.
name|_bits
index|[
name|j
operator|>>
literal|6
index|]
decl_stmt|;
while|while
condition|(
name|bits
operator|>=
literal|0
condition|)
block|{
comment|// Still in state (1)?
name|long
name|oldbits
init|=
name|bits
decl_stmt|;
name|bits
operator||=
name|mask
argument_list|(
literal|63
argument_list|)
expr_stmt|;
comment|// Target state of bits: sign-bit means immutable
if|if
condition|(
name|old
operator|.
name|CAS
argument_list|(
name|j
operator|>>
literal|6
argument_list|,
name|oldbits
argument_list|,
name|bits
argument_list|)
condition|)
block|{
if|if
condition|(
name|oldbits
operator|==
literal|0
condition|)
name|_copyDone
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|// Success - old array word is now immutable
block|}
name|bits
operator|=
name|old
operator|.
name|_bits
index|[
name|j
operator|>>
literal|6
index|]
expr_stmt|;
comment|// Retry if CAS failed
block|}
comment|// Transit from state 2: non-zero in old and zero in new
if|if
condition|(
name|bits
operator|!=
name|mask
argument_list|(
literal|63
argument_list|)
condition|)
block|{
comment|// Non-zero in old?
name|long
name|new_bits
init|=
name|nnn
operator|.
name|_bits
index|[
name|j
operator|>>
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|new_bits
operator|==
literal|0
condition|)
block|{
comment|// New array is still zero
name|new_bits
operator|=
name|bits
operator|&
operator|~
name|mask
argument_list|(
literal|63
argument_list|)
expr_stmt|;
comment|// Desired new value: a mutable copy of bits
comment|// One-shot CAS attempt, no loop, from 0 to non-zero.
comment|// If it fails, somebody else did the copy for us
if|if
condition|(
operator|!
name|nnn
operator|.
name|CAS
argument_list|(
name|j
operator|>>
literal|6
argument_list|,
literal|0
argument_list|,
name|new_bits
argument_list|)
condition|)
name|new_bits
operator|=
name|nnn
operator|.
name|_bits
index|[
name|j
operator|>>
literal|6
index|]
expr_stmt|;
comment|// Since it failed, get the new value
assert|assert
name|new_bits
operator|!=
literal|0
assert|;
block|}
comment|// Transit from state 3: non-zero in old and non-zero in new
comment|// One-shot CAS attempt, no loop, from non-zero to 0 (but immutable)
if|if
condition|(
name|old
operator|.
name|CAS
argument_list|(
name|j
operator|>>
literal|6
argument_list|,
name|bits
argument_list|,
name|mask
argument_list|(
literal|63
argument_list|)
argument_list|)
condition|)
name|_copyDone
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// One more word finished copying
block|}
comment|// Now in state 4: zero (and immutable) in old
comment|// Return the self bitvector for 'fluid' programming style
return|return
name|this
return|;
block|}
DECL|method|print
specifier|private
name|void
name|print
parameter_list|(
name|int
name|d
parameter_list|,
name|String
name|msg
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
DECL|method|print
specifier|private
name|void
name|print
parameter_list|(
name|int
name|d
parameter_list|)
block|{
name|StringBuffer
name|buf
init|=
operator|new
name|StringBuffer
argument_list|()
decl_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|"NBSI - _bits.len="
argument_list|)
expr_stmt|;
name|NBSI
name|x
init|=
name|this
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
literal|" "
operator|+
name|x
operator|.
name|_bits
operator|.
name|length
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|.
name|_nbsi64
expr_stmt|;
block|}
name|print
argument_list|(
name|d
argument_list|,
name|buf
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|x
operator|=
name|this
expr_stmt|;
while|while
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|x
operator|.
name|_bits
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
name|Long
operator|.
name|toHexString
argument_list|(
name|x
operator|.
name|_bits
index|[
name|i
index|]
argument_list|)
operator|+
literal|" "
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|.
name|_nbsi64
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|_copyIdx
operator|.
name|get
argument_list|()
operator|!=
literal|0
operator|||
name|_copyDone
operator|.
name|get
argument_list|()
operator|!=
literal|0
condition|)
name|print
argument_list|(
name|d
argument_list|,
literal|"_copyIdx="
operator|+
name|_copyIdx
operator|.
name|get
argument_list|()
operator|+
literal|" _copyDone="
operator|+
name|_copyDone
operator|.
name|get
argument_list|()
operator|+
literal|" _words_to_cpy="
operator|+
name|_sum_bits_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|_new
operator|!=
literal|null
condition|)
block|{
name|print
argument_list|(
name|d
argument_list|,
literal|"__has_new - "
argument_list|)
expr_stmt|;
name|_new
operator|.
name|print
argument_list|(
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

