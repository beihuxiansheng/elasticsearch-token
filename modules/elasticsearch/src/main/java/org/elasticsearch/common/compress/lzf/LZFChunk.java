begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/* Licensed under the Apache License, Version 2.0 (the "License"); you may not use this  * file except in compliance with the License. You may obtain a copy of the License at  *  * http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software distributed under  * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS  * OF ANY KIND, either express or implied. See the License for the specific language  * governing permissions and limitations under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.compress.lzf
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|lzf
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_comment
comment|/**  * Helper class used to store LZF encoded segments (compressed and non-compressed)  * that can be sequenced to produce LZF files/streams.  *  * @author tatu@ning.com  */
end_comment

begin_class
DECL|class|LZFChunk
specifier|public
class|class
name|LZFChunk
block|{
comment|/**      * Maximum length of literal run for LZF encoding.      */
DECL|field|MAX_LITERAL
specifier|public
specifier|static
specifier|final
name|int
name|MAX_LITERAL
init|=
literal|1
operator|<<
literal|5
decl_stmt|;
comment|// 32
comment|// Chunk length is limited by 2-byte length indicator, to 64k
DECL|field|MAX_CHUNK_LEN
specifier|public
specifier|static
specifier|final
name|int
name|MAX_CHUNK_LEN
init|=
literal|0xFFFF
decl_stmt|;
DECL|field|BYTE_Z
specifier|public
specifier|final
specifier|static
name|byte
name|BYTE_Z
init|=
literal|'Z'
decl_stmt|;
DECL|field|BYTE_V
specifier|public
specifier|final
specifier|static
name|byte
name|BYTE_V
init|=
literal|'V'
decl_stmt|;
DECL|field|BLOCK_TYPE_NON_COMPRESSED
specifier|public
specifier|final
specifier|static
name|int
name|BLOCK_TYPE_NON_COMPRESSED
init|=
literal|0
decl_stmt|;
DECL|field|BLOCK_TYPE_COMPRESSED
specifier|public
specifier|final
specifier|static
name|int
name|BLOCK_TYPE_COMPRESSED
init|=
literal|1
decl_stmt|;
DECL|field|_data
specifier|final
name|byte
index|[]
name|_data
decl_stmt|;
DECL|field|_next
name|LZFChunk
name|_next
decl_stmt|;
DECL|method|LZFChunk
specifier|private
name|LZFChunk
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
block|{
name|_data
operator|=
name|data
expr_stmt|;
block|}
DECL|method|createCompressed
specifier|public
specifier|static
name|int
name|createCompressed
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|int
name|origLen
parameter_list|,
name|byte
index|[]
name|encData
parameter_list|,
name|int
name|encPtr
parameter_list|,
name|int
name|encLen
parameter_list|)
throws|throws
name|IOException
block|{
name|os
operator|.
name|write
argument_list|(
name|BYTE_Z
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|BYTE_V
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|BLOCK_TYPE_COMPRESSED
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|encLen
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|encLen
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
operator|(
name|origLen
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|origLen
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|encData
argument_list|,
name|encPtr
argument_list|,
name|encLen
argument_list|)
expr_stmt|;
return|return
name|encLen
operator|+
literal|7
return|;
block|}
comment|/**      * Factory method for constructing compressed chunk      */
DECL|method|createCompressed
specifier|public
specifier|static
name|LZFChunk
name|createCompressed
parameter_list|(
name|int
name|origLen
parameter_list|,
name|byte
index|[]
name|encData
parameter_list|,
name|int
name|encPtr
parameter_list|,
name|int
name|encLen
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|encLen
operator|+
literal|7
index|]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|BYTE_Z
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|BYTE_V
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|BLOCK_TYPE_COMPRESSED
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|encLen
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|=
operator|(
name|byte
operator|)
name|encLen
expr_stmt|;
name|result
index|[
literal|5
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|origLen
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|result
index|[
literal|6
index|]
operator|=
operator|(
name|byte
operator|)
name|origLen
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|encData
argument_list|,
name|encPtr
argument_list|,
name|result
argument_list|,
literal|7
argument_list|,
name|encLen
argument_list|)
expr_stmt|;
return|return
operator|new
name|LZFChunk
argument_list|(
name|result
argument_list|)
return|;
block|}
DECL|method|createNonCompressed
specifier|public
specifier|static
name|int
name|createNonCompressed
parameter_list|(
name|OutputStream
name|os
parameter_list|,
name|byte
index|[]
name|plainData
parameter_list|,
name|int
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|os
operator|.
name|write
argument_list|(
name|BYTE_Z
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|BYTE_V
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|BLOCK_TYPE_NON_COMPRESSED
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|os
operator|.
name|write
argument_list|(
name|plainData
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|len
operator|+
literal|5
return|;
block|}
comment|/**      * Factory method for constructing compressed chunk      */
DECL|method|createNonCompressed
specifier|public
specifier|static
name|LZFChunk
name|createNonCompressed
parameter_list|(
name|byte
index|[]
name|plainData
parameter_list|,
name|int
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|byte
index|[]
name|result
init|=
operator|new
name|byte
index|[
name|len
operator|+
literal|5
index|]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|BYTE_Z
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|BYTE_V
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|BLOCK_TYPE_NON_COMPRESSED
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|=
call|(
name|byte
call|)
argument_list|(
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|=
operator|(
name|byte
operator|)
name|len
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|plainData
argument_list|,
name|ptr
argument_list|,
name|result
argument_list|,
literal|5
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|new
name|LZFChunk
argument_list|(
name|result
argument_list|)
return|;
block|}
DECL|method|setNext
specifier|public
name|void
name|setNext
parameter_list|(
name|LZFChunk
name|next
parameter_list|)
block|{
name|_next
operator|=
name|next
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|LZFChunk
name|next
parameter_list|()
block|{
return|return
name|_next
return|;
block|}
DECL|method|length
specifier|public
name|int
name|length
parameter_list|()
block|{
return|return
name|_data
operator|.
name|length
return|;
block|}
DECL|method|getData
specifier|public
name|byte
index|[]
name|getData
parameter_list|()
block|{
return|return
name|_data
return|;
block|}
DECL|method|copyTo
specifier|public
name|int
name|copyTo
parameter_list|(
name|byte
index|[]
name|dst
parameter_list|,
name|int
name|ptr
parameter_list|)
block|{
name|int
name|len
init|=
name|_data
operator|.
name|length
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|_data
argument_list|,
literal|0
argument_list|,
name|dst
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|ptr
operator|+
name|len
return|;
block|}
block|}
end_class

end_unit

