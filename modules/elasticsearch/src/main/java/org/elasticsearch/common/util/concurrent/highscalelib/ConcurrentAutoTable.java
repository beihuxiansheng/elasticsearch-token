begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Cliff Click and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.util.concurrent.highscalelib
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|highscalelib
package|;
end_package

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|Unsafe
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLongFieldUpdater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceFieldUpdater
import|;
end_import

begin_comment
comment|/**  * An auto-resizing table of {@code longs}, supporting low-contention CAS  * operations.  Updates are done with CAS's to no particular table element.  * The intent is to support highly scalable counters, r/w locks, and other  * structures where the updates are associative, loss-free (no-brainer), and  * otherwise happen at such a high volume that the cache contention for  * CAS'ing a single word is unacceptable.  *<p/>  *<p>This API is overkill for simple counters (e.g. no need for the 'mask')  * and is untested as an API for making a scalable r/w lock and so is likely  * to change!  *  * @author Cliff Click  * @since 1.5  */
end_comment

begin_class
DECL|class|ConcurrentAutoTable
specifier|public
class|class
name|ConcurrentAutoTable
implements|implements
name|Serializable
block|{
comment|// --- public interface ---
comment|/**      * Add the given value to current counter value.  Concurrent updates will      * not be lost, but addAndGet or getAndAdd are not implemented because the      * total counter value (i.e., {@link #get}) is not atomically updated.      * Updates are striped across an array of counters to avoid cache contention      * and has been tested with performance scaling linearly up to 768 CPUs.      */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|long
name|x
parameter_list|)
block|{
name|add_if_mask
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@link #add} with -1      */
DECL|method|decrement
specifier|public
name|void
name|decrement
parameter_list|()
block|{
name|add_if_mask
argument_list|(
operator|-
literal|1L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * {@link #add} with +1      */
DECL|method|increment
specifier|public
name|void
name|increment
parameter_list|()
block|{
name|add_if_mask
argument_list|(
literal|1L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Atomically set the sum of the striped counters to specified value.      * Rather more expensive than a simple store, in order to remain atomic.      */
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|long
name|x
parameter_list|)
block|{
name|CAT
name|newcat
init|=
operator|new
name|CAT
argument_list|(
literal|null
argument_list|,
literal|4
argument_list|,
name|x
argument_list|)
decl_stmt|;
comment|// Spin until CAS works
while|while
condition|(
operator|!
name|CAS_cat
argument_list|(
name|_cat
argument_list|,
name|newcat
argument_list|)
condition|)
empty_stmt|;
block|}
comment|/**      * Current value of the counter.  Since other threads are updating furiously      * the value is only approximate, but it includes all counts made by the      * current thread.  Requires a pass over the internally striped counters.      */
DECL|method|get
specifier|public
name|long
name|get
parameter_list|()
block|{
return|return
name|_cat
operator|.
name|sum
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Same as {@link #get}, included for completeness.      */
DECL|method|intValue
specifier|public
name|int
name|intValue
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|_cat
operator|.
name|sum
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Same as {@link #get}, included for completeness.      */
DECL|method|longValue
specifier|public
name|long
name|longValue
parameter_list|()
block|{
return|return
name|_cat
operator|.
name|sum
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * A cheaper {@link #get}.  Updated only once/millisecond, but as fast as a      * simple load instruction when not updating.      */
DECL|method|estimate_get
specifier|public
name|long
name|estimate_get
parameter_list|()
block|{
return|return
name|_cat
operator|.
name|estimate_sum
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Return the counter's {@code long} value converted to a string.      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|_cat
operator|.
name|toString
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * A more verbose print than {@link #toString}, showing internal structure.      * Useful for debugging.      */
DECL|method|print
specifier|public
name|void
name|print
parameter_list|()
block|{
name|_cat
operator|.
name|print
argument_list|()
expr_stmt|;
block|}
comment|/**      * Return the internal counter striping factor.  Useful for diagnosing      * performance problems.      */
DECL|method|internal_size
specifier|public
name|int
name|internal_size
parameter_list|()
block|{
return|return
name|_cat
operator|.
name|_t
operator|.
name|length
return|;
block|}
comment|// Only add 'x' to some slot in table, hinted at by 'hash', if bits under
comment|// the mask are all zero.  The sum can overflow or 'x' can contain bits in
comment|// the mask. Value is CAS'd so no counts are lost.  The CAS is retried until
comment|// it succeeds or bits are found under the mask.  Returned value is the old
comment|// value - which WILL have zero under the mask on success and WILL NOT have
comment|// zero under the mask for failure.
DECL|method|add_if_mask
specifier|private
name|long
name|add_if_mask
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|mask
parameter_list|)
block|{
return|return
name|_cat
operator|.
name|add_if_mask
argument_list|(
name|x
argument_list|,
name|mask
argument_list|,
name|hash
argument_list|()
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|// The underlying array of concurrently updated long counters
DECL|field|_cat
specifier|private
specifier|volatile
name|CAT
name|_cat
init|=
operator|new
name|CAT
argument_list|(
literal|null
argument_list|,
literal|4
comment|/*Start Small, Think Big!*/
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
DECL|field|_catUpdater
specifier|private
specifier|static
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|ConcurrentAutoTable
argument_list|,
name|CAT
argument_list|>
name|_catUpdater
init|=
name|AtomicReferenceFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|ConcurrentAutoTable
operator|.
name|class
argument_list|,
name|CAT
operator|.
name|class
argument_list|,
literal|"_cat"
argument_list|)
decl_stmt|;
DECL|method|CAS_cat
specifier|private
name|boolean
name|CAS_cat
parameter_list|(
name|CAT
name|oldcat
parameter_list|,
name|CAT
name|newcat
parameter_list|)
block|{
return|return
name|_catUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|oldcat
argument_list|,
name|newcat
argument_list|)
return|;
block|}
comment|// Hash spreader
DECL|method|hash
specifier|private
specifier|static
specifier|final
name|int
name|hash
parameter_list|()
block|{
name|int
name|h
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
decl_stmt|;
comment|// You would think that System.identityHashCode on the current thread
comment|// would be a good hash fcn, but actually on SunOS 5.8 it is pretty lousy
comment|// in the low bits.
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|20
operator|)
operator|^
operator|(
name|h
operator|>>>
literal|12
operator|)
expr_stmt|;
comment|// Bit spreader, borrowed from Doug Lea
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|7
operator|)
operator|^
operator|(
name|h
operator|>>>
literal|4
operator|)
expr_stmt|;
return|return
name|h
operator|<<
literal|2
return|;
comment|// Pad out cache lines.  The goal is to avoid cache-line contention
block|}
comment|// --- CAT -----------------------------------------------------------------
DECL|class|CAT
specifier|private
specifier|static
class|class
name|CAT
implements|implements
name|Serializable
block|{
comment|// Unsafe crud: get a function which will CAS arrays
DECL|field|_unsafe
specifier|private
specifier|static
specifier|final
name|Unsafe
name|_unsafe
init|=
name|UtilUnsafe
operator|.
name|getUnsafe
argument_list|()
decl_stmt|;
DECL|field|_Lbase
specifier|private
specifier|static
specifier|final
name|int
name|_Lbase
init|=
name|_unsafe
operator|.
name|arrayBaseOffset
argument_list|(
name|long
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|_Lscale
specifier|private
specifier|static
specifier|final
name|int
name|_Lscale
init|=
name|_unsafe
operator|.
name|arrayIndexScale
argument_list|(
name|long
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|rawIndex
specifier|private
specifier|static
name|long
name|rawIndex
parameter_list|(
name|long
index|[]
name|ary
parameter_list|,
name|int
name|i
parameter_list|)
block|{
assert|assert
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|ary
operator|.
name|length
assert|;
return|return
name|_Lbase
operator|+
name|i
operator|*
name|_Lscale
return|;
block|}
DECL|method|CAS
specifier|private
specifier|final
specifier|static
name|boolean
name|CAS
parameter_list|(
name|long
index|[]
name|A
parameter_list|,
name|int
name|idx
parameter_list|,
name|long
name|old
parameter_list|,
name|long
name|nnn
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapLong
argument_list|(
name|A
argument_list|,
name|rawIndex
argument_list|(
name|A
argument_list|,
name|idx
argument_list|)
argument_list|,
name|old
argument_list|,
name|nnn
argument_list|)
return|;
block|}
DECL|field|_resizers
specifier|volatile
name|long
name|_resizers
decl_stmt|;
comment|// count of threads attempting a resize
DECL|field|_resizerUpdater
specifier|static
specifier|private
specifier|final
name|AtomicLongFieldUpdater
argument_list|<
name|CAT
argument_list|>
name|_resizerUpdater
init|=
name|AtomicLongFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CAT
operator|.
name|class
argument_list|,
literal|"_resizers"
argument_list|)
decl_stmt|;
DECL|field|_next
specifier|private
specifier|final
name|CAT
name|_next
decl_stmt|;
DECL|field|_sum_cache
specifier|private
specifier|volatile
name|long
name|_sum_cache
decl_stmt|;
DECL|field|_fuzzy_sum_cache
specifier|private
specifier|volatile
name|long
name|_fuzzy_sum_cache
decl_stmt|;
DECL|field|_fuzzy_time
specifier|private
specifier|volatile
name|long
name|_fuzzy_time
decl_stmt|;
DECL|field|MAX_SPIN
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SPIN
init|=
literal|2
decl_stmt|;
DECL|field|_t
specifier|private
name|long
index|[]
name|_t
decl_stmt|;
comment|// Power-of-2 array of longs
DECL|method|CAT
name|CAT
parameter_list|(
name|CAT
name|next
parameter_list|,
name|int
name|sz
parameter_list|,
name|long
name|init
parameter_list|)
block|{
name|_next
operator|=
name|next
expr_stmt|;
name|_sum_cache
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
name|_t
operator|=
operator|new
name|long
index|[
name|sz
index|]
expr_stmt|;
name|_t
index|[
literal|0
index|]
operator|=
name|init
expr_stmt|;
block|}
comment|// Only add 'x' to some slot in table, hinted at by 'hash', if bits under
comment|// the mask are all zero.  The sum can overflow or 'x' can contain bits in
comment|// the mask.  Value is CAS'd so no counts are lost.  The CAS is attempted
comment|// ONCE.
DECL|method|add_if_mask
specifier|public
name|long
name|add_if_mask
parameter_list|(
name|long
name|x
parameter_list|,
name|long
name|mask
parameter_list|,
name|int
name|hash
parameter_list|,
name|ConcurrentAutoTable
name|master
parameter_list|)
block|{
name|long
index|[]
name|t
init|=
name|_t
decl_stmt|;
name|int
name|idx
init|=
name|hash
operator|&
operator|(
name|t
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
comment|// Peel loop; try once fast
name|long
name|old
init|=
name|t
index|[
name|idx
index|]
decl_stmt|;
name|boolean
name|ok
init|=
name|CAS
argument_list|(
name|t
argument_list|,
name|idx
argument_list|,
name|old
operator|&
operator|~
name|mask
argument_list|,
name|old
operator|+
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|_sum_cache
operator|!=
name|Long
operator|.
name|MIN_VALUE
condition|)
name|_sum_cache
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
comment|// Blow out cache
if|if
condition|(
name|ok
condition|)
return|return
name|old
return|;
comment|// Got it
if|if
condition|(
operator|(
name|old
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
return|return
name|old
return|;
comment|// Failed for bit-set under mask
comment|// Try harder
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|old
operator|=
name|t
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|old
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
return|return
name|old
return|;
comment|// Failed for bit-set under mask
if|if
condition|(
name|CAS
argument_list|(
name|t
argument_list|,
name|idx
argument_list|,
name|old
argument_list|,
name|old
operator|+
name|x
argument_list|)
condition|)
break|break;
comment|// Got it!
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
name|MAX_SPIN
condition|)
return|return
name|old
return|;
comment|// Allowable spin loop count
if|if
condition|(
name|t
operator|.
name|length
operator|>=
literal|1024
operator|*
literal|1024
condition|)
return|return
name|old
return|;
comment|// too big already
comment|// Too much contention; double array size in an effort to reduce contention
name|long
name|r
init|=
name|_resizers
decl_stmt|;
name|int
name|newbytes
init|=
operator|(
name|t
operator|.
name|length
operator|<<
literal|1
operator|)
operator|<<
literal|3
comment|/*word to bytes*/
decl_stmt|;
while|while
condition|(
operator|!
name|_resizerUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|r
argument_list|,
name|r
operator|+
name|newbytes
argument_list|)
condition|)
name|r
operator|=
name|_resizers
expr_stmt|;
name|r
operator|+=
name|newbytes
expr_stmt|;
if|if
condition|(
name|master
operator|.
name|_cat
operator|!=
name|this
condition|)
return|return
name|old
return|;
comment|// Already doubled, don't bother
if|if
condition|(
operator|(
name|r
operator|>>
literal|17
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// Already too much allocation attempts?
comment|// TODO - use a wait with timeout, so we'll wakeup as soon as the new
comment|// table is ready, or after the timeout in any case.  Annoyingly, this
comment|// breaks the non-blocking property - so for now we just briefly sleep.
comment|//synchronized( this ) { wait(8*megs); }         // Timeout - we always wakeup
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
name|r
operator|>>
literal|17
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{                 }
if|if
condition|(
name|master
operator|.
name|_cat
operator|!=
name|this
condition|)
return|return
name|old
return|;
block|}
name|CAT
name|newcat
init|=
operator|new
name|CAT
argument_list|(
name|this
argument_list|,
name|t
operator|.
name|length
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|// Take 1 stab at updating the CAT with the new larger size.  If this
comment|// fails, we assume some other thread already expanded the CAT - so we
comment|// do not need to retry until it succeeds.
name|master
operator|.
name|CAS_cat
argument_list|(
name|this
argument_list|,
name|newcat
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
comment|// Return the current sum of all things in the table, stripping off mask
comment|// before the add.  Writers can be updating the table furiously, so the
comment|// sum is only locally accurate.
DECL|method|sum
specifier|public
name|long
name|sum
parameter_list|(
name|long
name|mask
parameter_list|)
block|{
name|long
name|sum
init|=
name|_sum_cache
decl_stmt|;
if|if
condition|(
name|sum
operator|!=
name|Long
operator|.
name|MIN_VALUE
condition|)
return|return
name|sum
return|;
name|sum
operator|=
name|_next
operator|==
literal|null
condition|?
literal|0
else|:
name|_next
operator|.
name|sum
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|// Recursively get cached sum
name|long
index|[]
name|t
init|=
name|_t
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|t
index|[
name|i
index|]
operator|&
operator|(
operator|~
name|mask
operator|)
expr_stmt|;
name|_sum_cache
operator|=
name|sum
expr_stmt|;
comment|// Cache includes recursive counts
return|return
name|sum
return|;
block|}
comment|// Fast fuzzy version.  Used a cached value until it gets old, then re-up
comment|// the cache.
DECL|method|estimate_sum
specifier|public
name|long
name|estimate_sum
parameter_list|(
name|long
name|mask
parameter_list|)
block|{
comment|// For short tables, just do the work
if|if
condition|(
name|_t
operator|.
name|length
operator|<=
literal|64
condition|)
return|return
name|sum
argument_list|(
name|mask
argument_list|)
return|;
comment|// For bigger tables, periodically freshen a cached value
name|long
name|millis
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
if|if
condition|(
name|_fuzzy_time
operator|!=
name|millis
condition|)
block|{
comment|// Time marches on?
name|_fuzzy_sum_cache
operator|=
name|sum
argument_list|(
name|mask
argument_list|)
expr_stmt|;
comment|// Get sum the hard way
name|_fuzzy_time
operator|=
name|millis
expr_stmt|;
comment|// Indicate freshness of cached value
block|}
return|return
name|_fuzzy_sum_cache
return|;
comment|// Return cached sum
block|}
comment|// Update all table slots with CAS.
DECL|method|all_or
specifier|public
name|void
name|all_or
parameter_list|(
name|long
name|mask
parameter_list|)
block|{
name|long
index|[]
name|t
init|=
name|_t
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|long
name|old
init|=
name|t
index|[
name|i
index|]
decl_stmt|;
name|done
operator|=
name|CAS
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|old
argument_list|,
name|old
operator||
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_next
operator|!=
literal|null
condition|)
name|_next
operator|.
name|all_or
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|_sum_cache
operator|!=
name|Long
operator|.
name|MIN_VALUE
condition|)
name|_sum_cache
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
comment|// Blow out cache
block|}
DECL|method|all_and
specifier|public
name|void
name|all_and
parameter_list|(
name|long
name|mask
parameter_list|)
block|{
name|long
index|[]
name|t
init|=
name|_t
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|boolean
name|done
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|long
name|old
init|=
name|t
index|[
name|i
index|]
decl_stmt|;
name|done
operator|=
name|CAS
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|old
argument_list|,
name|old
operator|&
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_next
operator|!=
literal|null
condition|)
name|_next
operator|.
name|all_and
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|_sum_cache
operator|!=
name|Long
operator|.
name|MIN_VALUE
condition|)
name|_sum_cache
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
comment|// Blow out cache
block|}
comment|// Set/stomp all table slots.  No CAS.
DECL|method|all_set
specifier|public
name|void
name|all_set
parameter_list|(
name|long
name|val
parameter_list|)
block|{
name|long
index|[]
name|t
init|=
name|_t
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|t
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|t
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|_next
operator|!=
literal|null
condition|)
name|_next
operator|.
name|all_set
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|_sum_cache
operator|!=
name|Long
operator|.
name|MIN_VALUE
condition|)
name|_sum_cache
operator|=
name|Long
operator|.
name|MIN_VALUE
expr_stmt|;
comment|// Blow out cache
block|}
DECL|method|toString
name|String
name|toString
parameter_list|(
name|long
name|mask
parameter_list|)
block|{
return|return
name|Long
operator|.
name|toString
argument_list|(
name|sum
argument_list|(
name|mask
argument_list|)
argument_list|)
return|;
block|}
DECL|method|print
specifier|public
name|void
name|print
parameter_list|()
block|{
name|long
index|[]
name|t
init|=
name|_t
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"[sum="
operator|+
name|_sum_cache
operator|+
literal|","
operator|+
name|t
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|t
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|","
operator|+
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|print
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_next
operator|!=
literal|null
condition|)
name|_next
operator|.
name|print
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

