begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|trove
operator|.
name|set
operator|.
name|hash
operator|.
name|THashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * @author kimchy (Shay Banon)  */
end_comment

begin_class
DECL|class|Strings
specifier|public
class|class
name|Strings
block|{
DECL|field|EMPTY_ARRAY
specifier|public
specifier|static
specifier|final
name|String
index|[]
name|EMPTY_ARRAY
init|=
operator|new
name|String
index|[
literal|0
index|]
decl_stmt|;
DECL|field|FOLDER_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|FOLDER_SEPARATOR
init|=
literal|"/"
decl_stmt|;
DECL|field|WINDOWS_FOLDER_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|WINDOWS_FOLDER_SEPARATOR
init|=
literal|"\\"
decl_stmt|;
DECL|field|TOP_PATH
specifier|private
specifier|static
specifier|final
name|String
name|TOP_PATH
init|=
literal|".."
decl_stmt|;
DECL|field|CURRENT_PATH
specifier|private
specifier|static
specifier|final
name|String
name|CURRENT_PATH
init|=
literal|"."
decl_stmt|;
DECL|field|EXTENSION_SEPARATOR
specifier|private
specifier|static
specifier|final
name|char
name|EXTENSION_SEPARATOR
init|=
literal|'.'
decl_stmt|;
comment|/**      * Splits a backslash escaped string on the separator.      *<p>      * Current backslash escaping supported:      *<br> \n \t \r \b \f are escaped the same as a Java String      *<br> Other characters following a backslash are produced verbatim (\c => c)      *      * @param s         the string to split      * @param separator the separator to split on      * @param decode    decode backslash escaping      */
DECL|method|splitSmart
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|splitSmart
parameter_list|(
name|String
name|s
parameter_list|,
name|String
name|separator
parameter_list|,
name|boolean
name|decode
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|s
operator|.
name|startsWith
argument_list|(
name|separator
argument_list|,
name|pos
argument_list|)
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
name|pos
operator|+=
name|separator
operator|.
name|length
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|char
name|ch
init|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|decode
condition|)
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
break|break;
comment|// ERROR, or let it go?
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|lst
return|;
block|}
DECL|method|splitWS
specifier|public
specifier|static
name|List
argument_list|<
name|String
argument_list|>
name|splitWS
parameter_list|(
name|String
name|s
parameter_list|,
name|boolean
name|decode
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|String
argument_list|>
name|lst
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|,
name|end
init|=
name|s
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|pos
operator|<
name|end
condition|)
block|{
name|char
name|ch
init|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|decode
condition|)
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|end
condition|)
break|break;
comment|// ERROR, or let it go?
name|ch
operator|=
name|s
operator|.
name|charAt
argument_list|(
name|pos
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
name|ch
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ch
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ch
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ch
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ch
operator|=
literal|'\f'
expr_stmt|;
break|break;
block|}
block|}
block|}
name|sb
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|lst
operator|.
name|add
argument_list|(
name|sb
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|lst
return|;
block|}
comment|//---------------------------------------------------------------------
comment|// General convenience methods for working with Strings
comment|//---------------------------------------------------------------------
comment|/**      * Check that the given CharSequence is neither<code>null</code> nor of length 0.      * Note: Will return<code>true</code> for a CharSequence that purely consists of whitespace.      *<p><pre>      * StringUtils.hasLength(null) = false      * StringUtils.hasLength("") = false      * StringUtils.hasLength(" ") = true      * StringUtils.hasLength("Hello") = true      *</pre>      *      * @param str the CharSequence to check (may be<code>null</code>)      * @return<code>true</code> if the CharSequence is not null and has length      * @see #hasText(String)      */
DECL|method|hasLength
specifier|public
specifier|static
name|boolean
name|hasLength
parameter_list|(
name|CharSequence
name|str
parameter_list|)
block|{
return|return
operator|(
name|str
operator|!=
literal|null
operator|&&
name|str
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
comment|/**      * Check that the given String is neither<code>null</code> nor of length 0.      * Note: Will return<code>true</code> for a String that purely consists of whitespace.      *      * @param str the String to check (may be<code>null</code>)      * @return<code>true</code> if the String is not null and has length      * @see #hasLength(CharSequence)      */
DECL|method|hasLength
specifier|public
specifier|static
name|boolean
name|hasLength
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|hasLength
argument_list|(
operator|(
name|CharSequence
operator|)
name|str
argument_list|)
return|;
block|}
comment|/**      * Check whether the given CharSequence has actual text.      * More specifically, returns<code>true</code> if the string not<code>null</code>,      * its length is greater than 0, and it contains at least one non-whitespace character.      *<p><pre>      * StringUtils.hasText(null) = false      * StringUtils.hasText("") = false      * StringUtils.hasText(" ") = false      * StringUtils.hasText("12345") = true      * StringUtils.hasText(" 12345 ") = true      *</pre>      *      * @param str the CharSequence to check (may be<code>null</code>)      * @return<code>true</code> if the CharSequence is not<code>null</code>,      *         its length is greater than 0, and it does not contain whitespace only      * @see java.lang.Character#isWhitespace      */
DECL|method|hasText
specifier|public
specifier|static
name|boolean
name|hasText
parameter_list|(
name|CharSequence
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|strLen
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|Character
operator|.
name|isWhitespace
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Check whether the given String has actual text.      * More specifically, returns<code>true</code> if the string not<code>null</code>,      * its length is greater than 0, and it contains at least one non-whitespace character.      *      * @param str the String to check (may be<code>null</code>)      * @return<code>true</code> if the String is not<code>null</code>, its length is      *         greater than 0, and it does not contain whitespace only      * @see #hasText(CharSequence)      */
DECL|method|hasText
specifier|public
specifier|static
name|boolean
name|hasText
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|hasText
argument_list|(
operator|(
name|CharSequence
operator|)
name|str
argument_list|)
return|;
block|}
comment|/**      * Check whether the given CharSequence contains any whitespace characters.      *      * @param str the CharSequence to check (may be<code>null</code>)      * @return<code>true</code> if the CharSequence is not empty and      *         contains at least 1 whitespace character      * @see java.lang.Character#isWhitespace      */
DECL|method|containsWhitespace
specifier|public
specifier|static
name|boolean
name|containsWhitespace
parameter_list|(
name|CharSequence
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|int
name|strLen
init|=
name|str
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|strLen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Check whether the given String contains any whitespace characters.      *      * @param str the String to check (may be<code>null</code>)      * @return<code>true</code> if the String is not empty and      *         contains at least 1 whitespace character      * @see #containsWhitespace(CharSequence)      */
DECL|method|containsWhitespace
specifier|public
specifier|static
name|boolean
name|containsWhitespace
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|containsWhitespace
argument_list|(
operator|(
name|CharSequence
operator|)
name|str
argument_list|)
return|;
block|}
comment|/**      * Trim leading and trailing whitespace from the given String.      *      * @param str the String to check      * @return the trimmed String      * @see java.lang.Character#isWhitespace      */
DECL|method|trimWhitespace
specifier|public
specifier|static
name|String
name|trimWhitespace
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim<i>all</i> whitespace from the given String:      * leading, trailing, and inbetween characters.      *      * @param str the String to check      * @return the trimmed String      * @see java.lang.Character#isWhitespace      */
DECL|method|trimAllWhitespace
specifier|public
specifier|static
name|String
name|trimAllWhitespace
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
name|index
condition|)
block|{
if|if
condition|(
name|Character
operator|.
name|isWhitespace
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
argument_list|)
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim leading whitespace from the given String.      *      * @param str the String to check      * @return the trimmed String      * @see java.lang.Character#isWhitespace      */
DECL|method|trimLeadingWhitespace
specifier|public
specifier|static
name|String
name|trimLeadingWhitespace
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim trailing whitespace from the given String.      *      * @param str the String to check      * @return the trimmed String      * @see java.lang.Character#isWhitespace      */
DECL|method|trimTrailingWhitespace
specifier|public
specifier|static
name|String
name|trimTrailingWhitespace
parameter_list|(
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|Character
operator|.
name|isWhitespace
argument_list|(
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim all occurences of the supplied leading character from the given String.      *      * @param str              the String to check      * @param leadingCharacter the leading character to be trimmed      * @return the trimmed String      */
DECL|method|trimLeadingCharacter
specifier|public
specifier|static
name|String
name|trimLeadingCharacter
parameter_list|(
name|String
name|str
parameter_list|,
name|char
name|leadingCharacter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|sb
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
name|leadingCharacter
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Trim all occurences of the supplied trailing character from the given String.      *      * @param str               the String to check      * @param trailingCharacter the trailing character to be trimmed      * @return the trimmed String      */
DECL|method|trimTrailingCharacter
specifier|public
specifier|static
name|String
name|trimTrailingCharacter
parameter_list|(
name|String
name|str
parameter_list|,
name|char
name|trailingCharacter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|str
argument_list|)
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
argument_list|)
decl_stmt|;
while|while
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|sb
operator|.
name|charAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
operator|==
name|trailingCharacter
condition|)
block|{
name|sb
operator|.
name|deleteCharAt
argument_list|(
name|sb
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Test if the given String starts with the specified prefix,      * ignoring upper/lower case.      *      * @param str    the String to check      * @param prefix the prefix to look for      * @see java.lang.String#startsWith      */
DECL|method|startsWithIgnoreCase
specifier|public
specifier|static
name|boolean
name|startsWithIgnoreCase
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|prefix
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|str
operator|.
name|startsWith
argument_list|(
name|prefix
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|<
name|prefix
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|lcStr
init|=
name|str
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|prefix
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|lcPrefix
init|=
name|prefix
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
return|return
name|lcStr
operator|.
name|equals
argument_list|(
name|lcPrefix
argument_list|)
return|;
block|}
comment|/**      * Test if the given String ends with the specified suffix,      * ignoring upper/lower case.      *      * @param str    the String to check      * @param suffix the suffix to look for      * @see java.lang.String#endsWith      */
DECL|method|endsWithIgnoreCase
specifier|public
specifier|static
name|boolean
name|endsWithIgnoreCase
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|suffix
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|suffix
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|str
operator|.
name|endsWith
argument_list|(
name|suffix
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|<
name|suffix
operator|.
name|length
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|String
name|lcStr
init|=
name|str
operator|.
name|substring
argument_list|(
name|str
operator|.
name|length
argument_list|()
operator|-
name|suffix
operator|.
name|length
argument_list|()
argument_list|)
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
name|String
name|lcSuffix
init|=
name|suffix
operator|.
name|toLowerCase
argument_list|()
decl_stmt|;
return|return
name|lcStr
operator|.
name|equals
argument_list|(
name|lcSuffix
argument_list|)
return|;
block|}
comment|/**      * Test whether the given string matches the given substring      * at the given index.      *      * @param str       the original string (or StringBuilder)      * @param index     the index in the original string to start matching against      * @param substring the substring to match at the given index      */
DECL|method|substringMatch
specifier|public
specifier|static
name|boolean
name|substringMatch
parameter_list|(
name|CharSequence
name|str
parameter_list|,
name|int
name|index
parameter_list|,
name|CharSequence
name|substring
parameter_list|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|substring
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
name|int
name|i
init|=
name|index
operator|+
name|j
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|str
operator|.
name|length
argument_list|()
operator|||
name|str
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
operator|!=
name|substring
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Count the occurrences of the substring in string s.      *      * @param str string to search in. Return 0 if this is null.      * @param sub string to search for. Return 0 if this is null.      */
DECL|method|countOccurrencesOf
specifier|public
specifier|static
name|int
name|countOccurrencesOf
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|sub
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|sub
operator|==
literal|null
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|sub
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
while|while
condition|(
operator|(
name|idx
operator|=
name|str
operator|.
name|indexOf
argument_list|(
name|sub
argument_list|,
name|pos
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|pos
operator|=
name|idx
operator|+
name|sub
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**      * Replace all occurences of a substring within a string with      * another string.      *      * @param inString   String to examine      * @param oldPattern String to replace      * @param newPattern String to insert      * @return a String with the replacements      */
DECL|method|replace
specifier|public
specifier|static
name|String
name|replace
parameter_list|(
name|String
name|inString
parameter_list|,
name|String
name|oldPattern
parameter_list|,
name|String
name|newPattern
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|inString
argument_list|)
operator|||
operator|!
name|hasLength
argument_list|(
name|oldPattern
argument_list|)
operator|||
name|newPattern
operator|==
literal|null
condition|)
block|{
return|return
name|inString
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// our position in the old string
name|int
name|index
init|=
name|inString
operator|.
name|indexOf
argument_list|(
name|oldPattern
argument_list|)
decl_stmt|;
comment|// the index of an occurrence we've found, or -1
name|int
name|patLen
init|=
name|oldPattern
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|>=
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|inString
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|newPattern
argument_list|)
expr_stmt|;
name|pos
operator|=
name|index
operator|+
name|patLen
expr_stmt|;
name|index
operator|=
name|inString
operator|.
name|indexOf
argument_list|(
name|oldPattern
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|inString
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|)
expr_stmt|;
comment|// remember to append any characters to the right of a match
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Delete all occurrences of the given substring.      *      * @param inString the original String      * @param pattern  the pattern to delete all occurrences of      * @return the resulting String      */
DECL|method|delete
specifier|public
specifier|static
name|String
name|delete
parameter_list|(
name|String
name|inString
parameter_list|,
name|String
name|pattern
parameter_list|)
block|{
return|return
name|replace
argument_list|(
name|inString
argument_list|,
name|pattern
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * Delete any character in a given String.      *      * @param inString      the original String      * @param charsToDelete a set of characters to delete.      *                      E.g. "az\n" will delete 'a's, 'z's and new lines.      * @return the resulting String      */
DECL|method|deleteAny
specifier|public
specifier|static
name|String
name|deleteAny
parameter_list|(
name|String
name|inString
parameter_list|,
name|String
name|charsToDelete
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|inString
argument_list|)
operator|||
operator|!
name|hasLength
argument_list|(
name|charsToDelete
argument_list|)
condition|)
block|{
return|return
name|inString
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|inString
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|inString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|charsToDelete
operator|.
name|indexOf
argument_list|(
name|c
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|//---------------------------------------------------------------------
comment|// Convenience methods for working with formatted Strings
comment|//---------------------------------------------------------------------
comment|/**      * Quote the given String with single quotes.      *      * @param str the input String (e.g. "myString")      * @return the quoted String (e.g. "'myString'"),      *         or<code>null<code> if the input was<code>null</code>      */
DECL|method|quote
specifier|public
specifier|static
name|String
name|quote
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
operator|(
name|str
operator|!=
literal|null
condition|?
literal|"'"
operator|+
name|str
operator|+
literal|"'"
else|:
literal|null
operator|)
return|;
block|}
comment|/**      * Turn the given Object into a String with single quotes      * if it is a String; keeping the Object as-is else.      *      * @param obj the input Object (e.g. "myString")      * @return the quoted String (e.g. "'myString'"),      *         or the input object as-is if not a String      */
DECL|method|quoteIfString
specifier|public
specifier|static
name|Object
name|quoteIfString
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
operator|(
name|obj
operator|instanceof
name|String
condition|?
name|quote
argument_list|(
operator|(
name|String
operator|)
name|obj
argument_list|)
else|:
name|obj
operator|)
return|;
block|}
comment|/**      * Unqualify a string qualified by a '.' dot character. For example,      * "this.name.is.qualified", returns "qualified".      *      * @param qualifiedName the qualified name      */
DECL|method|unqualify
specifier|public
specifier|static
name|String
name|unqualify
parameter_list|(
name|String
name|qualifiedName
parameter_list|)
block|{
return|return
name|unqualify
argument_list|(
name|qualifiedName
argument_list|,
literal|'.'
argument_list|)
return|;
block|}
comment|/**      * Unqualify a string qualified by a separator character. For example,      * "this:name:is:qualified" returns "qualified" if using a ':' separator.      *      * @param qualifiedName the qualified name      * @param separator     the separator      */
DECL|method|unqualify
specifier|public
specifier|static
name|String
name|unqualify
parameter_list|(
name|String
name|qualifiedName
parameter_list|,
name|char
name|separator
parameter_list|)
block|{
return|return
name|qualifiedName
operator|.
name|substring
argument_list|(
name|qualifiedName
operator|.
name|lastIndexOf
argument_list|(
name|separator
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
comment|/**      * Capitalize a<code>String</code>, changing the first letter to      * upper case as per {@link Character#toUpperCase(char)}.      * No other letters are changed.      *      * @param str the String to capitalize, may be<code>null</code>      * @return the capitalized String,<code>null</code> if null      */
DECL|method|capitalize
specifier|public
specifier|static
name|String
name|capitalize
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|changeFirstCharacterCase
argument_list|(
name|str
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Uncapitalize a<code>String</code>, changing the first letter to      * lower case as per {@link Character#toLowerCase(char)}.      * No other letters are changed.      *      * @param str the String to uncapitalize, may be<code>null</code>      * @return the uncapitalized String,<code>null</code> if null      */
DECL|method|uncapitalize
specifier|public
specifier|static
name|String
name|uncapitalize
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|changeFirstCharacterCase
argument_list|(
name|str
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|changeFirstCharacterCase
specifier|private
specifier|static
name|String
name|changeFirstCharacterCase
parameter_list|(
name|String
name|str
parameter_list|,
name|boolean
name|capitalize
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
operator|||
name|str
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|str
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
name|str
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|capitalize
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|str
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|str
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|field|INVALID_FILENAME_CHARS
specifier|public
specifier|static
specifier|final
name|ImmutableSet
argument_list|<
name|Character
argument_list|>
name|INVALID_FILENAME_CHARS
init|=
name|ImmutableSet
operator|.
name|of
argument_list|(
literal|'\\'
argument_list|,
literal|'/'
argument_list|,
literal|'*'
argument_list|,
literal|'?'
argument_list|,
literal|'"'
argument_list|,
literal|'<'
argument_list|,
literal|'>'
argument_list|,
literal|'|'
argument_list|,
literal|' '
argument_list|,
literal|','
argument_list|)
decl_stmt|;
DECL|method|validFileName
specifier|public
specifier|static
name|boolean
name|validFileName
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileName
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|fileName
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|INVALID_FILENAME_CHARS
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|validFileNameExcludingAstrix
specifier|public
specifier|static
name|boolean
name|validFileNameExcludingAstrix
parameter_list|(
name|String
name|fileName
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileName
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|fileName
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
operator|&&
name|INVALID_FILENAME_CHARS
operator|.
name|contains
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Extract the filename from the given path,      * e.g. "mypath/myfile.txt" -> "myfile.txt".      *      * @param path the file path (may be<code>null</code>)      * @return the extracted filename, or<code>null</code> if none      */
DECL|method|getFilename
specifier|public
specifier|static
name|String
name|getFilename
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|separatorIndex
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
name|FOLDER_SEPARATOR
argument_list|)
decl_stmt|;
return|return
operator|(
name|separatorIndex
operator|!=
operator|-
literal|1
condition|?
name|path
operator|.
name|substring
argument_list|(
name|separatorIndex
operator|+
literal|1
argument_list|)
else|:
name|path
operator|)
return|;
block|}
comment|/**      * Extract the filename extension from the given path,      * e.g. "mypath/myfile.txt" -> "txt".      *      * @param path the file path (may be<code>null</code>)      * @return the extracted filename extension, or<code>null</code> if none      */
DECL|method|getFilenameExtension
specifier|public
specifier|static
name|String
name|getFilenameExtension
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|sepIndex
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
name|EXTENSION_SEPARATOR
argument_list|)
decl_stmt|;
return|return
operator|(
name|sepIndex
operator|!=
operator|-
literal|1
condition|?
name|path
operator|.
name|substring
argument_list|(
name|sepIndex
operator|+
literal|1
argument_list|)
else|:
literal|null
operator|)
return|;
block|}
comment|/**      * Strip the filename extension from the given path,      * e.g. "mypath/myfile.txt" -> "mypath/myfile".      *      * @param path the file path (may be<code>null</code>)      * @return the path with stripped filename extension,      *         or<code>null</code> if none      */
DECL|method|stripFilenameExtension
specifier|public
specifier|static
name|String
name|stripFilenameExtension
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|sepIndex
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
name|EXTENSION_SEPARATOR
argument_list|)
decl_stmt|;
return|return
operator|(
name|sepIndex
operator|!=
operator|-
literal|1
condition|?
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|sepIndex
argument_list|)
else|:
name|path
operator|)
return|;
block|}
comment|/**      * Apply the given relative path to the given path,      * assuming standard Java folder separation (i.e. "/" separators);      *      * @param path         the path to start from (usually a full file path)      * @param relativePath the relative path to apply      *                     (relative to the full file path above)      * @return the full file path that results from applying the relative path      */
DECL|method|applyRelativePath
specifier|public
specifier|static
name|String
name|applyRelativePath
parameter_list|(
name|String
name|path
parameter_list|,
name|String
name|relativePath
parameter_list|)
block|{
name|int
name|separatorIndex
init|=
name|path
operator|.
name|lastIndexOf
argument_list|(
name|FOLDER_SEPARATOR
argument_list|)
decl_stmt|;
if|if
condition|(
name|separatorIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
name|newPath
init|=
name|path
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|separatorIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|relativePath
operator|.
name|startsWith
argument_list|(
name|FOLDER_SEPARATOR
argument_list|)
condition|)
block|{
name|newPath
operator|+=
name|FOLDER_SEPARATOR
expr_stmt|;
block|}
return|return
name|newPath
operator|+
name|relativePath
return|;
block|}
else|else
block|{
return|return
name|relativePath
return|;
block|}
block|}
comment|/**      * Normalize the path by suppressing sequences like "path/.." and      * inner simple dots.      *<p>The result is convenient for path comparison. For other uses,      * notice that Windows separators ("\") are replaced by simple slashes.      *      * @param path the original path      * @return the normalized path      */
DECL|method|cleanPath
specifier|public
specifier|static
name|String
name|cleanPath
parameter_list|(
name|String
name|path
parameter_list|)
block|{
if|if
condition|(
name|path
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|pathToUse
init|=
name|replace
argument_list|(
name|path
argument_list|,
name|WINDOWS_FOLDER_SEPARATOR
argument_list|,
name|FOLDER_SEPARATOR
argument_list|)
decl_stmt|;
comment|// Strip prefix from path to analyze, to not treat it as part of the
comment|// first path element. This is necessary to correctly parse paths like
comment|// "file:core/../core/io/Resource.class", where the ".." should just
comment|// strip the first "core" directory while keeping the "file:" prefix.
name|int
name|prefixIndex
init|=
name|pathToUse
operator|.
name|indexOf
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|String
name|prefix
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|prefixIndex
operator|!=
operator|-
literal|1
condition|)
block|{
name|prefix
operator|=
name|pathToUse
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|prefixIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pathToUse
operator|=
name|pathToUse
operator|.
name|substring
argument_list|(
name|prefixIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pathToUse
operator|.
name|startsWith
argument_list|(
name|FOLDER_SEPARATOR
argument_list|)
condition|)
block|{
name|prefix
operator|=
name|prefix
operator|+
name|FOLDER_SEPARATOR
expr_stmt|;
name|pathToUse
operator|=
name|pathToUse
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|pathArray
init|=
name|delimitedListToStringArray
argument_list|(
name|pathToUse
argument_list|,
name|FOLDER_SEPARATOR
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|pathElements
init|=
operator|new
name|LinkedList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|tops
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|pathArray
operator|.
name|length
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|String
name|element
init|=
name|pathArray
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|CURRENT_PATH
operator|.
name|equals
argument_list|(
name|element
argument_list|)
condition|)
block|{
comment|// Points to current directory - drop it.
block|}
elseif|else
if|if
condition|(
name|TOP_PATH
operator|.
name|equals
argument_list|(
name|element
argument_list|)
condition|)
block|{
comment|// Registering top path found.
name|tops
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tops
operator|>
literal|0
condition|)
block|{
comment|// Merging path element with element corresponding to top path.
name|tops
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|// Normal path element found.
name|pathElements
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Remaining top paths need to be retained.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tops
condition|;
name|i
operator|++
control|)
block|{
name|pathElements
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|TOP_PATH
argument_list|)
expr_stmt|;
block|}
return|return
name|prefix
operator|+
name|collectionToDelimitedString
argument_list|(
name|pathElements
argument_list|,
name|FOLDER_SEPARATOR
argument_list|)
return|;
block|}
comment|/**      * Compare two paths after normalization of them.      *      * @param path1 first path for comparison      * @param path2 second path for comparison      * @return whether the two paths are equivalent after normalization      */
DECL|method|pathEquals
specifier|public
specifier|static
name|boolean
name|pathEquals
parameter_list|(
name|String
name|path1
parameter_list|,
name|String
name|path2
parameter_list|)
block|{
return|return
name|cleanPath
argument_list|(
name|path1
argument_list|)
operator|.
name|equals
argument_list|(
name|cleanPath
argument_list|(
name|path2
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Parse the given<code>localeString</code> into a {@link Locale}.      *<p>This is the inverse operation of {@link Locale#toString Locale's toString}.      *      * @param localeString the locale string, following<code>Locale's</code>      *<code>toString()</code> format ("en", "en_UK", etc);      *                     also accepts spaces as separators, as an alternative to underscores      * @return a corresponding<code>Locale</code> instance      */
DECL|method|parseLocaleString
specifier|public
specifier|static
name|Locale
name|parseLocaleString
parameter_list|(
name|String
name|localeString
parameter_list|)
block|{
name|String
index|[]
name|parts
init|=
name|tokenizeToStringArray
argument_list|(
name|localeString
argument_list|,
literal|"_ "
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
decl_stmt|;
name|String
name|language
init|=
operator|(
name|parts
operator|.
name|length
operator|>
literal|0
condition|?
name|parts
index|[
literal|0
index|]
else|:
literal|""
operator|)
decl_stmt|;
name|String
name|country
init|=
operator|(
name|parts
operator|.
name|length
operator|>
literal|1
condition|?
name|parts
index|[
literal|1
index|]
else|:
literal|""
operator|)
decl_stmt|;
name|String
name|variant
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|length
operator|>=
literal|2
condition|)
block|{
comment|// There is definitely a variant, and it is everything after the country
comment|// code sans the separator between the country code and the variant.
name|int
name|endIndexOfCountryCode
init|=
name|localeString
operator|.
name|indexOf
argument_list|(
name|country
argument_list|)
operator|+
name|country
operator|.
name|length
argument_list|()
decl_stmt|;
comment|// Strip off any leading '_' and whitespace, what's left is the variant.
name|variant
operator|=
name|trimLeadingWhitespace
argument_list|(
name|localeString
operator|.
name|substring
argument_list|(
name|endIndexOfCountryCode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|variant
operator|.
name|startsWith
argument_list|(
literal|"_"
argument_list|)
condition|)
block|{
name|variant
operator|=
name|trimLeadingCharacter
argument_list|(
name|variant
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|language
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|?
operator|new
name|Locale
argument_list|(
name|language
argument_list|,
name|country
argument_list|,
name|variant
argument_list|)
else|:
literal|null
operator|)
return|;
block|}
comment|/**      * Determine the RFC 3066 compliant language tag,      * as used for the HTTP "Accept-Language" header.      *      * @param locale the Locale to transform to a language tag      * @return the RFC 3066 compliant language tag as String      */
DECL|method|toLanguageTag
specifier|public
specifier|static
name|String
name|toLanguageTag
parameter_list|(
name|Locale
name|locale
parameter_list|)
block|{
return|return
name|locale
operator|.
name|getLanguage
argument_list|()
operator|+
operator|(
name|hasText
argument_list|(
name|locale
operator|.
name|getCountry
argument_list|()
argument_list|)
condition|?
literal|"-"
operator|+
name|locale
operator|.
name|getCountry
argument_list|()
else|:
literal|""
operator|)
return|;
block|}
comment|//---------------------------------------------------------------------
comment|// Convenience methods for working with String arrays
comment|//---------------------------------------------------------------------
comment|/**      * Append the given String to the given String array, returning a new array      * consisting of the input array contents plus the given String.      *      * @param array the array to append to (can be<code>null</code>)      * @param str   the String to append      * @return the new array (never<code>null</code>)      */
DECL|method|addStringToArray
specifier|public
specifier|static
name|String
index|[]
name|addStringToArray
parameter_list|(
name|String
index|[]
name|array
parameter_list|,
name|String
name|str
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|array
argument_list|)
condition|)
block|{
return|return
operator|new
name|String
index|[]
block|{
name|str
block|}
return|;
block|}
name|String
index|[]
name|newArr
init|=
operator|new
name|String
index|[
name|array
operator|.
name|length
operator|+
literal|1
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|array
argument_list|,
literal|0
argument_list|,
name|newArr
argument_list|,
literal|0
argument_list|,
name|array
operator|.
name|length
argument_list|)
expr_stmt|;
name|newArr
index|[
name|array
operator|.
name|length
index|]
operator|=
name|str
expr_stmt|;
return|return
name|newArr
return|;
block|}
comment|/**      * Concatenate the given String arrays into one,      * with overlapping array elements included twice.      *<p>The order of elements in the original arrays is preserved.      *      * @param array1 the first array (can be<code>null</code>)      * @param array2 the second array (can be<code>null</code>)      * @return the new array (<code>null</code> if both given arrays were<code>null</code>)      */
DECL|method|concatenateStringArrays
specifier|public
specifier|static
name|String
index|[]
name|concatenateStringArrays
parameter_list|(
name|String
index|[]
name|array1
parameter_list|,
name|String
index|[]
name|array2
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|array1
argument_list|)
condition|)
block|{
return|return
name|array2
return|;
block|}
if|if
condition|(
name|isEmpty
argument_list|(
name|array2
argument_list|)
condition|)
block|{
return|return
name|array1
return|;
block|}
name|String
index|[]
name|newArr
init|=
operator|new
name|String
index|[
name|array1
operator|.
name|length
operator|+
name|array2
operator|.
name|length
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|array1
argument_list|,
literal|0
argument_list|,
name|newArr
argument_list|,
literal|0
argument_list|,
name|array1
operator|.
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|array2
argument_list|,
literal|0
argument_list|,
name|newArr
argument_list|,
name|array1
operator|.
name|length
argument_list|,
name|array2
operator|.
name|length
argument_list|)
expr_stmt|;
return|return
name|newArr
return|;
block|}
comment|/**      * Merge the given String arrays into one, with overlapping      * array elements only included once.      *<p>The order of elements in the original arrays is preserved      * (with the exception of overlapping elements, which are only      * included on their first occurence).      *      * @param array1 the first array (can be<code>null</code>)      * @param array2 the second array (can be<code>null</code>)      * @return the new array (<code>null</code> if both given arrays were<code>null</code>)      */
DECL|method|mergeStringArrays
specifier|public
specifier|static
name|String
index|[]
name|mergeStringArrays
parameter_list|(
name|String
index|[]
name|array1
parameter_list|,
name|String
index|[]
name|array2
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|array1
argument_list|)
condition|)
block|{
return|return
name|array2
return|;
block|}
if|if
condition|(
name|isEmpty
argument_list|(
name|array2
argument_list|)
condition|)
block|{
return|return
name|array1
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|result
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|array1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|str
range|:
name|array2
control|)
block|{
if|if
condition|(
operator|!
name|result
operator|.
name|contains
argument_list|(
name|str
argument_list|)
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toStringArray
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Turn given source String array into sorted array.      *      * @param array the source array      * @return the sorted array (never<code>null</code>)      */
DECL|method|sortStringArray
specifier|public
specifier|static
name|String
index|[]
name|sortStringArray
parameter_list|(
name|String
index|[]
name|array
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|array
argument_list|)
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|array
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
comment|/**      * Copy the given Collection into a String array.      * The Collection must contain String elements only.      *      * @param collection the Collection to copy      * @return the String array (<code>null</code> if the passed-in      *         Collection was<code>null</code>)      */
DECL|method|toStringArray
specifier|public
specifier|static
name|String
index|[]
name|toStringArray
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|collection
parameter_list|)
block|{
if|if
condition|(
name|collection
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
return|return
name|collection
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|collection
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Copy the given Enumeration into a String array.      * The Enumeration must contain String elements only.      *      * @param enumeration the Enumeration to copy      * @return the String array (<code>null</code> if the passed-in      *         Enumeration was<code>null</code>)      */
DECL|method|toStringArray
specifier|public
specifier|static
name|String
index|[]
name|toStringArray
parameter_list|(
name|Enumeration
argument_list|<
name|String
argument_list|>
name|enumeration
parameter_list|)
block|{
if|if
condition|(
name|enumeration
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|list
init|=
name|Collections
operator|.
name|list
argument_list|(
name|enumeration
argument_list|)
decl_stmt|;
return|return
name|list
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|list
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Trim the elements of the given String array,      * calling<code>String.trim()</code> on each of them.      *      * @param array the original String array      * @return the resulting array (of the same size) with trimmed elements      */
DECL|method|trimArrayElements
specifier|public
specifier|static
name|String
index|[]
name|trimArrayElements
parameter_list|(
name|String
index|[]
name|array
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|array
argument_list|)
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
name|String
index|[]
name|result
init|=
operator|new
name|String
index|[
name|array
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|array
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|String
name|element
init|=
name|array
index|[
name|i
index|]
decl_stmt|;
name|result
index|[
name|i
index|]
operator|=
operator|(
name|element
operator|!=
literal|null
condition|?
name|element
operator|.
name|trim
argument_list|()
else|:
literal|null
operator|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Remove duplicate Strings from the given array.      * Also sorts the array, as it uses a TreeSet.      *      * @param array the String array      * @return an array without duplicates, in natural sort order      */
DECL|method|removeDuplicateStrings
specifier|public
specifier|static
name|String
index|[]
name|removeDuplicateStrings
parameter_list|(
name|String
index|[]
name|array
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|array
argument_list|)
condition|)
block|{
return|return
name|array
return|;
block|}
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|toStringArray
argument_list|(
name|set
argument_list|)
return|;
block|}
DECL|method|splitStringByCommaToSet
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|splitStringByCommaToSet
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
return|return
name|splitStringToSet
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
return|;
block|}
DECL|method|splitStringByCommaToArray
specifier|public
specifier|static
name|String
index|[]
name|splitStringByCommaToArray
parameter_list|(
specifier|final
name|String
name|s
parameter_list|)
block|{
return|return
name|splitStringToArray
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
return|;
block|}
DECL|method|splitStringToSet
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|splitStringToSet
parameter_list|(
specifier|final
name|String
name|s
parameter_list|,
specifier|final
name|char
name|c
parameter_list|)
block|{
specifier|final
name|char
index|[]
name|chars
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
for|for
control|(
specifier|final
name|char
name|x
range|:
name|chars
control|)
block|{
if|if
condition|(
name|x
operator|==
name|c
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
specifier|final
name|THashSet
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|THashSet
argument_list|<
name|String
argument_list|>
argument_list|(
name|count
argument_list|)
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|chars
operator|.
name|length
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
comment|// starting index in chars of the current substring.
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// current index in chars.
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// number of the current substring.
for|for
control|(
init|;
name|pos
operator|<
name|len
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|chars
index|[
name|pos
index|]
operator|==
name|c
condition|)
block|{
name|int
name|size
init|=
name|pos
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|// only add non empty strings
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|int
name|size
init|=
name|pos
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|splitStringToArray
specifier|public
specifier|static
name|String
index|[]
name|splitStringToArray
parameter_list|(
specifier|final
name|String
name|s
parameter_list|,
specifier|final
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|s
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|Strings
operator|.
name|EMPTY_ARRAY
return|;
block|}
specifier|final
name|char
index|[]
name|chars
init|=
name|s
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
for|for
control|(
specifier|final
name|char
name|x
range|:
name|chars
control|)
block|{
if|if
condition|(
name|x
operator|==
name|c
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
specifier|final
name|String
index|[]
name|result
init|=
operator|new
name|String
index|[
name|count
index|]
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|chars
operator|.
name|length
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|;
comment|// starting index in chars of the current substring.
name|int
name|pos
init|=
literal|0
decl_stmt|;
comment|// current index in chars.
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// number of the current substring.
for|for
control|(
init|;
name|pos
operator|<
name|len
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|chars
index|[
name|pos
index|]
operator|==
name|c
condition|)
block|{
name|int
name|size
init|=
name|pos
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|result
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|int
name|size
init|=
name|pos
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|result
index|[
name|i
operator|++
index|]
operator|=
operator|new
name|String
argument_list|(
name|chars
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|count
condition|)
block|{
comment|// we have empty strings, copy over to a new array
name|String
index|[]
name|result1
init|=
operator|new
name|String
index|[
name|i
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|result1
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|result1
return|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Split a String at the first occurrence of the delimiter.      * Does not include the delimiter in the result.      *      * @param toSplit   the string to split      * @param delimiter to split the string up with      * @return a two element array with index 0 being before the delimiter, and      *         index 1 being after the delimiter (neither element includes the delimiter);      *         or<code>null</code> if the delimiter wasn't found in the given input String      */
DECL|method|split
specifier|public
specifier|static
name|String
index|[]
name|split
parameter_list|(
name|String
name|toSplit
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasLength
argument_list|(
name|toSplit
argument_list|)
operator|||
operator|!
name|hasLength
argument_list|(
name|delimiter
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|int
name|offset
init|=
name|toSplit
operator|.
name|indexOf
argument_list|(
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
return|return
literal|null
return|;
block|}
name|String
name|beforeDelimiter
init|=
name|toSplit
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|String
name|afterDelimiter
init|=
name|toSplit
operator|.
name|substring
argument_list|(
name|offset
operator|+
name|delimiter
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|String
index|[]
block|{
name|beforeDelimiter
block|,
name|afterDelimiter
block|}
return|;
block|}
comment|/**      * Take an array Strings and split each element based on the given delimiter.      * A<code>Properties</code> instance is then generated, with the left of the      * delimiter providing the key, and the right of the delimiter providing the value.      *<p>Will trim both the key and value before adding them to the      *<code>Properties</code> instance.      *      * @param array     the array to process      * @param delimiter to split each element using (typically the equals symbol)      * @return a<code>Properties</code> instance representing the array contents,      *         or<code>null</code> if the array to process was null or empty      */
DECL|method|splitArrayElementsIntoProperties
specifier|public
specifier|static
name|Properties
name|splitArrayElementsIntoProperties
parameter_list|(
name|String
index|[]
name|array
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
return|return
name|splitArrayElementsIntoProperties
argument_list|(
name|array
argument_list|,
name|delimiter
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Take an array Strings and split each element based on the given delimiter.      * A<code>Properties</code> instance is then generated, with the left of the      * delimiter providing the key, and the right of the delimiter providing the value.      *<p>Will trim both the key and value before adding them to the      *<code>Properties</code> instance.      *      * @param array         the array to process      * @param delimiter     to split each element using (typically the equals symbol)      * @param charsToDelete one or more characters to remove from each element      *                      prior to attempting the split operation (typically the quotation mark      *                      symbol), or<code>null</code> if no removal should occur      * @return a<code>Properties</code> instance representing the array contents,      *         or<code>null</code> if the array to process was<code>null</code> or empty      */
DECL|method|splitArrayElementsIntoProperties
specifier|public
specifier|static
name|Properties
name|splitArrayElementsIntoProperties
parameter_list|(
name|String
index|[]
name|array
parameter_list|,
name|String
name|delimiter
parameter_list|,
name|String
name|charsToDelete
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|array
argument_list|)
condition|)
block|{
return|return
literal|null
return|;
block|}
name|Properties
name|result
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|element
range|:
name|array
control|)
block|{
if|if
condition|(
name|charsToDelete
operator|!=
literal|null
condition|)
block|{
name|element
operator|=
name|deleteAny
argument_list|(
name|element
argument_list|,
name|charsToDelete
argument_list|)
expr_stmt|;
block|}
name|String
index|[]
name|splittedElement
init|=
name|split
argument_list|(
name|element
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|splittedElement
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
name|result
operator|.
name|setProperty
argument_list|(
name|splittedElement
index|[
literal|0
index|]
operator|.
name|trim
argument_list|()
argument_list|,
name|splittedElement
index|[
literal|1
index|]
operator|.
name|trim
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Tokenize the given String into a String array via a StringTokenizer.      * Trims tokens and omits empty tokens.      *<p>The given delimiters string is supposed to consist of any number of      * delimiter characters. Each of those characters can be used to separate      * tokens. A delimiter is always a single character; for multi-character      * delimiters, consider using<code>delimitedListToStringArray</code>      *      * @param str        the String to tokenize      * @param delimiters the delimiter characters, assembled as String      *                   (each of those characters is individually considered as delimiter).      * @return an array of the tokens      * @see java.util.StringTokenizer      * @see java.lang.String#trim()      * @see #delimitedListToStringArray      */
DECL|method|tokenizeToStringArray
specifier|public
specifier|static
name|String
index|[]
name|tokenizeToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiters
parameter_list|)
block|{
return|return
name|tokenizeToStringArray
argument_list|(
name|str
argument_list|,
name|delimiters
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Tokenize the given String into a String array via a StringTokenizer.      *<p>The given delimiters string is supposed to consist of any number of      * delimiter characters. Each of those characters can be used to separate      * tokens. A delimiter is always a single character; for multi-character      * delimiters, consider using<code>delimitedListToStringArray</code>      *      * @param str               the String to tokenize      * @param delimiters        the delimiter characters, assembled as String      *                          (each of those characters is individually considered as delimiter)      * @param trimTokens        trim the tokens via String's<code>trim</code>      * @param ignoreEmptyTokens omit empty tokens from the result array      *                          (only applies to tokens that are empty after trimming; StringTokenizer      *                          will not consider subsequent delimiters as token in the first place).      * @return an array of the tokens (<code>null</code> if the input String      *         was<code>null</code>)      * @see java.util.StringTokenizer      * @see java.lang.String#trim()      * @see #delimitedListToStringArray      */
DECL|method|tokenizeToStringArray
specifier|public
specifier|static
name|String
index|[]
name|tokenizeToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiters
parameter_list|,
name|boolean
name|trimTokens
parameter_list|,
name|boolean
name|ignoreEmptyTokens
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
name|StringTokenizer
name|st
init|=
operator|new
name|StringTokenizer
argument_list|(
name|str
argument_list|,
name|delimiters
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|tokens
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
while|while
condition|(
name|st
operator|.
name|hasMoreTokens
argument_list|()
condition|)
block|{
name|String
name|token
init|=
name|st
operator|.
name|nextToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|trimTokens
condition|)
block|{
name|token
operator|=
name|token
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ignoreEmptyTokens
operator|||
name|token
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toStringArray
argument_list|(
name|tokens
argument_list|)
return|;
block|}
comment|/**      * Take a String which is a delimited list and convert it to a String array.      *<p>A single delimiter can consists of more than one character: It will still      * be considered as single delimiter string, rather than as bunch of potential      * delimiter characters - in contrast to<code>tokenizeToStringArray</code>.      *      * @param str       the input String      * @param delimiter the delimiter between elements (this is a single delimiter,      *                  rather than a bunch individual delimiter characters)      * @return an array of the tokens in the list      * @see #tokenizeToStringArray      */
DECL|method|delimitedListToStringArray
specifier|public
specifier|static
name|String
index|[]
name|delimitedListToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiter
parameter_list|)
block|{
return|return
name|delimitedListToStringArray
argument_list|(
name|str
argument_list|,
name|delimiter
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Take a String which is a delimited list and convert it to a String array.      *<p>A single delimiter can consists of more than one character: It will still      * be considered as single delimiter string, rather than as bunch of potential      * delimiter characters - in contrast to<code>tokenizeToStringArray</code>.      *      * @param str           the input String      * @param delimiter     the delimiter between elements (this is a single delimiter,      *                      rather than a bunch individual delimiter characters)      * @param charsToDelete a set of characters to delete. Useful for deleting unwanted      *                      line breaks: e.g. "\r\n\f" will delete all new lines and line feeds in a String.      * @return an array of the tokens in the list      * @see #tokenizeToStringArray      */
DECL|method|delimitedListToStringArray
specifier|public
specifier|static
name|String
index|[]
name|delimitedListToStringArray
parameter_list|(
name|String
name|str
parameter_list|,
name|String
name|delimiter
parameter_list|,
name|String
name|charsToDelete
parameter_list|)
block|{
if|if
condition|(
name|str
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|delimiter
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|String
index|[]
block|{
name|str
block|}
return|;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|delimiter
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|str
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|deleteAny
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|charsToDelete
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|delPos
decl_stmt|;
while|while
condition|(
operator|(
name|delPos
operator|=
name|str
operator|.
name|indexOf
argument_list|(
name|delimiter
argument_list|,
name|pos
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|.
name|add
argument_list|(
name|deleteAny
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|pos
argument_list|,
name|delPos
argument_list|)
argument_list|,
name|charsToDelete
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|=
name|delPos
operator|+
name|delimiter
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|.
name|length
argument_list|()
operator|>
literal|0
operator|&&
name|pos
operator|<=
name|str
operator|.
name|length
argument_list|()
condition|)
block|{
comment|// Add rest of String, but not in case of empty input.
name|result
operator|.
name|add
argument_list|(
name|deleteAny
argument_list|(
name|str
operator|.
name|substring
argument_list|(
name|pos
argument_list|)
argument_list|,
name|charsToDelete
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|toStringArray
argument_list|(
name|result
argument_list|)
return|;
block|}
comment|/**      * Convert a CSV list into an array of Strings.      *      * @param str the input String      * @return an array of Strings, or the empty array in case of empty input      */
DECL|method|commaDelimitedListToStringArray
specifier|public
specifier|static
name|String
index|[]
name|commaDelimitedListToStringArray
parameter_list|(
name|String
name|str
parameter_list|)
block|{
return|return
name|delimitedListToStringArray
argument_list|(
name|str
argument_list|,
literal|","
argument_list|)
return|;
block|}
comment|/**      * Convenience method to convert a CSV string list to a set.      * Note that this will suppress duplicates.      *      * @param str the input String      * @return a Set of String entries in the list      */
DECL|method|commaDelimitedListToSet
specifier|public
specifier|static
name|Set
argument_list|<
name|String
argument_list|>
name|commaDelimitedListToSet
parameter_list|(
name|String
name|str
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|set
init|=
operator|new
name|TreeSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|String
index|[]
name|tokens
init|=
name|commaDelimitedListToStringArray
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|set
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|tokens
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|set
return|;
block|}
comment|/**      * Convenience method to return a Collection as a delimited (e.g. CSV)      * String. E.g. useful for<code>toString()</code> implementations.      *      * @param coll   the Collection to display      * @param delim  the delimiter to use (probably a ",")      * @param prefix the String to start each element with      * @param suffix the String to end each element with      * @return the delimited String      */
DECL|method|collectionToDelimitedString
specifier|public
specifier|static
name|String
name|collectionToDelimitedString
parameter_list|(
name|Iterable
name|coll
parameter_list|,
name|String
name|delim
parameter_list|,
name|String
name|prefix
parameter_list|,
name|String
name|suffix
parameter_list|)
block|{
if|if
condition|(
name|Iterables
operator|.
name|isEmpty
argument_list|(
name|coll
argument_list|)
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Iterator
name|it
init|=
name|coll
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|prefix
argument_list|)
operator|.
name|append
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
operator|.
name|append
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|delim
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Convenience method to return a Collection as a delimited (e.g. CSV)      * String. E.g. useful for<code>toString()</code> implementations.      *      * @param coll  the Collection to display      * @param delim the delimiter to use (probably a ",")      * @return the delimited String      */
DECL|method|collectionToDelimitedString
specifier|public
specifier|static
name|String
name|collectionToDelimitedString
parameter_list|(
name|Iterable
name|coll
parameter_list|,
name|String
name|delim
parameter_list|)
block|{
return|return
name|collectionToDelimitedString
argument_list|(
name|coll
argument_list|,
name|delim
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
return|;
block|}
comment|/**      * Convenience method to return a Collection as a CSV String.      * E.g. useful for<code>toString()</code> implementations.      *      * @param coll the Collection to display      * @return the delimited String      */
DECL|method|collectionToCommaDelimitedString
specifier|public
specifier|static
name|String
name|collectionToCommaDelimitedString
parameter_list|(
name|Iterable
name|coll
parameter_list|)
block|{
return|return
name|collectionToDelimitedString
argument_list|(
name|coll
argument_list|,
literal|","
argument_list|)
return|;
block|}
comment|/**      * Convenience method to return a String array as a delimited (e.g. CSV)      * String. E.g. useful for<code>toString()</code> implementations.      *      * @param arr   the array to display      * @param delim the delimiter to use (probably a ",")      * @return the delimited String      */
DECL|method|arrayToDelimitedString
specifier|public
specifier|static
name|String
name|arrayToDelimitedString
parameter_list|(
name|Object
index|[]
name|arr
parameter_list|,
name|String
name|delim
parameter_list|)
block|{
if|if
condition|(
name|isEmpty
argument_list|(
name|arr
argument_list|)
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arr
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|delim
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Convenience method to return a String array as a CSV String.      * E.g. useful for<code>toString()</code> implementations.      *      * @param arr the array to display      * @return the delimited String      */
DECL|method|arrayToCommaDelimitedString
specifier|public
specifier|static
name|String
name|arrayToCommaDelimitedString
parameter_list|(
name|Object
index|[]
name|arr
parameter_list|)
block|{
return|return
name|arrayToDelimitedString
argument_list|(
name|arr
argument_list|,
literal|","
argument_list|)
return|;
block|}
comment|/**      * Format the double value with a single decimal points, trimming trailing '.0'.      */
DECL|method|format1Decimals
specifier|public
specifier|static
name|String
name|format1Decimals
parameter_list|(
name|double
name|value
parameter_list|,
name|String
name|suffix
parameter_list|)
block|{
name|String
name|p
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|int
name|ix
init|=
name|p
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|ex
init|=
name|p
operator|.
name|indexOf
argument_list|(
literal|'E'
argument_list|)
decl_stmt|;
name|char
name|fraction
init|=
name|p
operator|.
name|charAt
argument_list|(
name|ix
argument_list|)
decl_stmt|;
if|if
condition|(
name|fraction
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|ex
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
operator|-
literal|1
argument_list|)
operator|+
name|p
operator|.
name|substring
argument_list|(
name|ex
argument_list|)
operator|+
name|suffix
return|;
block|}
else|else
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
operator|-
literal|1
argument_list|)
operator|+
name|suffix
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ex
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
argument_list|)
operator|+
name|fraction
operator|+
name|p
operator|.
name|substring
argument_list|(
name|ex
argument_list|)
operator|+
name|suffix
return|;
block|}
else|else
block|{
return|return
name|p
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|ix
argument_list|)
operator|+
name|fraction
operator|+
name|suffix
return|;
block|}
block|}
block|}
DECL|method|toCamelCase
specifier|public
specifier|static
name|String
name|toCamelCase
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|toCamelCase
argument_list|(
name|value
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|toCamelCase
specifier|public
specifier|static
name|String
name|toCamelCase
parameter_list|(
name|String
name|value
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|value
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
comment|// copy it over here
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
literal|true
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toUpperCase
argument_list|(
name|value
operator|.
name|charAt
argument_list|(
operator|++
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|changed
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
block|{
return|return
name|value
return|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|toUnderscoreCase
specifier|public
specifier|static
name|String
name|toUnderscoreCase
parameter_list|(
name|String
name|value
parameter_list|)
block|{
return|return
name|toUnderscoreCase
argument_list|(
name|value
argument_list|,
literal|null
argument_list|)
return|;
block|}
DECL|method|toUnderscoreCase
specifier|public
specifier|static
name|String
name|toUnderscoreCase
parameter_list|(
name|String
name|value
parameter_list|,
name|StringBuilder
name|sb
parameter_list|)
block|{
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|value
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|value
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|Character
operator|.
name|isUpperCase
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|changed
condition|)
block|{
if|if
condition|(
name|sb
operator|!=
literal|null
condition|)
block|{
name|sb
operator|.
name|setLength
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|=
operator|new
name|StringBuilder
argument_list|()
expr_stmt|;
block|}
comment|// copy it over here
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|value
operator|.
name|charAt
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sb
operator|.
name|append
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|changed
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|changed
condition|)
block|{
return|return
name|value
return|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Determine whether the given array is empty:      * i.e.<code>null</code> or of zero length.      *      * @param array the array to check      */
DECL|method|isEmpty
specifier|private
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Object
index|[]
name|array
parameter_list|)
block|{
return|return
operator|(
name|array
operator|==
literal|null
operator|||
name|array
operator|.
name|length
operator|==
literal|0
operator|)
return|;
block|}
comment|/**      * Return<code>true</code> if the supplied Collection is<code>null</code>      * or empty. Otherwise, return<code>false</code>.      *      * @param collection the Collection to check      * @return whether the given Collection is empty      */
DECL|method|isEmpty
specifier|private
specifier|static
name|boolean
name|isEmpty
parameter_list|(
name|Collection
name|collection
parameter_list|)
block|{
return|return
operator|(
name|collection
operator|==
literal|null
operator|||
name|collection
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
DECL|method|Strings
specifier|private
name|Strings
parameter_list|()
block|{      }
block|}
end_class

end_unit

