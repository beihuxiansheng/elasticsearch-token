begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.util.concurrent
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|jsr166y
operator|.
name|LinkedTransferQueue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * @author kimchy (shay.banon)  */
end_comment

begin_class
DECL|class|ScalingThreadPoolExecutor
specifier|public
class|class
name|ScalingThreadPoolExecutor
extends|extends
name|AbstractExecutorService
block|{
DECL|field|workQueue
specifier|private
specifier|final
name|BlockingQueue
argument_list|<
name|Runnable
argument_list|>
name|workQueue
init|=
operator|new
name|LinkedTransferQueue
argument_list|<
name|Runnable
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|queueSize
specifier|private
specifier|final
name|AtomicInteger
name|queueSize
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**      * Lock held on updates to poolSize, corePoolSize,      * maximumPoolSize, runState, and workers set.      */
DECL|field|mainLock
specifier|private
specifier|final
name|ReentrantLock
name|mainLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|/**      * Wait condition to support awaitTermination      */
DECL|field|termination
specifier|private
specifier|final
name|Condition
name|termination
init|=
name|mainLock
operator|.
name|newCondition
argument_list|()
decl_stmt|;
comment|/**      * Set containing all worker threads in pool. Accessed only when      * holding mainLock.      */
DECL|field|workers
specifier|private
specifier|final
name|HashSet
argument_list|<
name|Worker
argument_list|>
name|workers
init|=
operator|new
name|HashSet
argument_list|<
name|Worker
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Factory for new threads. All threads are created using this      * factory (via method addThread).  All callers must be prepared      * for addThread to fail by returning null, which may reflect a      * system or user's policy limiting the number of threads.  Even      * though it is not treated as an error, failure to create threads      * may result in new tasks being rejected or existing ones      * remaining stuck in the queue. On the other hand, no special      * precautions exist to handle OutOfMemoryErrors that might be      * thrown while trying to create threads, since there is generally      * no recourse from within this class.      */
DECL|field|threadFactory
specifier|private
specifier|final
name|ThreadFactory
name|threadFactory
decl_stmt|;
comment|/**      * runState provides the main lifecyle control, taking on values:      *      * RUNNING:  Accept new tasks and process queued tasks      * SHUTDOWN: Don't accept new tasks, but process queued tasks      * STOP:     Don't accept new tasks, don't process queued tasks,      * and interrupt in-progress tasks      * TERMINATED: Same as STOP, plus all threads have terminated      *      * The numerical order among these values matters, to allow      * ordered comparisons. The runState monotonically increases over      * time, but need not hit each state. The transitions are:      *      * RUNNING -> SHUTDOWN      * On invocation of shutdown(), perhaps implicitly in finalize()      * (RUNNING or SHUTDOWN) -> STOP      * On invocation of shutdownNow()      * SHUTDOWN -> TERMINATED      * When both queue and pool are empty      * STOP -> TERMINATED      * When pool is empty      */
DECL|field|runState
specifier|volatile
name|int
name|runState
decl_stmt|;
DECL|field|RUNNING
specifier|static
specifier|final
name|int
name|RUNNING
init|=
literal|0
decl_stmt|;
DECL|field|SHUTDOWN
specifier|static
specifier|final
name|int
name|SHUTDOWN
init|=
literal|1
decl_stmt|;
DECL|field|STOP
specifier|static
specifier|final
name|int
name|STOP
init|=
literal|2
decl_stmt|;
DECL|field|TERMINATED
specifier|static
specifier|final
name|int
name|TERMINATED
init|=
literal|3
decl_stmt|;
comment|/**      * Core pool size, updated only while holding mainLock, but      * volatile to allow concurrent readability even during updates.      */
DECL|field|corePoolSize
specifier|private
specifier|final
name|int
name|corePoolSize
decl_stmt|;
comment|/**      * Maximum pool size, updated only while holding mainLock but      * volatile to allow concurrent readability even during updates.      */
DECL|field|maximumPoolSize
specifier|private
specifier|final
name|int
name|maximumPoolSize
decl_stmt|;
comment|/**      * Timeout in nanoseconds for idle threads waiting for work.      * Threads use this timeout when there are more than corePoolSize      * present or if allowCoreThreadTimeOut. Otherwise they wait      * forever for new work.      */
DECL|field|keepAliveTime
specifier|private
specifier|final
name|long
name|keepAliveTime
decl_stmt|;
comment|/**      * Current pool size, updated only while holding mainLock but      * volatile to allow concurrent readability even during updates.      */
DECL|field|poolSize
specifier|private
specifier|volatile
name|int
name|poolSize
decl_stmt|;
DECL|field|scheduledFuture
specifier|private
specifier|final
name|ScheduledFuture
name|scheduledFuture
decl_stmt|;
DECL|method|ScalingThreadPoolExecutor
specifier|public
name|ScalingThreadPoolExecutor
parameter_list|(
name|int
name|corePoolSize
parameter_list|,
name|int
name|maximumPoolSize
parameter_list|,
name|TimeValue
name|keepAlive
parameter_list|,
name|ThreadFactory
name|threadFactory
parameter_list|,
name|ScheduledExecutorService
name|scheduler
parameter_list|,
name|TimeValue
name|schedulerInterval
parameter_list|)
block|{
name|this
operator|.
name|corePoolSize
operator|=
name|corePoolSize
expr_stmt|;
name|this
operator|.
name|maximumPoolSize
operator|=
name|maximumPoolSize
expr_stmt|;
name|this
operator|.
name|keepAliveTime
operator|=
name|keepAlive
operator|.
name|nanos
argument_list|()
expr_stmt|;
name|this
operator|.
name|threadFactory
operator|=
name|threadFactory
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|corePoolSize
condition|;
name|i
operator|++
control|)
block|{
name|Thread
name|t
init|=
name|addThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|scheduledFuture
operator|=
name|scheduler
operator|.
name|scheduleWithFixedDelay
argument_list|(
operator|new
name|Scheduler
argument_list|()
argument_list|,
name|schedulerInterval
operator|.
name|nanos
argument_list|()
argument_list|,
name|schedulerInterval
operator|.
name|nanos
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
DECL|method|execute
annotation|@
name|Override
specifier|public
name|void
name|execute
parameter_list|(
name|Runnable
name|command
parameter_list|)
block|{
name|queueSize
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|workQueue
operator|.
name|add
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
DECL|method|shutdown
annotation|@
name|Override
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
if|if
condition|(
operator|!
name|scheduledFuture
operator|.
name|isCancelled
argument_list|()
condition|)
block|{
name|scheduledFuture
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|state
init|=
name|runState
decl_stmt|;
if|if
condition|(
name|state
operator|<
name|SHUTDOWN
condition|)
name|runState
operator|=
name|SHUTDOWN
expr_stmt|;
try|try
block|{
for|for
control|(
name|Worker
name|w
range|:
name|workers
control|)
block|{
name|w
operator|.
name|interruptIfIdle
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
comment|// Try to back out
name|runState
operator|=
name|state
expr_stmt|;
comment|// tryTerminate() here would be a no-op
throw|throw
name|se
throw|;
block|}
name|tryTerminate
argument_list|()
expr_stmt|;
comment|// Terminate now if pool and queue empty
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|shutdownNow
annotation|@
name|Override
specifier|public
name|List
argument_list|<
name|Runnable
argument_list|>
name|shutdownNow
parameter_list|()
block|{
if|if
condition|(
operator|!
name|scheduledFuture
operator|.
name|isCancelled
argument_list|()
condition|)
block|{
name|scheduledFuture
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|state
init|=
name|runState
decl_stmt|;
if|if
condition|(
name|state
operator|<
name|STOP
condition|)
name|runState
operator|=
name|STOP
expr_stmt|;
try|try
block|{
for|for
control|(
name|Worker
name|w
range|:
name|workers
control|)
block|{
name|w
operator|.
name|interruptNow
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
comment|// Try to back out
name|runState
operator|=
name|state
expr_stmt|;
comment|// tryTerminate() here would be a no-op
throw|throw
name|se
throw|;
block|}
name|List
argument_list|<
name|Runnable
argument_list|>
name|tasks
init|=
name|drainQueue
argument_list|()
decl_stmt|;
name|tryTerminate
argument_list|()
expr_stmt|;
comment|// Terminate now if pool and queue empty
return|return
name|tasks
return|;
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|isShutdown
annotation|@
name|Override
specifier|public
name|boolean
name|isShutdown
parameter_list|()
block|{
return|return
name|runState
operator|!=
name|RUNNING
return|;
block|}
DECL|method|isTerminated
annotation|@
name|Override
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
return|return
name|runState
operator|==
name|TERMINATED
return|;
block|}
DECL|method|awaitTermination
annotation|@
name|Override
specifier|public
name|boolean
name|awaitTermination
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|runState
operator|==
name|TERMINATED
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|nanos
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|nanos
operator|=
name|termination
operator|.
name|awaitNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns the current number of threads in the pool.      *      * @return the number of threads      */
DECL|method|getPoolSize
specifier|public
name|int
name|getPoolSize
parameter_list|()
block|{
return|return
name|poolSize
return|;
block|}
comment|/**      * Returns the approximate number of threads that are actively      * executing tasks.      *      * @return the number of threads      */
DECL|method|getActiveCount
specifier|public
name|int
name|getActiveCount
parameter_list|()
block|{
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Worker
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|.
name|isActive
argument_list|()
condition|)
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Scheduler
specifier|private
specifier|final
class|class
name|Scheduler
implements|implements
name|Runnable
block|{
DECL|method|run
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
if|if
condition|(
name|queueSize
operator|.
name|get
argument_list|()
operator|>
literal|0
operator|&&
name|poolSize
operator|<
name|maximumPoolSize
condition|)
block|{
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|ScalingThreadPoolExecutor
operator|.
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|currentQueueSize
init|=
name|queueSize
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentQueueSize
operator|>
literal|0
operator|&&
name|poolSize
operator|<
name|maximumPoolSize
condition|)
block|{
name|int
name|incrementBy
init|=
name|currentQueueSize
decl_stmt|;
if|if
condition|(
name|poolSize
operator|+
name|incrementBy
operator|>
name|maximumPoolSize
condition|)
block|{
name|incrementBy
operator|=
name|maximumPoolSize
operator|-
name|poolSize
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|incrementBy
condition|;
name|i
operator|++
control|)
block|{
name|Thread
name|t
init|=
name|addThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|class|Worker
specifier|private
specifier|final
class|class
name|Worker
implements|implements
name|Runnable
block|{
comment|/**          * The runLock is acquired and released surrounding each task          * execution. It mainly protects against interrupts that are          * intended to cancel the worker thread from instead          * interrupting the task being run.          */
DECL|field|runLock
specifier|private
specifier|final
name|ReentrantLock
name|runLock
init|=
operator|new
name|ReentrantLock
argument_list|()
decl_stmt|;
comment|/**          * Thread this worker is running in.  Acts as a final field,          * but cannot be set until thread is created.          */
DECL|field|thread
name|Thread
name|thread
decl_stmt|;
DECL|method|Worker
name|Worker
parameter_list|()
block|{         }
DECL|method|isActive
name|boolean
name|isActive
parameter_list|()
block|{
return|return
name|runLock
operator|.
name|isLocked
argument_list|()
return|;
block|}
comment|/**          * Interrupts thread if not running a task.          */
DECL|method|interruptIfIdle
name|void
name|interruptIfIdle
parameter_list|()
block|{
specifier|final
name|ReentrantLock
name|runLock
init|=
name|this
operator|.
name|runLock
decl_stmt|;
if|if
condition|(
name|runLock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
if|if
condition|(
name|thread
operator|!=
name|Thread
operator|.
name|currentThread
argument_list|()
condition|)
name|thread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|runLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Interrupts thread even if running a task.          */
DECL|method|interruptNow
name|void
name|interruptNow
parameter_list|()
block|{
name|thread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
comment|/**          * Runs a single task between before/after methods.          */
DECL|method|runTask
specifier|private
name|void
name|runTask
parameter_list|(
name|Runnable
name|task
parameter_list|)
block|{
specifier|final
name|ReentrantLock
name|runLock
init|=
name|this
operator|.
name|runLock
decl_stmt|;
name|runLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|/*                  * Ensure that unless pool is stopping, this thread                  * does not have its interrupt set. This requires a                  * double-check of state in case the interrupt was                  * cleared concurrently with a shutdownNow -- if so,                  * the interrupt is re-enabled.                  */
if|if
condition|(
name|runState
operator|<
name|STOP
operator|&&
name|Thread
operator|.
name|interrupted
argument_list|()
operator|&&
name|runState
operator|>=
name|STOP
condition|)
name|thread
operator|.
name|interrupt
argument_list|()
expr_stmt|;
name|task
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|runLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Main run loop          */
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|Runnable
name|task
decl_stmt|;
while|while
condition|(
operator|(
name|task
operator|=
name|getTask
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|runTask
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|workerDone
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getTask
name|Runnable
name|getTask
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
try|try
block|{
name|int
name|state
init|=
name|runState
decl_stmt|;
if|if
condition|(
name|state
operator|>
name|SHUTDOWN
condition|)
return|return
literal|null
return|;
name|Runnable
name|r
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|SHUTDOWN
condition|)
comment|// Help drain queue
name|r
operator|=
name|workQueue
operator|.
name|poll
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|poolSize
operator|>
name|corePoolSize
condition|)
name|r
operator|=
name|workQueue
operator|.
name|poll
argument_list|(
name|keepAliveTime
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|workQueue
operator|.
name|take
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
condition|)
block|{
name|queueSize
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|workerCanExit
argument_list|()
condition|)
block|{
if|if
condition|(
name|runState
operator|>=
name|SHUTDOWN
condition|)
comment|// Wake up others
name|interruptIdleWorkers
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|// Else retry
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
comment|// On interruption, re-check runState
block|}
block|}
block|}
comment|/**      * Check whether a worker thread that fails to get a task can      * exit.  We allow a worker thread to die if the pool is stopping,      * or the queue is empty, or there is at least one thread to      * handle possibly non-empty queue, even if core timeouts are      * allowed.      */
DECL|method|workerCanExit
specifier|private
name|boolean
name|workerCanExit
parameter_list|()
block|{
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|boolean
name|canExit
decl_stmt|;
try|try
block|{
name|canExit
operator|=
name|runState
operator|>=
name|STOP
operator|||
name|queueSize
operator|.
name|get
argument_list|()
operator|==
literal|0
expr_stmt|;
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|canExit
return|;
block|}
comment|/**      * Wakes up all threads that might be waiting for tasks so they      * can check for termination. Note: this method is also called by      * ScheduledThreadPoolExecutor.      */
DECL|method|interruptIdleWorkers
name|void
name|interruptIdleWorkers
parameter_list|()
block|{
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
name|Worker
name|w
range|:
name|workers
control|)
name|w
operator|.
name|interruptIfIdle
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Performs bookkeeping for an exiting worker thread.      *      * @param w the worker      */
DECL|method|workerDone
name|void
name|workerDone
parameter_list|(
name|Worker
name|w
parameter_list|)
block|{
specifier|final
name|ReentrantLock
name|mainLock
init|=
name|this
operator|.
name|mainLock
decl_stmt|;
name|mainLock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|workers
operator|.
name|remove
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|poolSize
operator|==
literal|0
condition|)
name|tryTerminate
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|mainLock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Transitions to TERMINATED state if either (SHUTDOWN and pool      * and queue empty) or (STOP and pool empty), otherwise unless      * stopped, ensuring that there is at least one live thread to      * handle queued tasks.      *      * This method is called from the three places in which      * termination can occur: in workerDone on exit of the last thread      * after pool has been shut down, or directly within calls to      * shutdown or shutdownNow, if there are no live threads.      */
DECL|method|tryTerminate
specifier|private
name|void
name|tryTerminate
parameter_list|()
block|{
if|if
condition|(
name|poolSize
operator|==
literal|0
condition|)
block|{
name|int
name|state
init|=
name|runState
decl_stmt|;
if|if
condition|(
name|state
argument_list|<
name|STOP
operator|&&
name|queueSize
operator|.
name|get
operator|(
operator|)
argument_list|>
literal|0
condition|)
block|{
name|state
operator|=
name|RUNNING
expr_stmt|;
comment|// disable termination check below
name|Thread
name|t
init|=
name|addThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|t
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|STOP
operator|||
name|state
operator|==
name|SHUTDOWN
condition|)
block|{
name|runState
operator|=
name|TERMINATED
expr_stmt|;
name|termination
operator|.
name|signalAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Creates and returns a new thread running firstTask as its first      * task. Call only while holding mainLock.      */
DECL|method|addThread
specifier|private
name|Thread
name|addThread
parameter_list|()
block|{
name|Worker
name|w
init|=
operator|new
name|Worker
argument_list|()
decl_stmt|;
name|Thread
name|t
init|=
name|threadFactory
operator|.
name|newThread
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|w
operator|.
name|thread
operator|=
name|t
expr_stmt|;
name|workers
operator|.
name|add
argument_list|(
name|w
argument_list|)
expr_stmt|;
operator|++
name|poolSize
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/**      * Drains the task queue into a new list. Used by shutdownNow.      * Call only while holding main lock.      */
DECL|method|drainQueue
specifier|private
name|List
argument_list|<
name|Runnable
argument_list|>
name|drainQueue
parameter_list|()
block|{
name|List
argument_list|<
name|Runnable
argument_list|>
name|taskList
init|=
operator|new
name|ArrayList
argument_list|<
name|Runnable
argument_list|>
argument_list|()
decl_stmt|;
name|workQueue
operator|.
name|drainTo
argument_list|(
name|taskList
argument_list|)
expr_stmt|;
name|queueSize
operator|.
name|getAndAdd
argument_list|(
name|taskList
operator|.
name|size
argument_list|()
operator|*
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*          * If the queue is a DelayQueue or any other kind of queue          * for which poll or drainTo may fail to remove some elements,          * we need to manually traverse and remove remaining tasks.          * To guarantee atomicity wrt other threads using this queue,          * we need to create a new iterator for each element removed.          */
while|while
condition|(
operator|!
name|workQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Iterator
argument_list|<
name|Runnable
argument_list|>
name|it
init|=
name|workQueue
operator|.
name|iterator
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Runnable
name|r
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|workQueue
operator|.
name|remove
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|taskList
operator|.
name|add
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|queueSize
operator|.
name|decrementAndGet
argument_list|()
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ConcurrentModificationException
name|ignore
parameter_list|)
block|{             }
block|}
return|return
name|taskList
return|;
block|}
block|}
end_class

end_unit

