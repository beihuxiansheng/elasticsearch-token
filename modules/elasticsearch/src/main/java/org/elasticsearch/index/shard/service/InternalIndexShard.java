begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.shard.service
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|service
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Document
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CheckIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FilteredQuery
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticSearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticSearchIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticSearchIllegalStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|FastByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ThreadSafe
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|IndexCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|IndexQueryParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|IndexQueryParserMissingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|IndexQueryParserService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|settings
operator|.
name|IndexSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|recovery
operator|.
name|RecoveryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|Translog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesLifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|InternalIndicesLifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedByInterruptException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|SourceToParse
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * @author kimchy (shay.banon)  */
end_comment

begin_class
annotation|@
name|ThreadSafe
DECL|class|InternalIndexShard
specifier|public
class|class
name|InternalIndexShard
extends|extends
name|AbstractIndexShardComponent
implements|implements
name|IndexShard
block|{
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|mapperService
specifier|private
specifier|final
name|MapperService
name|mapperService
decl_stmt|;
DECL|field|queryParserService
specifier|private
specifier|final
name|IndexQueryParserService
name|queryParserService
decl_stmt|;
DECL|field|indexCache
specifier|private
specifier|final
name|IndexCache
name|indexCache
decl_stmt|;
DECL|field|indicesLifecycle
specifier|private
specifier|final
name|InternalIndicesLifecycle
name|indicesLifecycle
decl_stmt|;
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|engine
specifier|private
specifier|final
name|Engine
name|engine
decl_stmt|;
DECL|field|translog
specifier|private
specifier|final
name|Translog
name|translog
decl_stmt|;
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|checkIndex
specifier|private
specifier|final
name|boolean
name|checkIndex
decl_stmt|;
DECL|field|state
specifier|private
specifier|volatile
name|IndexShardState
name|state
decl_stmt|;
DECL|field|refreshInterval
specifier|private
specifier|final
name|TimeValue
name|refreshInterval
decl_stmt|;
DECL|field|optimizeInterval
specifier|private
specifier|final
name|TimeValue
name|optimizeInterval
decl_stmt|;
DECL|field|refreshScheduledFuture
specifier|private
specifier|volatile
name|ScheduledFuture
name|refreshScheduledFuture
decl_stmt|;
DECL|field|optimizeScheduleFuture
specifier|private
specifier|volatile
name|ScheduledFuture
name|optimizeScheduleFuture
decl_stmt|;
DECL|field|shardRouting
specifier|private
specifier|volatile
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|field|peerRecoveryStatus
specifier|private
name|RecoveryStatus
name|peerRecoveryStatus
decl_stmt|;
DECL|field|listeners
specifier|private
name|CopyOnWriteArrayList
argument_list|<
name|OperationListener
argument_list|>
name|listeners
init|=
literal|null
decl_stmt|;
DECL|method|InternalIndexShard
annotation|@
name|Inject
specifier|public
name|InternalIndexShard
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
annotation|@
name|IndexSettings
name|Settings
name|indexSettings
parameter_list|,
name|IndicesLifecycle
name|indicesLifecycle
parameter_list|,
name|Store
name|store
parameter_list|,
name|Engine
name|engine
parameter_list|,
name|Translog
name|translog
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|IndexQueryParserService
name|queryParserService
parameter_list|,
name|IndexCache
name|indexCache
parameter_list|)
block|{
name|super
argument_list|(
name|shardId
argument_list|,
name|indexSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicesLifecycle
operator|=
operator|(
name|InternalIndicesLifecycle
operator|)
name|indicesLifecycle
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
name|this
operator|.
name|engine
operator|=
name|engine
expr_stmt|;
name|this
operator|.
name|translog
operator|=
name|translog
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|mapperService
operator|=
name|mapperService
expr_stmt|;
name|this
operator|.
name|queryParserService
operator|=
name|queryParserService
expr_stmt|;
name|this
operator|.
name|indexCache
operator|=
name|indexCache
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|CREATED
expr_stmt|;
if|if
condition|(
name|engine
operator|instanceof
name|ScheduledRefreshableEngine
condition|)
block|{
name|refreshInterval
operator|=
operator|(
operator|(
name|ScheduledRefreshableEngine
operator|)
name|engine
operator|)
operator|.
name|refreshInterval
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|refreshInterval
operator|=
operator|new
name|TimeValue
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|optimizeInterval
operator|=
name|indexSettings
operator|.
name|getAsTime
argument_list|(
literal|"index.merge.async_interval"
argument_list|,
name|TimeValue
operator|.
name|timeValueSeconds
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [CREATED]"
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkIndex
operator|=
name|indexSettings
operator|.
name|getAsBoolean
argument_list|(
literal|"index.shard.check_index"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|addListener
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|addListener
parameter_list|(
name|OperationListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|listeners
operator|==
literal|null
condition|)
block|{
name|listeners
operator|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|OperationListener
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|listeners
operator|.
name|add
argument_list|(
name|listener
argument_list|)
expr_stmt|;
block|}
DECL|method|removeListener
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|removeListener
parameter_list|(
name|OperationListener
name|listener
parameter_list|)
block|{
if|if
condition|(
name|listeners
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|listeners
operator|.
name|remove
argument_list|(
name|listener
argument_list|)
expr_stmt|;
if|if
condition|(
name|listeners
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|listeners
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|method|store
specifier|public
name|Store
name|store
parameter_list|()
block|{
return|return
name|this
operator|.
name|store
return|;
block|}
DECL|method|engine
specifier|public
name|Engine
name|engine
parameter_list|()
block|{
return|return
name|engine
return|;
block|}
DECL|method|translog
specifier|public
name|Translog
name|translog
parameter_list|()
block|{
return|return
name|translog
return|;
block|}
DECL|method|routingEntry
annotation|@
name|Override
specifier|public
name|ShardRouting
name|routingEntry
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardRouting
return|;
block|}
DECL|method|routingEntry
specifier|public
name|InternalIndexShard
name|routingEntry
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|shardId
argument_list|()
operator|.
name|equals
argument_list|(
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ElasticSearchIllegalArgumentException
argument_list|(
literal|"Trying to set a routing entry with shardId ["
operator|+
name|shardRouting
operator|.
name|shardId
argument_list|()
operator|+
literal|"] on a shard with shardId ["
operator|+
name|shardId
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|this
operator|.
name|shardRouting
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|this
operator|.
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"suspect illegal state: trying to move shard from primary mode to backup mode"
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|shardRouting
operator|=
name|shardRouting
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Marks the shard as recovering, fails with exception is recovering is not allowed to be set.      */
DECL|method|recovering
specifier|public
name|IndexShardState
name|recovering
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardRecoveringException
throws|,
name|IndexShardClosedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|IndexShardState
name|returnValue
init|=
name|state
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardRecoveringException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [{}]"
argument_list|,
name|state
argument_list|,
name|IndexShardState
operator|.
name|RECOVERING
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|RECOVERING
expr_stmt|;
return|return
name|returnValue
return|;
block|}
block|}
DECL|method|relocated
specifier|public
name|InternalIndexShard
name|relocated
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardNotStartedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [{}]"
argument_list|,
name|state
argument_list|,
name|IndexShardState
operator|.
name|RELOCATED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|RELOCATED
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|start
specifier|public
name|InternalIndexShard
name|start
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardClosedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|checkIndex
condition|)
block|{
name|checkIndex
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|start
argument_list|()
expr_stmt|;
name|startScheduledTasksIfNeeded
argument_list|()
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [{}]"
argument_list|,
name|state
argument_list|,
name|IndexShardState
operator|.
name|STARTED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|STARTED
expr_stmt|;
block|}
name|indicesLifecycle
operator|.
name|afterIndexShardStarted
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
DECL|method|state
annotation|@
name|Override
specifier|public
name|IndexShardState
name|state
parameter_list|()
block|{
return|return
name|state
return|;
block|}
comment|/**      * Returns the estimated flushable memory size. Returns<tt>null</tt> if not available.      */
DECL|method|estimateFlushableMemorySize
annotation|@
name|Override
specifier|public
name|ByteSizeValue
name|estimateFlushableMemorySize
parameter_list|()
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
return|return
name|engine
operator|.
name|estimateFlushableMemorySize
argument_list|()
return|;
block|}
DECL|method|prepareCreate
annotation|@
name|Override
specifier|public
name|Engine
operator|.
name|Create
name|prepareCreate
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|DocumentMapper
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|parse
argument_list|(
name|source
argument_list|)
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|Create
argument_list|(
name|docMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|doc
operator|.
name|uid
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|)
operator|.
name|version
argument_list|(
name|source
operator|.
name|version
argument_list|()
argument_list|)
return|;
block|}
DECL|method|create
annotation|@
name|Override
specifier|public
name|ParsedDocument
name|create
parameter_list|(
name|Engine
operator|.
name|Create
name|create
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|listeners
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|OperationListener
name|listener
range|:
name|listeners
control|)
block|{
name|create
operator|=
name|listener
operator|.
name|beforeCreate
argument_list|(
name|create
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"index {}"
argument_list|,
name|create
operator|.
name|doc
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|create
argument_list|(
name|create
argument_list|)
expr_stmt|;
return|return
name|create
operator|.
name|parsedDoc
argument_list|()
return|;
block|}
DECL|method|prepareIndex
annotation|@
name|Override
specifier|public
name|Engine
operator|.
name|Index
name|prepareIndex
parameter_list|(
name|SourceToParse
name|source
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|DocumentMapper
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|parse
argument_list|(
name|source
argument_list|)
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|Index
argument_list|(
name|docMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|doc
operator|.
name|uid
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|)
operator|.
name|version
argument_list|(
name|source
operator|.
name|version
argument_list|()
argument_list|)
return|;
block|}
DECL|method|index
annotation|@
name|Override
specifier|public
name|ParsedDocument
name|index
parameter_list|(
name|Engine
operator|.
name|Index
name|index
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|listeners
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|OperationListener
name|listener
range|:
name|listeners
control|)
block|{
name|index
operator|=
name|listener
operator|.
name|beforeIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"index {}"
argument_list|,
name|index
operator|.
name|doc
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|index
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|index
operator|.
name|parsedDoc
argument_list|()
return|;
block|}
DECL|method|prepareDelete
annotation|@
name|Override
specifier|public
name|Engine
operator|.
name|Delete
name|prepareDelete
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|version
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|DocumentMapper
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|Delete
argument_list|(
name|type
argument_list|,
name|id
argument_list|,
name|docMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
argument_list|)
operator|.
name|version
argument_list|(
name|version
argument_list|)
return|;
block|}
DECL|method|delete
annotation|@
name|Override
specifier|public
name|void
name|delete
parameter_list|(
name|Engine
operator|.
name|Delete
name|delete
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|listeners
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|OperationListener
name|listener
range|:
name|listeners
control|)
block|{
name|delete
operator|=
name|listener
operator|.
name|beforeDelete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"delete [{}]"
argument_list|,
name|delete
operator|.
name|uid
argument_list|()
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|delete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
DECL|method|bulk
annotation|@
name|Override
specifier|public
name|EngineException
index|[]
name|bulk
parameter_list|(
name|Engine
operator|.
name|Bulk
name|bulk
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|listeners
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|bulk
operator|.
name|ops
argument_list|()
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Engine
operator|.
name|Operation
name|op
init|=
name|bulk
operator|.
name|ops
argument_list|()
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|op
operator|.
name|opType
argument_list|()
condition|)
block|{
case|case
name|CREATE
case|:
name|Engine
operator|.
name|Create
name|create
init|=
operator|(
name|Engine
operator|.
name|Create
operator|)
name|op
decl_stmt|;
for|for
control|(
name|OperationListener
name|listener
range|:
name|listeners
control|)
block|{
name|bulk
operator|.
name|ops
argument_list|()
index|[
name|i
index|]
operator|=
name|listener
operator|.
name|beforeCreate
argument_list|(
name|create
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INDEX
case|:
name|Engine
operator|.
name|Index
name|index
init|=
operator|(
name|Engine
operator|.
name|Index
operator|)
name|op
decl_stmt|;
for|for
control|(
name|OperationListener
name|listener
range|:
name|listeners
control|)
block|{
name|bulk
operator|.
name|ops
argument_list|()
index|[
name|i
index|]
operator|=
name|listener
operator|.
name|beforeIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DELETE
case|:
name|Engine
operator|.
name|Delete
name|delete
init|=
operator|(
name|Engine
operator|.
name|Delete
operator|)
name|op
decl_stmt|;
for|for
control|(
name|OperationListener
name|listener
range|:
name|listeners
control|)
block|{
name|bulk
operator|.
name|ops
argument_list|()
index|[
name|i
index|]
operator|=
name|listener
operator|.
name|beforeDelete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"bulk, items [{}]"
argument_list|,
name|bulk
operator|.
name|ops
argument_list|()
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|engine
operator|.
name|bulk
argument_list|(
name|bulk
argument_list|)
return|;
block|}
DECL|method|deleteByQuery
annotation|@
name|Override
specifier|public
name|void
name|deleteByQuery
parameter_list|(
name|byte
index|[]
name|querySource
parameter_list|,
annotation|@
name|Nullable
name|String
name|queryParserName
parameter_list|,
name|String
modifier|...
name|types
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|types
operator|==
literal|null
condition|)
block|{
name|types
operator|=
name|Strings
operator|.
name|EMPTY_ARRAY
expr_stmt|;
block|}
name|innerDeleteByQuery
argument_list|(
name|querySource
argument_list|,
name|queryParserName
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
DECL|method|innerDeleteByQuery
specifier|private
name|void
name|innerDeleteByQuery
parameter_list|(
name|byte
index|[]
name|querySource
parameter_list|,
name|String
name|queryParserName
parameter_list|,
name|String
modifier|...
name|types
parameter_list|)
block|{
name|IndexQueryParser
name|queryParser
init|=
name|queryParserService
operator|.
name|defaultIndexQueryParser
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryParserName
operator|!=
literal|null
condition|)
block|{
name|queryParser
operator|=
name|queryParserService
operator|.
name|indexQueryParser
argument_list|(
name|queryParserName
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryParser
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IndexQueryParserMissingException
argument_list|(
name|queryParserName
argument_list|)
throw|;
block|}
block|}
name|Query
name|query
init|=
name|queryParser
operator|.
name|parse
argument_list|(
name|querySource
argument_list|)
operator|.
name|query
argument_list|()
decl_stmt|;
name|query
operator|=
name|filterByTypesIfNeeded
argument_list|(
name|query
argument_list|,
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"delete_by_query [{}]"
argument_list|,
name|query
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|delete
argument_list|(
operator|new
name|Engine
operator|.
name|DeleteByQuery
argument_list|(
name|query
argument_list|,
name|querySource
argument_list|,
name|queryParserName
argument_list|,
name|types
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|get
annotation|@
name|Override
specifier|public
name|byte
index|[]
name|get
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|readAllowed
argument_list|()
expr_stmt|;
name|DocumentMapper
name|docMapper
init|=
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|Engine
operator|.
name|Searcher
name|searcher
init|=
name|engine
operator|.
name|searcher
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|docId
init|=
name|Lucene
operator|.
name|docId
argument_list|(
name|searcher
operator|.
name|reader
argument_list|()
argument_list|,
name|docMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|docId
operator|==
name|Lucene
operator|.
name|NO_DOC
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"get for [{}#{}] returned no result"
argument_list|,
name|type
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
name|Document
name|doc
init|=
name|searcher
operator|.
name|reader
argument_list|()
operator|.
name|document
argument_list|(
name|docId
argument_list|,
name|docMapper
operator|.
name|sourceMapper
argument_list|()
operator|.
name|fieldSelector
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"get for [{}#{}] returned [{}]"
argument_list|,
name|type
argument_list|,
name|id
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
return|return
name|docMapper
operator|.
name|sourceMapper
argument_list|()
operator|.
name|value
argument_list|(
name|doc
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticSearchException
argument_list|(
literal|"Failed to get type ["
operator|+
name|type
operator|+
literal|"] and id ["
operator|+
name|id
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|searcher
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|count
annotation|@
name|Override
specifier|public
name|long
name|count
parameter_list|(
name|float
name|minScore
parameter_list|,
name|byte
index|[]
name|querySource
parameter_list|,
annotation|@
name|Nullable
name|String
name|queryParserName
parameter_list|,
name|String
modifier|...
name|types
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
return|return
name|count
argument_list|(
name|minScore
argument_list|,
name|querySource
argument_list|,
literal|0
argument_list|,
name|querySource
operator|.
name|length
argument_list|,
name|queryParserName
argument_list|,
name|types
argument_list|)
return|;
block|}
DECL|method|count
annotation|@
name|Override
specifier|public
name|long
name|count
parameter_list|(
name|float
name|minScore
parameter_list|,
name|byte
index|[]
name|querySource
parameter_list|,
name|int
name|querySourceOffset
parameter_list|,
name|int
name|querySourceLength
parameter_list|,
annotation|@
name|Nullable
name|String
name|queryParserName
parameter_list|,
name|String
modifier|...
name|types
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|readAllowed
argument_list|()
expr_stmt|;
name|IndexQueryParser
name|queryParser
init|=
name|queryParserService
operator|.
name|defaultIndexQueryParser
argument_list|()
decl_stmt|;
if|if
condition|(
name|queryParserName
operator|!=
literal|null
condition|)
block|{
name|queryParser
operator|=
name|queryParserService
operator|.
name|indexQueryParser
argument_list|(
name|queryParserName
argument_list|)
expr_stmt|;
if|if
condition|(
name|queryParser
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IndexQueryParserMissingException
argument_list|(
name|queryParserName
argument_list|)
throw|;
block|}
block|}
name|Query
name|query
init|=
name|queryParser
operator|.
name|parse
argument_list|(
name|querySource
argument_list|,
name|querySourceOffset
argument_list|,
name|querySourceLength
argument_list|)
operator|.
name|query
argument_list|()
decl_stmt|;
comment|// wrap it in filter, cache it, and constant score it
comment|// Don't cache it, since it might be very different queries each time...
comment|//        query = new ConstantScoreQuery(filterCache.cache(new QueryWrapperFilter(query)));
name|query
operator|=
name|filterByTypesIfNeeded
argument_list|(
name|query
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|Engine
operator|.
name|Searcher
name|searcher
init|=
name|engine
operator|.
name|searcher
argument_list|()
decl_stmt|;
try|try
block|{
name|long
name|count
init|=
name|Lucene
operator|.
name|count
argument_list|(
name|searcher
operator|.
name|searcher
argument_list|()
argument_list|,
name|query
argument_list|,
name|minScore
argument_list|)
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"count of [{}] is [{}]"
argument_list|,
name|query
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticSearchException
argument_list|(
literal|"Failed to count query ["
operator|+
name|query
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|searcher
operator|.
name|release
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|refresh
annotation|@
name|Override
specifier|public
name|void
name|refresh
parameter_list|(
name|Engine
operator|.
name|Refresh
name|refresh
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"refresh with {}"
argument_list|,
name|refresh
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|refresh
argument_list|(
name|refresh
argument_list|)
expr_stmt|;
block|}
DECL|method|flush
annotation|@
name|Override
specifier|public
name|void
name|flush
parameter_list|(
name|Engine
operator|.
name|Flush
name|flush
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"flush with {}"
argument_list|,
name|flush
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|flush
argument_list|(
name|flush
argument_list|)
expr_stmt|;
block|}
DECL|method|optimize
annotation|@
name|Override
specifier|public
name|void
name|optimize
parameter_list|(
name|Engine
operator|.
name|Optimize
name|optimize
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"optimize with {}"
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|optimize
argument_list|(
name|optimize
argument_list|)
expr_stmt|;
block|}
DECL|method|snapshot
annotation|@
name|Override
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|snapshot
parameter_list|(
name|Engine
operator|.
name|SnapshotHandler
argument_list|<
name|T
argument_list|>
name|snapshotHandler
parameter_list|)
throws|throws
name|EngineException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
comment|// we allow snapshot on closed index shard, since we want to do one after we close the shard and before we close the engine
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"snapshot is not allowed"
argument_list|)
throw|;
block|}
return|return
name|engine
operator|.
name|snapshot
argument_list|(
name|snapshotHandler
argument_list|)
return|;
block|}
DECL|method|recover
annotation|@
name|Override
specifier|public
name|void
name|recover
parameter_list|(
name|Engine
operator|.
name|RecoveryHandler
name|recoveryHandler
parameter_list|)
throws|throws
name|EngineException
block|{
name|writeAllowed
argument_list|()
expr_stmt|;
name|engine
operator|.
name|recover
argument_list|(
name|recoveryHandler
argument_list|)
expr_stmt|;
block|}
DECL|method|searcher
annotation|@
name|Override
specifier|public
name|Engine
operator|.
name|Searcher
name|searcher
parameter_list|()
block|{
name|readAllowed
argument_list|()
expr_stmt|;
return|return
name|engine
operator|.
name|searcher
argument_list|()
return|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|String
name|reason
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
if|if
condition|(
name|refreshScheduledFuture
operator|!=
literal|null
condition|)
block|{
name|refreshScheduledFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|refreshScheduledFuture
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|optimizeScheduleFuture
operator|!=
literal|null
condition|)
block|{
name|optimizeScheduleFuture
operator|.
name|cancel
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|optimizeScheduleFuture
operator|=
literal|null
expr_stmt|;
block|}
block|}
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [{}]"
argument_list|,
name|state
argument_list|,
name|IndexShardState
operator|.
name|CLOSED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|CLOSED
expr_stmt|;
block|}
block|}
comment|/**      * After the store has been recovered, we need to start the engine in order to apply operations      */
DECL|method|performRecoveryPrepareForTranslog
specifier|public
name|void
name|performRecoveryPrepareForTranslog
parameter_list|()
throws|throws
name|ElasticSearchException
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
comment|// also check here, before we apply the translog
if|if
condition|(
name|checkIndex
condition|)
block|{
name|checkIndex
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|engine
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
comment|/**      * The peer recovery status if this shard recovered from a peer shard.      */
DECL|method|peerRecoveryStatus
specifier|public
name|RecoveryStatus
name|peerRecoveryStatus
parameter_list|()
block|{
return|return
name|this
operator|.
name|peerRecoveryStatus
return|;
block|}
DECL|method|performRecoveryFinalization
specifier|public
name|void
name|performRecoveryFinalization
parameter_list|(
name|boolean
name|withFlush
parameter_list|,
name|RecoveryStatus
name|peerRecoveryStatus
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
name|performRecoveryFinalization
argument_list|(
name|withFlush
argument_list|)
expr_stmt|;
name|this
operator|.
name|peerRecoveryStatus
operator|=
name|peerRecoveryStatus
expr_stmt|;
block|}
DECL|method|performRecoveryFinalization
specifier|public
name|void
name|performRecoveryFinalization
parameter_list|(
name|boolean
name|withFlush
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
if|if
condition|(
name|withFlush
condition|)
block|{
name|engine
operator|.
name|flush
argument_list|(
operator|new
name|Engine
operator|.
name|Flush
argument_list|()
argument_list|)
expr_stmt|;
block|}
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [post recovery]"
argument_list|,
name|state
argument_list|,
name|IndexShardState
operator|.
name|STARTED
argument_list|)
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|STARTED
expr_stmt|;
block|}
name|startScheduledTasksIfNeeded
argument_list|()
expr_stmt|;
name|engine
operator|.
name|refresh
argument_list|(
operator|new
name|Engine
operator|.
name|Refresh
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// clear unreferenced files
name|translog
operator|.
name|clearUnreferenced
argument_list|()
expr_stmt|;
name|indicesLifecycle
operator|.
name|afterIndexShardStarted
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|performRecoveryOperation
specifier|public
name|void
name|performRecoveryOperation
parameter_list|(
name|Translog
operator|.
name|Operation
name|operation
parameter_list|)
throws|throws
name|ElasticSearchException
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|operation
operator|.
name|opType
argument_list|()
condition|)
block|{
case|case
name|CREATE
case|:
name|Translog
operator|.
name|Create
name|create
init|=
operator|(
name|Translog
operator|.
name|Create
operator|)
name|operation
decl_stmt|;
name|engine
operator|.
name|create
argument_list|(
name|prepareCreate
argument_list|(
name|source
argument_list|(
name|create
operator|.
name|source
argument_list|()
argument_list|)
operator|.
name|type
argument_list|(
name|create
operator|.
name|type
argument_list|()
argument_list|)
operator|.
name|id
argument_list|(
name|create
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|routing
argument_list|(
name|create
operator|.
name|routing
argument_list|()
argument_list|)
operator|.
name|parent
argument_list|(
name|create
operator|.
name|parent
argument_list|()
argument_list|)
argument_list|)
operator|.
name|version
argument_list|(
name|create
operator|.
name|version
argument_list|()
argument_list|)
operator|.
name|origin
argument_list|(
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|RECOVERY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE
case|:
name|Translog
operator|.
name|Index
name|index
init|=
operator|(
name|Translog
operator|.
name|Index
operator|)
name|operation
decl_stmt|;
name|engine
operator|.
name|index
argument_list|(
name|prepareIndex
argument_list|(
name|source
argument_list|(
name|index
operator|.
name|source
argument_list|()
argument_list|)
operator|.
name|type
argument_list|(
name|index
operator|.
name|type
argument_list|()
argument_list|)
operator|.
name|id
argument_list|(
name|index
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|routing
argument_list|(
name|index
operator|.
name|routing
argument_list|()
argument_list|)
operator|.
name|parent
argument_list|(
name|index
operator|.
name|parent
argument_list|()
argument_list|)
argument_list|)
operator|.
name|version
argument_list|(
name|index
operator|.
name|version
argument_list|()
argument_list|)
operator|.
name|origin
argument_list|(
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|RECOVERY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE
case|:
name|Translog
operator|.
name|Delete
name|delete
init|=
operator|(
name|Translog
operator|.
name|Delete
operator|)
name|operation
decl_stmt|;
name|Uid
name|uid
init|=
name|Uid
operator|.
name|createUid
argument_list|(
name|delete
operator|.
name|uid
argument_list|()
operator|.
name|text
argument_list|()
argument_list|)
decl_stmt|;
name|engine
operator|.
name|delete
argument_list|(
operator|new
name|Engine
operator|.
name|Delete
argument_list|(
name|uid
operator|.
name|type
argument_list|()
argument_list|,
name|uid
operator|.
name|id
argument_list|()
argument_list|,
name|delete
operator|.
name|uid
argument_list|()
argument_list|)
operator|.
name|version
argument_list|(
name|delete
operator|.
name|version
argument_list|()
argument_list|)
operator|.
name|origin
argument_list|(
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|RECOVERY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DELETE_BY_QUERY
case|:
name|Translog
operator|.
name|DeleteByQuery
name|deleteByQuery
init|=
operator|(
name|Translog
operator|.
name|DeleteByQuery
operator|)
name|operation
decl_stmt|;
name|innerDeleteByQuery
argument_list|(
name|deleteByQuery
operator|.
name|source
argument_list|()
argument_list|,
name|deleteByQuery
operator|.
name|queryParserName
argument_list|()
argument_list|,
name|deleteByQuery
operator|.
name|types
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|ElasticSearchIllegalStateException
argument_list|(
literal|"No operation defined for ["
operator|+
name|operation
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns<tt>true</tt> if this shard can ignore a recovery attempt made to it (since the already doing/done it)      */
DECL|method|ignoreRecoveryAttempt
specifier|public
name|boolean
name|ignoreRecoveryAttempt
parameter_list|()
block|{
name|IndexShardState
name|state
init|=
name|state
argument_list|()
decl_stmt|;
comment|// one time volatile read
return|return
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
return|;
block|}
DECL|method|readAllowed
specifier|public
name|void
name|readAllowed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"Read operations only allowed when started/relocated"
argument_list|)
throw|;
block|}
block|}
DECL|method|writeAllowed
specifier|public
name|void
name|writeAllowed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
block|}
DECL|method|startScheduledTasksIfNeeded
specifier|private
name|void
name|startScheduledTasksIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|refreshInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
operator|new
name|EngineRefresher
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduling refresher every {}"
argument_list|,
name|refreshInterval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduled refresher disabled"
argument_list|)
expr_stmt|;
block|}
comment|// since we can do async merging, it will not be called explicitly when indexing (adding / deleting docs), and only when flushing
comment|// so, make sure we periodically call it, this need to be a small enough value so mergine will actually
comment|// happen and reduce the number of segments
if|if
condition|(
name|optimizeInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|optimizeScheduleFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|optimizeInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|MANAGEMENT
argument_list|,
operator|new
name|EngineOptimizer
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduling optimizer / merger every {}"
argument_list|,
name|optimizeInterval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduled optimizer / merger disabled"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|filterByTypesIfNeeded
specifier|private
name|Query
name|filterByTypesIfNeeded
parameter_list|(
name|Query
name|query
parameter_list|,
name|String
index|[]
name|types
parameter_list|)
block|{
if|if
condition|(
name|types
operator|!=
literal|null
operator|&&
name|types
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|query
operator|=
operator|new
name|FilteredQuery
argument_list|(
name|query
argument_list|,
name|indexCache
operator|.
name|filter
argument_list|()
operator|.
name|cache
argument_list|(
name|mapperService
operator|.
name|typesFilter
argument_list|(
name|types
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|query
return|;
block|}
DECL|class|EngineRefresher
specifier|private
class|class
name|EngineRefresher
implements|implements
name|Runnable
block|{
DECL|method|run
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// we check before if a refresh is needed, if not, we reschedule, otherwise, we fork, refresh, and then reschedule
if|if
condition|(
operator|!
name|engine
argument_list|()
operator|.
name|refreshNeeded
argument_list|()
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|threadPool
operator|.
name|cached
argument_list|()
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|engine
operator|.
name|refreshNeeded
argument_list|()
condition|)
block|{
name|engine
operator|.
name|refresh
argument_list|(
operator|new
name|Engine
operator|.
name|Refresh
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|e
parameter_list|)
block|{
comment|// we are being closed, ignore
block|}
catch|catch
parameter_list|(
name|RefreshFailedEngineException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|InterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ClosedByInterruptException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ThreadInterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|EngineOptimizer
specifier|private
class|class
name|EngineOptimizer
implements|implements
name|Runnable
block|{
DECL|method|run
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
comment|// -1 means maybe merge
name|engine
operator|.
name|optimize
argument_list|(
operator|new
name|Engine
operator|.
name|Optimize
argument_list|()
operator|.
name|maxNumSegments
argument_list|(
operator|-
literal|1
argument_list|)
operator|.
name|waitForMerge
argument_list|(
literal|false
argument_list|)
operator|.
name|flush
argument_list|(
literal|false
argument_list|)
operator|.
name|refresh
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|e
parameter_list|)
block|{
comment|// we are being closed, ignore
block|}
catch|catch
parameter_list|(
name|OptimizeFailedEngineException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|InterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ClosedByInterruptException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ThreadInterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
else|else
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine optimize/merge"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine optimize/merge"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|optimizeScheduleFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|optimizeInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|MANAGEMENT
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|checkIndex
specifier|private
name|void
name|checkIndex
parameter_list|(
name|boolean
name|throwException
parameter_list|)
throws|throws
name|IndexShardException
block|{
try|try
block|{
if|if
condition|(
operator|!
name|IndexReader
operator|.
name|indexExists
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|CheckIndex
name|checkIndex
init|=
operator|new
name|CheckIndex
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
decl_stmt|;
name|FastByteArrayOutputStream
name|os
init|=
operator|new
name|FastByteArrayOutputStream
argument_list|()
decl_stmt|;
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|checkIndex
operator|.
name|setInfoStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|status
init|=
name|checkIndex
operator|.
name|checkIndex
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|clean
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// ignore if closed....
return|return;
block|}
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|unsafeByteArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|os
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|throwException
condition|)
block|{
throw|throw
operator|new
name|IndexShardException
argument_list|(
name|shardId
argument_list|,
literal|"index check failure"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"check index [success]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|unsafeByteArray
argument_list|()
argument_list|,
literal|0
argument_list|,
name|os
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to check index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

