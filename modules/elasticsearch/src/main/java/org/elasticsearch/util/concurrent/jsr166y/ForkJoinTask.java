begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.concurrent.jsr166y
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|concurrent
operator|.
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Abstract base class for tasks that run within a {@link ForkJoinPool}.  * A {@code ForkJoinTask} is a thread-like entity that is much  * lighter weight than a normal thread.  Huge numbers of tasks and  * subtasks may be hosted by a small number of actual threads in a  * ForkJoinPool, at the price of some usage limitations.  *  *<p>A "main" {@code ForkJoinTask} begins execution when submitted  * to a {@link ForkJoinPool}.  Once started, it will usually in turn  * start other subtasks.  As indicated by the name of this class,  * many programs using {@code ForkJoinTask} employ only methods  * {@link #fork} and {@link #join}, or derivatives such as {@link  * #invokeAll}.  However, this class also provides a number of other  * methods that can come into play in advanced usages, as well as  * extension mechanics that allow support of new forms of fork/join  * processing.  *  *<p>A {@code ForkJoinTask} is a lightweight form of {@link Future}.  * The efficiency of {@code ForkJoinTask}s stems from a set of  * restrictions (that are only partially statically enforceable)  * reflecting their intended use as computational tasks calculating  * pure functions or operating on purely isolated objects.  The  * primary coordination mechanisms are {@link #fork}, that arranges  * asynchronous execution, and {@link #join}, that doesn't proceed  * until the task's result has been computed.  Computations should  * avoid {@code synchronized} methods or blocks, and should minimize  * other blocking synchronization apart from joining other tasks or  * using synchronizers such as Phasers that are advertised to  * cooperate with fork/join scheduling. Tasks should also not perform  * blocking IO, and should ideally access variables that are  * completely independent of those accessed by other running  * tasks. Minor breaches of these restrictions, for example using  * shared output streams, may be tolerable in practice, but frequent  * use may result in poor performance, and the potential to  * indefinitely stall if the number of threads not waiting for IO or  * other external synchronization becomes exhausted. This usage  * restriction is in part enforced by not permitting checked  * exceptions such as {@code IOExceptions} to be thrown. However,  * computations may still encounter unchecked exceptions, that are  * rethrown to callers attempting to join them. These exceptions may  * additionally include {@link RejectedExecutionException} stemming  * from internal resource exhaustion, such as failure to allocate  * internal task queues.  *  *<p>The primary method for awaiting completion and extracting  * results of a task is {@link #join}, but there are several variants:  * The {@link Future#get} methods support interruptible and/or timed  * waits for completion and report results using {@code Future}  * conventions. Method {@link #helpJoin} enables callers to actively  * execute other tasks while awaiting joins, which is sometimes more  * efficient but only applies when all subtasks are known to be  * strictly tree-structured. Method {@link #invoke} is semantically  * equivalent to {@code fork(); join()} but always attempts to begin  * execution in the current thread. The "<em>quiet</em>" forms of  * these methods do not extract results or report exceptions. These  * may be useful when a set of tasks are being executed, and you need  * to delay processing of results or exceptions until all complete.  * Method {@code invokeAll} (available in multiple versions)  * performs the most common form of parallel invocation: forking a set  * of tasks and joining them all.  *  *<p>The execution status of tasks may be queried at several levels  * of detail: {@link #isDone} is true if a task completed in any way  * (including the case where a task was cancelled without executing);  * {@link #isCompletedNormally} is true if a task completed without  * cancellation or encountering an exception; {@link #isCancelled} is  * true if the task was cancelled (in which case {@link #getException}  * returns a {@link java.util.concurrent.CancellationException}); and  * {@link #isCompletedAbnormally} is true if a task was either  * cancelled or encountered an exception, in which case {@link  * #getException} will return either the encountered exception or  * {@link java.util.concurrent.CancellationException}.  *  *<p>The ForkJoinTask class is not usually directly subclassed.  * Instead, you subclass one of the abstract classes that support a  * particular style of fork/join processing, typically {@link  * RecursiveAction} for computations that do not return results, or  * {@link RecursiveTask} for those that do.  Normally, a concrete  * ForkJoinTask subclass declares fields comprising its parameters,  * established in a constructor, and then defines a {@code compute}  * method that somehow uses the control methods supplied by this base  * class. While these methods have {@code public} access (to allow  * instances of different task subclasses to call each other's  * methods), some of them may only be called from within other  * ForkJoinTasks (as may be determined using method {@link  * #inForkJoinPool}).  Attempts to invoke them in other contexts  * result in exceptions or errors, possibly including  * ClassCastException.  *  *<p>Most base support methods are {@code final}, to prevent  * overriding of implementations that are intrinsically tied to the  * underlying lightweight task scheduling framework.  Developers  * creating new basic styles of fork/join processing should minimally  * implement {@code protected} methods {@link #exec}, {@link  * #setRawResult}, and {@link #getRawResult}, while also introducing  * an abstract computational method that can be implemented in its  * subclasses, possibly relying on other {@code protected} methods  * provided by this class.  *  *<p>ForkJoinTasks should perform relatively small amounts of  * computation. Large tasks should be split into smaller subtasks,  * usually via recursive decomposition. As a very rough rule of thumb,  * a task should perform more than 100 and less than 10000 basic  * computational steps. If tasks are too big, then parallelism cannot  * improve throughput. If too small, then memory and internal task  * maintenance overhead may overwhelm processing.  *  *<p>This class provides {@code adapt} methods for {@link Runnable}  * and {@link Callable}, that may be of use when mixing execution of  * {@code ForkJoinTasks} with other kinds of tasks. When all tasks  * are of this form, consider using a pool in  * {@linkplain ForkJoinPool#setAsyncMode async mode}.  *  *<p>ForkJoinTasks are {@code Serializable}, which enables them to be  * used in extensions such as remote execution frameworks. It is  * sensible to serialize tasks only before or after, but not during,  * execution. Serialization is not relied on during execution itself.  *  * @author Doug Lea  * @since 1.7  */
end_comment

begin_class
DECL|class|ForkJoinTask
specifier|public
specifier|abstract
class|class
name|ForkJoinTask
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Future
argument_list|<
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*      * See the internal documentation of class ForkJoinPool for a      * general implementation overview.  ForkJoinTasks are mainly      * responsible for maintaining their "status" field amidst relays      * to methods in ForkJoinWorkerThread and ForkJoinPool. The      * methods of this class are more-or-less layered into (1) basic      * status maintenance (2) execution and awaiting completion (3)      * user-level methods that additionally report results. This is      * sometimes hard to see because this file orders exported methods      * in a way that flows well in javadocs.      */
comment|/**      * Run control status bits packed into a single int to minimize      * footprint and to ensure atomicity (via CAS).  Status is      * initially zero, and takes on nonnegative values until      * completed, upon which status holds COMPLETED. CANCELLED, or      * EXCEPTIONAL, which use the top 3 bits.  Tasks undergoing      * blocking waits by other threads have SIGNAL_MASK bits set --      * bit 15 for external (nonFJ) waits, and the rest a count of      * waiting FJ threads.  (This representation relies on      * ForkJoinPool max thread limits). Signal counts are not directly      * incremented by ForkJoinTask methods, but instead via a call to      * requestSignal within ForkJoinPool.preJoin, once their need is      * established.      *      * Completion of a stolen task with SIGNAL_MASK bits set awakens      * any waiters via notifyAll. Even though suboptimal for some      * purposes, we use basic builtin wait/notify to take advantage of      * "monitor inflation" in JVMs that we would otherwise need to      * emulate to avoid adding further per-task bookkeeping overhead.      * We want these monitors to be "fat", i.e., not use biasing or      * thin-lock techniques, so use some odd coding idioms that tend      * to avoid them.      *      * Note that bits 16-28 are currently unused. Also value      * 0x80000000 is available as spare completion value.      */
DECL|field|status
specifier|volatile
name|int
name|status
decl_stmt|;
comment|// accessed directly by pool and workers
DECL|field|COMPLETION_MASK
specifier|private
specifier|static
specifier|final
name|int
name|COMPLETION_MASK
init|=
literal|0xe0000000
decl_stmt|;
DECL|field|NORMAL
specifier|private
specifier|static
specifier|final
name|int
name|NORMAL
init|=
literal|0xe0000000
decl_stmt|;
comment|// == mask
DECL|field|CANCELLED
specifier|private
specifier|static
specifier|final
name|int
name|CANCELLED
init|=
literal|0xc0000000
decl_stmt|;
DECL|field|EXCEPTIONAL
specifier|private
specifier|static
specifier|final
name|int
name|EXCEPTIONAL
init|=
literal|0xa0000000
decl_stmt|;
DECL|field|SIGNAL_MASK
specifier|private
specifier|static
specifier|final
name|int
name|SIGNAL_MASK
init|=
literal|0x0000ffff
decl_stmt|;
DECL|field|INTERNAL_SIGNAL_MASK
specifier|private
specifier|static
specifier|final
name|int
name|INTERNAL_SIGNAL_MASK
init|=
literal|0x00007fff
decl_stmt|;
DECL|field|EXTERNAL_SIGNAL
specifier|private
specifier|static
specifier|final
name|int
name|EXTERNAL_SIGNAL
init|=
literal|0x00008000
decl_stmt|;
comment|/**      * Table of exceptions thrown by tasks, to enable reporting by      * callers. Because exceptions are rare, we don't directly keep      * them with task objects, but instead use a weak ref table.  Note      * that cancellation exceptions don't appear in the table, but are      * instead recorded as status values.      * TODO: Use ConcurrentReferenceHashMap      */
DECL|field|exceptionMap
specifier|static
specifier|final
name|Map
argument_list|<
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|,
name|Throwable
argument_list|>
name|exceptionMap
init|=
name|Collections
operator|.
name|synchronizedMap
argument_list|(
operator|new
name|WeakHashMap
argument_list|<
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|,
name|Throwable
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
comment|// Maintaining completion status
comment|/**      * Marks completion and wakes up threads waiting to join this task,      * also clearing signal request bits.      *      * @param completion one of NORMAL, CANCELLED, EXCEPTIONAL      */
DECL|method|setCompletion
specifier|private
name|void
name|setCompletion
parameter_list|(
name|int
name|completion
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|statusOffset
argument_list|,
name|s
argument_list|,
name|completion
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|&
name|SIGNAL_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
condition|)
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
operator|.
name|updateRunningCount
argument_list|(
name|s
operator|&
name|INTERNAL_SIGNAL_MASK
argument_list|)
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
block|}
comment|/**      * Record exception and set exceptional completion      */
DECL|method|setDoneExceptionally
specifier|private
name|void
name|setDoneExceptionally
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|exceptionMap
operator|.
name|put
argument_list|(
name|this
argument_list|,
name|rex
argument_list|)
expr_stmt|;
name|setCompletion
argument_list|(
name|EXCEPTIONAL
argument_list|)
expr_stmt|;
block|}
comment|/**      * Main internal execution method: Unless done, calls exec and      * records completion.      *      * @return true if ran and completed normally      */
DECL|method|tryExec
specifier|final
name|boolean
name|tryExec
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|status
operator|<
literal|0
operator|||
operator|!
name|exec
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|setDoneExceptionally
argument_list|(
name|rex
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|setCompletion
argument_list|(
name|NORMAL
argument_list|)
expr_stmt|;
comment|// must be outside try block
return|return
literal|true
return|;
block|}
comment|/**      * Increments internal signal count (thus requesting signal upon      * completion) unless already done.  Call only once per join.      * Used by ForkJoinPool.preJoin.      *      * @return status      */
DECL|method|requestSignal
specifier|final
name|int
name|requestSignal
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
do|do
block|{         }
do|while
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|statusOffset
argument_list|,
name|s
argument_list|,
name|s
operator|+
literal|1
argument_list|)
condition|)
do|;
return|return
name|s
return|;
block|}
comment|/**      * Sets external signal request unless already done.      *      * @return status      */
DECL|method|requestExternalSignal
specifier|private
name|int
name|requestExternalSignal
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
do|do
block|{         }
do|while
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|statusOffset
argument_list|,
name|s
argument_list|,
name|s
operator||
name|EXTERNAL_SIGNAL
argument_list|)
condition|)
do|;
return|return
name|s
return|;
block|}
comment|/*      * Awaiting completion. The four versions, internal vs external X      * untimed vs timed, have the same overall structure but differ      * from each other enough to defy simple integration.      */
comment|/**      * Blocks a worker until this task is done, also maintaining pool      * and signal counts      */
DECL|method|awaitDone
specifier|private
name|void
name|awaitDone
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
name|w
operator|.
name|pool
operator|.
name|preJoin
argument_list|(
name|this
argument_list|)
expr_stmt|;
while|while
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
try|try
block|{
comment|// minimize lock scope
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|wait
argument_list|()
expr_stmt|;
else|else
block|{
comment|// help release; also helps avoid lock-biasing
name|notifyAll
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|cancelIfTerminating
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Blocks a non-ForkJoin thread until this task is done.      */
DECL|method|externalAwaitDone
specifier|private
name|void
name|externalAwaitDone
parameter_list|()
block|{
if|if
condition|(
name|requestExternalSignal
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
try|try
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|wait
argument_list|()
expr_stmt|;
else|else
block|{
name|notifyAll
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interrupted
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Blocks a worker until this task is done or timeout elapses      */
DECL|method|timedAwaitDone
specifier|private
name|void
name|timedAwaitDone
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|,
name|long
name|nanos
parameter_list|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|ForkJoinPool
name|pool
init|=
name|w
operator|.
name|pool
decl_stmt|;
name|pool
operator|.
name|preJoin
argument_list|(
name|this
argument_list|)
expr_stmt|;
while|while
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
name|long
name|nt
init|=
name|nanos
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|nt
operator|>
literal|0
condition|)
block|{
name|long
name|ms
init|=
name|nt
operator|/
literal|1000000
decl_stmt|;
name|int
name|ns
init|=
call|(
name|int
call|)
argument_list|(
name|nt
operator|%
literal|1000000
argument_list|)
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|wait
argument_list|(
name|ms
argument_list|,
name|ns
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|cancelIfTerminating
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|s
decl_stmt|;
comment|// adjust running count on timeout
while|while
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|&
name|INTERNAL_SIGNAL_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|statusOffset
argument_list|,
name|s
argument_list|,
name|s
operator|-
literal|1
argument_list|)
condition|)
block|{
name|pool
operator|.
name|updateRunningCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Blocks a non-ForkJoin thread until this task is done or timeout elapses      */
DECL|method|externalTimedAwaitDone
specifier|private
name|void
name|externalTimedAwaitDone
parameter_list|(
name|long
name|nanos
parameter_list|)
block|{
if|if
condition|(
name|requestExternalSignal
argument_list|()
operator|>=
literal|0
condition|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
name|long
name|nt
init|=
name|nanos
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|nt
operator|<=
literal|0
condition|)
break|break;
name|long
name|ms
init|=
name|nt
operator|/
literal|1000000
decl_stmt|;
name|int
name|ns
init|=
call|(
name|int
call|)
argument_list|(
name|nt
operator|%
literal|1000000
argument_list|)
decl_stmt|;
try|try
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|wait
argument_list|(
name|ms
argument_list|,
name|ns
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interrupted
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
comment|// reporting results
comment|/**      * Returns result or throws the exception associated with status.      * Uses Unsafe as a workaround for javac not allowing rethrow of      * unchecked exceptions.      */
DECL|method|reportResult
specifier|private
name|V
name|reportResult
parameter_list|()
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|COMPLETION_MASK
operator|)
operator|<
name|NORMAL
condition|)
block|{
name|Throwable
name|ex
init|=
name|getException
argument_list|()
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|UNSAFE
operator|.
name|throwException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
name|getRawResult
argument_list|()
return|;
block|}
comment|/**      * Returns result or throws exception using j.u.c.Future conventions.      * Only call when {@code isDone} known to be true or thread known      * to be interrupted.      */
DECL|method|reportFutureResult
specifier|private
name|V
name|reportFutureResult
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
name|int
name|s
init|=
name|status
operator|&
name|COMPLETION_MASK
decl_stmt|;
if|if
condition|(
name|s
operator|<
name|NORMAL
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|CANCELLED
condition|)
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
if|if
condition|(
name|s
operator|==
name|EXCEPTIONAL
operator|&&
operator|(
name|ex
operator|=
name|exceptionMap
operator|.
name|get
argument_list|(
name|this
argument_list|)
operator|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
name|getRawResult
argument_list|()
return|;
block|}
comment|/**      * Returns result or throws exception using j.u.c.Future conventions      * with timeouts.      */
DECL|method|reportTimedFutureResult
specifier|private
name|V
name|reportTimedFutureResult
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
name|Throwable
name|ex
decl_stmt|;
name|int
name|s
init|=
name|status
operator|&
name|COMPLETION_MASK
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NORMAL
condition|)
return|return
name|getRawResult
argument_list|()
return|;
elseif|else
if|if
condition|(
name|s
operator|==
name|CANCELLED
condition|)
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
elseif|else
if|if
condition|(
name|s
operator|==
name|EXCEPTIONAL
operator|&&
operator|(
name|ex
operator|=
name|exceptionMap
operator|.
name|get
argument_list|(
name|this
argument_list|)
operator|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
else|else
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
comment|// public methods
comment|/**      * Arranges to asynchronously execute this task.  While it is not      * necessarily enforced, it is a usage error to fork a task more      * than once unless it has completed and been reinitialized.      * Subsequent modifications to the state of this task or any data      * it operates on are not necessarily consistently observable by      * any thread other than the one executing it unless preceded by a      * call to {@link #join} or related methods, or a call to {@link      * #isDone} returning {@code true}.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return {@code this}, to simplify usage      */
DECL|method|fork
specifier|public
specifier|final
name|ForkJoinTask
argument_list|<
name|V
argument_list|>
name|fork
parameter_list|()
block|{
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|pushTask
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Returns the result of the computation when it {@link #isDone is done}.      * This method differs from {@link #get()} in that      * abnormal completion results in {@code RuntimeException} or      * {@code Error}, not {@code ExecutionException}.      *      * @return the computed result      */
DECL|method|join
specifier|public
specifier|final
name|V
name|join
parameter_list|()
block|{
name|quietlyJoin
argument_list|()
expr_stmt|;
return|return
name|reportResult
argument_list|()
return|;
block|}
comment|/**      * Commences performing this task, awaits its completion if      * necessary, and return its result, or throws an (unchecked)      * exception if the underlying computation did so.      *      * @return the computed result      */
DECL|method|invoke
specifier|public
specifier|final
name|V
name|invoke
parameter_list|()
block|{
if|if
condition|(
operator|!
name|tryExec
argument_list|()
condition|)
name|quietlyJoin
argument_list|()
expr_stmt|;
return|return
name|reportResult
argument_list|()
return|;
block|}
comment|/**      * Forks the given tasks, returning when {@code isDone} holds for      * each task or an (unchecked) exception is encountered, in which      * case the exception is rethrown.  If either task encounters an      * exception, the other one may be, but is not guaranteed to be,      * cancelled.  If both tasks throw an exception, then this method      * throws one of them.  The individual status of each task may be      * checked using {@link #getException()} and related methods.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @param t1 the first task      * @param t2 the second task      * @throws NullPointerException if any task is null      */
DECL|method|invokeAll
specifier|public
specifier|static
name|void
name|invokeAll
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t1
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t2
parameter_list|)
block|{
name|t2
operator|.
name|fork
argument_list|()
expr_stmt|;
name|t1
operator|.
name|invoke
argument_list|()
expr_stmt|;
name|t2
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
comment|/**      * Forks the given tasks, returning when {@code isDone} holds for      * each task or an (unchecked) exception is encountered, in which      * case the exception is rethrown. If any task encounters an      * exception, others may be, but are not guaranteed to be,      * cancelled.  If more than one task encounters an exception, then      * this method throws any one of these exceptions.  The individual      * status of each task may be checked using {@link #getException()}      * and related methods.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @param tasks the tasks      * @throws NullPointerException if any task is null      */
DECL|method|invokeAll
specifier|public
specifier|static
name|void
name|invokeAll
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
modifier|...
name|tasks
parameter_list|)
block|{
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|int
name|last
init|=
name|tasks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|last
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|tasks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|t
operator|.
name|fork
argument_list|()
expr_stmt|;
else|else
block|{
name|t
operator|.
name|quietlyInvoke
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|tasks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|t
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|.
name|quietlyJoin
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|UNSAFE
operator|.
name|throwException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/**      * Forks all tasks in the specified collection, returning when      * {@code isDone} holds for each task or an (unchecked) exception      * is encountered.  If any task encounters an exception, others      * may be, but are not guaranteed to be, cancelled.  If more than      * one task encounters an exception, then this method throws any      * one of these exceptions.  The individual status of each task      * may be checked using {@link #getException()} and related      * methods.  The behavior of this operation is undefined if the      * specified collection is modified while the operation is in      * progress.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @param tasks the collection of tasks      * @return the tasks argument, to simplify usage      * @throws NullPointerException if tasks or any element are null      */
DECL|method|invokeAll
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|invokeAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|tasks
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|tasks
operator|instanceof
name|RandomAccess
operator|)
operator|||
operator|!
operator|(
name|tasks
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
operator|)
condition|)
block|{
name|invokeAll
argument_list|(
name|tasks
operator|.
name|toArray
argument_list|(
operator|new
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[
name|tasks
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tasks
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|?
extends|extends
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
name|ts
init|=
operator|(
name|List
argument_list|<
name|?
extends|extends
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
operator|)
name|tasks
decl_stmt|;
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|int
name|last
init|=
name|ts
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|last
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|ts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|t
operator|.
name|fork
argument_list|()
expr_stmt|;
else|else
block|{
name|t
operator|.
name|quietlyInvoke
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|ts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|t
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|.
name|quietlyJoin
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|UNSAFE
operator|.
name|throwException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
name|tasks
return|;
block|}
comment|/**      * Attempts to cancel execution of this task. This attempt will      * fail if the task has already completed, has already been      * cancelled, or could not be cancelled for some other reason. If      * successful, and this task has not started when cancel is      * called, execution of this task is suppressed, {@link      * #isCancelled} will report true, and {@link #join} will result      * in a {@code CancellationException} being thrown.      *      *<p>This method may be overridden in subclasses, but if so, must      * still ensure that these minimal properties hold. In particular,      * the {@code cancel} method itself must not throw exceptions.      *      *<p>This method is designed to be invoked by<em>other</em>      * tasks. To terminate the current task, you can just return or      * throw an unchecked exception from its computation method, or      * invoke {@link #completeExceptionally}.      *      * @param mayInterruptIfRunning this value is ignored in the      *                              default implementation because tasks are not      *                              cancelled via interruption      * @return {@code true} if this task is now cancelled      */
DECL|method|cancel
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|setCompletion
argument_list|(
name|CANCELLED
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|&
name|COMPLETION_MASK
operator|)
operator|==
name|CANCELLED
return|;
block|}
comment|/**      * Cancels, ignoring any exceptions it throws. Used during worker      * and pool shutdown.      */
DECL|method|cancelIgnoringExceptions
specifier|final
name|void
name|cancelIgnoringExceptions
parameter_list|()
block|{
try|try
block|{
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignore
parameter_list|)
block|{         }
block|}
comment|/**      * Cancels ignoring exceptions if worker is terminating      */
DECL|method|cancelIfTerminating
specifier|private
name|void
name|cancelIfTerminating
parameter_list|()
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
operator|)
operator|&&
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|isTerminating
argument_list|()
condition|)
block|{
try|try
block|{
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignore
parameter_list|)
block|{             }
block|}
block|}
DECL|method|isDone
specifier|public
specifier|final
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|status
operator|<
literal|0
return|;
block|}
DECL|method|isCancelled
specifier|public
specifier|final
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
operator|(
name|status
operator|&
name|COMPLETION_MASK
operator|)
operator|==
name|CANCELLED
return|;
block|}
comment|/**      * Returns {@code true} if this task threw an exception or was cancelled.      *      * @return {@code true} if this task threw an exception or was cancelled      */
DECL|method|isCompletedAbnormally
specifier|public
specifier|final
name|boolean
name|isCompletedAbnormally
parameter_list|()
block|{
return|return
operator|(
name|status
operator|&
name|COMPLETION_MASK
operator|)
operator|<
name|NORMAL
return|;
block|}
comment|/**      * Returns {@code true} if this task completed without throwing an      * exception and was not cancelled.      *      * @return {@code true} if this task completed without throwing an      *         exception and was not cancelled      */
DECL|method|isCompletedNormally
specifier|public
specifier|final
name|boolean
name|isCompletedNormally
parameter_list|()
block|{
return|return
operator|(
name|status
operator|&
name|COMPLETION_MASK
operator|)
operator|==
name|NORMAL
return|;
block|}
comment|/**      * Returns the exception thrown by the base computation, or a      * {@code CancellationException} if cancelled, or {@code null} if      * none or if the method has not yet completed.      *      * @return the exception, or {@code null} if none      */
DECL|method|getException
specifier|public
specifier|final
name|Throwable
name|getException
parameter_list|()
block|{
name|int
name|s
init|=
name|status
operator|&
name|COMPLETION_MASK
decl_stmt|;
return|return
operator|(
operator|(
name|s
operator|>=
name|NORMAL
operator|)
condition|?
literal|null
else|:
operator|(
name|s
operator|==
name|CANCELLED
operator|)
condition|?
operator|new
name|CancellationException
argument_list|()
else|:
name|exceptionMap
operator|.
name|get
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Completes this task abnormally, and if not already aborted or      * cancelled, causes it to throw the given exception upon      * {@code join} and related operations. This method may be used      * to induce exceptions in asynchronous tasks, or to force      * completion of tasks that would not otherwise complete.  Its use      * in other situations is discouraged.  This method is      * overridable, but overridden versions must invoke {@code super}      * implementation to maintain guarantees.      *      * @param ex the exception to throw. If this exception is not a      *           {@code RuntimeException} or {@code Error}, the actual exception      *           thrown will be a {@code RuntimeException} with cause {@code ex}.      */
DECL|method|completeExceptionally
specifier|public
name|void
name|completeExceptionally
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|setDoneExceptionally
argument_list|(
operator|(
name|ex
operator|instanceof
name|RuntimeException
operator|)
operator|||
operator|(
name|ex
operator|instanceof
name|Error
operator|)
condition|?
name|ex
else|:
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Completes this task, and if not already aborted or cancelled,      * returning a {@code null} result upon {@code join} and related      * operations. This method may be used to provide results for      * asynchronous tasks, or to provide alternative handling for      * tasks that would not otherwise complete normally. Its use in      * other situations is discouraged. This method is      * overridable, but overridden versions must invoke {@code super}      * implementation to maintain guarantees.      *      * @param value the result value for this task      */
DECL|method|complete
specifier|public
name|void
name|complete
parameter_list|(
name|V
name|value
parameter_list|)
block|{
try|try
block|{
name|setRawResult
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|setDoneExceptionally
argument_list|(
name|rex
argument_list|)
expr_stmt|;
return|return;
block|}
name|setCompletion
argument_list|(
name|NORMAL
argument_list|)
expr_stmt|;
block|}
DECL|method|get
specifier|public
specifier|final
name|V
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
name|quietlyJoin
argument_list|()
expr_stmt|;
return|return
name|reportFutureResult
argument_list|()
return|;
block|}
DECL|method|get
specifier|public
specifier|final
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
condition|)
block|{
name|ForkJoinWorkerThread
name|w
init|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|unpushTask
argument_list|(
name|this
argument_list|)
operator|||
operator|!
name|tryExec
argument_list|()
condition|)
name|timedAwaitDone
argument_list|(
name|w
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
block|}
else|else
name|externalTimedAwaitDone
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
return|return
name|reportTimedFutureResult
argument_list|()
return|;
block|}
comment|/**      * Possibly executes other tasks until this task {@link #isDone is      * done}, then returns the result of the computation.  This method      * may be more efficient than {@code join}, but is only applicable      * when there are no potential dependencies between continuation      * of the current task and that of any other task that might be      * executed while helping. (This usually holds for pure      * divide-and-conquer tasks).      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return the computed result      */
DECL|method|helpJoin
specifier|public
specifier|final
name|V
name|helpJoin
parameter_list|()
block|{
name|quietlyHelpJoin
argument_list|()
expr_stmt|;
return|return
name|reportResult
argument_list|()
return|;
block|}
comment|/**      * Possibly executes other tasks until this task {@link #isDone is      * done}.  This method may be useful when processing collections      * of tasks when some have been cancelled or otherwise known to      * have aborted.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      */
DECL|method|quietlyHelpJoin
specifier|public
specifier|final
name|void
name|quietlyHelpJoin
parameter_list|()
block|{
name|ForkJoinWorkerThread
name|w
init|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|unpushTask
argument_list|(
name|this
argument_list|)
operator|||
operator|!
name|tryExec
argument_list|()
condition|)
block|{
while|while
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|w
operator|.
name|scanWhileJoining
argument_list|(
name|this
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|awaitDone
argument_list|(
name|w
argument_list|)
expr_stmt|;
break|break;
block|}
name|t
operator|.
name|tryExec
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Joins this task, without returning its result or throwing an      * exception. This method may be useful when processing      * collections of tasks when some have been cancelled or otherwise      * known to have aborted.      */
DECL|method|quietlyJoin
specifier|public
specifier|final
name|void
name|quietlyJoin
parameter_list|()
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
condition|)
block|{
name|ForkJoinWorkerThread
name|w
init|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|w
operator|.
name|unpushTask
argument_list|(
name|this
argument_list|)
operator|||
operator|!
name|tryExec
argument_list|()
condition|)
name|awaitDone
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
else|else
name|externalAwaitDone
argument_list|()
expr_stmt|;
block|}
comment|/**      * Commences performing this task and awaits its completion if      * necessary, without returning its result or throwing an      * exception. This method may be useful when processing      * collections of tasks when some have been cancelled or otherwise      * known to have aborted.      */
DECL|method|quietlyInvoke
specifier|public
specifier|final
name|void
name|quietlyInvoke
parameter_list|()
block|{
if|if
condition|(
operator|!
name|tryExec
argument_list|()
condition|)
name|quietlyJoin
argument_list|()
expr_stmt|;
block|}
comment|/**      * Possibly executes tasks until the pool hosting the current task      * {@link ForkJoinPool#isQuiescent is quiescent}. This method may      * be of use in designs in which many tasks are forked, but none      * are explicitly joined, instead executing them until all are      * processed.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      */
DECL|method|helpQuiesce
specifier|public
specifier|static
name|void
name|helpQuiesce
parameter_list|()
block|{
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|helpQuiescePool
argument_list|()
expr_stmt|;
block|}
comment|/**      * Resets the internal bookkeeping state of this task, allowing a      * subsequent {@code fork}. This method allows repeated reuse of      * this task, but only if reuse occurs when this task has either      * never been forked, or has been forked, then completed and all      * outstanding joins of this task have also completed. Effects      * under any other usage conditions are not guaranteed.      * This method may be useful when executing      * pre-constructed trees of subtasks in loops.      */
DECL|method|reinitialize
specifier|public
name|void
name|reinitialize
parameter_list|()
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|COMPLETION_MASK
operator|)
operator|==
name|EXCEPTIONAL
condition|)
name|exceptionMap
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Returns the pool hosting the current task execution, or null      * if this task is executing outside of any ForkJoinPool.      *      * @return the pool, or {@code null} if none      * @see #inForkJoinPool      */
DECL|method|getPool
specifier|public
specifier|static
name|ForkJoinPool
name|getPool
parameter_list|()
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
return|return
operator|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
else|:
literal|null
return|;
block|}
comment|/**      * Returns {@code true} if the current thread is executing as a      * ForkJoinPool computation.      *      * @return {@code true} if the current thread is executing as a      *         ForkJoinPool computation, or false otherwise      */
DECL|method|inForkJoinPool
specifier|public
specifier|static
name|boolean
name|inForkJoinPool
parameter_list|()
block|{
return|return
name|Thread
operator|.
name|currentThread
argument_list|()
operator|instanceof
name|ForkJoinWorkerThread
return|;
block|}
comment|/**      * Tries to unschedule this task for execution. This method will      * typically succeed if this task is the most recently forked task      * by the current thread, and has not commenced executing in      * another thread.  This method may be useful when arranging      * alternative local processing of tasks that could have been, but      * were not, stolen.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return {@code true} if unforked      */
DECL|method|tryUnfork
specifier|public
name|boolean
name|tryUnfork
parameter_list|()
block|{
return|return
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|unpushTask
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns an estimate of the number of tasks that have been      * forked by the current worker thread but not yet executed. This      * value may be useful for heuristic decisions about whether to      * fork other tasks.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return the number of tasks      */
DECL|method|getQueuedTaskCount
specifier|public
specifier|static
name|int
name|getQueuedTaskCount
parameter_list|()
block|{
return|return
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|getQueueSize
argument_list|()
return|;
block|}
comment|/**      * Returns an estimate of how many more locally queued tasks are      * held by the current worker thread than there are other worker      * threads that might steal them.  This value may be useful for      * heuristic decisions about whether to fork other tasks. In many      * usages of ForkJoinTasks, at steady state, each worker should      * aim to maintain a small constant surplus (for example, 3) of      * tasks, and to process computations locally if this threshold is      * exceeded.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return the surplus number of tasks, which may be negative      */
DECL|method|getSurplusQueuedTaskCount
specifier|public
specifier|static
name|int
name|getSurplusQueuedTaskCount
parameter_list|()
block|{
return|return
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|getEstimatedSurplusTaskCount
argument_list|()
return|;
block|}
comment|// Extension methods
comment|/**      * Returns the result that would be returned by {@link #join}, even      * if this task completed abnormally, or {@code null} if this task      * is not known to have been completed.  This method is designed      * to aid debugging, as well as to support extensions. Its use in      * any other context is discouraged.      *      * @return the result, or {@code null} if not completed      */
DECL|method|getRawResult
specifier|public
specifier|abstract
name|V
name|getRawResult
parameter_list|()
function_decl|;
comment|/**      * Forces the given value to be returned as a result.  This method      * is designed to support extensions, and should not in general be      * called otherwise.      *      * @param value the value      */
DECL|method|setRawResult
specifier|protected
specifier|abstract
name|void
name|setRawResult
parameter_list|(
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Immediately performs the base action of this task.  This method      * is designed to support extensions, and should not in general be      * called otherwise. The return value controls whether this task      * is considered to be done normally. It may return false in      * asynchronous actions that require explicit invocations of      * {@link #complete} to become joinable. It may also throw an      * (unchecked) exception to indicate abnormal exit.      *      * @return {@code true} if completed normally      */
DECL|method|exec
specifier|protected
specifier|abstract
name|boolean
name|exec
parameter_list|()
function_decl|;
comment|/**      * Returns, but does not unschedule or execute, a task queued by      * the current thread but not yet executed, if one is immediately      * available. There is no guarantee that this task will actually      * be polled or executed next. Conversely, this method may return      * null even if a task exists but cannot be accessed without      * contention with other threads.  This method is designed      * primarily to support extensions, and is unlikely to be useful      * otherwise.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return the next task, or {@code null} if none are available      */
DECL|method|peekNextLocalTask
specifier|protected
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|peekNextLocalTask
parameter_list|()
block|{
return|return
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|peekTask
argument_list|()
return|;
block|}
comment|/**      * Unschedules and returns, without executing, the next task      * queued by the current thread but not yet executed.  This method      * is designed primarily to support extensions, and is unlikely to      * be useful otherwise.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return the next task, or {@code null} if none are available      */
DECL|method|pollNextLocalTask
specifier|protected
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollNextLocalTask
parameter_list|()
block|{
return|return
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|pollLocalTask
argument_list|()
return|;
block|}
comment|/**      * Unschedules and returns, without executing, the next task      * queued by the current thread but not yet executed, if one is      * available, or if not available, a task that was forked by some      * other thread, if available. Availability may be transient, so a      * {@code null} result does not necessarily imply quiescence      * of the pool this task is operating in.  This method is designed      * primarily to support extensions, and is unlikely to be useful      * otherwise.      *      *<p>This method may be invoked only from within {@code      * ForkJoinTask} computations (as may be determined using method      * {@link #inForkJoinPool}).  Attempts to invoke in other contexts      * result in exceptions or errors, possibly including {@code      * ClassCastException}.      *      * @return a task, or {@code null} if none are available      */
DECL|method|pollTask
specifier|protected
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollTask
parameter_list|()
block|{
return|return
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|.
name|pollTask
argument_list|()
return|;
block|}
comment|/**      * Adaptor for Runnables. This implements RunnableFuture      * to be compliant with AbstractExecutorService constraints      * when used in ForkJoinPool.      */
DECL|class|AdaptedRunnable
specifier|static
specifier|final
class|class
name|AdaptedRunnable
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
implements|implements
name|RunnableFuture
argument_list|<
name|T
argument_list|>
block|{
DECL|field|runnable
specifier|final
name|Runnable
name|runnable
decl_stmt|;
DECL|field|resultOnCompletion
specifier|final
name|T
name|resultOnCompletion
decl_stmt|;
DECL|field|result
name|T
name|result
decl_stmt|;
DECL|method|AdaptedRunnable
name|AdaptedRunnable
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|T
name|result
parameter_list|)
block|{
if|if
condition|(
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|runnable
operator|=
name|runnable
expr_stmt|;
name|this
operator|.
name|resultOnCompletion
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
name|T
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|setRawResult
specifier|public
name|void
name|setRawResult
parameter_list|(
name|T
name|v
parameter_list|)
block|{
name|result
operator|=
name|v
expr_stmt|;
block|}
DECL|method|exec
specifier|public
name|boolean
name|exec
parameter_list|()
block|{
name|runnable
operator|.
name|run
argument_list|()
expr_stmt|;
name|result
operator|=
name|resultOnCompletion
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|invoke
argument_list|()
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|/**      * Adaptor for Callables      */
DECL|class|AdaptedCallable
specifier|static
specifier|final
class|class
name|AdaptedCallable
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
implements|implements
name|RunnableFuture
argument_list|<
name|T
argument_list|>
block|{
DECL|field|callable
specifier|final
name|Callable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|callable
decl_stmt|;
DECL|field|result
name|T
name|result
decl_stmt|;
DECL|method|AdaptedCallable
name|AdaptedCallable
parameter_list|(
name|Callable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|callable
parameter_list|)
block|{
if|if
condition|(
name|callable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|callable
operator|=
name|callable
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
name|T
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|setRawResult
specifier|public
name|void
name|setRawResult
parameter_list|(
name|T
name|v
parameter_list|)
block|{
name|result
operator|=
name|v
expr_stmt|;
block|}
DECL|method|exec
specifier|public
name|boolean
name|exec
parameter_list|()
block|{
try|try
block|{
name|result
operator|=
name|callable
operator|.
name|call
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Error
name|err
parameter_list|)
block|{
throw|throw
name|err
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|rex
parameter_list|)
block|{
throw|throw
name|rex
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|invoke
argument_list|()
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2838392045355241008L
decl_stmt|;
block|}
comment|/**      * Returns a new {@code ForkJoinTask} that performs the {@code run}      * method of the given {@code Runnable} as its action, and returns      * a null result upon {@link #join}.      *      * @param runnable the runnable action      * @return the task      */
DECL|method|adapt
specifier|public
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|adapt
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
return|return
operator|new
name|AdaptedRunnable
argument_list|<
name|Void
argument_list|>
argument_list|(
name|runnable
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new {@code ForkJoinTask} that performs the {@code run}      * method of the given {@code Runnable} as its action, and returns      * the given result upon {@link #join}.      *      * @param runnable the runnable action      * @param result   the result upon completion      * @return the task      */
DECL|method|adapt
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|adapt
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|T
name|result
parameter_list|)
block|{
return|return
operator|new
name|AdaptedRunnable
argument_list|<
name|T
argument_list|>
argument_list|(
name|runnable
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**      * Returns a new {@code ForkJoinTask} that performs the {@code call}      * method of the given {@code Callable} as its action, and returns      * its result upon {@link #join}, translating any checked exceptions      * encountered into {@code RuntimeException}.      *      * @param callable the callable action      * @return the task      */
DECL|method|adapt
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|adapt
parameter_list|(
name|Callable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|callable
parameter_list|)
block|{
return|return
operator|new
name|AdaptedCallable
argument_list|<
name|T
argument_list|>
argument_list|(
name|callable
argument_list|)
return|;
block|}
comment|// Serialization support
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|7721805057305804111L
decl_stmt|;
comment|/**      * Saves the state to a stream.      *      * @param s the stream      * @serialData the current run status and the exception thrown      * during execution, or {@code null} if none      */
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reconstitutes the instance from a stream.      *      * @param s the stream      */
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|status
operator|&=
operator|~
name|INTERNAL_SIGNAL_MASK
expr_stmt|;
comment|// clear internal signal counts
name|status
operator||=
name|EXTERNAL_SIGNAL
expr_stmt|;
comment|// conservatively set external signal
name|Object
name|ex
init|=
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|setDoneExceptionally
argument_list|(
operator|(
name|Throwable
operator|)
name|ex
argument_list|)
expr_stmt|;
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
init|=
name|getUnsafe
argument_list|()
decl_stmt|;
DECL|field|statusOffset
specifier|private
specifier|static
specifier|final
name|long
name|statusOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"status"
argument_list|,
name|ForkJoinTask
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|objectFieldOffset
specifier|private
specifier|static
name|long
name|objectFieldOffset
parameter_list|(
name|String
name|field
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|klazz
parameter_list|)
block|{
try|try
block|{
return|return
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|klazz
operator|.
name|getDeclaredField
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
comment|// Convert Exception to corresponding Error
name|NoSuchFieldError
name|error
init|=
operator|new
name|NoSuchFieldError
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

