begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.concurrent.jsr166y
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|concurrent
operator|.
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * An {@link ExecutorService} for running {@link ForkJoinTask}s.  * A {@code ForkJoinPool} provides the entry point for submissions  * from non-{@code ForkJoinTask}s, as well as management and  * monitoring operations.  *  *<p>A {@code ForkJoinPool} differs from other kinds of {@link  * ExecutorService} mainly by virtue of employing  *<em>work-stealing</em>: all threads in the pool attempt to find and  * execute subtasks created by other active tasks (eventually blocking  * waiting for work if none exist). This enables efficient processing  * when most tasks spawn other subtasks (as do most {@code  * ForkJoinTask}s). A {@code ForkJoinPool} may also be used for mixed  * execution of some plain {@code Runnable}- or {@code Callable}-  * based activities along with {@code ForkJoinTask}s. When setting  * {@linkplain #setAsyncMode async mode}, a {@code ForkJoinPool} may  * also be appropriate for use with fine-grained tasks of any form  * that are never joined. Otherwise, other {@code ExecutorService}  * implementations are typically more appropriate choices.  *  *<p>A {@code ForkJoinPool} is constructed with a given target  * parallelism level; by default, equal to the number of available  * processors. Unless configured otherwise via {@link  * #setMaintainsParallelism}, the pool attempts to maintain this  * number of active (or available) threads by dynamically adding,  * suspending, or resuming internal worker threads, even if some tasks  * are stalled waiting to join others. However, no such adjustments  * are performed in the face of blocked IO or other unmanaged  * synchronization. The nested {@link ManagedBlocker} interface  * enables extension of the kinds of synchronization accommodated.  * The target parallelism level may also be changed dynamically  * ({@link #setParallelism}). The total number of threads may be  * limited using method {@link #setMaximumPoolSize}, in which case it  * may become possible for the activities of a pool to stall due to  * the lack of available threads to process new tasks. When the pool  * is executing tasks, these and other configuration setting methods  * may only gradually affect actual pool sizes. It is normally best  * practice to invoke these methods only when the pool is known to be  * quiescent.  *  *<p>In addition to execution and lifecycle control methods, this  * class provides status check methods (for example  * {@link #getStealCount}) that are intended to aid in developing,  * tuning, and monitoring fork/join applications. Also, method  * {@link #toString} returns indications of pool state in a  * convenient form for informal monitoring.  *  *<p><b>Sample Usage.</b> Normally a single {@code ForkJoinPool} is  * used for all parallel task execution in a program or subsystem.  * Otherwise, use would not usually outweigh the construction and  * bookkeeping overhead of creating a large set of threads. For  * example, a common pool could be used for the {@code SortTasks}  * illustrated in {@link RecursiveAction}. Because {@code  * ForkJoinPool} uses threads in {@linkplain java.lang.Thread#isDaemon  * daemon} mode, there is typically no need to explicitly {@link  * #shutdown} such a pool upon program exit.  *  *<pre>  * static final ForkJoinPool mainPool = new ForkJoinPool();  * ...  * public void sort(long[] array) {  *   mainPool.invoke(new SortTask(array, 0, array.length));  * }  *</pre>  *  *<p><b>Implementation notes</b>: This implementation restricts the  * maximum number of running threads to 32767. Attempts to create  * pools with greater than the maximum number result in  * {@code IllegalArgumentException}.  *  *<p>This implementation rejects submitted tasks (that is, by throwing  * {@link RejectedExecutionException}) only when the pool is shut down.  *  * @author Doug Lea  * @since 1.7  */
end_comment

begin_class
DECL|class|ForkJoinPool
specifier|public
class|class
name|ForkJoinPool
extends|extends
name|AbstractExecutorService
block|{
comment|/*      * Implementation Overview      *      * This class provides the central bookkeeping and control for a      * set of worker threads: Submissions from non-FJ threads enter      * into a submission queue. Workers take these tasks and typically      * split them into subtasks that may be stolen by other workers.      * The main work-stealing mechanics implemented in class      * ForkJoinWorkerThread give first priority to processing tasks      * from their own queues (LIFO or FIFO, depending on mode), then      * to randomized FIFO steals of tasks in other worker queues, and      * lastly to new submissions. These mechanics do not consider      * affinities, loads, cache localities, etc, so rarely provide the      * best possible performance on a given machine, but portably      * provide good throughput by averaging over these factors.      * (Further, even if we did try to use such information, we do not      * usually have a basis for exploiting it. For example, some sets      * of tasks profit from cache affinities, but others are harmed by      * cache pollution effects.)      *      * The main throughput advantages of work-stealing stem from      * decentralized control -- workers mostly steal tasks from each      * other. We do not want to negate this by creating bottlenecks      * implementing the management responsibilities of this class. So      * we use a collection of techniques that avoid, reduce, or cope      * well with contention. These entail several instances of      * bit-packing into CASable fields to maintain only the minimally      * required atomicity. To enable such packing, we restrict maximum      * parallelism to (1<<15)-1 (enabling twice this to fit into a 16      * bit field), which is far in excess of normal operating range.      * Even though updates to some of these bookkeeping fields do      * sometimes contend with each other, they don't normally      * cache-contend with updates to others enough to warrant memory      * padding or isolation. So they are all held as fields of      * ForkJoinPool objects.  The main capabilities are as follows:      *      * 1. Creating and removing workers. Workers are recorded in the      * "workers" array. This is an array as opposed to some other data      * structure to support index-based random steals by workers.      * Updates to the array recording new workers and unrecording      * terminated ones are protected from each other by a lock      * (workerLock) but the array is otherwise concurrently readable,      * and accessed directly by workers. To simplify index-based      * operations, the array size is always a power of two, and all      * readers must tolerate null slots. Currently, all but the first      * worker thread creation is on-demand, triggered by task      * submissions, replacement of terminated workers, and/or      * compensation for blocked workers. However, all other support      * code is set up to work with other policies.      *      * 2. Bookkeeping for dynamically adding and removing workers. We      * maintain a given level of parallelism (or, if      * maintainsParallelism is false, at least avoid starvation). When      * some workers are known to be blocked (on joins or via      * ManagedBlocker), we may create or resume others to take their      * place until they unblock (see below). Implementing this      * requires counts of the number of "running" threads (i.e., those      * that are neither blocked nor artifically suspended) as well as      * the total number.  These two values are packed into one field,      * "workerCounts" because we need accurate snapshots when deciding      * to create, resume or suspend.  To support these decisions,      * updates must be prospective (not retrospective).  For example,      * the running count is decremented before blocking by a thread      * about to block, but incremented by the thread about to unblock      * it. (In a few cases, these prospective updates may need to be      * rolled back, for example when deciding to create a new worker      * but the thread factory fails or returns null. In these cases,      * we are no worse off wrt other decisions than we would be      * otherwise.)  Updates to the workerCounts field sometimes      * transiently encounter a fair amount of contention when join      * dependencies are such that many threads block or unblock at      * about the same time. We alleviate this by sometimes bundling      * updates (for example blocking one thread on join and resuming a      * spare cancel each other out), and in most other cases      * performing an alternative action (like releasing waiters and      * finding spares; see below) as a more productive form of      * backoff.      *      * 3. Maintaining global run state. The run state of the pool      * consists of a runLevel (SHUTDOWN, TERMINATING, etc) similar to      * those in other Executor implementations, as well as a count of      * "active" workers -- those that are, or soon will be, or      * recently were executing tasks. The runLevel and active count      * are packed together in order to correctly trigger shutdown and      * termination. Without care, active counts can be subject to very      * high contention.  We substantially reduce this contention by      * relaxing update rules.  A worker must claim active status      * prospectively, by activating if it sees that a submitted or      * stealable task exists (it may find after activating that the      * task no longer exists). It stays active while processing this      * task (if it exists) and any other local subtasks it produces,      * until it cannot find any other tasks. It then tries      * inactivating (see method preStep), but upon update contention      * instead scans for more tasks, later retrying inactivation if it      * doesn't find any.      *      * 4. Managing idle workers waiting for tasks. We cannot let      * workers spin indefinitely scanning for tasks when none are      * available. On the other hand, we must quickly prod them into      * action when new tasks are submitted or generated.  We      * park/unpark these idle workers using an event-count scheme.      * Field eventCount is incremented upon events that may enable      * workers that previously could not find a task to now find one:      * Submission of a new task to the pool, or another worker pushing      * a task onto a previously empty queue.  (We also use this      * mechanism for termination and reconfiguration actions that      * require wakeups of idle workers).  Each worker maintains its      * last known event count, and blocks when a scan for work did not      * find a task AND its lastEventCount matches the current      * eventCount. Waiting idle workers are recorded in a variant of      * Treiber stack headed by field eventWaiters which, when nonzero,      * encodes the thread index and count awaited for by the worker      * thread most recently calling eventSync. This thread in turn has      * a record (field nextEventWaiter) for the next waiting worker.      * In addition to allowing simpler decisions about need for      * wakeup, the event count bits in eventWaiters serve the role of      * tags to avoid ABA errors in Treiber stacks.  To reduce delays      * in task diffusion, workers not otherwise occupied may invoke      * method releaseWaiters, that removes and signals (unparks)      * workers not waiting on current count. To minimize task      * production stalls associate with signalling, any worker pushing      * a task on an empty queue invokes the weaker method signalWork,      * that only releases idle workers until it detects interference      * by other threads trying to release, and lets them take      * over. The net effect is a tree-like diffusion of signals, where      * released threads and possibly others) help with unparks.  To      * further reduce contention effects a bit, failed CASes to      * increment field eventCount are tolerated without retries.      * Conceptually they are merged into the same event, which is OK      * when their only purpose is to enable workers to scan for work.      *      * 5. Managing suspension of extra workers. When a worker is about      * to block waiting for a join (or via ManagedBlockers), we may      * create a new thread to maintain parallelism level, or at least      * avoid starvation (see below). Usually, extra threads are needed      * for only very short periods, yet join dependencies are such      * that we sometimes need them in bursts. Rather than create new      * threads each time this happens, we suspend no-longer-needed      * extra ones as "spares". For most purposes, we don't distinguish      * "extra" spare threads from normal "core" threads: On each call      * to preStep (the only point at which we can do this) a worker      * checks to see if there are now too many running workers, and if      * so, suspends itself.  Methods preJoin and doBlock look for      * suspended threads to resume before considering creating a new      * replacement. We don't need a special data structure to maintain      * spares; simply scanning the workers array looking for      * worker.isSuspended() is fine because the calling thread is      * otherwise not doing anything useful anyway; we are at least as      * happy if after locating a spare, the caller doesn't actually      * block because the join is ready before we try to adjust and      * compensate.  Note that this is intrinsically racy.  One thread      * may become a spare at about the same time as another is      * needlessly being created. We counteract this and related slop      * in part by requiring resumed spares to immediately recheck (in      * preStep) to see whether they they should re-suspend. The only      * effective difference between "extra" and "core" threads is that      * we allow the "extra" ones to time out and die if they are not      * resumed within a keep-alive interval of a few seconds. This is      * implemented mainly within ForkJoinWorkerThread, but requires      * some coordination (isTrimmed() -- meaning killed while      * suspended) to correctly maintain pool counts.      *      * 6. Deciding when to create new workers. The main dynamic      * control in this class is deciding when to create extra threads,      * in methods preJoin and doBlock. We always need to create one      * when the number of running threads becomes zero. But because      * blocked joins are typically dependent, we don't necessarily      * need or want one-to-one replacement. Using a one-to-one      * compensation rule often leads to enough useless overhead      * creating, suspending, resuming, and/or killing threads to      * signficantly degrade throughput.  We use a rule reflecting the      * idea that, the more spare threads you already have, the more      * evidence you need to create another one; where "evidence" is      * expressed as the current deficit -- target minus running      * threads. To reduce flickering and drift around target values,      * the relation is quadratic: adding a spare if (dc*dc)>=(sc*pc)      * (where dc is deficit, sc is number of spare threads and pc is      * target parallelism.)  This effectively reduces churn at the      * price of systematically undershooting target parallelism when      * many threads are blocked.  However, biasing toward undeshooting      * partially compensates for the above mechanics to suspend extra      * threads, that normally lead to overshoot because we can only      * suspend workers in-between top-level actions. It also better      * copes with the fact that some of the methods in this class tend      * to never become compiled (but are interpreted), so some      * components of the entire set of controls might execute many      * times faster than others. And similarly for cases where the      * apparent lack of work is just due to GC stalls and other      * transient system activity.      *      * 7. Maintaining other configuration parameters and monitoring      * statistics. Updates to fields controlling parallelism level,      * max size, etc can only meaningfully take effect for individual      * threads upon their next top-level actions; i.e., between      * stealing/running tasks/submission, which are separated by calls      * to preStep.  Memory ordering for these (assumed infrequent)      * reconfiguration calls is ensured by using reads and writes to      * volatile field workerCounts (that must be read in preStep anyway)      * as "fences" -- user-level reads are preceded by reads of      * workCounts, and writes are followed by no-op CAS to      * workerCounts. The values reported by other management and      * monitoring methods are either computed on demand, or are kept      * in fields that are only updated when threads are otherwise      * idle.      *      * Beware that there is a lot of representation-level coupling      * among classes ForkJoinPool, ForkJoinWorkerThread, and      * ForkJoinTask.  For example, direct access to "workers" array by      * workers, and direct access to ForkJoinTask.status by both      * ForkJoinPool and ForkJoinWorkerThread.  There is little point      * trying to reduce this, since any associated future changes in      * representations will need to be accompanied by algorithmic      * changes anyway.      *      * Style notes: There are lots of inline assignments (of form      * "while ((local = field) != 0)") which are usually the simplest      * way to ensure read orderings. Also several occurrences of the      * unusual "do {} while(!cas...)" which is the simplest way to      * force an update of a CAS'ed variable. There are also a few      * other coding oddities that help some methods perform reasonably      * even when interpreted (not compiled).      *      * The order of declarations in this file is: (1) statics (2)      * fields (along with constants used when unpacking some of them)      * (3) internal control methods (4) callbacks and other support      * for ForkJoinTask and ForkJoinWorkerThread classes, (5) exported      * methods (plus a few little helpers).      */
comment|/**      * Factory for creating new {@link ForkJoinWorkerThread}s.      * A {@code ForkJoinWorkerThreadFactory} must be defined and used      * for {@code ForkJoinWorkerThread} subclasses that extend base      * functionality or initialize threads with different contexts.      */
DECL|interface|ForkJoinWorkerThreadFactory
specifier|public
specifier|static
interface|interface
name|ForkJoinWorkerThreadFactory
block|{
comment|/**          * Returns a new worker thread operating in the given pool.          *          * @param pool the pool this thread works in          * @throws NullPointerException if the pool is null          */
DECL|method|newThread
specifier|public
name|ForkJoinWorkerThread
name|newThread
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|)
function_decl|;
block|}
comment|/**      * Default ForkJoinWorkerThreadFactory implementation; creates a      * new ForkJoinWorkerThread.      */
DECL|class|DefaultForkJoinWorkerThreadFactory
specifier|static
class|class
name|DefaultForkJoinWorkerThreadFactory
implements|implements
name|ForkJoinWorkerThreadFactory
block|{
DECL|method|newThread
specifier|public
name|ForkJoinWorkerThread
name|newThread
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|)
block|{
return|return
operator|new
name|ForkJoinWorkerThread
argument_list|(
name|pool
argument_list|)
return|;
block|}
block|}
comment|/**      * Creates a new ForkJoinWorkerThread. This factory is used unless      * overridden in ForkJoinPool constructors.      */
specifier|public
specifier|static
specifier|final
name|ForkJoinWorkerThreadFactory
DECL|field|defaultForkJoinWorkerThreadFactory
name|defaultForkJoinWorkerThreadFactory
init|=
operator|new
name|DefaultForkJoinWorkerThreadFactory
argument_list|()
decl_stmt|;
comment|/**      * Permission required for callers of methods that may start or      * kill threads.      */
DECL|field|modifyThreadPermission
specifier|private
specifier|static
specifier|final
name|RuntimePermission
name|modifyThreadPermission
init|=
operator|new
name|RuntimePermission
argument_list|(
literal|"modifyThread"
argument_list|)
decl_stmt|;
comment|/**      * If there is a security manager, makes sure caller has      * permission to modify threads.      */
DECL|method|checkPermission
specifier|private
specifier|static
name|void
name|checkPermission
parameter_list|()
block|{
name|SecurityManager
name|security
init|=
name|System
operator|.
name|getSecurityManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|security
operator|!=
literal|null
condition|)
name|security
operator|.
name|checkPermission
argument_list|(
name|modifyThreadPermission
argument_list|)
expr_stmt|;
block|}
comment|/**      * Generator for assigning sequence numbers as pool names.      */
DECL|field|poolNumberGenerator
specifier|private
specifier|static
specifier|final
name|AtomicInteger
name|poolNumberGenerator
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**      * Absolute bound for parallelism level. Twice this number must      * fit into a 16bit field to enable word-packing for some counts.      */
DECL|field|MAX_THREADS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_THREADS
init|=
literal|0x7fff
decl_stmt|;
comment|/**      * Array holding all worker threads in the pool.  Array size must      * be a power of two.  Updates and replacements are protected by      * workerLock, but the array is always kept in a consistent enough      * state to be randomly accessed without locking by workers      * performing work-stealing, as well as other traversal-based      * methods in this class. All readers must tolerate that some      * array slots may be null.      */
DECL|field|workers
specifier|volatile
name|ForkJoinWorkerThread
index|[]
name|workers
decl_stmt|;
comment|/**      * Queue for external submissions.      */
DECL|field|submissionQueue
specifier|private
specifier|final
name|LinkedTransferQueue
argument_list|<
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
name|submissionQueue
decl_stmt|;
comment|/**      * Lock protecting updates to workers array.      */
DECL|field|workerLock
specifier|private
specifier|final
name|ReentrantLock
name|workerLock
decl_stmt|;
comment|/**      * Latch released upon termination.      */
DECL|field|terminationLatch
specifier|private
specifier|final
name|CountDownLatch
name|terminationLatch
decl_stmt|;
comment|/**      * Creation factory for worker threads.      */
DECL|field|factory
specifier|private
specifier|final
name|ForkJoinWorkerThreadFactory
name|factory
decl_stmt|;
comment|/**      * Sum of per-thread steal counts, updated only when threads are      * idle or terminating.      */
DECL|field|stealCount
specifier|private
specifier|volatile
name|long
name|stealCount
decl_stmt|;
comment|/**      * Encoded record of top of treiber stack of threads waiting for      * events. The top 32 bits contain the count being waited for. The      * bottom word contains one plus the pool index of waiting worker      * thread.      */
DECL|field|eventWaiters
specifier|private
specifier|volatile
name|long
name|eventWaiters
decl_stmt|;
DECL|field|EVENT_COUNT_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|EVENT_COUNT_SHIFT
init|=
literal|32
decl_stmt|;
DECL|field|WAITER_INDEX_MASK
specifier|private
specifier|static
specifier|final
name|long
name|WAITER_INDEX_MASK
init|=
operator|(
literal|1L
operator|<<
name|EVENT_COUNT_SHIFT
operator|)
operator|-
literal|1L
decl_stmt|;
comment|/**      * A counter for events that may wake up worker threads:      * - Submission of a new task to the pool      * - A worker pushing a task on an empty queue      * - termination and reconfiguration      */
DECL|field|eventCount
specifier|private
specifier|volatile
name|int
name|eventCount
decl_stmt|;
comment|/**      * Lifecycle control. The low word contains the number of workers      * that are (probably) executing tasks. This value is atomically      * incremented before a worker gets a task to run, and decremented      * when worker has no tasks and cannot find any.  Bits 16-18      * contain runLevel value. When all are zero, the pool is      * running. Level transitions are monotonic (running -> shutdown      * -> terminating -> terminated) so each transition adds a bit.      * These are bundled together to ensure consistent read for      * termination checks (i.e., that runLevel is at least SHUTDOWN      * and active threads is zero).      */
DECL|field|runState
specifier|private
specifier|volatile
name|int
name|runState
decl_stmt|;
comment|// Note: The order among run level values matters.
DECL|field|RUNLEVEL_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|RUNLEVEL_SHIFT
init|=
literal|16
decl_stmt|;
DECL|field|SHUTDOWN
specifier|private
specifier|static
specifier|final
name|int
name|SHUTDOWN
init|=
literal|1
operator|<<
name|RUNLEVEL_SHIFT
decl_stmt|;
DECL|field|TERMINATING
specifier|private
specifier|static
specifier|final
name|int
name|TERMINATING
init|=
literal|1
operator|<<
operator|(
name|RUNLEVEL_SHIFT
operator|+
literal|1
operator|)
decl_stmt|;
DECL|field|TERMINATED
specifier|private
specifier|static
specifier|final
name|int
name|TERMINATED
init|=
literal|1
operator|<<
operator|(
name|RUNLEVEL_SHIFT
operator|+
literal|2
operator|)
decl_stmt|;
DECL|field|ACTIVE_COUNT_MASK
specifier|private
specifier|static
specifier|final
name|int
name|ACTIVE_COUNT_MASK
init|=
operator|(
literal|1
operator|<<
name|RUNLEVEL_SHIFT
operator|)
operator|-
literal|1
decl_stmt|;
DECL|field|ONE_ACTIVE
specifier|private
specifier|static
specifier|final
name|int
name|ONE_ACTIVE
init|=
literal|1
decl_stmt|;
comment|// active update delta
comment|/**      * Holds number of total (i.e., created and not yet terminated)      * and running (i.e., not blocked on joins or other managed sync)      * threads, packed together to ensure consistent snapshot when      * making decisions about creating and suspending spare      * threads. Updated only by CAS. Note that adding a new worker      * requires incrementing both counts, since workers start off in      * running state.  This field is also used for memory-fencing      * configuration parameters.      */
DECL|field|workerCounts
specifier|private
specifier|volatile
name|int
name|workerCounts
decl_stmt|;
DECL|field|TOTAL_COUNT_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|TOTAL_COUNT_SHIFT
init|=
literal|16
decl_stmt|;
DECL|field|RUNNING_COUNT_MASK
specifier|private
specifier|static
specifier|final
name|int
name|RUNNING_COUNT_MASK
init|=
operator|(
literal|1
operator|<<
name|TOTAL_COUNT_SHIFT
operator|)
operator|-
literal|1
decl_stmt|;
DECL|field|ONE_RUNNING
specifier|private
specifier|static
specifier|final
name|int
name|ONE_RUNNING
init|=
literal|1
decl_stmt|;
DECL|field|ONE_TOTAL
specifier|private
specifier|static
specifier|final
name|int
name|ONE_TOTAL
init|=
literal|1
operator|<<
name|TOTAL_COUNT_SHIFT
decl_stmt|;
comment|/*      * Fields parallelism. maxPoolSize, locallyFifo,      * maintainsParallelism, and ueh are non-volatile, but external      * reads/writes use workerCount fences to ensure visability.      */
comment|/**      * The target parallelism level.      */
DECL|field|parallelism
specifier|private
name|int
name|parallelism
decl_stmt|;
comment|/**      * The maximum allowed pool size.      */
DECL|field|maxPoolSize
specifier|private
name|int
name|maxPoolSize
decl_stmt|;
comment|/**      * True if use local fifo, not default lifo, for local polling      * Replicated by ForkJoinWorkerThreads      */
DECL|field|locallyFifo
specifier|private
name|boolean
name|locallyFifo
decl_stmt|;
comment|/**      * Controls whether to add spares to maintain parallelism      */
DECL|field|maintainsParallelism
specifier|private
name|boolean
name|maintainsParallelism
decl_stmt|;
comment|/**      * The uncaught exception handler used when any worker      * abruptly terminates      */
DECL|field|ueh
specifier|private
name|Thread
operator|.
name|UncaughtExceptionHandler
name|ueh
decl_stmt|;
comment|/**      * Pool number, just for assigning useful names to worker threads      */
DECL|field|poolNumber
specifier|private
specifier|final
name|int
name|poolNumber
decl_stmt|;
comment|// utilities for updating fields
comment|/**      * Adds delta to running count.  Used mainly by ForkJoinTask.      *      * @param delta the number to add      */
DECL|method|updateRunningCount
specifier|final
name|void
name|updateRunningCount
parameter_list|(
name|int
name|delta
parameter_list|)
block|{
name|int
name|wc
decl_stmt|;
do|do
block|{         }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
operator|=
name|workerCounts
argument_list|,
name|wc
operator|+
name|delta
argument_list|)
condition|)
do|;
block|}
comment|/**      * Write fence for user modifications of pool parameters      * (parallelism. etc).  Note that it doesn't matter if CAS fails.      */
DECL|method|workerCountWriteFence
specifier|private
name|void
name|workerCountWriteFence
parameter_list|()
block|{
name|int
name|wc
decl_stmt|;
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
operator|=
name|workerCounts
argument_list|,
name|wc
argument_list|)
expr_stmt|;
block|}
comment|/**      * Read fence for external reads of pool parameters      * (parallelism. maxPoolSize, etc).      */
DECL|method|workerCountReadFence
specifier|private
name|void
name|workerCountReadFence
parameter_list|()
block|{
name|int
name|ignore
init|=
name|workerCounts
decl_stmt|;
block|}
comment|/**      * Tries incrementing active count; fails on contention.      * Called by workers before executing tasks.      *      * @return true on success      */
DECL|method|tryIncrementActiveCount
specifier|final
name|boolean
name|tryIncrementActiveCount
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
return|return
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|c
operator|=
name|runState
argument_list|,
name|c
operator|+
name|ONE_ACTIVE
argument_list|)
return|;
block|}
comment|/**      * Tries decrementing active count; fails on contention.      * Called when workers cannot find tasks to run.      */
DECL|method|tryDecrementActiveCount
specifier|final
name|boolean
name|tryDecrementActiveCount
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
return|return
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|c
operator|=
name|runState
argument_list|,
name|c
operator|-
name|ONE_ACTIVE
argument_list|)
return|;
block|}
comment|/**      * Advances to at least the given level. Returns true if not      * already in at least the given level.      */
DECL|method|advanceRunLevel
specifier|private
name|boolean
name|advanceRunLevel
parameter_list|(
name|int
name|level
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|s
init|=
name|runState
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|level
operator|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
argument_list|,
name|s
operator||
name|level
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
comment|// workers array maintenance
comment|/**      * Records and returns a workers array index for new worker.      */
DECL|method|recordWorker
specifier|private
name|int
name|recordWorker
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|)
block|{
comment|// Try using slot totalCount-1. If not available, scan and/or resize
name|int
name|k
init|=
operator|(
name|workerCounts
operator|>>>
name|TOTAL_COUNT_SHIFT
operator|)
operator|-
literal|1
decl_stmt|;
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|workerLock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|ForkJoinWorkerThread
index|[]
name|ws
init|=
name|workers
decl_stmt|;
name|int
name|len
init|=
name|ws
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
name|k
operator|>=
name|len
operator|||
name|ws
index|[
name|k
index|]
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|len
operator|&&
name|ws
index|[
name|k
index|]
operator|!=
literal|null
condition|;
operator|++
name|k
control|)
empty_stmt|;
if|if
condition|(
name|k
operator|==
name|len
condition|)
name|ws
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|ws
argument_list|,
name|len
operator|<<
literal|1
argument_list|)
expr_stmt|;
block|}
name|ws
index|[
name|k
index|]
operator|=
name|w
expr_stmt|;
name|workers
operator|=
name|ws
expr_stmt|;
comment|// volatile array write ensures slot visibility
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
name|k
return|;
block|}
comment|/**      * Nulls out record of worker in workers array      */
DECL|method|forgetWorker
specifier|private
name|void
name|forgetWorker
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|)
block|{
name|int
name|idx
init|=
name|w
operator|.
name|poolIndex
decl_stmt|;
comment|// Locking helps method recordWorker avoid unecessary expansion
specifier|final
name|ReentrantLock
name|lock
init|=
name|this
operator|.
name|workerLock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|ForkJoinWorkerThread
index|[]
name|ws
init|=
name|workers
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ws
operator|.
name|length
operator|&&
name|ws
index|[
name|idx
index|]
operator|==
name|w
condition|)
comment|// verify
name|ws
index|[
name|idx
index|]
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|// adding and removing workers
comment|/**      * Tries to create and add new worker. Assumes that worker counts      * are already updated to accommodate the worker, so adjusts on      * failure.      *      * @return new worker or null if creation failed      */
DECL|method|addWorker
specifier|private
name|ForkJoinWorkerThread
name|addWorker
parameter_list|()
block|{
name|ForkJoinWorkerThread
name|w
init|=
literal|null
decl_stmt|;
try|try
block|{
name|w
operator|=
name|factory
operator|.
name|newThread
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
comment|// Adjust on either null or exceptional factory return
if|if
condition|(
name|w
operator|==
literal|null
condition|)
block|{
name|onWorkerCreationFailure
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
name|w
operator|.
name|start
argument_list|(
name|recordWorker
argument_list|(
name|w
argument_list|)
argument_list|,
name|locallyFifo
argument_list|,
name|ueh
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
comment|/**      * Adjusts counts upon failure to create worker      */
DECL|method|onWorkerCreationFailure
specifier|private
name|void
name|onWorkerCreationFailure
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
do|do
block|{         }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|c
operator|=
name|workerCounts
argument_list|,
name|c
operator|-
operator|(
name|ONE_RUNNING
operator||
name|ONE_TOTAL
operator|)
argument_list|)
condition|)
do|;
name|tryTerminate
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// in case of failure during shutdown
block|}
comment|/**      * Create enough total workers to establish target parallelism,      * giving up if terminating or addWorker fails      */
DECL|method|ensureEnoughTotalWorkers
specifier|private
name|void
name|ensureEnoughTotalWorkers
parameter_list|()
block|{
name|int
name|wc
decl_stmt|;
while|while
condition|(
name|runState
operator|<
name|TERMINATING
operator|&&
operator|(
operator|(
name|wc
operator|=
name|workerCounts
operator|)
operator|>>>
name|TOTAL_COUNT_SHIFT
operator|)
operator|<
name|parallelism
condition|)
block|{
if|if
condition|(
operator|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
argument_list|,
name|wc
operator|+
operator|(
name|ONE_RUNNING
operator||
name|ONE_TOTAL
operator|)
argument_list|)
operator|&&
name|addWorker
argument_list|()
operator|==
literal|null
operator|)
condition|)
break|break;
block|}
block|}
comment|/**      * Final callback from terminating worker.  Removes record of      * worker from array, and adjusts counts. If pool is shutting      * down, tries to complete terminatation, else possibly replaces      * the worker.      *      * @param w the worker      */
DECL|method|workerTerminated
specifier|final
name|void
name|workerTerminated
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|)
block|{
if|if
condition|(
name|w
operator|.
name|active
condition|)
block|{
comment|// force inactive
name|w
operator|.
name|active
operator|=
literal|false
expr_stmt|;
do|do
block|{             }
do|while
condition|(
operator|!
name|tryDecrementActiveCount
argument_list|()
condition|)
do|;
block|}
name|forgetWorker
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|// decrement total count, and if was running, running count
name|int
name|unit
init|=
name|w
operator|.
name|isTrimmed
argument_list|()
condition|?
name|ONE_TOTAL
else|:
operator|(
name|ONE_RUNNING
operator||
name|ONE_TOTAL
operator|)
decl_stmt|;
name|int
name|wc
decl_stmt|;
do|do
block|{         }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
operator|=
name|workerCounts
argument_list|,
name|wc
operator|-
name|unit
argument_list|)
condition|)
do|;
name|accumulateStealCount
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|// collect final count
if|if
condition|(
operator|!
name|tryTerminate
argument_list|(
literal|false
argument_list|)
condition|)
name|ensureEnoughTotalWorkers
argument_list|()
expr_stmt|;
block|}
comment|// Waiting for and signalling events
comment|/**      * Ensures eventCount on exit is different (mod 2^32) than on      * entry.  CAS failures are OK -- any change in count suffices.      */
DECL|method|advanceEventCount
specifier|private
name|void
name|advanceEventCount
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|eventCountOffset
argument_list|,
name|c
operator|=
name|eventCount
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Releases workers blocked on a count not equal to current count.      */
DECL|method|releaseWaiters
specifier|final
name|void
name|releaseWaiters
parameter_list|()
block|{
name|long
name|top
decl_stmt|;
name|int
name|id
decl_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|top
operator|=
name|eventWaiters
operator|)
operator|&
name|WAITER_INDEX_MASK
argument_list|)
operator|)
operator|>
literal|0
operator|&&
call|(
name|int
call|)
argument_list|(
name|top
operator|>>>
name|EVENT_COUNT_SHIFT
argument_list|)
operator|!=
name|eventCount
condition|)
block|{
name|ForkJoinWorkerThread
index|[]
name|ws
init|=
name|workers
decl_stmt|;
name|ForkJoinWorkerThread
name|w
decl_stmt|;
if|if
condition|(
name|ws
operator|.
name|length
operator|>=
name|id
operator|&&
operator|(
name|w
operator|=
name|ws
index|[
name|id
operator|-
literal|1
index|]
operator|)
operator|!=
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|eventWaitersOffset
argument_list|,
name|top
argument_list|,
name|w
operator|.
name|nextWaiter
argument_list|)
condition|)
name|LockSupport
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Advances eventCount and releases waiters until interference by      * other releasing threads is detected.      */
DECL|method|signalWork
specifier|final
name|void
name|signalWork
parameter_list|()
block|{
name|int
name|ec
decl_stmt|;
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|eventCountOffset
argument_list|,
name|ec
operator|=
name|eventCount
argument_list|,
name|ec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outer
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|top
init|=
name|eventWaiters
decl_stmt|;
name|ec
operator|=
name|eventCount
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ForkJoinWorkerThread
index|[]
name|ws
decl_stmt|;
name|ForkJoinWorkerThread
name|w
decl_stmt|;
name|int
name|id
init|=
call|(
name|int
call|)
argument_list|(
name|top
operator|&
name|WAITER_INDEX_MASK
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|<=
literal|0
operator|||
call|(
name|int
call|)
argument_list|(
name|top
operator|>>>
name|EVENT_COUNT_SHIFT
argument_list|)
operator|==
name|ec
condition|)
return|return;
if|if
condition|(
operator|(
name|ws
operator|=
name|workers
operator|)
operator|.
name|length
operator|<
name|id
operator|||
operator|(
name|w
operator|=
name|ws
index|[
name|id
operator|-
literal|1
index|]
operator|)
operator|==
literal|null
operator|||
operator|!
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|eventWaitersOffset
argument_list|,
name|top
argument_list|,
name|top
operator|=
name|w
operator|.
name|nextWaiter
argument_list|)
condition|)
continue|continue
name|outer
continue|;
comment|// possibly stale; reread
name|LockSupport
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|!=
name|eventWaiters
condition|)
comment|// let someone else take over
return|return;
block|}
block|}
block|}
comment|/**      * If worker is inactive, blocks until terminating or event count      * advances from last value held by worker; in any case helps      * release others.      *      * @param w the calling worker thread      */
DECL|method|eventSync
specifier|private
name|void
name|eventSync
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|)
block|{
if|if
condition|(
operator|!
name|w
operator|.
name|active
condition|)
block|{
name|int
name|prev
init|=
name|w
operator|.
name|lastEventCount
decl_stmt|;
name|long
name|nextTop
init|=
operator|(
operator|(
operator|(
name|long
operator|)
name|prev
operator|<<
name|EVENT_COUNT_SHIFT
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|poolIndex
operator|+
literal|1
argument_list|)
operator|)
operator|)
decl_stmt|;
name|long
name|top
decl_stmt|;
while|while
condition|(
operator|(
name|runState
operator|<
name|SHUTDOWN
operator|||
operator|!
name|tryTerminate
argument_list|(
literal|false
argument_list|)
operator|)
operator|&&
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|top
operator|=
name|eventWaiters
argument_list|)
operator|&
name|WAITER_INDEX_MASK
operator|)
operator|==
literal|0
operator|||
call|(
name|int
call|)
argument_list|(
name|top
operator|>>>
name|EVENT_COUNT_SHIFT
argument_list|)
operator|==
name|prev
operator|)
operator|&&
name|eventCount
operator|==
name|prev
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|eventWaitersOffset
argument_list|,
name|w
operator|.
name|nextWaiter
operator|=
name|top
argument_list|,
name|nextTop
argument_list|)
condition|)
block|{
name|accumulateStealCount
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|// transfer steals while idle
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
comment|// clear/ignore interrupt
while|while
condition|(
name|eventCount
operator|==
name|prev
condition|)
name|w
operator|.
name|doPark
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|w
operator|.
name|lastEventCount
operator|=
name|eventCount
expr_stmt|;
block|}
name|releaseWaiters
argument_list|()
expr_stmt|;
block|}
comment|/**      * Callback from workers invoked upon each top-level action (i.e.,      * stealing a task or taking a submission and running      * it). Performs one or both of the following:      *      * * If the worker cannot find work, updates its active status to      * inactive and updates activeCount unless there is contention, in      * which case it may try again (either in this or a subsequent      * call).  Additionally, awaits the next task event and/or helps      * wake up other releasable waiters.      *      * * If there are too many running threads, suspends this worker      * (first forcing inactivation if necessary).  If it is not      * resumed before a keepAlive elapses, the worker may be "trimmed"      * -- killed while suspended within suspendAsSpare. Otherwise,      * upon resume it rechecks to make sure that it is still needed.      *      * @param w      the worker      * @param worked false if the worker scanned for work but didn't      *               find any (in which case it may block waiting for work).      */
DECL|method|preStep
specifier|final
name|void
name|preStep
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|,
name|boolean
name|worked
parameter_list|)
block|{
name|boolean
name|active
init|=
name|w
operator|.
name|active
decl_stmt|;
name|boolean
name|inactivate
init|=
operator|!
name|worked
operator|&
name|active
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|inactivate
condition|)
block|{
name|int
name|c
init|=
name|runState
decl_stmt|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|c
argument_list|,
name|c
operator|-
name|ONE_ACTIVE
argument_list|)
condition|)
name|inactivate
operator|=
name|active
operator|=
name|w
operator|.
name|active
operator|=
literal|false
expr_stmt|;
block|}
name|int
name|wc
init|=
name|workerCounts
decl_stmt|;
if|if
condition|(
operator|(
name|wc
operator|&
name|RUNNING_COUNT_MASK
operator|)
operator|<=
name|parallelism
condition|)
block|{
if|if
condition|(
operator|!
name|worked
condition|)
name|eventSync
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|inactivate
operator||=
name|active
operator|)
operator|&&
comment|// must inactivate to suspend
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
argument_list|,
name|wc
operator|-
name|ONE_RUNNING
argument_list|)
operator|&&
operator|!
name|w
operator|.
name|suspendAsSpare
argument_list|()
condition|)
comment|// false if trimmed
return|return;
block|}
block|}
comment|/**      * Adjusts counts and creates or resumes compensating threads for      * a worker about to block on task joinMe, returning early if      * joinMe becomes ready. First tries resuming an existing spare      * (which usually also avoids any count adjustment), but must then      * decrement running count to determine whether a new thread is      * needed. See above for fuller explanation.      */
DECL|method|preJoin
specifier|final
name|void
name|preJoin
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|joinMe
parameter_list|)
block|{
name|boolean
name|dec
init|=
literal|false
decl_stmt|;
comment|// true when running count decremented
for|for
control|(
init|;
condition|;
control|)
block|{
name|releaseWaiters
argument_list|()
expr_stmt|;
comment|// help other threads progress
if|if
condition|(
name|joinMe
operator|.
name|status
operator|<
literal|0
condition|)
comment|// surround spare search with done checks
return|return;
name|ForkJoinWorkerThread
name|spare
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|isSuspended
argument_list|()
condition|)
block|{
name|spare
operator|=
name|w
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|joinMe
operator|.
name|status
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|spare
operator|!=
literal|null
operator|&&
name|spare
operator|.
name|tryUnsuspend
argument_list|()
condition|)
block|{
if|if
condition|(
name|dec
operator|||
name|joinMe
operator|.
name|requestSignal
argument_list|()
operator|<
literal|0
condition|)
block|{
name|int
name|c
decl_stmt|;
do|do
block|{                     }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|c
operator|=
name|workerCounts
argument_list|,
name|c
operator|+
name|ONE_RUNNING
argument_list|)
condition|)
do|;
block|}
comment|// else no net count change
name|LockSupport
operator|.
name|unpark
argument_list|(
name|spare
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|wc
init|=
name|workerCounts
decl_stmt|;
comment|// decrement running count
if|if
condition|(
operator|!
name|dec
operator|&&
operator|(
name|wc
operator|&
name|RUNNING_COUNT_MASK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|dec
operator|=
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
argument_list|,
name|wc
operator|-=
name|ONE_RUNNING
argument_list|)
operator|)
operator|&&
name|joinMe
operator|.
name|requestSignal
argument_list|()
operator|<
literal|0
condition|)
block|{
comment|// cannot block
name|int
name|c
decl_stmt|;
comment|// back out
do|do
block|{                 }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|c
operator|=
name|workerCounts
argument_list|,
name|c
operator|+
name|ONE_RUNNING
argument_list|)
condition|)
do|;
return|return;
block|}
if|if
condition|(
name|dec
condition|)
block|{
name|int
name|tc
init|=
name|wc
operator|>>>
name|TOTAL_COUNT_SHIFT
decl_stmt|;
name|int
name|pc
init|=
name|parallelism
decl_stmt|;
name|int
name|dc
init|=
name|pc
operator|-
operator|(
name|wc
operator|&
name|RUNNING_COUNT_MASK
operator|)
decl_stmt|;
comment|// deficit count
if|if
condition|(
operator|(
name|dc
operator|<
name|pc
operator|&&
operator|(
name|dc
operator|<=
literal|0
operator|||
operator|(
name|dc
operator|*
name|dc
operator|<
operator|(
name|tc
operator|-
name|pc
operator|)
operator|*
name|pc
operator|)
operator|||
operator|!
name|maintainsParallelism
operator|)
operator|)
operator|||
name|tc
operator|>=
name|maxPoolSize
condition|)
comment|// cannot add
return|return;
if|if
condition|(
name|spare
operator|==
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
argument_list|,
name|wc
operator|+
operator|(
name|ONE_RUNNING
operator||
name|ONE_TOTAL
operator|)
argument_list|)
condition|)
block|{
name|addWorker
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/**      * Same idea as preJoin but with too many differing details to      * integrate: There are no task-based signal counts, and only one      * way to do the actual blocking. So for simplicity it is directly      * incorporated into this method.      */
DECL|method|doBlock
specifier|final
name|void
name|doBlock
parameter_list|(
name|ManagedBlocker
name|blocker
parameter_list|,
name|boolean
name|maintainPar
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|maintainPar
operator|&=
name|maintainsParallelism
expr_stmt|;
comment|// override
name|boolean
name|dec
init|=
literal|false
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|releaseWaiters
argument_list|()
expr_stmt|;
if|if
condition|(
name|done
operator|=
name|blocker
operator|.
name|isReleasable
argument_list|()
condition|)
break|break;
name|ForkJoinWorkerThread
name|spare
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|isSuspended
argument_list|()
condition|)
block|{
name|spare
operator|=
name|w
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|done
operator|=
name|blocker
operator|.
name|isReleasable
argument_list|()
condition|)
break|break;
if|if
condition|(
name|spare
operator|!=
literal|null
operator|&&
name|spare
operator|.
name|tryUnsuspend
argument_list|()
condition|)
block|{
if|if
condition|(
name|dec
condition|)
block|{
name|int
name|c
decl_stmt|;
do|do
block|{                     }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|c
operator|=
name|workerCounts
argument_list|,
name|c
operator|+
name|ONE_RUNNING
argument_list|)
condition|)
do|;
block|}
name|LockSupport
operator|.
name|unpark
argument_list|(
name|spare
argument_list|)
expr_stmt|;
break|break;
block|}
name|int
name|wc
init|=
name|workerCounts
decl_stmt|;
if|if
condition|(
operator|!
name|dec
operator|&&
operator|(
name|wc
operator|&
name|RUNNING_COUNT_MASK
operator|)
operator|!=
literal|0
condition|)
name|dec
operator|=
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
argument_list|,
name|wc
operator|-=
name|ONE_RUNNING
argument_list|)
expr_stmt|;
if|if
condition|(
name|dec
condition|)
block|{
name|int
name|tc
init|=
name|wc
operator|>>>
name|TOTAL_COUNT_SHIFT
decl_stmt|;
name|int
name|pc
init|=
name|parallelism
decl_stmt|;
name|int
name|dc
init|=
name|pc
operator|-
operator|(
name|wc
operator|&
name|RUNNING_COUNT_MASK
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|dc
operator|<
name|pc
operator|&&
operator|(
name|dc
operator|<=
literal|0
operator|||
operator|(
name|dc
operator|*
name|dc
operator|<
operator|(
name|tc
operator|-
name|pc
operator|)
operator|*
name|pc
operator|)
operator|||
operator|!
name|maintainPar
operator|)
operator|)
operator|||
name|tc
operator|>=
name|maxPoolSize
condition|)
break|break;
if|if
condition|(
name|spare
operator|==
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|wc
argument_list|,
name|wc
operator|+
operator|(
name|ONE_RUNNING
operator||
name|ONE_TOTAL
operator|)
argument_list|)
condition|)
block|{
name|addWorker
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
try|try
block|{
if|if
condition|(
operator|!
name|done
condition|)
do|do
block|{                 }
do|while
condition|(
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
operator|&&
operator|!
name|blocker
operator|.
name|block
argument_list|()
condition|)
do|;
block|}
finally|finally
block|{
if|if
condition|(
name|dec
condition|)
block|{
name|int
name|c
decl_stmt|;
do|do
block|{                 }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|workerCountsOffset
argument_list|,
name|c
operator|=
name|workerCounts
argument_list|,
name|c
operator|+
name|ONE_RUNNING
argument_list|)
condition|)
do|;
block|}
block|}
block|}
comment|/**      * Possibly initiates and/or completes termination.      *      * @param now if true, unconditionally terminate, else only      *            if shutdown and empty queue and no active workers      * @return true if now terminating or terminated      */
DECL|method|tryTerminate
specifier|private
name|boolean
name|tryTerminate
parameter_list|(
name|boolean
name|now
parameter_list|)
block|{
if|if
condition|(
name|now
condition|)
name|advanceRunLevel
argument_list|(
name|SHUTDOWN
argument_list|)
expr_stmt|;
comment|// ensure at least SHUTDOWN
elseif|else
if|if
condition|(
name|runState
operator|<
name|SHUTDOWN
operator|||
operator|!
name|submissionQueue
operator|.
name|isEmpty
argument_list|()
operator|||
operator|(
name|runState
operator|&
name|ACTIVE_COUNT_MASK
operator|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|advanceRunLevel
argument_list|(
name|TERMINATING
argument_list|)
condition|)
name|startTerminating
argument_list|()
expr_stmt|;
comment|// Finish now if all threads terminated; else in some subsequent call
if|if
condition|(
operator|(
name|workerCounts
operator|>>>
name|TOTAL_COUNT_SHIFT
operator|)
operator|==
literal|0
condition|)
block|{
name|advanceRunLevel
argument_list|(
name|TERMINATED
argument_list|)
expr_stmt|;
name|terminationLatch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Actions on transition to TERMINATING      */
DECL|method|startTerminating
specifier|private
name|void
name|startTerminating
parameter_list|()
block|{
comment|// Clear out and cancel submissions, ignoring exceptions
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
decl_stmt|;
while|while
condition|(
operator|(
name|task
operator|=
name|submissionQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|task
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignore
parameter_list|)
block|{             }
block|}
comment|// Propagate run level
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
name|w
operator|.
name|shutdown
argument_list|()
expr_stmt|;
comment|// also resumes suspended workers
block|}
comment|// Ensure no straggling local tasks
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
name|w
operator|.
name|cancelTasks
argument_list|()
expr_stmt|;
block|}
comment|// Wake up idle workers
name|advanceEventCount
argument_list|()
expr_stmt|;
name|releaseWaiters
argument_list|()
expr_stmt|;
comment|// Unstick pending joins
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
operator|!
name|w
operator|.
name|isTerminated
argument_list|()
condition|)
block|{
try|try
block|{
name|w
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|ignore
parameter_list|)
block|{                 }
block|}
block|}
block|}
comment|// misc support for ForkJoinWorkerThread
comment|/**      * Returns pool number      */
DECL|method|getPoolNumber
specifier|final
name|int
name|getPoolNumber
parameter_list|()
block|{
return|return
name|poolNumber
return|;
block|}
comment|/**      * Accumulates steal count from a worker, clearing      * the worker's value      */
DECL|method|accumulateStealCount
specifier|final
name|void
name|accumulateStealCount
parameter_list|(
name|ForkJoinWorkerThread
name|w
parameter_list|)
block|{
name|int
name|sc
init|=
name|w
operator|.
name|stealCount
decl_stmt|;
if|if
condition|(
name|sc
operator|!=
literal|0
condition|)
block|{
name|long
name|c
decl_stmt|;
name|w
operator|.
name|stealCount
operator|=
literal|0
expr_stmt|;
do|do
block|{             }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stealCountOffset
argument_list|,
name|c
operator|=
name|stealCount
argument_list|,
name|c
operator|+
name|sc
argument_list|)
condition|)
do|;
block|}
block|}
comment|/**      * Returns the approximate (non-atomic) number of idle threads per      * active thread.      */
DECL|method|idlePerActive
specifier|final
name|int
name|idlePerActive
parameter_list|()
block|{
name|int
name|ac
init|=
name|runState
decl_stmt|;
comment|// no mask -- artifically boosts during shutdown
name|int
name|pc
init|=
name|parallelism
decl_stmt|;
comment|// use targeted parallelism, not rc
comment|// Use exact results for small values, saturate past 4
return|return
name|pc
operator|<=
name|ac
condition|?
literal|0
else|:
name|pc
operator|>>>
literal|1
operator|<=
name|ac
condition|?
literal|1
else|:
name|pc
operator|>>>
literal|2
operator|<=
name|ac
condition|?
literal|3
else|:
name|pc
operator|>>>
literal|3
return|;
block|}
comment|/**      * Returns the approximate (non-atomic) difference between running      * and active counts.      */
DECL|method|inactiveCount
specifier|final
name|int
name|inactiveCount
parameter_list|()
block|{
return|return
operator|(
name|workerCounts
operator|&
name|RUNNING_COUNT_MASK
operator|)
operator|-
operator|(
name|runState
operator|&
name|ACTIVE_COUNT_MASK
operator|)
return|;
block|}
comment|// Public and protected methods
comment|// Constructors
comment|/**      * Creates a {@code ForkJoinPool} with parallelism equal to {@link      * java.lang.Runtime#availableProcessors}, and using the {@linkplain      * #defaultForkJoinWorkerThreadFactory default thread factory}.      *      * @throws SecurityException if a security manager exists and      *                           the caller is not permitted to modify threads      *                           because it does not hold {@link      *                           java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|()
block|{
name|this
argument_list|(
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
argument_list|,
name|defaultForkJoinWorkerThreadFactory
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@code ForkJoinPool} with the indicated parallelism      * level and using the {@linkplain      * #defaultForkJoinWorkerThreadFactory default thread factory}.      *      * @param parallelism the parallelism level      * @throws IllegalArgumentException if parallelism less than or      *                                  equal to zero, or greater than implementation limit      * @throws SecurityException        if a security manager exists and      *                                  the caller is not permitted to modify threads      *                                  because it does not hold {@link      *                                  java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|(
name|int
name|parallelism
parameter_list|)
block|{
name|this
argument_list|(
name|parallelism
argument_list|,
name|defaultForkJoinWorkerThreadFactory
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@code ForkJoinPool} with parallelism equal to {@link      * java.lang.Runtime#availableProcessors}, and using the given      * thread factory.      *      * @param factory the factory for creating new threads      * @throws NullPointerException if the factory is null      * @throws SecurityException    if a security manager exists and      *                              the caller is not permitted to modify threads      *                              because it does not hold {@link      *                              java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|(
name|ForkJoinWorkerThreadFactory
name|factory
parameter_list|)
block|{
name|this
argument_list|(
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
argument_list|,
name|factory
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@code ForkJoinPool} with the given parallelism and      * thread factory.      *      * @param parallelism the parallelism level      * @param factory     the factory for creating new threads      * @throws IllegalArgumentException if parallelism less than or      *                                  equal to zero, or greater than implementation limit      * @throws NullPointerException     if the factory is null      * @throws SecurityException        if a security manager exists and      *                                  the caller is not permitted to modify threads      *                                  because it does not hold {@link      *                                  java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|(
name|int
name|parallelism
parameter_list|,
name|ForkJoinWorkerThreadFactory
name|factory
parameter_list|)
block|{
name|checkPermission
argument_list|()
expr_stmt|;
if|if
condition|(
name|factory
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|parallelism
operator|<=
literal|0
operator|||
name|parallelism
operator|>
name|MAX_THREADS
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|this
operator|.
name|poolNumber
operator|=
name|poolNumberGenerator
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
name|int
name|arraySize
init|=
name|initialArraySizeFor
argument_list|(
name|parallelism
argument_list|)
decl_stmt|;
name|this
operator|.
name|parallelism
operator|=
name|parallelism
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|maxPoolSize
operator|=
name|MAX_THREADS
expr_stmt|;
name|this
operator|.
name|maintainsParallelism
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|workers
operator|=
operator|new
name|ForkJoinWorkerThread
index|[
name|arraySize
index|]
expr_stmt|;
name|this
operator|.
name|submissionQueue
operator|=
operator|new
name|LinkedTransferQueue
argument_list|<
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|workerLock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|this
operator|.
name|terminationLatch
operator|=
operator|new
name|CountDownLatch
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Start first worker; remaining workers added upon first submission
name|workerCounts
operator|=
name|ONE_RUNNING
operator||
name|ONE_TOTAL
expr_stmt|;
name|addWorker
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns initial power of two size for workers array.      *      * @param pc the initial parallelism level      */
DECL|method|initialArraySizeFor
specifier|private
specifier|static
name|int
name|initialArraySizeFor
parameter_list|(
name|int
name|pc
parameter_list|)
block|{
comment|// See Hackers Delight, sec 3.2. We know MAX_THREADS< (1>>> 16)
name|int
name|size
init|=
name|pc
operator|<
name|MAX_THREADS
condition|?
name|pc
operator|+
literal|1
else|:
name|MAX_THREADS
decl_stmt|;
name|size
operator||=
name|size
operator|>>>
literal|1
expr_stmt|;
name|size
operator||=
name|size
operator|>>>
literal|2
expr_stmt|;
name|size
operator||=
name|size
operator|>>>
literal|4
expr_stmt|;
name|size
operator||=
name|size
operator|>>>
literal|8
expr_stmt|;
return|return
name|size
operator|+
literal|1
return|;
block|}
comment|// Execution methods
comment|/**      * Common code for execute, invoke and submit      */
DECL|method|doSubmit
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|doSubmit
parameter_list|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|runState
operator|>=
name|SHUTDOWN
condition|)
throw|throw
operator|new
name|RejectedExecutionException
argument_list|()
throw|;
name|submissionQueue
operator|.
name|offer
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|advanceEventCount
argument_list|()
expr_stmt|;
name|releaseWaiters
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|workerCounts
operator|>>>
name|TOTAL_COUNT_SHIFT
operator|)
operator|<
name|parallelism
condition|)
name|ensureEnoughTotalWorkers
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given task, returning its result upon completion.      *      * @param task the task      * @return the task's result      * @throws NullPointerException       if the task is null      * @throws RejectedExecutionException if the task cannot be      *                                    scheduled for execution      */
DECL|method|invoke
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|invoke
parameter_list|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|doSubmit
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
operator|.
name|join
argument_list|()
return|;
block|}
comment|/**      * Arranges for (asynchronous) execution of the given task.      *      * @param task the task      * @throws NullPointerException       if the task is null      * @throws RejectedExecutionException if the task cannot be      *                                    scheduled for execution      */
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|doSubmit
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|// AbstractExecutorService methods
comment|/**      * @throws NullPointerException       if the task is null      * @throws RejectedExecutionException if the task cannot be      *                                    scheduled for execution      */
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|Runnable
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|job
decl_stmt|;
if|if
condition|(
name|task
operator|instanceof
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
condition|)
comment|// avoid re-wrap
condition|job = (ForkJoinTask<?>
condition|)
name|task
expr_stmt|;
else|else
name|job
operator|=
name|ForkJoinTask
operator|.
name|adapt
argument_list|(
name|task
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
comment|/**      * @throws NullPointerException       if the task is null      * @throws RejectedExecutionException if the task cannot be      *                                    scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|job
init|=
name|ForkJoinTask
operator|.
name|adapt
argument_list|(
name|task
argument_list|)
decl_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException       if the task is null      * @throws RejectedExecutionException if the task cannot be      *                                    scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|Runnable
name|task
parameter_list|,
name|T
name|result
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|job
init|=
name|ForkJoinTask
operator|.
name|adapt
argument_list|(
name|task
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException       if the task is null      * @throws RejectedExecutionException if the task cannot be      *                                    scheduled for execution      */
DECL|method|submit
specifier|public
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|submit
parameter_list|(
name|Runnable
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|job
decl_stmt|;
if|if
condition|(
name|task
operator|instanceof
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
condition|)
comment|// avoid re-wrap
condition|job = (ForkJoinTask<?>
condition|)
name|task
expr_stmt|;
else|else
name|job
operator|=
name|ForkJoinTask
operator|.
name|adapt
argument_list|(
name|task
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * Submits a ForkJoinTask for execution.      *      * @param task the task to submit      * @return the task      * @throws NullPointerException       if the task is null      * @throws RejectedExecutionException if the task cannot be      *                                    scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|doSubmit
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**      * @throws NullPointerException       {@inheritDoc}      * @throws RejectedExecutionException {@inheritDoc}      */
DECL|method|invokeAll
specifier|public
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|invokeAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Callable
argument_list|<
name|T
argument_list|>
argument_list|>
name|tasks
parameter_list|)
block|{
name|ArrayList
argument_list|<
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
argument_list|>
name|forkJoinTasks
init|=
operator|new
name|ArrayList
argument_list|<
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|(
name|tasks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Callable
argument_list|<
name|T
argument_list|>
name|task
range|:
name|tasks
control|)
name|forkJoinTasks
operator|.
name|add
argument_list|(
name|ForkJoinTask
operator|.
name|adapt
argument_list|(
name|task
argument_list|)
argument_list|)
expr_stmt|;
name|invoke
argument_list|(
operator|new
name|InvokeAll
argument_list|<
name|T
argument_list|>
argument_list|(
name|forkJoinTasks
argument_list|)
argument_list|)
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|futures
init|=
call|(
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
call|)
argument_list|(
name|List
argument_list|)
name|forkJoinTasks
decl_stmt|;
return|return
name|futures
return|;
block|}
DECL|class|InvokeAll
specifier|static
specifier|final
class|class
name|InvokeAll
parameter_list|<
name|T
parameter_list|>
extends|extends
name|RecursiveAction
block|{
DECL|field|tasks
specifier|final
name|ArrayList
argument_list|<
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
argument_list|>
name|tasks
decl_stmt|;
DECL|method|InvokeAll
name|InvokeAll
parameter_list|(
name|ArrayList
argument_list|<
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
argument_list|>
name|tasks
parameter_list|)
block|{
name|this
operator|.
name|tasks
operator|=
name|tasks
expr_stmt|;
block|}
DECL|method|compute
specifier|public
name|void
name|compute
parameter_list|()
block|{
try|try
block|{
name|invokeAll
argument_list|(
name|tasks
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignore
parameter_list|)
block|{             }
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|7914297376763021607L
decl_stmt|;
block|}
comment|/**      * Returns the factory used for constructing new workers.      *      * @return the factory used for constructing new workers      */
DECL|method|getFactory
specifier|public
name|ForkJoinWorkerThreadFactory
name|getFactory
parameter_list|()
block|{
return|return
name|factory
return|;
block|}
comment|/**      * Returns the handler for internal worker threads that terminate      * due to unrecoverable errors encountered while executing tasks.      *      * @return the handler, or {@code null} if none      */
DECL|method|getUncaughtExceptionHandler
specifier|public
name|Thread
operator|.
name|UncaughtExceptionHandler
name|getUncaughtExceptionHandler
parameter_list|()
block|{
name|workerCountReadFence
argument_list|()
expr_stmt|;
return|return
name|ueh
return|;
block|}
comment|/**      * Sets the handler for internal worker threads that terminate due      * to unrecoverable errors encountered while executing tasks.      * Unless set, the current default or ThreadGroup handler is used      * as handler.      *      * @param h the new handler      * @return the old handler, or {@code null} if none      * @throws SecurityException if a security manager exists and      *                           the caller is not permitted to modify threads      *                           because it does not hold {@link      *                           java.lang.RuntimePermission}{@code ("modifyThread")}      */
specifier|public
name|Thread
operator|.
name|UncaughtExceptionHandler
DECL|method|setUncaughtExceptionHandler
name|setUncaughtExceptionHandler
parameter_list|(
name|Thread
operator|.
name|UncaughtExceptionHandler
name|h
parameter_list|)
block|{
name|checkPermission
argument_list|()
expr_stmt|;
name|workerCountReadFence
argument_list|()
expr_stmt|;
name|Thread
operator|.
name|UncaughtExceptionHandler
name|old
init|=
name|ueh
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|old
condition|)
block|{
name|ueh
operator|=
name|h
expr_stmt|;
name|workerCountWriteFence
argument_list|()
expr_stmt|;
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
name|w
operator|.
name|setUncaughtExceptionHandler
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|old
return|;
block|}
comment|/**      * Sets the target parallelism level of this pool.      *      * @param parallelism the target parallelism      * @throws IllegalArgumentException if parallelism less than or      *                                  equal to zero or greater than maximum size bounds      * @throws SecurityException        if a security manager exists and      *                                  the caller is not permitted to modify threads      *                                  because it does not hold {@link      *                                  java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|setParallelism
specifier|public
name|void
name|setParallelism
parameter_list|(
name|int
name|parallelism
parameter_list|)
block|{
name|checkPermission
argument_list|()
expr_stmt|;
if|if
condition|(
name|parallelism
operator|<=
literal|0
operator|||
name|parallelism
operator|>
name|maxPoolSize
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|workerCountReadFence
argument_list|()
expr_stmt|;
name|int
name|pc
init|=
name|this
operator|.
name|parallelism
decl_stmt|;
if|if
condition|(
name|pc
operator|!=
name|parallelism
condition|)
block|{
name|this
operator|.
name|parallelism
operator|=
name|parallelism
expr_stmt|;
name|workerCountWriteFence
argument_list|()
expr_stmt|;
comment|// Release spares. If too many, some will die after re-suspend
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|tryUnsuspend
argument_list|()
condition|)
block|{
name|updateRunningCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
name|ensureEnoughTotalWorkers
argument_list|()
expr_stmt|;
name|advanceEventCount
argument_list|()
expr_stmt|;
name|releaseWaiters
argument_list|()
expr_stmt|;
comment|// force config recheck by existing workers
block|}
block|}
comment|/**      * Returns the targeted parallelism level of this pool.      *      * @return the targeted parallelism level of this pool      */
DECL|method|getParallelism
specifier|public
name|int
name|getParallelism
parameter_list|()
block|{
comment|//        workerCountReadFence(); // inlined below
name|int
name|ignore
init|=
name|workerCounts
decl_stmt|;
return|return
name|parallelism
return|;
block|}
comment|/**      * Returns the number of worker threads that have started but not      * yet terminated.  This result returned by this method may differ      * from {@link #getParallelism} when threads are created to      * maintain parallelism when others are cooperatively blocked.      *      * @return the number of worker threads      */
DECL|method|getPoolSize
specifier|public
name|int
name|getPoolSize
parameter_list|()
block|{
return|return
name|workerCounts
operator|>>>
name|TOTAL_COUNT_SHIFT
return|;
block|}
comment|/**      * Returns the maximum number of threads allowed to exist in the      * pool. Unless set using {@link #setMaximumPoolSize}, the      * maximum is an implementation-defined value designed only to      * prevent runaway growth.      *      * @return the maximum      */
DECL|method|getMaximumPoolSize
specifier|public
name|int
name|getMaximumPoolSize
parameter_list|()
block|{
name|workerCountReadFence
argument_list|()
expr_stmt|;
return|return
name|maxPoolSize
return|;
block|}
comment|/**      * Sets the maximum number of threads allowed to exist in the      * pool. The given value should normally be greater than or equal      * to the {@link #getParallelism parallelism} level. Setting this      * value has no effect on current pool size. It controls      * construction of new threads.      *      * @throws IllegalArgumentException if negative or greater than      *                                  internal implementation limit      */
DECL|method|setMaximumPoolSize
specifier|public
name|void
name|setMaximumPoolSize
parameter_list|(
name|int
name|newMax
parameter_list|)
block|{
if|if
condition|(
name|newMax
argument_list|<
literal|0
operator|||
name|newMax
argument_list|>
name|MAX_THREADS
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|maxPoolSize
operator|=
name|newMax
expr_stmt|;
name|workerCountWriteFence
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns {@code true} if this pool dynamically maintains its      * target parallelism level. If false, new threads are added only      * to avoid possible starvation.  This setting is by default true.      *      * @return {@code true} if maintains parallelism      */
DECL|method|getMaintainsParallelism
specifier|public
name|boolean
name|getMaintainsParallelism
parameter_list|()
block|{
name|workerCountReadFence
argument_list|()
expr_stmt|;
return|return
name|maintainsParallelism
return|;
block|}
comment|/**      * Sets whether this pool dynamically maintains its target      * parallelism level. If false, new threads are added only to      * avoid possible starvation.      *      * @param enable {@code true} to maintain parallelism      */
DECL|method|setMaintainsParallelism
specifier|public
name|void
name|setMaintainsParallelism
parameter_list|(
name|boolean
name|enable
parameter_list|)
block|{
name|maintainsParallelism
operator|=
name|enable
expr_stmt|;
name|workerCountWriteFence
argument_list|()
expr_stmt|;
block|}
comment|/**      * Establishes local first-in-first-out scheduling mode for forked      * tasks that are never joined. This mode may be more appropriate      * than default locally stack-based mode in applications in which      * worker threads only process asynchronous tasks.  This method is      * designed to be invoked only when the pool is quiescent, and      * typically only before any tasks are submitted. The effects of      * invocations at other times may be unpredictable.      *      * @param async if {@code true}, use locally FIFO scheduling      * @return the previous mode      * @see #getAsyncMode      */
DECL|method|setAsyncMode
specifier|public
name|boolean
name|setAsyncMode
parameter_list|(
name|boolean
name|async
parameter_list|)
block|{
name|workerCountReadFence
argument_list|()
expr_stmt|;
name|boolean
name|oldMode
init|=
name|locallyFifo
decl_stmt|;
if|if
condition|(
name|oldMode
operator|!=
name|async
condition|)
block|{
name|locallyFifo
operator|=
name|async
expr_stmt|;
name|workerCountWriteFence
argument_list|()
expr_stmt|;
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
name|w
operator|.
name|setAsyncMode
argument_list|(
name|async
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|oldMode
return|;
block|}
comment|/**      * Returns {@code true} if this pool uses local first-in-first-out      * scheduling mode for forked tasks that are never joined.      *      * @return {@code true} if this pool uses async mode      * @see #setAsyncMode      */
DECL|method|getAsyncMode
specifier|public
name|boolean
name|getAsyncMode
parameter_list|()
block|{
name|workerCountReadFence
argument_list|()
expr_stmt|;
return|return
name|locallyFifo
return|;
block|}
comment|/**      * Returns an estimate of the number of worker threads that are      * not blocked waiting to join tasks or for other managed      * synchronization. This method may overestimate the      * number of running threads.      *      * @return the number of worker threads      */
DECL|method|getRunningThreadCount
specifier|public
name|int
name|getRunningThreadCount
parameter_list|()
block|{
return|return
name|workerCounts
operator|&
name|RUNNING_COUNT_MASK
return|;
block|}
comment|/**      * Returns an estimate of the number of threads that are currently      * stealing or executing tasks. This method may overestimate the      * number of active threads.      *      * @return the number of active threads      */
DECL|method|getActiveThreadCount
specifier|public
name|int
name|getActiveThreadCount
parameter_list|()
block|{
return|return
name|runState
operator|&
name|ACTIVE_COUNT_MASK
return|;
block|}
comment|/**      * Returns {@code true} if all worker threads are currently idle.      * An idle worker is one that cannot obtain a task to execute      * because none are available to steal from other threads, and      * there are no pending submissions to the pool. This method is      * conservative; it might not return {@code true} immediately upon      * idleness of all threads, but will eventually become true if      * threads remain inactive.      *      * @return {@code true} if all threads are currently idle      */
DECL|method|isQuiescent
specifier|public
name|boolean
name|isQuiescent
parameter_list|()
block|{
return|return
operator|(
name|runState
operator|&
name|ACTIVE_COUNT_MASK
operator|)
operator|==
literal|0
return|;
block|}
comment|/**      * Returns an estimate of the total number of tasks stolen from      * one thread's work queue by another. The reported value      * underestimates the actual total number of steals when the pool      * is not quiescent. This value may be useful for monitoring and      * tuning fork/join programs: in general, steal counts should be      * high enough to keep threads busy, but low enough to avoid      * overhead and contention across threads.      *      * @return the number of steals      */
DECL|method|getStealCount
specifier|public
name|long
name|getStealCount
parameter_list|()
block|{
return|return
name|stealCount
return|;
block|}
comment|/**      * Returns an estimate of the total number of tasks currently held      * in queues by worker threads (but not including tasks submitted      * to the pool that have not begun executing). This value is only      * an approximation, obtained by iterating across all threads in      * the pool. This method may be useful for tuning task      * granularities.      *      * @return the number of queued tasks      */
DECL|method|getQueuedTaskCount
specifier|public
name|long
name|getQueuedTaskCount
parameter_list|()
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
name|count
operator|+=
name|w
operator|.
name|getQueueSize
argument_list|()
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns an estimate of the number of tasks submitted to this      * pool that have not yet begun executing.  This method takes time      * proportional to the number of submissions.      *      * @return the number of queued submissions      */
DECL|method|getQueuedSubmissionCount
specifier|public
name|int
name|getQueuedSubmissionCount
parameter_list|()
block|{
return|return
name|submissionQueue
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Returns {@code true} if there are any tasks submitted to this      * pool that have not yet begun executing.      *      * @return {@code true} if there are any queued submissions      */
DECL|method|hasQueuedSubmissions
specifier|public
name|boolean
name|hasQueuedSubmissions
parameter_list|()
block|{
return|return
operator|!
name|submissionQueue
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|/**      * Removes and returns the next unexecuted submission if one is      * available.  This method may be useful in extensions to this      * class that re-assign work in systems with multiple pools.      *      * @return the next submission, or {@code null} if none      */
DECL|method|pollSubmission
specifier|protected
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollSubmission
parameter_list|()
block|{
return|return
name|submissionQueue
operator|.
name|poll
argument_list|()
return|;
block|}
comment|/**      * Removes all available unexecuted submitted and forked tasks      * from scheduling queues and adds them to the given collection,      * without altering their execution status. These may include      * artificially generated or wrapped tasks. This method is      * designed to be invoked only when the pool is known to be      * quiescent. Invocations at other times may not remove all      * tasks. A failure encountered while attempting to add elements      * to collection {@code c} may result in elements being in      * neither, either or both collections when the associated      * exception is thrown.  The behavior of this operation is      * undefined if the specified collection is modified while the      * operation is in progress.      *      * @param c the collection to transfer elements into      * @return the number of elements transferred      */
DECL|method|drainTasksTo
specifier|protected
name|int
name|drainTasksTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
parameter_list|)
block|{
name|int
name|n
init|=
name|submissionQueue
operator|.
name|drainTo
argument_list|(
name|c
argument_list|)
decl_stmt|;
for|for
control|(
name|ForkJoinWorkerThread
name|w
range|:
name|workers
control|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
condition|)
name|n
operator|+=
name|w
operator|.
name|drainTasksTo
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/**      * Returns a string identifying this pool, as well as its state,      * including indications of run state, parallelism level, and      * worker and task counts.      *      * @return a string identifying this pool, as well as its state      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|long
name|st
init|=
name|getStealCount
argument_list|()
decl_stmt|;
name|long
name|qt
init|=
name|getQueuedTaskCount
argument_list|()
decl_stmt|;
name|long
name|qs
init|=
name|getQueuedSubmissionCount
argument_list|()
decl_stmt|;
name|int
name|wc
init|=
name|workerCounts
decl_stmt|;
name|int
name|tc
init|=
name|wc
operator|>>>
name|TOTAL_COUNT_SHIFT
decl_stmt|;
name|int
name|rc
init|=
name|wc
operator|&
name|RUNNING_COUNT_MASK
decl_stmt|;
name|int
name|pc
init|=
name|parallelism
decl_stmt|;
name|int
name|rs
init|=
name|runState
decl_stmt|;
name|int
name|ac
init|=
name|rs
operator|&
name|ACTIVE_COUNT_MASK
decl_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"["
operator|+
name|runLevelToString
argument_list|(
name|rs
argument_list|)
operator|+
literal|", parallelism = "
operator|+
name|pc
operator|+
literal|", size = "
operator|+
name|tc
operator|+
literal|", active = "
operator|+
name|ac
operator|+
literal|", running = "
operator|+
name|rc
operator|+
literal|", steals = "
operator|+
name|st
operator|+
literal|", tasks = "
operator|+
name|qt
operator|+
literal|", submissions = "
operator|+
name|qs
operator|+
literal|"]"
return|;
block|}
DECL|method|runLevelToString
specifier|private
specifier|static
name|String
name|runLevelToString
parameter_list|(
name|int
name|s
parameter_list|)
block|{
return|return
operator|(
operator|(
name|s
operator|&
name|TERMINATED
operator|)
operator|!=
literal|0
condition|?
literal|"Terminated"
else|:
operator|(
operator|(
name|s
operator|&
name|TERMINATING
operator|)
operator|!=
literal|0
condition|?
literal|"Terminating"
else|:
operator|(
operator|(
name|s
operator|&
name|SHUTDOWN
operator|)
operator|!=
literal|0
condition|?
literal|"Shutting down"
else|:
literal|"Running"
operator|)
operator|)
operator|)
return|;
block|}
comment|/**      * Initiates an orderly shutdown in which previously submitted      * tasks are executed, but no new tasks will be accepted.      * Invocation has no additional effect if already shut down.      * Tasks that are in the process of being submitted concurrently      * during the course of this method may or may not be rejected.      *      * @throws SecurityException if a security manager exists and      *                           the caller is not permitted to modify threads      *                           because it does not hold {@link      *                           java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|shutdown
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|checkPermission
argument_list|()
expr_stmt|;
name|advanceRunLevel
argument_list|(
name|SHUTDOWN
argument_list|)
expr_stmt|;
name|tryTerminate
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Attempts to cancel and/or stop all tasks, and reject all      * subsequently submitted tasks.  Tasks that are in the process of      * being submitted or executed concurrently during the course of      * this method may or may not be rejected. This method cancels      * both existing and unexecuted tasks, in order to permit      * termination in the presence of task dependencies. So the method      * always returns an empty list (unlike the case for some other      * Executors).      *      * @return an empty list      * @throws SecurityException if a security manager exists and      *                           the caller is not permitted to modify threads      *                           because it does not hold {@link      *                           java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|shutdownNow
specifier|public
name|List
argument_list|<
name|Runnable
argument_list|>
name|shutdownNow
parameter_list|()
block|{
name|checkPermission
argument_list|()
expr_stmt|;
name|tryTerminate
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|/**      * Returns {@code true} if all tasks have completed following shut down.      *      * @return {@code true} if all tasks have completed following shut down      */
DECL|method|isTerminated
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
return|return
name|runState
operator|>=
name|TERMINATED
return|;
block|}
comment|/**      * Returns {@code true} if the process of termination has      * commenced but not yet completed.  This method may be useful for      * debugging. A return of {@code true} reported a sufficient      * period after shutdown may indicate that submitted tasks have      * ignored or suppressed interruption, causing this executor not      * to properly terminate.      *      * @return {@code true} if terminating but not yet terminated      */
DECL|method|isTerminating
specifier|public
name|boolean
name|isTerminating
parameter_list|()
block|{
return|return
operator|(
name|runState
operator|&
operator|(
name|TERMINATING
operator||
name|TERMINATED
operator|)
operator|)
operator|==
name|TERMINATING
return|;
block|}
comment|/**      * Returns {@code true} if this pool has been shut down.      *      * @return {@code true} if this pool has been shut down      */
DECL|method|isShutdown
specifier|public
name|boolean
name|isShutdown
parameter_list|()
block|{
return|return
name|runState
operator|>=
name|SHUTDOWN
return|;
block|}
comment|/**      * Blocks until all tasks have completed execution after a shutdown      * request, or the timeout occurs, or the current thread is      * interrupted, whichever happens first.      *      * @param timeout the maximum time to wait      * @param unit    the time unit of the timeout argument      * @return {@code true} if this executor terminated and      *         {@code false} if the timeout elapsed before termination      * @throws InterruptedException if interrupted while waiting      */
DECL|method|awaitTermination
specifier|public
name|boolean
name|awaitTermination
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|terminationLatch
operator|.
name|await
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
return|;
block|}
comment|/**      * Interface for extending managed parallelism for tasks running      * in {@link ForkJoinPool}s.      *      *<p>A {@code ManagedBlocker} provides two methods.      * Method {@code isReleasable} must return {@code true} if      * blocking is not necessary. Method {@code block} blocks the      * current thread if necessary (perhaps internally invoking      * {@code isReleasable} before actually blocking).      *      *<p>For example, here is a ManagedBlocker based on a      * ReentrantLock:      *<pre> {@code      * class ManagedLocker implements ManagedBlocker {      *   final ReentrantLock lock;      *   boolean hasLock = false;      *   ManagedLocker(ReentrantLock lock) { this.lock = lock; }      *   public boolean block() {      *     if (!hasLock)      *       lock.lock();      *     return true;      *   }      *   public boolean isReleasable() {      *     return hasLock || (hasLock = lock.tryLock());      *   }      * }}</pre>      */
DECL|interface|ManagedBlocker
specifier|public
specifier|static
interface|interface
name|ManagedBlocker
block|{
comment|/**          * Possibly blocks the current thread, for example waiting for          * a lock or condition.          *          * @return {@code true} if no additional blocking is necessary          *         (i.e., if isReleasable would return true)          * @throws InterruptedException if interrupted while waiting          *                              (the method is not required to do so, but is allowed to)          */
DECL|method|block
name|boolean
name|block
parameter_list|()
throws|throws
name|InterruptedException
function_decl|;
comment|/**          * Returns {@code true} if blocking is unnecessary.          */
DECL|method|isReleasable
name|boolean
name|isReleasable
parameter_list|()
function_decl|;
block|}
comment|/**      * Blocks in accord with the given blocker.  If the current thread      * is a {@link ForkJoinWorkerThread}, this method possibly      * arranges for a spare thread to be activated if necessary to      * ensure parallelism while the current thread is blocked.      *      *<p>If {@code maintainParallelism} is {@code true} and the pool      * supports it ({@link #getMaintainsParallelism}), this method      * attempts to maintain the pool's nominal parallelism. Otherwise      * it activates a thread only if necessary to avoid complete      * starvation. This option may be preferable when blockages use      * timeouts, or are almost always brief.      *      *<p>If the caller is not a {@link ForkJoinTask}, this method is      * behaviorally equivalent to      *<pre> {@code      * while (!blocker.isReleasable())      *   if (blocker.block())      *     return;      * }</pre>      *      * If the caller is a {@code ForkJoinTask}, then the pool may      * first be expanded to ensure parallelism, and later adjusted.      *      * @param blocker             the blocker      * @param maintainParallelism if {@code true} and supported by      *                            this pool, attempt to maintain the pool's nominal parallelism;      *                            otherwise activate a thread only if necessary to avoid      *                            complete starvation.      * @throws InterruptedException if blocker.block did so      */
DECL|method|managedBlock
specifier|public
specifier|static
name|void
name|managedBlock
parameter_list|(
name|ManagedBlocker
name|blocker
parameter_list|,
name|boolean
name|maintainParallelism
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
condition|)
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
operator|.
name|doBlock
argument_list|(
name|blocker
argument_list|,
name|maintainParallelism
argument_list|)
expr_stmt|;
else|else
name|awaitBlocker
argument_list|(
name|blocker
argument_list|)
expr_stmt|;
block|}
comment|/**      * Performs Non-FJ blocking      */
DECL|method|awaitBlocker
specifier|private
specifier|static
name|void
name|awaitBlocker
parameter_list|(
name|ManagedBlocker
name|blocker
parameter_list|)
throws|throws
name|InterruptedException
block|{
do|do
block|{         }
do|while
condition|(
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
operator|&&
operator|!
name|blocker
operator|.
name|block
argument_list|()
condition|)
do|;
block|}
comment|// AbstractExecutorService overrides.  These rely on undocumented
comment|// fact that ForkJoinTask.adapt returns ForkJoinTasks that also
comment|// implement RunnableFuture.
DECL|method|newTaskFor
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|RunnableFuture
argument_list|<
name|T
argument_list|>
name|newTaskFor
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|T
name|value
parameter_list|)
block|{
return|return
operator|(
name|RunnableFuture
argument_list|<
name|T
argument_list|>
operator|)
name|ForkJoinTask
operator|.
name|adapt
argument_list|(
name|runnable
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|newTaskFor
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|RunnableFuture
argument_list|<
name|T
argument_list|>
name|newTaskFor
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
block|{
return|return
operator|(
name|RunnableFuture
argument_list|<
name|T
argument_list|>
operator|)
name|ForkJoinTask
operator|.
name|adapt
argument_list|(
name|callable
argument_list|)
return|;
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
init|=
name|getUnsafe
argument_list|()
decl_stmt|;
DECL|field|workerCountsOffset
specifier|private
specifier|static
specifier|final
name|long
name|workerCountsOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"workerCounts"
argument_list|,
name|ForkJoinPool
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|runStateOffset
specifier|private
specifier|static
specifier|final
name|long
name|runStateOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"runState"
argument_list|,
name|ForkJoinPool
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|eventCountOffset
specifier|private
specifier|static
specifier|final
name|long
name|eventCountOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"eventCount"
argument_list|,
name|ForkJoinPool
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|eventWaitersOffset
specifier|private
specifier|static
specifier|final
name|long
name|eventWaitersOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"eventWaiters"
argument_list|,
name|ForkJoinPool
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|stealCountOffset
specifier|private
specifier|static
specifier|final
name|long
name|stealCountOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"stealCount"
argument_list|,
name|ForkJoinPool
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|objectFieldOffset
specifier|private
specifier|static
name|long
name|objectFieldOffset
parameter_list|(
name|String
name|field
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|klazz
parameter_list|)
block|{
try|try
block|{
return|return
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|klazz
operator|.
name|getDeclaredField
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
comment|// Convert Exception to corresponding Error
name|NoSuchFieldError
name|error
init|=
operator|new
name|NoSuchFieldError
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

