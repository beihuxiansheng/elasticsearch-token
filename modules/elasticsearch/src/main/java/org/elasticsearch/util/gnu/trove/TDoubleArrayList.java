begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.gnu.trove
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|gnu
operator|.
name|trove
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Externalizable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_comment
comment|//////////////////////////////////////////////////
end_comment

begin_comment
comment|// THIS IS A GENERATED CLASS. DO NOT HAND EDIT! //
end_comment

begin_comment
comment|//////////////////////////////////////////////////
end_comment

begin_comment
comment|/**  * A resizable, array-backed list of double primitives.  *<p/>  * Created: Sat Dec 29 14:21:12 2001  *  * @author Eric D. Friedman  * @author Rob Eden  */
end_comment

begin_class
DECL|class|TDoubleArrayList
specifier|public
class|class
name|TDoubleArrayList
implements|implements
name|Externalizable
implements|,
name|Cloneable
block|{
DECL|field|serialVersionUID
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**      * the data of the list      */
DECL|field|_data
specifier|protected
name|double
index|[]
name|_data
decl_stmt|;
comment|/**      * the index after the last entry in the list      */
DECL|field|_pos
specifier|protected
name|int
name|_pos
decl_stmt|;
comment|/**      * the default capacity for new lists      */
DECL|field|DEFAULT_CAPACITY
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_CAPACITY
init|=
literal|10
decl_stmt|;
comment|/**      * Creates a new<code>TDoubleArrayList</code> instance with the      * default capacity.      */
DECL|method|TDoubleArrayList
specifier|public
name|TDoubleArrayList
parameter_list|()
block|{
name|this
argument_list|(
name|DEFAULT_CAPACITY
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new<code>TDoubleArrayList</code> instance with the      * specified capacity.      *      * @param capacity an<code>int</code> value      */
DECL|method|TDoubleArrayList
specifier|public
name|TDoubleArrayList
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|_data
operator|=
operator|new
name|double
index|[
name|capacity
index|]
expr_stmt|;
name|_pos
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Creates a new<code>TDoubleArrayList</code> instance whose      * capacity is the greater of the length of<tt>values</tt> and      * DEFAULT_CAPACITY and whose initial contents are the specified      * values.      *      * @param values an<code>double[]</code> value      */
DECL|method|TDoubleArrayList
specifier|public
name|TDoubleArrayList
parameter_list|(
name|double
index|[]
name|values
parameter_list|)
block|{
name|this
argument_list|(
name|Math
operator|.
name|max
argument_list|(
name|values
operator|.
name|length
argument_list|,
name|DEFAULT_CAPACITY
argument_list|)
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|values
argument_list|)
expr_stmt|;
block|}
comment|// sizing
comment|/**      * Grow the internal array as needed to accommodate the specified      * number of elements.  The size of the array doubles on each      * resize unless<tt>capacity</tt> requires more than twice the      * current capacity.      *      * @param capacity an<code>int</code> value      */
DECL|method|ensureCapacity
specifier|public
name|void
name|ensureCapacity
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
if|if
condition|(
name|capacity
operator|>
name|_data
operator|.
name|length
condition|)
block|{
name|int
name|newCap
init|=
name|Math
operator|.
name|max
argument_list|(
name|_data
operator|.
name|length
operator|<<
literal|1
argument_list|,
name|capacity
argument_list|)
decl_stmt|;
name|double
index|[]
name|tmp
init|=
operator|new
name|double
index|[
name|newCap
index|]
decl_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|_data
argument_list|,
literal|0
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
name|_data
operator|.
name|length
argument_list|)
expr_stmt|;
name|_data
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/**      * Returns the number of values in the list.      *      * @return the number of values in the list.      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|_pos
return|;
block|}
comment|/**      * Tests whether this list contains any values.      *      * @return true if the list is empty.      */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|_pos
operator|==
literal|0
return|;
block|}
comment|/**      * Sheds any excess capacity above and beyond the current size of      * the list.      */
DECL|method|trimToSize
specifier|public
name|void
name|trimToSize
parameter_list|()
block|{
if|if
condition|(
name|_data
operator|.
name|length
operator|>
name|size
argument_list|()
condition|)
block|{
name|double
index|[]
name|tmp
init|=
operator|new
name|double
index|[
name|size
argument_list|()
index|]
decl_stmt|;
name|toNativeArray
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|tmp
operator|.
name|length
argument_list|)
expr_stmt|;
name|_data
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|// modifying
comment|/**      * Adds<tt>val</tt> to the end of the list, growing as needed.      *      * @param val an<code>double</code> value      */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|double
name|val
parameter_list|)
block|{
name|ensureCapacity
argument_list|(
name|_pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|_data
index|[
name|_pos
operator|++
index|]
operator|=
name|val
expr_stmt|;
block|}
comment|/**      * Adds the values in the array<tt>vals</tt> to the end of the      * list, in order.      *      * @param vals an<code>double[]</code> value      */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|double
index|[]
name|vals
parameter_list|)
block|{
name|add
argument_list|(
name|vals
argument_list|,
literal|0
argument_list|,
name|vals
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a subset of the values in the array<tt>vals</tt> to the      * end of the list, in order.      *      * @param vals   an<code>double[]</code> value      * @param offset the offset at which to start copying      * @param length the number of values to copy.      */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|double
index|[]
name|vals
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|ensureCapacity
argument_list|(
name|_pos
operator|+
name|length
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|vals
argument_list|,
name|offset
argument_list|,
name|_data
argument_list|,
name|_pos
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|_pos
operator|+=
name|length
expr_stmt|;
block|}
comment|/**      * Inserts<tt>value</tt> into the list at<tt>offset</tt>.  All      * values including and to the right of<tt>offset</tt> are shifted      * to the right.      *      * @param offset an<code>int</code> value      * @param value  an<code>double</code> value      */
DECL|method|insert
specifier|public
name|void
name|insert
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
name|value
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
name|_pos
condition|)
block|{
name|add
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureCapacity
argument_list|(
name|_pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// shift right
name|System
operator|.
name|arraycopy
argument_list|(
name|_data
argument_list|,
name|offset
argument_list|,
name|_data
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|_pos
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|// insert
name|_data
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
name|_pos
operator|++
expr_stmt|;
block|}
comment|/**      * Inserts the array of<tt>values</tt> into the list at      *<tt>offset</tt>.  All values including and to the right of      *<tt>offset</tt> are shifted to the right.      *      * @param offset an<code>int</code> value      * @param values an<code>double[]</code> value      */
DECL|method|insert
specifier|public
name|void
name|insert
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
index|[]
name|values
parameter_list|)
block|{
name|insert
argument_list|(
name|offset
argument_list|,
name|values
argument_list|,
literal|0
argument_list|,
name|values
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inserts a slice of the array of<tt>values</tt> into the list      * at<tt>offset</tt>.  All values including and to the right of      *<tt>offset</tt> are shifted to the right.      *      * @param offset    an<code>int</code> value      * @param values    an<code>double[]</code> value      * @param valOffset the offset in the values array at which to      *                  start copying.      * @param len       the number of values to copy from the values array      */
DECL|method|insert
specifier|public
name|void
name|insert
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
index|[]
name|values
parameter_list|,
name|int
name|valOffset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|==
name|_pos
condition|)
block|{
name|add
argument_list|(
name|values
argument_list|,
name|valOffset
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|ensureCapacity
argument_list|(
name|_pos
operator|+
name|len
argument_list|)
expr_stmt|;
comment|// shift right
name|System
operator|.
name|arraycopy
argument_list|(
name|_data
argument_list|,
name|offset
argument_list|,
name|_data
argument_list|,
name|offset
operator|+
name|len
argument_list|,
name|_pos
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|// insert
name|System
operator|.
name|arraycopy
argument_list|(
name|values
argument_list|,
name|valOffset
argument_list|,
name|_data
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|_pos
operator|+=
name|len
expr_stmt|;
block|}
comment|/**      * Returns the value at the specified offset.      *      * @param offset an<code>int</code> value      * @return an<code>double</code> value      */
DECL|method|get
specifier|public
name|double
name|get
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>=
name|_pos
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|offset
argument_list|)
throw|;
block|}
return|return
name|_data
index|[
name|offset
index|]
return|;
block|}
comment|/**      * Returns the value at the specified offset without doing any      * bounds checking.      *      * @param offset an<code>int</code> value      * @return an<code>double</code> value      */
DECL|method|getQuick
specifier|public
name|double
name|getQuick
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
return|return
name|_data
index|[
name|offset
index|]
return|;
block|}
comment|/**      * Sets the value at the specified offset.      *      * @param offset an<code>int</code> value      * @param val    an<code>double</code> value      */
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
name|val
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>=
name|_pos
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|offset
argument_list|)
throw|;
block|}
name|_data
index|[
name|offset
index|]
operator|=
name|val
expr_stmt|;
block|}
comment|/**      * Sets the value at the specified offset and returns the      * previously stored value.      *      * @param offset an<code>int</code> value      * @param val    an<code>double</code> value      * @return the value previously stored at offset.      */
DECL|method|getSet
specifier|public
name|double
name|getSet
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
name|val
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>=
name|_pos
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|offset
argument_list|)
throw|;
block|}
name|double
name|old
init|=
name|_data
index|[
name|offset
index|]
decl_stmt|;
name|_data
index|[
name|offset
index|]
operator|=
name|val
expr_stmt|;
return|return
name|old
return|;
block|}
comment|/**      * Replace the values in the list starting at<tt>offset</tt> with      * the contents of the<tt>values</tt> array.      *      * @param offset the first offset to replace      * @param values the source of the new values      */
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
index|[]
name|values
parameter_list|)
block|{
name|set
argument_list|(
name|offset
argument_list|,
name|values
argument_list|,
literal|0
argument_list|,
name|values
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Replace the values in the list starting at<tt>offset</tt> with      *<tt>length</tt> values from the<tt>values</tt> array, starting      * at valOffset.      *      * @param offset    the first offset to replace      * @param values    the source of the new values      * @param valOffset the first value to copy from the values array      * @param length    the number of values to copy      */
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
index|[]
name|values
parameter_list|,
name|int
name|valOffset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|offset
argument_list|<
literal|0
operator|||
name|offset
operator|+
name|length
argument_list|>
name|_pos
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|offset
argument_list|)
throw|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|values
argument_list|,
name|valOffset
argument_list|,
name|_data
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the value at the specified offset without doing any bounds      * checking.      *      * @param offset an<code>int</code> value      * @param val    an<code>double</code> value      */
DECL|method|setQuick
specifier|public
name|void
name|setQuick
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
name|val
parameter_list|)
block|{
name|_data
index|[
name|offset
index|]
operator|=
name|val
expr_stmt|;
block|}
comment|/**      * Flushes the internal state of the list, resetting the capacity      * to the default.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|clear
argument_list|(
name|DEFAULT_CAPACITY
argument_list|)
expr_stmt|;
block|}
comment|/**      * Flushes the internal state of the list, setting the capacity of      * the empty list to<tt>capacity</tt>.      *      * @param capacity an<code>int</code> value      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|_data
operator|=
operator|new
name|double
index|[
name|capacity
index|]
expr_stmt|;
name|_pos
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Sets the size of the list to 0, but does not change its      * capacity.  This method can be used as an alternative to the      * {@link #clear clear} method if you want to recyle a list without      * allocating new backing arrays.      *      * @see #clear      */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|()
block|{
name|_pos
operator|=
literal|0
expr_stmt|;
name|fill
argument_list|(
operator|(
name|double
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sets the size of the list to 0, but does not change its      * capacity.  This method can be used as an alternative to the      * {@link #clear clear} method if you want to recyle a list      * without allocating new backing arrays.  This method differs      * from {@link #reset reset} in that it does not clear the old      * values in the backing array.  Thus, it is possible for {@link      * #getQuick getQuick} to return stale data if this method is used      * and the caller is careless about bounds checking.      *      * @see #reset      * @see #clear      * @see #getQuick      */
DECL|method|resetQuick
specifier|public
name|void
name|resetQuick
parameter_list|()
block|{
name|_pos
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Removes the value at<tt>offset</tt> from the list.      *      * @param offset an<code>int</code> value      * @return the value previously stored at offset.      */
DECL|method|remove
specifier|public
name|double
name|remove
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|double
name|old
init|=
name|get
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|remove
argument_list|(
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
comment|/**      * Removes<tt>length</tt> values from the list, starting at      *<tt>offset</tt>      *      * @param offset an<code>int</code> value      * @param length an<code>int</code> value      */
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|_pos
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|offset
argument_list|)
throw|;
block|}
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
comment|// data at the front
name|System
operator|.
name|arraycopy
argument_list|(
name|_data
argument_list|,
name|length
argument_list|,
name|_data
argument_list|,
literal|0
argument_list|,
name|_pos
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_pos
operator|-
name|length
operator|==
name|offset
condition|)
block|{
comment|// no copy to make, decrementing pos "deletes" values at
comment|// the end
block|}
else|else
block|{
comment|// data in the middle
name|System
operator|.
name|arraycopy
argument_list|(
name|_data
argument_list|,
name|offset
operator|+
name|length
argument_list|,
name|_data
argument_list|,
name|offset
argument_list|,
name|_pos
operator|-
operator|(
name|offset
operator|+
name|length
operator|)
argument_list|)
expr_stmt|;
block|}
name|_pos
operator|-=
name|length
expr_stmt|;
comment|// no need to clear old values beyond _pos, because this is a
comment|// primitive collection and 0 takes as much room as any other
comment|// value
block|}
comment|/**      * Transform each value in the list using the specified function.      *      * @param function a<code>TDoubleFunction</code> value      */
DECL|method|transformValues
specifier|public
name|void
name|transformValues
parameter_list|(
name|TDoubleFunction
name|function
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|_pos
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|_data
index|[
name|i
index|]
operator|=
name|function
operator|.
name|execute
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Reverse the order of the elements in the list.      */
DECL|method|reverse
specifier|public
name|void
name|reverse
parameter_list|()
block|{
name|reverse
argument_list|(
literal|0
argument_list|,
name|_pos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reverse the order of the elements in the range of the list.      *      * @param from the inclusive index at which to start reversing      * @param to   the exclusive index at which to stop reversing      */
DECL|method|reverse
specifier|public
name|void
name|reverse
parameter_list|(
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|==
name|to
condition|)
block|{
return|return;
comment|// nothing to do
block|}
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"from cannot be greater than to"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
name|from
init|,
name|j
init|=
name|to
operator|-
literal|1
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
name|swap
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Shuffle the elements of the list using the specified random      * number generator.      *      * @param rand a<code>Random</code> value      */
DECL|method|shuffle
specifier|public
name|void
name|shuffle
parameter_list|(
name|Random
name|rand
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|_pos
init|;
name|i
operator|--
operator|>
literal|1
condition|;
control|)
block|{
name|swap
argument_list|(
name|i
argument_list|,
name|rand
operator|.
name|nextInt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Swap the values at offsets<tt>i</tt> and<tt>j</tt>.      *      * @param i an offset into the data array      * @param j an offset into the data array      */
DECL|method|swap
specifier|private
specifier|final
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|double
name|tmp
init|=
name|_data
index|[
name|i
index|]
decl_stmt|;
name|_data
index|[
name|i
index|]
operator|=
name|_data
index|[
name|j
index|]
expr_stmt|;
name|_data
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
comment|// copying
comment|/**      * Returns a clone of this list.  Since this is a primitive      * collection, this will be a deep clone.      *      * @return a deep clone of the list.      */
DECL|method|clone
specifier|public
name|Object
name|clone
parameter_list|()
block|{
name|TDoubleArrayList
name|list
init|=
literal|null
decl_stmt|;
try|try
block|{
name|list
operator|=
operator|(
name|TDoubleArrayList
operator|)
name|super
operator|.
name|clone
argument_list|()
expr_stmt|;
name|list
operator|.
name|_data
operator|=
name|toNativeArray
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|e
parameter_list|)
block|{
comment|// it's supported
block|}
comment|// end of try-catch
return|return
name|list
return|;
block|}
comment|/**      * Returns a sublist of this list.      *      * @param begin low endpoint (inclusive) of the subList.      * @param end   high endpoint (exclusive) of the subList.      * @return sublist of this list from begin, inclusive to end, exclusive.      * @throws IndexOutOfBoundsException - endpoint out of range      * @throws IllegalArgumentException  - endpoints out of order (end> begin)      */
DECL|method|subList
specifier|public
name|TDoubleArrayList
name|subList
parameter_list|(
name|int
name|begin
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|end
operator|<
name|begin
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"end index "
operator|+
name|end
operator|+
literal|" greater than begin index "
operator|+
name|begin
argument_list|)
throw|;
if|if
condition|(
name|begin
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"begin index can not be< 0"
argument_list|)
throw|;
if|if
condition|(
name|end
operator|>
name|_data
operator|.
name|length
condition|)
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"end index< "
operator|+
name|_data
operator|.
name|length
argument_list|)
throw|;
name|TDoubleArrayList
name|list
init|=
operator|new
name|TDoubleArrayList
argument_list|(
name|end
operator|-
name|begin
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|begin
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**      * Copies the contents of the list into a native array.      *      * @return an<code>double[]</code> value      */
DECL|method|toNativeArray
specifier|public
name|double
index|[]
name|toNativeArray
parameter_list|()
block|{
return|return
name|toNativeArray
argument_list|(
literal|0
argument_list|,
name|_pos
argument_list|)
return|;
block|}
comment|/**      * Copies a slice of the list into a native array.      *      * @param offset the offset at which to start copying      * @param len    the number of values to copy.      * @return an<code>double[]</code> value      */
DECL|method|toNativeArray
specifier|public
name|double
index|[]
name|toNativeArray
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|double
index|[]
name|rv
init|=
operator|new
name|double
index|[
name|len
index|]
decl_stmt|;
name|toNativeArray
argument_list|(
name|rv
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
comment|/**      * Copies a slice of the list into a native array.      *      * @param dest   the array to copy into.      * @param offset the offset of the first value to copy      * @param len    the number of values to copy.      */
DECL|method|toNativeArray
specifier|public
name|void
name|toNativeArray
parameter_list|(
name|double
index|[]
name|dest
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return;
comment|// nothing to copy
block|}
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|_pos
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|offset
argument_list|)
throw|;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|_data
argument_list|,
name|offset
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|// comparing
comment|/**      * Compares this list to another list, value by value.      *      * @param other the object to compare against      * @return true if other is a TDoubleArrayList and has exactly the      *         same values.      */
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|other
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
name|this
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|other
operator|instanceof
name|TDoubleArrayList
condition|)
block|{
name|TDoubleArrayList
name|that
init|=
operator|(
name|TDoubleArrayList
operator|)
name|other
decl_stmt|;
if|if
condition|(
name|that
operator|.
name|size
argument_list|()
operator|!=
name|this
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
for|for
control|(
name|int
name|i
init|=
name|_pos
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|this
operator|.
name|_data
index|[
name|i
index|]
operator|!=
name|that
operator|.
name|_data
index|[
name|i
index|]
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|_pos
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|h
operator|=
literal|37
operator|*
name|h
operator|+
name|HashFunctions
operator|.
name|hash
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|// procedures
comment|/**      * Applies the procedure to each value in the list in ascending      * (front to back) order.      *      * @param procedure a<code>TDoubleProcedure</code> value      * @return true if the procedure did not terminate prematurely.      */
DECL|method|forEach
specifier|public
name|boolean
name|forEach
parameter_list|(
name|TDoubleProcedure
name|procedure
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|procedure
operator|.
name|execute
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Applies the procedure to each value in the list in descending      * (back to front) order.      *      * @param procedure a<code>TDoubleProcedure</code> value      * @return true if the procedure did not terminate prematurely.      */
DECL|method|forEachDescending
specifier|public
name|boolean
name|forEachDescending
parameter_list|(
name|TDoubleProcedure
name|procedure
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|_pos
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|procedure
operator|.
name|execute
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// sorting
comment|/**      * Sort the values in the list (ascending) using the Sun quicksort      * implementation.      *      * @see java.util.Arrays#sort      */
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|()
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|_data
argument_list|,
literal|0
argument_list|,
name|_pos
argument_list|)
expr_stmt|;
block|}
comment|/**      * Sort a slice of the list (ascending) using the Sun quicksort      * implementation.      *      * @param fromIndex the index at which to start sorting (inclusive)      * @param toIndex   the index at which to stop sorting (exclusive)      * @see java.util.Arrays#sort      */
DECL|method|sort
specifier|public
name|void
name|sort
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|Arrays
operator|.
name|sort
argument_list|(
name|_data
argument_list|,
name|fromIndex
argument_list|,
name|toIndex
argument_list|)
expr_stmt|;
block|}
comment|// filling
comment|/**      * Fills every slot in the list with the specified value.      *      * @param val the value to use when filling      */
DECL|method|fill
specifier|public
name|void
name|fill
parameter_list|(
name|double
name|val
parameter_list|)
block|{
name|Arrays
operator|.
name|fill
argument_list|(
name|_data
argument_list|,
literal|0
argument_list|,
name|_pos
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/**      * Fills a range in the list with the specified value.      *      * @param fromIndex the offset at which to start filling (inclusive)      * @param toIndex   the offset at which to stop filling (exclusive)      * @param val       the value to use when filling      */
DECL|method|fill
specifier|public
name|void
name|fill
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|,
name|double
name|val
parameter_list|)
block|{
if|if
condition|(
name|toIndex
operator|>
name|_pos
condition|)
block|{
name|ensureCapacity
argument_list|(
name|toIndex
argument_list|)
expr_stmt|;
name|_pos
operator|=
name|toIndex
expr_stmt|;
block|}
name|Arrays
operator|.
name|fill
argument_list|(
name|_data
argument_list|,
name|fromIndex
argument_list|,
name|toIndex
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|// searching
comment|/**      * Performs a binary search for<tt>value</tt> in the entire list.      * Note that you<b>must</b> @{link #sort sort} the list before      * doing a search.      *      * @param value the value to search for      * @return the absolute offset in the list of the value, or its      *         negative insertion point into the sorted list.      */
DECL|method|binarySearch
specifier|public
name|int
name|binarySearch
parameter_list|(
name|double
name|value
parameter_list|)
block|{
return|return
name|binarySearch
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
name|_pos
argument_list|)
return|;
block|}
comment|/**      * Performs a binary search for<tt>value</tt> in the specified      * range.  Note that you<b>must</b> @{link #sort sort} the list      * or the range before doing a search.      *      * @param value     the value to search for      * @param fromIndex the lower boundary of the range (inclusive)      * @param toIndex   the upper boundary of the range (exclusive)      * @return the absolute offset in the list of the value, or its      *         negative insertion point into the sorted list.      */
DECL|method|binarySearch
specifier|public
name|int
name|binarySearch
parameter_list|(
name|double
name|value
parameter_list|,
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|fromIndex
argument_list|)
throw|;
block|}
if|if
condition|(
name|toIndex
operator|>
name|_pos
condition|)
block|{
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|toIndex
argument_list|)
throw|;
block|}
name|int
name|low
init|=
name|fromIndex
decl_stmt|;
name|int
name|high
init|=
name|toIndex
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|int
name|mid
init|=
operator|(
name|low
operator|+
name|high
operator|)
operator|>>>
literal|1
decl_stmt|;
name|double
name|midVal
init|=
name|_data
index|[
name|mid
index|]
decl_stmt|;
if|if
condition|(
name|midVal
operator|<
name|value
condition|)
block|{
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|midVal
operator|>
name|value
condition|)
block|{
name|high
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return
name|mid
return|;
comment|// value found
block|}
block|}
return|return
operator|-
operator|(
name|low
operator|+
literal|1
operator|)
return|;
comment|// value not found.
block|}
comment|/**      * Searches the list front to back for the index of      *<tt>value</tt>.      *      * @param value an<code>double</code> value      * @return the first offset of the value, or -1 if it is not in      *         the list.      * @see #binarySearch for faster searches on sorted lists      */
DECL|method|indexOf
specifier|public
name|int
name|indexOf
parameter_list|(
name|double
name|value
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
literal|0
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * Searches the list front to back for the index of      *<tt>value</tt>, starting at<tt>offset</tt>.      *      * @param offset the offset at which to start the linear search      *               (inclusive)      * @param value  an<code>double</code> value      * @return the first offset of the value, or -1 if it is not in      *         the list.      * @see #binarySearch for faster searches on sorted lists      */
DECL|method|indexOf
specifier|public
name|int
name|indexOf
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
name|value
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|<
name|_pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_data
index|[
name|i
index|]
operator|==
name|value
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Searches the list back to front for the last index of      *<tt>value</tt>.      *      * @param value an<code>double</code> value      * @return the last offset of the value, or -1 if it is not in      *         the list.      * @see #binarySearch for faster searches on sorted lists      */
DECL|method|lastIndexOf
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|double
name|value
parameter_list|)
block|{
return|return
name|lastIndexOf
argument_list|(
name|_pos
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * Searches the list back to front for the last index of      *<tt>value</tt>, starting at<tt>offset</tt>.      *      * @param offset the offset at which to start the linear search      *               (exclusive)      * @param value  an<code>double</code> value      * @return the last offset of the value, or -1 if it is not in      *         the list.      * @see #binarySearch for faster searches on sorted lists      */
DECL|method|lastIndexOf
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|int
name|offset
parameter_list|,
name|double
name|value
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|offset
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|_data
index|[
name|i
index|]
operator|==
name|value
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      * Searches the list for<tt>value</tt>      *      * @param value an<code>double</code> value      * @return true if value is in the list.      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|double
name|value
parameter_list|)
block|{
return|return
name|lastIndexOf
argument_list|(
name|value
argument_list|)
operator|>=
literal|0
return|;
block|}
comment|/**      * Searches the list for values satisfying<tt>condition</tt> in      * the manner of the *nix<tt>grep</tt> utility.      *      * @param condition a condition to apply to each element in the list      * @return a list of values which match the condition.      */
DECL|method|grep
specifier|public
name|TDoubleArrayList
name|grep
parameter_list|(
name|TDoubleProcedure
name|condition
parameter_list|)
block|{
name|TDoubleArrayList
name|list
init|=
operator|new
name|TDoubleArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|condition
operator|.
name|execute
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**      * Searches the list for values which do<b>not</b> satisfy      *<tt>condition</tt>.  This is akin to *nix<code>grep -v</code>.      *      * @param condition a condition to apply to each element in the list      * @return a list of values which do not match the condition.      */
DECL|method|inverseGrep
specifier|public
name|TDoubleArrayList
name|inverseGrep
parameter_list|(
name|TDoubleProcedure
name|condition
parameter_list|)
block|{
name|TDoubleArrayList
name|list
init|=
operator|new
name|TDoubleArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|condition
operator|.
name|execute
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**      * Finds the maximum value in the list.      *      * @return the largest value in the list.      * @throws IllegalStateException if the list is empty      */
DECL|method|max
specifier|public
name|double
name|max
parameter_list|()
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot find maximum of an empty list"
argument_list|)
throw|;
block|}
name|double
name|max
init|=
name|Double
operator|.
name|NEGATIVE_INFINITY
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_data
index|[
name|i
index|]
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|_data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|max
return|;
block|}
comment|/**      * Finds the minimum value in the list.      *      * @return the smallest value in the list.      * @throws IllegalStateException if the list is empty      */
DECL|method|min
specifier|public
name|double
name|min
parameter_list|()
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"cannot find minimum of an empty list"
argument_list|)
throw|;
block|}
name|double
name|min
init|=
name|Double
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_pos
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|_data
index|[
name|i
index|]
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|_data
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
return|return
name|min
return|;
block|}
comment|// stringification
comment|/**      * Returns a String representation of the list, front to back.      *      * @return a<code>String</code> value      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StringBuilder
name|buf
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"{"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|end
init|=
name|_pos
operator|-
literal|1
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
operator|.
name|append
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
argument_list|()
operator|>
literal|0
condition|)
block|{
name|buf
operator|.
name|append
argument_list|(
name|_data
index|[
name|_pos
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|buf
operator|.
name|append
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|buf
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|writeExternal
specifier|public
name|void
name|writeExternal
parameter_list|(
name|ObjectOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// VERSION
name|out
operator|.
name|writeByte
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// POSITION
name|out
operator|.
name|writeInt
argument_list|(
name|_pos
argument_list|)
expr_stmt|;
comment|// ENTRIES
name|int
name|len
init|=
name|_pos
decl_stmt|;
name|out
operator|.
name|writeInt
argument_list|(
name|_pos
argument_list|)
expr_stmt|;
comment|// Written twice for backwards compatability with
comment|// version 0
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|out
operator|.
name|writeDouble
argument_list|(
name|_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|readExternal
specifier|public
name|void
name|readExternal
parameter_list|(
name|ObjectInput
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
comment|// VERSION
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
comment|// POSITION
name|_pos
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// ENTRIES
name|int
name|len
init|=
name|in
operator|.
name|readInt
argument_list|()
decl_stmt|;
name|_data
operator|=
operator|new
name|double
index|[
name|len
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|_data
index|[
name|i
index|]
operator|=
name|in
operator|.
name|readDouble
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// TDoubleArrayList
end_comment

end_unit

