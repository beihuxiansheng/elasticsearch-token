begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.concurrent.jsr166y
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|concurrent
operator|.
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_comment
comment|/**  * A thread managed by a {@link ForkJoinPool}.  This class is  * subclassable solely for the sake of adding functionality -- there  * are no overridable methods dealing with scheduling or execution.  * However, you can override initialization and termination methods  * surrounding the main task processing loop.  If you do create such a  * subclass, you will also need to supply a custom {@link  * ForkJoinPool.ForkJoinWorkerThreadFactory} to use it in a {@code  * ForkJoinPool}.  *  * @author Doug Lea  * @since 1.7  */
end_comment

begin_class
DECL|class|ForkJoinWorkerThread
specifier|public
class|class
name|ForkJoinWorkerThread
extends|extends
name|Thread
block|{
comment|/*      * Overview:      *      * ForkJoinWorkerThreads are managed by ForkJoinPools and perform      * ForkJoinTasks. This class includes bookkeeping in support of      * worker activation, suspension, and lifecycle control described      * in more detail in the internal documentation of class      * ForkJoinPool. And as described further below, this class also      * includes special-cased support for some ForkJoinTask      * methods. But the main mechanics involve work-stealing:      *      * Work-stealing queues are special forms of Deques that support      * only three of the four possible end-operations -- push, pop,      * and deq (aka steal), under the further constraints that push      * and pop are called only from the owning thread, while deq may      * be called from other threads.  (If you are unfamiliar with      * them, you probably want to read Herlihy and Shavit's book "The      * Art of Multiprocessor programming", chapter 16 describing these      * in more detail before proceeding.)  The main work-stealing      * queue design is roughly similar to those in the papers "Dynamic      * Circular Work-Stealing Deque" by Chase and Lev, SPAA 2005      * (http://research.sun.com/scalable/pubs/index.html) and      * "Idempotent work stealing" by Michael, Saraswat, and Vechev,      * PPoPP 2009 (http://portal.acm.org/citation.cfm?id=1504186).      * The main differences ultimately stem from gc requirements that      * we null out taken slots as soon as we can, to maintain as small      * a footprint as possible even in programs generating huge      * numbers of tasks. To accomplish this, we shift the CAS      * arbitrating pop vs deq (steal) from being on the indices      * ("base" and "sp") to the slots themselves (mainly via method      * "casSlotNull()"). So, both a successful pop and deq mainly      * entail a CAS of a slot from non-null to null.  Because we rely      * on CASes of references, we do not need tag bits on base or sp.      * They are simple ints as used in any circular array-based queue      * (see for example ArrayDeque).  Updates to the indices must      * still be ordered in a way that guarantees that sp == base means      * the queue is empty, but otherwise may err on the side of      * possibly making the queue appear nonempty when a push, pop, or      * deq have not fully committed. Note that this means that the deq      * operation, considered individually, is not wait-free. One thief      * cannot successfully continue until another in-progress one (or,      * if previously empty, a push) completes.  However, in the      * aggregate, we ensure at least probabilistic non-blockingness.      * If an attempted steal fails, a thief always chooses a different      * random victim target to try next. So, in order for one thief to      * progress, it suffices for any in-progress deq or new push on      * any empty queue to complete. One reason this works well here is      * that apparently-nonempty often means soon-to-be-stealable,      * which gives threads a chance to set activation status if      * necessary before stealing.      *      * This approach also enables support for "async mode" where local      * task processing is in FIFO, not LIFO order; simply by using a      * version of deq rather than pop when locallyFifo is true (as set      * by the ForkJoinPool).  This allows use in message-passing      * frameworks in which tasks are never joined.      *      * Efficient implementation of this approach currently relies on      * an uncomfortable amount of "Unsafe" mechanics. To maintain      * correct orderings, reads and writes of variable base require      * volatile ordering.  Variable sp does not require volatile      * writes but still needs store-ordering, which we accomplish by      * pre-incrementing sp before filling the slot with an ordered      * store.  (Pre-incrementing also enables backouts used in      * scanWhileJoining.)  Because they are protected by volatile base      * reads, reads of the queue array and its slots by other threads      * do not need volatile load semantics, but writes (in push)      * require store order and CASes (in pop and deq) require      * (volatile) CAS semantics.  (Michael, Saraswat, and Vechev's      * algorithm has similar properties, but without support for      * nulling slots.)  Since these combinations aren't supported      * using ordinary volatiles, the only way to accomplish these      * efficiently is to use direct Unsafe calls. (Using external      * AtomicIntegers and AtomicReferenceArrays for the indices and      * array is significantly slower because of memory locality and      * indirection effects.)      *      * Further, performance on most platforms is very sensitive to      * placement and sizing of the (resizable) queue array.  Even      * though these queues don't usually become all that big, the      * initial size must be large enough to counteract cache      * contention effects across multiple queues (especially in the      * presence of GC cardmarking). Also, to improve thread-locality,      * queues are initialized after starting.  All together, these      * low-level implementation choices produce as much as a factor of      * 4 performance improvement compared to naive implementations,      * and enable the processing of billions of tasks per second,      * sometimes at the expense of ugliness.      */
comment|/**      * Generator for initial random seeds for random victim      * selection. This is used only to create initial seeds. Random      * steals use a cheaper xorshift generator per steal attempt. We      * expect only rare contention on seedGenerator, so just use a      * plain Random.      */
DECL|field|seedGenerator
specifier|private
specifier|static
specifier|final
name|Random
name|seedGenerator
init|=
operator|new
name|Random
argument_list|()
decl_stmt|;
comment|/**      * The timeout value for suspending spares. Spare workers that      * remain unsignalled for more than this time may be trimmed      * (killed and removed from pool).  Since our goal is to avoid      * long-term thread buildup, the exact value of timeout does not      * matter too much so long as it avoids most false-alarm timeouts      * under GC stalls or momentarily high system load.      */
DECL|field|SPARE_KEEPALIVE_NANOS
specifier|private
specifier|static
specifier|final
name|long
name|SPARE_KEEPALIVE_NANOS
init|=
literal|5L
operator|*
literal|1000L
operator|*
literal|1000L
operator|*
literal|1000L
decl_stmt|;
comment|// 5 secs
comment|/**      * Capacity of work-stealing queue array upon initialization.      * Must be a power of two. Initial size must be at least 2, but is      * padded to minimize cache effects.      */
DECL|field|INITIAL_QUEUE_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|INITIAL_QUEUE_CAPACITY
init|=
literal|1
operator|<<
literal|13
decl_stmt|;
comment|/**      * Maximum work-stealing queue array size.  Must be less than or      * equal to 1<< 28 to ensure lack of index wraparound. (This      * is less than usual bounds, because we need leftshift by 3      * to be in int range).      */
DECL|field|MAXIMUM_QUEUE_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|MAXIMUM_QUEUE_CAPACITY
init|=
literal|1
operator|<<
literal|28
decl_stmt|;
comment|/**      * The pool this thread works in. Accessed directly by ForkJoinTask.      */
DECL|field|pool
specifier|final
name|ForkJoinPool
name|pool
decl_stmt|;
comment|/**      * The work-stealing queue array. Size must be a power of two.      * Initialized in onStart, to improve memory locality.      */
DECL|field|queue
specifier|private
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|queue
decl_stmt|;
comment|/**      * Index (mod queue.length) of least valid queue slot, which is      * always the next position to steal from if nonempty.      */
DECL|field|base
specifier|private
specifier|volatile
name|int
name|base
decl_stmt|;
comment|/**      * Index (mod queue.length) of next queue slot to push to or pop      * from. It is written only by owner thread, and accessed by other      * threads only after reading (volatile) base.  Both sp and base      * are allowed to wrap around on overflow, but (sp - base) still      * estimates size.      */
DECL|field|sp
specifier|private
name|int
name|sp
decl_stmt|;
comment|/**      * Run state of this worker. In addition to the usual run levels,      * tracks if this worker is suspended as a spare, and if it was      * killed (trimmed) while suspended. However, "active" status is      * maintained separately.      */
DECL|field|runState
specifier|private
specifier|volatile
name|int
name|runState
decl_stmt|;
DECL|field|TERMINATING
specifier|private
specifier|static
specifier|final
name|int
name|TERMINATING
init|=
literal|0x01
decl_stmt|;
DECL|field|TERMINATED
specifier|private
specifier|static
specifier|final
name|int
name|TERMINATED
init|=
literal|0x02
decl_stmt|;
DECL|field|SUSPENDED
specifier|private
specifier|static
specifier|final
name|int
name|SUSPENDED
init|=
literal|0x04
decl_stmt|;
comment|// inactive spare
DECL|field|TRIMMED
specifier|private
specifier|static
specifier|final
name|int
name|TRIMMED
init|=
literal|0x08
decl_stmt|;
comment|// killed while suspended
comment|/**      * Number of LockSupport.park calls to block this thread for      * suspension or event waits. Used for internal instrumention;      * currently not exported but included because volatile write upon      * park also provides a workaround for a JVM bug.      */
DECL|field|parkCount
specifier|private
specifier|volatile
name|int
name|parkCount
decl_stmt|;
comment|/**      * Number of steals, transferred and reset in pool callbacks pool      * when idle Accessed directly by pool.      */
DECL|field|stealCount
name|int
name|stealCount
decl_stmt|;
comment|/**      * Seed for random number generator for choosing steal victims.      * Uses Marsaglia xorshift. Must be initialized as nonzero.      */
DECL|field|seed
specifier|private
name|int
name|seed
decl_stmt|;
comment|/**      * Activity status. When true, this worker is considered active.      * Accessed directly by pool.  Must be false upon construction.      */
DECL|field|active
name|boolean
name|active
decl_stmt|;
comment|/**      * True if use local fifo, not default lifo, for local polling.      * Shadows value from ForkJoinPool, which resets it if changed      * pool-wide.      */
DECL|field|locallyFifo
specifier|private
name|boolean
name|locallyFifo
decl_stmt|;
comment|/**      * Index of this worker in pool array. Set once by pool before      * running, and accessed directly by pool to locate this worker in      * its workers array.      */
DECL|field|poolIndex
name|int
name|poolIndex
decl_stmt|;
comment|/**      * The last pool event waited for. Accessed only by pool in      * callback methods invoked within this thread.      */
DECL|field|lastEventCount
name|int
name|lastEventCount
decl_stmt|;
comment|/**      * Encoded index and event count of next event waiter. Used only      * by ForkJoinPool for managing event waiters.      */
DECL|field|nextWaiter
specifier|volatile
name|long
name|nextWaiter
decl_stmt|;
comment|/**      * Creates a ForkJoinWorkerThread operating in the given pool.      *      * @param pool the pool this thread works in      * @throws NullPointerException if pool is null      */
DECL|method|ForkJoinWorkerThread
specifier|protected
name|ForkJoinWorkerThread
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|)
block|{
if|if
condition|(
name|pool
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|// To avoid exposing construction details to subclasses,
comment|// remaining initialization is in start() and onStart()
block|}
comment|/**      * Performs additional initialization and starts this thread      */
DECL|method|start
specifier|final
name|void
name|start
parameter_list|(
name|int
name|poolIndex
parameter_list|,
name|boolean
name|locallyFifo
parameter_list|,
name|UncaughtExceptionHandler
name|ueh
parameter_list|)
block|{
name|this
operator|.
name|poolIndex
operator|=
name|poolIndex
expr_stmt|;
name|this
operator|.
name|locallyFifo
operator|=
name|locallyFifo
expr_stmt|;
if|if
condition|(
name|ueh
operator|!=
literal|null
condition|)
name|setUncaughtExceptionHandler
argument_list|(
name|ueh
argument_list|)
expr_stmt|;
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|start
argument_list|()
expr_stmt|;
block|}
comment|// Public/protected methods
comment|/**      * Returns the pool hosting this thread.      *      * @return the pool      */
DECL|method|getPool
specifier|public
name|ForkJoinPool
name|getPool
parameter_list|()
block|{
return|return
name|pool
return|;
block|}
comment|/**      * Returns the index number of this thread in its pool.  The      * returned value ranges from zero to the maximum number of      * threads (minus one) that have ever been created in the pool.      * This method may be useful for applications that track status or      * collect results per-worker rather than per-task.      *      * @return the index number      */
DECL|method|getPoolIndex
specifier|public
name|int
name|getPoolIndex
parameter_list|()
block|{
return|return
name|poolIndex
return|;
block|}
comment|/**      * Initializes internal state after construction but before      * processing any tasks. If you override this method, you must      * invoke super.onStart() at the beginning of the method.      * Initialization requires care: Most fields must have legal      * default values, to ensure that attempted accesses from other      * threads work correctly even before this thread starts      * processing tasks.      */
DECL|method|onStart
specifier|protected
name|void
name|onStart
parameter_list|()
block|{
name|int
name|rs
init|=
name|seedGenerator
operator|.
name|nextInt
argument_list|()
decl_stmt|;
name|seed
operator|=
name|rs
operator|==
literal|0
condition|?
literal|1
else|:
name|rs
expr_stmt|;
comment|// seed must be nonzero
comment|// Allocate name string and queue array in this thread
name|String
name|pid
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|pool
operator|.
name|getPoolNumber
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|wid
init|=
name|Integer
operator|.
name|toString
argument_list|(
name|poolIndex
argument_list|)
decl_stmt|;
name|setName
argument_list|(
literal|"ForkJoinPool-"
operator|+
name|pid
operator|+
literal|"-worker-"
operator|+
name|wid
argument_list|)
expr_stmt|;
name|queue
operator|=
operator|new
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[
name|INITIAL_QUEUE_CAPACITY
index|]
expr_stmt|;
block|}
comment|/**      * Performs cleanup associated with termination of this worker      * thread.  If you override this method, you must invoke      * {@code super.onTermination} at the end of the overridden method.      *      * @param exception the exception causing this thread to abort due      *                  to an unrecoverable error, or {@code null} if completed normally      */
DECL|method|onTermination
specifier|protected
name|void
name|onTermination
parameter_list|(
name|Throwable
name|exception
parameter_list|)
block|{
try|try
block|{
name|cancelTasks
argument_list|()
expr_stmt|;
name|setTerminated
argument_list|()
expr_stmt|;
name|pool
operator|.
name|workerTerminated
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// Shouldn't ever happen
if|if
condition|(
name|exception
operator|==
literal|null
condition|)
comment|// but if so, at least rethrown
name|exception
operator|=
name|ex
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|exception
operator|!=
literal|null
condition|)
name|UNSAFE
operator|.
name|throwException
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * This method is required to be public, but should never be      * called explicitly. It performs the main run loop to execute      * ForkJoinTasks.      */
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
name|Throwable
name|exception
init|=
literal|null
decl_stmt|;
try|try
block|{
name|onStart
argument_list|()
expr_stmt|;
name|mainLoop
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|exception
operator|=
name|ex
expr_stmt|;
block|}
finally|finally
block|{
name|onTermination
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
comment|// helpers for run()
comment|/**      * Find and execute tasks and check status while running      */
DECL|method|mainLoop
specifier|private
name|void
name|mainLoop
parameter_list|()
block|{
name|boolean
name|ran
init|=
literal|false
decl_stmt|;
comment|// true if ran task on previous step
name|ForkJoinPool
name|p
init|=
name|pool
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|.
name|preStep
argument_list|(
name|this
argument_list|,
name|ran
argument_list|)
expr_stmt|;
if|if
condition|(
name|runState
operator|!=
literal|0
condition|)
return|return;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
comment|// try to get and run stolen or submitted task
if|if
condition|(
name|ran
operator|=
operator|(
name|t
operator|=
name|scan
argument_list|()
operator|)
operator|!=
literal|null
operator|||
operator|(
name|t
operator|=
name|pollSubmission
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|tryExec
argument_list|()
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|sp
condition|)
name|runLocalTasks
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Runs local tasks until queue is empty or shut down.  Call only      * while active.      */
DECL|method|runLocalTasks
specifier|private
name|void
name|runLocalTasks
parameter_list|()
block|{
while|while
condition|(
name|runState
operator|==
literal|0
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|locallyFifo
condition|?
name|locallyDeqTask
argument_list|()
else|:
name|popTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|t
operator|.
name|tryExec
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|base
operator|==
name|sp
condition|)
break|break;
block|}
block|}
comment|/**      * If a submission exists, try to activate and take it      *      * @return a task, if available      */
DECL|method|pollSubmission
specifier|private
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollSubmission
parameter_list|()
block|{
name|ForkJoinPool
name|p
init|=
name|pool
decl_stmt|;
while|while
condition|(
name|p
operator|.
name|hasQueuedSubmissions
argument_list|()
condition|)
block|{
if|if
condition|(
name|active
operator|||
operator|(
name|active
operator|=
name|p
operator|.
name|tryIncrementActiveCount
argument_list|()
operator|)
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|p
operator|.
name|pollSubmission
argument_list|()
decl_stmt|;
return|return
name|t
operator|!=
literal|null
condition|?
name|t
else|:
name|scan
argument_list|()
return|;
comment|// if missed, rescan
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/*      * Intrinsics-based atomic writes for queue slots. These are      * basically the same as methods in AtomicObjectArray, but      * specialized for (1) ForkJoinTask elements (2) requirement that      * nullness and bounds checks have already been performed by      * callers and (3) effective offsets are known not to overflow      * from int to long (because of MAXIMUM_QUEUE_CAPACITY). We don't      * need corresponding version for reads: plain array reads are OK      * because they protected by other volatile reads and are      * confirmed by CASes.      *      * Most uses don't actually call these methods, but instead contain      * inlined forms that enable more predictable optimization.  We      * don't define the version of write used in pushTask at all, but      * instead inline there a store-fenced array slot write.      */
comment|/**      * CASes slot i of array q from t to null. Caller must ensure q is      * non-null and index is in range.      */
DECL|method|casSlotNull
specifier|private
specifier|static
specifier|final
name|boolean
name|casSlotNull
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
parameter_list|,
name|int
name|i
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
operator|(
name|i
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Performs a volatile write of the given task at given slot of      * array q.  Caller must ensure q is non-null and index is in      * range. This method is used only during resets and backouts.      */
DECL|method|writeSlot
specifier|private
specifier|static
specifier|final
name|void
name|writeSlot
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
parameter_list|,
name|int
name|i
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObjectVolatile
argument_list|(
name|q
argument_list|,
operator|(
name|i
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|// queue methods
comment|/**      * Pushes a task. Call only from this thread.      *      * @param t the task. Caller must ensure non-null.      */
DECL|method|pushTask
specifier|final
name|void
name|pushTask
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
init|=
name|queue
decl_stmt|;
name|int
name|mask
init|=
name|q
operator|.
name|length
operator|-
literal|1
decl_stmt|;
comment|// implicit assert q != null
name|UNSAFE
operator|.
name|putOrderedObject
argument_list|(
name|q
argument_list|,
operator|(
operator|(
operator|(
name|s
operator|=
name|sp
operator|++
operator|)
operator|&
name|mask
operator|)
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|-=
name|base
operator|)
operator|<=
literal|0
condition|)
name|pool
operator|.
name|signalWork
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|+
literal|1
operator|>=
name|mask
condition|)
name|growQueue
argument_list|()
expr_stmt|;
block|}
comment|/**      * Tries to take a task from the base of the queue, failing if      * empty or contended. Note: Specializations of this code appear      * in scan and scanWhileJoining.      *      * @return a task, or null if none or contended      */
DECL|method|deqTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|deqTask
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
decl_stmt|;
name|int
name|b
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|base
operator|)
operator|!=
name|sp
operator|&&
operator|(
name|q
operator|=
name|queue
operator|)
operator|!=
literal|null
operator|&&
comment|// must read q after b
operator|(
name|t
operator|=
name|q
index|[
name|i
operator|=
operator|(
name|q
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
index|]
operator|)
operator|!=
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
operator|(
name|i
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Tries to take a task from the base of own queue. Assumes active      * status.  Called only by current thread.      *      * @return a task, or null if none      */
DECL|method|locallyDeqTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|locallyDeqTask
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
init|=
name|queue
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|int
name|b
decl_stmt|,
name|i
decl_stmt|;
while|while
condition|(
name|sp
operator|!=
operator|(
name|b
operator|=
name|base
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|q
index|[
name|i
operator|=
operator|(
name|q
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
index|]
operator|)
operator|!=
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
operator|(
name|i
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns a popped task, or null if empty. Assumes active status.      * Called only by current thread. (Note: a specialization of this      * code appears in scanWhileJoining.)      */
DECL|method|popTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|popTask
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
init|=
name|queue
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|sp
operator|)
operator|!=
name|base
condition|)
block|{
name|int
name|i
init|=
operator|(
name|q
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
operator|--
name|s
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|q
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
operator|(
name|i
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|sp
operator|=
name|s
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Specialized version of popTask to pop only if      * topmost element is the given task. Called only      * by current thread while active.      *      * @param t the task. Caller must ensure non-null.      */
DECL|method|unpushTask
specifier|final
name|boolean
name|unpushTask
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
init|=
name|queue
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
operator|(
operator|(
operator|(
name|q
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
operator|(
name|s
operator|=
name|sp
operator|-
literal|1
operator|)
operator|)
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|sp
operator|=
name|s
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns next task or null if empty or contended      */
DECL|method|peekTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|peekTask
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
init|=
name|queue
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|int
name|mask
init|=
name|q
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|i
init|=
name|locallyFifo
condition|?
name|base
else|:
operator|(
name|sp
operator|-
literal|1
operator|)
decl_stmt|;
return|return
name|q
index|[
name|i
operator|&
name|mask
index|]
return|;
block|}
comment|/**      * Doubles queue array size. Transfers elements by emulating      * steals (deqs) from old array and placing, oldest first, into      * new array.      */
DECL|method|growQueue
specifier|private
name|void
name|growQueue
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|oldQ
init|=
name|queue
decl_stmt|;
name|int
name|oldSize
init|=
name|oldQ
operator|.
name|length
decl_stmt|;
name|int
name|newSize
init|=
name|oldSize
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|newSize
operator|>
name|MAXIMUM_QUEUE_CAPACITY
condition|)
throw|throw
operator|new
name|RejectedExecutionException
argument_list|(
literal|"Queue capacity exceeded"
argument_list|)
throw|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|newQ
init|=
name|queue
operator|=
operator|new
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[
name|newSize
index|]
decl_stmt|;
name|int
name|b
init|=
name|base
decl_stmt|;
name|int
name|bf
init|=
name|b
operator|+
name|oldSize
decl_stmt|;
name|int
name|oldMask
init|=
name|oldSize
operator|-
literal|1
decl_stmt|;
name|int
name|newMask
init|=
name|newSize
operator|-
literal|1
decl_stmt|;
do|do
block|{
name|int
name|oldIndex
init|=
name|b
operator|&
name|oldMask
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|oldQ
index|[
name|oldIndex
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
operator|!
name|casSlotNull
argument_list|(
name|oldQ
argument_list|,
name|oldIndex
argument_list|,
name|t
argument_list|)
condition|)
name|t
operator|=
literal|null
expr_stmt|;
name|writeSlot
argument_list|(
name|newQ
argument_list|,
name|b
operator|&
name|newMask
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|b
operator|!=
name|bf
condition|)
do|;
name|pool
operator|.
name|signalWork
argument_list|()
expr_stmt|;
block|}
comment|/**      * Computes next value for random victim probe in scan().  Scans      * don't require a very high quality generator, but also not a      * crummy one.  Marsaglia xor-shift is cheap and works well enough.      * Note: This is manually inlined in scan()      */
DECL|method|xorShift
specifier|private
specifier|static
specifier|final
name|int
name|xorShift
parameter_list|(
name|int
name|r
parameter_list|)
block|{
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
return|return
name|r
operator|^
operator|(
name|r
operator|<<
literal|5
operator|)
return|;
block|}
comment|/**      * Tries to steal a task from another worker. Starts at a random      * index of workers array, and probes workers until finding one      * with non-empty queue or finding that all are empty.  It      * randomly selects the first n probes. If these are empty, it      * resorts to a circular sweep, which is necessary to accurately      * set active status. (The circular sweep uses steps of      * approximately half the array size plus 1, to avoid bias      * stemming from leftmost packing of the array in ForkJoinPool.)      *      * This method must be both fast and quiet -- usually avoiding      * memory accesses that could disrupt cache sharing etc other than      * those needed to check for and take tasks (or to activate if not      * already active). This accounts for, among other things,      * updating random seed in place without storing it until exit.      *      * @return a task, or null if none found      */
DECL|method|scan
specifier|private
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|scan
parameter_list|()
block|{
name|ForkJoinPool
name|p
init|=
name|pool
decl_stmt|;
name|ForkJoinWorkerThread
index|[]
name|ws
init|=
name|p
operator|.
name|workers
decl_stmt|;
name|int
name|n
init|=
name|ws
operator|.
name|length
decl_stmt|;
comment|// upper bound of #workers
name|boolean
name|canSteal
init|=
name|active
decl_stmt|;
comment|// shadow active status
name|int
name|r
init|=
name|seed
decl_stmt|;
comment|// extract seed once
name|int
name|k
init|=
name|r
decl_stmt|;
comment|// index: random if j<0 else step
for|for
control|(
name|int
name|j
init|=
operator|-
name|n
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
block|{
name|ForkJoinWorkerThread
name|v
init|=
name|ws
index|[
name|k
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|5
expr_stmt|;
comment|// xorshift
if|if
condition|(
name|v
operator|!=
literal|null
operator|&&
name|v
operator|.
name|base
operator|!=
name|v
operator|.
name|sp
condition|)
block|{
if|if
condition|(
name|canSteal
operator|||
comment|// ensure active status
operator|(
name|canSteal
operator|=
name|active
operator|=
name|p
operator|.
name|tryIncrementActiveCount
argument_list|()
operator|)
condition|)
block|{
name|int
name|b
decl_stmt|,
name|i
decl_stmt|;
comment|// inlined specialization of deqTask
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|v
operator|.
name|base
operator|)
operator|!=
name|v
operator|.
name|sp
operator|&&
comment|// recheck
operator|(
name|q
operator|=
name|v
operator|.
name|queue
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|t
operator|=
name|q
index|[
name|i
operator|=
operator|(
name|q
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
index|]
operator|)
operator|!=
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
operator|(
name|i
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|v
operator|.
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
name|seed
operator|=
name|r
expr_stmt|;
operator|++
name|stealCount
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
name|j
operator|=
operator|-
name|n
expr_stmt|;
comment|// reset on contention
block|}
name|k
operator|=
name|j
operator|>=
literal|0
condition|?
name|k
operator|+
operator|(
operator|(
name|n
operator|>>>
literal|1
operator|)
operator||
literal|1
operator|)
else|:
name|r
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|// Run State management
comment|// status check methods used mainly by ForkJoinPool
DECL|method|isTerminating
specifier|final
name|boolean
name|isTerminating
parameter_list|()
block|{
return|return
operator|(
name|runState
operator|&
name|TERMINATING
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|isTerminated
specifier|final
name|boolean
name|isTerminated
parameter_list|()
block|{
return|return
operator|(
name|runState
operator|&
name|TERMINATED
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|isSuspended
specifier|final
name|boolean
name|isSuspended
parameter_list|()
block|{
return|return
operator|(
name|runState
operator|&
name|SUSPENDED
operator|)
operator|!=
literal|0
return|;
block|}
DECL|method|isTrimmed
specifier|final
name|boolean
name|isTrimmed
parameter_list|()
block|{
return|return
operator|(
name|runState
operator|&
name|TRIMMED
operator|)
operator|!=
literal|0
return|;
block|}
comment|/**      * Sets state to TERMINATING, also resuming if suspended.      */
DECL|method|shutdown
specifier|final
name|void
name|shutdown
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|s
init|=
name|runState
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|SUSPENDED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// kill and wakeup if suspended
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
argument_list|,
operator|(
name|s
operator|&
operator|~
name|SUSPENDED
operator|)
operator||
operator|(
name|TRIMMED
operator||
name|TERMINATING
operator|)
argument_list|)
condition|)
block|{
name|LockSupport
operator|.
name|unpark
argument_list|(
name|this
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
argument_list|,
name|s
operator||
name|TERMINATING
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/**      * Sets state to TERMINATED. Called only by this thread.      */
DECL|method|setTerminated
specifier|private
name|void
name|setTerminated
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
do|do
block|{         }
do|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
operator|=
name|runState
argument_list|,
name|s
operator||
operator|(
name|TERMINATING
operator||
name|TERMINATED
operator|)
argument_list|)
condition|)
do|;
block|}
comment|/**      * Instrumented version of park. Also used by ForkJoinPool.awaitEvent      */
DECL|method|doPark
specifier|final
name|void
name|doPark
parameter_list|()
block|{
operator|++
name|parkCount
expr_stmt|;
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * If suspended, tries to set status to unsuspended.      * Caller must unpark to actually resume      *      * @return true if successful      */
DECL|method|tryUnsuspend
specifier|final
name|boolean
name|tryUnsuspend
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|s
operator|=
name|runState
operator|)
operator|&
name|SUSPENDED
operator|)
operator|!=
literal|0
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
argument_list|,
name|s
operator|&
operator|~
name|SUSPENDED
argument_list|)
operator|)
return|;
block|}
comment|/**      * Sets suspended status and blocks as spare until resumed,      * shutdown, or timed out.      *      * @return false if trimmed      */
DECL|method|suspendAsSpare
specifier|final
name|boolean
name|suspendAsSpare
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// set suspended unless terminating
name|int
name|s
init|=
name|runState
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|TERMINATING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// must kill
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
argument_list|,
name|s
operator||
operator|(
name|TRIMMED
operator||
name|TERMINATING
operator|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
argument_list|,
name|s
operator||
name|SUSPENDED
argument_list|)
condition|)
break|break;
block|}
name|lastEventCount
operator|=
literal|0
expr_stmt|;
comment|// reset upon resume
name|ForkJoinPool
name|p
init|=
name|pool
decl_stmt|;
name|p
operator|.
name|releaseWaiters
argument_list|()
expr_stmt|;
comment|// help others progress
name|p
operator|.
name|accumulateStealCount
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|interrupted
argument_list|()
expr_stmt|;
comment|// clear/ignore interrupts
if|if
condition|(
name|poolIndex
operator|<
name|p
operator|.
name|getParallelism
argument_list|()
condition|)
block|{
comment|// untimed wait
while|while
condition|(
operator|(
name|runState
operator|&
name|SUSPENDED
operator|)
operator|!=
literal|0
condition|)
name|doPark
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|timedSuspend
argument_list|()
return|;
comment|// timed wait if apparently non-core
block|}
comment|/**      * Blocks as spare until resumed or timed out      *      * @return false if trimmed      */
DECL|method|timedSuspend
specifier|private
name|boolean
name|timedSuspend
parameter_list|()
block|{
name|long
name|nanos
init|=
name|SPARE_KEEPALIVE_NANOS
decl_stmt|;
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
name|runState
operator|&
name|SUSPENDED
operator|)
operator|!=
literal|0
condition|)
block|{
operator|++
name|parkCount
expr_stmt|;
if|if
condition|(
operator|(
name|nanos
operator|-=
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
operator|)
operator|>
literal|0
condition|)
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
else|else
block|{
comment|// try to trim on timeout
name|int
name|s
init|=
name|runState
decl_stmt|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|runStateOffset
argument_list|,
name|s
argument_list|,
operator|(
name|s
operator|&
operator|~
name|SUSPENDED
operator|)
operator||
operator|(
name|TRIMMED
operator||
name|TERMINATING
operator|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|// Misc support methods for ForkJoinPool
comment|/**      * Returns an estimate of the number of tasks in the queue.  Also      * used by ForkJoinTask.      */
DECL|method|getQueueSize
specifier|final
name|int
name|getQueueSize
parameter_list|()
block|{
return|return
operator|-
name|base
operator|+
name|sp
return|;
block|}
comment|/**      * Set locallyFifo mode. Called only by ForkJoinPool      */
DECL|method|setAsyncMode
specifier|final
name|void
name|setAsyncMode
parameter_list|(
name|boolean
name|async
parameter_list|)
block|{
name|locallyFifo
operator|=
name|async
expr_stmt|;
block|}
comment|/**      * Removes and cancels all tasks in queue.  Can be called from any      * thread.      */
DECL|method|cancelTasks
specifier|final
name|void
name|cancelTasks
parameter_list|()
block|{
while|while
condition|(
name|base
operator|!=
name|sp
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|deqTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
name|t
operator|.
name|cancelIgnoringExceptions
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Drains tasks to given collection c.      *      * @return the number of tasks drained      */
DECL|method|drainTasksTo
specifier|final
name|int
name|drainTasksTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|base
operator|!=
name|sp
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|deqTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|c
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
block|}
return|return
name|n
return|;
block|}
comment|// Support methods for ForkJoinTask
comment|/**      * Returns an estimate of the number of tasks, offset by a      * function of number of idle workers.      *      * This method provides a cheap heuristic guide for task      * partitioning when programmers, frameworks, tools, or languages      * have little or no idea about task granularity.  In essence by      * offering this method, we ask users only about tradeoffs in      * overhead vs expected throughput and its variance, rather than      * how finely to partition tasks.      *      * In a steady state strict (tree-structured) computation, each      * thread makes available for stealing enough tasks for other      * threads to remain active. Inductively, if all threads play by      * the same rules, each thread should make available only a      * constant number of tasks.      *      * The minimum useful constant is just 1. But using a value of 1      * would require immediate replenishment upon each steal to      * maintain enough tasks, which is infeasible.  Further,      * partitionings/granularities of offered tasks should minimize      * steal rates, which in general means that threads nearer the top      * of computation tree should generate more than those nearer the      * bottom. In perfect steady state, each thread is at      * approximately the same level of computation tree. However,      * producing extra tasks amortizes the uncertainty of progress and      * diffusion assumptions.      *      * So, users will want to use values larger, but not much larger      * than 1 to both smooth over transient shortages and hedge      * against uneven progress; as traded off against the cost of      * extra task overhead. We leave the user to pick a threshold      * value to compare with the results of this call to guide      * decisions, but recommend values such as 3.      *      * When all threads are active, it is on average OK to estimate      * surplus strictly locally. In steady-state, if one thread is      * maintaining say 2 surplus tasks, then so are others. So we can      * just use estimated queue length (although note that (sp - base)      * can be an overestimate because of stealers lagging increments      * of base).  However, this strategy alone leads to serious      * mis-estimates in some non-steady-state conditions (ramp-up,      * ramp-down, other stalls). We can detect many of these by      * further considering the number of "idle" threads, that are      * known to have zero queued tasks, so compensate by a factor of      * (#idle/#active) threads.      */
DECL|method|getEstimatedSurplusTaskCount
specifier|final
name|int
name|getEstimatedSurplusTaskCount
parameter_list|()
block|{
return|return
name|sp
operator|-
name|base
operator|-
name|pool
operator|.
name|idlePerActive
argument_list|()
return|;
block|}
comment|/**      * Gets and removes a local task.      *      * @return a task, if available      */
DECL|method|pollLocalTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollLocalTask
parameter_list|()
block|{
while|while
condition|(
name|base
operator|!=
name|sp
condition|)
block|{
if|if
condition|(
name|active
operator|||
operator|(
name|active
operator|=
name|pool
operator|.
name|tryIncrementActiveCount
argument_list|()
operator|)
condition|)
return|return
name|locallyFifo
condition|?
name|locallyDeqTask
argument_list|()
else|:
name|popTask
argument_list|()
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Gets and removes a local or stolen task.      *      * @return a task, if available      */
DECL|method|pollTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollTask
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
return|return
operator|(
name|t
operator|=
name|pollLocalTask
argument_list|()
operator|)
operator|!=
literal|null
condition|?
name|t
else|:
name|scan
argument_list|()
return|;
block|}
comment|/**      * Returns a stolen task, if available, unless joinMe is done      *      * This method is intrinsically nonmodular. To maintain the      * property that tasks are never stolen if the awaited task is      * ready, we must interleave mechanics of scan with status      * checks. We rely here on the commit points of deq that allow us      * to cancel a steal even after CASing slot to null, but before      * adjusting base index: If, after the CAS, we see that joinMe is      * ready, we can back out by placing the task back into the slot,      * without adjusting index. The scan loop is otherwise the same as      * in scan.      *      * The outer loop cannot be allowed to run forever, because it      * could lead to a form of deadlock if all threads are executing      * this method. However, we must also be patient before giving up,      * to cope with GC stalls, transient high loads, etc. The loop      * terminates (causing caller to possibly block this thread and      * create a replacement) only after #workers clean sweeps during      * which all running threads are active.      */
DECL|method|scanWhileJoining
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|scanWhileJoining
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|joinMe
parameter_list|)
block|{
name|int
name|sweeps
init|=
literal|0
decl_stmt|;
name|int
name|r
init|=
name|seed
decl_stmt|;
name|ForkJoinPool
name|p
init|=
name|pool
decl_stmt|;
name|p
operator|.
name|releaseWaiters
argument_list|()
expr_stmt|;
comment|// help other threads progress
while|while
condition|(
name|joinMe
operator|.
name|status
operator|>=
literal|0
condition|)
block|{
name|ForkJoinWorkerThread
index|[]
name|ws
init|=
name|p
operator|.
name|workers
decl_stmt|;
name|int
name|n
init|=
name|ws
operator|.
name|length
decl_stmt|;
name|int
name|k
init|=
name|r
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
operator|-
name|n
init|;
name|j
operator|<
name|n
condition|;
operator|++
name|j
control|)
block|{
name|ForkJoinWorkerThread
name|v
init|=
name|ws
index|[
name|k
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
index|]
decl_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|5
expr_stmt|;
comment|// xorshift
if|if
condition|(
name|v
operator|!=
literal|null
condition|)
block|{
name|int
name|b
init|=
name|v
operator|.
name|base
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|q
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|v
operator|.
name|sp
operator|&&
operator|(
name|q
operator|=
name|v
operator|.
name|queue
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|i
init|=
operator|(
name|q
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|q
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|joinMe
operator|.
name|status
operator|<
literal|0
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
operator|(
name|i
operator|<<
name|qShift
operator|)
operator|+
name|qBase
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
if|if
condition|(
name|joinMe
operator|.
name|status
operator|<
literal|0
condition|)
block|{
name|writeSlot
argument_list|(
name|q
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|// back out
return|return
literal|null
return|;
block|}
name|v
operator|.
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
name|seed
operator|=
name|r
expr_stmt|;
operator|++
name|stealCount
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
name|sweeps
operator|=
literal|0
expr_stmt|;
comment|// ensure rescan on contention
block|}
block|}
name|k
operator|=
name|j
operator|>=
literal|0
condition|?
name|k
operator|+
operator|(
operator|(
name|n
operator|>>>
literal|1
operator|)
operator||
literal|1
operator|)
else|:
name|r
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
literal|7
operator|)
operator|==
literal|0
operator|&&
name|joinMe
operator|.
name|status
operator|<
literal|0
condition|)
comment|// periodically recheck
return|return
literal|null
return|;
block|}
if|if
condition|(
operator|(
name|sweeps
operator|=
name|p
operator|.
name|inactiveCount
argument_list|()
operator|==
literal|0
condition|?
name|sweeps
operator|+
literal|1
else|:
literal|0
operator|)
operator|>
name|n
condition|)
return|return
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Runs tasks until {@code pool.isQuiescent()}.      */
DECL|method|helpQuiescePool
specifier|final
name|void
name|helpQuiescePool
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|pollLocalTask
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
operator|||
operator|(
name|t
operator|=
name|scan
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|tryExec
argument_list|()
expr_stmt|;
else|else
block|{
name|ForkJoinPool
name|p
init|=
name|pool
decl_stmt|;
if|if
condition|(
name|active
condition|)
block|{
name|active
operator|=
literal|false
expr_stmt|;
comment|// inactivate
do|do
block|{                     }
do|while
condition|(
operator|!
name|p
operator|.
name|tryDecrementActiveCount
argument_list|()
condition|)
do|;
block|}
if|if
condition|(
name|p
operator|.
name|isQuiescent
argument_list|()
condition|)
block|{
name|active
operator|=
literal|true
expr_stmt|;
comment|// re-activate
do|do
block|{                     }
do|while
condition|(
operator|!
name|p
operator|.
name|tryIncrementActiveCount
argument_list|()
condition|)
do|;
return|return;
block|}
block|}
block|}
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
init|=
name|getUnsafe
argument_list|()
decl_stmt|;
DECL|field|runStateOffset
specifier|private
specifier|static
specifier|final
name|long
name|runStateOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"runState"
argument_list|,
name|ForkJoinWorkerThread
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|qBase
specifier|private
specifier|static
specifier|final
name|long
name|qBase
init|=
name|UNSAFE
operator|.
name|arrayBaseOffset
argument_list|(
name|ForkJoinTask
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|qShift
specifier|private
specifier|static
specifier|final
name|int
name|qShift
decl_stmt|;
static|static
block|{
name|int
name|s
init|=
name|UNSAFE
operator|.
name|arrayIndexScale
argument_list|(
name|ForkJoinTask
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|qShift
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
DECL|method|objectFieldOffset
specifier|private
specifier|static
name|long
name|objectFieldOffset
parameter_list|(
name|String
name|field
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|klazz
parameter_list|)
block|{
try|try
block|{
return|return
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|klazz
operator|.
name|getDeclaredField
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
comment|// Convert Exception to corresponding Error
name|NoSuchFieldError
name|error
init|=
operator|new
name|NoSuchFieldError
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

