begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Cliff Click and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.concurrent.highscalelib
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|concurrent
operator|.
name|highscalelib
package|;
end_package

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|Unsafe
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLongFieldUpdater
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReferenceFieldUpdater
import|;
end_import

begin_comment
comment|/**  * A lock-free alternate implementation of {@link java.util.ConcurrentHashMap}  * with<strong>primitive long keys</strong>, better scaling properties and  * generally lower costs.  The use of {@code long} keys allows for faster  * compares and lower memory costs.  The Map provides identical correctness  * properties as ConcurrentHashMap.  All operations are non-blocking and  * multi-thread safe, including all update operations.  {@link  * NonBlockingHashMapLong} scales substatially better than {@link  * java.util.ConcurrentHashMap} for high update rates, even with a large  * concurrency factor.  Scaling is linear up to 768 CPUs on a 768-CPU Azul  * box, even with 100% updates or 100% reads or any fraction in-between.  * Linear scaling up to all cpus has been observed on a 32-way Sun US2 box,  * 32-way Sun Niagra box, 8-way Intel box and a 4-way Power box.  *<p/>  *<p><strong>The main benefit of this class</strong> over using plain {@link  * org.cliffc.high_scale_lib.NonBlockingHashMap} with {@link Long} keys is  * that it avoids the auto-boxing and unboxing costs.  Since auto-boxing is  *<em>automatic</em>, it is easy to accidentally cause auto-boxing and negate  * the space and speed benefits.  *<p/>  *<p>This class obeys the same functional specification as {@link  * java.util.Hashtable}, and includes versions of methods corresponding to  * each method of<tt>Hashtable</tt>.  However, even though all operations are  * thread-safe, operations do<em>not</em> entail locking and there is  *<em>not</em> any support for locking the entire table in a way that  * prevents all access.  This class is fully interoperable with  *<tt>Hashtable</tt> in programs that rely on its thread safety but not on  * its synchronization details.  *<p/>  *<p> Operations (including<tt>put</tt>) generally do not block, so may  * overlap with other update operations (including other<tt>puts</tt> and  *<tt>removes</tt>).  Retrievals reflect the results of the most recently  *<em>completed</em> update operations holding upon their onset.  For  * aggregate operations such as<tt>putAll</tt>, concurrent retrievals may  * reflect insertion or removal of only some entries.  Similarly, Iterators  * and Enumerations return elements reflecting the state of the hash table at  * some point at or since the creation of the iterator/enumeration.  They do  *<em>not</em> throw {@link ConcurrentModificationException}.  However,  * iterators are designed to be used by only one thread at a time.  *<p/>  *<p> Very full tables, or tables with high reprobe rates may trigger an  * internal resize operation to move into a larger table.  Resizing is not  * terribly expensive, but it is not free either; during resize operations  * table throughput may drop somewhat.  All threads that visit the table  * during a resize will 'help' the resizing but will still be allowed to  * complete their operation before the resize is finished (i.e., a simple  * 'get' operation on a million-entry table undergoing resizing will not need  * to block until the entire million entries are copied).  *<p/>  *<p>This class and its views and iterators implement all of the  *<em>optional</em> methods of the {@link Map} and {@link Iterator}  * interfaces.  *<p/>  *<p> Like {@link Hashtable} but unlike {@link HashMap}, this class  * does<em>not</em> allow<tt>null</tt> to be used as a value.  *  * @author Cliff Click  * @param<TypeV> the type of mapped values  * @since 1.5  */
end_comment

begin_class
DECL|class|NonBlockingHashMapLong
specifier|public
class|class
name|NonBlockingHashMapLong
parameter_list|<
name|TypeV
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1234123412341234124L
decl_stmt|;
DECL|field|REPROBE_LIMIT
specifier|private
specifier|static
specifier|final
name|int
name|REPROBE_LIMIT
init|=
literal|10
decl_stmt|;
comment|// Too many reprobes then force a table-resize
comment|// --- Bits to allow Unsafe access to arrays
DECL|field|_unsafe
specifier|private
specifier|static
specifier|final
name|Unsafe
name|_unsafe
init|=
name|UtilUnsafe
operator|.
name|getUnsafe
argument_list|()
decl_stmt|;
DECL|field|_Obase
specifier|private
specifier|static
specifier|final
name|int
name|_Obase
init|=
name|_unsafe
operator|.
name|arrayBaseOffset
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|_Oscale
specifier|private
specifier|static
specifier|final
name|int
name|_Oscale
init|=
name|_unsafe
operator|.
name|arrayIndexScale
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|rawIndex
specifier|private
specifier|static
name|long
name|rawIndex
parameter_list|(
specifier|final
name|Object
index|[]
name|ary
parameter_list|,
specifier|final
name|int
name|idx
parameter_list|)
block|{
assert|assert
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ary
operator|.
name|length
assert|;
return|return
name|_Obase
operator|+
name|idx
operator|*
name|_Oscale
return|;
block|}
DECL|field|_Lbase
specifier|private
specifier|static
specifier|final
name|int
name|_Lbase
init|=
name|_unsafe
operator|.
name|arrayBaseOffset
argument_list|(
name|long
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|_Lscale
specifier|private
specifier|static
specifier|final
name|int
name|_Lscale
init|=
name|_unsafe
operator|.
name|arrayIndexScale
argument_list|(
name|long
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|rawIndex
specifier|private
specifier|static
name|long
name|rawIndex
parameter_list|(
specifier|final
name|long
index|[]
name|ary
parameter_list|,
specifier|final
name|int
name|idx
parameter_list|)
block|{
assert|assert
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ary
operator|.
name|length
assert|;
return|return
name|_Lbase
operator|+
name|idx
operator|*
name|_Lscale
return|;
block|}
comment|// --- Bits to allow Unsafe CAS'ing of the CHM field
DECL|field|_chm_offset
specifier|private
specifier|static
specifier|final
name|long
name|_chm_offset
decl_stmt|;
DECL|field|_val_1_offset
specifier|private
specifier|static
specifier|final
name|long
name|_val_1_offset
decl_stmt|;
static|static
block|{
comment|//<clinit>
name|Field
name|f
init|=
literal|null
decl_stmt|;
try|try
block|{
name|f
operator|=
name|NonBlockingHashMapLong
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"_chm"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|NoSuchFieldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|_chm_offset
operator|=
name|_unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|f
argument_list|)
expr_stmt|;
try|try
block|{
name|f
operator|=
name|NonBlockingHashMapLong
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"_val_1"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|lang
operator|.
name|NoSuchFieldException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|_val_1_offset
operator|=
name|_unsafe
operator|.
name|objectFieldOffset
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
DECL|method|CAS
specifier|private
specifier|final
name|boolean
name|CAS
parameter_list|(
specifier|final
name|long
name|offset
parameter_list|,
specifier|final
name|Object
name|old
parameter_list|,
specifier|final
name|Object
name|nnn
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|offset
argument_list|,
name|old
argument_list|,
name|nnn
argument_list|)
return|;
block|}
comment|// --- Adding a 'prime' bit onto Values via wrapping with a junk wrapper class
DECL|class|Prime
specifier|private
specifier|static
specifier|final
class|class
name|Prime
block|{
DECL|field|_V
specifier|final
name|Object
name|_V
decl_stmt|;
DECL|method|Prime
name|Prime
parameter_list|(
name|Object
name|V
parameter_list|)
block|{
name|_V
operator|=
name|V
expr_stmt|;
block|}
DECL|method|unbox
specifier|static
name|Object
name|unbox
parameter_list|(
name|Object
name|V
parameter_list|)
block|{
return|return
name|V
operator|instanceof
name|Prime
condition|?
operator|(
operator|(
name|Prime
operator|)
name|V
operator|)
operator|.
name|_V
else|:
name|V
return|;
block|}
block|}
comment|// --- The Hash Table --------------------
DECL|field|_chm
specifier|private
specifier|transient
name|CHM
name|_chm
decl_stmt|;
comment|// This next field holds the value for Key 0 - the special key value which
comment|// is the initial array value, and also means: no-key-inserted-yet.
DECL|field|_val_1
specifier|private
specifier|transient
name|Object
name|_val_1
decl_stmt|;
comment|// Value for Key: NO_KEY
comment|// Time since last resize
DECL|field|_last_resize_milli
specifier|private
specifier|transient
name|long
name|_last_resize_milli
decl_stmt|;
comment|// Optimize for space: use a 1/2-sized table and allow more re-probes
DECL|field|_opt_for_space
specifier|private
specifier|final
name|boolean
name|_opt_for_space
decl_stmt|;
comment|// --- Minimum table size ----------------
comment|// Pick size 16 K/V pairs, which turns into (16*2)*4+12 = 140 bytes on a
comment|// standard 32-bit HotSpot, and (16*2)*8+12 = 268 bytes on 64-bit Azul.
DECL|field|MIN_SIZE_LOG
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SIZE_LOG
init|=
literal|4
decl_stmt|;
comment|//
DECL|field|MIN_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SIZE
init|=
operator|(
literal|1
operator|<<
name|MIN_SIZE_LOG
operator|)
decl_stmt|;
comment|// Must be power of 2
comment|// --- Sentinels -------------------------
comment|// No-Match-Old - putIfMatch does updates only if it matches the old value,
comment|// and NO_MATCH_OLD basically counts as a wildcard match.
DECL|field|NO_MATCH_OLD
specifier|private
specifier|static
specifier|final
name|Object
name|NO_MATCH_OLD
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Sentinel
comment|// Match-Any-not-null - putIfMatch does updates only if it find a real old
comment|// value.
DECL|field|MATCH_ANY
specifier|private
specifier|static
specifier|final
name|Object
name|MATCH_ANY
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Sentinel
comment|// This K/V pair has been deleted (but the Key slot is forever claimed).
comment|// The same Key can be reinserted with a new value later.
DECL|field|TOMBSTONE
specifier|private
specifier|static
specifier|final
name|Object
name|TOMBSTONE
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
comment|// Prime'd or box'd version of TOMBSTONE.  This K/V pair was deleted, then a
comment|// table resize started.  The K/V pair has been marked so that no new
comment|// updates can happen to the old table (and since the K/V pair was deleted
comment|// nothing was copied to the new table).
DECL|field|TOMBPRIME
specifier|private
specifier|static
specifier|final
name|Prime
name|TOMBPRIME
init|=
operator|new
name|Prime
argument_list|(
name|TOMBSTONE
argument_list|)
decl_stmt|;
comment|// I exclude 1 long from the 2^64 possibilities, and test for it before
comment|// entering the main array.  The NO_KEY value must be zero, the initial
comment|// value set by Java before it hands me the array.
DECL|field|NO_KEY
specifier|private
specifier|static
specifier|final
name|long
name|NO_KEY
init|=
literal|0L
decl_stmt|;
comment|// --- dump ----------------------------------------------------------------
comment|/**      * Verbose printout of table internals, useful for debugging.      */
DECL|method|print
specifier|public
specifier|final
name|void
name|print
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"========="
argument_list|)
expr_stmt|;
name|print_impl
argument_list|(
operator|-
literal|99
argument_list|,
name|NO_KEY
argument_list|,
name|_val_1
argument_list|)
expr_stmt|;
name|_chm
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"========="
argument_list|)
expr_stmt|;
block|}
DECL|method|print_impl
specifier|private
specifier|static
specifier|final
name|void
name|print_impl
parameter_list|(
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|long
name|K
parameter_list|,
specifier|final
name|Object
name|V
parameter_list|)
block|{
name|String
name|p
init|=
operator|(
name|V
operator|instanceof
name|Prime
operator|)
condition|?
literal|"prime_"
else|:
literal|""
decl_stmt|;
name|Object
name|V2
init|=
name|Prime
operator|.
name|unbox
argument_list|(
name|V
argument_list|)
decl_stmt|;
name|String
name|VS
init|=
operator|(
name|V2
operator|==
name|TOMBSTONE
operator|)
condition|?
literal|"tombstone"
else|:
name|V2
operator|.
name|toString
argument_list|()
decl_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"["
operator|+
name|i
operator|+
literal|"]=("
operator|+
name|K
operator|+
literal|","
operator|+
name|p
operator|+
name|VS
operator|+
literal|")"
argument_list|)
expr_stmt|;
block|}
DECL|method|print2
specifier|private
specifier|final
name|void
name|print2
parameter_list|()
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"========="
argument_list|)
expr_stmt|;
name|print2_impl
argument_list|(
operator|-
literal|99
argument_list|,
name|NO_KEY
argument_list|,
name|_val_1
argument_list|)
expr_stmt|;
name|_chm
operator|.
name|print
argument_list|()
expr_stmt|;
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"========="
argument_list|)
expr_stmt|;
block|}
DECL|method|print2_impl
specifier|private
specifier|static
specifier|final
name|void
name|print2_impl
parameter_list|(
specifier|final
name|int
name|i
parameter_list|,
specifier|final
name|long
name|K
parameter_list|,
specifier|final
name|Object
name|V
parameter_list|)
block|{
if|if
condition|(
name|V
operator|!=
literal|null
operator|&&
name|Prime
operator|.
name|unbox
argument_list|(
name|V
argument_list|)
operator|!=
name|TOMBSTONE
condition|)
name|print_impl
argument_list|(
name|i
argument_list|,
name|K
argument_list|,
name|V
argument_list|)
expr_stmt|;
block|}
comment|// Count of reprobes
DECL|field|_reprobes
specifier|private
specifier|transient
name|Counter
name|_reprobes
init|=
operator|new
name|Counter
argument_list|()
decl_stmt|;
comment|/**      * Get and clear the current count of reprobes.  Reprobes happen on key      * collisions, and a high reprobe rate may indicate a poor hash function or      * weaknesses in the table resizing function.      *      * @return the count of reprobes since the last call to {@link #reprobes}      *         or since the table was created.      */
DECL|method|reprobes
specifier|public
name|long
name|reprobes
parameter_list|()
block|{
name|long
name|r
init|=
name|_reprobes
operator|.
name|get
argument_list|()
decl_stmt|;
name|_reprobes
operator|=
operator|new
name|Counter
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
comment|// --- reprobe_limit -----------------------------------------------------
comment|// Heuristic to decide if we have reprobed toooo many times.  Running over
comment|// the reprobe limit on a 'get' call acts as a 'miss'; on a 'put' call it
comment|// can trigger a table resize.  Several places must have exact agreement on
comment|// what the reprobe_limit is, so we share it here.
DECL|method|reprobe_limit
specifier|private
specifier|static
specifier|final
name|int
name|reprobe_limit
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|REPROBE_LIMIT
operator|+
operator|(
name|len
operator|>>
literal|2
operator|)
return|;
block|}
comment|// --- NonBlockingHashMapLong ----------------------------------------------
comment|// Constructors
comment|/**      * Create a new NonBlockingHashMapLong with default minimum size (currently set      * to 8 K/V pairs or roughly 84 bytes on a standard 32-bit JVM).      */
DECL|method|NonBlockingHashMapLong
specifier|public
name|NonBlockingHashMapLong
parameter_list|()
block|{
name|this
argument_list|(
name|MIN_SIZE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new NonBlockingHashMapLong with initial room for the given      * number of elements, thus avoiding internal resizing operations to reach      * an appropriate size.  Large numbers here when used with a small count of      * elements will sacrifice space for a small amount of time gained.  The      * initial size will be rounded up internally to the next larger power of 2.      */
DECL|method|NonBlockingHashMapLong
specifier|public
name|NonBlockingHashMapLong
parameter_list|(
specifier|final
name|int
name|initial_sz
parameter_list|)
block|{
name|this
argument_list|(
name|initial_sz
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new NonBlockingHashMapLong, setting the space-for-speed      * tradeoff.  {@code true} optimizes for space and is the default.  {@code      * false} optimizes for speed and doubles space costs for roughly a 10%      * speed improvement.      */
DECL|method|NonBlockingHashMapLong
specifier|public
name|NonBlockingHashMapLong
parameter_list|(
specifier|final
name|boolean
name|opt_for_space
parameter_list|)
block|{
name|this
argument_list|(
literal|1
argument_list|,
name|opt_for_space
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create a new NonBlockingHashMapLong, setting both the initial size and      * the space-for-speed tradeoff.  {@code true} optimizes for space and is      * the default.  {@code false} optimizes for speed and doubles space costs      * for roughly a 10% speed improvement.      */
DECL|method|NonBlockingHashMapLong
specifier|public
name|NonBlockingHashMapLong
parameter_list|(
specifier|final
name|int
name|initial_sz
parameter_list|,
specifier|final
name|boolean
name|opt_for_space
parameter_list|)
block|{
name|_opt_for_space
operator|=
name|opt_for_space
expr_stmt|;
name|initialize
argument_list|(
name|initial_sz
argument_list|)
expr_stmt|;
block|}
DECL|method|initialize
specifier|private
specifier|final
name|void
name|initialize
parameter_list|(
specifier|final
name|int
name|initial_sz
parameter_list|)
block|{
if|if
condition|(
name|initial_sz
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|int
name|i
decl_stmt|;
comment|// Convert to next largest power-of-2
for|for
control|(
name|i
operator|=
name|MIN_SIZE_LOG
init|;
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<
name|initial_sz
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|_chm
operator|=
operator|new
name|CHM
argument_list|(
name|this
argument_list|,
operator|new
name|Counter
argument_list|()
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|_val_1
operator|=
name|TOMBSTONE
expr_stmt|;
comment|// Always as-if deleted
name|_last_resize_milli
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
comment|// --- wrappers ------------------------------------------------------------
comment|/**      * Returns the number of key-value mappings in this map.      *      * @return the number of key-value mappings in this map      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
operator|(
name|_val_1
operator|==
name|TOMBSTONE
condition|?
literal|0
else|:
literal|1
operator|)
operator|+
operator|(
name|int
operator|)
name|_chm
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**      * Tests if the key in the table.      *      * @return<tt>true</tt> if the key is in the table      */
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|long
name|key
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Legacy method testing if some key maps into the specified value in this      * table.  This method is identical in functionality to {@link      * #containsValue}, and exists solely to ensure full compatibility with      * class {@link java.util.Hashtable}, which supported this method prior to      * introduction of the Java Collections framework.      *      * @param val a value to search for      * @return<tt>true</tt> if this map maps one or more keys to the specified value      * @throws NullPointerException if the specified value is null      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|val
parameter_list|)
block|{
return|return
name|containsValue
argument_list|(
name|val
argument_list|)
return|;
block|}
comment|/**      * Maps the specified key to the specified value in the table.  The value      * cannot be null.<p> The value can be retrieved by calling {@link #get}      * with a key that is equal to the original key.      *      * @param key key with which the specified value is to be associated      * @param val value to be associated with the specified key      * @return the previous value associated with<tt>key</tt>, or      *<tt>null</tt> if there was no mapping for<tt>key</tt>      * @throws NullPointerException if the specified value is null      */
DECL|method|put
specifier|public
name|TypeV
name|put
parameter_list|(
name|long
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|NO_MATCH_OLD
argument_list|)
return|;
block|}
comment|/**      * Atomically, do a {@link #put} if-and-only-if the key is not mapped.      * Useful to ensure that only a single mapping for the key exists, even if      * many threads are trying to create the mapping in parallel.      *      * @return the previous value associated with the specified key,      *         or<tt>null</tt> if there was no mapping for the key      * @throws NullPointerException if the specified is value is null      */
DECL|method|putIfAbsent
specifier|public
name|TypeV
name|putIfAbsent
parameter_list|(
name|long
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|TOMBSTONE
argument_list|)
return|;
block|}
comment|/**      * Removes the key (and its corresponding value) from this map.      * This method does nothing if the key is not in the map.      *      * @return the previous value associated with<tt>key</tt>, or      *<tt>null</tt> if there was no mapping for<tt>key</tt>      */
DECL|method|remove
specifier|public
name|TypeV
name|remove
parameter_list|(
name|long
name|key
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|TOMBSTONE
argument_list|,
name|NO_MATCH_OLD
argument_list|)
return|;
block|}
comment|/**      * Atomically do a {@link #remove(long)} if-and-only-if the key is mapped      * to a value which is<code>equals</code> to the given value.      *      * @throws NullPointerException if the specified value is null      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|long
name|key
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|TOMBSTONE
argument_list|,
name|val
argument_list|)
operator|==
name|val
return|;
block|}
comment|/**      * Atomically do a<code>put(key,val)</code> if-and-only-if the key is      * mapped to some value already.      *      * @throws NullPointerException if the specified value is null      */
DECL|method|replace
specifier|public
name|TypeV
name|replace
parameter_list|(
name|long
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|val
argument_list|,
name|MATCH_ANY
argument_list|)
return|;
block|}
comment|/**      * Atomically do a<code>put(key,newValue)</code> if-and-only-if the key is      * mapped a value which is<code>equals</code> to<code>oldValue</code>.      *      * @throws NullPointerException if the specified value is null      */
DECL|method|replace
specifier|public
name|boolean
name|replace
parameter_list|(
name|long
name|key
parameter_list|,
name|TypeV
name|oldValue
parameter_list|,
name|TypeV
name|newValue
parameter_list|)
block|{
return|return
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|,
name|oldValue
argument_list|)
operator|==
name|oldValue
return|;
block|}
DECL|method|putIfMatch
specifier|private
specifier|final
name|TypeV
name|putIfMatch
parameter_list|(
name|long
name|key
parameter_list|,
name|Object
name|newVal
parameter_list|,
name|Object
name|oldVal
parameter_list|)
block|{
if|if
condition|(
name|oldVal
operator|==
literal|null
operator|||
name|newVal
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|key
operator|==
name|NO_KEY
condition|)
block|{
specifier|final
name|Object
name|curVal
init|=
name|_val_1
decl_stmt|;
if|if
condition|(
name|oldVal
operator|==
name|NO_MATCH_OLD
operator|||
comment|// Do we care about expected-Value at all?
name|curVal
operator|==
name|oldVal
operator|||
comment|// No instant match already?
operator|(
name|oldVal
operator|==
name|MATCH_ANY
operator|&&
name|curVal
operator|!=
name|TOMBSTONE
operator|)
operator|||
name|oldVal
operator|.
name|equals
argument_list|(
name|curVal
argument_list|)
condition|)
comment|// Expensive equals check
name|CAS
argument_list|(
name|_val_1_offset
argument_list|,
name|curVal
argument_list|,
name|newVal
argument_list|)
expr_stmt|;
comment|// One shot CAS update attempt
return|return
name|curVal
operator|==
name|TOMBSTONE
condition|?
literal|null
else|:
operator|(
name|TypeV
operator|)
name|curVal
return|;
comment|// Return the last value present
block|}
specifier|final
name|Object
name|res
init|=
name|_chm
operator|.
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|newVal
argument_list|,
name|oldVal
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|res
operator|instanceof
name|Prime
operator|)
assert|;
assert|assert
name|res
operator|!=
literal|null
assert|;
return|return
name|res
operator|==
name|TOMBSTONE
condition|?
literal|null
else|:
operator|(
name|TypeV
operator|)
name|res
return|;
block|}
comment|/**      * Removes all of the mappings from this map.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
comment|// Smack a new empty table down
name|CHM
name|newchm
init|=
operator|new
name|CHM
argument_list|(
name|this
argument_list|,
operator|new
name|Counter
argument_list|()
argument_list|,
name|MIN_SIZE_LOG
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|CAS
argument_list|(
name|_chm_offset
argument_list|,
name|_chm
argument_list|,
name|newchm
argument_list|)
condition|)
comment|// Spin until the clear works
empty_stmt|;
name|CAS
argument_list|(
name|_val_1_offset
argument_list|,
name|_val_1
argument_list|,
name|TOMBSTONE
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<tt>true</tt> if this Map maps one or more keys to the specified      * value.<em>Note</em>: This method requires a full internal traversal of the      * hash table and is much slower than {@link #containsKey}.      *      * @param val value whose presence in this map is to be tested      * @return<tt>true</tt> if this Map maps one or more keys to the specified value      * @throws NullPointerException if the specified value is null      */
DECL|method|containsValue
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|val
operator|==
name|_val_1
condition|)
return|return
literal|true
return|;
comment|// Key 0
for|for
control|(
name|TypeV
name|V
range|:
name|values
argument_list|()
control|)
if|if
condition|(
name|V
operator|==
name|val
operator|||
name|V
operator|.
name|equals
argument_list|(
name|val
argument_list|)
condition|)
return|return
literal|true
return|;
return|return
literal|false
return|;
block|}
comment|// --- get -----------------------------------------------------------------
comment|/**      * Returns the value to which the specified key is mapped, or {@code null}      * if this map contains no mapping for the key.      *<p>More formally, if this map contains a mapping from a key {@code k} to      * a value {@code v} such that {@code key==k}, then this method      * returns {@code v}; otherwise it returns {@code null}.  (There can be at      * most one such mapping.)      *      * @throws NullPointerException if the specified key is null      */
comment|// Never returns a Prime nor a Tombstone.
DECL|method|get
specifier|public
specifier|final
name|TypeV
name|get
parameter_list|(
name|long
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
name|NO_KEY
condition|)
block|{
specifier|final
name|Object
name|V
init|=
name|_val_1
decl_stmt|;
return|return
name|V
operator|==
name|TOMBSTONE
condition|?
literal|null
else|:
operator|(
name|TypeV
operator|)
name|V
return|;
block|}
specifier|final
name|Object
name|V
init|=
name|_chm
operator|.
name|get_impl
argument_list|(
name|key
argument_list|)
decl_stmt|;
assert|assert
operator|!
operator|(
name|V
operator|instanceof
name|Prime
operator|)
assert|;
comment|// Never return a Prime
assert|assert
name|V
operator|!=
name|TOMBSTONE
assert|;
return|return
operator|(
name|TypeV
operator|)
name|V
return|;
block|}
comment|/**      * Auto-boxing version of {@link #get(long)}.      */
DECL|method|get
specifier|public
name|TypeV
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
operator|(
name|key
operator|instanceof
name|Long
operator|)
condition|?
name|get
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|key
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**      * Auto-boxing version of {@link #remove(long)}.      */
DECL|method|remove
specifier|public
name|TypeV
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
operator|(
name|key
operator|instanceof
name|Long
operator|)
condition|?
name|remove
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|key
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
else|:
literal|null
return|;
block|}
comment|/**      * Auto-boxing version of {@link #remove(long,Object)}.      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|Val
parameter_list|)
block|{
return|return
operator|(
name|key
operator|instanceof
name|Long
operator|)
condition|?
name|remove
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|key
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|Val
argument_list|)
else|:
literal|false
return|;
block|}
comment|/**      * Auto-boxing version of {@link #containsKey(long)}.      */
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
operator|(
name|key
operator|instanceof
name|Long
operator|)
condition|?
name|containsKey
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|key
operator|)
operator|.
name|longValue
argument_list|()
argument_list|)
else|:
literal|false
return|;
block|}
comment|/**      * Auto-boxing version of {@link #putIfAbsent}.      */
DECL|method|putIfAbsent
specifier|public
name|TypeV
name|putIfAbsent
parameter_list|(
name|Long
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|putIfAbsent
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|key
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/**      * Auto-boxing version of {@link #replace}.      */
DECL|method|replace
specifier|public
name|TypeV
name|replace
parameter_list|(
name|Long
name|key
parameter_list|,
name|TypeV
name|Val
parameter_list|)
block|{
return|return
name|replace
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|key
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|Val
argument_list|)
return|;
block|}
comment|/**      * Auto-boxing version of {@link #put}.      */
DECL|method|put
specifier|public
name|TypeV
name|put
parameter_list|(
name|Long
name|key
parameter_list|,
name|TypeV
name|val
parameter_list|)
block|{
return|return
name|put
argument_list|(
name|key
operator|.
name|longValue
argument_list|()
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/**      * Auto-boxing version of {@link #replace}.      */
DECL|method|replace
specifier|public
name|boolean
name|replace
parameter_list|(
name|Long
name|key
parameter_list|,
name|TypeV
name|oldValue
parameter_list|,
name|TypeV
name|newValue
parameter_list|)
block|{
return|return
name|replace
argument_list|(
operator|(
operator|(
name|Long
operator|)
name|key
operator|)
operator|.
name|longValue
argument_list|()
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
comment|// --- help_copy -----------------------------------------------------------
comment|// Help along an existing resize operation.  This is just a fast cut-out
comment|// wrapper, to encourage inlining for the fast no-copy-in-progress case.  We
comment|// always help the top-most table copy, even if there are nested table
comment|// copies in progress.
DECL|method|help_copy
specifier|private
specifier|final
name|void
name|help_copy
parameter_list|()
block|{
comment|// Read the top-level CHM only once.  We'll try to help this copy along,
comment|// even if it gets promoted out from under us (i.e., the copy completes
comment|// and another KVS becomes the top-level copy).
name|CHM
name|topchm
init|=
name|_chm
decl_stmt|;
if|if
condition|(
name|topchm
operator|.
name|_newchm
operator|==
literal|null
condition|)
return|return;
comment|// No copy in-progress
name|topchm
operator|.
name|help_copy_impl
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// --- CHM -----------------------------------------------------------------
comment|// The control structure for the NonBlockingHashMapLong
DECL|class|CHM
specifier|private
specifier|static
specifier|final
class|class
name|CHM
parameter_list|<
name|TypeV
parameter_list|>
implements|implements
name|Serializable
block|{
comment|// Back-pointer to top-level structure
DECL|field|_nbhml
specifier|final
name|NonBlockingHashMapLong
name|_nbhml
decl_stmt|;
comment|// Size in active K,V pairs
DECL|field|_size
specifier|private
specifier|final
name|Counter
name|_size
decl_stmt|;
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|_size
operator|.
name|get
argument_list|()
return|;
block|}
comment|// ---
comment|// These next 2 fields are used in the resizing heuristics, to judge when
comment|// it is time to resize or copy the table.  Slots is a count of used-up
comment|// key slots, and when it nears a large fraction of the table we probably
comment|// end up reprobing too much.  Last-resize-milli is the time since the
comment|// last resize; if we are running back-to-back resizes without growing
comment|// (because there are only a few live keys but many slots full of dead
comment|// keys) then we need a larger table to cut down on the churn.
comment|// Count of used slots, to tell when table is full of dead unusable slots
DECL|field|_slots
specifier|private
specifier|final
name|Counter
name|_slots
decl_stmt|;
DECL|method|slots
specifier|public
name|int
name|slots
parameter_list|()
block|{
return|return
operator|(
name|int
operator|)
name|_slots
operator|.
name|get
argument_list|()
return|;
block|}
comment|// ---
comment|// New mappings, used during resizing.
comment|// The 'next' CHM - created during a resize operation.  This represents
comment|// the new table being copied from the old one.  It's the volatile
comment|// variable that is read as we cross from one table to the next, to get
comment|// the required memory orderings.  It monotonically transits from null to
comment|// set (once).
DECL|field|_newchm
specifier|volatile
name|CHM
name|_newchm
decl_stmt|;
DECL|field|_newchmUpdater
specifier|private
specifier|static
specifier|final
name|AtomicReferenceFieldUpdater
argument_list|<
name|CHM
argument_list|,
name|CHM
argument_list|>
name|_newchmUpdater
init|=
name|AtomicReferenceFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
name|CHM
operator|.
name|class
argument_list|,
literal|"_newchm"
argument_list|)
decl_stmt|;
comment|// Set the _newchm field if we can.  AtomicUpdaters do not fail spuriously.
DECL|method|CAS_newchm
name|boolean
name|CAS_newchm
parameter_list|(
name|CHM
name|newchm
parameter_list|)
block|{
return|return
name|_newchmUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|newchm
argument_list|)
return|;
block|}
comment|// Sometimes many threads race to create a new very large table.  Only 1
comment|// wins the race, but the losers all allocate a junk large table with
comment|// hefty allocation costs.  Attempt to control the overkill here by
comment|// throttling attempts to create a new table.  I cannot really block here
comment|// (lest I lose the non-blocking property) but late-arriving threads can
comment|// give the initial resizing thread a little time to allocate the initial
comment|// new table.  The Right Long Term Fix here is to use array-lets and
comment|// incrementally create the new very large array.  In C I'd make the array
comment|// with malloc (which would mmap under the hood) which would only eat
comment|// virtual-address and not real memory - and after Somebody wins then we
comment|// could in parallel initialize the array.  Java does not allow
comment|// un-initialized array creation (especially of ref arrays!).
DECL|field|_resizers
specifier|volatile
name|long
name|_resizers
decl_stmt|;
comment|// count of threads attempting an initial resize
DECL|field|_resizerUpdater
specifier|private
specifier|static
specifier|final
name|AtomicLongFieldUpdater
argument_list|<
name|CHM
argument_list|>
name|_resizerUpdater
init|=
name|AtomicLongFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
literal|"_resizers"
argument_list|)
decl_stmt|;
comment|// --- key,val -------------------------------------------------------------
comment|// Access K,V for a given idx
DECL|method|CAS_key
specifier|private
specifier|final
name|boolean
name|CAS_key
parameter_list|(
name|int
name|idx
parameter_list|,
name|long
name|old
parameter_list|,
name|long
name|key
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapLong
argument_list|(
name|_keys
argument_list|,
name|rawIndex
argument_list|(
name|_keys
argument_list|,
name|idx
argument_list|)
argument_list|,
name|old
argument_list|,
name|key
argument_list|)
return|;
block|}
DECL|method|CAS_val
specifier|private
specifier|final
name|boolean
name|CAS_val
parameter_list|(
name|int
name|idx
parameter_list|,
name|Object
name|old
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
return|return
name|_unsafe
operator|.
name|compareAndSwapObject
argument_list|(
name|_vals
argument_list|,
name|rawIndex
argument_list|(
name|_vals
argument_list|,
name|idx
argument_list|)
argument_list|,
name|old
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|field|_keys
specifier|final
name|long
index|[]
name|_keys
decl_stmt|;
DECL|field|_vals
specifier|final
name|Object
index|[]
name|_vals
decl_stmt|;
comment|// Simple constructor
DECL|method|CHM
name|CHM
parameter_list|(
specifier|final
name|NonBlockingHashMapLong
name|nbhml
parameter_list|,
name|Counter
name|size
parameter_list|,
specifier|final
name|int
name|logsize
parameter_list|)
block|{
name|_nbhml
operator|=
name|nbhml
expr_stmt|;
name|_size
operator|=
name|size
expr_stmt|;
name|_slots
operator|=
operator|new
name|Counter
argument_list|()
expr_stmt|;
name|_keys
operator|=
operator|new
name|long
index|[
literal|1
operator|<<
name|logsize
index|]
expr_stmt|;
name|_vals
operator|=
operator|new
name|Object
index|[
literal|1
operator|<<
name|logsize
index|]
expr_stmt|;
block|}
comment|// --- print innards
DECL|method|print
specifier|private
specifier|final
name|void
name|print
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_keys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|K
init|=
name|_keys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|K
operator|!=
name|NO_KEY
condition|)
name|print_impl
argument_list|(
name|i
argument_list|,
name|K
argument_list|,
name|_vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|CHM
name|newchm
init|=
name|_newchm
decl_stmt|;
comment|// New table, if any
if|if
condition|(
name|newchm
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"----"
argument_list|)
expr_stmt|;
name|newchm
operator|.
name|print
argument_list|()
expr_stmt|;
block|}
block|}
comment|// --- print only the live objects
DECL|method|print2
specifier|private
specifier|final
name|void
name|print2
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|_keys
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|long
name|K
init|=
name|_keys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|K
operator|!=
name|NO_KEY
condition|)
comment|// key is sane
name|print2_impl
argument_list|(
name|i
argument_list|,
name|K
argument_list|,
name|_vals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|CHM
name|newchm
init|=
name|_newchm
decl_stmt|;
comment|// New table, if any
if|if
condition|(
name|newchm
operator|!=
literal|null
condition|)
block|{
name|System
operator|.
name|out
operator|.
name|println
argument_list|(
literal|"----"
argument_list|)
expr_stmt|;
name|newchm
operator|.
name|print2
argument_list|()
expr_stmt|;
block|}
block|}
comment|// --- get_impl ----------------------------------------------------------
comment|// Never returns a Prime nor a Tombstone.
DECL|method|get_impl
specifier|private
specifier|final
name|Object
name|get_impl
parameter_list|(
specifier|final
name|long
name|key
parameter_list|)
block|{
specifier|final
name|int
name|len
init|=
name|_keys
operator|.
name|length
decl_stmt|;
name|int
name|idx
init|=
call|(
name|int
call|)
argument_list|(
name|key
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
comment|// First key hash
comment|// Main spin/reprobe loop, looking for a Key hit
name|int
name|reprobe_cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|long
name|K
init|=
name|_keys
index|[
name|idx
index|]
decl_stmt|;
comment|// Get key   before volatile read, could be NO_KEY
specifier|final
name|Object
name|V
init|=
name|_vals
index|[
name|idx
index|]
decl_stmt|;
comment|// Get value before volatile read, could be null or Tombstone or Prime
if|if
condition|(
name|K
operator|==
name|NO_KEY
condition|)
return|return
literal|null
return|;
comment|// A clear miss
comment|// Key-compare
if|if
condition|(
name|key
operator|==
name|K
condition|)
block|{
comment|// Key hit!  Check for no table-copy-in-progress
if|if
condition|(
operator|!
operator|(
name|V
operator|instanceof
name|Prime
operator|)
condition|)
block|{
comment|// No copy?
if|if
condition|(
name|V
operator|==
name|TOMBSTONE
condition|)
return|return
literal|null
return|;
comment|// We need a volatile-read between reading a newly inserted Value
comment|// and returning the Value (so the user might end up reading the
comment|// stale Value contents).
specifier|final
name|CHM
name|newchm
init|=
name|_newchm
decl_stmt|;
comment|// VOLATILE READ before returning V
return|return
name|V
return|;
block|}
comment|// Key hit - but slot is (possibly partially) copied to the new table.
comment|// Finish the copy& retry in the new table.
return|return
name|copy_slot_and_check
argument_list|(
name|idx
argument_list|,
name|key
argument_list|)
operator|.
name|get_impl
argument_list|(
name|key
argument_list|)
return|;
comment|// Retry in the new table
block|}
comment|// get and put must have the same key lookup logic!  But only 'put'
comment|// needs to force a table-resize for a too-long key-reprobe sequence.
comment|// Check for too-many-reprobes on get.
if|if
condition|(
operator|++
name|reprobe_cnt
operator|>=
name|reprobe_limit
argument_list|(
name|len
argument_list|)
condition|)
comment|// too many probes
return|return
name|_newchm
operator|==
literal|null
comment|// Table copy in progress?
condition|?
literal|null
comment|// Nope!  A clear miss
else|:
name|copy_slot_and_check
argument_list|(
name|idx
argument_list|,
name|key
argument_list|)
operator|.
name|get_impl
argument_list|(
name|key
argument_list|)
return|;
comment|// Retry in the new table
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
comment|// Reprobe by 1!  (could now prefetch)
block|}
block|}
comment|// --- putIfMatch ---------------------------------------------------------
comment|// Put, Remove, PutIfAbsent, etc.  Return the old value.  If the returned
comment|// value is equal to expVal (or expVal is NO_MATCH_OLD) then the put can
comment|// be assumed to work (although might have been immediately overwritten).
comment|// Only the path through copy_slot passes in an expected value of null,
comment|// and putIfMatch only returns a null if passed in an expected null.
DECL|method|putIfMatch
specifier|private
specifier|final
name|Object
name|putIfMatch
parameter_list|(
specifier|final
name|long
name|key
parameter_list|,
specifier|final
name|Object
name|putval
parameter_list|,
specifier|final
name|Object
name|expVal
parameter_list|)
block|{
assert|assert
name|putval
operator|!=
literal|null
assert|;
assert|assert
operator|!
operator|(
name|putval
operator|instanceof
name|Prime
operator|)
assert|;
assert|assert
operator|!
operator|(
name|expVal
operator|instanceof
name|Prime
operator|)
assert|;
specifier|final
name|int
name|len
init|=
name|_keys
operator|.
name|length
decl_stmt|;
name|int
name|idx
init|=
call|(
name|int
call|)
argument_list|(
name|key
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
argument_list|)
decl_stmt|;
comment|// The first key
comment|// ---
comment|// Key-Claim stanza: spin till we can claim a Key (or force a resizing).
name|int
name|reprobe_cnt
init|=
literal|0
decl_stmt|;
name|long
name|K
init|=
name|NO_KEY
decl_stmt|;
name|Object
name|V
init|=
literal|null
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Spin till we get a Key slot
name|V
operator|=
name|_vals
index|[
name|idx
index|]
expr_stmt|;
comment|// Get old value
name|K
operator|=
name|_keys
index|[
name|idx
index|]
expr_stmt|;
comment|// Get current key
if|if
condition|(
name|K
operator|==
name|NO_KEY
condition|)
block|{
comment|// Slot is free?
comment|// Found an empty Key slot - which means this Key has never been in
comment|// this table.  No need to put a Tombstone - the Key is not here!
if|if
condition|(
name|putval
operator|==
name|TOMBSTONE
condition|)
return|return
name|putval
return|;
comment|// Not-now& never-been in this table
comment|// Claim the zero key-slot
if|if
condition|(
name|CAS_key
argument_list|(
name|idx
argument_list|,
name|NO_KEY
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|// Claim slot for Key
name|_slots
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Raise key-slots-used count
break|break;
comment|// Got it!
block|}
comment|// CAS to claim the key-slot failed.
comment|//
comment|// This re-read of the Key points out an annoying short-coming of Java
comment|// CAS.  Most hardware CAS's report back the existing value - so that
comment|// if you fail you have a *witness* - the value which caused the CAS
comment|// to fail.  The Java API turns this into a boolean destroying the
comment|// witness.  Re-reading does not recover the witness because another
comment|// thread can write over the memory after the CAS.  Hence we can be in
comment|// the unfortunate situation of having a CAS fail *for cause* but
comment|// having that cause removed by a later store.  This turns a
comment|// non-spurious-failure CAS (such as Azul has) into one that can
comment|// apparently spuriously fail - and we avoid apparent spurious failure
comment|// by not allowing Keys to ever change.
name|K
operator|=
name|_keys
index|[
name|idx
index|]
expr_stmt|;
comment|// CAS failed, get updated value
assert|assert
name|K
operator|!=
name|NO_KEY
assert|;
comment|// If keys[idx] is NO_KEY, CAS shoulda worked
block|}
comment|// Key slot was not null, there exists a Key here
if|if
condition|(
name|K
operator|==
name|key
condition|)
break|break;
comment|// Got it!
comment|// get and put must have the same key lookup logic!  Lest 'get' give
comment|// up looking too soon.
comment|//topmap._reprobes.add(1);
if|if
condition|(
operator|++
name|reprobe_cnt
operator|>=
name|reprobe_limit
argument_list|(
name|len
argument_list|)
condition|)
block|{
comment|// We simply must have a new table to do a 'put'.  At this point a
comment|// 'get' will also go to the new table (if any).  We do not need
comment|// to claim a key slot (indeed, we cannot find a free one to claim!).
specifier|final
name|CHM
name|newchm
init|=
name|resize
argument_list|()
decl_stmt|;
if|if
condition|(
name|expVal
operator|!=
literal|null
condition|)
name|_nbhml
operator|.
name|help_copy
argument_list|()
expr_stmt|;
comment|// help along an existing copy
return|return
name|newchm
operator|.
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|putval
argument_list|,
name|expVal
argument_list|)
return|;
block|}
name|idx
operator|=
operator|(
name|idx
operator|+
literal|1
operator|)
operator|&
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
comment|// Reprobe!
block|}
comment|// End of spinning till we get a Key slot
comment|// ---
comment|// Found the proper Key slot, now update the matching Value slot.  We
comment|// never put a null, so Value slots monotonically move from null to
comment|// not-null (deleted Values use Tombstone).  Thus if 'V' is null we
comment|// fail this fast cutout and fall into the check for table-full.
if|if
condition|(
name|putval
operator|==
name|V
condition|)
return|return
name|V
return|;
comment|// Fast cutout for no-change
comment|// See if we want to move to a new table (to avoid high average re-probe
comment|// counts).  We only check on the initial set of a Value from null to
comment|// not-null (i.e., once per key-insert).
if|if
condition|(
operator|(
name|V
operator|==
literal|null
operator|&&
name|tableFull
argument_list|(
name|reprobe_cnt
argument_list|,
name|len
argument_list|)
operator|)
operator|||
comment|// Or we found a Prime: resize is already in progress.  The resize
comment|// call below will do a CAS on _newchm forcing the read.
name|V
operator|instanceof
name|Prime
condition|)
block|{
name|resize
argument_list|()
expr_stmt|;
comment|// Force the new table copy to start
return|return
name|copy_slot_and_check
argument_list|(
name|idx
argument_list|,
name|expVal
argument_list|)
operator|.
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|putval
argument_list|,
name|expVal
argument_list|)
return|;
block|}
comment|// ---
comment|// We are finally prepared to update the existing table
while|while
condition|(
literal|true
condition|)
block|{
assert|assert
operator|!
operator|(
name|V
operator|instanceof
name|Prime
operator|)
assert|;
comment|// Must match old, and we do not?  Then bail out now.  Note that either V
comment|// or expVal might be TOMBSTONE.  Also V can be null, if we've never
comment|// inserted a value before.  expVal can be null if we are called from
comment|// copy_slot.
if|if
condition|(
name|expVal
operator|!=
name|NO_MATCH_OLD
operator|&&
comment|// Do we care about expected-Value at all?
name|V
operator|!=
name|expVal
operator|&&
comment|// No instant match already?
operator|(
name|expVal
operator|!=
name|MATCH_ANY
operator|||
name|V
operator|==
name|TOMBSTONE
operator|||
name|V
operator|==
literal|null
operator|)
operator|&&
operator|!
operator|(
name|V
operator|==
literal|null
operator|&&
name|expVal
operator|==
name|TOMBSTONE
operator|)
operator|&&
comment|// Match on null/TOMBSTONE combo
operator|(
name|expVal
operator|==
literal|null
operator|||
operator|!
name|expVal
operator|.
name|equals
argument_list|(
name|V
argument_list|)
operator|)
condition|)
comment|// Expensive equals check at the last
return|return
name|V
return|;
comment|// Do not update!
comment|// Actually change the Value in the Key,Value pair
if|if
condition|(
name|CAS_val
argument_list|(
name|idx
argument_list|,
name|V
argument_list|,
name|putval
argument_list|)
condition|)
block|{
comment|// CAS succeeded - we did the update!
comment|// Both normal put's and table-copy calls putIfMatch, but table-copy
comment|// does not (effectively) increase the number of live k/v pairs.
if|if
condition|(
name|expVal
operator|!=
literal|null
condition|)
block|{
comment|// Adjust sizes - a striped counter
if|if
condition|(
operator|(
name|V
operator|==
literal|null
operator|||
name|V
operator|==
name|TOMBSTONE
operator|)
operator|&&
name|putval
operator|!=
name|TOMBSTONE
condition|)
name|_size
operator|.
name|add
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|V
operator|==
literal|null
operator|||
name|V
operator|==
name|TOMBSTONE
operator|)
operator|&&
name|putval
operator|==
name|TOMBSTONE
condition|)
name|_size
operator|.
name|add
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|V
operator|==
literal|null
operator|&&
name|expVal
operator|!=
literal|null
operator|)
condition|?
name|TOMBSTONE
else|:
name|V
return|;
block|}
comment|// Else CAS failed
name|V
operator|=
name|_vals
index|[
name|idx
index|]
expr_stmt|;
comment|// Get new value
comment|// If a Prime'd value got installed, we need to re-run the put on the
comment|// new table.  Otherwise we lost the CAS to another racing put.
comment|// Simply retry from the start.
if|if
condition|(
name|V
operator|instanceof
name|Prime
condition|)
return|return
name|copy_slot_and_check
argument_list|(
name|idx
argument_list|,
name|expVal
argument_list|)
operator|.
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|putval
argument_list|,
name|expVal
argument_list|)
return|;
block|}
block|}
comment|// --- tableFull ---------------------------------------------------------
comment|// Heuristic to decide if this table is too full, and we should start a
comment|// new table.  Note that if a 'get' call has reprobed too many times and
comment|// decided the table must be full, then always the estimate_sum must be
comment|// high and we must report the table is full.  If we do not, then we might
comment|// end up deciding that the table is not full and inserting into the
comment|// current table, while a 'get' has decided the same key cannot be in this
comment|// table because of too many reprobes.  The invariant is:
comment|//   slots.estimate_sum>= max_reprobe_cnt>= reprobe_limit(len)
DECL|method|tableFull
specifier|private
specifier|final
name|boolean
name|tableFull
parameter_list|(
name|int
name|reprobe_cnt
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
comment|// Do the cheap check first: we allow some number of reprobes always
name|reprobe_cnt
operator|>=
name|REPROBE_LIMIT
operator|&&
comment|// More expensive check: see if the table is> 1/4 full.
name|_slots
operator|.
name|estimate_get
argument_list|()
operator|>=
name|reprobe_limit
argument_list|(
name|len
argument_list|)
return|;
block|}
comment|// --- resize ------------------------------------------------------------
comment|// Resizing after too many probes.  "How Big???" heuristics are here.
comment|// Callers will (not this routine) will 'help_copy' any in-progress copy.
comment|// Since this routine has a fast cutout for copy-already-started, callers
comment|// MUST 'help_copy' lest we have a path which forever runs through
comment|// 'resize' only to discover a copy-in-progress which never progresses.
DECL|method|resize
specifier|private
specifier|final
name|CHM
name|resize
parameter_list|()
block|{
comment|// Check for resize already in progress, probably triggered by another thread
name|CHM
name|newchm
init|=
name|_newchm
decl_stmt|;
comment|// VOLATILE READ
if|if
condition|(
name|newchm
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|newchm
return|;
comment|// Use the new table already
comment|// No copy in-progress, so start one.  First up: compute new table size.
name|int
name|oldlen
init|=
name|_keys
operator|.
name|length
decl_stmt|;
comment|// Old count of K,V pairs allowed
name|int
name|sz
init|=
name|size
argument_list|()
decl_stmt|;
comment|// Get current table count of active K,V pairs
name|int
name|newsz
init|=
name|sz
decl_stmt|;
comment|// First size estimate
comment|// Heuristic to determine new size.  We expect plenty of dead-slots-with-keys
comment|// and we need some decent padding to avoid endless reprobing.
if|if
condition|(
name|_nbhml
operator|.
name|_opt_for_space
condition|)
block|{
comment|// This heuristic leads to a much denser table with a higher reprobe rate
if|if
condition|(
name|sz
operator|>=
operator|(
name|oldlen
operator|>>
literal|1
operator|)
condition|)
comment|// If we are>50% full of keys then...
name|newsz
operator|=
name|oldlen
operator|<<
literal|1
expr_stmt|;
comment|// Double size
block|}
else|else
block|{
if|if
condition|(
name|sz
operator|>=
operator|(
name|oldlen
operator|>>
literal|2
operator|)
condition|)
block|{
comment|// If we are>25% full of keys then...
name|newsz
operator|=
name|oldlen
operator|<<
literal|1
expr_stmt|;
comment|// Double size
if|if
condition|(
name|sz
operator|>=
operator|(
name|oldlen
operator|>>
literal|1
operator|)
condition|)
comment|// If we are>50% full of keys then...
name|newsz
operator|=
name|oldlen
operator|<<
literal|2
expr_stmt|;
comment|// Double double size
block|}
block|}
comment|// Last (re)size operation was very recent?  Then double again; slows
comment|// down resize operations for tables subject to a high key churn rate.
name|long
name|tm
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|long
name|q
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|newsz
operator|<=
name|oldlen
operator|&&
comment|// New table would shrink or hold steady?
name|tm
operator|<=
name|_nbhml
operator|.
name|_last_resize_milli
operator|+
literal|10000
operator|&&
comment|// Recent resize (less than 1 sec ago)
comment|//(q=_slots.estimate_sum())>= (sz<<1) ) // 1/2 of keys are dead?
literal|true
condition|)
name|newsz
operator|=
name|oldlen
operator|<<
literal|1
expr_stmt|;
comment|// Double the existing size
comment|// Do not shrink, ever
if|if
condition|(
name|newsz
operator|<
name|oldlen
condition|)
name|newsz
operator|=
name|oldlen
expr_stmt|;
comment|//System.out.println("old="+oldlen+" new="+newsz+" size()="+sz+" est_slots()="+q+" millis="+(tm-_nbhml._last_resize_milli));
comment|// Convert to power-of-2
name|int
name|log2
decl_stmt|;
for|for
control|(
name|log2
operator|=
name|MIN_SIZE_LOG
init|;
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|<
name|newsz
condition|;
name|log2
operator|++
control|)
empty_stmt|;
comment|// Compute log2 of size
comment|// Now limit the number of threads actually allocating memory to a
comment|// handful - lest we have 750 threads all trying to allocate a giant
comment|// resized array.
name|long
name|r
init|=
name|_resizers
decl_stmt|;
while|while
condition|(
operator|!
name|_resizerUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|r
argument_list|,
name|r
operator|+
literal|1
argument_list|)
condition|)
name|r
operator|=
name|_resizers
expr_stmt|;
comment|// Size calculation: 2 words (K+V) per table entry, plus a handful.  We
comment|// guess at 32-bit pointers; 64-bit pointers screws up the size calc by
comment|// 2x but does not screw up the heuristic very much.
name|int
name|megs
init|=
operator|(
operator|(
operator|(
operator|(
literal|1
operator|<<
name|log2
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|4
operator|)
operator|<<
literal|3
comment|/*word to bytes*/
operator|)
operator|>>
literal|20
comment|/*megs*/
decl_stmt|;
if|if
condition|(
name|r
operator|>=
literal|2
operator|&&
name|megs
operator|>
literal|0
condition|)
block|{
comment|// Already 2 guys trying; wait and see
name|newchm
operator|=
name|_newchm
expr_stmt|;
comment|// Between dorking around, another thread did it
if|if
condition|(
name|newchm
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|newchm
return|;
comment|// Use the new table already
comment|// TODO - use a wait with timeout, so we'll wakeup as soon as the new table
comment|// is ready, or after the timeout in any case.
comment|//synchronized( this ) { wait(8*megs); }         // Timeout - we always wakeup
comment|// For now, sleep a tad and see if the 2 guys already trying to make
comment|// the table actually get around to making it happen.
try|try
block|{
name|Thread
operator|.
name|sleep
argument_list|(
literal|8
operator|*
name|megs
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{                 }
block|}
comment|// Last check, since the 'new' below is expensive and there is a chance
comment|// that another thread slipped in a new thread while we ran the heuristic.
name|newchm
operator|=
name|_newchm
expr_stmt|;
if|if
condition|(
name|newchm
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|newchm
return|;
comment|// Use the new table already
comment|// New CHM - actually allocate the big arrays
name|newchm
operator|=
operator|new
name|CHM
argument_list|(
name|_nbhml
argument_list|,
name|_size
argument_list|,
name|log2
argument_list|)
expr_stmt|;
comment|// Another check after the slow allocation
if|if
condition|(
name|_newchm
operator|!=
literal|null
condition|)
comment|// See if resize is already in progress
return|return
name|_newchm
return|;
comment|// Use the new table already
comment|// The new table must be CAS'd in so only 1 winner amongst duplicate
comment|// racing resizing threads.  Extra CHM's will be GC'd.
if|if
condition|(
name|CAS_newchm
argument_list|(
name|newchm
argument_list|)
condition|)
block|{
comment|// NOW a resize-is-in-progress!
comment|//notifyAll();            // Wake up any sleepers
comment|//long nano = System.nanoTime();
comment|//System.out.println(" "+nano+" Resize from "+oldlen+" to "+(1<<log2)+" and had "+(_resizers-1)+" extras" );
comment|//System.out.print("["+log2);
block|}
else|else
comment|// CAS failed?
name|newchm
operator|=
name|_newchm
expr_stmt|;
comment|// Reread new table
return|return
name|newchm
return|;
block|}
comment|// The next part of the table to copy.  It monotonically transits from zero
comment|// to _keys.length.  Visitors to the table can claim 'work chunks' by
comment|// CAS'ing this field up, then copying the indicated indices from the old
comment|// table to the new table.  Workers are not required to finish any chunk;
comment|// the counter simply wraps and work is copied duplicately until somebody
comment|// somewhere completes the count.
DECL|field|_copyIdx
specifier|volatile
name|long
name|_copyIdx
init|=
literal|0
decl_stmt|;
DECL|field|_copyIdxUpdater
specifier|static
specifier|private
specifier|final
name|AtomicLongFieldUpdater
argument_list|<
name|CHM
argument_list|>
name|_copyIdxUpdater
init|=
name|AtomicLongFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
literal|"_copyIdx"
argument_list|)
decl_stmt|;
comment|// Work-done reporting.  Used to efficiently signal when we can move to
comment|// the new table.  From 0 to len(oldkvs) refers to copying from the old
comment|// table to the new.
DECL|field|_copyDone
specifier|volatile
name|long
name|_copyDone
init|=
literal|0
decl_stmt|;
DECL|field|_copyDoneUpdater
specifier|static
specifier|private
specifier|final
name|AtomicLongFieldUpdater
argument_list|<
name|CHM
argument_list|>
name|_copyDoneUpdater
init|=
name|AtomicLongFieldUpdater
operator|.
name|newUpdater
argument_list|(
name|CHM
operator|.
name|class
argument_list|,
literal|"_copyDone"
argument_list|)
decl_stmt|;
comment|// --- help_copy_impl ----------------------------------------------------
comment|// Help along an existing resize operation.  We hope its the top-level
comment|// copy (it was when we started) but this CHM might have been promoted out
comment|// of the top position.
DECL|method|help_copy_impl
specifier|private
specifier|final
name|void
name|help_copy_impl
parameter_list|(
specifier|final
name|boolean
name|copy_all
parameter_list|)
block|{
specifier|final
name|CHM
name|newchm
init|=
name|_newchm
decl_stmt|;
assert|assert
name|newchm
operator|!=
literal|null
assert|;
comment|// Already checked by caller
name|int
name|oldlen
init|=
name|_keys
operator|.
name|length
decl_stmt|;
comment|// Total amount to copy
specifier|final
name|int
name|MIN_COPY_WORK
init|=
name|Math
operator|.
name|min
argument_list|(
name|oldlen
argument_list|,
literal|1024
argument_list|)
decl_stmt|;
comment|// Limit per-thread work
comment|// ---
name|int
name|panic_start
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|copyidx
init|=
operator|-
literal|9999
decl_stmt|;
comment|// Fool javac to think it's initialized
while|while
condition|(
name|_copyDone
operator|<
name|oldlen
condition|)
block|{
comment|// Still needing to copy?
comment|// Carve out a chunk of work.  The counter wraps around so every
comment|// thread eventually tries to copy every slot repeatedly.
comment|// We "panic" if we have tried TWICE to copy every slot - and it still
comment|// has not happened.  i.e., twice some thread somewhere claimed they
comment|// would copy 'slot X' (by bumping _copyIdx) but they never claimed to
comment|// have finished (by bumping _copyDone).  Our choices become limited:
comment|// we can wait for the work-claimers to finish (and become a blocking
comment|// algorithm) or do the copy work ourselves.  Tiny tables with huge
comment|// thread counts trying to copy the table often 'panic'.
if|if
condition|(
name|panic_start
operator|==
operator|-
literal|1
condition|)
block|{
comment|// No panic?
name|copyidx
operator|=
operator|(
name|int
operator|)
name|_copyIdx
expr_stmt|;
while|while
condition|(
name|copyidx
operator|<
operator|(
name|oldlen
operator|<<
literal|1
operator|)
operator|&&
comment|// 'panic' check
operator|!
name|_copyIdxUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|copyidx
argument_list|,
name|copyidx
operator|+
name|MIN_COPY_WORK
argument_list|)
condition|)
name|copyidx
operator|=
operator|(
name|int
operator|)
name|_copyIdx
expr_stmt|;
comment|// Re-read
if|if
condition|(
operator|!
operator|(
name|copyidx
operator|<
operator|(
name|oldlen
operator|<<
literal|1
operator|)
operator|)
condition|)
comment|// Panic!
name|panic_start
operator|=
name|copyidx
expr_stmt|;
comment|// Record where we started to panic-copy
block|}
comment|// We now know what to copy.  Try to copy.
name|int
name|workdone
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|MIN_COPY_WORK
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|copy_slot
argument_list|(
operator|(
name|copyidx
operator|+
name|i
operator|)
operator|&
operator|(
name|oldlen
operator|-
literal|1
operator|)
argument_list|)
condition|)
comment|// Made an oldtable slot go dead?
name|workdone
operator|++
expr_stmt|;
comment|// Yes!
if|if
condition|(
name|workdone
operator|>
literal|0
condition|)
comment|// Report work-done occasionally
name|copy_check_and_promote
argument_list|(
name|workdone
argument_list|)
expr_stmt|;
comment|// See if we can promote
comment|//for( int i=0; i<MIN_COPY_WORK; i++ )
comment|//  if( copy_slot((copyidx+i)&(oldlen-1)) ) // Made an oldtable slot go dead?
comment|//    copy_check_and_promote( 1 );// See if we can promote
name|copyidx
operator|+=
name|MIN_COPY_WORK
expr_stmt|;
comment|// Uncomment these next 2 lines to turn on incremental table-copy.
comment|// Otherwise this thread continues to copy until it is all done.
if|if
condition|(
operator|!
name|copy_all
operator|&&
name|panic_start
operator|==
operator|-
literal|1
condition|)
comment|// No panic?
return|return;
comment|// Then done copying after doing MIN_COPY_WORK
block|}
comment|// Extra promotion check, in case another thread finished all copying
comment|// then got stalled before promoting.
name|copy_check_and_promote
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// See if we can promote
block|}
comment|// --- copy_slot_and_check -----------------------------------------------
comment|// Copy slot 'idx' from the old table to the new table.  If this thread
comment|// confirmed the copy, update the counters and check for promotion.
comment|//
comment|// Returns the result of reading the volatile _newchm, mostly as a
comment|// convenience to callers.  We come here with 1-shot copy requests
comment|// typically because the caller has found a Prime, and has not yet read
comment|// the _newchm volatile - which must have changed from null-to-not-null
comment|// before any Prime appears.  So the caller needs to read the _newchm
comment|// field to retry his operation in the new table, but probably has not
comment|// read it yet.
DECL|method|copy_slot_and_check
specifier|private
specifier|final
name|CHM
name|copy_slot_and_check
parameter_list|(
name|int
name|idx
parameter_list|,
name|Object
name|should_help
parameter_list|)
block|{
comment|// We're only here because the caller saw a Prime, which implies a
comment|// table-copy is in progress.
assert|assert
name|_newchm
operator|!=
literal|null
assert|;
if|if
condition|(
name|copy_slot
argument_list|(
name|idx
argument_list|)
condition|)
comment|// Copy the desired slot
name|copy_check_and_promote
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Record the slot copied
comment|// Generically help along any copy (except if called recursively from a helper)
if|if
condition|(
name|should_help
operator|!=
literal|null
condition|)
name|_nbhml
operator|.
name|help_copy
argument_list|()
expr_stmt|;
return|return
name|_newchm
return|;
block|}
comment|// --- copy_check_and_promote --------------------------------------------
DECL|method|copy_check_and_promote
specifier|private
specifier|final
name|void
name|copy_check_and_promote
parameter_list|(
name|int
name|workdone
parameter_list|)
block|{
name|int
name|oldlen
init|=
name|_keys
operator|.
name|length
decl_stmt|;
comment|// We made a slot unusable and so did some of the needed copy work
name|long
name|copyDone
init|=
name|_copyDone
decl_stmt|;
name|long
name|nowDone
init|=
name|copyDone
operator|+
name|workdone
decl_stmt|;
assert|assert
name|nowDone
operator|<=
name|oldlen
assert|;
if|if
condition|(
name|workdone
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|!
name|_copyDoneUpdater
operator|.
name|compareAndSet
argument_list|(
name|this
argument_list|,
name|copyDone
argument_list|,
name|nowDone
argument_list|)
condition|)
block|{
name|copyDone
operator|=
name|_copyDone
expr_stmt|;
comment|// Reload, retry
name|nowDone
operator|=
name|copyDone
operator|+
name|workdone
expr_stmt|;
assert|assert
name|nowDone
operator|<=
name|oldlen
assert|;
block|}
comment|//if( (10*copyDone/oldlen) != (10*nowDone/oldlen) )
comment|//  System.out.print(" "+nowDone*100/oldlen+"%"+"_"+(_copyIdx*100/oldlen)+"%");
block|}
comment|// Check for copy being ALL done, and promote.  Note that we might have
comment|// nested in-progress copies and manage to finish a nested copy before
comment|// finishing the top-level copy.  We only promote top-level copies.
if|if
condition|(
name|nowDone
operator|==
name|oldlen
operator|&&
comment|// Ready to promote this table?
name|_nbhml
operator|.
name|_chm
operator|==
name|this
operator|&&
comment|// Looking at the top-level table?
comment|// Attempt to promote
name|_nbhml
operator|.
name|CAS
argument_list|(
name|_chm_offset
argument_list|,
name|this
argument_list|,
name|_newchm
argument_list|)
condition|)
block|{
name|_nbhml
operator|.
name|_last_resize_milli
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
comment|// Record resize time for next check
comment|//long nano = System.nanoTime();
comment|//System.out.println(" "+nano+" Promote table "+oldlen+" to "+_newchm._keys.length);
comment|//System.out.print("_"+oldlen+"]");
block|}
block|}
comment|// --- copy_slot ---------------------------------------------------------
comment|// Copy one K/V pair from oldkvs[i] to newkvs.  Returns true if we can
comment|// confirm that the new table guaranteed has a value for this old-table
comment|// slot.  We need an accurate confirmed-copy count so that we know when we
comment|// can promote (if we promote the new table too soon, other threads may
comment|// 'miss' on values not-yet-copied from the old table).  We don't allow
comment|// any direct updates on the new table, unless they first happened to the
comment|// old table - so that any transition in the new table from null to
comment|// not-null must have been from a copy_slot (or other old-table overwrite)
comment|// and not from a thread directly writing in the new table.  Thus we can
comment|// count null-to-not-null transitions in the new table.
DECL|method|copy_slot
specifier|private
name|boolean
name|copy_slot
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
comment|// Blindly set the key slot from NO_KEY to some key which hashes here,
comment|// to eagerly stop fresh put's from inserting new values in the old
comment|// table when the old table is mid-resize.  We don't need to act on the
comment|// results here, because our correctness stems from box'ing the Value
comment|// field.  Slamming the Key field is a minor speed optimization.
name|long
name|key
decl_stmt|;
while|while
condition|(
operator|(
name|key
operator|=
name|_keys
index|[
name|idx
index|]
operator|)
operator|==
name|NO_KEY
condition|)
name|CAS_key
argument_list|(
name|idx
argument_list|,
name|NO_KEY
argument_list|,
operator|(
name|idx
operator|+
name|_keys
operator|.
name|length
operator|)
comment|/*a non-zero key which hashes here*/
argument_list|)
expr_stmt|;
comment|// ---
comment|// Prevent new values from appearing in the old table.
comment|// Box what we see in the old table, to prevent further updates.
name|Object
name|oldval
init|=
name|_vals
index|[
name|idx
index|]
decl_stmt|;
comment|// Read OLD table
while|while
condition|(
operator|!
operator|(
name|oldval
operator|instanceof
name|Prime
operator|)
condition|)
block|{
specifier|final
name|Prime
name|box
init|=
operator|(
name|oldval
operator|==
literal|null
operator|||
name|oldval
operator|==
name|TOMBSTONE
operator|)
condition|?
name|TOMBPRIME
else|:
operator|new
name|Prime
argument_list|(
name|oldval
argument_list|)
decl_stmt|;
if|if
condition|(
name|CAS_val
argument_list|(
name|idx
argument_list|,
name|oldval
argument_list|,
name|box
argument_list|)
condition|)
block|{
comment|// CAS down a box'd version of oldval
comment|// If we made the Value slot hold a TOMBPRIME, then we both
comment|// prevented further updates here but also the (absent) oldval is
comment|// vaccuously available in the new table.  We return with true here:
comment|// any thread looking for a value for this key can correctly go
comment|// straight to the new table and skip looking in the old table.
if|if
condition|(
name|box
operator|==
name|TOMBPRIME
condition|)
return|return
literal|true
return|;
comment|// Otherwise we boxed something, but it still needs to be
comment|// copied into the new table.
name|oldval
operator|=
name|box
expr_stmt|;
comment|// Record updated oldval
break|break;
comment|// Break loop; oldval is now boxed by us
block|}
name|oldval
operator|=
name|_vals
index|[
name|idx
index|]
expr_stmt|;
comment|// Else try, try again
block|}
if|if
condition|(
name|oldval
operator|==
name|TOMBPRIME
condition|)
return|return
literal|false
return|;
comment|// Copy already complete here!
comment|// ---
comment|// Copy the value into the new table, but only if we overwrite a null.
comment|// If another value is already in the new table, then somebody else
comment|// wrote something there and that write is happens-after any value that
comment|// appears in the old table.  If putIfMatch does not find a null in the
comment|// new table - somebody else should have recorded the null-not_null
comment|// transition in this copy.
name|Object
name|old_unboxed
init|=
operator|(
operator|(
name|Prime
operator|)
name|oldval
operator|)
operator|.
name|_V
decl_stmt|;
assert|assert
name|old_unboxed
operator|!=
name|TOMBSTONE
assert|;
name|boolean
name|copied_into_new
init|=
operator|(
name|_newchm
operator|.
name|putIfMatch
argument_list|(
name|key
argument_list|,
name|old_unboxed
argument_list|,
literal|null
argument_list|)
operator|==
literal|null
operator|)
decl_stmt|;
comment|// ---
comment|// Finally, now that any old value is exposed in the new table, we can
comment|// forever hide the old-table value by slapping a TOMBPRIME down.  This
comment|// will stop other threads from uselessly attempting to copy this slot
comment|// (i.e., it's a speed optimization not a correctness issue).
while|while
condition|(
operator|!
name|CAS_val
argument_list|(
name|idx
argument_list|,
name|oldval
argument_list|,
name|TOMBPRIME
argument_list|)
condition|)
name|oldval
operator|=
name|_vals
index|[
name|idx
index|]
expr_stmt|;
return|return
name|copied_into_new
return|;
block|}
comment|// end copy_slot
block|}
comment|// End of CHM
comment|// --- Snapshot ------------------------------------------------------------
DECL|class|SnapshotV
specifier|private
class|class
name|SnapshotV
implements|implements
name|Iterator
argument_list|<
name|TypeV
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|TypeV
argument_list|>
block|{
DECL|field|_sschm
specifier|final
name|CHM
name|_sschm
decl_stmt|;
DECL|method|SnapshotV
specifier|public
name|SnapshotV
parameter_list|()
block|{
name|CHM
name|topchm
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Verify no table-copy-in-progress
name|topchm
operator|=
name|_chm
expr_stmt|;
if|if
condition|(
name|topchm
operator|.
name|_newchm
operator|==
literal|null
condition|)
comment|// No table-copy-in-progress
break|break;
comment|// Table copy in-progress - so we cannot get a clean iteration.  We
comment|// must help finish the table copy before we can start iterating.
name|topchm
operator|.
name|help_copy_impl
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// The "linearization point" for the iteration.  Every key in this table
comment|// will be visited, but keys added later might be skipped or even be
comment|// added to a following table (also not iterated over).
name|_sschm
operator|=
name|topchm
expr_stmt|;
comment|// Warm-up the iterator
name|_idx
operator|=
operator|-
literal|1
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
block|}
DECL|method|length
name|int
name|length
parameter_list|()
block|{
return|return
name|_sschm
operator|.
name|_keys
operator|.
name|length
return|;
block|}
DECL|method|key
name|long
name|key
parameter_list|(
specifier|final
name|int
name|idx
parameter_list|)
block|{
return|return
name|_sschm
operator|.
name|_keys
index|[
name|idx
index|]
return|;
block|}
DECL|field|_idx
specifier|private
name|int
name|_idx
decl_stmt|;
comment|// -2 for NO_KEY, -1 for CHECK_NEW_TABLE_LONG, 0-keys.length
DECL|field|_nextK
DECL|field|_prevK
specifier|private
name|long
name|_nextK
decl_stmt|,
name|_prevK
decl_stmt|;
comment|// Last 2 keys found
DECL|field|_nextV
DECL|field|_prevV
specifier|private
name|TypeV
name|_nextV
decl_stmt|,
name|_prevV
decl_stmt|;
comment|// Last 2 values found
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_nextV
operator|!=
literal|null
return|;
block|}
DECL|method|next
specifier|public
name|TypeV
name|next
parameter_list|()
block|{
comment|// 'next' actually knows what the next value will be - it had to
comment|// figure that out last go 'round lest 'hasNext' report true and
comment|// some other thread deleted the last value.  Instead, 'next'
comment|// spends all its effort finding the key that comes after the
comment|// 'next' key.
if|if
condition|(
name|_idx
operator|!=
operator|-
literal|1
operator|&&
name|_nextV
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|_prevK
operator|=
name|_nextK
expr_stmt|;
comment|// This will become the previous key
name|_prevV
operator|=
name|_nextV
expr_stmt|;
comment|// This will become the previous value
name|_nextV
operator|=
literal|null
expr_stmt|;
comment|// We have no more next-key
comment|// Attempt to set<_nextK,_nextV> to the next K,V pair.
comment|// _nextV is the trigger: stop searching when it is != null
if|if
condition|(
name|_idx
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Check for NO_KEY
name|_idx
operator|=
literal|0
expr_stmt|;
comment|// Setup for next phase of search
name|_nextK
operator|=
name|NO_KEY
expr_stmt|;
if|if
condition|(
operator|(
name|_nextV
operator|=
name|get
argument_list|(
name|_nextK
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|_prevV
return|;
block|}
while|while
condition|(
name|_idx
operator|<
name|length
argument_list|()
condition|)
block|{
comment|// Scan array
name|_nextK
operator|=
name|key
argument_list|(
name|_idx
operator|++
argument_list|)
expr_stmt|;
comment|// Get a key that definitely is in the set (for the moment!)
if|if
condition|(
name|_nextK
operator|!=
name|NO_KEY
operator|&&
comment|// Found something?
operator|(
name|_nextV
operator|=
name|get
argument_list|(
name|_nextK
argument_list|)
operator|)
operator|!=
literal|null
condition|)
break|break;
comment|// Got it!  _nextK is a valid Key
block|}
comment|// Else keep scanning
return|return
name|_prevV
return|;
comment|// Return current value.
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|_prevV
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|_sschm
operator|.
name|putIfMatch
argument_list|(
name|_prevK
argument_list|,
name|TOMBSTONE
argument_list|,
name|_prevV
argument_list|)
expr_stmt|;
name|_prevV
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|nextElement
specifier|public
name|TypeV
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
DECL|method|hasMoreElements
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns an enumeration of the values in this table.      *      * @return an enumeration of the values in this table      * @see #values()      */
DECL|method|elements
specifier|public
name|Enumeration
argument_list|<
name|TypeV
argument_list|>
name|elements
parameter_list|()
block|{
return|return
operator|new
name|SnapshotV
argument_list|()
return|;
block|}
comment|// --- values --------------------------------------------------------------
comment|/**      * Returns a {@link Collection} view of the values contained in this map.      * The collection is backed by the map, so changes to the map are reflected      * in the collection, and vice-versa.  The collection supports element      * removal, which removes the corresponding mapping from this map, via the      *<tt>Iterator.remove</tt>,<tt>Collection.remove</tt>,      *<tt>removeAll</tt>,<tt>retainAll</tt>, and<tt>clear</tt> operations.      * It does not support the<tt>add</tt> or<tt>addAll</tt> operations.      *<p/>      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException}, and guarantees      * to traverse elements as they existed upon construction of the iterator,      * and may (but is not guaranteed to) reflect any modifications subsequent      * to construction.      */
DECL|method|values
specifier|public
name|Collection
argument_list|<
name|TypeV
argument_list|>
name|values
parameter_list|()
block|{
return|return
operator|new
name|AbstractCollection
argument_list|<
name|TypeV
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|v
parameter_list|)
block|{
return|return
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|v
argument_list|)
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|TypeV
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|SnapshotV
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|// --- keySet --------------------------------------------------------------
comment|/**      * A class which implements the {@link Iterator} and {@link Enumeration}      * interfaces, generified to the {@link Long} class and supporting a      *<strong>non-auto-boxing</strong> {@link #nextLong} function.      */
DECL|class|IteratorLong
specifier|public
class|class
name|IteratorLong
implements|implements
name|Iterator
argument_list|<
name|Long
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|Long
argument_list|>
block|{
DECL|field|_ss
specifier|private
specifier|final
name|SnapshotV
name|_ss
decl_stmt|;
comment|/**          * A new IteratorLong          */
DECL|method|IteratorLong
specifier|public
name|IteratorLong
parameter_list|()
block|{
name|_ss
operator|=
operator|new
name|SnapshotV
argument_list|()
expr_stmt|;
block|}
comment|/**          * Remove last key returned by {@link #next} or {@link #nextLong}.          */
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|_ss
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
comment|/**          *<strong>Auto-box</strong> and return the next key.          */
DECL|method|next
specifier|public
name|Long
name|next
parameter_list|()
block|{
name|_ss
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|_ss
operator|.
name|_prevK
return|;
block|}
comment|/**          * Return the next key as a primitive {@code long}.          */
DECL|method|nextLong
specifier|public
name|long
name|nextLong
parameter_list|()
block|{
name|_ss
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
name|_ss
operator|.
name|_prevK
return|;
block|}
comment|/**          * True if there are more keys to iterate over.          */
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_ss
operator|.
name|hasNext
argument_list|()
return|;
block|}
comment|/**          *<strong>Auto-box</strong> and return the next key.          */
DECL|method|nextElement
specifier|public
name|Long
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
comment|/**          * True if there are more keys to iterate over.          */
DECL|method|hasMoreElements
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns an enumeration of the<strong>auto-boxed</strong> keys in this table.      *<strong>Warning:</strong> this version will auto-box all returned keys.      *      * @return an enumeration of the auto-boxed keys in this table      * @see #keySet()      */
DECL|method|keys
specifier|public
name|Enumeration
argument_list|<
name|Long
argument_list|>
name|keys
parameter_list|()
block|{
return|return
operator|new
name|IteratorLong
argument_list|()
return|;
block|}
comment|/**      * Returns a {@link Set} view of the keys contained in this map; with care      * the keys may be iterated over<strong>without auto-boxing</strong>.  The      * set is backed by the map, so changes to the map are reflected in the      * set, and vice-versa.  The set supports element removal, which removes      * the corresponding mapping from this map, via the      *<tt>Iterator.remove</tt>,<tt>Set.remove</tt>,<tt>removeAll</tt>,      *<tt>retainAll</tt>, and<tt>clear</tt> operations.  It does not support      * the<tt>add</tt> or<tt>addAll</tt> operations.      *<p/>      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException}, and guarantees      * to traverse elements as they existed upon construction of the iterator,      * and may (but is not guaranteed to) reflect any modifications subsequent      * to construction.      */
DECL|method|keySet
specifier|public
name|Set
argument_list|<
name|Long
argument_list|>
name|keySet
parameter_list|()
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
return|return
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|k
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
return|return
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|remove
argument_list|(
name|k
argument_list|)
operator|!=
literal|null
return|;
block|}
specifier|public
name|IteratorLong
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|IteratorLong
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|// --- entrySet ------------------------------------------------------------
comment|// Warning: Each call to 'next' in this iterator constructs a new Long and a
comment|// new NBHMLEntry.
DECL|class|NBHMLEntry
specifier|private
class|class
name|NBHMLEntry
extends|extends
name|AbstractEntry
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
block|{
DECL|method|NBHMLEntry
name|NBHMLEntry
parameter_list|(
specifier|final
name|Long
name|k
parameter_list|,
specifier|final
name|TypeV
name|v
parameter_list|)
block|{
name|super
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
DECL|method|setValue
specifier|public
name|TypeV
name|setValue
parameter_list|(
specifier|final
name|TypeV
name|val
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|_val
operator|=
name|val
expr_stmt|;
return|return
name|put
argument_list|(
name|_key
argument_list|,
name|val
argument_list|)
return|;
block|}
block|}
DECL|class|SnapshotE
specifier|private
class|class
name|SnapshotE
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
argument_list|>
block|{
DECL|field|_ss
specifier|final
name|SnapshotV
name|_ss
decl_stmt|;
DECL|method|SnapshotE
specifier|public
name|SnapshotE
parameter_list|()
block|{
name|_ss
operator|=
operator|new
name|SnapshotV
argument_list|()
expr_stmt|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|_ss
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
DECL|method|next
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
name|next
parameter_list|()
block|{
name|_ss
operator|.
name|next
argument_list|()
expr_stmt|;
return|return
operator|new
name|NBHMLEntry
argument_list|(
name|_ss
operator|.
name|_prevK
argument_list|,
name|_ss
operator|.
name|_prevV
argument_list|)
return|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_ss
operator|.
name|hasNext
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns a {@link Set} view of the mappings contained in this map.  The      * set is backed by the map, so changes to the map are reflected in the      * set, and vice-versa.  The set supports element removal, which removes      * the corresponding mapping from the map, via the      *<tt>Iterator.remove</tt>,<tt>Set.remove</tt>,<tt>removeAll</tt>,      *<tt>retainAll</tt>, and<tt>clear</tt> operations.  It does not support      * the<tt>add</tt> or<tt>addAll</tt> operations.      *<p/>      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      *<p/>      *<p><strong>Warning:</strong> the iterator associated with this Set      * requires the creation of {@link java.util.Map.Entry} objects with each      * iteration.  The {@link org.cliffc.high_scale_lib.NonBlockingHashMap}      * does not normally create or using {@link java.util.Map.Entry} objects so      * they will be created soley to support this iteration.  Iterating using      * {@link #keySet} or {@link #values} will be more efficient.  In addition,      * this version requires<strong>auto-boxing</strong> the keys.      */
DECL|method|entrySet
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
return|return
operator|new
name|AbstractSet
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
argument_list|>
argument_list|()
block|{
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|remove
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
condition|)
return|return
literal|false
return|;
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|NonBlockingHashMapLong
operator|.
name|this
operator|.
name|remove
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|contains
parameter_list|(
specifier|final
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
condition|)
return|return
literal|false
return|;
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|TypeV
name|v
init|=
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|v
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|Long
argument_list|,
name|TypeV
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|SnapshotE
argument_list|()
return|;
block|}
block|}
return|;
block|}
comment|// --- writeObject -------------------------------------------------------
comment|// Write a NBHML to a stream
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|IOException
block|{
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
comment|// Write nothing
for|for
control|(
name|long
name|K
range|:
name|keySet
argument_list|()
control|)
block|{
specifier|final
name|Object
name|V
init|=
name|get
argument_list|(
name|K
argument_list|)
decl_stmt|;
comment|// Do an official 'get'
name|s
operator|.
name|writeLong
argument_list|(
name|K
argument_list|)
expr_stmt|;
comment|// Write the<long,TypeV> pair
name|s
operator|.
name|writeObject
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|writeLong
argument_list|(
name|NO_KEY
argument_list|)
expr_stmt|;
comment|// Sentinel to indicate end-of-data
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|// --- readObject --------------------------------------------------------
comment|// Read a CHM from a stream
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
comment|// Read nothing
name|initialize
argument_list|(
name|MIN_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|final
name|long
name|K
init|=
name|s
operator|.
name|readLong
argument_list|()
decl_stmt|;
specifier|final
name|TypeV
name|V
init|=
operator|(
name|TypeV
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|K
operator|==
name|NO_KEY
operator|&&
name|V
operator|==
literal|null
condition|)
break|break;
name|put
argument_list|(
name|K
argument_list|,
name|V
argument_list|)
expr_stmt|;
comment|// Insert with an offical put
block|}
block|}
block|}
end_class

begin_comment
comment|// End NonBlockingHashMapLong class
end_comment

end_unit

