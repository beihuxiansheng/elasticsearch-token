begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2010 Ning, Inc.  *  * Ning licenses this file to you under the Apache License, version 2.0  * (the "License"); you may not use this file except in compliance with the  * License.  You may obtain a copy of the License at:  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the  * License for the specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.http.multipart
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|http
operator|.
name|multipart
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|logging
operator|.
name|Loggers
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ByteArrayOutputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|OutputStream
import|;
end_import

begin_comment
comment|/**  * This class is an adaptation of the Apache HttpClient implementation  *  * @link http://hc.apache.org/httpclient-3.x/  */
end_comment

begin_class
DECL|class|Part
specifier|public
specifier|abstract
class|class
name|Part
block|{
comment|/**      * Log object for this class.      */
DECL|field|LOG
specifier|private
specifier|final
specifier|static
name|ESLogger
name|LOG
init|=
name|Loggers
operator|.
name|getLogger
argument_list|(
name|Part
operator|.
name|class
argument_list|)
decl_stmt|;
comment|/**      * The boundary      */
DECL|field|BOUNDARY
specifier|protected
specifier|static
specifier|final
name|String
name|BOUNDARY
init|=
literal|"----------------314159265358979323846"
decl_stmt|;
comment|/**      * The boundary as a byte array.      *      * @deprecated      */
DECL|field|BOUNDARY_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|BOUNDARY_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|BOUNDARY
argument_list|)
decl_stmt|;
comment|/**      * The default boundary to be used if etBoundaryBytes(byte[]) has not      * been called.      */
DECL|field|DEFAULT_BOUNDARY_BYTES
specifier|private
specifier|static
specifier|final
name|byte
index|[]
name|DEFAULT_BOUNDARY_BYTES
init|=
name|BOUNDARY_BYTES
decl_stmt|;
comment|/**      * Carriage return/linefeed      */
DECL|field|CRLF
specifier|protected
specifier|static
specifier|final
name|String
name|CRLF
init|=
literal|"\r\n"
decl_stmt|;
comment|/**      * Carriage return/linefeed as a byte array      */
DECL|field|CRLF_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|CRLF_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|CRLF
argument_list|)
decl_stmt|;
comment|/**      * Content dispostion characters      */
DECL|field|QUOTE
specifier|protected
specifier|static
specifier|final
name|String
name|QUOTE
init|=
literal|"\""
decl_stmt|;
comment|/**      * Content dispostion as a byte array      */
DECL|field|QUOTE_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|QUOTE_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|QUOTE
argument_list|)
decl_stmt|;
comment|/**      * Extra characters      */
DECL|field|EXTRA
specifier|protected
specifier|static
specifier|final
name|String
name|EXTRA
init|=
literal|"--"
decl_stmt|;
comment|/**      * Extra characters as a byte array      */
DECL|field|EXTRA_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|EXTRA_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|EXTRA
argument_list|)
decl_stmt|;
comment|/**      * Content dispostion characters      */
DECL|field|CONTENT_DISPOSITION
specifier|protected
specifier|static
specifier|final
name|String
name|CONTENT_DISPOSITION
init|=
literal|"Content-Disposition: form-data; name="
decl_stmt|;
comment|/**      * Content dispostion as a byte array      */
DECL|field|CONTENT_DISPOSITION_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|CONTENT_DISPOSITION_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|CONTENT_DISPOSITION
argument_list|)
decl_stmt|;
comment|/**      * Content type header      */
DECL|field|CONTENT_TYPE
specifier|protected
specifier|static
specifier|final
name|String
name|CONTENT_TYPE
init|=
literal|"Content-Type: "
decl_stmt|;
comment|/**      * Content type header as a byte array      */
DECL|field|CONTENT_TYPE_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|CONTENT_TYPE_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|CONTENT_TYPE
argument_list|)
decl_stmt|;
comment|/**      * Content charset      */
DECL|field|CHARSET
specifier|protected
specifier|static
specifier|final
name|String
name|CHARSET
init|=
literal|"; charset="
decl_stmt|;
comment|/**      * Content charset as a byte array      */
DECL|field|CHARSET_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|CHARSET_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|CHARSET
argument_list|)
decl_stmt|;
comment|/**      * Content type header      */
DECL|field|CONTENT_TRANSFER_ENCODING
specifier|protected
specifier|static
specifier|final
name|String
name|CONTENT_TRANSFER_ENCODING
init|=
literal|"Content-Transfer-Encoding: "
decl_stmt|;
comment|/**      * Content type header as a byte array      */
DECL|field|CONTENT_TRANSFER_ENCODING_BYTES
specifier|protected
specifier|static
specifier|final
name|byte
index|[]
name|CONTENT_TRANSFER_ENCODING_BYTES
init|=
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|CONTENT_TRANSFER_ENCODING
argument_list|)
decl_stmt|;
comment|/**      * Return the boundary string.      *      * @return the boundary string      * @deprecated uses a constant string. Rather use {@link #getPartBoundary}      */
DECL|method|getBoundary
specifier|public
specifier|static
name|String
name|getBoundary
parameter_list|()
block|{
return|return
name|BOUNDARY
return|;
block|}
comment|/**      * The ASCII bytes to use as the multipart boundary.      */
DECL|field|boundaryBytes
specifier|private
name|byte
index|[]
name|boundaryBytes
decl_stmt|;
comment|/**      * Return the name of this part.      *      * @return The name.      */
DECL|method|getName
specifier|public
specifier|abstract
name|String
name|getName
parameter_list|()
function_decl|;
comment|/**      * Returns the content type of this part.      *      * @return the content type, or<code>null</code> to exclude the content type header      */
DECL|method|getContentType
specifier|public
specifier|abstract
name|String
name|getContentType
parameter_list|()
function_decl|;
comment|/**      * Return the character encoding of this part.      *      * @return the character encoding, or<code>null</code> to exclude the character      *         encoding header      */
DECL|method|getCharSet
specifier|public
specifier|abstract
name|String
name|getCharSet
parameter_list|()
function_decl|;
comment|/**      * Return the transfer encoding of this part.      *      * @return the transfer encoding, or<code>null</code> to exclude the transfer encoding header      */
DECL|method|getTransferEncoding
specifier|public
specifier|abstract
name|String
name|getTransferEncoding
parameter_list|()
function_decl|;
comment|/**      * Gets the part boundary to be used.      *      * @return the part boundary as an array of bytes.      * @since 3.0      */
DECL|method|getPartBoundary
specifier|protected
name|byte
index|[]
name|getPartBoundary
parameter_list|()
block|{
if|if
condition|(
name|boundaryBytes
operator|==
literal|null
condition|)
block|{
comment|// custom boundary bytes have not been set, use the default.
return|return
name|DEFAULT_BOUNDARY_BYTES
return|;
block|}
else|else
block|{
return|return
name|boundaryBytes
return|;
block|}
block|}
comment|/**      * Sets the part boundary.  Only meant to be used by      * {@link Part#sendParts(java.io.OutputStream , Part[], byte[])}      * and {@link Part#getLengthOfParts(Part[], byte[])}      *      * @param boundaryBytes An array of ASCII bytes.      * @since 3.0      */
DECL|method|setPartBoundary
name|void
name|setPartBoundary
parameter_list|(
name|byte
index|[]
name|boundaryBytes
parameter_list|)
block|{
name|this
operator|.
name|boundaryBytes
operator|=
name|boundaryBytes
expr_stmt|;
block|}
comment|/**      * Tests if this part can be sent more than once.      *      * @return<code>true</code> if {@link #sendData(java.io.OutputStream)} can be successfully called      *         more than once.      * @since 3.0      */
DECL|method|isRepeatable
specifier|public
name|boolean
name|isRepeatable
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|/**      * Write the start to the specified output stream      *      * @param out The output stream      * @throws java.io.IOException If an IO problem occurs.      */
DECL|method|sendStart
specifier|protected
name|void
name|sendStart
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter sendStart(OutputStream out)"
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|EXTRA_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|getPartBoundary
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CRLF_BYTES
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the content disposition header to the specified output stream      *      * @param out The output stream      * @throws IOException If an IO problem occurs.      */
DECL|method|sendDispositionHeader
specifier|protected
name|void
name|sendDispositionHeader
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter sendDispositionHeader(OutputStream out)"
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CONTENT_DISPOSITION_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|QUOTE_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|getName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|QUOTE_BYTES
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the content type header to the specified output stream      *      * @param out The output stream      * @throws IOException If an IO problem occurs.      */
DECL|method|sendContentTypeHeader
specifier|protected
name|void
name|sendContentTypeHeader
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter sendContentTypeHeader(OutputStream out)"
argument_list|)
expr_stmt|;
name|String
name|contentType
init|=
name|getContentType
argument_list|()
decl_stmt|;
if|if
condition|(
name|contentType
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|CRLF_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CONTENT_TYPE_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|contentType
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|charSet
init|=
name|getCharSet
argument_list|()
decl_stmt|;
if|if
condition|(
name|charSet
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|CHARSET_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|charSet
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Write the content transfer encoding header to the specified      * output stream      *      * @param out The output stream      * @throws IOException If an IO problem occurs.      */
DECL|method|sendTransferEncodingHeader
specifier|protected
name|void
name|sendTransferEncodingHeader
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter sendTransferEncodingHeader(OutputStream out)"
argument_list|)
expr_stmt|;
name|String
name|transferEncoding
init|=
name|getTransferEncoding
argument_list|()
decl_stmt|;
if|if
condition|(
name|transferEncoding
operator|!=
literal|null
condition|)
block|{
name|out
operator|.
name|write
argument_list|(
name|CRLF_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CONTENT_TRANSFER_ENCODING_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|MultipartEncodingUtil
operator|.
name|getAsciiBytes
argument_list|(
name|transferEncoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Write the end of the header to the output stream      *      * @param out The output stream      * @throws IOException If an IO problem occurs.      */
DECL|method|sendEndOfHeader
specifier|protected
name|void
name|sendEndOfHeader
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter sendEndOfHeader(OutputStream out)"
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CRLF_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CRLF_BYTES
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write the data to the specified output stream      *      * @param out The output stream      * @throws IOException If an IO problem occurs.      */
DECL|method|sendData
specifier|protected
specifier|abstract
name|void
name|sendData
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
function_decl|;
comment|/**      * Return the length of the main content      *      * @return long The length.      * @throws IOException If an IO problem occurs      */
DECL|method|lengthOfData
specifier|protected
specifier|abstract
name|long
name|lengthOfData
parameter_list|()
throws|throws
name|IOException
function_decl|;
comment|/**      * Write the end data to the output stream.      *      * @param out The output stream      * @throws IOException If an IO problem occurs.      */
DECL|method|sendEnd
specifier|protected
name|void
name|sendEnd
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter sendEnd(OutputStream out)"
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CRLF_BYTES
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write all the data to the output stream.      * If you override this method make sure to override      * #length() as well      *      * @param out The output stream      * @throws IOException If an IO problem occurs.      */
DECL|method|send
specifier|public
name|void
name|send
parameter_list|(
name|OutputStream
name|out
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter send(OutputStream out)"
argument_list|)
expr_stmt|;
name|sendStart
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sendDispositionHeader
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sendContentTypeHeader
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sendTransferEncodingHeader
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sendEndOfHeader
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sendData
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|sendEnd
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
comment|/**      * Return the full length of all the data.      * If you override this method make sure to override      * #send(OutputStream) as well      *      * @return long The length.      * @throws IOException If an IO problem occurs      */
DECL|method|length
specifier|public
name|long
name|length
parameter_list|()
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"enter length()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lengthOfData
argument_list|()
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|ByteArrayOutputStream
name|overhead
init|=
operator|new
name|ByteArrayOutputStream
argument_list|()
decl_stmt|;
name|sendStart
argument_list|(
name|overhead
argument_list|)
expr_stmt|;
name|sendDispositionHeader
argument_list|(
name|overhead
argument_list|)
expr_stmt|;
name|sendContentTypeHeader
argument_list|(
name|overhead
argument_list|)
expr_stmt|;
name|sendTransferEncodingHeader
argument_list|(
name|overhead
argument_list|)
expr_stmt|;
name|sendEndOfHeader
argument_list|(
name|overhead
argument_list|)
expr_stmt|;
name|sendEnd
argument_list|(
name|overhead
argument_list|)
expr_stmt|;
return|return
name|overhead
operator|.
name|size
argument_list|()
operator|+
name|lengthOfData
argument_list|()
return|;
block|}
comment|/**      * Return a string representation of this object.      *      * @return A string representation of this object.      * @see java.lang.Object#toString()      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|this
operator|.
name|getName
argument_list|()
return|;
block|}
comment|/**      * Write all parts and the last boundary to the specified output stream.      *      * @param out   The stream to write to.      * @param parts The parts to write.      * @throws IOException If an I/O error occurs while writing the parts.      */
DECL|method|sendParts
specifier|public
specifier|static
name|void
name|sendParts
parameter_list|(
name|OutputStream
name|out
parameter_list|,
specifier|final
name|Part
index|[]
name|parts
parameter_list|)
throws|throws
name|IOException
block|{
name|sendParts
argument_list|(
name|out
argument_list|,
name|parts
argument_list|,
name|DEFAULT_BOUNDARY_BYTES
argument_list|)
expr_stmt|;
block|}
comment|/**      * Write all parts and the last boundary to the specified output stream.      *      * @param out          The stream to write to.      * @param parts        The parts to write.      * @param partBoundary The ASCII bytes to use as the part boundary.      * @throws IOException If an I/O error occurs while writing the parts.      * @since 3.0      */
DECL|method|sendParts
specifier|public
specifier|static
name|void
name|sendParts
parameter_list|(
name|OutputStream
name|out
parameter_list|,
name|Part
index|[]
name|parts
parameter_list|,
name|byte
index|[]
name|partBoundary
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|parts
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parts may not be null"
argument_list|)
throw|;
block|}
if|if
condition|(
name|partBoundary
operator|==
literal|null
operator|||
name|partBoundary
operator|.
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"partBoundary may not be empty"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// set the part boundary before the part is sent
name|parts
index|[
name|i
index|]
operator|.
name|setPartBoundary
argument_list|(
name|partBoundary
argument_list|)
expr_stmt|;
name|parts
index|[
name|i
index|]
operator|.
name|send
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|write
argument_list|(
name|EXTRA_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|partBoundary
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|EXTRA_BYTES
argument_list|)
expr_stmt|;
name|out
operator|.
name|write
argument_list|(
name|CRLF_BYTES
argument_list|)
expr_stmt|;
block|}
comment|/**      * Return the total sum of all parts and that of the last boundary      *      * @param parts The parts.      * @return The total length      * @throws IOException If an I/O error occurs while writing the parts.      */
DECL|method|getLengthOfParts
specifier|public
specifier|static
name|long
name|getLengthOfParts
parameter_list|(
name|Part
index|[]
name|parts
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|getLengthOfParts
argument_list|(
name|parts
argument_list|,
name|DEFAULT_BOUNDARY_BYTES
argument_list|)
return|;
block|}
comment|/**      * Gets the length of the multipart message including the given parts.      *      * @param parts        The parts.      * @param partBoundary The ASCII bytes to use as the part boundary.      * @return The total length      * @throws IOException If an I/O error occurs while writing the parts.      * @since 3.0      */
DECL|method|getLengthOfParts
specifier|public
specifier|static
name|long
name|getLengthOfParts
parameter_list|(
name|Part
index|[]
name|parts
parameter_list|,
name|byte
index|[]
name|partBoundary
parameter_list|)
throws|throws
name|IOException
block|{
name|LOG
operator|.
name|trace
argument_list|(
literal|"getLengthOfParts(Parts[])"
argument_list|)
expr_stmt|;
if|if
condition|(
name|parts
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Parts may not be null"
argument_list|)
throw|;
block|}
name|long
name|total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// set the part boundary before we calculate the part's length
name|parts
index|[
name|i
index|]
operator|.
name|setPartBoundary
argument_list|(
name|partBoundary
argument_list|)
expr_stmt|;
name|long
name|l
init|=
name|parts
index|[
name|i
index|]
operator|.
name|length
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|total
operator|+=
name|l
expr_stmt|;
block|}
name|total
operator|+=
name|EXTRA_BYTES
operator|.
name|length
expr_stmt|;
name|total
operator|+=
name|partBoundary
operator|.
name|length
expr_stmt|;
name|total
operator|+=
name|EXTRA_BYTES
operator|.
name|length
expr_stmt|;
name|total
operator|+=
name|CRLF_BYTES
operator|.
name|length
expr_stmt|;
return|return
name|total
return|;
block|}
block|}
end_class

end_unit

