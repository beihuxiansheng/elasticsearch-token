begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.yaml.snakeyaml.parser
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|parser
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|error
operator|.
name|Mark
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|error
operator|.
name|YAMLException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|events
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|nodes
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|reader
operator|.
name|StreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|scanner
operator|.
name|Scanner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|scanner
operator|.
name|ScannerImpl
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|tokens
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|util
operator|.
name|ArrayStack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  *<pre>  * # The following YAML grammar is LL(1) and is parsed by a recursive descent  * parser.  * stream            ::= STREAM-START implicit_document? explicit_document* STREAM-END  * implicit_document ::= block_node DOCUMENT-END*  * explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*  * block_node_or_indentless_sequence ::=  *                       ALIAS  *                       | properties (block_content | indentless_block_sequence)?  *                       | block_content  *                       | indentless_block_sequence  * block_node        ::= ALIAS  *                       | properties block_content?  *                       | block_content  * flow_node         ::= ALIAS  *                       | properties flow_content?  *                       | flow_content  * properties        ::= TAG ANCHOR? | ANCHOR TAG?  * block_content     ::= block_collection | flow_collection | SCALAR  * flow_content      ::= flow_collection | SCALAR  * block_collection  ::= block_sequence | block_mapping  * flow_collection   ::= flow_sequence | flow_mapping  * block_sequence    ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END  * indentless_sequence   ::= (BLOCK-ENTRY block_node?)+  * block_mapping     ::= BLOCK-MAPPING_START  *                       ((KEY block_node_or_indentless_sequence?)?  *                       (VALUE block_node_or_indentless_sequence?)?)*  *                       BLOCK-END  * flow_sequence     ::= FLOW-SEQUENCE-START  *                       (flow_sequence_entry FLOW-ENTRY)*  *                       flow_sequence_entry?  *                       FLOW-SEQUENCE-END  * flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?  * flow_mapping      ::= FLOW-MAPPING-START  *                       (flow_mapping_entry FLOW-ENTRY)*  *                       flow_mapping_entry?  *                       FLOW-MAPPING-END  * flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?  * FIRST sets:  * stream: { STREAM-START }  * explicit_document: { DIRECTIVE DOCUMENT-START }  * implicit_document: FIRST(block_node)  * block_node: { ALIAS TAG ANCHOR SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START }  * flow_node: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START }  * block_content: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }  * flow_content: { FLOW-SEQUENCE-START FLOW-MAPPING-START SCALAR }  * block_collection: { BLOCK-SEQUENCE-START BLOCK-MAPPING-START }  * flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }  * block_sequence: { BLOCK-SEQUENCE-START }  * block_mapping: { BLOCK-MAPPING-START }  * block_node_or_indentless_sequence: { ALIAS ANCHOR TAG SCALAR BLOCK-SEQUENCE-START BLOCK-MAPPING-START FLOW-SEQUENCE-START FLOW-MAPPING-START BLOCK-ENTRY }  * indentless_sequence: { ENTRY }  * flow_collection: { FLOW-SEQUENCE-START FLOW-MAPPING-START }  * flow_sequence: { FLOW-SEQUENCE-START }  * flow_mapping: { FLOW-MAPPING-START }  * flow_sequence_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }  * flow_mapping_entry: { ALIAS ANCHOR TAG SCALAR FLOW-SEQUENCE-START FLOW-MAPPING-START KEY }  *</pre>  *  * Since writing a recursive-descendant parser is a straightforward task, we do  * not give many comments here.  *  * @see<a href="http://pyyaml.org/wiki/PyYAML">PyYAML</a> for more information  */
end_comment

begin_class
DECL|class|ParserImpl
specifier|public
specifier|final
class|class
name|ParserImpl
implements|implements
name|Parser
block|{
DECL|field|DEFAULT_TAGS
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|DEFAULT_TAGS
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|DEFAULT_TAGS
operator|.
name|put
argument_list|(
literal|"!"
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
name|DEFAULT_TAGS
operator|.
name|put
argument_list|(
literal|"!!"
argument_list|,
name|Tag
operator|.
name|PREFIX
argument_list|)
expr_stmt|;
block|}
DECL|field|scanner
specifier|private
specifier|final
name|Scanner
name|scanner
decl_stmt|;
DECL|field|currentEvent
specifier|private
name|Event
name|currentEvent
decl_stmt|;
DECL|field|yamlVersion
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|yamlVersion
decl_stmt|;
DECL|field|tagHandles
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tagHandles
decl_stmt|;
DECL|field|states
specifier|private
specifier|final
name|ArrayStack
argument_list|<
name|Production
argument_list|>
name|states
decl_stmt|;
DECL|field|marks
specifier|private
specifier|final
name|ArrayStack
argument_list|<
name|Mark
argument_list|>
name|marks
decl_stmt|;
DECL|field|state
specifier|private
name|Production
name|state
decl_stmt|;
DECL|method|ParserImpl
specifier|public
name|ParserImpl
parameter_list|(
name|StreamReader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|scanner
operator|=
operator|new
name|ScannerImpl
argument_list|(
name|reader
argument_list|)
expr_stmt|;
name|currentEvent
operator|=
literal|null
expr_stmt|;
name|yamlVersion
operator|=
literal|null
expr_stmt|;
name|tagHandles
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|states
operator|=
operator|new
name|ArrayStack
argument_list|<
name|Production
argument_list|>
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|marks
operator|=
operator|new
name|ArrayStack
argument_list|<
name|Mark
argument_list|>
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseStreamStart
argument_list|()
expr_stmt|;
block|}
comment|/**      * Check the type of the next event.      */
DECL|method|checkEvent
specifier|public
name|boolean
name|checkEvent
parameter_list|(
name|Event
operator|.
name|ID
name|choices
parameter_list|)
block|{
name|peekEvent
argument_list|()
expr_stmt|;
if|if
condition|(
name|currentEvent
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|currentEvent
operator|.
name|is
argument_list|(
name|choices
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/*      * Get the next event.      */
DECL|method|peekEvent
specifier|public
name|Event
name|peekEvent
parameter_list|()
block|{
if|if
condition|(
name|currentEvent
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|state
operator|!=
literal|null
condition|)
block|{
name|currentEvent
operator|=
name|state
operator|.
name|produce
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|currentEvent
return|;
block|}
comment|/*      * Get the next event and proceed further.      */
DECL|method|getEvent
specifier|public
name|Event
name|getEvent
parameter_list|()
block|{
name|peekEvent
argument_list|()
expr_stmt|;
name|Event
name|value
init|=
name|currentEvent
decl_stmt|;
name|currentEvent
operator|=
literal|null
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/**      *<pre>      * stream    ::= STREAM-START implicit_document? explicit_document* STREAM-END      * implicit_document ::= block_node DOCUMENT-END*      * explicit_document ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*      *</pre>      */
DECL|class|ParseStreamStart
specifier|private
class|class
name|ParseStreamStart
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
comment|// Parse the stream start.
name|StreamStartToken
name|token
init|=
operator|(
name|StreamStartToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|StreamStartEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
decl_stmt|;
comment|// Prepare the next state.
name|state
operator|=
operator|new
name|ParseImplicitDocumentStart
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
DECL|class|ParseImplicitDocumentStart
specifier|private
class|class
name|ParseImplicitDocumentStart
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
comment|// Parse an implicit document.
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Directive
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|DocumentStart
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|StreamEnd
argument_list|)
condition|)
block|{
name|tagHandles
operator|=
name|DEFAULT_TAGS
expr_stmt|;
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
name|Mark
name|startMark
init|=
name|token
operator|.
name|getStartMark
argument_list|()
decl_stmt|;
name|Mark
name|endMark
init|=
name|startMark
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|DocumentStartEvent
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
comment|// Prepare the next state.
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseDocumentEnd
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseBlockNode
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
else|else
block|{
name|Production
name|p
init|=
operator|new
name|ParseDocumentStart
argument_list|()
decl_stmt|;
return|return
name|p
operator|.
name|produce
argument_list|()
return|;
block|}
block|}
block|}
DECL|class|ParseDocumentStart
specifier|private
class|class
name|ParseDocumentStart
implements|implements
name|Production
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
comment|// Parse any extra document end indicators.
while|while
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|DocumentEnd
argument_list|)
condition|)
block|{
name|scanner
operator|.
name|getToken
argument_list|()
expr_stmt|;
block|}
comment|// Parse an explicit document.
name|Event
name|event
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|StreamEnd
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
name|Mark
name|startMark
init|=
name|token
operator|.
name|getStartMark
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|version_tags
init|=
name|processDirectives
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|version
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|version_tags
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tags
init|=
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
operator|)
name|version_tags
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|DocumentStart
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ParserException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"expected '<document start>', but found "
operator|+
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getTokenId
argument_list|()
argument_list|,
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
name|token
operator|=
name|scanner
operator|.
name|getToken
argument_list|()
expr_stmt|;
name|Mark
name|endMark
init|=
name|token
operator|.
name|getEndMark
argument_list|()
decl_stmt|;
name|Integer
index|[]
name|versionInteger
decl_stmt|;
if|if
condition|(
name|version
operator|!=
literal|null
condition|)
block|{
name|versionInteger
operator|=
operator|new
name|Integer
index|[
literal|2
index|]
expr_stmt|;
name|versionInteger
operator|=
name|version
operator|.
name|toArray
argument_list|(
name|versionInteger
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|versionInteger
operator|=
literal|null
expr_stmt|;
block|}
name|event
operator|=
operator|new
name|DocumentStartEvent
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|,
literal|true
argument_list|,
name|versionInteger
argument_list|,
name|tags
argument_list|)
expr_stmt|;
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseDocumentEnd
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseDocumentContent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Parse the end of the stream.
name|StreamEndToken
name|token
init|=
operator|(
name|StreamEndToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|event
operator|=
operator|new
name|StreamEndEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|states
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Unexpected end of stream. States left: "
operator|+
name|states
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|marks
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Unexpected end of stream. Marks left: "
operator|+
name|marks
argument_list|)
throw|;
block|}
name|state
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|event
return|;
block|}
block|}
DECL|class|ParseDocumentEnd
specifier|private
class|class
name|ParseDocumentEnd
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
comment|// Parse the document end.
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
name|Mark
name|startMark
init|=
name|token
operator|.
name|getStartMark
argument_list|()
decl_stmt|;
name|Mark
name|endMark
init|=
name|startMark
decl_stmt|;
name|boolean
name|explicit
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|DocumentEnd
argument_list|)
condition|)
block|{
name|token
operator|=
name|scanner
operator|.
name|getToken
argument_list|()
expr_stmt|;
name|endMark
operator|=
name|token
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|explicit
operator|=
literal|true
expr_stmt|;
block|}
name|Event
name|event
init|=
operator|new
name|DocumentEndEvent
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|,
name|explicit
argument_list|)
decl_stmt|;
comment|// Prepare the next state.
name|state
operator|=
operator|new
name|ParseDocumentStart
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
DECL|class|ParseDocumentContent
specifier|private
class|class
name|ParseDocumentContent
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|Event
name|event
decl_stmt|;
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Directive
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|DocumentStart
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|DocumentEnd
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|StreamEnd
argument_list|)
condition|)
block|{
name|event
operator|=
name|processEmptyScalar
argument_list|(
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getStartMark
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
else|else
block|{
name|Production
name|p
init|=
operator|new
name|ParseBlockNode
argument_list|()
decl_stmt|;
return|return
name|p
operator|.
name|produce
argument_list|()
return|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|processDirectives
specifier|private
name|List
argument_list|<
name|Object
argument_list|>
name|processDirectives
parameter_list|()
block|{
name|yamlVersion
operator|=
literal|null
expr_stmt|;
name|tagHandles
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
expr_stmt|;
while|while
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Directive
argument_list|)
condition|)
block|{
name|DirectiveToken
name|token
init|=
operator|(
name|DirectiveToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
name|token
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"YAML"
argument_list|)
condition|)
block|{
if|if
condition|(
name|yamlVersion
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ParserException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"found duplicate YAML directive"
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|value
init|=
operator|(
name|List
argument_list|<
name|Integer
argument_list|>
operator|)
name|token
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|Integer
name|major
init|=
name|value
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|major
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|ParserException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"found incompatible YAML document (version 1.* is required)"
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
name|yamlVersion
operator|=
operator|(
name|List
argument_list|<
name|Integer
argument_list|>
operator|)
name|token
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|.
name|getName
argument_list|()
operator|.
name|equals
argument_list|(
literal|"TAG"
argument_list|)
condition|)
block|{
name|List
argument_list|<
name|String
argument_list|>
name|value
init|=
operator|(
name|List
argument_list|<
name|String
argument_list|>
operator|)
name|token
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|String
name|handle
init|=
name|value
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|String
name|prefix
init|=
name|value
operator|.
name|get
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|tagHandles
operator|.
name|containsKey
argument_list|(
name|handle
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ParserException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"duplicate tag handle "
operator|+
name|handle
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
name|tagHandles
operator|.
name|put
argument_list|(
name|handle
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|value
init|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|value
operator|.
name|add
argument_list|(
name|yamlVersion
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tagHandles
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|value
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|tagHandles
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|.
name|add
argument_list|(
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|String
name|key
range|:
name|DEFAULT_TAGS
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|tagHandles
operator|.
name|containsKey
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|tagHandles
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|DEFAULT_TAGS
operator|.
name|get
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|value
return|;
block|}
comment|/**      *<pre>      *  block_node_or_indentless_sequence ::= ALIAS      *                | properties (block_content | indentless_block_sequence)?      *                | block_content      *                | indentless_block_sequence      *  block_node    ::= ALIAS      *                    | properties block_content?      *                    | block_content      *  flow_node     ::= ALIAS      *                    | properties flow_content?      *                    | flow_content      *  properties    ::= TAG ANCHOR? | ANCHOR TAG?      *  block_content     ::= block_collection | flow_collection | SCALAR      *  flow_content      ::= flow_collection | SCALAR      *  block_collection  ::= block_sequence | block_mapping      *  flow_collection   ::= flow_sequence | flow_mapping      *</pre>      */
DECL|class|ParseBlockNode
specifier|private
class|class
name|ParseBlockNode
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
return|return
name|parseNode
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
return|;
block|}
block|}
DECL|method|parseFlowNode
specifier|private
name|Event
name|parseFlowNode
parameter_list|()
block|{
return|return
name|parseNode
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|parseBlockNodeOrIndentlessSequence
specifier|private
name|Event
name|parseBlockNodeOrIndentlessSequence
parameter_list|()
block|{
return|return
name|parseNode
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
return|;
block|}
DECL|method|parseNode
specifier|private
name|Event
name|parseNode
parameter_list|(
name|boolean
name|block
parameter_list|,
name|boolean
name|indentlessSequence
parameter_list|)
block|{
name|Event
name|event
decl_stmt|;
name|Mark
name|startMark
init|=
literal|null
decl_stmt|;
name|Mark
name|endMark
init|=
literal|null
decl_stmt|;
name|Mark
name|tagMark
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Alias
argument_list|)
condition|)
block|{
name|AliasToken
name|token
init|=
operator|(
name|AliasToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|event
operator|=
operator|new
name|AliasEvent
argument_list|(
name|token
operator|.
name|getValue
argument_list|()
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|anchor
init|=
literal|null
decl_stmt|;
name|TagTuple
name|tagTokenTag
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Anchor
argument_list|)
condition|)
block|{
name|AnchorToken
name|token
init|=
operator|(
name|AnchorToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|startMark
operator|=
name|token
operator|.
name|getStartMark
argument_list|()
expr_stmt|;
name|endMark
operator|=
name|token
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|anchor
operator|=
name|token
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Tag
argument_list|)
condition|)
block|{
name|TagToken
name|tagToken
init|=
operator|(
name|TagToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|tagMark
operator|=
name|tagToken
operator|.
name|getStartMark
argument_list|()
expr_stmt|;
name|endMark
operator|=
name|tagToken
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|tagTokenTag
operator|=
name|tagToken
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Tag
argument_list|)
condition|)
block|{
name|TagToken
name|tagToken
init|=
operator|(
name|TagToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|startMark
operator|=
name|tagToken
operator|.
name|getStartMark
argument_list|()
expr_stmt|;
name|tagMark
operator|=
name|startMark
expr_stmt|;
name|endMark
operator|=
name|tagToken
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|tagTokenTag
operator|=
name|tagToken
operator|.
name|getValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Anchor
argument_list|)
condition|)
block|{
name|AnchorToken
name|token
init|=
operator|(
name|AnchorToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|endMark
operator|=
name|token
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|anchor
operator|=
name|token
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
block|}
name|String
name|tag
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|tagTokenTag
operator|!=
literal|null
condition|)
block|{
name|String
name|handle
init|=
name|tagTokenTag
operator|.
name|getHandle
argument_list|()
decl_stmt|;
name|String
name|suffix
init|=
name|tagTokenTag
operator|.
name|getSuffix
argument_list|()
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|tagHandles
operator|.
name|containsKey
argument_list|(
name|handle
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ParserException
argument_list|(
literal|"while parsing a node"
argument_list|,
name|startMark
argument_list|,
literal|"found undefined tag handle "
operator|+
name|handle
argument_list|,
name|tagMark
argument_list|)
throw|;
block|}
name|tag
operator|=
name|tagHandles
operator|.
name|get
argument_list|(
name|handle
argument_list|)
operator|+
name|suffix
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
name|suffix
expr_stmt|;
block|}
block|}
if|if
condition|(
name|startMark
operator|==
literal|null
condition|)
block|{
name|startMark
operator|=
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getStartMark
argument_list|()
expr_stmt|;
name|endMark
operator|=
name|startMark
expr_stmt|;
block|}
name|event
operator|=
literal|null
expr_stmt|;
name|boolean
name|implicit
init|=
operator|(
name|tag
operator|==
literal|null
operator|||
name|tag
operator|.
name|equals
argument_list|(
literal|"!"
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|indentlessSequence
operator|&&
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockEntry
argument_list|)
condition|)
block|{
name|endMark
operator|=
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|event
operator|=
operator|new
name|SequenceStartEvent
argument_list|(
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseIndentlessSequenceEntry
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Scalar
argument_list|)
condition|)
block|{
name|ScalarToken
name|token
init|=
operator|(
name|ScalarToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|endMark
operator|=
name|token
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|ImplicitTuple
name|implicitValues
decl_stmt|;
if|if
condition|(
operator|(
name|token
operator|.
name|getPlain
argument_list|()
operator|&&
name|tag
operator|==
literal|null
operator|)
operator|||
literal|"!"
operator|.
name|equals
argument_list|(
name|tag
argument_list|)
condition|)
block|{
name|implicitValues
operator|=
operator|new
name|ImplicitTuple
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|==
literal|null
condition|)
block|{
name|implicitValues
operator|=
operator|new
name|ImplicitTuple
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|implicitValues
operator|=
operator|new
name|ImplicitTuple
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
name|event
operator|=
operator|new
name|ScalarEvent
argument_list|(
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicitValues
argument_list|,
name|token
operator|.
name|getValue
argument_list|()
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|token
operator|.
name|getStyle
argument_list|()
argument_list|)
expr_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowSequenceStart
argument_list|)
condition|)
block|{
name|endMark
operator|=
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|event
operator|=
operator|new
name|SequenceStartEvent
argument_list|(
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseFlowSequenceFirstEntry
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowMappingStart
argument_list|)
condition|)
block|{
name|endMark
operator|=
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getEndMark
argument_list|()
expr_stmt|;
name|event
operator|=
operator|new
name|MappingStartEvent
argument_list|(
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseFlowMappingFirstKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block
operator|&&
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockSequenceStart
argument_list|)
condition|)
block|{
name|endMark
operator|=
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getStartMark
argument_list|()
expr_stmt|;
name|event
operator|=
operator|new
name|SequenceStartEvent
argument_list|(
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseBlockSequenceFirstEntry
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|block
operator|&&
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockMappingStart
argument_list|)
condition|)
block|{
name|endMark
operator|=
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getStartMark
argument_list|()
expr_stmt|;
name|event
operator|=
operator|new
name|MappingStartEvent
argument_list|(
name|anchor
argument_list|,
name|tag
argument_list|,
name|implicit
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|Boolean
operator|.
name|FALSE
argument_list|)
expr_stmt|;
name|state
operator|=
operator|new
name|ParseBlockMappingFirstKey
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|anchor
operator|!=
literal|null
operator|||
name|tag
operator|!=
literal|null
condition|)
block|{
comment|// Empty scalars are allowed even if a tag or an anchor is
comment|// specified.
name|event
operator|=
operator|new
name|ScalarEvent
argument_list|(
name|anchor
argument_list|,
name|tag
argument_list|,
operator|new
name|ImplicitTuple
argument_list|(
name|implicit
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|""
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
expr_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|String
name|node
decl_stmt|;
if|if
condition|(
name|block
condition|)
block|{
name|node
operator|=
literal|"block"
expr_stmt|;
block|}
else|else
block|{
name|node
operator|=
literal|"flow"
expr_stmt|;
block|}
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|ParserException
argument_list|(
literal|"while parsing a "
operator|+
name|node
operator|+
literal|" node"
argument_list|,
name|startMark
argument_list|,
literal|"expected the node content, but found "
operator|+
name|token
operator|.
name|getTokenId
argument_list|()
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|event
return|;
block|}
comment|// block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)*
comment|// BLOCK-END
DECL|class|ParseBlockSequenceFirstEntry
specifier|private
class|class
name|ParseBlockSequenceFirstEntry
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|marks
operator|.
name|push
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParseBlockSequenceEntry
argument_list|()
operator|.
name|produce
argument_list|()
return|;
block|}
block|}
DECL|class|ParseBlockSequenceEntry
specifier|private
class|class
name|ParseBlockSequenceEntry
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockEntry
argument_list|)
condition|)
block|{
name|BlockEntryToken
name|token
init|=
operator|(
name|BlockEntryToken
operator|)
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockEntry
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|BlockEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseBlockSequenceEntry
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParseBlockNode
argument_list|()
operator|.
name|produce
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseBlockSequenceEntry
argument_list|()
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockEnd
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|ParserException
argument_list|(
literal|"while parsing a block collection"
argument_list|,
name|marks
operator|.
name|pop
argument_list|()
argument_list|,
literal|"expected<block end>, but found "
operator|+
name|token
operator|.
name|getTokenId
argument_list|()
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|SequenceEndEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
decl_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
name|marks
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
comment|// indentless_sequence ::= (BLOCK-ENTRY block_node?)+
DECL|class|ParseIndentlessSequenceEntry
specifier|private
class|class
name|ParseIndentlessSequenceEntry
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockEntry
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockEntry
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|Key
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|BlockEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseIndentlessSequenceEntry
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParseBlockNode
argument_list|()
operator|.
name|produce
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseIndentlessSequenceEntry
argument_list|()
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|SequenceEndEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
decl_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
DECL|class|ParseBlockMappingFirstKey
specifier|private
class|class
name|ParseBlockMappingFirstKey
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|marks
operator|.
name|push
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParseBlockMappingKey
argument_list|()
operator|.
name|produce
argument_list|()
return|;
block|}
block|}
DECL|class|ParseBlockMappingKey
specifier|private
class|class
name|ParseBlockMappingKey
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Key
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Key
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|BlockEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseBlockMappingValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|parseBlockNodeOrIndentlessSequence
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseBlockMappingValue
argument_list|()
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|BlockEnd
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|ParserException
argument_list|(
literal|"while parsing a block mapping"
argument_list|,
name|marks
operator|.
name|pop
argument_list|()
argument_list|,
literal|"expected<block end>, but found "
operator|+
name|token
operator|.
name|getTokenId
argument_list|()
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|MappingEndEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
decl_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
name|marks
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
DECL|class|ParseBlockMappingValue
specifier|private
class|class
name|ParseBlockMappingValue
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Key
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|BlockEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseBlockMappingKey
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|parseBlockNodeOrIndentlessSequence
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseBlockMappingKey
argument_list|()
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
name|state
operator|=
operator|new
name|ParseBlockMappingKey
argument_list|()
expr_stmt|;
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      *<pre>      * flow_sequence     ::= FLOW-SEQUENCE-START      *                       (flow_sequence_entry FLOW-ENTRY)*      *                       flow_sequence_entry?      *                       FLOW-SEQUENCE-END      * flow_sequence_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?      * Note that while production rules for both flow_sequence_entry and      * flow_mapping_entry are equal, their interpretations are different.      * For `flow_sequence_entry`, the part `KEY flow_node? (VALUE flow_node?)?`      * generate an inline mapping (set syntax).      *</pre>      */
DECL|class|ParseFlowSequenceFirstEntry
specifier|private
class|class
name|ParseFlowSequenceFirstEntry
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|marks
operator|.
name|push
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParseFlowSequenceEntry
argument_list|(
literal|true
argument_list|)
operator|.
name|produce
argument_list|()
return|;
block|}
block|}
DECL|class|ParseFlowSequenceEntry
specifier|private
class|class
name|ParseFlowSequenceEntry
implements|implements
name|Production
block|{
DECL|field|first
specifier|private
name|boolean
name|first
init|=
literal|false
decl_stmt|;
DECL|method|ParseFlowSequenceEntry
specifier|public
name|ParseFlowSequenceEntry
parameter_list|(
name|boolean
name|first
parameter_list|)
block|{
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
block|}
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowSequenceEnd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowEntry
argument_list|)
condition|)
block|{
name|scanner
operator|.
name|getToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|ParserException
argument_list|(
literal|"while parsing a flow sequence"
argument_list|,
name|marks
operator|.
name|pop
argument_list|()
argument_list|,
literal|"expected ',' or ']', but got "
operator|+
name|token
operator|.
name|getTokenId
argument_list|()
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Key
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|MappingStartEvent
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
decl_stmt|;
name|state
operator|=
operator|new
name|ParseFlowSequenceEntryMappingKey
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowSequenceEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseFlowSequenceEntry
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|parseFlowNode
argument_list|()
return|;
block|}
block|}
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|SequenceEndEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
decl_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
name|marks
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
DECL|class|ParseFlowSequenceEntryMappingKey
specifier|private
class|class
name|ParseFlowSequenceEntryMappingKey
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|FlowEntry
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|FlowSequenceEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseFlowSequenceEntryMappingValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|parseFlowNode
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseFlowSequenceEntryMappingValue
argument_list|()
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|ParseFlowSequenceEntryMappingValue
specifier|private
class|class
name|ParseFlowSequenceEntryMappingValue
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowEntry
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|FlowSequenceEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseFlowSequenceEntryMappingEnd
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|parseFlowNode
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseFlowSequenceEntryMappingEnd
argument_list|()
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseFlowSequenceEntryMappingEnd
argument_list|()
expr_stmt|;
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|ParseFlowSequenceEntryMappingEnd
specifier|private
class|class
name|ParseFlowSequenceEntryMappingEnd
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|state
operator|=
operator|new
name|ParseFlowSequenceEntry
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
return|return
operator|new
name|MappingEndEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      *<pre>      *   flow_mapping  ::= FLOW-MAPPING-START      *          (flow_mapping_entry FLOW-ENTRY)*      *          flow_mapping_entry?      *          FLOW-MAPPING-END      *   flow_mapping_entry    ::= flow_node | KEY flow_node? (VALUE flow_node?)?      *</pre>      */
DECL|class|ParseFlowMappingFirstKey
specifier|private
class|class
name|ParseFlowMappingFirstKey
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|marks
operator|.
name|push
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|new
name|ParseFlowMappingKey
argument_list|(
literal|true
argument_list|)
operator|.
name|produce
argument_list|()
return|;
block|}
block|}
DECL|class|ParseFlowMappingKey
specifier|private
class|class
name|ParseFlowMappingKey
implements|implements
name|Production
block|{
DECL|field|first
specifier|private
name|boolean
name|first
init|=
literal|false
decl_stmt|;
DECL|method|ParseFlowMappingKey
specifier|public
name|ParseFlowMappingKey
parameter_list|(
name|boolean
name|first
parameter_list|)
block|{
name|this
operator|.
name|first
operator|=
name|first
expr_stmt|;
block|}
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowMappingEnd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowEntry
argument_list|)
condition|)
block|{
name|scanner
operator|.
name|getToken
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
throw|throw
operator|new
name|ParserException
argument_list|(
literal|"while parsing a flow mapping"
argument_list|,
name|marks
operator|.
name|pop
argument_list|()
argument_list|,
literal|"expected ',' or '}', but got "
operator|+
name|token
operator|.
name|getTokenId
argument_list|()
argument_list|,
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Key
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|FlowEntry
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|FlowMappingEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseFlowMappingValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|parseFlowNode
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseFlowMappingValue
argument_list|()
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowMappingEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseFlowMappingEmptyValue
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|parseFlowNode
argument_list|()
return|;
block|}
block|}
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
name|Event
name|event
init|=
operator|new
name|MappingEndEvent
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
decl_stmt|;
name|state
operator|=
name|states
operator|.
name|pop
argument_list|()
expr_stmt|;
name|marks
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
name|event
return|;
block|}
block|}
DECL|class|ParseFlowMappingValue
specifier|private
class|class
name|ParseFlowMappingValue
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
if|if
condition|(
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|Value
argument_list|)
condition|)
block|{
name|Token
name|token
init|=
name|scanner
operator|.
name|getToken
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|scanner
operator|.
name|checkToken
argument_list|(
name|Token
operator|.
name|ID
operator|.
name|FlowEntry
argument_list|,
name|Token
operator|.
name|ID
operator|.
name|FlowMappingEnd
argument_list|)
condition|)
block|{
name|states
operator|.
name|push
argument_list|(
operator|new
name|ParseFlowMappingKey
argument_list|(
literal|false
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|parseFlowNode
argument_list|()
return|;
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseFlowMappingKey
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getEndMark
argument_list|()
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|state
operator|=
operator|new
name|ParseFlowMappingKey
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|Token
name|token
init|=
name|scanner
operator|.
name|peekToken
argument_list|()
decl_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|token
operator|.
name|getStartMark
argument_list|()
argument_list|)
return|;
block|}
block|}
block|}
DECL|class|ParseFlowMappingEmptyValue
specifier|private
class|class
name|ParseFlowMappingEmptyValue
implements|implements
name|Production
block|{
DECL|method|produce
specifier|public
name|Event
name|produce
parameter_list|()
block|{
name|state
operator|=
operator|new
name|ParseFlowMappingKey
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|processEmptyScalar
argument_list|(
name|scanner
operator|.
name|peekToken
argument_list|()
operator|.
name|getStartMark
argument_list|()
argument_list|)
return|;
block|}
block|}
comment|/**      *<pre>      * block_mapping     ::= BLOCK-MAPPING_START      *           ((KEY block_node_or_indentless_sequence?)?      *           (VALUE block_node_or_indentless_sequence?)?)*      *           BLOCK-END      *</pre>      */
DECL|method|processEmptyScalar
specifier|private
name|Event
name|processEmptyScalar
parameter_list|(
name|Mark
name|mark
parameter_list|)
block|{
return|return
operator|new
name|ScalarEvent
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
operator|new
name|ImplicitTuple
argument_list|(
literal|true
argument_list|,
literal|false
argument_list|)
argument_list|,
literal|""
argument_list|,
name|mark
argument_list|,
name|mark
argument_list|,
operator|(
name|char
operator|)
literal|0
argument_list|)
return|;
block|}
block|}
end_class

end_unit

