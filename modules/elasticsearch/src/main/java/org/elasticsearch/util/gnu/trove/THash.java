begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.gnu.trove
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|gnu
operator|.
name|trove
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Externalizable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutput
import|;
end_import

begin_comment
comment|/**  * Base class for hashtables that use open addressing to resolve  * collisions.  *<p/>  * Created: Wed Nov 28 21:11:16 2001  *  * @author Eric D. Friedman  * @author Rob Eden (auto-compaction)  * @version $Id: THash.java,v 1.14 2008/10/08 16:39:10 robeden Exp $  */
end_comment

begin_class
DECL|class|THash
specifier|abstract
specifier|public
class|class
name|THash
implements|implements
name|Cloneable
implements|,
name|Externalizable
block|{
DECL|field|serialVersionUID
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|1792948471915530295L
decl_stmt|;
comment|/**      * the load above which rehashing occurs.      */
DECL|field|DEFAULT_LOAD_FACTOR
specifier|protected
specifier|static
specifier|final
name|float
name|DEFAULT_LOAD_FACTOR
init|=
literal|0.5f
decl_stmt|;
comment|/**      * the default initial capacity for the hash table.  This is one      * less than a prime value because one is added to it when      * searching for a prime capacity to account for the free slot      * required by open addressing. Thus, the real default capacity is      * 11.      */
DECL|field|DEFAULT_INITIAL_CAPACITY
specifier|protected
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|10
decl_stmt|;
comment|/**      * the current number of occupied slots in the hash.      */
DECL|field|_size
specifier|protected
specifier|transient
name|int
name|_size
decl_stmt|;
comment|/**      * the current number of free slots in the hash.      */
DECL|field|_free
specifier|protected
specifier|transient
name|int
name|_free
decl_stmt|;
comment|/**      * Determines how full the internal table can become before      * rehashing is required. This must be a value in the range: 0.0<      * loadFactor< 1.0.  The default value is 0.5, which is about as      * large as you can get in open addressing without hurting      * performance.  Cf. Knuth, Volume 3., Chapter 6.      */
DECL|field|_loadFactor
specifier|protected
name|float
name|_loadFactor
decl_stmt|;
comment|/**      * The maximum number of elements allowed without allocating more      * space.      */
DECL|field|_maxSize
specifier|protected
name|int
name|_maxSize
decl_stmt|;
comment|/**      * The number of removes that should be performed before an auto-compaction occurs.      */
DECL|field|_autoCompactRemovesRemaining
specifier|protected
name|int
name|_autoCompactRemovesRemaining
decl_stmt|;
comment|/**      * The auto-compaction factor for the table.      *      * @see #setAutoCompactionFactor      */
DECL|field|_autoCompactionFactor
specifier|protected
name|float
name|_autoCompactionFactor
decl_stmt|;
comment|/**      * @see #tempDisableAutoCompaction      */
DECL|field|_autoCompactTemporaryDisable
specifier|private
specifier|transient
name|boolean
name|_autoCompactTemporaryDisable
init|=
literal|false
decl_stmt|;
comment|/**      * Creates a new<code>THash</code> instance with the default      * capacity and load factor.      */
DECL|method|THash
specifier|public
name|THash
parameter_list|()
block|{
name|this
argument_list|(
name|DEFAULT_INITIAL_CAPACITY
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new<code>THash</code> instance with a prime capacity      * at or near the specified capacity and with the default load      * factor.      *      * @param initialCapacity an<code>int</code> value      */
DECL|method|THash
specifier|public
name|THash
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new<code>THash</code> instance with a prime capacity      * at or near the minimum needed to hold<tt>initialCapacity</tt>      * elements with load factor<tt>loadFactor</tt> without triggering      * a rehash.      *      * @param initialCapacity an<code>int</code> value      * @param loadFactor      a<code>float</code> value      */
DECL|method|THash
specifier|public
name|THash
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
name|_loadFactor
operator|=
name|loadFactor
expr_stmt|;
comment|// Through testing, the load factor (especially the default load factor) has been
comment|// found to be a pretty good starting auto-compaction factor.
name|_autoCompactionFactor
operator|=
name|loadFactor
expr_stmt|;
name|setUp
argument_list|(
name|HashFunctions
operator|.
name|fastCeil
argument_list|(
name|initialCapacity
operator|/
name|loadFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|clone
specifier|public
name|Object
name|clone
parameter_list|()
block|{
try|try
block|{
return|return
name|super
operator|.
name|clone
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|CloneNotSupportedException
name|cnse
parameter_list|)
block|{
return|return
literal|null
return|;
comment|// it's supported
block|}
block|}
comment|/**      * Tells whether this set is currently holding any elements.      *      * @return a<code>boolean</code> value      */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
literal|0
operator|==
name|_size
return|;
block|}
comment|/**      * Returns the number of distinct elements in this collection.      *      * @return an<code>int</code> value      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|_size
return|;
block|}
comment|/**      * @return the current physical capacity of the hash table.      */
DECL|method|capacity
specifier|abstract
specifier|protected
name|int
name|capacity
parameter_list|()
function_decl|;
comment|/**      * Ensure that this hashtable has sufficient capacity to hold      *<tt>desiredCapacity<tt><b>additional</b> elements without      * requiring a rehash.  This is a tuning method you can call      * before doing a large insert.      *      * @param desiredCapacity an<code>int</code> value      */
DECL|method|ensureCapacity
specifier|public
name|void
name|ensureCapacity
parameter_list|(
name|int
name|desiredCapacity
parameter_list|)
block|{
if|if
condition|(
name|desiredCapacity
operator|>
operator|(
name|_maxSize
operator|-
name|size
argument_list|()
operator|)
condition|)
block|{
name|rehash
argument_list|(
name|PrimeFinder
operator|.
name|nextPrime
argument_list|(
name|HashFunctions
operator|.
name|fastCeil
argument_list|(
operator|(
name|desiredCapacity
operator|+
name|size
argument_list|()
operator|)
operator|/
name|_loadFactor
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|computeMaxSize
argument_list|(
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Compresses the hashtable to the minimum prime size (as defined      * by PrimeFinder) that will hold all of the elements currently in      * the table.  If you have done a lot of<tt>remove</tt>      * operations and plan to do a lot of queries or insertions or      * iteration, it is a good idea to invoke this method.  Doing so      * will accomplish two things:      *<p/>      *<ol>      *<li> You'll free memory allocated to the table but no      * longer needed because of the remove()s.</li>      *<p/>      *<li> You'll get better query/insert/iterator performance      * because there won't be any<tt>REMOVED</tt> slots to skip      * over when probing for indices in the table.</li>      *</ol>      */
DECL|method|compact
specifier|public
name|void
name|compact
parameter_list|()
block|{
comment|// need at least one free spot for open addressing
name|rehash
argument_list|(
name|PrimeFinder
operator|.
name|nextPrime
argument_list|(
name|HashFunctions
operator|.
name|fastCeil
argument_list|(
name|size
argument_list|()
operator|/
name|_loadFactor
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|computeMaxSize
argument_list|(
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
comment|// If auto-compaction is enabled, re-determine the compaction interval
if|if
condition|(
name|_autoCompactionFactor
operator|!=
literal|0
condition|)
block|{
name|computeNextAutoCompactionAmount
argument_list|(
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * The auto-compaction factor controls whether and when a table performs a      * {@link #compact} automatically after a certain number of remove operations.      * If the value is non-zero, the number of removes that need to occur for      * auto-compaction is the size of table at the time of the previous compaction      * (or the initial capacity) multiplied by this factor.      *<p/>      * Setting this value to zero will disable auto-compaction.      */
DECL|method|setAutoCompactionFactor
specifier|public
name|void
name|setAutoCompactionFactor
parameter_list|(
name|float
name|factor
parameter_list|)
block|{
if|if
condition|(
name|factor
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Factor must be>= 0: "
operator|+
name|factor
argument_list|)
throw|;
block|}
name|_autoCompactionFactor
operator|=
name|factor
expr_stmt|;
block|}
comment|/**      * @see #setAutoCompactionFactor      */
DECL|method|getAutoCompactionFactor
specifier|public
name|float
name|getAutoCompactionFactor
parameter_list|()
block|{
return|return
name|_autoCompactionFactor
return|;
block|}
comment|/**      * This simply calls {@link #compact compact}.  It is included for      * symmetry with other collection classes.  Note that the name of this      * method is somewhat misleading (which is why we prefer      *<tt>compact</tt>) as the load factor may require capacity above      * and beyond the size of this collection.      *      * @see #compact      */
DECL|method|trimToSize
specifier|public
specifier|final
name|void
name|trimToSize
parameter_list|()
block|{
name|compact
argument_list|()
expr_stmt|;
block|}
comment|/**      * Delete the record at<tt>index</tt>.  Reduces the size of the      * collection by one.      *      * @param index an<code>int</code> value      */
DECL|method|removeAt
specifier|protected
name|void
name|removeAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|_size
operator|--
expr_stmt|;
comment|// If auto-compaction is enabled, see if we need to compact
if|if
condition|(
name|_autoCompactionFactor
operator|!=
literal|0
condition|)
block|{
name|_autoCompactRemovesRemaining
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|_autoCompactTemporaryDisable
operator|&&
name|_autoCompactRemovesRemaining
operator|<=
literal|0
condition|)
block|{
comment|// Do the compact
comment|// NOTE: this will cause the next compaction interval to be calculated
name|compact
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Empties the collection.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|_size
operator|=
literal|0
expr_stmt|;
name|_free
operator|=
name|capacity
argument_list|()
expr_stmt|;
block|}
comment|/**      * initializes the hashtable to a prime capacity which is at least      *<tt>initialCapacity + 1</tt>.      *      * @param initialCapacity an<code>int</code> value      * @return the actual capacity chosen      */
DECL|method|setUp
specifier|protected
name|int
name|setUp
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|int
name|capacity
decl_stmt|;
name|capacity
operator|=
name|PrimeFinder
operator|.
name|nextPrime
argument_list|(
name|initialCapacity
argument_list|)
expr_stmt|;
name|computeMaxSize
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
name|computeNextAutoCompactionAmount
argument_list|(
name|initialCapacity
argument_list|)
expr_stmt|;
return|return
name|capacity
return|;
block|}
comment|/**      * Rehashes the set.      *      * @param newCapacity an<code>int</code> value      */
DECL|method|rehash
specifier|protected
specifier|abstract
name|void
name|rehash
parameter_list|(
name|int
name|newCapacity
parameter_list|)
function_decl|;
comment|/**      * Temporarily disables auto-compaction. MUST be followed by calling      * {@link #reenableAutoCompaction}.      */
DECL|method|tempDisableAutoCompaction
specifier|protected
name|void
name|tempDisableAutoCompaction
parameter_list|()
block|{
name|_autoCompactTemporaryDisable
operator|=
literal|true
expr_stmt|;
block|}
comment|/**      * Re-enable auto-compaction after it was disabled via      * {@link #tempDisableAutoCompaction()}.      *      * @param check_for_compaction True if compaction should be performed if needed      *                             before returning. If false, no compaction will be      *                             performed.      */
DECL|method|reenableAutoCompaction
specifier|protected
name|void
name|reenableAutoCompaction
parameter_list|(
name|boolean
name|check_for_compaction
parameter_list|)
block|{
name|_autoCompactTemporaryDisable
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|check_for_compaction
operator|&&
name|_autoCompactRemovesRemaining
operator|<=
literal|0
operator|&&
name|_autoCompactionFactor
operator|!=
literal|0
condition|)
block|{
comment|// Do the compact
comment|// NOTE: this will cause the next compaction interval to be calculated
name|compact
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Computes the values of maxSize. There will always be at least      * one free slot required.      *      * @param capacity an<code>int</code> value      */
DECL|method|computeMaxSize
specifier|private
name|void
name|computeMaxSize
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
comment|// need at least one free slot for open addressing
name|_maxSize
operator|=
name|Math
operator|.
name|min
argument_list|(
name|capacity
operator|-
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|capacity
operator|*
name|_loadFactor
argument_list|)
argument_list|)
expr_stmt|;
name|_free
operator|=
name|capacity
operator|-
name|_size
expr_stmt|;
comment|// reset the free element count
block|}
comment|/**      * Computes the number of removes that need to happen before the next auto-compaction      * will occur.      */
DECL|method|computeNextAutoCompactionAmount
specifier|private
name|void
name|computeNextAutoCompactionAmount
parameter_list|(
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|_autoCompactionFactor
operator|!=
literal|0
condition|)
block|{
comment|// NOTE: doing the round ourselves has been found to be faster than using
comment|//       Math.round.
name|_autoCompactRemovesRemaining
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|size
operator|*
name|_autoCompactionFactor
operator|)
operator|+
literal|0.5f
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * After an insert, this hook is called to adjust the size/free      * values of the set and to perform rehashing if necessary.      */
DECL|method|postInsertHook
specifier|protected
specifier|final
name|void
name|postInsertHook
parameter_list|(
name|boolean
name|usedFreeSlot
parameter_list|)
block|{
if|if
condition|(
name|usedFreeSlot
condition|)
block|{
name|_free
operator|--
expr_stmt|;
block|}
comment|// rehash whenever we exhaust the available space in the table
if|if
condition|(
operator|++
name|_size
operator|>
name|_maxSize
operator|||
name|_free
operator|==
literal|0
condition|)
block|{
comment|// choose a new capacity suited to the new state of the table
comment|// if we've grown beyond our maximum size, double capacity;
comment|// if we've exhausted the free spots, rehash to the same capacity,
comment|// which will free up any stale removed slots for reuse.
name|int
name|newCapacity
init|=
name|_size
operator|>
name|_maxSize
condition|?
name|PrimeFinder
operator|.
name|nextPrime
argument_list|(
name|capacity
argument_list|()
operator|<<
literal|1
argument_list|)
else|:
name|capacity
argument_list|()
decl_stmt|;
name|rehash
argument_list|(
name|newCapacity
argument_list|)
expr_stmt|;
name|computeMaxSize
argument_list|(
name|capacity
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|calculateGrownCapacity
specifier|protected
name|int
name|calculateGrownCapacity
parameter_list|()
block|{
return|return
name|capacity
argument_list|()
operator|<<
literal|1
return|;
block|}
DECL|method|writeExternal
specifier|public
name|void
name|writeExternal
parameter_list|(
name|ObjectOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// VERSION
name|out
operator|.
name|writeByte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// LOAD FACTOR
name|out
operator|.
name|writeFloat
argument_list|(
name|_loadFactor
argument_list|)
expr_stmt|;
comment|// AUTO COMPACTION LOAD FACTOR
name|out
operator|.
name|writeFloat
argument_list|(
name|_autoCompactionFactor
argument_list|)
expr_stmt|;
block|}
DECL|method|readExternal
specifier|public
name|void
name|readExternal
parameter_list|(
name|ObjectInput
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
comment|// VERSION
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
comment|// LOAD FACTOR
name|float
name|old_factor
init|=
name|_loadFactor
decl_stmt|;
name|_loadFactor
operator|=
name|in
operator|.
name|readFloat
argument_list|()
expr_stmt|;
comment|// AUTO COMPACTION LOAD FACTOR
name|_autoCompactionFactor
operator|=
name|in
operator|.
name|readFloat
argument_list|()
expr_stmt|;
comment|// If we change the laod factor from the default, re-setup
if|if
condition|(
name|old_factor
operator|!=
name|_loadFactor
condition|)
block|{
name|setUp
argument_list|(
operator|(
name|int
operator|)
name|Math
operator|.
name|ceil
argument_list|(
name|DEFAULT_INITIAL_CAPACITY
operator|/
name|_loadFactor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// THash
end_comment

end_unit

