begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/licenses/publicdomain  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.concurrent.jsr166y
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|concurrent
operator|.
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_comment
comment|/**  * A reusable synchronization barrier, similar in functionality to  * {@link java.util.concurrent.CyclicBarrier CyclicBarrier} and  * {@link java.util.concurrent.CountDownLatch CountDownLatch}  * but supporting more flexible usage.  *  *<p><b>Registration.</b> Unlike the case for other barriers, the  * number of parties<em>registered</em> to synchronize on a phaser  * may vary over time.  Tasks may be registered at any time (using  * methods {@link #register}, {@link #bulkRegister}, or forms of  * constructors establishing initial numbers of parties), and  * optionally deregistered upon any arrival (using {@link  * #arriveAndDeregister}).  As is the case with most basic  * synchronization constructs, registration and deregistration affect  * only internal counts; they do not establish any further internal  * bookkeeping, so tasks cannot query whether they are registered.  * (However, you can introduce such bookkeeping by subclassing this  * class.)  *  *<p><b>Synchronization.</b> Like a {@code CyclicBarrier}, a {@code  * Phaser} may be repeatedly awaited.  Method {@link  * #arriveAndAwaitAdvance} has effect analogous to {@link  * java.util.concurrent.CyclicBarrier#await CyclicBarrier.await}. Each  * generation of a {@code Phaser} has an associated phase number. The  * phase number starts at zero, and advances when all parties arrive  * at the barrier, wrapping around to zero after reaching {@code  * Integer.MAX_VALUE}. The use of phase numbers enables independent  * control of actions upon arrival at a barrier and upon awaiting  * others, via two kinds of methods that may be invoked by any  * registered party:  *  *<ul>  *  *<li><b>Arrival.</b> Methods {@link #arrive} and  * {@link #arriveAndDeregister} record arrival at a  * barrier. These methods do not block, but return an associated  *<em>arrival phase number</em>; that is, the phase number of  * the barrier to which the arrival applied. When the final  * party for a given phase arrives, an optional barrier action  * is performed and the phase advances.  Barrier actions,  * performed by the party triggering a phase advance, are  * arranged by overriding method {@link #onAdvance(int, int)},  * which also controls termination. Overriding this method is  * similar to, but more flexible than, providing a barrier  * action to a {@code CyclicBarrier}.  *  *<li><b>Waiting.</b> Method {@link #awaitAdvance} requires an  * argument indicating an arrival phase number, and returns when  * the barrier advances to (or is already at) a different phase.  * Unlike similar constructions using {@code CyclicBarrier},  * method {@code awaitAdvance} continues to wait even if the  * waiting thread is interrupted. Interruptible and timeout  * versions are also available, but exceptions encountered while  * tasks wait interruptibly or with timeout do not change the  * state of the barrier. If necessary, you can perform any  * associated recovery within handlers of those exceptions,  * often after invoking {@code forceTermination}.  Phasers may  * also be used by tasks executing in a {@link ForkJoinPool},  * which will ensure sufficient parallelism to execute tasks  * when others are blocked waiting for a phase to advance.  *  *</ul>  *  *<p><b>Termination.</b> A {@code Phaser} may enter a  *<em>termination</em> state in which all synchronization methods  * immediately return without updating phaser state or waiting for  * advance, and indicating (via a negative phase value) that execution  * is complete.  Termination is triggered when an invocation of {@code  * onAdvance} returns {@code true}.  As illustrated below, when  * phasers control actions with a fixed number of iterations, it is  * often convenient to override this method to cause termination when  * the current phase number reaches a threshold. Method {@link  * #forceTermination} is also available to abruptly release waiting  * threads and allow them to terminate.  *  *<p><b>Tiering.</b> Phasers may be<em>tiered</em> (i.e., arranged  * in tree structures) to reduce contention. Phasers with large  * numbers of parties that would otherwise experience heavy  * synchronization contention costs may instead be set up so that  * groups of sub-phasers share a common parent.  This may greatly  * increase throughput even though it incurs greater per-operation  * overhead.  *  *<p><b>Monitoring.</b> While synchronization methods may be invoked  * only by registered parties, the current state of a phaser may be  * monitored by any caller.  At any given moment there are {@link  * #getRegisteredParties} parties in total, of which {@link  * #getArrivedParties} have arrived at the current phase ({@link  * #getPhase}).  When the remaining ({@link #getUnarrivedParties})  * parties arrive, the phase advances.  The values returned by these  * methods may reflect transient states and so are not in general  * useful for synchronization control.  Method {@link #toString}  * returns snapshots of these state queries in a form convenient for  * informal monitoring.  *  *<p><b>Sample usages:</b>  *  *<p>A {@code Phaser} may be used instead of a {@code CountDownLatch}  * to control a one-shot action serving a variable number of  * parties. The typical idiom is for the method setting this up to  * first register, then start the actions, then deregister, as in:  *  *<pre> {@code  * void runTasks(List<Runnable> tasks) {  *   final Phaser phaser = new Phaser(1); // "1" to register self  *   // create and start threads  *   for (Runnable task : tasks) {  *     phaser.register();  *     new Thread() {  *       public void run() {  *         phaser.arriveAndAwaitAdvance(); // await all creation  *         task.run();  *       }  *     }.start();  *   }  *  *   // allow threads to start and deregister self  *   phaser.arriveAndDeregister();  * }}</pre>  *  *<p>One way to cause a set of threads to repeatedly perform actions  * for a given number of iterations is to override {@code onAdvance}:  *  *<pre> {@code  * void startTasks(List<Runnable> tasks, final int iterations) {  *   final Phaser phaser = new Phaser() {  *     protected boolean onAdvance(int phase, int registeredParties) {  *       return phase>= iterations || registeredParties == 0;  *     }  *   };  *   phaser.register();  *   for (final Runnable task : tasks) {  *     phaser.register();  *     new Thread() {  *       public void run() {  *         do {  *           task.run();  *           phaser.arriveAndAwaitAdvance();  *         } while (!phaser.isTerminated());  *       }  *     }.start();  *   }  *   phaser.arriveAndDeregister(); // deregister self, don't wait  * }}</pre>  *  * If the main task must later await termination, it  * may re-register and then execute a similar loop:  *<pre> {@code  *   // ...  *   phaser.register();  *   while (!phaser.isTerminated())  *     phaser.arriveAndAwaitAdvance();}</pre>  *  *<p>Related constructions may be used to await particular phase numbers  * in contexts where you are sure that the phase will never wrap around  * {@code Integer.MAX_VALUE}. For example:  *  *<pre> {@code  * void awaitPhase(Phaser phaser, int phase) {  *   int p = phaser.register(); // assumes caller not already registered  *   while (p< phase) {  *     if (phaser.isTerminated())  *       // ... deal with unexpected termination  *     else  *       p = phaser.arriveAndAwaitAdvance();  *   }  *   phaser.arriveAndDeregister();  * }}</pre>  *  *  *<p>To create a set of tasks using a tree of phasers,  * you could use code of the following form, assuming a  * Task class with a constructor accepting a phaser that  * it registers for upon construction:  *  *<pre> {@code  * void build(Task[] actions, int lo, int hi, Phaser ph) {  *   if (hi - lo> TASKS_PER_PHASER) {  *     for (int i = lo; i< hi; i += TASKS_PER_PHASER) {  *       int j = Math.min(i + TASKS_PER_PHASER, hi);  *       build(actions, i, j, new Phaser(ph));  *     }  *   } else {  *     for (int i = lo; i< hi; ++i)  *       actions[i] = new Task(ph);  *       // assumes new Task(ph) performs ph.register()  *   }  * }  * // .. initially called, for n tasks via  * build(new Task[n], 0, n, new Phaser());}</pre>  *  * The best value of {@code TASKS_PER_PHASER} depends mainly on  * expected barrier synchronization rates. A value as low as four may  * be appropriate for extremely small per-barrier task bodies (thus  * high rates), or up to hundreds for extremely large ones.  *  *</pre>  *  *<p><b>Implementation notes</b>: This implementation restricts the  * maximum number of parties to 65535. Attempts to register additional  * parties result in {@code IllegalStateException}. However, you can and  * should create tiered phasers to accommodate arbitrarily large sets  * of participants.  *  * @author Doug Lea  * @since 1.7  */
end_comment

begin_class
DECL|class|Phaser
specifier|public
class|class
name|Phaser
block|{
comment|/*      * This class implements an extension of X10 "clocks".  Thanks to      * Vijay Saraswat for the idea, and to Vivek Sarkar for      * enhancements to extend functionality.      */
comment|/**      * Barrier state representation. Conceptually, a barrier contains      * four values:      *      * * parties -- the number of parties to wait (16 bits)      * * unarrived -- the number of parties yet to hit barrier (16 bits)      * * phase -- the generation of the barrier (31 bits)      * * terminated -- set if barrier is terminated (1 bit)      *      * However, to efficiently maintain atomicity, these values are      * packed into a single (atomic) long. Termination uses the sign      * bit of 32 bit representation of phase, so phase is set to -1 on      * termination. Good performance relies on keeping state decoding      * and encoding simple, and keeping race windows short.      *      * Note: there are some cheats in arrive() that rely on unarrived      * count being lowest 16 bits.      */
DECL|field|state
specifier|private
specifier|volatile
name|long
name|state
decl_stmt|;
DECL|field|ushortMask
specifier|private
specifier|static
specifier|final
name|int
name|ushortMask
init|=
literal|0xffff
decl_stmt|;
DECL|field|phaseMask
specifier|private
specifier|static
specifier|final
name|int
name|phaseMask
init|=
literal|0x7fffffff
decl_stmt|;
DECL|method|unarrivedOf
specifier|private
specifier|static
name|int
name|unarrivedOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|s
operator|&
name|ushortMask
argument_list|)
return|;
block|}
DECL|method|partiesOf
specifier|private
specifier|static
name|int
name|partiesOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
operator|(
operator|(
name|int
operator|)
name|s
operator|)
operator|>>>
literal|16
return|;
block|}
DECL|method|phaseOf
specifier|private
specifier|static
name|int
name|phaseOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
literal|32
argument_list|)
return|;
block|}
DECL|method|arrivedOf
specifier|private
specifier|static
name|int
name|arrivedOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
name|partiesOf
argument_list|(
name|s
argument_list|)
operator|-
name|unarrivedOf
argument_list|(
name|s
argument_list|)
return|;
block|}
DECL|method|stateFor
specifier|private
specifier|static
name|long
name|stateFor
parameter_list|(
name|int
name|phase
parameter_list|,
name|int
name|parties
parameter_list|,
name|int
name|unarrived
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|long
operator|)
name|phase
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|long
operator|)
name|parties
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|long
operator|)
name|unarrived
operator|)
return|;
block|}
DECL|method|trippedStateFor
specifier|private
specifier|static
name|long
name|trippedStateFor
parameter_list|(
name|int
name|phase
parameter_list|,
name|int
name|parties
parameter_list|)
block|{
name|long
name|lp
init|=
operator|(
name|long
operator|)
name|parties
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|long
operator|)
name|phase
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
name|lp
operator|<<
literal|16
operator|)
operator||
name|lp
return|;
block|}
comment|/**      * Returns message string for bad bounds exceptions.      */
DECL|method|badBounds
specifier|private
specifier|static
name|String
name|badBounds
parameter_list|(
name|int
name|parties
parameter_list|,
name|int
name|unarrived
parameter_list|)
block|{
return|return
operator|(
literal|"Attempt to set "
operator|+
name|unarrived
operator|+
literal|" unarrived of "
operator|+
name|parties
operator|+
literal|" parties"
operator|)
return|;
block|}
comment|/**      * The parent of this phaser, or null if none      */
DECL|field|parent
specifier|private
specifier|final
name|Phaser
name|parent
decl_stmt|;
comment|/**      * The root of phaser tree. Equals this if not in a tree.  Used to      * support faster state push-down.      */
DECL|field|root
specifier|private
specifier|final
name|Phaser
name|root
decl_stmt|;
comment|// Wait queues
comment|/**      * Heads of Treiber stacks for waiting threads. To eliminate      * contention while releasing some threads while adding others, we      * use two of them, alternating across even and odd phases.      */
DECL|field|evenQ
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|evenQ
init|=
operator|new
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|oddQ
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|oddQ
init|=
operator|new
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|queueFor
specifier|private
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|queueFor
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
return|return
operator|(
operator|(
name|phase
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|evenQ
else|:
name|oddQ
return|;
block|}
comment|/**      * Returns current state, first resolving lagged propagation from      * root if necessary.      */
DECL|method|getReconciledState
specifier|private
name|long
name|getReconciledState
parameter_list|()
block|{
return|return
operator|(
name|parent
operator|==
literal|null
operator|)
condition|?
name|state
else|:
name|reconcileState
argument_list|()
return|;
block|}
comment|/**      * Recursively resolves state.      */
DECL|method|reconcileState
specifier|private
name|long
name|reconcileState
parameter_list|()
block|{
name|Phaser
name|p
init|=
name|parent
decl_stmt|;
name|long
name|s
init|=
name|state
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
name|unarrivedOf
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|phaseOf
argument_list|(
name|s
argument_list|)
operator|!=
name|phaseOf
argument_list|(
name|root
operator|.
name|state
argument_list|)
condition|)
block|{
name|long
name|parentState
init|=
name|p
operator|.
name|getReconciledState
argument_list|()
decl_stmt|;
name|int
name|parentPhase
init|=
name|phaseOf
argument_list|(
name|parentState
argument_list|)
decl_stmt|;
name|int
name|phase
init|=
name|phaseOf
argument_list|(
name|s
operator|=
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|!=
name|parentPhase
condition|)
block|{
name|long
name|next
init|=
name|trippedStateFor
argument_list|(
name|parentPhase
argument_list|,
name|partiesOf
argument_list|(
name|s
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|casState
argument_list|(
name|s
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
name|s
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**      * Creates a new phaser without any initially registered parties,      * initial phase number 0, and no parent. Any thread using this      * phaser will need to first register for it.      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new phaser with the given numbers of registered      * unarrived parties, initial phase number 0, and no parent.      *      * @param parties the number of parties required to trip barrier      * @throws IllegalArgumentException if parties less than zero      *                                  or greater than the maximum number of parties supported      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|(
name|int
name|parties
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|parties
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new phaser with the given parent, without any      * initially registered parties. If parent is non-null this phaser      * is registered with the parent and its initial phase number is      * the same as that of parent phaser.      *      * @param parent the parent phaser      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|(
name|Phaser
name|parent
parameter_list|)
block|{
name|int
name|phase
init|=
literal|0
decl_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|root
operator|=
name|parent
operator|.
name|root
expr_stmt|;
name|phase
operator|=
name|parent
operator|.
name|register
argument_list|()
expr_stmt|;
block|}
else|else
name|this
operator|.
name|root
operator|=
name|this
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|trippedStateFor
argument_list|(
name|phase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new phaser with the given parent and numbers of      * registered unarrived parties. If parent is non-null, this phaser      * is registered with the parent and its initial phase number is      * the same as that of parent phaser.      *      * @param parent  the parent phaser      * @param parties the number of parties required to trip barrier      * @throws IllegalArgumentException if parties less than zero      *                                  or greater than the maximum number of parties supported      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|(
name|Phaser
name|parent
parameter_list|,
name|int
name|parties
parameter_list|)
block|{
if|if
condition|(
name|parties
argument_list|<
literal|0
operator|||
name|parties
argument_list|>
name|ushortMask
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal number of parties"
argument_list|)
throw|;
name|int
name|phase
init|=
literal|0
decl_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|root
operator|=
name|parent
operator|.
name|root
expr_stmt|;
name|phase
operator|=
name|parent
operator|.
name|register
argument_list|()
expr_stmt|;
block|}
else|else
name|this
operator|.
name|root
operator|=
name|this
expr_stmt|;
name|this
operator|.
name|state
operator|=
name|trippedStateFor
argument_list|(
name|phase
argument_list|,
name|parties
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a new unarrived party to this phaser.      *      * @return the arrival phase number to which this registration applied      * @throws IllegalStateException if attempting to register more      *                               than the maximum supported number of parties      */
DECL|method|register
specifier|public
name|int
name|register
parameter_list|()
block|{
return|return
name|doRegister
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**      * Adds the given number of new unarrived parties to this phaser.      *      * @param parties the number of parties required to trip barrier      * @return the arrival phase number to which this registration applied      * @throws IllegalStateException if attempting to register more      *                               than the maximum supported number of parties      */
DECL|method|bulkRegister
specifier|public
name|int
name|bulkRegister
parameter_list|(
name|int
name|parties
parameter_list|)
block|{
if|if
condition|(
name|parties
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
if|if
condition|(
name|parties
operator|==
literal|0
condition|)
return|return
name|getPhase
argument_list|()
return|;
return|return
name|doRegister
argument_list|(
name|parties
argument_list|)
return|;
block|}
comment|/**      * Shared code for register, bulkRegister      */
DECL|method|doRegister
specifier|private
name|int
name|doRegister
parameter_list|(
name|int
name|registrations
parameter_list|)
block|{
name|int
name|phase
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
init|=
name|getReconciledState
argument_list|()
decl_stmt|;
name|phase
operator|=
name|phaseOf
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|int
name|unarrived
init|=
name|unarrivedOf
argument_list|(
name|s
argument_list|)
operator|+
name|registrations
decl_stmt|;
name|int
name|parties
init|=
name|partiesOf
argument_list|(
name|s
argument_list|)
operator|+
name|registrations
decl_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|parties
operator|>
name|ushortMask
operator|||
name|unarrived
operator|>
name|ushortMask
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|badBounds
argument_list|(
name|parties
argument_list|,
name|unarrived
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|phase
operator|==
name|phaseOf
argument_list|(
name|root
operator|.
name|state
argument_list|)
operator|&&
name|casState
argument_list|(
name|s
argument_list|,
name|stateFor
argument_list|(
name|phase
argument_list|,
name|parties
argument_list|,
name|unarrived
argument_list|)
argument_list|)
condition|)
break|break;
block|}
return|return
name|phase
return|;
block|}
comment|/**      * Arrives at the barrier, but does not wait for others.  (You can      * in turn wait for others via {@link #awaitAdvance}).  It is an      * unenforced usage error for an unregistered party to invoke this      * method.      *      * @return the arrival phase number, or a negative value if terminated      * @throws IllegalStateException if not terminated and the number      *                               of unarrived parties would become negative      */
DECL|method|arrive
specifier|public
name|int
name|arrive
parameter_list|()
block|{
name|int
name|phase
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
init|=
name|state
decl_stmt|;
name|phase
operator|=
name|phaseOf
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
break|break;
name|int
name|parties
init|=
name|partiesOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|unarrived
init|=
name|unarrivedOf
argument_list|(
name|s
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|unarrived
operator|>
literal|0
condition|)
block|{
comment|// Not the last arrival
if|if
condition|(
name|casState
argument_list|(
name|s
argument_list|,
name|s
operator|-
literal|1
argument_list|)
condition|)
comment|// s-1 adds one arrival
break|break;
block|}
elseif|else
if|if
condition|(
name|unarrived
operator|==
literal|0
condition|)
block|{
comment|// the last arrival
name|Phaser
name|par
init|=
name|parent
decl_stmt|;
if|if
condition|(
name|par
operator|==
literal|null
condition|)
block|{
comment|// directly trip
if|if
condition|(
name|casState
argument_list|(
name|s
argument_list|,
name|trippedStateFor
argument_list|(
name|onAdvance
argument_list|(
name|phase
argument_list|,
name|parties
argument_list|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|phase
operator|+
literal|1
operator|)
operator|&
name|phaseMask
operator|)
argument_list|,
name|parties
argument_list|)
argument_list|)
condition|)
block|{
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|// cascade to parent
if|if
condition|(
name|casState
argument_list|(
name|s
argument_list|,
name|s
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// zeroes unarrived
name|par
operator|.
name|arrive
argument_list|()
expr_stmt|;
name|reconcileState
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|phase
operator|!=
name|phaseOf
argument_list|(
name|root
operator|.
name|state
argument_list|)
condition|)
comment|// or if unreconciled
name|reconcileState
argument_list|()
expr_stmt|;
else|else
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|badBounds
argument_list|(
name|parties
argument_list|,
name|unarrived
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|phase
return|;
block|}
comment|/**      * Arrives at the barrier and deregisters from it without waiting      * for others. Deregistration reduces the number of parties      * required to trip the barrier in future phases.  If this phaser      * has a parent, and deregistration causes this phaser to have      * zero parties, this phaser also arrives at and is deregistered      * from its parent.  It is an unenforced usage error for an      * unregistered party to invoke this method.      *      * @return the arrival phase number, or a negative value if terminated      * @throws IllegalStateException if not terminated and the number      *                               of registered or unarrived parties would become negative      */
DECL|method|arriveAndDeregister
specifier|public
name|int
name|arriveAndDeregister
parameter_list|()
block|{
comment|// similar code to arrive, but too different to merge
name|Phaser
name|par
init|=
name|parent
decl_stmt|;
name|int
name|phase
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
init|=
name|state
decl_stmt|;
name|phase
operator|=
name|phaseOf
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
break|break;
name|int
name|parties
init|=
name|partiesOf
argument_list|(
name|s
argument_list|)
operator|-
literal|1
decl_stmt|;
name|int
name|unarrived
init|=
name|unarrivedOf
argument_list|(
name|s
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|parties
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|unarrived
operator|>
literal|0
operator|||
operator|(
name|unarrived
operator|==
literal|0
operator|&&
name|par
operator|!=
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|casState
argument_list|(
name|s
argument_list|,
name|stateFor
argument_list|(
name|phase
argument_list|,
name|parties
argument_list|,
name|unarrived
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|unarrived
operator|==
literal|0
condition|)
block|{
name|par
operator|.
name|arriveAndDeregister
argument_list|()
expr_stmt|;
name|reconcileState
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|unarrived
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|casState
argument_list|(
name|s
argument_list|,
name|trippedStateFor
argument_list|(
name|onAdvance
argument_list|(
name|phase
argument_list|,
name|parties
argument_list|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|phase
operator|+
literal|1
operator|)
operator|&
name|phaseMask
operator|)
argument_list|,
name|parties
argument_list|)
argument_list|)
condition|)
block|{
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|par
operator|!=
literal|null
operator|&&
name|phase
operator|!=
name|phaseOf
argument_list|(
name|root
operator|.
name|state
argument_list|)
condition|)
block|{
name|reconcileState
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|badBounds
argument_list|(
name|parties
argument_list|,
name|unarrived
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|phase
return|;
block|}
comment|/**      * Arrives at the barrier and awaits others. Equivalent in effect      * to {@code awaitAdvance(arrive())}.  If you need to await with      * interruption or timeout, you can arrange this with an analogous      * construction using one of the other forms of the awaitAdvance      * method.  If instead you need to deregister upon arrival use      * {@code arriveAndDeregister}. It is an unenforced usage error      * for an unregistered party to invoke this method.      *      * @return the arrival phase number, or a negative number if terminated      * @throws IllegalStateException if not terminated and the number      *                               of unarrived parties would become negative      */
DECL|method|arriveAndAwaitAdvance
specifier|public
name|int
name|arriveAndAwaitAdvance
parameter_list|()
block|{
return|return
name|awaitAdvance
argument_list|(
name|arrive
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Awaits the phase of the barrier to advance from the given phase      * value, returning immediately if the current phase of the      * barrier is not equal to the given phase value or this barrier      * is terminated.  It is an unenforced usage error for an      * unregistered party to invoke this method.      *      * @param phase an arrival phase number, or negative value if      *              terminated; this argument is normally the value returned by a      *              previous call to {@code arrive} or its variants      * @return the next arrival phase number, or a negative value      *         if terminated or argument is negative      */
DECL|method|awaitAdvance
specifier|public
name|int
name|awaitAdvance
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
name|long
name|s
init|=
name|getReconciledState
argument_list|()
decl_stmt|;
name|int
name|p
init|=
name|phaseOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|phase
condition|)
return|return
name|p
return|;
if|if
condition|(
name|unarrivedOf
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|parent
operator|!=
literal|null
condition|)
name|parent
operator|.
name|awaitAdvance
argument_list|(
name|phase
argument_list|)
expr_stmt|;
comment|// Fall here even if parent waited, to reconcile and help release
return|return
name|untimedWait
argument_list|(
name|phase
argument_list|)
return|;
block|}
comment|/**      * Awaits the phase of the barrier to advance from the given phase      * value, throwing {@code InterruptedException} if interrupted      * while waiting, or returning immediately if the current phase of      * the barrier is not equal to the given phase value or this      * barrier is terminated. It is an unenforced usage error for an      * unregistered party to invoke this method.      *      * @param phase an arrival phase number, or negative value if      *              terminated; this argument is normally the value returned by a      *              previous call to {@code arrive} or its variants      * @return the next arrival phase number, or a negative value      *         if terminated or argument is negative      * @throws InterruptedException if thread interrupted while waiting      */
DECL|method|awaitAdvanceInterruptibly
specifier|public
name|int
name|awaitAdvanceInterruptibly
parameter_list|(
name|int
name|phase
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
name|long
name|s
init|=
name|getReconciledState
argument_list|()
decl_stmt|;
name|int
name|p
init|=
name|phaseOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|phase
condition|)
return|return
name|p
return|;
if|if
condition|(
name|unarrivedOf
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|parent
operator|!=
literal|null
condition|)
name|parent
operator|.
name|awaitAdvanceInterruptibly
argument_list|(
name|phase
argument_list|)
expr_stmt|;
return|return
name|interruptibleWait
argument_list|(
name|phase
argument_list|)
return|;
block|}
comment|/**      * Awaits the phase of the barrier to advance from the given phase      * value or the given timeout to elapse, throwing {@code      * InterruptedException} if interrupted while waiting, or      * returning immediately if the current phase of the barrier is      * not equal to the given phase value or this barrier is      * terminated.  It is an unenforced usage error for an      * unregistered party to invoke this method.      *      * @param phase   an arrival phase number, or negative value if      *                terminated; this argument is normally the value returned by a      *                previous call to {@code arrive} or its variants      * @param timeout how long to wait before giving up, in units of      *                {@code unit}      * @param unit    a {@code TimeUnit} determining how to interpret the      *                {@code timeout} parameter      * @return the next arrival phase number, or a negative value      *         if terminated or argument is negative      * @throws InterruptedException if thread interrupted while waiting      * @throws TimeoutException     if timed out while waiting      */
DECL|method|awaitAdvanceInterruptibly
specifier|public
name|int
name|awaitAdvanceInterruptibly
parameter_list|(
name|int
name|phase
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
name|long
name|s
init|=
name|getReconciledState
argument_list|()
decl_stmt|;
name|int
name|p
init|=
name|phaseOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|phase
condition|)
return|return
name|p
return|;
if|if
condition|(
name|unarrivedOf
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|&&
name|parent
operator|!=
literal|null
condition|)
name|parent
operator|.
name|awaitAdvanceInterruptibly
argument_list|(
name|phase
argument_list|,
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|timedWait
argument_list|(
name|phase
argument_list|,
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Forces this barrier to enter termination state. Counts of      * arrived and registered parties are unaffected. If this phaser      * has a parent, it too is terminated. This method may be useful      * for coordinating recovery after one or more tasks encounter      * unexpected exceptions.      */
DECL|method|forceTermination
specifier|public
name|void
name|forceTermination
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
init|=
name|getReconciledState
argument_list|()
decl_stmt|;
name|int
name|phase
init|=
name|phaseOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|parties
init|=
name|partiesOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|unarrived
init|=
name|unarrivedOf
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
operator|||
name|casState
argument_list|(
name|s
argument_list|,
name|stateFor
argument_list|(
operator|-
literal|1
argument_list|,
name|parties
argument_list|,
name|unarrived
argument_list|)
argument_list|)
condition|)
block|{
name|releaseWaiters
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|releaseWaiters
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
name|parent
operator|.
name|forceTermination
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/**      * Returns the current phase number. The maximum phase number is      * {@code Integer.MAX_VALUE}, after which it restarts at      * zero. Upon termination, the phase number is negative.      *      * @return the phase number, or a negative value if terminated      */
DECL|method|getPhase
specifier|public
specifier|final
name|int
name|getPhase
parameter_list|()
block|{
return|return
name|phaseOf
argument_list|(
name|getReconciledState
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the number of parties registered at this barrier.      *      * @return the number of parties      */
DECL|method|getRegisteredParties
specifier|public
name|int
name|getRegisteredParties
parameter_list|()
block|{
return|return
name|partiesOf
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**      * Returns the number of registered parties that have arrived at      * the current phase of this barrier.      *      * @return the number of arrived parties      */
DECL|method|getArrivedParties
specifier|public
name|int
name|getArrivedParties
parameter_list|()
block|{
return|return
name|arrivedOf
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**      * Returns the number of registered parties that have not yet      * arrived at the current phase of this barrier.      *      * @return the number of unarrived parties      */
DECL|method|getUnarrivedParties
specifier|public
name|int
name|getUnarrivedParties
parameter_list|()
block|{
return|return
name|unarrivedOf
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**      * Returns the parent of this phaser, or {@code null} if none.      *      * @return the parent of this phaser, or {@code null} if none      */
DECL|method|getParent
specifier|public
name|Phaser
name|getParent
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
comment|/**      * Returns the root ancestor of this phaser, which is the same as      * this phaser if it has no parent.      *      * @return the root ancestor of this phaser      */
DECL|method|getRoot
specifier|public
name|Phaser
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
comment|/**      * Returns {@code true} if this barrier has been terminated.      *      * @return {@code true} if this barrier has been terminated      */
DECL|method|isTerminated
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
return|return
name|getPhase
argument_list|()
operator|<
literal|0
return|;
block|}
comment|/**      * Overridable method to perform an action upon impending phase      * advance, and to control termination. This method is invoked      * upon arrival of the party tripping the barrier (when all other      * waiting parties are dormant).  If this method returns {@code      * true}, then, rather than advance the phase number, this barrier      * will be set to a final termination state, and subsequent calls      * to {@link #isTerminated} will return true. Any (unchecked)      * Exception or Error thrown by an invocation of this method is      * propagated to the party attempting to trip the barrier, in      * which case no advance occurs.      *      *<p>The arguments to this method provide the state of the phaser      * prevailing for the current transition. (When called from within      * an implementation of {@code onAdvance} the values returned by      * methods such as {@code getPhase} may or may not reliably      * indicate the state to which this transition applies.)      *      *<p>The default version returns {@code true} when the number of      * registered parties is zero. Normally, overrides that arrange      * termination for other reasons should also preserve this      * property.      *      *<p>You may override this method to perform an action with side      * effects visible to participating tasks, but it is only sensible      * to do so in designs where all parties register before any      * arrive, and all {@link #awaitAdvance} at each phase.      * Otherwise, you cannot ensure lack of interference from other      * parties during the invocation of this method. Additionally,      * method {@code onAdvance} may be invoked more than once per      * transition if registrations are intermixed with arrivals.      *      * @param phase             the phase number on entering the barrier      * @param registeredParties the current number of registered parties      * @return {@code true} if this barrier should terminate      */
DECL|method|onAdvance
specifier|protected
name|boolean
name|onAdvance
parameter_list|(
name|int
name|phase
parameter_list|,
name|int
name|registeredParties
parameter_list|)
block|{
return|return
name|registeredParties
operator|<=
literal|0
return|;
block|}
comment|/**      * Returns a string identifying this phaser, as well as its      * state.  The state, in brackets, includes the String {@code      * "phase = "} followed by the phase number, {@code "parties = "}      * followed by the number of registered parties, and {@code      * "arrived = "} followed by the number of arrived parties.      *      * @return a string identifying this barrier, as well as its state      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|long
name|s
init|=
name|getReconciledState
argument_list|()
decl_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"[phase = "
operator|+
name|phaseOf
argument_list|(
name|s
argument_list|)
operator|+
literal|" parties = "
operator|+
name|partiesOf
argument_list|(
name|s
argument_list|)
operator|+
literal|" arrived = "
operator|+
name|arrivedOf
argument_list|(
name|s
argument_list|)
operator|+
literal|"]"
return|;
block|}
comment|// methods for waiting
comment|/**      * Wait nodes for Treiber stack representing wait queue      */
DECL|class|QNode
specifier|static
specifier|final
class|class
name|QNode
implements|implements
name|ForkJoinPool
operator|.
name|ManagedBlocker
block|{
DECL|field|phaser
specifier|final
name|Phaser
name|phaser
decl_stmt|;
DECL|field|phase
specifier|final
name|int
name|phase
decl_stmt|;
DECL|field|startTime
specifier|final
name|long
name|startTime
decl_stmt|;
DECL|field|nanos
specifier|final
name|long
name|nanos
decl_stmt|;
DECL|field|timed
specifier|final
name|boolean
name|timed
decl_stmt|;
DECL|field|interruptible
specifier|final
name|boolean
name|interruptible
decl_stmt|;
DECL|field|wasInterrupted
specifier|volatile
name|boolean
name|wasInterrupted
init|=
literal|false
decl_stmt|;
DECL|field|thread
specifier|volatile
name|Thread
name|thread
decl_stmt|;
comment|// nulled to cancel wait
DECL|field|next
name|QNode
name|next
decl_stmt|;
DECL|method|QNode
name|QNode
parameter_list|(
name|Phaser
name|phaser
parameter_list|,
name|int
name|phase
parameter_list|,
name|boolean
name|interruptible
parameter_list|,
name|boolean
name|timed
parameter_list|,
name|long
name|startTime
parameter_list|,
name|long
name|nanos
parameter_list|)
block|{
name|this
operator|.
name|phaser
operator|=
name|phaser
expr_stmt|;
name|this
operator|.
name|phase
operator|=
name|phase
expr_stmt|;
name|this
operator|.
name|timed
operator|=
name|timed
expr_stmt|;
name|this
operator|.
name|interruptible
operator|=
name|interruptible
expr_stmt|;
name|this
operator|.
name|startTime
operator|=
name|startTime
expr_stmt|;
name|this
operator|.
name|nanos
operator|=
name|nanos
expr_stmt|;
name|thread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
block|}
DECL|method|isReleasable
specifier|public
name|boolean
name|isReleasable
parameter_list|()
block|{
return|return
operator|(
name|thread
operator|==
literal|null
operator|||
name|phaser
operator|.
name|getPhase
argument_list|()
operator|!=
name|phase
operator|||
operator|(
name|interruptible
operator|&&
name|wasInterrupted
operator|)
operator|||
operator|(
name|timed
operator|&&
operator|(
name|nanos
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
operator|)
operator|<=
literal|0
operator|)
operator|)
return|;
block|}
DECL|method|block
specifier|public
name|boolean
name|block
parameter_list|()
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|wasInterrupted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|interruptible
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|timed
condition|)
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
block|{
name|long
name|waitTime
init|=
name|nanos
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
decl_stmt|;
if|if
condition|(
name|waitTime
operator|<=
literal|0
condition|)
return|return
literal|true
return|;
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|waitTime
argument_list|)
expr_stmt|;
block|}
return|return
name|isReleasable
argument_list|()
return|;
block|}
DECL|method|signal
name|void
name|signal
parameter_list|()
block|{
name|Thread
name|t
init|=
name|thread
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|doWait
name|boolean
name|doWait
parameter_list|()
block|{
if|if
condition|(
name|thread
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|ForkJoinPool
operator|.
name|managedBlock
argument_list|(
name|this
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{                 }
block|}
return|return
name|wasInterrupted
return|;
block|}
block|}
comment|/**      * Removes and signals waiting threads from wait queue.      */
DECL|method|releaseWaiters
specifier|private
name|void
name|releaseWaiters
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|head
init|=
name|queueFor
argument_list|(
name|phase
argument_list|)
decl_stmt|;
name|QNode
name|q
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|head
operator|.
name|get
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|head
operator|.
name|compareAndSet
argument_list|(
name|q
argument_list|,
name|q
operator|.
name|next
argument_list|)
condition|)
name|q
operator|.
name|signal
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Tries to enqueue given node in the appropriate wait queue.      *      * @return true if successful      */
DECL|method|tryEnqueue
specifier|private
name|boolean
name|tryEnqueue
parameter_list|(
name|QNode
name|node
parameter_list|)
block|{
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|head
init|=
name|queueFor
argument_list|(
name|node
operator|.
name|phase
argument_list|)
decl_stmt|;
return|return
name|head
operator|.
name|compareAndSet
argument_list|(
name|node
operator|.
name|next
operator|=
name|head
operator|.
name|get
argument_list|()
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/**      * Enqueues node and waits unless aborted or signalled.      *      * @return current phase      */
DECL|method|untimedWait
specifier|private
name|int
name|untimedWait
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
name|QNode
name|node
init|=
literal|null
decl_stmt|;
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
name|int
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|getPhase
argument_list|()
operator|)
operator|==
name|phase
condition|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
name|interrupted
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|node
operator|=
operator|new
name|QNode
argument_list|(
name|this
argument_list|,
name|phase
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
name|queued
operator|=
name|tryEnqueue
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|interrupted
operator|=
name|node
operator|.
name|doWait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**      * Interruptible version      *      * @return current phase      */
DECL|method|interruptibleWait
specifier|private
name|int
name|interruptibleWait
parameter_list|(
name|int
name|phase
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|QNode
name|node
init|=
literal|null
decl_stmt|;
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
name|int
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|getPhase
argument_list|()
operator|)
operator|==
name|phase
operator|&&
operator|!
name|interrupted
condition|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
name|interrupted
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|node
operator|=
operator|new
name|QNode
argument_list|(
name|this
argument_list|,
name|phase
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
name|queued
operator|=
name|tryEnqueue
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|interrupted
operator|=
name|node
operator|.
name|doWait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|phase
operator|||
operator|(
name|p
operator|=
name|getPhase
argument_list|()
operator|)
operator|!=
name|phase
condition|)
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
return|return
name|p
return|;
block|}
comment|/**      * Timeout version.      *      * @return current phase      */
DECL|method|timedWait
specifier|private
name|int
name|timedWait
parameter_list|(
name|int
name|phase
parameter_list|,
name|long
name|nanos
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|QNode
name|node
init|=
literal|null
decl_stmt|;
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
name|int
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|getPhase
argument_list|()
operator|)
operator|==
name|phase
operator|&&
operator|!
name|interrupted
condition|)
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
name|interrupted
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|nanos
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
operator|<=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|node
operator|=
operator|new
name|QNode
argument_list|(
name|this
argument_list|,
name|phase
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|startTime
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
name|queued
operator|=
name|tryEnqueue
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|interrupted
operator|=
name|node
operator|.
name|doWait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|phase
operator|||
operator|(
name|p
operator|=
name|getPhase
argument_list|()
operator|)
operator|!=
name|phase
condition|)
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
if|if
condition|(
name|interrupted
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
if|if
condition|(
name|p
operator|==
name|phase
condition|)
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
return|return
name|p
return|;
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
init|=
name|getUnsafe
argument_list|()
decl_stmt|;
DECL|field|stateOffset
specifier|private
specifier|static
specifier|final
name|long
name|stateOffset
init|=
name|objectFieldOffset
argument_list|(
literal|"state"
argument_list|,
name|Phaser
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|casState
specifier|private
specifier|final
name|boolean
name|casState
parameter_list|(
name|long
name|cmp
parameter_list|,
name|long
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|objectFieldOffset
specifier|private
specifier|static
name|long
name|objectFieldOffset
parameter_list|(
name|String
name|field
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|klazz
parameter_list|)
block|{
try|try
block|{
return|return
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|klazz
operator|.
name|getDeclaredField
argument_list|(
name|field
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
name|e
parameter_list|)
block|{
comment|// Convert Exception to corresponding Error
name|NoSuchFieldError
name|error
init|=
operator|new
name|NoSuchFieldError
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|error
operator|.
name|initCause
argument_list|(
name|e
argument_list|)
expr_stmt|;
throw|throw
name|error
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

