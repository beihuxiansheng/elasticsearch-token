begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.yaml.snakeyaml.constructor
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|constructor
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|TypeDescription
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|error
operator|.
name|YAMLException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|introspector
operator|.
name|FieldProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|introspector
operator|.
name|MethodProperty
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|introspector
operator|.
name|Property
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|nodes
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|IntrospectionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|Introspector
import|;
end_import

begin_import
import|import
name|java
operator|.
name|beans
operator|.
name|PropertyDescriptor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Construct a custom Java instance.  */
end_comment

begin_class
DECL|class|Constructor
specifier|public
class|class
name|Constructor
extends|extends
name|SafeConstructor
block|{
DECL|field|typeTags
specifier|private
specifier|final
name|Map
argument_list|<
name|Tag
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
argument_list|>
name|typeTags
decl_stmt|;
DECL|field|typeDefinitions
specifier|private
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
argument_list|,
name|TypeDescription
argument_list|>
name|typeDefinitions
decl_stmt|;
DECL|method|Constructor
specifier|public
name|Constructor
parameter_list|()
block|{
name|this
argument_list|(
name|Object
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create Constructor for the specified class as the root.      *      * @param theRoot - the class (usually JavaBean) to be constructed      */
DECL|method|Constructor
specifier|public
name|Constructor
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|theRoot
parameter_list|)
block|{
if|if
condition|(
name|theRoot
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Root type must be provided."
argument_list|)
throw|;
block|}
name|this
operator|.
name|yamlConstructors
operator|.
name|put
argument_list|(
literal|null
argument_list|,
operator|new
name|ConstructYamlObject
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Object
operator|.
name|class
operator|.
name|equals
argument_list|(
name|theRoot
argument_list|)
condition|)
block|{
name|rootTag
operator|=
operator|new
name|Tag
argument_list|(
name|theRoot
argument_list|)
expr_stmt|;
block|}
name|typeTags
operator|=
operator|new
name|HashMap
argument_list|<
name|Tag
argument_list|,
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|typeDefinitions
operator|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
argument_list|,
name|TypeDescription
argument_list|>
argument_list|()
expr_stmt|;
name|yamlClassConstructors
operator|.
name|put
argument_list|(
name|NodeId
operator|.
name|scalar
argument_list|,
operator|new
name|ConstructScalar
argument_list|()
argument_list|)
expr_stmt|;
name|yamlClassConstructors
operator|.
name|put
argument_list|(
name|NodeId
operator|.
name|mapping
argument_list|,
operator|new
name|ConstructMapping
argument_list|()
argument_list|)
expr_stmt|;
name|yamlClassConstructors
operator|.
name|put
argument_list|(
name|NodeId
operator|.
name|sequence
argument_list|,
operator|new
name|ConstructSequence
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Create Constructor for a class which does not have to be in the classpath      * or for a definition from a Spring ApplicationContext.      *      * @param theRoot fully qualified class name of the root class (usually      *                JavaBean)      * @throws ClassNotFoundException      */
DECL|method|Constructor
specifier|public
name|Constructor
parameter_list|(
name|String
name|theRoot
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
name|this
argument_list|(
name|Class
operator|.
name|forName
argument_list|(
name|check
argument_list|(
name|theRoot
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|check
specifier|private
specifier|static
specifier|final
name|String
name|check
parameter_list|(
name|String
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"Root type must be provided."
argument_list|)
throw|;
block|}
if|if
condition|(
name|s
operator|.
name|trim
argument_list|()
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Root type must be provided."
argument_list|)
throw|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Make YAML aware how to parse a custom Class. If there is no root Class      * assigned in constructor then the 'root' property of this definition is      * respected.      *      * @param definition to be added to the Constructor      * @return the previous value associated with<tt>definition</tt>, or      *<tt>null</tt> if there was no mapping for<tt>definition</tt>.      */
DECL|method|addTypeDescription
specifier|public
name|TypeDescription
name|addTypeDescription
parameter_list|(
name|TypeDescription
name|definition
parameter_list|)
block|{
if|if
condition|(
name|definition
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|(
literal|"TypeDescription is required."
argument_list|)
throw|;
block|}
if|if
condition|(
name|rootTag
operator|==
literal|null
operator|&&
name|definition
operator|.
name|isRoot
argument_list|()
condition|)
block|{
name|rootTag
operator|=
operator|new
name|Tag
argument_list|(
name|definition
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Tag
name|tag
init|=
name|definition
operator|.
name|getTag
argument_list|()
decl_stmt|;
name|typeTags
operator|.
name|put
argument_list|(
name|tag
argument_list|,
name|definition
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|typeDefinitions
operator|.
name|put
argument_list|(
name|definition
operator|.
name|getType
argument_list|()
argument_list|,
name|definition
argument_list|)
return|;
block|}
comment|/**      * Construct mapping instance (Map, JavaBean) when the runtime class is      * known.      */
DECL|class|ConstructMapping
specifier|private
class|class
name|ConstructMapping
implements|implements
name|Construct
block|{
DECL|field|propertiesCache
specifier|private
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Property
argument_list|>
argument_list|>
name|propertiesCache
init|=
operator|new
name|HashMap
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|Property
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**          * Construct JavaBean. If type safe collections are used please look at          *<code>TypeDescription</code>.          *          * @param node node where the keys are property names (they can only be          *<code>String</code>s) and values are objects to be created          * @return constructed JavaBean          */
DECL|method|construct
specifier|public
name|Object
name|construct
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|MappingNode
name|mnode
init|=
operator|(
name|MappingNode
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|Properties
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|Properties
name|properties
init|=
operator|new
name|Properties
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|isTwoStepsConstruction
argument_list|()
condition|)
block|{
name|constructMapping2ndStep
argument_list|(
name|mnode
argument_list|,
operator|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
operator|)
name|properties
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Properties must not be recursive."
argument_list|)
throw|;
block|}
return|return
name|properties
return|;
block|}
elseif|else
if|if
condition|(
name|SortedMap
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|SortedMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|TreeMap
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|isTwoStepsConstruction
argument_list|()
condition|)
block|{
name|constructMapping2ndStep
argument_list|(
name|mnode
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isTwoStepsConstruction
argument_list|()
condition|)
block|{
return|return
name|createDefaultMap
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|constructMapping
argument_list|(
name|mnode
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|SortedSet
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|SortedSet
argument_list|<
name|Object
argument_list|>
name|set
init|=
operator|new
name|TreeSet
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|isTwoStepsConstruction
argument_list|()
condition|)
block|{
name|constructSet2ndStep
argument_list|(
name|mnode
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
elseif|else
if|if
condition|(
name|Set
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isTwoStepsConstruction
argument_list|()
condition|)
block|{
return|return
name|createDefaultSet
argument_list|()
return|;
block|}
else|else
block|{
return|return
name|constructSet
argument_list|(
name|mnode
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|node
operator|.
name|isTwoStepsConstruction
argument_list|()
condition|)
block|{
return|return
name|createEmptyJavaBean
argument_list|(
name|mnode
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|constructJavaBean2ndStep
argument_list|(
name|mnode
argument_list|,
name|createEmptyJavaBean
argument_list|(
name|mnode
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|construct2ndStep
specifier|public
name|void
name|construct2ndStep
parameter_list|(
name|Node
name|node
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|constructMapping2ndStep
argument_list|(
operator|(
name|MappingNode
operator|)
name|node
argument_list|,
operator|(
name|Map
argument_list|<
name|Object
argument_list|,
name|Object
argument_list|>
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Set
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|constructSet2ndStep
argument_list|(
operator|(
name|MappingNode
operator|)
name|node
argument_list|,
operator|(
name|Set
argument_list|<
name|Object
argument_list|>
operator|)
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|constructJavaBean2ndStep
argument_list|(
operator|(
name|MappingNode
operator|)
name|node
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|createEmptyJavaBean
specifier|private
name|Object
name|createEmptyJavaBean
parameter_list|(
name|MappingNode
name|node
parameter_list|)
block|{
try|try
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|type
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
if|if
condition|(
name|Modifier
operator|.
name|isAbstract
argument_list|(
name|type
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|node
operator|.
name|setType
argument_list|(
name|getClassForNode
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**                  * Using only default constructor. Everything else will be                  * initialized on 2nd step. If we do here some partial                  * initialization, how do we then track what need to be done on                  * 2nd step? I think it is better to get only object here (to                  * have it as reference for recursion) and do all other thing on                  * 2nd step.                  */
return|return
name|node
operator|.
name|getType
argument_list|()
operator|.
name|newInstance
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|IllegalAccessException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|constructJavaBean2ndStep
specifier|private
name|Object
name|constructJavaBean2ndStep
parameter_list|(
name|MappingNode
name|node
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|beanType
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|NodeTuple
argument_list|>
name|nodeValue
init|=
operator|(
name|List
argument_list|<
name|NodeTuple
argument_list|>
operator|)
name|node
operator|.
name|getValue
argument_list|()
decl_stmt|;
for|for
control|(
name|NodeTuple
name|tuple
range|:
name|nodeValue
control|)
block|{
name|ScalarNode
name|keyNode
decl_stmt|;
if|if
condition|(
name|tuple
operator|.
name|getKeyNode
argument_list|()
operator|instanceof
name|ScalarNode
condition|)
block|{
comment|// key must be scalar
name|keyNode
operator|=
operator|(
name|ScalarNode
operator|)
name|tuple
operator|.
name|getKeyNode
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Keys must be scalars but found: "
operator|+
name|tuple
operator|.
name|getKeyNode
argument_list|()
argument_list|)
throw|;
block|}
name|Node
name|valueNode
init|=
name|tuple
operator|.
name|getValueNode
argument_list|()
decl_stmt|;
comment|// keys can only be Strings
name|keyNode
operator|.
name|setType
argument_list|(
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|String
name|key
init|=
operator|(
name|String
operator|)
name|constructObject
argument_list|(
name|keyNode
argument_list|)
decl_stmt|;
name|boolean
name|isArray
init|=
literal|false
decl_stmt|;
try|try
block|{
name|Property
name|property
init|=
name|getProperty
argument_list|(
name|beanType
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|valueNode
operator|.
name|setType
argument_list|(
name|property
operator|.
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|property
operator|.
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|isArray
operator|=
literal|true
expr_stmt|;
block|}
name|TypeDescription
name|memberDescription
init|=
name|typeDefinitions
operator|.
name|get
argument_list|(
name|beanType
argument_list|)
decl_stmt|;
name|boolean
name|typeDetected
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|memberDescription
operator|!=
literal|null
condition|)
block|{
switch|switch
condition|(
name|valueNode
operator|.
name|getNodeId
argument_list|()
condition|)
block|{
case|case
name|sequence
case|:
name|SequenceNode
name|snode
init|=
operator|(
name|SequenceNode
operator|)
name|valueNode
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|memberType
init|=
name|memberDescription
operator|.
name|getListPropertyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|memberType
operator|!=
literal|null
condition|)
block|{
name|snode
operator|.
name|setListType
argument_list|(
name|memberType
argument_list|)
expr_stmt|;
name|typeDetected
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
operator|.
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
name|isArray
operator|=
literal|true
expr_stmt|;
name|snode
operator|.
name|setListType
argument_list|(
name|property
operator|.
name|getType
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|)
expr_stmt|;
name|typeDetected
operator|=
literal|true
expr_stmt|;
block|}
break|break;
case|case
name|mapping
case|:
name|MappingNode
name|mnode
init|=
operator|(
name|MappingNode
operator|)
name|valueNode
decl_stmt|;
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|keyType
init|=
name|memberDescription
operator|.
name|getMapKeyType
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|keyType
operator|!=
literal|null
condition|)
block|{
name|mnode
operator|.
name|setKeyType
argument_list|(
name|keyType
argument_list|)
expr_stmt|;
name|mnode
operator|.
name|setValueType
argument_list|(
name|memberDescription
operator|.
name|getMapValueType
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|typeDetected
operator|=
literal|true
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|typeDetected
operator|&&
name|valueNode
operator|.
name|getNodeId
argument_list|()
operator|!=
name|NodeId
operator|.
name|scalar
condition|)
block|{
comment|// only if there is no explicit TypeDescription
name|Type
index|[]
name|arguments
init|=
name|property
operator|.
name|getActualTypeArguments
argument_list|()
decl_stmt|;
if|if
condition|(
name|arguments
operator|!=
literal|null
condition|)
block|{
comment|// type safe (generic) collection may contain the
comment|// proper class
if|if
condition|(
name|valueNode
operator|.
name|getNodeId
argument_list|()
operator|==
name|NodeId
operator|.
name|sequence
condition|)
block|{
name|Class
name|t
init|=
operator|(
name|Class
operator|)
name|arguments
index|[
literal|0
index|]
decl_stmt|;
name|SequenceNode
name|snode
init|=
operator|(
name|SequenceNode
operator|)
name|valueNode
decl_stmt|;
name|snode
operator|.
name|setListType
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valueNode
operator|.
name|getTag
argument_list|()
operator|.
name|equals
argument_list|(
name|Tag
operator|.
name|SET
argument_list|)
condition|)
block|{
name|Class
name|t
init|=
operator|(
name|Class
operator|)
name|arguments
index|[
literal|0
index|]
decl_stmt|;
name|MappingNode
name|mnode
init|=
operator|(
name|MappingNode
operator|)
name|valueNode
decl_stmt|;
name|mnode
operator|.
name|setKeyType
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|mnode
operator|.
name|setUseClassConstructor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|valueNode
operator|.
name|getNodeId
argument_list|()
operator|==
name|NodeId
operator|.
name|mapping
condition|)
block|{
name|Class
name|ketType
init|=
operator|(
name|Class
operator|)
name|arguments
index|[
literal|0
index|]
decl_stmt|;
name|Class
name|valueType
init|=
operator|(
name|Class
operator|)
name|arguments
index|[
literal|1
index|]
decl_stmt|;
name|MappingNode
name|mnode
init|=
operator|(
name|MappingNode
operator|)
name|valueNode
decl_stmt|;
name|mnode
operator|.
name|setKeyType
argument_list|(
name|ketType
argument_list|)
expr_stmt|;
name|mnode
operator|.
name|setValueType
argument_list|(
name|valueType
argument_list|)
expr_stmt|;
name|mnode
operator|.
name|setUseClassConstructor
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Object
name|value
init|=
name|constructObject
argument_list|(
name|valueNode
argument_list|)
decl_stmt|;
if|if
condition|(
name|isArray
operator|&&
name|value
operator|instanceof
name|List
condition|)
block|{
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|value
decl_stmt|;
name|value
operator|=
name|list
operator|.
name|toArray
argument_list|(
name|createArray
argument_list|(
name|property
operator|.
name|getType
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|property
operator|.
name|set
argument_list|(
name|object
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Cannot create property="
operator|+
name|key
operator|+
literal|" for JavaBean="
operator|+
name|object
operator|+
literal|"; "
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|object
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|createArray
specifier|private
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|createArray
parameter_list|(
name|Class
argument_list|<
name|T
argument_list|>
name|type
parameter_list|)
block|{
return|return
operator|(
name|T
index|[]
operator|)
name|Array
operator|.
name|newInstance
argument_list|(
name|type
operator|.
name|getComponentType
argument_list|()
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|getProperty
specifier|private
name|Property
name|getProperty
parameter_list|(
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|type
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|IntrospectionException
block|{
comment|// check cache
name|Map
argument_list|<
name|String
argument_list|,
name|Property
argument_list|>
name|properties
init|=
name|propertiesCache
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|properties
operator|==
literal|null
condition|)
block|{
name|properties
operator|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|Property
argument_list|>
argument_list|()
expr_stmt|;
name|propertiesCache
operator|.
name|put
argument_list|(
name|type
argument_list|,
name|properties
argument_list|)
expr_stmt|;
for|for
control|(
name|PropertyDescriptor
name|property
range|:
name|Introspector
operator|.
name|getBeanInfo
argument_list|(
name|type
argument_list|)
operator|.
name|getPropertyDescriptors
argument_list|()
control|)
block|{
name|String
name|methodName
init|=
name|property
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|property
operator|.
name|getWriteMethod
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|properties
operator|.
name|put
argument_list|(
name|methodName
argument_list|,
operator|new
name|MethodProperty
argument_list|(
name|property
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Field
name|field
range|:
name|type
operator|.
name|getFields
argument_list|()
control|)
block|{
name|int
name|modifiers
init|=
name|field
operator|.
name|getModifiers
argument_list|()
decl_stmt|;
if|if
condition|(
name|Modifier
operator|.
name|isStatic
argument_list|(
name|modifiers
argument_list|)
operator|||
name|Modifier
operator|.
name|isTransient
argument_list|(
name|modifiers
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|properties
operator|.
name|put
argument_list|(
name|field
operator|.
name|getName
argument_list|()
argument_list|,
operator|new
name|FieldProperty
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// take from cache
name|Property
name|property
init|=
name|properties
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|property
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Unable to find property '"
operator|+
name|name
operator|+
literal|"' on class: "
operator|+
name|type
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|property
return|;
block|}
block|}
block|}
comment|/**      * Construct an instance when the runtime class is not known but a global      * tag with a class name is defined. It delegates the construction to the      * appropriate constructor based on the node kind (scalar, sequence,      * mapping)      */
DECL|class|ConstructYamlObject
specifier|private
class|class
name|ConstructYamlObject
implements|implements
name|Construct
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|getConstructor
specifier|private
name|Construct
name|getConstructor
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|Class
name|cl
init|=
name|getClassForNode
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|node
operator|.
name|setType
argument_list|(
name|cl
argument_list|)
expr_stmt|;
comment|// call the constructor as if the runtime class is defined
name|Construct
name|constructor
init|=
name|yamlClassConstructors
operator|.
name|get
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|constructor
return|;
block|}
DECL|method|construct
specifier|public
name|Object
name|construct
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|Object
name|result
init|=
literal|null
decl_stmt|;
try|try
block|{
name|result
operator|=
name|getConstructor
argument_list|(
name|node
argument_list|)
operator|.
name|construct
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConstructorException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"Can't construct a java object for "
operator|+
name|node
operator|.
name|getTag
argument_list|()
operator|+
literal|"; exception="
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|node
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
DECL|method|construct2ndStep
specifier|public
name|void
name|construct2ndStep
parameter_list|(
name|Node
name|node
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
try|try
block|{
name|getConstructor
argument_list|(
name|node
argument_list|)
operator|.
name|construct2ndStep
argument_list|(
name|node
argument_list|,
name|object
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConstructorException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"Can't construct a second step for a java object for "
operator|+
name|node
operator|.
name|getTag
argument_list|()
operator|+
literal|"; exception="
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|node
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Construct scalar instance when the runtime class is known. Recursive      * structures are not supported.      */
DECL|class|ConstructScalar
specifier|protected
class|class
name|ConstructScalar
extends|extends
name|AbstractConstruct
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|construct
specifier|public
name|Object
name|construct
parameter_list|(
name|Node
name|nnode
parameter_list|)
block|{
name|ScalarNode
name|node
init|=
operator|(
name|ScalarNode
operator|)
name|nnode
decl_stmt|;
name|Class
name|type
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
name|Object
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isPrimitive
argument_list|()
operator|||
name|type
operator|==
name|String
operator|.
name|class
operator|||
name|Number
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|==
name|Boolean
operator|.
name|class
operator|||
name|Date
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
operator|||
name|type
operator|==
name|Character
operator|.
name|class
operator|||
name|type
operator|==
name|BigInteger
operator|.
name|class
operator|||
name|type
operator|==
name|BigDecimal
operator|.
name|class
operator|||
name|Enum
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
operator|||
name|Tag
operator|.
name|BINARY
operator|.
name|equals
argument_list|(
name|node
operator|.
name|getTag
argument_list|()
argument_list|)
operator|||
name|Calendar
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// standard classes created directly
name|result
operator|=
name|constructStandardJavaInstance
argument_list|(
name|type
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// there must be only 1 constructor with 1 argument
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
index|[]
name|javaConstructors
init|=
name|type
operator|.
name|getConstructors
argument_list|()
decl_stmt|;
name|int
name|oneArgCount
init|=
literal|0
decl_stmt|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|javaConstructor
init|=
literal|null
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|c
range|:
name|javaConstructors
control|)
block|{
if|if
condition|(
name|c
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|oneArgCount
operator|++
expr_stmt|;
name|javaConstructor
operator|=
name|c
expr_stmt|;
block|}
block|}
name|Object
name|argument
decl_stmt|;
if|if
condition|(
name|javaConstructor
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"No single argument constructor found for "
operator|+
name|type
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|oneArgCount
operator|==
literal|1
condition|)
block|{
name|argument
operator|=
name|constructStandardJavaInstance
argument_list|(
name|javaConstructor
operator|.
name|getParameterTypes
argument_list|()
index|[
literal|0
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// TODO it should be possible to use implicit types instead
comment|// of forcing String. Resolver must be available here to
comment|// obtain the implicit tag. Then we can set the tag and call
comment|// callConstructor(node) to create the argument instance.
comment|// On the other hand it may be safer to require a custom
comment|// constructor to avoid guessing the argument class
name|argument
operator|=
name|constructScalar
argument_list|(
name|node
argument_list|)
expr_stmt|;
try|try
block|{
name|javaConstructor
operator|=
name|type
operator|.
name|getConstructor
argument_list|(
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConstructorException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"Can't construct a java object for scalar "
operator|+
name|node
operator|.
name|getTag
argument_list|()
operator|+
literal|"; No String constructor found. Exception="
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|node
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|result
operator|=
name|javaConstructor
operator|.
name|newInstance
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ConstructorException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"Can't construct a java object for scalar "
operator|+
name|node
operator|.
name|getTag
argument_list|()
operator|+
literal|"; exception="
operator|+
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|node
operator|.
name|getStartMark
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|result
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|constructStandardJavaInstance
specifier|private
name|Object
name|constructStandardJavaInstance
parameter_list|(
name|Class
name|type
parameter_list|,
name|ScalarNode
name|node
parameter_list|)
block|{
name|Object
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|String
operator|.
name|class
condition|)
block|{
name|Construct
name|stringConstructor
init|=
name|yamlConstructors
operator|.
name|get
argument_list|(
name|Tag
operator|.
name|STR
argument_list|)
decl_stmt|;
name|result
operator|=
name|stringConstructor
operator|.
name|construct
argument_list|(
operator|(
name|ScalarNode
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Boolean
operator|.
name|class
operator|||
name|type
operator|==
name|Boolean
operator|.
name|TYPE
condition|)
block|{
name|Construct
name|boolConstructor
init|=
name|yamlConstructors
operator|.
name|get
argument_list|(
name|Tag
operator|.
name|BOOL
argument_list|)
decl_stmt|;
name|result
operator|=
name|boolConstructor
operator|.
name|construct
argument_list|(
operator|(
name|ScalarNode
operator|)
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Character
operator|.
name|class
operator|||
name|type
operator|==
name|Character
operator|.
name|TYPE
condition|)
block|{
name|Construct
name|charConstructor
init|=
name|yamlConstructors
operator|.
name|get
argument_list|(
name|Tag
operator|.
name|STR
argument_list|)
decl_stmt|;
name|String
name|ch
init|=
operator|(
name|String
operator|)
name|charConstructor
operator|.
name|construct
argument_list|(
operator|(
name|ScalarNode
operator|)
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|result
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|.
name|length
argument_list|()
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Invalid node Character: '"
operator|+
name|ch
operator|+
literal|"'; length: "
operator|+
name|ch
operator|.
name|length
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
name|result
operator|=
operator|new
name|Character
argument_list|(
name|ch
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Date
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|Construct
name|dateConstructor
init|=
name|yamlConstructors
operator|.
name|get
argument_list|(
name|Tag
operator|.
name|TIMESTAMP
argument_list|)
decl_stmt|;
name|Date
name|date
init|=
operator|(
name|Date
operator|)
name|dateConstructor
operator|.
name|construct
argument_list|(
operator|(
name|ScalarNode
operator|)
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Date
operator|.
name|class
condition|)
block|{
name|result
operator|=
name|date
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|<
name|?
argument_list|>
name|constr
init|=
name|type
operator|.
name|getConstructor
argument_list|(
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
name|result
operator|=
name|constr
operator|.
name|newInstance
argument_list|(
name|date
operator|.
name|getTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Cannot construct: '"
operator|+
name|type
operator|+
literal|"'"
argument_list|)
throw|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Float
operator|.
name|class
operator|||
name|type
operator|==
name|Double
operator|.
name|class
operator|||
name|type
operator|==
name|Float
operator|.
name|TYPE
operator|||
name|type
operator|==
name|Double
operator|.
name|TYPE
operator|||
name|type
operator|==
name|BigDecimal
operator|.
name|class
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BigDecimal
operator|.
name|class
condition|)
block|{
name|result
operator|=
operator|new
name|BigDecimal
argument_list|(
name|node
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Construct
name|doubleConstructor
init|=
name|yamlConstructors
operator|.
name|get
argument_list|(
name|Tag
operator|.
name|FLOAT
argument_list|)
decl_stmt|;
name|result
operator|=
name|doubleConstructor
operator|.
name|construct
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|Float
operator|.
name|class
operator|||
name|type
operator|==
name|Float
operator|.
name|TYPE
condition|)
block|{
name|result
operator|=
operator|new
name|Float
argument_list|(
operator|(
name|Double
operator|)
name|result
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Byte
operator|.
name|class
operator|||
name|type
operator|==
name|Short
operator|.
name|class
operator|||
name|type
operator|==
name|Integer
operator|.
name|class
operator|||
name|type
operator|==
name|Long
operator|.
name|class
operator|||
name|type
operator|==
name|BigInteger
operator|.
name|class
operator|||
name|type
operator|==
name|Byte
operator|.
name|TYPE
operator|||
name|type
operator|==
name|Short
operator|.
name|TYPE
operator|||
name|type
operator|==
name|Integer
operator|.
name|TYPE
operator|||
name|type
operator|==
name|Long
operator|.
name|TYPE
condition|)
block|{
name|Construct
name|intConstructor
init|=
name|yamlConstructors
operator|.
name|get
argument_list|(
name|Tag
operator|.
name|INT
argument_list|)
decl_stmt|;
name|result
operator|=
name|intConstructor
operator|.
name|construct
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|Byte
operator|.
name|class
operator|||
name|type
operator|==
name|Byte
operator|.
name|TYPE
condition|)
block|{
name|result
operator|=
operator|new
name|Byte
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Short
operator|.
name|class
operator|||
name|type
operator|==
name|Short
operator|.
name|TYPE
condition|)
block|{
name|result
operator|=
operator|new
name|Short
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Integer
operator|.
name|class
operator|||
name|type
operator|==
name|Integer
operator|.
name|TYPE
condition|)
block|{
name|result
operator|=
operator|new
name|Integer
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|Long
operator|.
name|class
operator|||
name|type
operator|==
name|Long
operator|.
name|TYPE
condition|)
block|{
name|result
operator|=
operator|new
name|Long
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// only BigInteger left
name|result
operator|=
operator|new
name|BigInteger
argument_list|(
name|result
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Enum
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|String
name|enumValueName
init|=
name|node
operator|.
name|getValue
argument_list|()
decl_stmt|;
try|try
block|{
name|result
operator|=
name|Enum
operator|.
name|valueOf
argument_list|(
name|type
argument_list|,
name|enumValueName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Unable to find enum value '"
operator|+
name|enumValueName
operator|+
literal|"' for enum class: "
operator|+
name|type
operator|.
name|getName
argument_list|()
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|Calendar
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|ConstructYamlTimestamp
name|contr
init|=
operator|new
name|ConstructYamlTimestamp
argument_list|()
decl_stmt|;
name|contr
operator|.
name|construct
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|result
operator|=
name|contr
operator|.
name|getCalendar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Unsupported class: "
operator|+
name|type
argument_list|)
throw|;
block|}
return|return
name|result
return|;
block|}
block|}
comment|/**      * Construct sequence (List, Array, or immutable object) when the runtime      * class is known.      */
DECL|class|ConstructSequence
specifier|private
class|class
name|ConstructSequence
implements|implements
name|Construct
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|construct
specifier|public
name|Object
name|construct
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|SequenceNode
name|snode
init|=
operator|(
name|SequenceNode
operator|)
name|node
decl_stmt|;
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
operator|||
name|node
operator|.
name|getType
argument_list|()
operator|.
name|isArray
argument_list|()
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|isTwoStepsConstruction
argument_list|()
condition|)
block|{
return|return
name|createDefaultList
argument_list|(
name|snode
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|constructSequence
argument_list|(
name|snode
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// create immutable object
name|List
argument_list|<
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|>
name|possibleConstructors
init|=
operator|new
name|ArrayList
argument_list|<
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|>
argument_list|(
name|snode
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|constructor
range|:
name|node
operator|.
name|getType
argument_list|()
operator|.
name|getConstructors
argument_list|()
control|)
block|{
if|if
condition|(
name|snode
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
operator|==
name|constructor
operator|.
name|getParameterTypes
argument_list|()
operator|.
name|length
condition|)
block|{
name|possibleConstructors
operator|.
name|add
argument_list|(
name|constructor
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|possibleConstructors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"No constructors with "
operator|+
name|String
operator|.
name|valueOf
argument_list|(
name|snode
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|+
literal|" arguments found for "
operator|+
name|node
operator|.
name|getType
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Object
argument_list|>
name|argumentList
decl_stmt|;
if|if
condition|(
name|possibleConstructors
operator|.
name|size
argument_list|()
operator|==
literal|1
condition|)
block|{
name|argumentList
operator|=
operator|new
name|ArrayList
argument_list|<
name|Object
argument_list|>
argument_list|(
name|snode
operator|.
name|getValue
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|c
init|=
name|possibleConstructors
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
name|argumentNode
range|:
name|snode
operator|.
name|getValue
argument_list|()
control|)
block|{
name|Class
name|type
init|=
name|c
operator|.
name|getParameterTypes
argument_list|()
index|[
name|index
index|]
decl_stmt|;
comment|// set runtime classes for arguments
name|argumentNode
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|Object
name|argumentValue
init|=
name|constructObject
argument_list|(
name|argumentNode
argument_list|)
decl_stmt|;
name|argumentList
operator|.
name|add
argument_list|(
name|argumentValue
argument_list|)
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// use BaseConstructor
name|argumentList
operator|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|constructSequence
argument_list|(
name|snode
argument_list|)
expr_stmt|;
block|}
name|Class
index|[]
name|parameterTypes
init|=
operator|new
name|Class
index|[
name|argumentList
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|parameter
range|:
name|argumentList
control|)
block|{
name|parameterTypes
index|[
name|index
index|]
operator|=
name|parameter
operator|.
name|getClass
argument_list|()
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
name|javaConstructor
decl_stmt|;
try|try
block|{
name|Class
name|cl
init|=
name|node
operator|.
name|getType
argument_list|()
decl_stmt|;
name|javaConstructor
operator|=
name|cl
operator|.
name|getConstructor
argument_list|(
name|parameterTypes
argument_list|)
expr_stmt|;
name|Object
index|[]
name|initargs
init|=
name|argumentList
operator|.
name|toArray
argument_list|()
decl_stmt|;
return|return
name|javaConstructor
operator|.
name|newInstance
argument_list|(
name|initargs
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|construct2ndStep
specifier|public
name|void
name|construct2ndStep
parameter_list|(
name|Node
name|node
parameter_list|,
name|Object
name|object
parameter_list|)
block|{
name|SequenceNode
name|snode
init|=
operator|(
name|SequenceNode
operator|)
name|node
decl_stmt|;
name|List
argument_list|<
name|Object
argument_list|>
name|list
init|=
operator|(
name|List
argument_list|<
name|Object
argument_list|>
operator|)
name|object
decl_stmt|;
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|node
operator|.
name|getType
argument_list|()
argument_list|)
condition|)
block|{
name|constructSequenceStep2
argument_list|(
name|snode
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Immutable objects cannot be recursive."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|getClassForNode
specifier|protected
name|Class
argument_list|<
name|?
argument_list|>
name|getClassForNode
parameter_list|(
name|Node
name|node
parameter_list|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Object
argument_list|>
name|classForTag
init|=
name|typeTags
operator|.
name|get
argument_list|(
name|node
operator|.
name|getTag
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|classForTag
operator|==
literal|null
condition|)
block|{
name|String
name|name
init|=
name|node
operator|.
name|getTag
argument_list|()
operator|.
name|getClassName
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|cl
decl_stmt|;
try|try
block|{
name|cl
operator|=
name|getClassForName
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"Class not found: "
operator|+
name|name
argument_list|)
throw|;
block|}
name|typeTags
operator|.
name|put
argument_list|(
name|node
operator|.
name|getTag
argument_list|()
argument_list|,
name|cl
argument_list|)
expr_stmt|;
return|return
name|cl
return|;
block|}
else|else
block|{
return|return
name|classForTag
return|;
block|}
block|}
DECL|method|getClassForName
specifier|protected
name|Class
argument_list|<
name|?
argument_list|>
name|getClassForName
parameter_list|(
name|String
name|name
parameter_list|)
throws|throws
name|ClassNotFoundException
block|{
return|return
name|Class
operator|.
name|forName
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
end_class

end_unit

