begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.yaml.snakeyaml.resolver
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|resolver
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|nodes
operator|.
name|NodeId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|nodes
operator|.
name|Tag
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * Resolver tries to detect a type by scalars's content (when the type is  * implicit)  *  * @see<a href="http://pyyaml.org/wiki/PyYAML">PyYAML</a> for more information  */
end_comment

begin_class
DECL|class|Resolver
specifier|public
class|class
name|Resolver
block|{
DECL|field|BOOL
specifier|public
specifier|static
specifier|final
name|Pattern
name|BOOL
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:yes|Yes|YES|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$"
argument_list|)
decl_stmt|;
DECL|field|FLOAT
specifier|public
specifier|static
specifier|final
name|Pattern
name|FLOAT
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?|[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]+(?:[eE][-+][0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
argument_list|)
decl_stmt|;
DECL|field|INT
specifier|public
specifier|static
specifier|final
name|Pattern
name|INT
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:[-+]?0b[0-1_]+|[-+]?0[0-7_]+|[-+]?(?:0|[1-9][0-9_]*)|[-+]?0x[0-9a-fA-F_]+|[-+]?[1-9][0-9_]*(?::[0-5]?[0-9])+)$"
argument_list|)
decl_stmt|;
DECL|field|MERGE
specifier|public
specifier|static
specifier|final
name|Pattern
name|MERGE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:<<)$"
argument_list|)
decl_stmt|;
DECL|field|NULL
specifier|public
specifier|static
specifier|final
name|Pattern
name|NULL
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:~|null|Null|NULL| )$"
argument_list|)
decl_stmt|;
DECL|field|EMPTY
specifier|public
specifier|static
specifier|final
name|Pattern
name|EMPTY
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^$"
argument_list|)
decl_stmt|;
DECL|field|TIMESTAMP
specifier|public
specifier|static
specifier|final
name|Pattern
name|TIMESTAMP
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]|[0-9][0-9][0-9][0-9]-[0-9][0-9]?-[0-9][0-9]?(?:[Tt]|[ \t]+)[0-9][0-9]?:[0-9][0-9]:[0-9][0-9](?:\\.[0-9]*)?(?:[ \t]*(?:Z|[-+][0-9][0-9]?(?::[0-9][0-9])?))?)$"
argument_list|)
decl_stmt|;
DECL|field|VALUE
specifier|public
specifier|static
specifier|final
name|Pattern
name|VALUE
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:=)$"
argument_list|)
decl_stmt|;
DECL|field|YAML
specifier|public
specifier|static
specifier|final
name|Pattern
name|YAML
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^(?:!|&|\\*)$"
argument_list|)
decl_stmt|;
DECL|field|yamlImplicitResolvers
specifier|protected
name|Map
argument_list|<
name|Character
argument_list|,
name|List
argument_list|<
name|ResolverTuple
argument_list|>
argument_list|>
name|yamlImplicitResolvers
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|List
argument_list|<
name|ResolverTuple
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Create Resolver      *      * @param respectDefaultImplicitScalars false to parse/dump scalars as plain Strings      * @deprecated override addImplicitResolvers instead      */
DECL|method|Resolver
specifier|public
name|Resolver
parameter_list|(
name|boolean
name|respectDefaultImplicitScalars
parameter_list|)
block|{
if|if
condition|(
name|respectDefaultImplicitScalars
condition|)
block|{
name|addImplicitResolvers
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|addImplicitResolvers
specifier|protected
name|void
name|addImplicitResolvers
parameter_list|()
block|{
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|BOOL
argument_list|,
name|BOOL
argument_list|,
literal|"yYnNtTfFoO"
argument_list|)
expr_stmt|;
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|FLOAT
argument_list|,
name|FLOAT
argument_list|,
literal|"-+0123456789."
argument_list|)
expr_stmt|;
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|INT
argument_list|,
name|INT
argument_list|,
literal|"-+0123456789"
argument_list|)
expr_stmt|;
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|MERGE
argument_list|,
name|MERGE
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"~nN\0"
argument_list|)
expr_stmt|;
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|NULL
argument_list|,
name|EMPTY
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|TIMESTAMP
argument_list|,
name|TIMESTAMP
argument_list|,
literal|"0123456789"
argument_list|)
expr_stmt|;
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|VALUE
argument_list|,
name|VALUE
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
comment|// The following implicit resolver is only for documentation
comment|// purposes.
comment|// It cannot work
comment|// because plain scalars cannot start with '!', '&', or '*'.
name|addImplicitResolver
argument_list|(
name|Tag
operator|.
name|YAML
argument_list|,
name|YAML
argument_list|,
literal|"!&*"
argument_list|)
expr_stmt|;
block|}
DECL|method|Resolver
specifier|public
name|Resolver
parameter_list|()
block|{
name|this
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|addImplicitResolver
specifier|public
name|void
name|addImplicitResolver
parameter_list|(
name|Tag
name|tag
parameter_list|,
name|Pattern
name|regexp
parameter_list|,
name|String
name|first
parameter_list|)
block|{
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|List
argument_list|<
name|ResolverTuple
argument_list|>
name|curr
init|=
name|yamlImplicitResolvers
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|curr
operator|==
literal|null
condition|)
block|{
name|curr
operator|=
operator|new
name|ArrayList
argument_list|<
name|ResolverTuple
argument_list|>
argument_list|()
expr_stmt|;
name|yamlImplicitResolvers
operator|.
name|put
argument_list|(
literal|null
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
name|curr
operator|.
name|add
argument_list|(
operator|new
name|ResolverTuple
argument_list|(
name|tag
argument_list|,
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
index|[]
name|chrs
init|=
name|first
operator|.
name|toCharArray
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
name|chrs
operator|.
name|length
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|Character
name|theC
init|=
operator|new
name|Character
argument_list|(
name|chrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|theC
operator|==
literal|0
condition|)
block|{
comment|// special case: for null
name|theC
operator|=
literal|null
expr_stmt|;
block|}
name|List
argument_list|<
name|ResolverTuple
argument_list|>
name|curr
init|=
name|yamlImplicitResolvers
operator|.
name|get
argument_list|(
name|theC
argument_list|)
decl_stmt|;
if|if
condition|(
name|curr
operator|==
literal|null
condition|)
block|{
name|curr
operator|=
operator|new
name|ArrayList
argument_list|<
name|ResolverTuple
argument_list|>
argument_list|()
expr_stmt|;
name|yamlImplicitResolvers
operator|.
name|put
argument_list|(
name|theC
argument_list|,
name|curr
argument_list|)
expr_stmt|;
block|}
name|curr
operator|.
name|add
argument_list|(
operator|new
name|ResolverTuple
argument_list|(
name|tag
argument_list|,
name|regexp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|resolve
specifier|public
name|Tag
name|resolve
parameter_list|(
name|NodeId
name|kind
parameter_list|,
name|String
name|value
parameter_list|,
name|boolean
name|implicit
parameter_list|)
block|{
if|if
condition|(
name|kind
operator|==
name|NodeId
operator|.
name|scalar
operator|&&
name|implicit
condition|)
block|{
name|List
argument_list|<
name|ResolverTuple
argument_list|>
name|resolvers
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|resolvers
operator|=
name|yamlImplicitResolvers
operator|.
name|get
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|resolvers
operator|=
name|yamlImplicitResolvers
operator|.
name|get
argument_list|(
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resolvers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ResolverTuple
name|v
range|:
name|resolvers
control|)
block|{
name|Tag
name|tag
init|=
name|v
operator|.
name|getTag
argument_list|()
decl_stmt|;
name|Pattern
name|regexp
init|=
name|v
operator|.
name|getRegexp
argument_list|()
decl_stmt|;
if|if
condition|(
name|regexp
operator|.
name|matcher
argument_list|(
name|value
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|tag
return|;
block|}
block|}
block|}
if|if
condition|(
name|yamlImplicitResolvers
operator|.
name|containsKey
argument_list|(
literal|null
argument_list|)
condition|)
block|{
for|for
control|(
name|ResolverTuple
name|v
range|:
name|yamlImplicitResolvers
operator|.
name|get
argument_list|(
literal|null
argument_list|)
control|)
block|{
name|Tag
name|tag
init|=
name|v
operator|.
name|getTag
argument_list|()
decl_stmt|;
name|Pattern
name|regexp
init|=
name|v
operator|.
name|getRegexp
argument_list|()
decl_stmt|;
if|if
condition|(
name|regexp
operator|.
name|matcher
argument_list|(
name|value
argument_list|)
operator|.
name|matches
argument_list|()
condition|)
block|{
return|return
name|tag
return|;
block|}
block|}
block|}
block|}
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|scalar
case|:
return|return
name|Tag
operator|.
name|STR
return|;
case|case
name|sequence
case|:
return|return
name|Tag
operator|.
name|SEQ
return|;
default|default:
return|return
name|Tag
operator|.
name|MAP
return|;
block|}
block|}
block|}
end_class

end_unit

