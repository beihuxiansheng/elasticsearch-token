begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.concurrent
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|concurrent
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|ReusableIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * An alternative identity-comparing {@link ConcurrentMap} which is similar to  * {@link java.util.concurrent.ConcurrentHashMap}.  *  * @author Doug Lea  * @author kimchy (shay.banon)  */
end_comment

begin_class
DECL|class|ConcurrentIdentityHashMap
specifier|public
specifier|final
class|class
name|ConcurrentIdentityHashMap
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
comment|/**      * The default initial capacity for this table, used when not otherwise      * specified in a constructor.      */
DECL|field|DEFAULT_INITIAL_CAPACITY
specifier|static
specifier|final
name|int
name|DEFAULT_INITIAL_CAPACITY
init|=
literal|16
decl_stmt|;
comment|/**      * The default load factor for this table, used when not otherwise specified      * in a constructor.      */
DECL|field|DEFAULT_LOAD_FACTOR
specifier|static
specifier|final
name|float
name|DEFAULT_LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
comment|/**      * The default concurrency level for this table, used when not otherwise      * specified in a constructor.      */
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
comment|/**      * The maximum capacity, used if a higher value is implicitly specified by      * either of the constructors with arguments.  MUST be a power of two      *<= 1<<30 to ensure that entries are indexable using integers.      */
DECL|field|MAXIMUM_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/**      * The maximum number of segments to allow; used to bound constructor      * arguments.      */
DECL|field|MAX_SEGMENTS
specifier|static
specifier|final
name|int
name|MAX_SEGMENTS
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// slightly conservative
comment|/**      * Number of unsynchronized retries in size and containsValue methods before      * resorting to locking. This is used to avoid unbounded retries if tables      * undergo continuous modification which would make it impossible to obtain      * an accurate result.      */
DECL|field|RETRIES_BEFORE_LOCK
specifier|static
specifier|final
name|int
name|RETRIES_BEFORE_LOCK
init|=
literal|2
decl_stmt|;
comment|/* ---------------- Fields -------------- */
comment|/**      * Mask value for indexing into segments. The upper bits of a key's hash      * code are used to choose the segment.      */
DECL|field|segmentMask
specifier|final
name|int
name|segmentMask
decl_stmt|;
comment|/**      * Shift value for indexing within segments.      */
DECL|field|segmentShift
specifier|final
name|int
name|segmentShift
decl_stmt|;
comment|/**      * The segments, each of which is a specialized hash table      */
DECL|field|segments
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
DECL|field|keySet
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
decl_stmt|;
DECL|field|entrySet
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
decl_stmt|;
DECL|field|values
name|Collection
argument_list|<
name|V
argument_list|>
name|values
decl_stmt|;
comment|/* ---------------- Small Utilities -------------- */
comment|/**      * Applies a supplemental hash function to a given hashCode, which defends      * against poor quality hash functions.  This is critical because      * ConcurrentReferenceHashMap uses power-of-two length hash tables, that      * otherwise encounter collisions for hashCodes that do not differ in lower      * or upper bits.      */
DECL|method|hash
specifier|private
specifier|static
name|int
name|hash
parameter_list|(
name|int
name|h
parameter_list|)
block|{
comment|// Spread bits to regularize both segment and index locations,
comment|// using variant of single-word Wang/Jenkins hash.
name|h
operator|+=
name|h
operator|<<
literal|15
operator|^
literal|0xffffcd7d
expr_stmt|;
name|h
operator|^=
name|h
operator|>>>
literal|10
expr_stmt|;
name|h
operator|+=
name|h
operator|<<
literal|3
expr_stmt|;
name|h
operator|^=
name|h
operator|>>>
literal|6
expr_stmt|;
name|h
operator|+=
operator|(
name|h
operator|<<
literal|2
operator|)
operator|+
operator|(
name|h
operator|<<
literal|14
operator|)
expr_stmt|;
return|return
name|h
operator|^
name|h
operator|>>>
literal|16
return|;
block|}
comment|/**      * Returns the segment that should be used for key with given hash.      *      * @param hash the hash code for the key      * @return the segment      */
DECL|method|segmentFor
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|segmentFor
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
return|return
name|segments
index|[
name|hash
operator|>>>
name|segmentShift
operator|&
name|segmentMask
index|]
return|;
block|}
DECL|method|hashOf
specifier|private
name|int
name|hashOf
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|hash
argument_list|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * ConcurrentReferenceHashMap list entry. Note that this is never exported      * out as a user-visible Map.Entry.      *      * Because the value field is volatile, not final, it is legal wrt      * the Java Memory Model for an unsynchronized reader to see null      * instead of initial value when read via a data race.  Although a      * reordering leading to this is not likely to ever actually      * occur, the Segment.readValueUnderLock method is used as a      * backup in case a null (pre-initialized) value is ever seen in      * an unsynchronized access method.      */
DECL|class|HashEntry
specifier|static
specifier|final
class|class
name|HashEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|key
specifier|final
name|Object
name|key
decl_stmt|;
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|value
specifier|volatile
name|Object
name|value
decl_stmt|;
DECL|field|next
specifier|final
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|method|HashEntry
name|HashEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|key
specifier|final
name|K
name|key
parameter_list|()
block|{
return|return
operator|(
name|K
operator|)
name|key
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|value
specifier|final
name|V
name|value
parameter_list|()
block|{
return|return
operator|(
name|V
operator|)
name|value
return|;
block|}
DECL|method|setValue
specifier|final
name|void
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newArray
specifier|static
specifier|final
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|newArray
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|new
name|HashEntry
index|[
name|i
index|]
return|;
block|}
block|}
comment|/**      * Segments are specialized versions of hash tables.  This subclasses from      * ReentrantLock opportunistically, just to simplify some locking and avoid      * separate construction.      */
DECL|class|Segment
specifier|static
specifier|final
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ReentrantLock
block|{
comment|/*          * Segments maintain a table of entry lists that are ALWAYS kept in a          * consistent state, so can be read without locking. Next fields of          * nodes are immutable (final).  All list additions are performed at the          * front of each bin. This makes it easy to check changes, and also fast          * to traverse. When nodes would otherwise be changed, new nodes are          * created to replace them. This works well for hash tables since the          * bin lists tend to be short. (The average length is less than two for          * the default load factor threshold.)          *          * Read operations can thus proceed without locking, but rely on          * selected uses of volatiles to ensure that completed write operations          * performed by other threads are noticed. For most purposes, the          * "count" field, tracking the number of elements, serves as that          * volatile variable ensuring visibility.  This is convenient because          * this field needs to be read in many read operations anyway:          *          *   - All (unsynchronized) read operations must first read the          *     "count" field, and should not look at table entries if          *     it is 0.          *          *   - All (synchronized) write operations should write to          *     the "count" field after structurally changing any bin.          *     The operations must not take any action that could even          *     momentarily cause a concurrent read operation to see          *     inconsistent data. This is made easier by the nature of          *     the read operations in Map. For example, no operation          *     can reveal that the table has grown but the threshold          *     has not yet been updated, so there are no atomicity          *     requirements for this with respect to reads.          *          * As a guide, all critical volatile reads and writes to the count field          * are marked in code comments.          */
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5207829234977119743L
decl_stmt|;
comment|/**          * The number of elements in this segment's region.          */
DECL|field|count
specifier|transient
specifier|volatile
name|int
name|count
decl_stmt|;
comment|/**          * Number of updates that alter the size of the table. This is used          * during bulk-read methods to make sure they see a consistent snapshot:          * If modCounts change during a traversal of segments computing size or          * checking containsValue, then we might have an inconsistent view of          * state so (usually) must retry.          */
DECL|field|modCount
name|int
name|modCount
decl_stmt|;
comment|/**          * The table is rehashed when its size exceeds this threshold.          * (The value of this field is always<tt>(capacity * loadFactor)</tt>.)          */
DECL|field|threshold
name|int
name|threshold
decl_stmt|;
comment|/**          * The per-segment table.          */
DECL|field|table
specifier|transient
specifier|volatile
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|table
decl_stmt|;
comment|/**          * The load factor for the hash table.  Even though this value is same          * for all segments, it is replicated to avoid needing links to outer          * object.          *          * @serial          */
DECL|field|loadFactor
specifier|final
name|float
name|loadFactor
decl_stmt|;
DECL|method|Segment
name|Segment
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|lf
parameter_list|)
block|{
name|loadFactor
operator|=
name|lf
expr_stmt|;
name|setTable
argument_list|(
name|HashEntry
operator|.
expr|<
name|K
argument_list|,
name|V
operator|>
name|newArray
argument_list|(
name|initialCapacity
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|newArray
specifier|static
specifier|final
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|newArray
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|new
name|Segment
index|[
name|i
index|]
return|;
block|}
DECL|method|keyEq
specifier|private
name|boolean
name|keyEq
parameter_list|(
name|Object
name|src
parameter_list|,
name|Object
name|dest
parameter_list|)
block|{
return|return
name|src
operator|==
name|dest
return|;
block|}
comment|/**          * Sets table to new HashEntry array. Call only while holding lock or in          * constructor.          */
DECL|method|setTable
name|void
name|setTable
parameter_list|(
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|newTable
parameter_list|)
block|{
name|threshold
operator|=
call|(
name|int
call|)
argument_list|(
name|newTable
operator|.
name|length
operator|*
name|loadFactor
argument_list|)
expr_stmt|;
name|table
operator|=
name|newTable
expr_stmt|;
block|}
comment|/**          * Returns properly casted first entry of bin for given hash.          */
DECL|method|getFirst
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getFirst
parameter_list|(
name|int
name|hash
parameter_list|)
block|{
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
return|return
name|tab
index|[
name|hash
operator|&
name|tab
operator|.
name|length
operator|-
literal|1
index|]
return|;
block|}
DECL|method|newHashEntry
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newHashEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
operator|new
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|next
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**          * Reads value field of an entry under lock. Called if value field ever          * appears to be null. This is possible only if a compiler happens to          * reorder a HashEntry initialization with its table assignment, which          * is legal under memory model but is not known to ever occur.          */
DECL|method|readValueUnderLock
name|V
name|readValueUnderLock
parameter_list|(
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
return|return
name|e
operator|.
name|value
argument_list|()
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Specialized implementations of map methods */
DECL|method|get
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
name|keyEq
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
name|V
name|opaque
init|=
name|e
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|opaque
operator|!=
literal|null
condition|)
block|{
return|return
name|opaque
return|;
block|}
return|return
name|readValueUnderLock
argument_list|(
name|e
argument_list|)
return|;
comment|// recheck
block|}
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|containsKey
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
name|keyEq
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|containsValue
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|// read-volatile
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
name|int
name|len
init|=
name|tab
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|tab
index|[
name|i
index|]
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
name|V
name|opaque
init|=
name|e
operator|.
name|value
argument_list|()
decl_stmt|;
name|V
name|v
decl_stmt|;
if|if
condition|(
name|opaque
operator|==
literal|null
condition|)
block|{
name|v
operator|=
name|readValueUnderLock
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// recheck
block|}
else|else
block|{
name|v
operator|=
name|opaque
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|.
name|equals
argument_list|(
name|v
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|replace
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
operator|&&
operator|(
name|e
operator|.
name|hash
operator|!=
name|hash
operator|||
operator|!
name|keyEq
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
name|boolean
name|replaced
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
operator|&&
name|oldValue
operator|.
name|equals
argument_list|(
name|e
operator|.
name|value
argument_list|()
argument_list|)
condition|)
block|{
name|replaced
operator|=
literal|true
expr_stmt|;
name|e
operator|.
name|setValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
return|return
name|replaced
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|replace
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|getFirst
argument_list|(
name|hash
argument_list|)
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
operator|&&
operator|(
name|e
operator|.
name|hash
operator|!=
name|hash
operator|||
operator|!
name|keyEq
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
name|V
name|oldValue
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|oldValue
operator|=
name|e
operator|.
name|value
argument_list|()
expr_stmt|;
name|e
operator|.
name|setValue
argument_list|(
name|newValue
argument_list|)
expr_stmt|;
block|}
return|return
name|oldValue
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|put
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|c
init|=
name|count
decl_stmt|;
if|if
condition|(
name|c
operator|++
operator|>
name|threshold
condition|)
block|{
comment|// ensure capacity
name|int
name|reduced
init|=
name|rehash
argument_list|()
decl_stmt|;
if|if
condition|(
name|reduced
operator|>
literal|0
condition|)
block|{
name|count
operator|=
operator|(
name|c
operator|-=
name|reduced
operator|)
operator|-
literal|1
expr_stmt|;
comment|// write-volatile
block|}
block|}
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
name|tab
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|tab
index|[
name|index
index|]
decl_stmt|;
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
operator|&&
operator|(
name|e
operator|.
name|hash
operator|!=
name|hash
operator|||
operator|!
name|keyEq
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
name|V
name|oldValue
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|oldValue
operator|=
name|e
operator|.
name|value
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|onlyIfAbsent
condition|)
block|{
name|e
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|oldValue
operator|=
literal|null
expr_stmt|;
operator|++
name|modCount
expr_stmt|;
name|tab
index|[
name|index
index|]
operator|=
name|newHashEntry
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|first
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|count
operator|=
name|c
expr_stmt|;
comment|// write-volatile
block|}
return|return
name|oldValue
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|rehash
name|int
name|rehash
parameter_list|()
block|{
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|oldTable
init|=
name|table
decl_stmt|;
name|int
name|oldCapacity
init|=
name|oldTable
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|oldCapacity
operator|>=
name|MAXIMUM_CAPACITY
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/*              * Reclassify nodes in each list to new Map.  Because we are using              * power-of-two expansion, the elements from each bin must either              * stay at same index, or move with a power of two offset. We              * eliminate unnecessary node creation by catching cases where old              * nodes can be reused because their next fields won't change.              * Statistically, at the default threshold, only about one-sixth of              * them need cloning when a table doubles. The nodes they replace              * will be garbage collectable as soon as they are no longer              * referenced by any reader thread that may be in the midst of              * traversing table right now.              */
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|newTable
init|=
name|HashEntry
operator|.
name|newArray
argument_list|(
name|oldCapacity
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|threshold
operator|=
call|(
name|int
call|)
argument_list|(
name|newTable
operator|.
name|length
operator|*
name|loadFactor
argument_list|)
expr_stmt|;
name|int
name|sizeMask
init|=
name|newTable
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|int
name|reduce
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|oldCapacity
condition|;
name|i
operator|++
control|)
block|{
comment|// We need to guarantee that any existing reads of old Map can
comment|// proceed. So we cannot yet null out each bin.
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|oldTable
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|e
operator|.
name|next
decl_stmt|;
name|int
name|idx
init|=
name|e
operator|.
name|hash
operator|&
name|sizeMask
decl_stmt|;
comment|// Single node on list
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|newTable
index|[
name|idx
index|]
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
comment|// Reuse trailing consecutive sequence at same slot
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastRun
init|=
name|e
decl_stmt|;
name|int
name|lastIdx
init|=
name|idx
decl_stmt|;
for|for
control|(
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|last
init|=
name|next
init|;
name|last
operator|!=
literal|null
condition|;
name|last
operator|=
name|last
operator|.
name|next
control|)
block|{
name|int
name|k
init|=
name|last
operator|.
name|hash
operator|&
name|sizeMask
decl_stmt|;
if|if
condition|(
name|k
operator|!=
name|lastIdx
condition|)
block|{
name|lastIdx
operator|=
name|k
expr_stmt|;
name|lastRun
operator|=
name|last
expr_stmt|;
block|}
block|}
name|newTable
index|[
name|lastIdx
index|]
operator|=
name|lastRun
expr_stmt|;
comment|// Clone all remaining nodes
for|for
control|(
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|e
init|;
name|p
operator|!=
name|lastRun
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
comment|// Skip GC'd weak references
name|K
name|key
init|=
name|p
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|null
condition|)
block|{
name|reduce
operator|++
expr_stmt|;
continue|continue;
block|}
name|int
name|k
init|=
name|p
operator|.
name|hash
operator|&
name|sizeMask
decl_stmt|;
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|n
init|=
name|newTable
index|[
name|k
index|]
decl_stmt|;
name|newTable
index|[
name|k
index|]
operator|=
name|newHashEntry
argument_list|(
name|key
argument_list|,
name|p
operator|.
name|hash
argument_list|,
name|n
argument_list|,
name|p
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|table
operator|=
name|newTable
expr_stmt|;
return|return
name|reduce
return|;
block|}
comment|/**          * Remove; match on key only if value null, else match both.          */
DECL|method|remove
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|hash
parameter_list|,
name|Object
name|value
parameter_list|,
name|boolean
name|refRemove
parameter_list|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|int
name|c
init|=
name|count
operator|-
literal|1
decl_stmt|;
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
name|int
name|index
init|=
name|hash
operator|&
name|tab
operator|.
name|length
operator|-
literal|1
decl_stmt|;
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
init|=
name|tab
index|[
name|index
index|]
decl_stmt|;
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
decl_stmt|;
comment|// a reference remove operation compares the Reference instance
while|while
condition|(
name|e
operator|!=
literal|null
operator|&&
name|key
operator|!=
name|e
operator|.
name|key
operator|&&
operator|(
name|refRemove
operator|||
name|hash
operator|!=
name|e
operator|.
name|hash
operator|||
operator|!
name|keyEq
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|key
argument_list|()
argument_list|)
operator|)
condition|)
block|{
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
name|V
name|oldValue
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|V
name|v
init|=
name|e
operator|.
name|value
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
operator|||
name|value
operator|.
name|equals
argument_list|(
name|v
argument_list|)
condition|)
block|{
name|oldValue
operator|=
name|v
expr_stmt|;
comment|// All entries following removed node can stay in list,
comment|// but all preceding ones need to be cloned.
operator|++
name|modCount
expr_stmt|;
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|newFirst
init|=
name|e
operator|.
name|next
decl_stmt|;
for|for
control|(
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|first
init|;
name|p
operator|!=
name|e
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|K
name|pKey
init|=
name|p
operator|.
name|key
argument_list|()
decl_stmt|;
if|if
condition|(
name|pKey
operator|==
literal|null
condition|)
block|{
comment|// Skip GC'd keys
name|c
operator|--
expr_stmt|;
continue|continue;
block|}
name|newFirst
operator|=
name|newHashEntry
argument_list|(
name|pKey
argument_list|,
name|p
operator|.
name|hash
argument_list|,
name|newFirst
argument_list|,
name|p
operator|.
name|value
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|tab
index|[
name|index
index|]
operator|=
name|newFirst
expr_stmt|;
name|count
operator|=
name|c
expr_stmt|;
comment|// write-volatile
block|}
block|}
return|return
name|oldValue
return|;
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|clear
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tab
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tab
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
operator|++
name|modCount
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|// write-volatile
block|}
finally|finally
block|{
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* ---------------- Public operations -------------- */
comment|/**      * Creates a new, empty map with the specified initial capacity, load factor      * and concurrency level.      *      * @param initialCapacity  the initial capacity. The implementation performs      *                         internal sizing to accommodate this many elements.      * @param loadFactor       the load factor threshold, used to control resizing.      *                         Resizing may be performed when the average number of      *                         elements per bin exceeds this threshold.      * @param concurrencyLevel the estimated number of concurrently updating      *                         threads. The implementation performs internal      *                         sizing to try to accommodate this many threads.      * @throws IllegalArgumentException if the initial capacity is negative or      *                                  the load factor or concurrencyLevel are      *                                  nonpositive.      */
DECL|method|ConcurrentIdentityHashMap
specifier|public
name|ConcurrentIdentityHashMap
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|loadFactor
operator|>
literal|0
operator|)
operator|||
name|initialCapacity
operator|<
literal|0
operator|||
name|concurrencyLevel
operator|<=
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
block|}
if|if
condition|(
name|concurrencyLevel
operator|>
name|MAX_SEGMENTS
condition|)
block|{
name|concurrencyLevel
operator|=
name|MAX_SEGMENTS
expr_stmt|;
block|}
comment|// Find power-of-two sizes best matching arguments
name|int
name|sshift
init|=
literal|0
decl_stmt|;
name|int
name|ssize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|ssize
operator|<
name|concurrencyLevel
condition|)
block|{
operator|++
name|sshift
expr_stmt|;
name|ssize
operator|<<=
literal|1
expr_stmt|;
block|}
name|segmentShift
operator|=
literal|32
operator|-
name|sshift
expr_stmt|;
name|segmentMask
operator|=
name|ssize
operator|-
literal|1
expr_stmt|;
name|this
operator|.
name|segments
operator|=
name|Segment
operator|.
name|newArray
argument_list|(
name|ssize
argument_list|)
expr_stmt|;
if|if
condition|(
name|initialCapacity
operator|>
name|MAXIMUM_CAPACITY
condition|)
block|{
name|initialCapacity
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
block|}
name|int
name|c
init|=
name|initialCapacity
operator|/
name|ssize
decl_stmt|;
if|if
condition|(
name|c
operator|*
name|ssize
operator|<
name|initialCapacity
condition|)
block|{
operator|++
name|c
expr_stmt|;
block|}
name|int
name|cap
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|cap
operator|<
name|c
condition|)
block|{
name|cap
operator|<<=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|this
operator|.
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|this
operator|.
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|cap
argument_list|,
name|loadFactor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Creates a new, empty map with the specified initial capacity and load      * factor and with the default reference types (weak keys, strong values),      * and concurrencyLevel (16).      *      * @param initialCapacity The implementation performs internal sizing to      *                        accommodate this many elements.      * @param loadFactor      the load factor threshold, used to control resizing.      *                        Resizing may be performed when the average number of      *                        elements per bin exceeds this threshold.      * @throws IllegalArgumentException if the initial capacity of elements is      *                                  negative or the load factor is      *                                  nonpositive      */
DECL|method|ConcurrentIdentityHashMap
specifier|public
name|ConcurrentIdentityHashMap
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|loadFactor
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with the specified initial capacity, and with      * default reference types (weak keys, strong values), load factor (0.75)      * and concurrencyLevel (16).      *      * @param initialCapacity the initial capacity. The implementation performs      *                        internal sizing to accommodate this many elements.      * @throws IllegalArgumentException if the initial capacity of elements is      *                                  negative.      */
DECL|method|ConcurrentIdentityHashMap
specifier|public
name|ConcurrentIdentityHashMap
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with a default initial capacity (16), reference      * types (weak keys, strong values), default load factor (0.75) and      * concurrencyLevel (16).      */
DECL|method|ConcurrentIdentityHashMap
specifier|public
name|ConcurrentIdentityHashMap
parameter_list|()
block|{
name|this
argument_list|(
name|DEFAULT_INITIAL_CAPACITY
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new map with the same mappings as the given map. The map is      * created with a capacity of 1.5 times the number of mappings in the given      * map or 16 (whichever is greater), and a default load factor (0.75) and      * concurrencyLevel (16).      *      * @param m the map      */
DECL|method|ConcurrentIdentityHashMap
specifier|public
name|ConcurrentIdentityHashMap
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|this
argument_list|(
name|Math
operator|.
name|max
argument_list|(
call|(
name|int
call|)
argument_list|(
name|m
operator|.
name|size
argument_list|()
operator|/
name|DEFAULT_LOAD_FACTOR
argument_list|)
operator|+
literal|1
argument_list|,
name|DEFAULT_INITIAL_CAPACITY
argument_list|)
argument_list|,
name|DEFAULT_LOAD_FACTOR
argument_list|,
name|DEFAULT_CONCURRENCY_LEVEL
argument_list|)
expr_stmt|;
name|putAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<tt>true</tt> if this map contains no key-value mappings.      *      * @return<tt>true</tt> if this map contains no key-value mappings      */
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
comment|/*          * We keep track of per-segment modCounts to avoid ABA problems in which          * an element in one segment was added and in another removed during          * traversal, in which case the table was never actually empty at any          * point. Note the similar use of modCounts in the size() and          * containsValue() methods, which are the only other methods also          * susceptible to ABA problems.          */
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
return|return
literal|false
return|;
block|}
else|else
block|{
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
block|}
comment|// If mcsum happens to be zero, then we know we got a snapshot before
comment|// any modifications at all were made.  This is probably common enough
comment|// to bother tracking.
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|count
operator|!=
literal|0
operator|||
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns the number of key-value mappings in this map. If the map contains      * more than<tt>Integer.MAX_VALUE</tt> elements, returns      *<tt>Integer.MAX_VALUE</tt>.      *      * @return the number of key-value mappings in this map      */
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|long
name|check
init|=
literal|0
decl_stmt|;
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
comment|// Try a few times to get accurate count. On failure due to continuous
comment|// async changes in table, resort to locking.
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|RETRIES_BEFORE_LOCK
condition|;
operator|++
name|k
control|)
block|{
name|check
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
block|}
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|check
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
if|if
condition|(
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
name|check
operator|=
operator|-
literal|1
expr_stmt|;
comment|// force retry
break|break;
block|}
block|}
block|}
if|if
condition|(
name|check
operator|==
name|sum
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|check
operator|!=
name|sum
condition|)
block|{
comment|// Resort to locking all segments
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|segments
index|[
name|i
index|]
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|sum
operator|+=
name|segments
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|segments
index|[
name|i
index|]
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
operator|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
else|else
block|{
return|return
operator|(
name|int
operator|)
name|sum
return|;
block|}
block|}
comment|/**      * Returns the value to which the specified key is mapped, or {@code null}      * if this map contains no mapping for the key.      *      *<p>More formally, if this map contains a mapping from a key {@code k} to      * a value {@code v} such that {@code key.equals(k)}, then this method      * returns {@code v}; otherwise it returns {@code null}.  (There can be at      * most one such mapping.)      *      * @throws NullPointerException if the specified key is null      */
annotation|@
name|Override
DECL|method|get
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|get
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Tests if the specified object is a key in this table.      *      * @param key possible key      * @return<tt>true</tt> if and only if the specified object is a key in      *         this table, as determined by the<tt>equals</tt> method;      *<tt>false</tt> otherwise.      * @throws NullPointerException if the specified key is null      */
annotation|@
name|Override
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|containsKey
argument_list|(
name|key
argument_list|,
name|hash
argument_list|)
return|;
block|}
comment|/**      * Returns<tt>true</tt> if this map maps one or more keys to the specified      * value. Note: This method requires a full internal traversal of the hash      * table, and so is much slower than method<tt>containsKey</tt>.      *      * @param value value whose presence in this map is to be tested      * @return<tt>true</tt> if this map maps one or more keys to the specified      *         value      * @throws NullPointerException if the specified value is null      */
annotation|@
name|Override
DECL|method|containsValue
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
comment|// See explanation of modCount use above
specifier|final
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
name|this
operator|.
name|segments
decl_stmt|;
name|int
index|[]
name|mc
init|=
operator|new
name|int
index|[
name|segments
operator|.
name|length
index|]
decl_stmt|;
comment|// Try a few times without locking
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
name|RETRIES_BEFORE_LOCK
condition|;
operator|++
name|k
control|)
block|{
name|int
name|mcsum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|mcsum
operator|+=
name|mc
index|[
name|i
index|]
operator|=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
expr_stmt|;
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
name|boolean
name|cleanSweep
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|mcsum
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mc
index|[
name|i
index|]
operator|!=
name|segments
index|[
name|i
index|]
operator|.
name|modCount
condition|)
block|{
name|cleanSweep
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|cleanSweep
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|// Resort to locking all segments
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|segments
index|[
name|i
index|]
operator|.
name|lock
argument_list|()
expr_stmt|;
block|}
name|boolean
name|found
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|segments
index|[
name|i
index|]
operator|.
name|containsValue
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
finally|finally
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|segments
index|[
name|i
index|]
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
comment|/**      * Legacy method testing if some key maps into the specified value in this      * table.  This method is identical in functionality to      * {@link #containsValue}, and exists solely to ensure full compatibility      * with class {@link Hashtable}, which supported this method prior to      * introduction of the Java Collections framework.      *      * @param value a value to search for      * @return<tt>true</tt> if and only if some key maps to the<tt>value</tt>      *         argument in this table as determined by the<tt>equals</tt>      *         method;<tt>false</tt> otherwise      * @throws NullPointerException if the specified value is null      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Maps the specified key to the specified value in this table.  Neither the      * key nor the value can be null.      *      *<p>The value can be retrieved by calling the<tt>get</tt> method with a      * key that is equal to the original key.      *      * @param key   key with which the specified value is to be associated      * @param value value to be associated with the specified key      * @return the previous value associated with<tt>key</tt>, or<tt>null</tt>      *         if there was no mapping for<tt>key</tt>      * @throws NullPointerException if the specified key or value is null      */
annotation|@
name|Override
DECL|method|put
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key, or      *<tt>null</tt> if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|putIfAbsent
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Copies all of the mappings from the specified map to this one.  These      * mappings replace any mappings that this map had for any of the keys      * currently in the specified map.      *      * @param m mappings to be stored in this map      */
annotation|@
name|Override
DECL|method|putAll
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|put
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Removes the key (and its corresponding value) from this map.  This method      * does nothing if the key is not in the map.      *      * @param key the key that needs to be removed      * @return the previous value associated with<tt>key</tt>, or<tt>null</tt>      *         if there was no mapping for<tt>key</tt>      * @throws NullPointerException if the specified key is null      */
annotation|@
name|Override
DECL|method|remove
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if the specified key is null      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|remove
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if any of the arguments are null      */
DECL|method|replace
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|oldValue
operator|==
literal|null
operator|||
name|newValue
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|oldValue
argument_list|,
name|newValue
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key, or      *<tt>null</tt> if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|replace
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|int
name|hash
init|=
name|hashOf
argument_list|(
name|key
argument_list|)
decl_stmt|;
return|return
name|segmentFor
argument_list|(
name|hash
argument_list|)
operator|.
name|replace
argument_list|(
name|key
argument_list|,
name|hash
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * Removes all of the mappings from this map.      */
annotation|@
name|Override
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|segments
index|[
name|i
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns a {@link Set} view of the keys contained in this map.  The set is      * backed by the map, so changes to the map are reflected in the set, and      * vice-versa.  The set supports element removal, which removes the      * corresponding mapping from this map, via the<tt>Iterator.remove</tt>,      *<tt>Set.remove</tt>,<tt>removeAll</tt>,<tt>retainAll</tt>, and      *<tt>clear</tt> operations.  It does not support the<tt>add</tt> or      *<tt>addAll</tt> operations.      *      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException}, and guarantees      * to traverse elements as they existed upon construction of the iterator,      * and may (but is not guaranteed to) reflect any modifications subsequent      * to construction.      */
annotation|@
name|Override
DECL|method|keySet
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|Set
argument_list|<
name|K
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
name|ks
operator|!=
literal|null
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|()
operator|)
return|;
block|}
comment|/**      * Returns a {@link Collection} view of the values contained in this map.      * The collection is backed by the map, so changes to the map are reflected      * in the collection, and vice-versa.  The collection supports element      * removal, which removes the corresponding mapping from this map, via the      *<tt>Iterator.remove</tt>,<tt>Collection.remove</tt>,<tt>removeAll</tt>,      *<tt>retainAll</tt>, and<tt>clear</tt> operations.  It does not support      * the<tt>add</tt> or<tt>addAll</tt> operations.      *      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException}, and guarantees      * to traverse elements as they existed upon construction of the iterator,      * and may (but is not guaranteed to) reflect any modifications subsequent      * to construction.      */
annotation|@
name|Override
DECL|method|values
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Collection
argument_list|<
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
name|vs
operator|!=
literal|null
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|()
operator|)
return|;
block|}
comment|/**      * Returns a {@link Set} view of the mappings contained in this map.      * The set is backed by the map, so changes to the map are reflected in the      * set, and vice-versa.  The set supports element removal, which removes the      * corresponding mapping from the map, via the<tt>Iterator.remove</tt>,      *<tt>Set.remove</tt>,<tt>removeAll</tt>,<tt>retainAll</tt>, and      *<tt>clear</tt> operations.  It does not support the<tt>add</tt> or      *<tt>addAll</tt> operations.      *      *<p>The view's<tt>iterator</tt> is a "weakly consistent" iterator that      * will never throw {@link ConcurrentModificationException}, and guarantees      * to traverse elements as they existed upon construction of the iterator,      * and may (but is not guaranteed to) reflect any modifications subsequent      * to construction.      */
annotation|@
name|Override
DECL|method|entrySet
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
name|es
operator|!=
literal|null
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|()
operator|)
return|;
block|}
comment|/**      * Returns an enumeration of the keys in this table.      *      * @return an enumeration of the keys in this table      * @see #keySet()      */
DECL|method|keys
specifier|public
name|Enumeration
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
comment|/**      * Returns an enumeration of the values in this table.      *      * @return an enumeration of the values in this table      * @see #values()      */
DECL|method|elements
specifier|public
name|Enumeration
argument_list|<
name|V
argument_list|>
name|elements
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
comment|/* ---------------- Iterator Support -------------- */
DECL|class|HashIterator
specifier|abstract
class|class
name|HashIterator
block|{
DECL|field|nextSegmentIndex
name|int
name|nextSegmentIndex
decl_stmt|;
DECL|field|nextTableIndex
name|int
name|nextTableIndex
decl_stmt|;
DECL|field|currentTable
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|currentTable
decl_stmt|;
DECL|field|nextEntry
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEntry
decl_stmt|;
DECL|field|lastReturned
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastReturned
decl_stmt|;
DECL|field|currentKey
name|K
name|currentKey
decl_stmt|;
comment|// Strong reference to weak key (prevents gc)
DECL|method|HashIterator
name|HashIterator
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
DECL|method|rewind
specifier|public
name|void
name|rewind
parameter_list|()
block|{
name|nextSegmentIndex
operator|=
name|segments
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|nextTableIndex
operator|=
operator|-
literal|1
expr_stmt|;
name|currentTable
operator|=
literal|null
expr_stmt|;
name|nextEntry
operator|=
literal|null
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
name|currentKey
operator|=
literal|null
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
DECL|method|hasMoreElements
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
DECL|method|advance
specifier|final
name|void
name|advance
parameter_list|()
block|{
if|if
condition|(
name|nextEntry
operator|!=
literal|null
operator|&&
operator|(
name|nextEntry
operator|=
name|nextEntry
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
while|while
condition|(
name|nextTableIndex
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
index|[
name|nextTableIndex
operator|--
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
return|return;
block|}
block|}
while|while
condition|(
name|nextSegmentIndex
operator|>=
literal|0
condition|)
block|{
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|seg
init|=
name|segments
index|[
name|nextSegmentIndex
operator|--
index|]
decl_stmt|;
if|if
condition|(
name|seg
operator|.
name|count
operator|!=
literal|0
condition|)
block|{
name|currentTable
operator|=
name|seg
operator|.
name|table
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|currentTable
operator|.
name|length
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
operator|(
name|nextEntry
operator|=
name|currentTable
index|[
name|j
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|nextTableIndex
operator|=
name|j
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
while|while
condition|(
name|nextEntry
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|nextEntry
operator|.
name|key
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
literal|true
return|;
block|}
name|advance
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|nextEntry
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextEntry
parameter_list|()
block|{
do|do
block|{
if|if
condition|(
name|nextEntry
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|lastReturned
operator|=
name|nextEntry
expr_stmt|;
name|currentKey
operator|=
name|lastReturned
operator|.
name|key
argument_list|()
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|currentKey
operator|==
literal|null
condition|)
do|;
comment|// Skip GC'd keys
return|return
name|lastReturned
return|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|lastReturned
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|currentKey
argument_list|)
expr_stmt|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|final
class|class
name|KeyIterator
extends|extends
name|HashIterator
implements|implements
name|ReusableIterator
argument_list|<
name|K
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|K
argument_list|>
block|{
DECL|method|next
specifier|public
name|K
name|next
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextEntry
argument_list|()
operator|.
name|key
argument_list|()
return|;
block|}
DECL|method|nextElement
specifier|public
name|K
name|nextElement
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextEntry
argument_list|()
operator|.
name|key
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|final
class|class
name|ValueIterator
extends|extends
name|HashIterator
implements|implements
name|ReusableIterator
argument_list|<
name|V
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|V
argument_list|>
block|{
DECL|method|next
specifier|public
name|V
name|next
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextEntry
argument_list|()
operator|.
name|value
argument_list|()
return|;
block|}
DECL|method|nextElement
specifier|public
name|V
name|nextElement
parameter_list|()
block|{
return|return
name|super
operator|.
name|nextEntry
argument_list|()
operator|.
name|value
argument_list|()
return|;
block|}
block|}
comment|/*      * This class is needed for JDK5 compatibility.      */
DECL|class|SimpleEntry
specifier|static
class|class
name|SimpleEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|8144765946475398746L
decl_stmt|;
DECL|field|key
specifier|private
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|value
specifier|private
name|V
name|value
decl_stmt|;
DECL|method|SimpleEntry
specifier|public
name|SimpleEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
DECL|method|SimpleEntry
specifier|public
name|SimpleEntry
parameter_list|(
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|entry
operator|.
name|getKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|entry
operator|.
name|getValue
argument_list|()
expr_stmt|;
block|}
DECL|method|getKey
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
DECL|method|setValue
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
name|V
name|oldValue
init|=
name|this
operator|.
name|value
decl_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|oldValue
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Map
operator|.
name|Entry
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
operator|)
name|o
decl_stmt|;
return|return
name|eq
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
operator|&&
name|eq
argument_list|(
name|value
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
operator|(
name|key
operator|==
literal|null
condition|?
literal|0
else|:
name|key
operator|.
name|hashCode
argument_list|()
operator|)
operator|^
operator|(
name|value
operator|==
literal|null
condition|?
literal|0
else|:
name|value
operator|.
name|hashCode
argument_list|()
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|key
operator|+
literal|"="
operator|+
name|value
return|;
block|}
DECL|method|eq
specifier|private
specifier|static
name|boolean
name|eq
parameter_list|(
name|Object
name|o1
parameter_list|,
name|Object
name|o2
parameter_list|)
block|{
return|return
name|o1
operator|==
literal|null
condition|?
name|o2
operator|==
literal|null
else|:
name|o1
operator|.
name|equals
argument_list|(
name|o2
argument_list|)
return|;
block|}
block|}
comment|/**      * Custom Entry class used by EntryIterator.next(), that relays setValue      * changes to the underlying map.      */
DECL|class|WriteThroughEntry
specifier|final
class|class
name|WriteThroughEntry
extends|extends
name|SimpleEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|WriteThroughEntry
name|WriteThroughEntry
parameter_list|(
name|K
name|k
parameter_list|,
name|V
name|v
parameter_list|)
block|{
name|super
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**          * Set our entry's value and write through to the map. The value to          * return is somewhat arbitrary here. Since a WriteThroughEntry does not          * necessarily track asynchronous changes, the most recent "previous"          * value could be different from what we return (or could even have been          * removed in which case the put will re-establish). We do not and can          * not guarantee more.          */
annotation|@
name|Override
DECL|method|setValue
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
name|V
name|v
init|=
name|super
operator|.
name|setValue
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|put
argument_list|(
name|getKey
argument_list|()
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|final
class|class
name|EntryIterator
extends|extends
name|HashIterator
implements|implements
name|ReusableIterator
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|next
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
name|HashEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|super
operator|.
name|nextEntry
argument_list|()
decl_stmt|;
return|return
operator|new
name|WriteThroughEntry
argument_list|(
name|e
operator|.
name|key
argument_list|()
argument_list|,
name|e
operator|.
name|value
argument_list|()
argument_list|)
return|;
block|}
block|}
DECL|class|KeySet
specifier|final
class|class
name|KeySet
extends|extends
name|AbstractSet
argument_list|<
name|K
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|Values
specifier|final
class|class
name|Values
extends|extends
name|AbstractCollection
argument_list|<
name|V
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|EntrySet
specifier|final
class|class
name|EntrySet
extends|extends
name|AbstractSet
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|V
name|v
init|=
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|get
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|v
operator|!=
literal|null
operator|&&
name|v
operator|.
name|equals
argument_list|(
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
init|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|remove
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|size
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|isEmpty
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|ConcurrentIdentityHashMap
operator|.
name|this
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

