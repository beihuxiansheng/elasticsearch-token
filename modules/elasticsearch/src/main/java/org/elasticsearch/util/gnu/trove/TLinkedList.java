begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.gnu.trove
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|gnu
operator|.
name|trove
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Externalizable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectInput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectOutput
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSequentialList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ListIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_comment
comment|/**  * A LinkedList implementation which holds instances of type  *<tt>TLinkable</tt>.  *<p/>  *<p>Using this implementation allows you to get java.util.LinkedList  * behavior (a doubly linked list, with Iterators that support insert  * and delete operations) without incurring the overhead of creating  *<tt>Node</tt> wrapper objects for every element in your list.</p>  *<p/>  *<p>The requirement to achieve this time/space gain is that the  * Objects stored in the List implement the<tt>TLinkable</tt>  * interface.</p>  *<p/>  *<p>The limitations are that you cannot put the same object into  * more than one list or more than once in the same list.  You must  * also ensure that you only remove objects that are actually in the  * list.  That is, if you have an object A and lists l1 and l2, you  * must ensure that you invoke List.remove(A) on the correct list.  It  * is also forbidden to invoke List.remove() with an unaffiliated  * TLinkable (one that belongs to no list): this will destroy the list  * you invoke it on.</p>  *<p/>  *<p>  * Created: Sat Nov 10 15:25:10 2001  *</p>  *  * @author Eric D. Friedman  * @version $Id: TLinkedList.java,v 1.15 2009/03/31 19:43:14 robeden Exp $  * @see org.elasticsearch.util.gnu.trove.TLinkable  */
end_comment

begin_class
DECL|class|TLinkedList
specifier|public
class|class
name|TLinkedList
parameter_list|<
name|T
extends|extends
name|TLinkable
parameter_list|>
extends|extends
name|AbstractSequentialList
argument_list|<
name|T
argument_list|>
implements|implements
name|Externalizable
block|{
DECL|field|serialVersionUID
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|1L
decl_stmt|;
comment|/**      * the head of the list      */
DECL|field|_head
specifier|protected
name|T
name|_head
decl_stmt|;
comment|/**      * the tail of the list      */
DECL|field|_tail
specifier|protected
name|T
name|_tail
decl_stmt|;
comment|/**      * the number of elements in the list      */
DECL|field|_size
specifier|protected
name|int
name|_size
init|=
literal|0
decl_stmt|;
comment|/**      * Creates a new<code>TLinkedList</code> instance.      */
DECL|method|TLinkedList
specifier|public
name|TLinkedList
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns an iterator positioned at<tt>index</tt>.  Assuming      * that the list has a value at that index, calling next() will      * retrieve and advance the iterator.  Assuming that there is a      * value before<tt>index</tt> in the list, calling previous()      * will retrieve it (the value at index - 1) and move the iterator      * to that position.  So, iterating from front to back starts at      * 0; iterating from back to front starts at<tt>size()</tt>.      *      * @param index an<code>int</code> value      * @return a<code>ListIterator</code> value      */
DECL|method|listIterator
specifier|public
name|ListIterator
argument_list|<
name|T
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|IteratorImpl
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/**      * Returns the number of elements in the list.      *      * @return an<code>int</code> value      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|_size
return|;
block|}
comment|/**      * Inserts<tt>linkable</tt> at index<tt>index</tt> in the list.      * All values> index are shifted over one position to accommodate      * the new addition.      *      * @param index    an<code>int</code> value      * @param linkable an object of type TLinkable      */
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|T
name|linkable
parameter_list|)
block|{
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|size
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"index:"
operator|+
name|index
argument_list|)
throw|;
block|}
name|insert
argument_list|(
name|index
argument_list|,
name|linkable
argument_list|)
expr_stmt|;
block|}
comment|/**      * Appends<tt>linkable</tt> to the end of the list.      *      * @param linkable an object of type TLinkable      * @return always true      */
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|T
name|linkable
parameter_list|)
block|{
name|insert
argument_list|(
name|_size
argument_list|,
name|linkable
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Inserts<tt>linkable</tt> at the head of the list.      *      * @param linkable an object of type TLinkable      */
DECL|method|addFirst
specifier|public
name|void
name|addFirst
parameter_list|(
name|T
name|linkable
parameter_list|)
block|{
name|insert
argument_list|(
literal|0
argument_list|,
name|linkable
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds<tt>linkable</tt> to the end of the list.      *      * @param linkable an object of type TLinkable      */
DECL|method|addLast
specifier|public
name|void
name|addLast
parameter_list|(
name|T
name|linkable
parameter_list|)
block|{
name|insert
argument_list|(
name|size
argument_list|()
argument_list|,
name|linkable
argument_list|)
expr_stmt|;
block|}
comment|/**      * Empties the list.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
if|if
condition|(
literal|null
operator|!=
name|_head
condition|)
block|{
for|for
control|(
name|TLinkable
name|link
init|=
name|_head
operator|.
name|getNext
argument_list|()
init|;
name|link
operator|!=
literal|null
condition|;
name|link
operator|=
name|link
operator|.
name|getNext
argument_list|()
control|)
block|{
name|TLinkable
name|prev
init|=
name|link
operator|.
name|getPrevious
argument_list|()
decl_stmt|;
name|prev
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|link
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|_head
operator|=
name|_tail
operator|=
literal|null
expr_stmt|;
block|}
name|_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Copies the list's contents into a native array.  This will be a      * shallow copy: the Tlinkable instances in the Object[] array      * have links to one another: changing those will put this list      * into an unpredictable state.  Holding a reference to one      * element in the list will prevent the others from being garbage      * collected unless you clear the next/previous links.<b>Caveat      * programmer!</b>      *      * @return an<code>Object[]</code> value      */
DECL|method|toArray
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|Object
index|[]
name|o
init|=
operator|new
name|Object
index|[
name|_size
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|TLinkable
name|link
init|=
name|_head
init|;
name|link
operator|!=
literal|null
condition|;
name|link
operator|=
name|link
operator|.
name|getNext
argument_list|()
control|)
block|{
name|o
index|[
name|i
operator|++
index|]
operator|=
name|link
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
comment|/**      * Copies the list to a native array, destroying the next/previous      * links as the copy is made.  This list will be emptied after the      * copy (as if clear() had been invoked).  The Object[] array      * returned will contain TLinkables that do<b>not</b> hold      * references to one another and so are less likely to be the      * cause of memory leaks.      *      * @return an<code>Object[]</code> value      */
DECL|method|toUnlinkedArray
specifier|public
name|Object
index|[]
name|toUnlinkedArray
parameter_list|()
block|{
name|Object
index|[]
name|o
init|=
operator|new
name|Object
index|[
name|_size
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|T
name|link
init|=
name|_head
init|,
name|tmp
init|=
literal|null
init|;
name|link
operator|!=
literal|null
condition|;
name|i
operator|++
control|)
block|{
name|o
index|[
name|i
index|]
operator|=
name|link
expr_stmt|;
name|tmp
operator|=
name|link
expr_stmt|;
name|link
operator|=
operator|(
name|T
operator|)
name|link
operator|.
name|getNext
argument_list|()
expr_stmt|;
name|tmp
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
comment|// clear the links
name|tmp
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|_size
operator|=
literal|0
expr_stmt|;
comment|// clear the list
name|_head
operator|=
name|_tail
operator|=
literal|null
expr_stmt|;
return|return
name|o
return|;
block|}
comment|/**      * A linear search for<tt>o</tt> in the list.      *      * @param o an<code>Object</code> value      * @return a<code>boolean</code> value      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
for|for
control|(
name|TLinkable
name|link
init|=
name|_head
init|;
name|link
operator|!=
literal|null
condition|;
name|link
operator|=
name|link
operator|.
name|getNext
argument_list|()
control|)
block|{
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|link
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|get
specifier|public
name|T
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
comment|// Blow out for bogus values
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|_size
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|(
literal|"Index: "
operator|+
name|index
operator|+
literal|", Size: "
operator|+
name|_size
argument_list|)
throw|;
block|}
comment|// Determine if it's better to get there from the front or the back
if|if
condition|(
name|index
operator|>
operator|(
name|_size
operator|>>
literal|1
operator|)
condition|)
block|{
name|int
name|position
init|=
name|_size
operator|-
literal|1
decl_stmt|;
name|T
name|node
init|=
name|_tail
decl_stmt|;
while|while
condition|(
name|position
operator|>
name|index
condition|)
block|{
name|node
operator|=
operator|(
name|T
operator|)
name|node
operator|.
name|getPrevious
argument_list|()
expr_stmt|;
name|position
operator|--
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
else|else
block|{
name|int
name|position
init|=
literal|0
decl_stmt|;
name|T
name|node
init|=
name|_head
decl_stmt|;
while|while
condition|(
name|position
operator|<
name|index
condition|)
block|{
name|node
operator|=
operator|(
name|T
operator|)
name|node
operator|.
name|getNext
argument_list|()
expr_stmt|;
name|position
operator|++
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
block|}
comment|/**      * Returns the head of the list      *      * @return an<code>Object</code> value      */
DECL|method|getFirst
specifier|public
name|T
name|getFirst
parameter_list|()
block|{
return|return
name|_head
return|;
block|}
comment|/**      * Returns the tail of the list.      *      * @return an<code>Object</code> value      */
DECL|method|getLast
specifier|public
name|T
name|getLast
parameter_list|()
block|{
return|return
name|_tail
return|;
block|}
comment|/**      * Return the node following the given node. This method exists for two reasons:      *<ol>      *<li>It's really not recommended that the methods implemented by TLinkable be      * called directly since they're used internally by this class.</li>      *<li>This solves problems arising from generics when working with the linked      * objects directly.</li>      *</ol>      *<p/>      * NOTE: this should only be used with nodes contained in the list. The results are      * undefined with anything else.      */
DECL|method|getNext
specifier|public
name|T
name|getNext
parameter_list|(
name|T
name|current
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|current
operator|.
name|getNext
argument_list|()
return|;
block|}
comment|/**      * Return the node preceding the given node. This method exists for two reasons:      *<ol>      *<li>It's really not recommended that the methods implemented by TLinkable be      * called directly since they're used internally by this class.</li>      *<li>This solves problems arising from generics when working with the linked      * objects directly.</li>      *</ol>      *<p/>      * NOTE: this should only be used with nodes contained in the list. The results are      * undefined with anything else.      */
DECL|method|getPrevious
specifier|public
name|T
name|getPrevious
parameter_list|(
name|T
name|current
parameter_list|)
block|{
return|return
operator|(
name|T
operator|)
name|current
operator|.
name|getPrevious
argument_list|()
return|;
block|}
comment|/**      * Remove and return the first element in the list.      *      * @return an<code>Object</code> value      */
DECL|method|removeFirst
specifier|public
name|T
name|removeFirst
parameter_list|()
block|{
name|T
name|o
init|=
name|_head
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|T
name|n
init|=
operator|(
name|T
operator|)
name|o
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|o
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|n
condition|)
block|{
name|n
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|_head
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|--
name|_size
operator|==
literal|0
condition|)
block|{
name|_tail
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
comment|/**      * Remove and return the last element in the list.      *      * @return an<code>Object</code> value      */
DECL|method|removeLast
specifier|public
name|T
name|removeLast
parameter_list|()
block|{
name|T
name|o
init|=
name|_tail
decl_stmt|;
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|null
return|;
name|T
name|prev
init|=
operator|(
name|T
operator|)
name|o
operator|.
name|getPrevious
argument_list|()
decl_stmt|;
name|o
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
literal|null
operator|!=
name|prev
condition|)
block|{
name|prev
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|_tail
operator|=
name|prev
expr_stmt|;
if|if
condition|(
operator|--
name|_size
operator|==
literal|0
condition|)
block|{
name|_head
operator|=
literal|null
expr_stmt|;
block|}
return|return
name|o
return|;
block|}
comment|/**      * Implementation of index-based list insertions.      *      * @param index    an<code>int</code> value      * @param linkable an object of type TLinkable      */
DECL|method|insert
specifier|protected
name|void
name|insert
parameter_list|(
name|int
name|index
parameter_list|,
name|T
name|linkable
parameter_list|)
block|{
name|T
name|newLink
init|=
name|linkable
decl_stmt|;
if|if
condition|(
name|_size
operator|==
literal|0
condition|)
block|{
name|_head
operator|=
name|_tail
operator|=
name|newLink
expr_stmt|;
comment|// first insertion
block|}
elseif|else
if|if
condition|(
name|index
operator|==
literal|0
condition|)
block|{
name|newLink
operator|.
name|setNext
argument_list|(
name|_head
argument_list|)
expr_stmt|;
comment|// insert at front
name|_head
operator|.
name|setPrevious
argument_list|(
name|newLink
argument_list|)
expr_stmt|;
name|_head
operator|=
name|newLink
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|==
name|_size
condition|)
block|{
comment|// insert at back
name|_tail
operator|.
name|setNext
argument_list|(
name|newLink
argument_list|)
expr_stmt|;
name|newLink
operator|.
name|setPrevious
argument_list|(
name|_tail
argument_list|)
expr_stmt|;
name|_tail
operator|=
name|newLink
expr_stmt|;
block|}
else|else
block|{
name|T
name|node
init|=
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
name|T
name|before
init|=
operator|(
name|T
operator|)
name|node
operator|.
name|getPrevious
argument_list|()
decl_stmt|;
if|if
condition|(
name|before
operator|!=
literal|null
condition|)
name|before
operator|.
name|setNext
argument_list|(
name|linkable
argument_list|)
expr_stmt|;
name|linkable
operator|.
name|setPrevious
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|linkable
operator|.
name|setNext
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|.
name|setPrevious
argument_list|(
name|linkable
argument_list|)
expr_stmt|;
block|}
name|_size
operator|++
expr_stmt|;
block|}
comment|/**      * Removes the specified element from the list.  Note that      * it is the caller's responsibility to ensure that the      * element does, in fact, belong to this list and not another      * instance of TLinkedList.      *      * @param o a TLinkable element already inserted in this list.      * @return true if the element was a TLinkable and removed      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|TLinkable
condition|)
block|{
name|T
name|p
decl_stmt|,
name|n
decl_stmt|;
name|TLinkable
name|link
init|=
operator|(
name|TLinkable
operator|)
name|o
decl_stmt|;
name|p
operator|=
operator|(
name|T
operator|)
name|link
operator|.
name|getPrevious
argument_list|()
expr_stmt|;
name|n
operator|=
operator|(
name|T
operator|)
name|link
operator|.
name|getNext
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
operator|&&
name|p
operator|==
literal|null
condition|)
block|{
comment|// emptying the list
comment|// It's possible this object is not something that's in the list. So,
comment|// make sure it's the head if it doesn't point to anything. This solves
comment|// problems caused by removing something multiple times.
if|if
condition|(
name|o
operator|!=
name|_head
condition|)
return|return
literal|false
return|;
name|_head
operator|=
name|_tail
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|null
condition|)
block|{
comment|// this is the tail
comment|// make previous the new tail
name|link
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|p
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|_tail
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
comment|// this is the head
comment|// make next the new head
name|link
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|n
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|_head
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
comment|// somewhere in the middle
name|p
operator|.
name|setNext
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|.
name|setPrevious
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|link
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|link
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
name|_size
operator|--
expr_stmt|;
comment|// reduce size of list
return|return
literal|true
return|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/**      * Inserts newElement into the list immediately before current.      * All elements to the right of and including current are shifted      * over.      *      * @param current    a<code>TLinkable</code> value currently in the list.      * @param newElement a<code>TLinkable</code> value to be added to      *                   the list.      */
DECL|method|addBefore
specifier|public
name|void
name|addBefore
parameter_list|(
name|T
name|current
parameter_list|,
name|T
name|newElement
parameter_list|)
block|{
if|if
condition|(
name|current
operator|==
name|_head
condition|)
block|{
name|addFirst
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|addLast
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TLinkable
name|p
init|=
name|current
operator|.
name|getPrevious
argument_list|()
decl_stmt|;
name|newElement
operator|.
name|setNext
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|p
operator|.
name|setNext
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
name|newElement
operator|.
name|setPrevious
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|current
operator|.
name|setPrevious
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
name|_size
operator|++
expr_stmt|;
block|}
block|}
comment|/**      * Inserts newElement into the list immediately after current.      * All elements to the left of and including current are shifted      * over.      *      * @param current    a<code>TLinkable</code> value currently in the list.      * @param newElement a<code>TLinkable</code> value to be added to      *                   the list.      */
DECL|method|addAfter
specifier|public
name|void
name|addAfter
parameter_list|(
name|T
name|current
parameter_list|,
name|T
name|newElement
parameter_list|)
block|{
if|if
condition|(
name|current
operator|==
name|_tail
condition|)
block|{
name|addLast
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|==
literal|null
condition|)
block|{
name|addFirst
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TLinkable
name|n
init|=
name|current
operator|.
name|getNext
argument_list|()
decl_stmt|;
name|newElement
operator|.
name|setPrevious
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|newElement
operator|.
name|setNext
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|current
operator|.
name|setNext
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
name|n
operator|.
name|setPrevious
argument_list|(
name|newElement
argument_list|)
expr_stmt|;
name|_size
operator|++
expr_stmt|;
block|}
block|}
comment|/**      * Executes<tt>procedure</tt> for each entry in the list.      *      * @param procedure a<code>TObjectProcedure</code> value      * @return false if the loop over the values terminated because      *         the procedure returned false for some value.      */
DECL|method|forEachValue
specifier|public
name|boolean
name|forEachValue
parameter_list|(
name|TObjectProcedure
argument_list|<
name|T
argument_list|>
name|procedure
parameter_list|)
block|{
name|T
name|node
init|=
name|_head
decl_stmt|;
while|while
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|boolean
name|keep_going
init|=
name|procedure
operator|.
name|execute
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|keep_going
condition|)
return|return
literal|false
return|;
name|node
operator|=
operator|(
name|T
operator|)
name|node
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|writeExternal
specifier|public
name|void
name|writeExternal
parameter_list|(
name|ObjectOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
comment|// VERSION
name|out
operator|.
name|writeByte
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// NUMBER OF ENTRIES
name|out
operator|.
name|writeInt
argument_list|(
name|_size
argument_list|)
expr_stmt|;
comment|// HEAD
name|out
operator|.
name|writeObject
argument_list|(
name|_head
argument_list|)
expr_stmt|;
comment|// TAIL
name|out
operator|.
name|writeObject
argument_list|(
name|_tail
argument_list|)
expr_stmt|;
block|}
DECL|method|readExternal
specifier|public
name|void
name|readExternal
parameter_list|(
name|ObjectInput
name|in
parameter_list|)
throws|throws
name|IOException
throws|,
name|ClassNotFoundException
block|{
comment|// VERSION
name|in
operator|.
name|readByte
argument_list|()
expr_stmt|;
comment|// NUMBER OF ENTRIED
name|_size
operator|=
name|in
operator|.
name|readInt
argument_list|()
expr_stmt|;
comment|// HEAD
name|_head
operator|=
operator|(
name|T
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
comment|// TAIL
name|_tail
operator|=
operator|(
name|T
operator|)
name|in
operator|.
name|readObject
argument_list|()
expr_stmt|;
block|}
comment|/**      * A ListIterator that supports additions and deletions.      */
DECL|class|IteratorImpl
specifier|protected
specifier|final
class|class
name|IteratorImpl
implements|implements
name|ListIterator
argument_list|<
name|T
argument_list|>
block|{
DECL|field|_nextIndex
specifier|private
name|int
name|_nextIndex
init|=
literal|0
decl_stmt|;
DECL|field|_next
specifier|private
name|T
name|_next
decl_stmt|;
DECL|field|_lastReturned
specifier|private
name|T
name|_lastReturned
decl_stmt|;
comment|/**          * Creates a new<code>Iterator</code> instance positioned at          *<tt>index</tt>.          *          * @param position an<code>int</code> value          */
DECL|method|IteratorImpl
name|IteratorImpl
parameter_list|(
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
argument_list|<
literal|0
operator|||
name|position
argument_list|>
name|_size
condition|)
block|{
throw|throw
operator|new
name|IndexOutOfBoundsException
argument_list|()
throw|;
block|}
name|_nextIndex
operator|=
name|position
expr_stmt|;
if|if
condition|(
name|position
operator|==
literal|0
condition|)
block|{
name|_next
operator|=
name|_head
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
name|_size
condition|)
block|{
name|_next
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|position
operator|<
operator|(
name|_size
operator|>>
literal|1
operator|)
condition|)
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|_next
operator|=
name|_head
init|;
name|pos
operator|<
name|position
condition|;
name|pos
operator|++
control|)
block|{
name|_next
operator|=
operator|(
name|T
operator|)
name|_next
operator|.
name|getNext
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|pos
init|=
name|_size
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|_next
operator|=
name|_tail
init|;
name|pos
operator|>
name|position
condition|;
name|pos
operator|--
control|)
block|{
name|_next
operator|=
operator|(
name|T
operator|)
name|_next
operator|.
name|getPrevious
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Insert<tt>linkable</tt> at the current position of the iterator.          * Calling next() after add() will return the added object.          *          * @param linkable an object of type TLinkable          */
DECL|method|add
specifier|public
specifier|final
name|void
name|add
parameter_list|(
name|T
name|linkable
parameter_list|)
block|{
name|_lastReturned
operator|=
literal|null
expr_stmt|;
name|_nextIndex
operator|++
expr_stmt|;
if|if
condition|(
name|_size
operator|==
literal|0
condition|)
block|{
name|TLinkedList
operator|.
name|this
operator|.
name|add
argument_list|(
name|linkable
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TLinkedList
operator|.
name|this
operator|.
name|addBefore
argument_list|(
name|_next
argument_list|,
name|linkable
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * True if a call to next() will return an object.          *          * @return a<code>boolean</code> value          */
DECL|method|hasNext
specifier|public
specifier|final
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|_nextIndex
operator|!=
name|_size
return|;
block|}
comment|/**          * True if a call to previous() will return a value.          *          * @return a<code>boolean</code> value          */
DECL|method|hasPrevious
specifier|public
specifier|final
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|_nextIndex
operator|!=
literal|0
return|;
block|}
comment|/**          * Returns the value at the Iterator's index and advances the          * iterator.          *          * @return an<code>Object</code> value          * @throws NoSuchElementException if there is no next element          */
DECL|method|next
specifier|public
specifier|final
name|T
name|next
parameter_list|()
block|{
if|if
condition|(
name|_nextIndex
operator|==
name|_size
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|_lastReturned
operator|=
name|_next
expr_stmt|;
name|_next
operator|=
operator|(
name|T
operator|)
name|_next
operator|.
name|getNext
argument_list|()
expr_stmt|;
name|_nextIndex
operator|++
expr_stmt|;
return|return
name|_lastReturned
return|;
block|}
comment|/**          * returns the index of the next node in the list (the          * one that would be returned by a call to next()).          *          * @return an<code>int</code> value          */
DECL|method|nextIndex
specifier|public
specifier|final
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|_nextIndex
return|;
block|}
comment|/**          * Returns the value before the Iterator's index and moves the          * iterator back one index.          *          * @return an<code>Object</code> value          * @throws NoSuchElementException if there is no previous element.          */
DECL|method|previous
specifier|public
specifier|final
name|T
name|previous
parameter_list|()
block|{
if|if
condition|(
name|_nextIndex
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
if|if
condition|(
name|_nextIndex
operator|==
name|_size
condition|)
block|{
name|_lastReturned
operator|=
name|_next
operator|=
name|_tail
expr_stmt|;
block|}
else|else
block|{
name|_lastReturned
operator|=
name|_next
operator|=
operator|(
name|T
operator|)
name|_next
operator|.
name|getPrevious
argument_list|()
expr_stmt|;
block|}
name|_nextIndex
operator|--
expr_stmt|;
return|return
name|_lastReturned
return|;
block|}
comment|/**          * Returns the previous element's index.          *          * @return an<code>int</code> value          */
DECL|method|previousIndex
specifier|public
specifier|final
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|_nextIndex
operator|-
literal|1
return|;
block|}
comment|/**          * Removes the current element in the list and shrinks its          * size accordingly.          *          * @throws IllegalStateException neither next nor previous          *                               have been invoked, or remove or add have been invoked after          *                               the last invocation of next or previous.          */
DECL|method|remove
specifier|public
specifier|final
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|_lastReturned
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"must invoke next or previous before invoking remove"
argument_list|)
throw|;
block|}
if|if
condition|(
name|_lastReturned
operator|!=
name|_next
condition|)
block|{
name|_nextIndex
operator|--
expr_stmt|;
block|}
name|_next
operator|=
operator|(
name|T
operator|)
name|_lastReturned
operator|.
name|getNext
argument_list|()
expr_stmt|;
name|TLinkedList
operator|.
name|this
operator|.
name|remove
argument_list|(
name|_lastReturned
argument_list|)
expr_stmt|;
name|_lastReturned
operator|=
literal|null
expr_stmt|;
block|}
comment|/**          * Replaces the current element in the list with          *<tt>linkable</tt>          *          * @param linkable an object of type TLinkable          */
DECL|method|set
specifier|public
specifier|final
name|void
name|set
parameter_list|(
name|T
name|linkable
parameter_list|)
block|{
if|if
condition|(
name|_lastReturned
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
name|T
name|l
init|=
name|linkable
decl_stmt|;
comment|// need to check both, since this could be the only
comment|// element in the list.
if|if
condition|(
name|_lastReturned
operator|==
name|_head
condition|)
block|{
name|_head
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
name|_lastReturned
operator|==
name|_tail
condition|)
block|{
name|_tail
operator|=
name|l
expr_stmt|;
block|}
name|swap
argument_list|(
name|_lastReturned
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|_lastReturned
operator|=
name|l
expr_stmt|;
block|}
comment|/**          * Replace from with to in the list.          *          * @param from a<code>TLinkable</code> value          * @param to   a<code>TLinkable</code> value          */
DECL|method|swap
specifier|private
name|void
name|swap
parameter_list|(
name|T
name|from
parameter_list|,
name|T
name|to
parameter_list|)
block|{
name|T
name|p
init|=
operator|(
name|T
operator|)
name|from
operator|.
name|getPrevious
argument_list|()
decl_stmt|;
name|T
name|n
init|=
operator|(
name|T
operator|)
name|from
operator|.
name|getNext
argument_list|()
decl_stmt|;
if|if
condition|(
literal|null
operator|!=
name|p
condition|)
block|{
name|to
operator|.
name|setPrevious
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|.
name|setNext
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|null
operator|!=
name|n
condition|)
block|{
name|to
operator|.
name|setNext
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|.
name|setPrevious
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|from
operator|.
name|setNext
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|from
operator|.
name|setPrevious
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

begin_comment
comment|// TLinkedList
end_comment

end_unit

