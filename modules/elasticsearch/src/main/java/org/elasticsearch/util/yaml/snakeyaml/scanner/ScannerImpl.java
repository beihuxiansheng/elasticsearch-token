begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.yaml.snakeyaml.scanner
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|scanner
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|error
operator|.
name|Mark
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|error
operator|.
name|YAMLException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|reader
operator|.
name|StreamReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|tokens
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|yaml
operator|.
name|snakeyaml
operator|.
name|util
operator|.
name|ArrayStack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  *<pre>  * Scanner produces tokens of the following types:  * STREAM-START  * STREAM-END  * DIRECTIVE(name, value)  * DOCUMENT-START  * DOCUMENT-END  * BLOCK-SEQUENCE-START  * BLOCK-MAPPING-START  * BLOCK-END  * FLOW-SEQUENCE-START  * FLOW-MAPPING-START  * FLOW-SEQUENCE-END  * FLOW-MAPPING-END  * BLOCK-ENTRY  * FLOW-ENTRY  * KEY  * VALUE  * ALIAS(value)  * ANCHOR(value)  * TAG(value)  * SCALAR(value, plain, style)  * Read comments in the Scanner code for more details.  *</pre>  *  * @see<a href="http://pyyaml.org/wiki/PyYAML">PyYAML</a> for more information  */
end_comment

begin_class
DECL|class|ScannerImpl
specifier|public
specifier|final
class|class
name|ScannerImpl
implements|implements
name|Scanner
block|{
DECL|field|ALPHA
specifier|private
specifier|final
specifier|static
name|String
name|ALPHA
init|=
literal|"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
decl_stmt|;
DECL|field|NOT_HEXA
specifier|private
specifier|final
specifier|static
name|Pattern
name|NOT_HEXA
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"[^0-9A-Fa-f]"
argument_list|)
decl_stmt|;
DECL|field|ESCAPE_REPLACEMENTS
specifier|public
specifier|final
specifier|static
name|Map
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
name|ESCAPE_REPLACEMENTS
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|ESCAPE_CODES
specifier|public
specifier|final
specifier|static
name|Map
argument_list|<
name|Character
argument_list|,
name|Integer
argument_list|>
name|ESCAPE_CODES
init|=
operator|new
name|HashMap
argument_list|<
name|Character
argument_list|,
name|Integer
argument_list|>
argument_list|()
decl_stmt|;
static|static
block|{
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'0'
argument_list|)
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'a'
argument_list|)
argument_list|,
literal|"\u0007"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'b'
argument_list|)
argument_list|,
literal|"\u0008"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'t'
argument_list|)
argument_list|,
literal|"\u0009"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'n'
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'v'
argument_list|)
argument_list|,
literal|"\u000B"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'f'
argument_list|)
argument_list|,
literal|"\u000C"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'r'
argument_list|)
argument_list|,
literal|"\r"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'e'
argument_list|)
argument_list|,
literal|"\u001B"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|' '
argument_list|)
argument_list|,
literal|"\u0020"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'"'
argument_list|)
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'\\'
argument_list|)
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'N'
argument_list|)
argument_list|,
literal|"\u0085"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'_'
argument_list|)
argument_list|,
literal|"\u00A0"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'L'
argument_list|)
argument_list|,
literal|"\u2028"
argument_list|)
expr_stmt|;
name|ESCAPE_REPLACEMENTS
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'P'
argument_list|)
argument_list|,
literal|"\u2029"
argument_list|)
expr_stmt|;
name|ESCAPE_CODES
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'x'
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ESCAPE_CODES
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'u'
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ESCAPE_CODES
operator|.
name|put
argument_list|(
operator|new
name|Character
argument_list|(
literal|'U'
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
DECL|field|reader
specifier|private
specifier|final
name|StreamReader
name|reader
decl_stmt|;
comment|// Had we reached the end of the stream?
DECL|field|done
specifier|private
name|boolean
name|done
init|=
literal|false
decl_stmt|;
comment|// The number of unclosed '{' and '['. `flow_level == 0` means block
comment|// context.
DECL|field|flowLevel
specifier|private
name|int
name|flowLevel
init|=
literal|0
decl_stmt|;
comment|// List of processed tokens that are not yet emitted.
DECL|field|tokens
specifier|private
name|List
argument_list|<
name|Token
argument_list|>
name|tokens
decl_stmt|;
comment|// Number of tokens that were emitted through the `get_token` method.
DECL|field|tokensTaken
specifier|private
name|int
name|tokensTaken
init|=
literal|0
decl_stmt|;
comment|// The current indentation level.
DECL|field|indent
specifier|private
name|int
name|indent
init|=
operator|-
literal|1
decl_stmt|;
comment|// Past indentation levels.
DECL|field|indents
specifier|private
name|ArrayStack
argument_list|<
name|Integer
argument_list|>
name|indents
decl_stmt|;
comment|// Variables related to simple keys treatment. See PyYAML.
comment|/**      *<pre>      * A simple key is a key that is not denoted by the '?' indicator.      * Example of simple keys:      *   ---      *   block simple key: value      *   ? not a simple key:      *   : { flow simple key: value }      * We emit the KEY token before all keys, so when we find a potential      * simple key, we try to locate the corresponding ':' indicator.      * Simple keys should be limited to a single line and 1024 characters.      *      * Can a simple key start at the current position? A simple key may      * start:      * - at the beginning of the line, not counting indentation spaces      *       (in block context),      * - after '{', '[', ',' (in the flow context),      * - after '?', ':', '-' (in the block context).      * In the block context, this flag also signifies if a block collection      * may start at the current position.      *</pre>      */
DECL|field|allowSimpleKey
specifier|private
name|boolean
name|allowSimpleKey
init|=
literal|true
decl_stmt|;
comment|/*      * Keep track of possible simple keys. This is a dictionary. The key is      * `flow_level`; there can be no more that one possible simple key for each      * level. The value is a SimpleKey record: (token_number, required, index,      * line, column, mark) A simple key may start with ALIAS, ANCHOR, TAG,      * SCALAR(flow), '[', or '{' tokens.      */
DECL|field|possibleSimpleKeys
specifier|private
name|Map
argument_list|<
name|Integer
argument_list|,
name|SimpleKey
argument_list|>
name|possibleSimpleKeys
decl_stmt|;
DECL|method|ScannerImpl
specifier|public
name|ScannerImpl
parameter_list|(
name|StreamReader
name|reader
parameter_list|)
block|{
name|this
operator|.
name|reader
operator|=
name|reader
expr_stmt|;
name|this
operator|.
name|tokens
operator|=
operator|new
name|ArrayList
argument_list|<
name|Token
argument_list|>
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|this
operator|.
name|indents
operator|=
operator|new
name|ArrayStack
argument_list|<
name|Integer
argument_list|>
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|// the order in possibleSimpleKeys is kept for nextPossibleSimpleKey()
name|this
operator|.
name|possibleSimpleKeys
operator|=
operator|new
name|LinkedHashMap
argument_list|<
name|Integer
argument_list|,
name|SimpleKey
argument_list|>
argument_list|()
expr_stmt|;
name|fetchStreamStart
argument_list|()
expr_stmt|;
comment|// Add the STREAM-START token.
block|}
comment|/**      * Check if the next token is one of the given types.      */
DECL|method|checkToken
specifier|public
name|boolean
name|checkToken
parameter_list|(
name|Token
operator|.
name|ID
modifier|...
name|choices
parameter_list|)
block|{
while|while
condition|(
name|needMoreTokens
argument_list|()
condition|)
block|{
name|fetchMoreTokens
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this
operator|.
name|tokens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|choices
operator|.
name|length
operator|==
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
name|Token
name|first
init|=
name|this
operator|.
name|tokens
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|Token
operator|.
name|ID
name|id
range|:
name|choices
control|)
block|{
if|if
condition|(
name|first
operator|.
name|getTokenId
argument_list|()
operator|==
name|id
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Return the next token, but do not delete if from the queue.      */
DECL|method|peekToken
specifier|public
name|Token
name|peekToken
parameter_list|()
block|{
while|while
condition|(
name|needMoreTokens
argument_list|()
condition|)
block|{
name|fetchMoreTokens
argument_list|()
expr_stmt|;
block|}
return|return
name|this
operator|.
name|tokens
operator|.
name|get
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/**      * Return the next token.      */
DECL|method|getToken
specifier|public
name|Token
name|getToken
parameter_list|()
block|{
if|if
condition|(
operator|!
name|this
operator|.
name|tokens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|this
operator|.
name|tokensTaken
operator|++
expr_stmt|;
return|return
name|this
operator|.
name|tokens
operator|.
name|remove
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
comment|// Private methods.
DECL|method|needMoreTokens
specifier|private
name|boolean
name|needMoreTokens
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|done
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|this
operator|.
name|tokens
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
comment|// The current token may be a potential simple key, so we
comment|// need to look further.
name|stalePossibleSimpleKeys
argument_list|()
expr_stmt|;
return|return
name|nextPossibleSimpleKey
argument_list|()
operator|==
name|this
operator|.
name|tokensTaken
return|;
block|}
DECL|method|fetchMoreTokens
specifier|private
name|void
name|fetchMoreTokens
parameter_list|()
block|{
comment|// Eat whitespaces and comments until we reach the next token.
name|scanToNextToken
argument_list|()
expr_stmt|;
comment|// Remove obsolete possible simple keys.
name|stalePossibleSimpleKeys
argument_list|()
expr_stmt|;
comment|// Compare the current indentation and column. It may add some tokens
comment|// and decrease the current indentation level.
name|unwindIndent
argument_list|(
name|reader
operator|.
name|getColumn
argument_list|()
argument_list|)
expr_stmt|;
comment|// Peek the next character.
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\0'
case|:
comment|// Is it the end of stream?
name|fetchStreamEnd
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'%'
case|:
comment|// Is it a directive?
if|if
condition|(
name|checkDirective
argument_list|()
condition|)
block|{
name|fetchDirective
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'-'
case|:
comment|// Is it the document start?
if|if
condition|(
name|checkDocumentStart
argument_list|()
condition|)
block|{
name|fetchDocumentStart
argument_list|()
expr_stmt|;
return|return;
comment|// Is it the block entry indicator?
block|}
elseif|else
if|if
condition|(
name|checkBlockEntry
argument_list|()
condition|)
block|{
name|fetchBlockEntry
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'.'
case|:
comment|// Is it the document end?
if|if
condition|(
name|checkDocumentEnd
argument_list|()
condition|)
block|{
name|fetchDocumentEnd
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
comment|// TODO support for BOM within a stream. (not implemented in PyYAML)
case|case
literal|'['
case|:
comment|// Is it the flow sequence start indicator?
name|fetchFlowSequenceStart
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'{'
case|:
comment|// Is it the flow mapping start indicator?
name|fetchFlowMappingStart
argument_list|()
expr_stmt|;
return|return;
case|case
literal|']'
case|:
comment|// Is it the flow sequence end indicator?
name|fetchFlowSequenceEnd
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'}'
case|:
comment|// Is it the flow mapping end indicator?
name|fetchFlowMappingEnd
argument_list|()
expr_stmt|;
return|return;
case|case
literal|','
case|:
comment|// Is it the flow entry indicator?
name|fetchFlowEntry
argument_list|()
expr_stmt|;
return|return;
comment|// see block entry indicator above
case|case
literal|'?'
case|:
comment|// Is it the key indicator?
if|if
condition|(
name|checkKey
argument_list|()
condition|)
block|{
name|fetchKey
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|':'
case|:
comment|// Is it the value indicator?
if|if
condition|(
name|checkValue
argument_list|()
condition|)
block|{
name|fetchValue
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'*'
case|:
comment|// Is it an alias?
name|fetchAlias
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'&'
case|:
comment|// Is it an anchor?
name|fetchAnchor
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'!'
case|:
comment|// Is it a tag?
name|fetchTag
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'|'
case|:
comment|// Is it a literal scalar?
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
condition|)
block|{
name|fetchLiteral
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'>'
case|:
comment|// Is it a folded scalar?
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
condition|)
block|{
name|fetchFolded
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'\''
case|:
comment|// Is it a single quoted scalar?
name|fetchSingle
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'"'
case|:
comment|// Is it a double quoted scalar?
name|fetchDouble
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// It must be a plain scalar then.
if|if
condition|(
name|checkPlain
argument_list|()
condition|)
block|{
name|fetchPlain
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// No? It's an error. Let's produce a nice error message.
name|String
name|chRepresentation
init|=
name|String
operator|.
name|valueOf
argument_list|(
name|ch
argument_list|)
decl_stmt|;
for|for
control|(
name|Character
name|s
range|:
name|ESCAPE_REPLACEMENTS
operator|.
name|keySet
argument_list|()
control|)
block|{
name|String
name|v
init|=
name|ESCAPE_REPLACEMENTS
operator|.
name|get
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|equals
argument_list|(
name|chRepresentation
argument_list|)
condition|)
block|{
name|chRepresentation
operator|=
literal|"\\"
operator|+
name|s
expr_stmt|;
comment|// ' ' -> '\t'
break|break;
block|}
block|}
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning for the next token"
argument_list|,
literal|null
argument_list|,
literal|"found character "
operator|+
name|ch
operator|+
literal|"'"
operator|+
name|chRepresentation
operator|+
literal|"' that cannot start any token"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
comment|// Simple keys treatment.
comment|/**      * Return the number of the nearest possible simple key. Actually we don't      * need to loop through the whole dictionary.      */
DECL|method|nextPossibleSimpleKey
specifier|private
name|int
name|nextPossibleSimpleKey
parameter_list|()
block|{
comment|/*          * the implementation is not as in PyYAML. Because          * this.possibleSimpleKeys is ordered we can simply take the first key          */
name|Iterator
argument_list|<
name|SimpleKey
argument_list|>
name|iter
init|=
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|iter
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|SimpleKey
name|key
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
return|return
name|key
operator|.
name|getTokenNumber
argument_list|()
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
comment|/**      *<pre>      * Remove entries that are no longer possible simple keys. According to      * the YAML specification, simple keys      * - should be limited to a single line,      * - should be no longer than 1024 characters.      * Disabling this procedure will allow simple keys of any length and      * height (may cause problems if indentation is broken though).      *</pre>      */
DECL|method|stalePossibleSimpleKeys
specifier|private
name|void
name|stalePossibleSimpleKeys
parameter_list|()
block|{
comment|// use toRemove to avoid java.util.ConcurrentModificationException
name|Set
argument_list|<
name|Integer
argument_list|>
name|toRemove
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Integer
name|level
range|:
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|keySet
argument_list|()
control|)
block|{
name|SimpleKey
name|key
init|=
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|get
argument_list|(
name|level
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|key
operator|.
name|getLine
argument_list|()
operator|!=
name|reader
operator|.
name|getLine
argument_list|()
operator|)
operator|||
operator|(
name|reader
operator|.
name|getIndex
argument_list|()
operator|-
name|key
operator|.
name|getIndex
argument_list|()
operator|>
literal|1024
operator|)
condition|)
block|{
if|if
condition|(
name|key
operator|.
name|isRequired
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a simple key"
argument_list|,
name|key
operator|.
name|getMark
argument_list|()
argument_list|,
literal|"could not found expected ':'"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|toRemove
operator|==
literal|null
condition|)
block|{
name|toRemove
operator|=
operator|new
name|HashSet
argument_list|<
name|Integer
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|toRemove
operator|.
name|add
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|toRemove
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Integer
name|level
range|:
name|toRemove
control|)
block|{
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|remove
argument_list|(
name|level
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * The next token may start a simple key. We check if it's possible and save      * its position. This function is called for ALIAS, ANCHOR, TAG,      * SCALAR(flow), '[', and '{'.      */
DECL|method|savePossibleSimpleKey
specifier|private
name|void
name|savePossibleSimpleKey
parameter_list|()
block|{
comment|// The next token may start a simple key. We check if it's possible
comment|// and save its position. This function is called for
comment|// ALIAS, ANCHOR, TAG, SCALAR(flow), '[', and '{'.
comment|// Check if a simple key is required at the current position.
name|boolean
name|required
init|=
operator|(
operator|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
operator|)
operator|&&
operator|(
name|this
operator|.
name|indent
operator|==
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|allowSimpleKey
operator|||
operator|!
name|required
condition|)
block|{
comment|// A simple key is required only if it is the first token in the
comment|// current
comment|// line. Therefore it is always allowed.
block|}
else|else
block|{
throw|throw
operator|new
name|YAMLException
argument_list|(
literal|"A simple key is required only if it is the first token in the current line"
argument_list|)
throw|;
block|}
comment|// The next token might be a simple key. Let's save it's number and
comment|// position.
if|if
condition|(
name|this
operator|.
name|allowSimpleKey
condition|)
block|{
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
name|int
name|tokenNumber
init|=
name|this
operator|.
name|tokensTaken
operator|+
name|this
operator|.
name|tokens
operator|.
name|size
argument_list|()
decl_stmt|;
name|SimpleKey
name|key
init|=
operator|new
name|SimpleKey
argument_list|(
name|tokenNumber
argument_list|,
name|required
argument_list|,
name|reader
operator|.
name|getIndex
argument_list|()
argument_list|,
name|reader
operator|.
name|getLine
argument_list|()
argument_list|,
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
argument_list|,
name|this
operator|.
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
decl_stmt|;
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|put
argument_list|(
name|this
operator|.
name|flowLevel
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Remove the saved possible key position at the current flow level.      */
DECL|method|removePossibleSimpleKey
specifier|private
name|void
name|removePossibleSimpleKey
parameter_list|()
block|{
name|SimpleKey
name|key
init|=
name|possibleSimpleKeys
operator|.
name|get
argument_list|(
name|flowLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|key
operator|!=
literal|null
operator|&&
name|key
operator|.
name|isRequired
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a simple key"
argument_list|,
name|key
operator|.
name|getMark
argument_list|()
argument_list|,
literal|"could not found expected ':'"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|possibleSimpleKeys
operator|.
name|remove
argument_list|(
name|flowLevel
argument_list|)
expr_stmt|;
block|}
comment|// Indentation functions.
comment|/**      *<pre>      * In flow context, tokens should respect indentation.      * Actually the condition should be `self.indent&gt;= column` according to      * the spec. But this condition will prohibit intuitively correct      * constructions such as      * key : {      * }      *</pre>      */
DECL|method|unwindIndent
specifier|private
name|void
name|unwindIndent
parameter_list|(
name|int
name|col
parameter_list|)
block|{
comment|// In the flow context, indentation is ignored. We make the scanner less
comment|// restrictive then specification requires.
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|// In block context, we may need to issue the BLOCK-END tokens.
while|while
condition|(
name|this
operator|.
name|indent
operator|>
name|col
condition|)
block|{
name|Mark
name|mark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|this
operator|.
name|indent
operator|=
name|this
operator|.
name|indents
operator|.
name|pop
argument_list|()
expr_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
operator|new
name|BlockEndToken
argument_list|(
name|mark
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Check if we need to increase indentation.      */
DECL|method|addIndent
specifier|private
name|boolean
name|addIndent
parameter_list|(
name|int
name|column
parameter_list|)
block|{
if|if
condition|(
name|this
operator|.
name|indent
operator|<
name|column
condition|)
block|{
name|this
operator|.
name|indents
operator|.
name|push
argument_list|(
name|this
operator|.
name|indent
argument_list|)
expr_stmt|;
name|this
operator|.
name|indent
operator|=
name|column
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// Fetchers.
comment|/**      * We always add STREAM-START as the first token and STREAM-END as the last      * token.      */
DECL|method|fetchStreamStart
specifier|private
name|void
name|fetchStreamStart
parameter_list|()
block|{
comment|// Read the token.
name|Mark
name|mark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
comment|// Add STREAM-START.
name|Token
name|token
init|=
operator|new
name|StreamStartToken
argument_list|(
name|mark
argument_list|,
name|mark
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchStreamEnd
specifier|private
name|void
name|fetchStreamEnd
parameter_list|()
block|{
comment|// Set the current intendation to -1.
name|unwindIndent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Reset simple keys.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Read the token.
name|Mark
name|mark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
comment|// Add STREAM-END.
name|Token
name|token
init|=
operator|new
name|StreamEndToken
argument_list|(
name|mark
argument_list|,
name|mark
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
comment|// The stream is finished.
name|this
operator|.
name|done
operator|=
literal|true
expr_stmt|;
block|}
DECL|method|fetchDirective
specifier|private
name|void
name|fetchDirective
parameter_list|()
block|{
comment|// Set the current intendation to -1.
name|unwindIndent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Reset simple keys.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Scan and add DIRECTIVE.
name|Token
name|tok
init|=
name|scanDirective
argument_list|()
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchDocumentStart
specifier|private
name|void
name|fetchDocumentStart
parameter_list|()
block|{
name|fetchDocumentIndicator
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchDocumentEnd
specifier|private
name|void
name|fetchDocumentEnd
parameter_list|()
block|{
name|fetchDocumentIndicator
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchDocumentIndicator
specifier|private
name|void
name|fetchDocumentIndicator
parameter_list|(
name|boolean
name|isDocumentStart
parameter_list|)
block|{
comment|// Set the current intendation to -1.
name|unwindIndent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// Reset simple keys. Note that there could not be a block collection
comment|// after '---'.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Add DOCUMENT-START or DOCUMENT-END.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|token
decl_stmt|;
if|if
condition|(
name|isDocumentStart
condition|)
block|{
name|token
operator|=
operator|new
name|DocumentStartToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|token
operator|=
operator|new
name|DocumentEndToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowSequenceStart
specifier|private
name|void
name|fetchFlowSequenceStart
parameter_list|()
block|{
name|fetchFlowCollectionStart
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowMappingStart
specifier|private
name|void
name|fetchFlowMappingStart
parameter_list|()
block|{
name|fetchFlowCollectionStart
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowCollectionStart
specifier|private
name|void
name|fetchFlowCollectionStart
parameter_list|(
name|boolean
name|isMappingStart
parameter_list|)
block|{
comment|// '[' and '{' may start a simple key.
name|savePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// Increase the flow level.
name|this
operator|.
name|flowLevel
operator|++
expr_stmt|;
comment|// Simple keys are allowed after '[' and '{'.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|true
expr_stmt|;
comment|// Add FLOW-SEQUENCE-START or FLOW-MAPPING-START.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|token
decl_stmt|;
if|if
condition|(
name|isMappingStart
condition|)
block|{
name|token
operator|=
operator|new
name|FlowMappingStartToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|token
operator|=
operator|new
name|FlowSequenceStartToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowSequenceEnd
specifier|private
name|void
name|fetchFlowSequenceEnd
parameter_list|()
block|{
name|fetchFlowCollectionEnd
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowMappingEnd
specifier|private
name|void
name|fetchFlowMappingEnd
parameter_list|()
block|{
name|fetchFlowCollectionEnd
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowCollectionEnd
specifier|private
name|void
name|fetchFlowCollectionEnd
parameter_list|(
name|boolean
name|isMappingEnd
parameter_list|)
block|{
comment|// Reset possible simple key on the current level.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// Decrease the flow level.
name|this
operator|.
name|flowLevel
operator|--
expr_stmt|;
comment|// No simple keys after ']' or '}'.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Add FLOW-SEQUENCE-END or FLOW-MAPPING-END.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|token
decl_stmt|;
if|if
condition|(
name|isMappingEnd
condition|)
block|{
name|token
operator|=
operator|new
name|FlowMappingEndToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|token
operator|=
operator|new
name|FlowSequenceEndToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowEntry
specifier|private
name|void
name|fetchFlowEntry
parameter_list|()
block|{
comment|// Simple keys are allowed after ','.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|true
expr_stmt|;
comment|// Reset possible simple key on the current level.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// Add FLOW-ENTRY.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|token
init|=
operator|new
name|FlowEntryToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchBlockEntry
specifier|private
name|void
name|fetchBlockEntry
parameter_list|()
block|{
comment|// Block context needs additional checks.
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
condition|)
block|{
comment|// Are we allowed to start a new entry?
if|if
condition|(
operator|!
name|this
operator|.
name|allowSimpleKey
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"sequence entries are not allowed here"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
comment|// We may need to add BLOCK-SEQUENCE-START.
if|if
condition|(
name|addIndent
argument_list|(
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
name|Mark
name|mark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
operator|new
name|BlockSequenceStartToken
argument_list|(
name|mark
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// It's an error for the block entry to occur in the flow
comment|// context,but we let the parser detect this.
block|}
comment|// Simple keys are allowed after '-'.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|true
expr_stmt|;
comment|// Reset possible simple key on the current level.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// Add BLOCK-ENTRY.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|token
init|=
operator|new
name|BlockEntryToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchKey
specifier|private
name|void
name|fetchKey
parameter_list|()
block|{
comment|// Block context needs additional checks.
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
condition|)
block|{
comment|// Are we allowed to start a key (not necessary a simple)?
if|if
condition|(
operator|!
name|this
operator|.
name|allowSimpleKey
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"mapping keys are not allowed here"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
comment|// We may need to add BLOCK-MAPPING-START.
if|if
condition|(
name|addIndent
argument_list|(
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
name|Mark
name|mark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
operator|new
name|BlockMappingStartToken
argument_list|(
name|mark
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Simple keys are allowed after '?' in the block context.
name|this
operator|.
name|allowSimpleKey
operator|=
name|this
operator|.
name|flowLevel
operator|==
literal|0
expr_stmt|;
comment|// Reset possible simple key on the current level.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// Add KEY.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|token
init|=
operator|new
name|KeyToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchValue
specifier|private
name|void
name|fetchValue
parameter_list|()
block|{
comment|// Do we determine a simple key?
if|if
condition|(
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|keySet
argument_list|()
operator|.
name|contains
argument_list|(
name|this
operator|.
name|flowLevel
argument_list|)
condition|)
block|{
comment|// Add KEY.
name|SimpleKey
name|key
init|=
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|get
argument_list|(
name|this
operator|.
name|flowLevel
argument_list|)
decl_stmt|;
name|this
operator|.
name|possibleSimpleKeys
operator|.
name|remove
argument_list|(
name|this
operator|.
name|flowLevel
argument_list|)
expr_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|key
operator|.
name|getTokenNumber
argument_list|()
operator|-
name|this
operator|.
name|tokensTaken
argument_list|,
operator|new
name|KeyToken
argument_list|(
name|key
operator|.
name|getMark
argument_list|()
argument_list|,
name|key
operator|.
name|getMark
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// If this key starts a new block mapping, we need to add
comment|// BLOCK-MAPPING-START.
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|addIndent
argument_list|(
name|key
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|key
operator|.
name|getTokenNumber
argument_list|()
operator|-
name|this
operator|.
name|tokensTaken
argument_list|,
operator|new
name|BlockMappingStartToken
argument_list|(
name|key
operator|.
name|getMark
argument_list|()
argument_list|,
name|key
operator|.
name|getMark
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// There cannot be two simple keys one after another.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// It must be a part of a complex key.
comment|// Block context needs additional checks.Do we really need them?
comment|// They
comment|// will be catched by the parser anyway.)
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
condition|)
block|{
comment|// We are allowed to start a complex value if and only if we can
comment|// start a simple key.
if|if
condition|(
operator|!
name|this
operator|.
name|allowSimpleKey
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|null
argument_list|,
literal|null
argument_list|,
literal|"mapping values are not allowed here"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
block|}
comment|// If this value starts a new block mapping, we need to add
comment|// BLOCK-MAPPING-START. It will be detected as an error later by
comment|// the parser.
if|if
condition|(
name|flowLevel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|addIndent
argument_list|(
name|reader
operator|.
name|getColumn
argument_list|()
argument_list|)
condition|)
block|{
name|Mark
name|mark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
operator|new
name|BlockMappingStartToken
argument_list|(
name|mark
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Simple keys are allowed after ':' in the block context.
name|allowSimpleKey
operator|=
operator|(
name|flowLevel
operator|==
literal|0
operator|)
expr_stmt|;
comment|// Reset possible simple key on the current level.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
block|}
comment|// Add VALUE.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|token
init|=
operator|new
name|ValueToken
argument_list|(
name|startMark
argument_list|,
name|endMark
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|token
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchAlias
specifier|private
name|void
name|fetchAlias
parameter_list|()
block|{
comment|// ALIAS could be a simple key.
name|savePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// No simple keys after ALIAS.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Scan and add ALIAS.
name|Token
name|tok
init|=
name|scanAnchor
argument_list|(
literal|false
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchAnchor
specifier|private
name|void
name|fetchAnchor
parameter_list|()
block|{
comment|// ANCHOR could start a simple key.
name|savePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// No simple keys after ANCHOR.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Scan and add ANCHOR.
name|Token
name|tok
init|=
name|scanAnchor
argument_list|(
literal|true
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchTag
specifier|private
name|void
name|fetchTag
parameter_list|()
block|{
comment|// TAG could start a simple key.
name|savePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// No simple keys after TAG.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Scan and add TAG.
name|Token
name|tok
init|=
name|scanTag
argument_list|()
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchLiteral
specifier|private
name|void
name|fetchLiteral
parameter_list|()
block|{
name|fetchBlockScalar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFolded
specifier|private
name|void
name|fetchFolded
parameter_list|()
block|{
name|fetchBlockScalar
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchBlockScalar
specifier|private
name|void
name|fetchBlockScalar
parameter_list|(
name|char
name|style
parameter_list|)
block|{
comment|// A simple key may follow a block scalar.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|true
expr_stmt|;
comment|// Reset possible simple key on the current level.
name|removePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// Scan and add SCALAR.
name|Token
name|tok
init|=
name|scanBlockScalar
argument_list|(
name|style
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchSingle
specifier|private
name|void
name|fetchSingle
parameter_list|()
block|{
name|fetchFlowScalar
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchDouble
specifier|private
name|void
name|fetchDouble
parameter_list|()
block|{
name|fetchFlowScalar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchFlowScalar
specifier|private
name|void
name|fetchFlowScalar
parameter_list|(
name|char
name|style
parameter_list|)
block|{
comment|// A flow scalar could be a simple key.
name|savePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// No simple keys after flow scalars.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Scan and add SCALAR.
name|Token
name|tok
init|=
name|scanFlowScalar
argument_list|(
name|style
argument_list|)
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
DECL|method|fetchPlain
specifier|private
name|void
name|fetchPlain
parameter_list|()
block|{
comment|// A plain scalar could be a simple key.
name|savePossibleSimpleKey
argument_list|()
expr_stmt|;
comment|// No simple keys after plain scalars. But note that `scan_plain` will
comment|// change this flag if the scan is finished at the beginning of the
comment|// line.
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
comment|// Scan and add SCALAR. May change `allow_simple_key`.
name|Token
name|tok
init|=
name|scanPlain
argument_list|()
decl_stmt|;
name|this
operator|.
name|tokens
operator|.
name|add
argument_list|(
name|tok
argument_list|)
expr_stmt|;
block|}
comment|// Checkers.
DECL|method|checkDirective
specifier|private
name|boolean
name|checkDirective
parameter_list|()
block|{
comment|// DIRECTIVE: ^ '%' ...
comment|// The '%' indicator is already checked.
return|return
name|reader
operator|.
name|getColumn
argument_list|()
operator|==
literal|0
return|;
block|}
DECL|method|checkDocumentStart
specifier|private
name|boolean
name|checkDocumentStart
parameter_list|()
block|{
comment|// DOCUMENT-START: ^ '---' (' '|'\n')
if|if
condition|(
name|reader
operator|.
name|getColumn
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
literal|"---"
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
literal|3
argument_list|)
argument_list|)
operator|&&
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|checkDocumentEnd
specifier|private
name|boolean
name|checkDocumentEnd
parameter_list|()
block|{
comment|// DOCUMENT-END: ^ '...' (' '|'\n')
if|if
condition|(
name|reader
operator|.
name|getColumn
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
literal|"..."
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
literal|3
argument_list|)
argument_list|)
operator|&&
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|checkBlockEntry
specifier|private
name|boolean
name|checkBlockEntry
parameter_list|()
block|{
comment|// BLOCK-ENTRY: '-' (' '|'\n')
return|return
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
DECL|method|checkKey
specifier|private
name|boolean
name|checkKey
parameter_list|()
block|{
comment|// KEY(flow context): '?'
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|!=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// KEY(block context): '?' (' '|'\n')
return|return
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|method|checkValue
specifier|private
name|boolean
name|checkValue
parameter_list|()
block|{
comment|// VALUE(flow context): ':'
if|if
condition|(
name|flowLevel
operator|!=
literal|0
condition|)
block|{
return|return
literal|true
return|;
block|}
else|else
block|{
comment|// VALUE(block context): ':' (' '|'\n')
return|return
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
argument_list|)
return|;
block|}
block|}
DECL|method|checkPlain
specifier|private
name|boolean
name|checkPlain
parameter_list|()
block|{
comment|/**          *<pre>          * A plain scalar may start with any non-space character except:          *   '-', '?', ':', ',', '[', ']', '{', '}',          *   '#', '&amp;', '*', '!', '|', '&gt;', '\'', '\&quot;',          *   '%', '@', '`'.          *          * It may also start with          *   '-', '?', ':'          * if it is followed by a non-space character.          *          * Note that we limit the last rule to the block context (except the          * '-' character) because we want the flow context to be space          * independent.          *</pre>          */
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
return|return
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|,
literal|"-?:,[]{}#&*!|>\'\"%@`"
argument_list|)
operator|||
operator|(
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&&
operator|(
name|ch
operator|==
literal|'-'
operator|||
operator|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
operator|&&
literal|"?:"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
comment|// Scanners.
comment|/**      *<pre>      * We ignore spaces, line breaks and comments.      * If we find a line break in the block context, we set the flag      * `allow_simple_key` on.      * The byte order mark is stripped if it's the first character in the      * stream. We do not yet support BOM inside the stream as the      * specification requires. Any such mark will be considered as a part      * of the document.      * TODO: We need to make tab handling rules more sane. A good rule is      *   Tabs cannot precede tokens      *   BLOCK-SEQUENCE-START, BLOCK-MAPPING-START, BLOCK-END,      *   KEY(block), VALUE(block), BLOCK-ENTRY      * So the checking code is      *   if&lt;TAB&gt;:      *       self.allow_simple_keys = False      * We also need to add the check for `allow_simple_keys == True` to      * `unwind_indent` before issuing BLOCK-END.      * Scanners for block, flow, and plain scalars need to be modified.      *</pre>      */
DECL|method|scanToNextToken
specifier|private
name|void
name|scanToNextToken
parameter_list|()
block|{
if|if
condition|(
name|reader
operator|.
name|getIndex
argument_list|()
operator|==
literal|0
operator|&&
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|'\uFEFF'
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
name|boolean
name|found
init|=
literal|false
decl_stmt|;
while|while
condition|(
operator|!
name|found
condition|)
block|{
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|Constant
operator|.
name|NULL_OR_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scanLineBreak
argument_list|()
operator|.
name|length
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
condition|)
block|{
name|this
operator|.
name|allowSimpleKey
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|found
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|scanDirective
specifier|private
name|Token
name|scanDirective
parameter_list|()
block|{
comment|// See the specification for details.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Mark
name|endMark
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|String
name|name
init|=
name|scanDirectiveName
argument_list|(
name|startMark
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|?
argument_list|>
name|value
init|=
literal|null
decl_stmt|;
if|if
condition|(
literal|"YAML"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|value
operator|=
name|scanYamlDirectiveValue
argument_list|(
name|startMark
argument_list|)
expr_stmt|;
name|endMark
operator|=
name|reader
operator|.
name|getMark
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"TAG"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|value
operator|=
name|scanTagDirectiveValue
argument_list|(
name|startMark
argument_list|)
expr_stmt|;
name|endMark
operator|=
name|reader
operator|.
name|getMark
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|endMark
operator|=
name|reader
operator|.
name|getMark
argument_list|()
expr_stmt|;
while|while
condition|(
name|Constant
operator|.
name|NULL_OR_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
name|scanDirectiveIgnoredLine
argument_list|(
name|startMark
argument_list|)
expr_stmt|;
return|return
operator|new
name|DirectiveToken
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|)
return|;
block|}
DECL|method|scanDirectiveName
specifier|private
name|String
name|scanDirectiveName
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|int
name|length
init|=
literal|0
decl_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|ALPHA
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected alphabetic or numeric character, but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|value
init|=
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected alphabetic or numeric character, but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
DECL|method|scanYamlDirectiveValue
specifier|private
name|List
argument_list|<
name|Integer
argument_list|>
name|scanYamlDirectiveValue
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
name|Integer
name|major
init|=
name|scanYamlDirectiveNumber
argument_list|(
name|startMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|!=
literal|'.'
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected a digit or '.', but found "
operator|+
name|reader
operator|.
name|peek
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|reader
operator|.
name|peek
argument_list|()
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Integer
name|minor
init|=
name|scanYamlDirectiveNumber
argument_list|(
name|startMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected a digit or ' ', but found "
operator|+
name|reader
operator|.
name|peek
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|reader
operator|.
name|peek
argument_list|()
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|Integer
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|Integer
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|major
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|minor
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|scanYamlDirectiveNumber
specifier|private
name|Integer
name|scanYamlDirectiveNumber
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Character
operator|.
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected a digit, but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
argument_list|)
condition|)
block|{
name|length
operator|++
expr_stmt|;
block|}
name|Integer
name|value
init|=
operator|new
name|Integer
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
argument_list|)
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|scanTagDirectiveValue
specifier|private
name|List
argument_list|<
name|String
argument_list|>
name|scanTagDirectiveValue
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
name|String
name|handle
init|=
name|scanTagDirectiveHandle
argument_list|(
name|startMark
argument_list|)
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
name|String
name|prefix
init|=
name|scanTagDirectivePrefix
argument_list|(
name|startMark
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|handle
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
DECL|method|scanTagDirectiveHandle
specifier|private
name|String
name|scanTagDirectiveHandle
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|String
name|value
init|=
name|scanTagHandle
argument_list|(
literal|"directive"
argument_list|,
name|startMark
argument_list|)
decl_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|' '
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected ' ', but found "
operator|+
name|reader
operator|.
name|peek
argument_list|()
operator|+
literal|"("
operator|+
name|ch
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
DECL|method|scanTagDirectivePrefix
specifier|private
name|String
name|scanTagDirectivePrefix
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|String
name|value
init|=
name|scanTagUri
argument_list|(
literal|"directive"
argument_list|,
name|startMark
argument_list|)
decl_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected ' ', but found "
operator|+
name|reader
operator|.
name|peek
argument_list|()
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|reader
operator|.
name|peek
argument_list|()
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
DECL|method|scanDirectiveIgnoredLine
specifier|private
name|String
name|scanDirectiveIgnoredLine
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|Constant
operator|.
name|NULL_OR_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_OR_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a directive"
argument_list|,
name|startMark
argument_list|,
literal|"expected a comment or a line break, but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|scanLineBreak
argument_list|()
return|;
block|}
comment|/**      *<pre>      * The specification does not restrict characters for anchors and      * aliases. This may lead to problems, for instance, the document:      *   [ *alias, value ]      * can be interpreted in two ways, as      *   [&quot;value&quot; ]      * and      *   [ *alias ,&quot;value&quot; ]      * Therefore we restrict aliases to numbers and ASCII letters.      *</pre>      */
DECL|method|scanAnchor
specifier|private
name|Token
name|scanAnchor
parameter_list|(
name|boolean
name|isAnchor
parameter_list|)
block|{
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|char
name|indicator
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|indicator
operator|==
literal|'*'
condition|?
literal|"alias"
else|:
literal|"anchor"
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|ALPHA
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning an "
operator|+
name|name
argument_list|,
name|startMark
argument_list|,
literal|"expected alphabetic or numeric character, but found but found "
operator|+
name|ch
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|String
name|value
init|=
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|,
literal|"?:,]}%@`"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning an "
operator|+
name|name
argument_list|,
name|startMark
argument_list|,
literal|"expected alphabetic or numeric character, but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|reader
operator|.
name|peek
argument_list|()
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Token
name|tok
decl_stmt|;
if|if
condition|(
name|isAnchor
condition|)
block|{
name|tok
operator|=
operator|new
name|AnchorToken
argument_list|(
name|value
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tok
operator|=
operator|new
name|AliasToken
argument_list|(
name|value
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|)
expr_stmt|;
block|}
return|return
name|tok
return|;
block|}
DECL|method|scanTag
specifier|private
name|Token
name|scanTag
parameter_list|()
block|{
comment|// See the specification for details.
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|String
name|handle
init|=
literal|null
decl_stmt|;
name|String
name|suffix
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'<'
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|scanTagUri
argument_list|(
literal|"tag"
argument_list|,
name|startMark
argument_list|)
expr_stmt|;
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|!=
literal|'>'
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a tag"
argument_list|,
name|startMark
argument_list|,
literal|"expected '>', but found '"
operator|+
name|reader
operator|.
name|peek
argument_list|()
operator|+
literal|"' ("
operator|+
operator|(
operator|(
name|int
operator|)
name|reader
operator|.
name|peek
argument_list|()
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|suffix
operator|=
literal|"!"
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|length
init|=
literal|1
decl_stmt|;
name|boolean
name|useHandle
init|=
literal|false
decl_stmt|;
while|while
condition|(
name|Constant
operator|.
name|NULL_BL_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'!'
condition|)
block|{
name|useHandle
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|length
operator|++
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
name|handle
operator|=
literal|"!"
expr_stmt|;
if|if
condition|(
name|useHandle
condition|)
block|{
name|handle
operator|=
name|scanTagHandle
argument_list|(
literal|"tag"
argument_list|,
name|startMark
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|handle
operator|=
literal|"!"
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
name|suffix
operator|=
name|scanTagUri
argument_list|(
literal|"tag"
argument_list|,
name|startMark
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a tag"
argument_list|,
name|startMark
argument_list|,
literal|"expected ' ', but found '"
operator|+
name|ch
operator|+
literal|"' ("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|TagTuple
name|value
init|=
operator|new
name|TagTuple
argument_list|(
name|handle
argument_list|,
name|suffix
argument_list|)
decl_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
return|return
operator|new
name|TagToken
argument_list|(
name|value
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|)
return|;
block|}
DECL|method|scanBlockScalar
specifier|private
name|Token
name|scanBlockScalar
parameter_list|(
name|char
name|style
parameter_list|)
block|{
comment|// See the specification for details.
name|boolean
name|folded
decl_stmt|;
if|if
condition|(
name|style
operator|==
literal|'>'
condition|)
block|{
name|folded
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|folded
operator|=
literal|false
expr_stmt|;
block|}
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
comment|// Scan the header.
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Chomping
name|chompi
init|=
name|scanBlockScalarIndicators
argument_list|(
name|startMark
argument_list|)
decl_stmt|;
name|int
name|increment
init|=
name|chompi
operator|.
name|getIncrement
argument_list|()
decl_stmt|;
name|scanBlockScalarIgnoredLine
argument_list|(
name|startMark
argument_list|)
expr_stmt|;
comment|// Determine the indentation level and go to the first non-empty line.
name|int
name|minIndent
init|=
name|this
operator|.
name|indent
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|minIndent
operator|<
literal|1
condition|)
block|{
name|minIndent
operator|=
literal|1
expr_stmt|;
block|}
name|String
name|breaks
init|=
literal|null
decl_stmt|;
name|int
name|maxIndent
init|=
literal|0
decl_stmt|;
name|int
name|indent
init|=
literal|0
decl_stmt|;
name|Mark
name|endMark
decl_stmt|;
if|if
condition|(
name|increment
operator|==
operator|-
literal|1
condition|)
block|{
name|Object
index|[]
name|brme
init|=
name|scanBlockScalarIndentation
argument_list|()
decl_stmt|;
name|breaks
operator|=
operator|(
name|String
operator|)
name|brme
index|[
literal|0
index|]
expr_stmt|;
name|maxIndent
operator|=
operator|(
operator|(
name|Integer
operator|)
name|brme
index|[
literal|1
index|]
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|endMark
operator|=
operator|(
name|Mark
operator|)
name|brme
index|[
literal|2
index|]
expr_stmt|;
name|indent
operator|=
name|Math
operator|.
name|max
argument_list|(
name|minIndent
argument_list|,
name|maxIndent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent
operator|=
name|minIndent
operator|+
name|increment
operator|-
literal|1
expr_stmt|;
name|Object
index|[]
name|brme
init|=
name|scanBlockScalarBreaks
argument_list|(
name|indent
argument_list|)
decl_stmt|;
name|breaks
operator|=
operator|(
name|String
operator|)
name|brme
index|[
literal|0
index|]
expr_stmt|;
name|endMark
operator|=
operator|(
name|Mark
operator|)
name|brme
index|[
literal|1
index|]
expr_stmt|;
block|}
name|String
name|lineBreak
init|=
literal|""
decl_stmt|;
comment|// Scan the inner part of the block scalar.
while|while
condition|(
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
operator|==
name|indent
operator|&&
name|reader
operator|.
name|peek
argument_list|()
operator|!=
literal|'\0'
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|breaks
argument_list|)
expr_stmt|;
name|boolean
name|leadingNonSpace
init|=
literal|" \t"
operator|.
name|indexOf
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|Constant
operator|.
name|NULL_OR_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
argument_list|)
condition|)
block|{
name|length
operator|++
expr_stmt|;
block|}
name|chunks
operator|.
name|append
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|lineBreak
operator|=
name|scanLineBreak
argument_list|()
expr_stmt|;
name|Object
index|[]
name|brme
init|=
name|scanBlockScalarBreaks
argument_list|(
name|indent
argument_list|)
decl_stmt|;
name|breaks
operator|=
operator|(
name|String
operator|)
name|brme
index|[
literal|0
index|]
expr_stmt|;
name|endMark
operator|=
operator|(
name|Mark
operator|)
name|brme
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
operator|==
name|indent
operator|&&
name|reader
operator|.
name|peek
argument_list|()
operator|!=
literal|'\0'
condition|)
block|{
comment|// Unfortunately, folding rules are ambiguous.
comment|//
comment|// This is the folding according to the specification:
if|if
condition|(
name|folded
operator|&&
literal|"\n"
operator|.
name|equals
argument_list|(
name|lineBreak
argument_list|)
operator|&&
name|leadingNonSpace
operator|&&
literal|" \t"
operator|.
name|indexOf
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|breaks
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|chunks
operator|.
name|append
argument_list|(
name|lineBreak
argument_list|)
expr_stmt|;
block|}
comment|// Clark Evans's interpretation (also in the spec examples) not
comment|// imported from PyYAML
block|}
else|else
block|{
break|break;
block|}
block|}
comment|// Chomp the tail.
if|if
condition|(
name|chompi
operator|.
name|chompTailIsNotFalse
argument_list|()
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|lineBreak
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chompi
operator|.
name|chompTailIsTrue
argument_list|()
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|breaks
argument_list|)
expr_stmt|;
block|}
comment|// We are done.
return|return
operator|new
name|ScalarToken
argument_list|(
name|chunks
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|style
argument_list|)
return|;
block|}
DECL|method|scanBlockScalarIndicators
specifier|private
name|Chomping
name|scanBlockScalarIndicators
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|Boolean
name|chomping
init|=
literal|null
decl_stmt|;
name|int
name|increment
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|chomping
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|chomping
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|increment
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a block scalar"
argument_list|,
name|startMark
argument_list|,
literal|"expected indentation indicator in the range 1-9, but found 0"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Character
operator|.
name|isDigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|increment
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|String
operator|.
name|valueOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|increment
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a block scalar"
argument_list|,
name|startMark
argument_list|,
literal|"expected indentation indicator in the range 1-9, but found 0"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
operator|||
name|ch
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|chomping
operator|=
name|Boolean
operator|.
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|chomping
operator|=
name|Boolean
operator|.
name|FALSE
expr_stmt|;
block|}
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a block scalar"
argument_list|,
name|startMark
argument_list|,
literal|"expected chomping or indentation indicators, but found "
operator|+
name|ch
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
return|return
operator|new
name|Chomping
argument_list|(
name|chomping
argument_list|,
name|increment
argument_list|)
return|;
block|}
DECL|method|scanBlockScalarIgnoredLine
specifier|private
name|String
name|scanBlockScalarIgnoredLine
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
name|Constant
operator|.
name|NULL_OR_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_OR_LINEBR
operator|.
name|hasNo
argument_list|(
name|ch
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a block scalar"
argument_list|,
name|startMark
argument_list|,
literal|"expected a comment or a line break, but found "
operator|+
name|ch
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|scanLineBreak
argument_list|()
return|;
block|}
DECL|method|scanBlockScalarIndentation
specifier|private
name|Object
index|[]
name|scanBlockScalarIndentation
parameter_list|()
block|{
comment|// See the specification for details.
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|maxIndent
init|=
literal|0
decl_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
while|while
condition|(
name|Constant
operator|.
name|LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|,
literal|" \r"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|!=
literal|' '
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|scanLineBreak
argument_list|()
argument_list|)
expr_stmt|;
name|endMark
operator|=
name|reader
operator|.
name|getMark
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
operator|>
name|maxIndent
condition|)
block|{
name|maxIndent
operator|=
name|reader
operator|.
name|getColumn
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|Object
index|[]
block|{
name|chunks
operator|.
name|toString
argument_list|()
block|,
name|maxIndent
block|,
name|endMark
block|}
return|;
block|}
DECL|method|scanBlockScalarBreaks
specifier|private
name|Object
index|[]
name|scanBlockScalarBreaks
parameter_list|(
name|int
name|indent
parameter_list|)
block|{
comment|// See the specification for details.
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
while|while
condition|(
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
operator|<
name|indent
operator|&&
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|Constant
operator|.
name|FULL_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|scanLineBreak
argument_list|()
argument_list|)
expr_stmt|;
name|endMark
operator|=
name|reader
operator|.
name|getMark
argument_list|()
expr_stmt|;
while|while
condition|(
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
operator|<
name|indent
operator|&&
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|new
name|Object
index|[]
block|{
name|chunks
operator|.
name|toString
argument_list|()
block|,
name|endMark
block|}
return|;
block|}
comment|/**      *<pre>      * See the specification for details.      * Note that we loose indentation rules for quoted scalars. Quoted      * scalars don't need to adhere indentation because&quot; and ' clearly      * mark the beginning and the end of them. Therefore we are less      * restrictive then the specification requires. We only need to check      * that document separators are not included in scalars.      *</pre>      */
DECL|method|scanFlowScalar
specifier|private
name|Token
name|scanFlowScalar
parameter_list|(
name|char
name|style
parameter_list|)
block|{
name|boolean
name|_double
decl_stmt|;
if|if
condition|(
name|style
operator|==
literal|'"'
condition|)
block|{
name|_double
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|_double
operator|=
literal|false
expr_stmt|;
block|}
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|char
name|quote
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|chunks
operator|.
name|append
argument_list|(
name|scanFlowScalarNonSpaces
argument_list|(
name|_double
argument_list|,
name|startMark
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|!=
name|quote
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|scanFlowScalarSpaces
argument_list|(
name|startMark
argument_list|)
argument_list|)
expr_stmt|;
name|chunks
operator|.
name|append
argument_list|(
name|scanFlowScalarNonSpaces
argument_list|(
name|_double
argument_list|,
name|startMark
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|Mark
name|endMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
return|return
operator|new
name|ScalarToken
argument_list|(
name|chunks
operator|.
name|toString
argument_list|()
argument_list|,
literal|false
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
name|style
argument_list|)
return|;
block|}
DECL|method|scanFlowScalarNonSpaces
specifier|private
name|String
name|scanFlowScalarNonSpaces
parameter_list|(
name|boolean
name|_double
parameter_list|,
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
argument_list|,
literal|"\'\"\\"
argument_list|)
condition|)
block|{
name|length
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|_double
operator|&&
name|ch
operator|==
literal|'\''
operator|&&
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
operator|==
literal|'\''
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|_double
operator|&&
name|ch
operator|==
literal|'\''
operator|)
operator|||
operator|(
operator|!
name|_double
operator|&&
literal|"\"\\"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_double
operator|&&
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|()
expr_stmt|;
if|if
condition|(
name|ESCAPE_REPLACEMENTS
operator|.
name|containsKey
argument_list|(
operator|new
name|Character
argument_list|(
name|ch
argument_list|)
argument_list|)
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|ESCAPE_REPLACEMENTS
operator|.
name|get
argument_list|(
operator|new
name|Character
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ESCAPE_CODES
operator|.
name|containsKey
argument_list|(
operator|new
name|Character
argument_list|(
name|ch
argument_list|)
argument_list|)
condition|)
block|{
name|length
operator|=
operator|(
operator|(
name|Integer
operator|)
name|ESCAPE_CODES
operator|.
name|get
argument_list|(
operator|new
name|Character
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
operator|.
name|intValue
argument_list|()
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
name|String
name|hex
init|=
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|NOT_HEXA
operator|.
name|matcher
argument_list|(
name|hex
argument_list|)
operator|.
name|find
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a double-quoted scalar"
argument_list|,
name|startMark
argument_list|,
literal|"expected escape sequence of "
operator|+
name|length
operator|+
literal|" hexadecimal numbers, but found: "
operator|+
name|hex
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|char
name|unicode
init|=
operator|(
name|char
operator|)
name|Integer
operator|.
name|parseInt
argument_list|(
name|hex
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|chunks
operator|.
name|append
argument_list|(
name|unicode
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Constant
operator|.
name|FULL_LINEBR
operator|.
name|has
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|scanLineBreak
argument_list|()
expr_stmt|;
name|chunks
operator|.
name|append
argument_list|(
name|scanFlowScalarBreaks
argument_list|(
name|startMark
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a double-quoted scalar"
argument_list|,
name|startMark
argument_list|,
literal|"found unknown escape character "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|chunks
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
DECL|method|scanFlowScalarSpaces
specifier|private
name|String
name|scanFlowScalarSpaces
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|" \t"
operator|.
name|indexOf
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|length
operator|++
expr_stmt|;
block|}
name|String
name|whitespaces
init|=
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a quoted scalar"
argument_list|,
name|startMark
argument_list|,
literal|"found unexpected end of stream"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|Constant
operator|.
name|FULL_LINEBR
operator|.
name|has
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|String
name|lineBreak
init|=
name|scanLineBreak
argument_list|()
decl_stmt|;
name|String
name|breaks
init|=
name|scanFlowScalarBreaks
argument_list|(
name|startMark
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
literal|"\n"
operator|.
name|equals
argument_list|(
name|lineBreak
argument_list|)
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|lineBreak
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|breaks
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|chunks
operator|.
name|append
argument_list|(
name|breaks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunks
operator|.
name|append
argument_list|(
name|whitespaces
argument_list|)
expr_stmt|;
block|}
return|return
name|chunks
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|scanFlowScalarBreaks
specifier|private
name|String
name|scanFlowScalarBreaks
parameter_list|(
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// Instead of checking indentation, we check for document
comment|// separators.
name|String
name|prefix
init|=
name|reader
operator|.
name|prefix
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
literal|"---"
operator|.
name|equals
argument_list|(
name|prefix
argument_list|)
operator|||
literal|"..."
operator|.
name|equals
argument_list|(
name|prefix
argument_list|)
operator|)
operator|&&
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a quoted scalar"
argument_list|,
name|startMark
argument_list|,
literal|"found unexpected document separator"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
while|while
condition|(
literal|" \t"
operator|.
name|indexOf
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Constant
operator|.
name|FULL_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|)
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|scanLineBreak
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|chunks
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
comment|/**      *<pre>      * See the specification for details.      * We add an additional restriction for the flow context:      *   plain scalars in the flow context cannot contain ',', ':' and '?'.      * We also keep track of the `allow_simple_key` flag here.      * Indentation rules are loosed for the flow context.      *</pre>      */
DECL|method|scanPlain
specifier|private
name|Token
name|scanPlain
parameter_list|()
block|{
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|Mark
name|startMark
init|=
name|reader
operator|.
name|getMark
argument_list|()
decl_stmt|;
name|Mark
name|endMark
init|=
name|startMark
decl_stmt|;
name|int
name|indent
init|=
name|this
operator|.
name|indent
operator|+
literal|1
decl_stmt|;
name|String
name|spaces
init|=
literal|""
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|char
name|ch
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|'#'
condition|)
block|{
break|break;
block|}
while|while
condition|(
literal|true
condition|)
block|{
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
operator|&&
name|ch
operator|==
literal|':'
operator|&&
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|this
operator|.
name|flowLevel
operator|!=
literal|0
operator|&&
literal|",:?[]{}"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
break|break;
block|}
name|length
operator|++
expr_stmt|;
block|}
comment|// It's not clear what we should do with ':' in the flow context.
if|if
condition|(
name|this
operator|.
name|flowLevel
operator|!=
literal|0
operator|&&
name|ch
operator|==
literal|':'
operator|&&
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|hasNo
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
name|length
operator|+
literal|1
argument_list|)
argument_list|,
literal|",[]{}"
argument_list|)
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a plain scalar"
argument_list|,
name|startMark
argument_list|,
literal|"found unexpected ':'"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|,
literal|"Please check http://pyyaml.org/wiki/YAMLColonInFlowContext for details."
argument_list|)
throw|;
block|}
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|this
operator|.
name|allowSimpleKey
operator|=
literal|false
expr_stmt|;
name|chunks
operator|.
name|append
argument_list|(
name|spaces
argument_list|)
expr_stmt|;
name|chunks
operator|.
name|append
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|endMark
operator|=
name|reader
operator|.
name|getMark
argument_list|()
expr_stmt|;
name|spaces
operator|=
name|scanPlainSpaces
argument_list|()
expr_stmt|;
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|spaces
argument_list|)
operator|||
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|'#'
operator|||
operator|(
name|this
operator|.
name|flowLevel
operator|==
literal|0
operator|&&
name|this
operator|.
name|reader
operator|.
name|getColumn
argument_list|()
operator|<
name|indent
operator|)
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|new
name|ScalarToken
argument_list|(
name|chunks
operator|.
name|toString
argument_list|()
argument_list|,
name|startMark
argument_list|,
name|endMark
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      *<pre>      * See the specification for details.      * The specification is really confusing about tabs in plain scalars.      * We just forbid them completely. Do not use tabs in YAML!      *</pre>      */
DECL|method|scanPlainSpaces
specifier|private
name|String
name|scanPlainSpaces
parameter_list|()
block|{
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
operator|==
literal|' '
condition|)
block|{
name|length
operator|++
expr_stmt|;
block|}
name|String
name|whitespaces
init|=
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|Constant
operator|.
name|FULL_LINEBR
operator|.
name|has
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|String
name|lineBreak
init|=
name|scanLineBreak
argument_list|()
decl_stmt|;
name|this
operator|.
name|allowSimpleKey
operator|=
literal|true
expr_stmt|;
name|String
name|prefix
init|=
name|reader
operator|.
name|prefix
argument_list|(
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"---"
operator|.
name|equals
argument_list|(
name|prefix
argument_list|)
operator|||
literal|"..."
operator|.
name|equals
argument_list|(
name|prefix
argument_list|)
operator|&&
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|""
return|;
block|}
name|StringBuilder
name|breaks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|Constant
operator|.
name|LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|()
argument_list|,
literal|" \r"
argument_list|)
condition|)
block|{
if|if
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|' '
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|breaks
operator|.
name|append
argument_list|(
name|scanLineBreak
argument_list|()
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|reader
operator|.
name|prefix
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"---"
operator|.
name|equals
argument_list|(
name|prefix
argument_list|)
operator|||
literal|"..."
operator|.
name|equals
argument_list|(
name|prefix
argument_list|)
operator|&&
name|Constant
operator|.
name|NULL_BL_T_LINEBR
operator|.
name|has
argument_list|(
name|reader
operator|.
name|peek
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
return|return
literal|""
return|;
block|}
block|}
block|}
if|if
condition|(
operator|!
literal|"\n"
operator|.
name|equals
argument_list|(
name|lineBreak
argument_list|)
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|lineBreak
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|breaks
operator|==
literal|null
operator|||
name|breaks
operator|.
name|toString
argument_list|()
operator|.
name|equals
argument_list|(
literal|""
argument_list|)
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
name|chunks
operator|.
name|append
argument_list|(
name|breaks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunks
operator|.
name|append
argument_list|(
name|whitespaces
argument_list|)
expr_stmt|;
block|}
return|return
name|chunks
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      *<pre>      * See the specification for details.      * For some strange reasons, the specification does not allow '_' in      * tag handles. I have allowed it anyway.      *</pre>      */
DECL|method|scanTagHandle
specifier|private
name|String
name|scanTagHandle
parameter_list|(
name|String
name|name
parameter_list|,
name|Mark
name|startMark
parameter_list|)
block|{
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'!'
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a "
operator|+
name|name
argument_list|,
name|startMark
argument_list|,
literal|"expected '!', but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|int
name|length
init|=
literal|1
decl_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|' '
condition|)
block|{
while|while
condition|(
name|ALPHA
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|length
operator|++
expr_stmt|;
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'!'
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a "
operator|+
name|name
argument_list|,
name|startMark
argument_list|,
literal|"expected '!', but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|length
operator|++
expr_stmt|;
block|}
name|String
name|value
init|=
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
DECL|method|scanTagUri
specifier|private
name|String
name|scanTagUri
parameter_list|(
name|String
name|name
parameter_list|,
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
comment|// Note: we do not check if URI is well-formed.
name|StringBuilder
name|chunks
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|ALPHA
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
operator|||
literal|"-;/?:@&=+$,_.!~*\'()[]%"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'%'
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
name|chunks
operator|.
name|append
argument_list|(
name|scanUriEscapes
argument_list|(
name|name
argument_list|,
name|startMark
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|++
expr_stmt|;
block|}
name|ch
operator|=
name|reader
operator|.
name|peek
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|chunks
operator|.
name|append
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|reader
operator|.
name|forward
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|chunks
operator|.
name|length
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a "
operator|+
name|name
argument_list|,
name|startMark
argument_list|,
literal|"expected URI, but found "
operator|+
name|ch
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|ch
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
return|return
name|chunks
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|scanUriEscapes
specifier|private
name|String
name|scanUriEscapes
parameter_list|(
name|String
name|name
parameter_list|,
name|Mark
name|startMark
parameter_list|)
block|{
comment|// See the specification for details.
name|StringBuilder
name|bytes
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
while|while
condition|(
name|reader
operator|.
name|peek
argument_list|()
operator|==
literal|'%'
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
try|try
block|{
name|bytes
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|parseInt
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|nfe
parameter_list|)
block|{
throw|throw
operator|new
name|ScannerException
argument_list|(
literal|"while scanning a "
operator|+
name|name
argument_list|,
name|startMark
argument_list|,
literal|"expected URI escape sequence of 2 hexadecimal numbers, but found "
operator|+
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|reader
operator|.
name|peek
argument_list|(
literal|1
argument_list|)
operator|)
operator|+
literal|") and "
operator|+
name|reader
operator|.
name|peek
argument_list|(
literal|2
argument_list|)
operator|+
literal|"("
operator|+
operator|(
operator|(
name|int
operator|)
name|reader
operator|.
name|peek
argument_list|(
literal|2
argument_list|)
operator|)
operator|+
literal|")"
argument_list|,
name|reader
operator|.
name|getMark
argument_list|()
argument_list|)
throw|;
block|}
name|reader
operator|.
name|forward
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|scanLineBreak
specifier|private
name|String
name|scanLineBreak
parameter_list|()
block|{
comment|// Transforms:
comment|// '\r\n' : '\n'
comment|// '\r' : '\n'
comment|// '\n' : '\n'
comment|// '\x85' : '\n'
comment|// default : ''
name|char
name|ch
init|=
name|reader
operator|.
name|peek
argument_list|()
decl_stmt|;
if|if
condition|(
literal|"\r\n\u0085"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
literal|"\r\n"
operator|.
name|equals
argument_list|(
name|reader
operator|.
name|prefix
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
block|}
return|return
literal|"\n"
return|;
block|}
elseif|else
if|if
condition|(
literal|"\u2028\u2029"
operator|.
name|indexOf
argument_list|(
name|ch
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|reader
operator|.
name|forward
argument_list|()
expr_stmt|;
return|return
name|String
operator|.
name|valueOf
argument_list|(
name|ch
argument_list|)
return|;
block|}
return|return
literal|""
return|;
block|}
comment|/**      * Chomping the tail may have 3 values - yes, no, not defined.      */
DECL|class|Chomping
specifier|private
class|class
name|Chomping
block|{
DECL|field|value
specifier|private
specifier|final
name|Boolean
name|value
decl_stmt|;
DECL|field|increment
specifier|private
specifier|final
name|int
name|increment
decl_stmt|;
DECL|method|Chomping
specifier|public
name|Chomping
parameter_list|(
name|Boolean
name|value
parameter_list|,
name|int
name|increment
parameter_list|)
block|{
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|this
operator|.
name|increment
operator|=
name|increment
expr_stmt|;
block|}
DECL|method|chompTailIsNotFalse
specifier|public
name|boolean
name|chompTailIsNotFalse
parameter_list|()
block|{
return|return
name|value
operator|==
literal|null
operator|||
name|value
return|;
block|}
DECL|method|chompTailIsTrue
specifier|public
name|boolean
name|chompTailIsTrue
parameter_list|()
block|{
return|return
name|value
operator|!=
literal|null
operator|&&
name|value
return|;
block|}
DECL|method|getIncrement
specifier|public
name|int
name|getIncrement
parameter_list|()
block|{
return|return
name|increment
return|;
block|}
block|}
block|}
end_class

end_unit

