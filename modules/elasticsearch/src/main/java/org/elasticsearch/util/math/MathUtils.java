begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.util.math
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|util
operator|.
name|math
package|;
end_package

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigDecimal
import|;
end_import

begin_import
import|import
name|java
operator|.
name|math
operator|.
name|BigInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_comment
comment|/**  * Some useful additions to the built-in functions in {@link Math}.  *  * @version $Revision: 927249 $ $Date: 2010-03-24 21:06:51 -0400 (Wed, 24 Mar 2010) $  */
end_comment

begin_class
DECL|class|MathUtils
specifier|public
specifier|final
class|class
name|MathUtils
block|{
comment|/**      * Smallest positive number such that 1 - EPSILON is not numerically equal to 1.      */
DECL|field|EPSILON
specifier|public
specifier|static
specifier|final
name|double
name|EPSILON
init|=
literal|0x1
literal|.0p
operator|-
literal|53
decl_stmt|;
comment|/**      * Safe minimum, such that 1 / SAFE_MIN does not overflow.      *<p>In IEEE 754 arithmetic, this is also the smallest normalized      * number 2<sup>-1022</sup>.</p>      */
DECL|field|SAFE_MIN
specifier|public
specifier|static
specifier|final
name|double
name|SAFE_MIN
init|=
literal|0x1
literal|.0p
operator|-
literal|1022
decl_stmt|;
comment|/**      * 2&pi;.      *      * @since 2.1      */
DECL|field|TWO_PI
specifier|public
specifier|static
specifier|final
name|double
name|TWO_PI
init|=
literal|2
operator|*
name|Math
operator|.
name|PI
decl_stmt|;
comment|/**      * -1.0 cast as a byte.      */
DECL|field|NB
specifier|private
specifier|static
specifier|final
name|byte
name|NB
init|=
operator|(
name|byte
operator|)
operator|-
literal|1
decl_stmt|;
comment|/**      * -1.0 cast as a short.      */
DECL|field|NS
specifier|private
specifier|static
specifier|final
name|short
name|NS
init|=
operator|(
name|short
operator|)
operator|-
literal|1
decl_stmt|;
comment|/**      * 1.0 cast as a byte.      */
DECL|field|PB
specifier|private
specifier|static
specifier|final
name|byte
name|PB
init|=
operator|(
name|byte
operator|)
literal|1
decl_stmt|;
comment|/**      * 1.0 cast as a short.      */
DECL|field|PS
specifier|private
specifier|static
specifier|final
name|short
name|PS
init|=
operator|(
name|short
operator|)
literal|1
decl_stmt|;
comment|/**      * 0.0 cast as a byte.      */
DECL|field|ZB
specifier|private
specifier|static
specifier|final
name|byte
name|ZB
init|=
operator|(
name|byte
operator|)
literal|0
decl_stmt|;
comment|/**      * 0.0 cast as a short.      */
DECL|field|ZS
specifier|private
specifier|static
specifier|final
name|short
name|ZS
init|=
operator|(
name|short
operator|)
literal|0
decl_stmt|;
comment|/**      * Gap between NaN and regular numbers.      */
DECL|field|NAN_GAP
specifier|private
specifier|static
specifier|final
name|int
name|NAN_GAP
init|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/**      * Offset to order signed double numbers lexicographically.      */
DECL|field|SGN_MASK
specifier|private
specifier|static
specifier|final
name|long
name|SGN_MASK
init|=
literal|0x8000000000000000L
decl_stmt|;
comment|/**      * All long-representable factorials      */
DECL|field|FACTORIALS
specifier|private
specifier|static
specifier|final
name|long
index|[]
name|FACTORIALS
init|=
operator|new
name|long
index|[]
block|{
literal|1l
block|,
literal|1l
block|,
literal|2l
block|,
literal|6l
block|,
literal|24l
block|,
literal|120l
block|,
literal|720l
block|,
literal|5040l
block|,
literal|40320l
block|,
literal|362880l
block|,
literal|3628800l
block|,
literal|39916800l
block|,
literal|479001600l
block|,
literal|6227020800l
block|,
literal|87178291200l
block|,
literal|1307674368000l
block|,
literal|20922789888000l
block|,
literal|355687428096000l
block|,
literal|6402373705728000l
block|,
literal|121645100408832000l
block|,
literal|2432902008176640000l
block|}
decl_stmt|;
comment|/**      * Private Constructor      */
DECL|method|MathUtils
specifier|private
name|MathUtils
parameter_list|()
block|{
name|super
argument_list|()
expr_stmt|;
block|}
comment|/**      * Add two integers, checking for overflow.      *      * @param x an addend      * @param y an addend      * @return the sum<code>x+y</code>      * @throws ArithmeticException if the result can not be represented as an      *                             int      * @since 1.1      */
DECL|method|addAndCheck
specifier|public
specifier|static
name|int
name|addAndCheck
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|long
name|s
init|=
operator|(
name|long
operator|)
name|x
operator|+
operator|(
name|long
operator|)
name|y
decl_stmt|;
if|if
condition|(
name|s
argument_list|<
name|Integer
operator|.
name|MIN_VALUE
operator|||
name|s
argument_list|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"overflow: add"
argument_list|)
throw|;
block|}
return|return
operator|(
name|int
operator|)
name|s
return|;
block|}
comment|/**      * Add two long integers, checking for overflow.      *      * @param a an addend      * @param b an addend      * @return the sum<code>a+b</code>      * @throws ArithmeticException if the result can not be represented as an      *                             long      * @since 1.2      */
DECL|method|addAndCheck
specifier|public
specifier|static
name|long
name|addAndCheck
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|addAndCheck
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
literal|"overflow: add"
argument_list|)
return|;
block|}
comment|/**      * Add two long integers, checking for overflow.      *      * @param a   an addend      * @param b   an addend      * @param msg the message to use for any thrown exception.      * @return the sum<code>a+b</code>      * @throws ArithmeticException if the result can not be represented as an      *                             long      * @since 1.2      */
DECL|method|addAndCheck
specifier|private
specifier|static
name|long
name|addAndCheck
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|,
name|String
name|msg
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
comment|// use symmetry to reduce boundary cases
name|ret
operator|=
name|addAndCheck
argument_list|(
name|b
argument_list|,
name|a
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// assert a<= b
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
comment|// check for negative overflow
if|if
condition|(
name|Long
operator|.
name|MIN_VALUE
operator|-
name|b
operator|<=
name|a
condition|)
block|{
name|ret
operator|=
name|a
operator|+
name|b
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// opposite sign addition is always safe
name|ret
operator|=
name|a
operator|+
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// assert a>= 0
comment|// assert b>= 0
comment|// check for positive overflow
if|if
condition|(
name|a
operator|<=
name|Long
operator|.
name|MAX_VALUE
operator|-
name|b
condition|)
block|{
name|ret
operator|=
name|a
operator|+
name|b
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Returns an exact representation of the<a      * href="http://mathworld.wolfram.com/BinomialCoefficient.html"> Binomial      * Coefficient</a>, "<code>n choose k</code>", the number of      *<code>k</code>-element subsets that can be selected from an      *<code>n</code>-element set.      *<p>      *<Strong>Preconditions</strong>:      *<ul>      *<li><code>0<= k<= n</code> (otherwise      *<code>IllegalArgumentException</code> is thrown)</li>      *<li> The result is small enough to fit into a<code>long</code>. The      * largest value of<code>n</code> for which all coefficients are      *<code>< Long.MAX_VALUE</code> is 66. If the computed value exceeds      *<code>Long.MAX_VALUE</code> an<code>ArithMeticException</code> is      * thrown.</li>      *</ul></p>      *      * @param n the size of the set      * @param k the size of the subsets to be counted      * @return<code>n choose k</code>      * @throws IllegalArgumentException if preconditions are not met.      * @throws ArithmeticException      if the result is too large to be represented      *                                  by a long integer.      */
DECL|method|binomialCoefficient
specifier|public
specifier|static
name|long
name|binomialCoefficient
parameter_list|(
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|k
parameter_list|)
block|{
name|checkBinomial
argument_list|(
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
name|k
operator|)
operator|||
operator|(
name|k
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|k
operator|==
literal|1
operator|)
operator|||
operator|(
name|k
operator|==
name|n
operator|-
literal|1
operator|)
condition|)
block|{
return|return
name|n
return|;
block|}
comment|// Use symmetry for large k
if|if
condition|(
name|k
operator|>
name|n
operator|/
literal|2
condition|)
return|return
name|binomialCoefficient
argument_list|(
name|n
argument_list|,
name|n
operator|-
name|k
argument_list|)
return|;
comment|// We use the formula
comment|// (n choose k) = n! / (n-k)! / k!
comment|// (n choose k) == ((n-k+1)*...*n) / (1*...*k)
comment|// which could be written
comment|// (n choose k) == (n-1 choose k-1) * n / k
name|long
name|result
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|61
condition|)
block|{
comment|// For n<= 61, the naive implementation cannot overflow.
name|int
name|i
init|=
name|n
operator|-
name|k
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
block|{
name|result
operator|=
name|result
operator|*
name|i
operator|/
name|j
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|n
operator|<=
literal|66
condition|)
block|{
comment|// For n> 61 but n<= 66, the result cannot overflow,
comment|// but we must take care not to overflow intermediate values.
name|int
name|i
init|=
name|n
operator|-
name|k
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
block|{
comment|// We know that (result * i) is divisible by j,
comment|// but (result * i) may overflow, so we split j:
comment|// Filter out the gcd, d, so j/d and i/d are integer.
comment|// result is divisible by (j/d) because (j/d)
comment|// is relative prime to (i/d) and is a divisor of
comment|// result * (i/d).
specifier|final
name|long
name|d
init|=
name|gcd
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|result
operator|=
operator|(
name|result
operator|/
operator|(
name|j
operator|/
name|d
operator|)
operator|)
operator|*
operator|(
name|i
operator|/
name|d
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// For n> 66, a result overflow might occur, so we check
comment|// the multiplication, taking care to not overflow
comment|// unnecessary.
name|int
name|i
init|=
name|n
operator|-
name|k
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<=
name|k
condition|;
name|j
operator|++
control|)
block|{
specifier|final
name|long
name|d
init|=
name|gcd
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|result
operator|=
name|mulAndCheck
argument_list|(
name|result
operator|/
operator|(
name|j
operator|/
name|d
operator|)
argument_list|,
name|i
operator|/
name|d
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|/**      * Returns a<code>double</code> representation of the<a      * href="http://mathworld.wolfram.com/BinomialCoefficient.html"> Binomial      * Coefficient</a>, "<code>n choose k</code>", the number of      *<code>k</code>-element subsets that can be selected from an      *<code>n</code>-element set.      *<p>      *<Strong>Preconditions</strong>:      *<ul>      *<li><code>0<= k<= n</code> (otherwise      *<code>IllegalArgumentException</code> is thrown)</li>      *<li> The result is small enough to fit into a<code>double</code>. The      * largest value of<code>n</code> for which all coefficients are<      * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,      * Double.POSITIVE_INFINITY is returned</li>      *</ul></p>      *      * @param n the size of the set      * @param k the size of the subsets to be counted      * @return<code>n choose k</code>      * @throws IllegalArgumentException if preconditions are not met.      */
DECL|method|binomialCoefficientDouble
specifier|public
specifier|static
name|double
name|binomialCoefficientDouble
parameter_list|(
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|k
parameter_list|)
block|{
name|checkBinomial
argument_list|(
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
name|k
operator|)
operator|||
operator|(
name|k
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|1d
return|;
block|}
if|if
condition|(
operator|(
name|k
operator|==
literal|1
operator|)
operator|||
operator|(
name|k
operator|==
name|n
operator|-
literal|1
operator|)
condition|)
block|{
return|return
name|n
return|;
block|}
if|if
condition|(
name|k
operator|>
name|n
operator|/
literal|2
condition|)
block|{
return|return
name|binomialCoefficientDouble
argument_list|(
name|n
argument_list|,
name|n
operator|-
name|k
argument_list|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|67
condition|)
block|{
return|return
name|binomialCoefficient
argument_list|(
name|n
argument_list|,
name|k
argument_list|)
return|;
block|}
name|double
name|result
init|=
literal|1d
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|*=
call|(
name|double
call|)
argument_list|(
name|n
operator|-
name|k
operator|+
name|i
argument_list|)
operator|/
operator|(
name|double
operator|)
name|i
expr_stmt|;
block|}
return|return
name|Math
operator|.
name|floor
argument_list|(
name|result
operator|+
literal|0.5
argument_list|)
return|;
block|}
comment|/**      * Returns the natural<code>log</code> of the<a      * href="http://mathworld.wolfram.com/BinomialCoefficient.html"> Binomial      * Coefficient</a>, "<code>n choose k</code>", the number of      *<code>k</code>-element subsets that can be selected from an      *<code>n</code>-element set.      *<p>      *<Strong>Preconditions</strong>:      *<ul>      *<li><code>0<= k<= n</code> (otherwise      *<code>IllegalArgumentException</code> is thrown)</li>      *</ul></p>      *      * @param n the size of the set      * @param k the size of the subsets to be counted      * @return<code>n choose k</code>      * @throws IllegalArgumentException if preconditions are not met.      */
DECL|method|binomialCoefficientLog
specifier|public
specifier|static
name|double
name|binomialCoefficientLog
parameter_list|(
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|k
parameter_list|)
block|{
name|checkBinomial
argument_list|(
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
name|k
operator|)
operator|||
operator|(
name|k
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|k
operator|==
literal|1
operator|)
operator|||
operator|(
name|k
operator|==
name|n
operator|-
literal|1
operator|)
condition|)
block|{
return|return
name|Math
operator|.
name|log
argument_list|(
name|n
argument_list|)
return|;
block|}
comment|/*          * For values small enough to do exact integer computation,          * return the log of the exact value          */
if|if
condition|(
name|n
operator|<
literal|67
condition|)
block|{
return|return
name|Math
operator|.
name|log
argument_list|(
name|binomialCoefficient
argument_list|(
name|n
argument_list|,
name|k
argument_list|)
argument_list|)
return|;
block|}
comment|/*          * Return the log of binomialCoefficientDouble for values that will not          * overflow binomialCoefficientDouble          */
if|if
condition|(
name|n
operator|<
literal|1030
condition|)
block|{
return|return
name|Math
operator|.
name|log
argument_list|(
name|binomialCoefficientDouble
argument_list|(
name|n
argument_list|,
name|k
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|k
operator|>
name|n
operator|/
literal|2
condition|)
block|{
return|return
name|binomialCoefficientLog
argument_list|(
name|n
argument_list|,
name|n
operator|-
name|k
argument_list|)
return|;
block|}
comment|/*          * Sum logs for values that could overflow          */
name|double
name|logSum
init|=
literal|0
decl_stmt|;
comment|// n!/(n-k)!
for|for
control|(
name|int
name|i
init|=
name|n
operator|-
name|k
operator|+
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|logSum
operator|+=
name|Math
operator|.
name|log
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|// divide by k!
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|k
condition|;
name|i
operator|++
control|)
block|{
name|logSum
operator|-=
name|Math
operator|.
name|log
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|logSum
return|;
block|}
comment|/**      * Check binomial preconditions.      *      * @param n the size of the set      * @param k the size of the subsets to be counted      * @throws IllegalArgumentException if preconditions are not met.      */
DECL|method|checkBinomial
specifier|private
specifier|static
name|void
name|checkBinomial
parameter_list|(
specifier|final
name|int
name|n
parameter_list|,
specifier|final
name|int
name|k
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|n
operator|<
name|k
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"must have n>= k for binomial coefficient (n,k), got n = {0}, k = {1}"
argument_list|,
name|n
argument_list|,
name|k
argument_list|)
throw|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"must have n>= 0 for binomial coefficient (n,k), got n = {0}"
argument_list|,
name|n
argument_list|)
throw|;
block|}
block|}
comment|/**      * Compares two numbers given some amount of allowed error.      *      * @param x   the first number      * @param y   the second number      * @param eps the amount of error to allow when checking for equality      * @return<ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>      *<li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)}&amp;&amp; x&lt; y</li>      *<li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)}&amp;&amp; x> y</li></ul>      */
DECL|method|compareTo
specifier|public
specifier|static
name|int
name|compareTo
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|eps
parameter_list|)
block|{
if|if
condition|(
name|equals
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|eps
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<
name|y
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/HyperbolicCosine.html">      * hyperbolic cosine</a> of x.      *      * @param x double value for which to find the hyperbolic cosine      * @return hyperbolic cosine of x      */
DECL|method|cosh
specifier|public
specifier|static
name|double
name|cosh
parameter_list|(
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|Math
operator|.
name|exp
argument_list|(
name|x
argument_list|)
operator|+
name|Math
operator|.
name|exp
argument_list|(
operator|-
name|x
argument_list|)
operator|)
operator|/
literal|2.0
return|;
block|}
comment|/**      * Returns true iff both arguments are NaN or neither is NaN and they are      * equal      *      * @param x first value      * @param y second value      * @return true if the values are equal or both are NaN      */
DECL|method|equals
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
return|return
operator|(
name|Double
operator|.
name|isNaN
argument_list|(
name|x
argument_list|)
operator|&&
name|Double
operator|.
name|isNaN
argument_list|(
name|y
argument_list|)
operator|)
operator|||
name|x
operator|==
name|y
return|;
block|}
comment|/**      * Returns true iff both arguments are equal or within the range of allowed      * error (inclusive).      *<p>      * Two NaNs are considered equals, as are two infinities with same sign.      *</p>      *      * @param x   first value      * @param y   second value      * @param eps the amount of absolute error to allow      * @return true if the values are equal or within range of each other      */
DECL|method|equals
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
name|eps
parameter_list|)
block|{
return|return
name|equals
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|||
operator|(
name|Math
operator|.
name|abs
argument_list|(
name|y
operator|-
name|x
argument_list|)
operator|<=
name|eps
operator|)
return|;
block|}
comment|/**      * Returns true iff both arguments are equal or within the range of allowed      * error (inclusive).      * Adapted from<a      * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">      * Bruce Dawson</a>      *      * @param x       first value      * @param y       second value      * @param maxUlps {@code (maxUlps - 1)} is the number of floating point      *                values between {@code x} and {@code y}.      * @return {@code true} if there are less than {@code maxUlps} floating      *         point values between {@code x} and {@code y}      */
DECL|method|equals
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|int
name|maxUlps
parameter_list|)
block|{
comment|// Check that "maxUlps" is non-negative and small enough so that the
comment|// default NAN won't compare as equal to anything.
assert|assert
name|maxUlps
operator|>
literal|0
operator|&&
name|maxUlps
operator|<
name|NAN_GAP
assert|;
name|long
name|xInt
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|long
name|yInt
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|y
argument_list|)
decl_stmt|;
comment|// Make lexicographically ordered as a two's-complement integer.
if|if
condition|(
name|xInt
operator|<
literal|0
condition|)
block|{
name|xInt
operator|=
name|SGN_MASK
operator|-
name|xInt
expr_stmt|;
block|}
if|if
condition|(
name|yInt
operator|<
literal|0
condition|)
block|{
name|yInt
operator|=
name|SGN_MASK
operator|-
name|yInt
expr_stmt|;
block|}
return|return
name|Math
operator|.
name|abs
argument_list|(
name|xInt
operator|-
name|yInt
argument_list|)
operator|<=
name|maxUlps
return|;
block|}
comment|/**      * Returns true iff both arguments are null or have same dimensions      * and all their elements are {@link #equals(double,double) equals}      *      * @param x first array      * @param y second array      * @return true if the values are both null or have same dimension      *         and equal elements      * @since 1.2      */
DECL|method|equals
specifier|public
specifier|static
name|boolean
name|equals
parameter_list|(
name|double
index|[]
name|x
parameter_list|,
name|double
index|[]
name|y
parameter_list|)
block|{
if|if
condition|(
operator|(
name|x
operator|==
literal|null
operator|)
operator|||
operator|(
name|y
operator|==
literal|null
operator|)
condition|)
block|{
return|return
operator|!
operator|(
operator|(
name|x
operator|==
literal|null
operator|)
operator|^
operator|(
name|y
operator|==
literal|null
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|.
name|length
operator|!=
name|y
operator|.
name|length
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|x
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|equals
argument_list|(
name|x
index|[
name|i
index|]
argument_list|,
name|y
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns n!. Shorthand for<code>n</code><a      * href="http://mathworld.wolfram.com/Factorial.html"> Factorial</a>, the      * product of the numbers<code>1,...,n</code>.      *<p>      *<Strong>Preconditions</strong>:      *<ul>      *<li><code>n>= 0</code> (otherwise      *<code>IllegalArgumentException</code> is thrown)</li>      *<li> The result is small enough to fit into a<code>long</code>. The      * largest value of<code>n</code> for which<code>n!</code><      * Long.MAX_VALUE</code> is 20. If the computed value exceeds<code>Long.MAX_VALUE</code>      * an<code>ArithMeticException</code> is thrown.</li>      *</ul>      *</p>      *      * @param n argument      * @return<code>n!</code>      * @throws ArithmeticException      if the result is too large to be represented      *                                  by a long integer.      * @throws IllegalArgumentException if n< 0      */
DECL|method|factorial
specifier|public
specifier|static
name|long
name|factorial
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"must have n>= 0 for n!, got n = {0}"
argument_list|,
name|n
argument_list|)
throw|;
block|}
if|if
condition|(
name|n
operator|>
literal|20
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"factorial value is too large to fit in a long"
argument_list|)
throw|;
block|}
return|return
name|FACTORIALS
index|[
name|n
index|]
return|;
block|}
comment|/**      * Returns n!. Shorthand for<code>n</code><a      * href="http://mathworld.wolfram.com/Factorial.html"> Factorial</a>, the      * product of the numbers<code>1,...,n</code> as a<code>double</code>.      *<p>      *<Strong>Preconditions</strong>:      *<ul>      *<li><code>n>= 0</code> (otherwise      *<code>IllegalArgumentException</code> is thrown)</li>      *<li> The result is small enough to fit into a<code>double</code>. The      * largest value of<code>n</code> for which<code>n!</code><      * Double.MAX_VALUE</code> is 170. If the computed value exceeds      * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>      *</ul>      *</p>      *      * @param n argument      * @return<code>n!</code>      * @throws IllegalArgumentException if n< 0      */
DECL|method|factorialDouble
specifier|public
specifier|static
name|double
name|factorialDouble
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"must have n>= 0 for n!, got n = {0}"
argument_list|,
name|n
argument_list|)
throw|;
block|}
if|if
condition|(
name|n
operator|<
literal|21
condition|)
block|{
return|return
name|factorial
argument_list|(
name|n
argument_list|)
return|;
block|}
return|return
name|Math
operator|.
name|floor
argument_list|(
name|Math
operator|.
name|exp
argument_list|(
name|factorialLog
argument_list|(
name|n
argument_list|)
argument_list|)
operator|+
literal|0.5
argument_list|)
return|;
block|}
comment|/**      * Returns the natural logarithm of n!.      *<p>      *<Strong>Preconditions</strong>:      *<ul>      *<li><code>n>= 0</code> (otherwise      *<code>IllegalArgumentException</code> is thrown)</li>      *</ul></p>      *      * @param n argument      * @return<code>n!</code>      * @throws IllegalArgumentException if preconditions are not met.      */
DECL|method|factorialLog
specifier|public
specifier|static
name|double
name|factorialLog
parameter_list|(
specifier|final
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"must have n>= 0 for n!, got n = {0}"
argument_list|,
name|n
argument_list|)
throw|;
block|}
if|if
condition|(
name|n
operator|<
literal|21
condition|)
block|{
return|return
name|Math
operator|.
name|log
argument_list|(
name|factorial
argument_list|(
name|n
argument_list|)
argument_list|)
return|;
block|}
name|double
name|logSum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|2
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|logSum
operator|+=
name|Math
operator|.
name|log
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|logSum
return|;
block|}
comment|/**      *<p>      * Gets the greatest common divisor of the absolute value of two numbers,      * using the "binary gcd" method which avoids division and modulo      * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef      * Stein (1961).      *</p>      * Special cases:      *<ul>      *<li>The invocations      *<code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,      *<code>gcd(Integer.MIN_VALUE, 0)</code> and      *<code>gcd(0, Integer.MIN_VALUE)</code> throw an      *<code>ArithmeticException</code>, because the result would be 2^31, which      * is too large for an int value.</li>      *<li>The result of<code>gcd(x, x)</code>,<code>gcd(0, x)</code> and      *<code>gcd(x, 0)</code> is the absolute value of<code>x</code>, except      * for the special cases above.      *<li>The invocation<code>gcd(0, 0)</code> is the only one which returns      *<code>0</code>.</li>      *</ul>      *      * @param p any number      * @param q any number      * @return the greatest common divisor, never negative      * @throws ArithmeticException if the result cannot be represented as a      *                             nonnegative int value      * @since 1.1      */
DECL|method|gcd
specifier|public
specifier|static
name|int
name|gcd
parameter_list|(
specifier|final
name|int
name|p
parameter_list|,
specifier|final
name|int
name|q
parameter_list|)
block|{
name|int
name|u
init|=
name|p
decl_stmt|;
name|int
name|v
init|=
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|==
literal|0
operator|)
operator|||
operator|(
name|v
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|==
name|Integer
operator|.
name|MIN_VALUE
operator|)
operator|||
operator|(
name|v
operator|==
name|Integer
operator|.
name|MIN_VALUE
operator|)
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"overflow: gcd({0}, {1}) is 2^31"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
throw|;
block|}
return|return
name|Math
operator|.
name|abs
argument_list|(
name|u
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|v
argument_list|)
return|;
block|}
comment|// keep u and v negative, as negative integers range down to
comment|// -2^31, while positive numbers can only be as large as 2^31-1
comment|// (i.e. we can't necessarily negate a negative number without
comment|// overflow)
comment|/* assert u!=0&& v!=0; */
if|if
condition|(
name|u
operator|>
literal|0
condition|)
block|{
name|u
operator|=
operator|-
name|u
expr_stmt|;
block|}
comment|// make u negative
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
block|}
comment|// make v negative
comment|// B1. [Find power of 2]
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|u
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
name|v
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|k
operator|<
literal|31
condition|)
block|{
comment|// while u and v are
comment|// both even...
name|u
operator|/=
literal|2
expr_stmt|;
name|v
operator|/=
literal|2
expr_stmt|;
name|k
operator|++
expr_stmt|;
comment|// cast out twos.
block|}
if|if
condition|(
name|k
operator|==
literal|31
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"overflow: gcd({0}, {1}) is 2^31"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
throw|;
block|}
comment|// B2. Initialize: u and v have been divided by 2^k and at least
comment|// one is odd.
name|int
name|t
init|=
operator|(
operator|(
name|u
operator|&
literal|1
operator|)
operator|==
literal|1
operator|)
condition|?
name|v
else|:
operator|-
operator|(
name|u
operator|/
literal|2
operator|)
comment|/* B3 */
decl_stmt|;
comment|// t negative: u was odd, v may be even (t replaces v)
comment|// t positive: u was even, v is odd (t replaces u)
do|do
block|{
comment|/* assert u<0&& v<0; */
comment|// B4/B3: cast out twos from t.
while|while
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// while t is even..
name|t
operator|/=
literal|2
expr_stmt|;
comment|// cast out twos
block|}
comment|// B5 [reset max(u,v)]
if|if
condition|(
name|t
operator|>
literal|0
condition|)
block|{
name|u
operator|=
operator|-
name|t
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|t
expr_stmt|;
block|}
comment|// B6/B3. at this point both u and v should be odd.
name|t
operator|=
operator|(
name|v
operator|-
name|u
operator|)
operator|/
literal|2
expr_stmt|;
comment|// |u| larger: t positive (replace u)
comment|// |v| larger: t negative (replace v)
block|}
do|while
condition|(
name|t
operator|!=
literal|0
condition|)
do|;
return|return
operator|-
name|u
operator|*
operator|(
literal|1
operator|<<
name|k
operator|)
return|;
comment|// gcd is u*2^k
block|}
comment|/**      *<p>      * Gets the greatest common divisor of the absolute value of two numbers,      * using the "binary gcd" method which avoids division and modulo      * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef      * Stein (1961).      *</p>      * Special cases:      *<ul>      *<li>The invocations      *<code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,      *<code>gcd(Long.MIN_VALUE, 0L)</code> and      *<code>gcd(0L, Long.MIN_VALUE)</code> throw an      *<code>ArithmeticException</code>, because the result would be 2^63, which      * is too large for a long value.</li>      *<li>The result of<code>gcd(x, x)</code>,<code>gcd(0L, x)</code> and      *<code>gcd(x, 0L)</code> is the absolute value of<code>x</code>, except      * for the special cases above.      *<li>The invocation<code>gcd(0L, 0L)</code> is the only one which returns      *<code>0L</code>.</li>      *</ul>      *      * @param p any number      * @param q any number      * @return the greatest common divisor, never negative      * @throws ArithmeticException if the result cannot be represented as a nonnegative long      *                             value      * @since 2.1      */
DECL|method|gcd
specifier|public
specifier|static
name|long
name|gcd
parameter_list|(
specifier|final
name|long
name|p
parameter_list|,
specifier|final
name|long
name|q
parameter_list|)
block|{
name|long
name|u
init|=
name|p
decl_stmt|;
name|long
name|v
init|=
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|==
literal|0
operator|)
operator|||
operator|(
name|v
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|==
name|Long
operator|.
name|MIN_VALUE
operator|)
operator|||
operator|(
name|v
operator|==
name|Long
operator|.
name|MIN_VALUE
operator|)
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"overflow: gcd({0}, {1}) is 2^63"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
throw|;
block|}
return|return
name|Math
operator|.
name|abs
argument_list|(
name|u
argument_list|)
operator|+
name|Math
operator|.
name|abs
argument_list|(
name|v
argument_list|)
return|;
block|}
comment|// keep u and v negative, as negative integers range down to
comment|// -2^63, while positive numbers can only be as large as 2^63-1
comment|// (i.e. we can't necessarily negate a negative number without
comment|// overflow)
comment|/* assert u!=0&& v!=0; */
if|if
condition|(
name|u
operator|>
literal|0
condition|)
block|{
name|u
operator|=
operator|-
name|u
expr_stmt|;
block|}
comment|// make u negative
if|if
condition|(
name|v
operator|>
literal|0
condition|)
block|{
name|v
operator|=
operator|-
name|v
expr_stmt|;
block|}
comment|// make v negative
comment|// B1. [Find power of 2]
name|int
name|k
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|u
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|(
name|v
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|k
operator|<
literal|63
condition|)
block|{
comment|// while u and v are
comment|// both even...
name|u
operator|/=
literal|2
expr_stmt|;
name|v
operator|/=
literal|2
expr_stmt|;
name|k
operator|++
expr_stmt|;
comment|// cast out twos.
block|}
if|if
condition|(
name|k
operator|==
literal|63
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"overflow: gcd({0}, {1}) is 2^63"
argument_list|,
name|p
argument_list|,
name|q
argument_list|)
throw|;
block|}
comment|// B2. Initialize: u and v have been divided by 2^k and at least
comment|// one is odd.
name|long
name|t
init|=
operator|(
operator|(
name|u
operator|&
literal|1
operator|)
operator|==
literal|1
operator|)
condition|?
name|v
else|:
operator|-
operator|(
name|u
operator|/
literal|2
operator|)
comment|/* B3 */
decl_stmt|;
comment|// t negative: u was odd, v may be even (t replaces v)
comment|// t positive: u was even, v is odd (t replaces u)
do|do
block|{
comment|/* assert u<0&& v<0; */
comment|// B4/B3: cast out twos from t.
while|while
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|// while t is even..
name|t
operator|/=
literal|2
expr_stmt|;
comment|// cast out twos
block|}
comment|// B5 [reset max(u,v)]
if|if
condition|(
name|t
operator|>
literal|0
condition|)
block|{
name|u
operator|=
operator|-
name|t
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|t
expr_stmt|;
block|}
comment|// B6/B3. at this point both u and v should be odd.
name|t
operator|=
operator|(
name|v
operator|-
name|u
operator|)
operator|/
literal|2
expr_stmt|;
comment|// |u| larger: t positive (replace u)
comment|// |v| larger: t negative (replace v)
block|}
do|while
condition|(
name|t
operator|!=
literal|0
condition|)
do|;
return|return
operator|-
name|u
operator|*
operator|(
literal|1L
operator|<<
name|k
operator|)
return|;
comment|// gcd is u*2^k
block|}
comment|/**      * Returns an integer hash code representing the given double value.      *      * @param value the value to be hashed      * @return the hash code      */
DECL|method|hash
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|double
name|value
parameter_list|)
block|{
return|return
operator|new
name|Double
argument_list|(
name|value
argument_list|)
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**      * Returns an integer hash code representing the given double array.      *      * @param value the value to be hashed (may be null)      * @return the hash code      * @since 1.2      */
DECL|method|hash
specifier|public
specifier|static
name|int
name|hash
parameter_list|(
name|double
index|[]
name|value
parameter_list|)
block|{
return|return
name|Arrays
operator|.
name|hashCode
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * For a byte value x, this method returns (byte)(+1) if x>= 0 and      * (byte)(-1) if x< 0.      *      * @param x the value, a byte      * @return (byte)(+1) or (byte)(-1), depending on the sign of x      */
DECL|method|indicator
specifier|public
specifier|static
name|byte
name|indicator
parameter_list|(
specifier|final
name|byte
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|>=
name|ZB
operator|)
condition|?
name|PB
else|:
name|NB
return|;
block|}
comment|/**      * For a double precision value x, this method returns +1.0 if x>= 0 and      * -1.0 if x< 0. Returns<code>NaN</code> if<code>x</code> is      *<code>NaN</code>.      *      * @param x the value, a double      * @return +1.0 or -1.0, depending on the sign of x      */
DECL|method|indicator
specifier|public
specifier|static
name|double
name|indicator
parameter_list|(
specifier|final
name|double
name|x
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|Double
operator|.
name|NaN
return|;
block|}
return|return
operator|(
name|x
operator|>=
literal|0.0
operator|)
condition|?
literal|1.0
else|:
operator|-
literal|1.0
return|;
block|}
comment|/**      * For a float value x, this method returns +1.0F if x>= 0 and -1.0F if x<      * 0. Returns<code>NaN</code> if<code>x</code> is<code>NaN</code>.      *      * @param x the value, a float      * @return +1.0F or -1.0F, depending on the sign of x      */
DECL|method|indicator
specifier|public
specifier|static
name|float
name|indicator
parameter_list|(
specifier|final
name|float
name|x
parameter_list|)
block|{
if|if
condition|(
name|Float
operator|.
name|isNaN
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|Float
operator|.
name|NaN
return|;
block|}
return|return
operator|(
name|x
operator|>=
literal|0.0F
operator|)
condition|?
literal|1.0F
else|:
operator|-
literal|1.0F
return|;
block|}
comment|/**      * For an int value x, this method returns +1 if x>= 0 and -1 if x< 0.      *      * @param x the value, an int      * @return +1 or -1, depending on the sign of x      */
DECL|method|indicator
specifier|public
specifier|static
name|int
name|indicator
parameter_list|(
specifier|final
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|>=
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/**      * For a long value x, this method returns +1L if x>= 0 and -1L if x< 0.      *      * @param x the value, a long      * @return +1L or -1L, depending on the sign of x      */
DECL|method|indicator
specifier|public
specifier|static
name|long
name|indicator
parameter_list|(
specifier|final
name|long
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|>=
literal|0L
operator|)
condition|?
literal|1L
else|:
operator|-
literal|1L
return|;
block|}
comment|/**      * For a short value x, this method returns (short)(+1) if x>= 0 and      * (short)(-1) if x< 0.      *      * @param x the value, a short      * @return (short)(+1) or (short)(-1), depending on the sign of x      */
DECL|method|indicator
specifier|public
specifier|static
name|short
name|indicator
parameter_list|(
specifier|final
name|short
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|>=
name|ZS
operator|)
condition|?
name|PS
else|:
name|NS
return|;
block|}
comment|/**      *<p>      * Returns the least common multiple of the absolute value of two numbers,      * using the formula<code>lcm(a,b) = (a / gcd(a,b)) * b</code>.      *</p>      * Special cases:      *<ul>      *<li>The invocations<code>lcm(Integer.MIN_VALUE, n)</code> and      *<code>lcm(n, Integer.MIN_VALUE)</code>, where<code>abs(n)</code> is a      * power of 2, throw an<code>ArithmeticException</code>, because the result      * would be 2^31, which is too large for an int value.</li>      *<li>The result of<code>lcm(0, x)</code> and<code>lcm(x, 0)</code> is      *<code>0</code> for any<code>x</code>.      *</ul>      *      * @param a any number      * @param b any number      * @return the least common multiple, never negative      * @throws ArithmeticException if the result cannot be represented as a nonnegative int      *                             value      * @since 1.1      */
DECL|method|lcm
specifier|public
specifier|static
name|int
name|lcm
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|int
name|lcm
init|=
name|Math
operator|.
name|abs
argument_list|(
name|mulAndCheck
argument_list|(
name|a
operator|/
name|gcd
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|,
name|b
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lcm
operator|==
name|Integer
operator|.
name|MIN_VALUE
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"overflow: lcm({0}, {1}) is 2^31"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
throw|;
block|}
return|return
name|lcm
return|;
block|}
comment|/**      *<p>      * Returns the least common multiple of the absolute value of two numbers,      * using the formula<code>lcm(a,b) = (a / gcd(a,b)) * b</code>.      *</p>      * Special cases:      *<ul>      *<li>The invocations<code>lcm(Long.MIN_VALUE, n)</code> and      *<code>lcm(n, Long.MIN_VALUE)</code>, where<code>abs(n)</code> is a      * power of 2, throw an<code>ArithmeticException</code>, because the result      * would be 2^63, which is too large for an int value.</li>      *<li>The result of<code>lcm(0L, x)</code> and<code>lcm(x, 0L)</code> is      *<code>0L</code> for any<code>x</code>.      *</ul>      *      * @param a any number      * @param b any number      * @return the least common multiple, never negative      * @throws ArithmeticException if the result cannot be represented as a nonnegative long      *                             value      * @since 2.1      */
DECL|method|lcm
specifier|public
specifier|static
name|long
name|lcm
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
operator|||
name|b
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|long
name|lcm
init|=
name|Math
operator|.
name|abs
argument_list|(
name|mulAndCheck
argument_list|(
name|a
operator|/
name|gcd
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
argument_list|,
name|b
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lcm
operator|==
name|Long
operator|.
name|MIN_VALUE
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"overflow: lcm({0}, {1}) is 2^63"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
throw|;
block|}
return|return
name|lcm
return|;
block|}
comment|/**      *<p>Returns the      *<a href="http://mathworld.wolfram.com/Logarithm.html">logarithm</a>      * for base<code>b</code> of<code>x</code>.      *</p>      *<p>Returns<code>NaN<code> if either argument is negative.  If      *<code>base</code> is 0 and<code>x</code> is positive, 0 is returned.      * If<code>base</code> is positive and<code>x</code> is 0,      *<code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments      * are 0, the result is<code>NaN</code>.</p>      *      * @param base the base of the logarithm, must be greater than 0      * @param x    argument, must be greater than 0      * @return the value of the logarithm - the number y such that base^y = x.      * @since 1.2      */
DECL|method|log
specifier|public
specifier|static
name|double
name|log
parameter_list|(
name|double
name|base
parameter_list|,
name|double
name|x
parameter_list|)
block|{
return|return
name|Math
operator|.
name|log
argument_list|(
name|x
argument_list|)
operator|/
name|Math
operator|.
name|log
argument_list|(
name|base
argument_list|)
return|;
block|}
comment|/**      * Multiply two integers, checking for overflow.      *      * @param x a factor      * @param y a factor      * @return the product<code>x*y</code>      * @throws ArithmeticException if the result can not be represented as an      *                             int      * @since 1.1      */
DECL|method|mulAndCheck
specifier|public
specifier|static
name|int
name|mulAndCheck
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|long
name|m
init|=
operator|(
operator|(
name|long
operator|)
name|x
operator|)
operator|*
operator|(
operator|(
name|long
operator|)
name|y
operator|)
decl_stmt|;
if|if
condition|(
name|m
argument_list|<
name|Integer
operator|.
name|MIN_VALUE
operator|||
name|m
argument_list|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"overflow: mul"
argument_list|)
throw|;
block|}
return|return
operator|(
name|int
operator|)
name|m
return|;
block|}
comment|/**      * Multiply two long integers, checking for overflow.      *      * @param a first value      * @param b second value      * @return the product<code>a * b</code>      * @throws ArithmeticException if the result can not be represented as an      *                             long      * @since 1.2      */
DECL|method|mulAndCheck
specifier|public
specifier|static
name|long
name|mulAndCheck
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
name|String
name|msg
init|=
literal|"overflow: multiply"
decl_stmt|;
if|if
condition|(
name|a
operator|>
name|b
condition|)
block|{
comment|// use symmetry to reduce boundary cases
name|ret
operator|=
name|mulAndCheck
argument_list|(
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
comment|// check for positive overflow with negative a, negative b
if|if
condition|(
name|a
operator|>=
name|Long
operator|.
name|MAX_VALUE
operator|/
name|b
condition|)
block|{
name|ret
operator|=
name|a
operator|*
name|b
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|b
operator|>
literal|0
condition|)
block|{
comment|// check for negative overflow with negative a, positive b
if|if
condition|(
name|Long
operator|.
name|MIN_VALUE
operator|/
name|b
operator|<=
name|a
condition|)
block|{
name|ret
operator|=
name|a
operator|*
name|b
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// assert b == 0
name|ret
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|a
operator|>
literal|0
condition|)
block|{
comment|// assert a> 0
comment|// assert b> 0
comment|// check for positive overflow with positive a, positive b
if|if
condition|(
name|a
operator|<=
name|Long
operator|.
name|MAX_VALUE
operator|/
name|b
condition|)
block|{
name|ret
operator|=
name|a
operator|*
name|b
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// assert a == 0
name|ret
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Get the next machine representable number after a number, moving      * in the direction of another number.      *<p>      * If<code>direction</code> is greater than or equal to<code>d</code>,      * the smallest machine representable number strictly greater than      *<code>d</code> is returned; otherwise the largest representable number      * strictly less than<code>d</code> is returned.</p>      *<p>      * If<code>d</code> is NaN or Infinite, it is returned unchanged.</p>      *      * @param d         base number      * @param direction (the only important thing is whether      *                  direction is greater or smaller than d)      * @return the next machine representable number in the specified direction      * @since 1.2      */
DECL|method|nextAfter
specifier|public
specifier|static
name|double
name|nextAfter
parameter_list|(
name|double
name|d
parameter_list|,
name|double
name|direction
parameter_list|)
block|{
comment|// handling of some important special cases
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|d
argument_list|)
operator|||
name|Double
operator|.
name|isInfinite
argument_list|(
name|d
argument_list|)
condition|)
block|{
return|return
name|d
return|;
block|}
elseif|else
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|direction
operator|<
literal|0
operator|)
condition|?
operator|-
name|Double
operator|.
name|MIN_VALUE
else|:
name|Double
operator|.
name|MIN_VALUE
return|;
block|}
comment|// special cases MAX_VALUE to infinity and  MIN_VALUE to 0
comment|// are handled just as normal numbers
comment|// split the double in raw components
name|long
name|bits
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|long
name|sign
init|=
name|bits
operator|&
literal|0x8000000000000000L
decl_stmt|;
name|long
name|exponent
init|=
name|bits
operator|&
literal|0x7ff0000000000000L
decl_stmt|;
name|long
name|mantissa
init|=
name|bits
operator|&
literal|0x000fffffffffffffL
decl_stmt|;
if|if
condition|(
name|d
operator|*
operator|(
name|direction
operator|-
name|d
operator|)
operator|>=
literal|0
condition|)
block|{
comment|// we should increase the mantissa
if|if
condition|(
name|mantissa
operator|==
literal|0x000fffffffffffffL
condition|)
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|sign
operator||
operator|(
name|exponent
operator|+
literal|0x0010000000000000L
operator|)
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|sign
operator||
name|exponent
operator||
operator|(
name|mantissa
operator|+
literal|1
operator|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|// we should decrease the mantissa
if|if
condition|(
name|mantissa
operator|==
literal|0L
condition|)
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|sign
operator||
operator|(
name|exponent
operator|-
literal|0x0010000000000000L
operator|)
operator||
literal|0x000fffffffffffffL
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|sign
operator||
name|exponent
operator||
operator|(
name|mantissa
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * Scale a number by 2<sup>scaleFactor</sup>.      *<p>If<code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>      *      * @param d           base number      * @param scaleFactor power of two by which d sould be multiplied      * @return d&times; 2<sup>scaleFactor</sup>      * @since 2.0      */
DECL|method|scalb
specifier|public
specifier|static
name|double
name|scalb
parameter_list|(
specifier|final
name|double
name|d
parameter_list|,
specifier|final
name|int
name|scaleFactor
parameter_list|)
block|{
comment|// handling of some important special cases
if|if
condition|(
operator|(
name|d
operator|==
literal|0
operator|)
operator|||
name|Double
operator|.
name|isNaN
argument_list|(
name|d
argument_list|)
operator|||
name|Double
operator|.
name|isInfinite
argument_list|(
name|d
argument_list|)
condition|)
block|{
return|return
name|d
return|;
block|}
comment|// split the double in raw components
specifier|final
name|long
name|bits
init|=
name|Double
operator|.
name|doubleToLongBits
argument_list|(
name|d
argument_list|)
decl_stmt|;
specifier|final
name|long
name|exponent
init|=
name|bits
operator|&
literal|0x7ff0000000000000L
decl_stmt|;
specifier|final
name|long
name|rest
init|=
name|bits
operator|&
literal|0x800fffffffffffffL
decl_stmt|;
comment|// shift the exponent
specifier|final
name|long
name|newBits
init|=
name|rest
operator||
operator|(
name|exponent
operator|+
operator|(
operator|(
operator|(
name|long
operator|)
name|scaleFactor
operator|)
operator|<<
literal|52
operator|)
operator|)
decl_stmt|;
return|return
name|Double
operator|.
name|longBitsToDouble
argument_list|(
name|newBits
argument_list|)
return|;
block|}
comment|/**      * Normalize an angle in a 2&pi wide interval around a center value.      *<p>This method has three main uses:</p>      *<ul>      *<li>normalize an angle between 0 and 2&pi;:<br/>      *<code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>      *<li>normalize an angle between -&pi; and +&pi;<br/>      *<code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>      *<li>compute the angle between two defining angular positions:<br>      *<code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>      *</ul>      *<p>Note that due to numerical accuracy and since&pi; cannot be represented      * exactly, the result interval is<em>closed</em>, it cannot be half-closed      * as would be more satisfactory in a purely mathematical view.</p>      *      * @param a      angle to normalize      * @param center center of the desired 2&pi; interval for the result      * @return a-2k&pi; with integer k and center-&pi;&lt;= a-2k&pi;&lt;= center+&pi;      * @since 1.2      */
DECL|method|normalizeAngle
specifier|public
specifier|static
name|double
name|normalizeAngle
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|center
parameter_list|)
block|{
return|return
name|a
operator|-
name|TWO_PI
operator|*
name|Math
operator|.
name|floor
argument_list|(
operator|(
name|a
operator|+
name|Math
operator|.
name|PI
operator|-
name|center
operator|)
operator|/
name|TWO_PI
argument_list|)
return|;
block|}
comment|/**      *<p>Normalizes an array to make it sum to a specified value.      * Returns the result of the transformation<pre>      *    x |-> x * normalizedSum / sum      *</pre>      * applied to each non-NaN element x of the input array, where sum is the      * sum of the non-NaN entries in the input array.</p>      *      *<p>Throws IllegalArgumentException if<code>normalizedSum</code> is infinite      * or NaN and ArithmeticException if the input array contains any infinite elements      * or sums to 0</p>      *      *<p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>      *      * @param values        input array to be normalized      * @param normalizedSum target sum for the normalized array      * @return normalized array      * @throws ArithmeticException      if the input array contains infinite elements or sums to zero      * @throws IllegalArgumentException if the target sum is infinite or NaN      * @since 2.1      */
DECL|method|normalizeArray
specifier|public
specifier|static
name|double
index|[]
name|normalizeArray
parameter_list|(
name|double
index|[]
name|values
parameter_list|,
name|double
name|normalizedSum
parameter_list|)
throws|throws
name|ArithmeticException
throws|,
name|IllegalArgumentException
block|{
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|normalizedSum
argument_list|)
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"Cannot normalize to an infinite value"
argument_list|)
throw|;
block|}
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|normalizedSum
argument_list|)
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"Cannot normalize to NaN"
argument_list|)
throw|;
block|}
name|double
name|sum
init|=
literal|0d
decl_stmt|;
specifier|final
name|int
name|len
init|=
name|values
operator|.
name|length
decl_stmt|;
name|double
index|[]
name|out
init|=
operator|new
name|double
index|[
name|len
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"Array contains an infinite element, {0} at index {1}"
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|sum
operator|+=
name|values
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createArithmeticException
argument_list|(
literal|"Array sums to zero"
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|out
index|[
name|i
index|]
operator|=
name|Double
operator|.
name|NaN
expr_stmt|;
block|}
else|else
block|{
name|out
index|[
name|i
index|]
operator|=
name|values
index|[
name|i
index|]
operator|*
name|normalizedSum
operator|/
name|sum
expr_stmt|;
block|}
block|}
return|return
name|out
return|;
block|}
comment|/**      * Round the given value to the specified number of decimal places. The      * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.      *      * @param x     the value to round.      * @param scale the number of digits to the right of the decimal point.      * @return the rounded value.      * @since 1.1      */
DECL|method|round
specifier|public
specifier|static
name|double
name|round
parameter_list|(
name|double
name|x
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
return|return
name|round
argument_list|(
name|x
argument_list|,
name|scale
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_UP
argument_list|)
return|;
block|}
comment|/**      * Round the given value to the specified number of decimal places. The      * value is rounded using the given method which is any method defined in      * {@link BigDecimal}.      *      * @param x              the value to round.      * @param scale          the number of digits to the right of the decimal point.      * @param roundingMethod the rounding method as defined in      *                       {@link BigDecimal}.      * @return the rounded value.      * @since 1.1      */
DECL|method|round
specifier|public
specifier|static
name|double
name|round
parameter_list|(
name|double
name|x
parameter_list|,
name|int
name|scale
parameter_list|,
name|int
name|roundingMethod
parameter_list|)
block|{
try|try
block|{
return|return
operator|(
operator|new
name|BigDecimal
argument_list|(
name|Double
operator|.
name|toString
argument_list|(
name|x
argument_list|)
argument_list|)
operator|.
name|setScale
argument_list|(
name|scale
argument_list|,
name|roundingMethod
argument_list|)
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|ex
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|isInfinite
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|x
return|;
block|}
else|else
block|{
return|return
name|Double
operator|.
name|NaN
return|;
block|}
block|}
block|}
comment|/**      * Round the given value to the specified number of decimal places. The      * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.      *      * @param x     the value to round.      * @param scale the number of digits to the right of the decimal point.      * @return the rounded value.      * @since 1.1      */
DECL|method|round
specifier|public
specifier|static
name|float
name|round
parameter_list|(
name|float
name|x
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
return|return
name|round
argument_list|(
name|x
argument_list|,
name|scale
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_UP
argument_list|)
return|;
block|}
comment|/**      * Round the given value to the specified number of decimal places. The      * value is rounded using the given method which is any method defined in      * {@link BigDecimal}.      *      * @param x              the value to round.      * @param scale          the number of digits to the right of the decimal point.      * @param roundingMethod the rounding method as defined in      *                       {@link BigDecimal}.      * @return the rounded value.      * @since 1.1      */
DECL|method|round
specifier|public
specifier|static
name|float
name|round
parameter_list|(
name|float
name|x
parameter_list|,
name|int
name|scale
parameter_list|,
name|int
name|roundingMethod
parameter_list|)
block|{
name|float
name|sign
init|=
name|indicator
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|float
name|factor
init|=
operator|(
name|float
operator|)
name|Math
operator|.
name|pow
argument_list|(
literal|10.0f
argument_list|,
name|scale
argument_list|)
operator|*
name|sign
decl_stmt|;
return|return
operator|(
name|float
operator|)
name|roundUnscaled
argument_list|(
name|x
operator|*
name|factor
argument_list|,
name|sign
argument_list|,
name|roundingMethod
argument_list|)
operator|/
name|factor
return|;
block|}
comment|/**      * Round the given non-negative, value to the "nearest" integer. Nearest is      * determined by the rounding method specified. Rounding methods are defined      * in {@link BigDecimal}.      *      * @param unscaled       the value to round.      * @param sign           the sign of the original, scaled value.      * @param roundingMethod the rounding method as defined in      *                       {@link BigDecimal}.      * @return the rounded value.      * @since 1.1      */
DECL|method|roundUnscaled
specifier|private
specifier|static
name|double
name|roundUnscaled
parameter_list|(
name|double
name|unscaled
parameter_list|,
name|double
name|sign
parameter_list|,
name|int
name|roundingMethod
parameter_list|)
block|{
switch|switch
condition|(
name|roundingMethod
condition|)
block|{
case|case
name|BigDecimal
operator|.
name|ROUND_CEILING
case|:
if|if
condition|(
name|sign
operator|==
operator|-
literal|1
condition|)
block|{
name|unscaled
operator|=
name|Math
operator|.
name|floor
argument_list|(
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|NEGATIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unscaled
operator|=
name|Math
operator|.
name|ceil
argument_list|(
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_DOWN
case|:
name|unscaled
operator|=
name|Math
operator|.
name|floor
argument_list|(
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|NEGATIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_FLOOR
case|:
if|if
condition|(
name|sign
operator|==
operator|-
literal|1
condition|)
block|{
name|unscaled
operator|=
name|Math
operator|.
name|ceil
argument_list|(
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unscaled
operator|=
name|Math
operator|.
name|floor
argument_list|(
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|NEGATIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_HALF_DOWN
case|:
block|{
name|unscaled
operator|=
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|NEGATIVE_INFINITY
argument_list|)
expr_stmt|;
name|double
name|fraction
init|=
name|unscaled
operator|-
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
decl_stmt|;
if|if
condition|(
name|fraction
operator|>
literal|0.5
condition|)
block|{
name|unscaled
operator|=
name|Math
operator|.
name|ceil
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unscaled
operator|=
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BigDecimal
operator|.
name|ROUND_HALF_EVEN
case|:
block|{
name|double
name|fraction
init|=
name|unscaled
operator|-
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
decl_stmt|;
if|if
condition|(
name|fraction
operator|>
literal|0.5
condition|)
block|{
name|unscaled
operator|=
name|Math
operator|.
name|ceil
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fraction
operator|<
literal|0.5
condition|)
block|{
name|unscaled
operator|=
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// The following equality test is intentional and needed for rounding purposes
if|if
condition|(
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
operator|/
literal|2.0
operator|==
name|Math
operator|.
name|floor
argument_list|(
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
operator|/
literal|2.0
argument_list|)
condition|)
block|{
comment|// even
name|unscaled
operator|=
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// odd
name|unscaled
operator|=
name|Math
operator|.
name|ceil
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|BigDecimal
operator|.
name|ROUND_HALF_UP
case|:
block|{
name|unscaled
operator|=
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
expr_stmt|;
name|double
name|fraction
init|=
name|unscaled
operator|-
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
decl_stmt|;
if|if
condition|(
name|fraction
operator|>=
literal|0.5
condition|)
block|{
name|unscaled
operator|=
name|Math
operator|.
name|ceil
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unscaled
operator|=
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BigDecimal
operator|.
name|ROUND_UNNECESSARY
case|:
if|if
condition|(
name|unscaled
operator|!=
name|Math
operator|.
name|floor
argument_list|(
name|unscaled
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"Inexact result from rounding"
argument_list|)
throw|;
block|}
break|break;
case|case
name|BigDecimal
operator|.
name|ROUND_UP
case|:
name|unscaled
operator|=
name|Math
operator|.
name|ceil
argument_list|(
name|nextAfter
argument_list|(
name|unscaled
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),"
operator|+
literal|" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})"
argument_list|,
name|roundingMethod
argument_list|,
literal|"ROUND_CEILING"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_CEILING
argument_list|,
literal|"ROUND_DOWN"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_DOWN
argument_list|,
literal|"ROUND_FLOOR"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_FLOOR
argument_list|,
literal|"ROUND_HALF_DOWN"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_DOWN
argument_list|,
literal|"ROUND_HALF_EVEN"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_EVEN
argument_list|,
literal|"ROUND_HALF_UP"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_HALF_UP
argument_list|,
literal|"ROUND_UNNECESSARY"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_UNNECESSARY
argument_list|,
literal|"ROUND_UP"
argument_list|,
name|BigDecimal
operator|.
name|ROUND_UP
argument_list|)
throw|;
block|}
return|return
name|unscaled
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/Sign.html"> sign</a>      * for byte value<code>x</code>.      *<p>      * For a byte value x, this method returns (byte)(+1) if x> 0, (byte)(0) if      * x = 0, and (byte)(-1) if x< 0.</p>      *      * @param x the value, a byte      * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x      */
DECL|method|sign
specifier|public
specifier|static
name|byte
name|sign
parameter_list|(
specifier|final
name|byte
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|==
name|ZB
operator|)
condition|?
name|ZB
else|:
operator|(
name|x
operator|>
name|ZB
operator|)
condition|?
name|PB
else|:
name|NB
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/Sign.html"> sign</a>      * for double precision<code>x</code>.      *<p>      * For a double value<code>x</code>, this method returns      *<code>+1.0</code> if<code>x> 0</code>,<code>0.0</code> if      *<code>x = 0.0</code>, and<code>-1.0</code> if<code>x< 0</code>.      * Returns<code>NaN</code> if<code>x</code> is<code>NaN</code>.</p>      *      * @param x the value, a double      * @return +1.0, 0.0, or -1.0, depending on the sign of x      */
DECL|method|sign
specifier|public
specifier|static
name|double
name|sign
parameter_list|(
specifier|final
name|double
name|x
parameter_list|)
block|{
if|if
condition|(
name|Double
operator|.
name|isNaN
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|Double
operator|.
name|NaN
return|;
block|}
return|return
operator|(
name|x
operator|==
literal|0.0
operator|)
condition|?
literal|0.0
else|:
operator|(
name|x
operator|>
literal|0.0
operator|)
condition|?
literal|1.0
else|:
operator|-
literal|1.0
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/Sign.html"> sign</a>      * for float value<code>x</code>.      *<p>      * For a float value x, this method returns +1.0F if x> 0, 0.0F if x =      * 0.0F, and -1.0F if x< 0. Returns<code>NaN</code> if<code>x</code>      * is<code>NaN</code>.</p>      *      * @param x the value, a float      * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x      */
DECL|method|sign
specifier|public
specifier|static
name|float
name|sign
parameter_list|(
specifier|final
name|float
name|x
parameter_list|)
block|{
if|if
condition|(
name|Float
operator|.
name|isNaN
argument_list|(
name|x
argument_list|)
condition|)
block|{
return|return
name|Float
operator|.
name|NaN
return|;
block|}
return|return
operator|(
name|x
operator|==
literal|0.0F
operator|)
condition|?
literal|0.0F
else|:
operator|(
name|x
operator|>
literal|0.0F
operator|)
condition|?
literal|1.0F
else|:
operator|-
literal|1.0F
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/Sign.html"> sign</a>      * for int value<code>x</code>.      *<p>      * For an int value x, this method returns +1 if x> 0, 0 if x = 0, and -1      * if x< 0.</p>      *      * @param x the value, an int      * @return +1, 0, or -1, depending on the sign of x      */
DECL|method|sign
specifier|public
specifier|static
name|int
name|sign
parameter_list|(
specifier|final
name|int
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|x
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/Sign.html"> sign</a>      * for long value<code>x</code>.      *<p>      * For a long value x, this method returns +1L if x> 0, 0L if x = 0, and      * -1L if x< 0.</p>      *      * @param x the value, a long      * @return +1L, 0L, or -1L, depending on the sign of x      */
DECL|method|sign
specifier|public
specifier|static
name|long
name|sign
parameter_list|(
specifier|final
name|long
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|==
literal|0L
operator|)
condition|?
literal|0L
else|:
operator|(
name|x
operator|>
literal|0L
operator|)
condition|?
literal|1L
else|:
operator|-
literal|1L
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/Sign.html"> sign</a>      * for short value<code>x</code>.      *<p>      * For a short value x, this method returns (short)(+1) if x> 0, (short)(0)      * if x = 0, and (short)(-1) if x< 0.</p>      *      * @param x the value, a short      * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of      *         x      */
DECL|method|sign
specifier|public
specifier|static
name|short
name|sign
parameter_list|(
specifier|final
name|short
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|==
name|ZS
operator|)
condition|?
name|ZS
else|:
operator|(
name|x
operator|>
name|ZS
operator|)
condition|?
name|PS
else|:
name|NS
return|;
block|}
comment|/**      * Returns the<a href="http://mathworld.wolfram.com/HyperbolicSine.html">      * hyperbolic sine</a> of x.      *      * @param x double value for which to find the hyperbolic sine      * @return hyperbolic sine of x      */
DECL|method|sinh
specifier|public
specifier|static
name|double
name|sinh
parameter_list|(
name|double
name|x
parameter_list|)
block|{
return|return
operator|(
name|Math
operator|.
name|exp
argument_list|(
name|x
argument_list|)
operator|-
name|Math
operator|.
name|exp
argument_list|(
operator|-
name|x
argument_list|)
operator|)
operator|/
literal|2.0
return|;
block|}
comment|/**      * Subtract two integers, checking for overflow.      *      * @param x the minuend      * @param y the subtrahend      * @return the difference<code>x-y</code>      * @throws ArithmeticException if the result can not be represented as an      *                             int      * @since 1.1      */
DECL|method|subAndCheck
specifier|public
specifier|static
name|int
name|subAndCheck
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|long
name|s
init|=
operator|(
name|long
operator|)
name|x
operator|-
operator|(
name|long
operator|)
name|y
decl_stmt|;
if|if
condition|(
name|s
argument_list|<
name|Integer
operator|.
name|MIN_VALUE
operator|||
name|s
argument_list|>
name|Integer
operator|.
name|MAX_VALUE
condition|)
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
literal|"overflow: subtract"
argument_list|)
throw|;
block|}
return|return
operator|(
name|int
operator|)
name|s
return|;
block|}
comment|/**      * Subtract two long integers, checking for overflow.      *      * @param a first value      * @param b second value      * @return the difference<code>a-b</code>      * @throws ArithmeticException if the result can not be represented as an      *                             long      * @since 1.2      */
DECL|method|subAndCheck
specifier|public
specifier|static
name|long
name|subAndCheck
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
name|long
name|ret
decl_stmt|;
name|String
name|msg
init|=
literal|"overflow: subtract"
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|Long
operator|.
name|MIN_VALUE
condition|)
block|{
if|if
condition|(
name|a
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|a
operator|-
name|b
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|ArithmeticException
argument_list|(
name|msg
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// use additive inverse
name|ret
operator|=
name|addAndCheck
argument_list|(
name|a
argument_list|,
operator|-
name|b
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Raise an int to an int power.      *      * @param k number to raise      * @param e exponent (must be positive or null)      * @return k<sup>e</sup>      * @throws IllegalArgumentException if e is negative      */
DECL|method|pow
specifier|public
specifier|static
name|int
name|pow
parameter_list|(
specifier|final
name|int
name|k
parameter_list|,
name|int
name|e
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"cannot raise an integral value to a negative power ({0}^{1})"
argument_list|,
name|k
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|int
name|result
init|=
literal|1
decl_stmt|;
name|int
name|k2p
init|=
name|k
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|*=
name|k2p
expr_stmt|;
block|}
name|k2p
operator|*=
name|k2p
expr_stmt|;
name|e
operator|=
name|e
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Raise an int to a long power.      *      * @param k number to raise      * @param e exponent (must be positive or null)      * @return k<sup>e</sup>      * @throws IllegalArgumentException if e is negative      */
DECL|method|pow
specifier|public
specifier|static
name|int
name|pow
parameter_list|(
specifier|final
name|int
name|k
parameter_list|,
name|long
name|e
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"cannot raise an integral value to a negative power ({0}^{1})"
argument_list|,
name|k
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|int
name|result
init|=
literal|1
decl_stmt|;
name|int
name|k2p
init|=
name|k
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|*=
name|k2p
expr_stmt|;
block|}
name|k2p
operator|*=
name|k2p
expr_stmt|;
name|e
operator|=
name|e
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Raise a long to an int power.      *      * @param k number to raise      * @param e exponent (must be positive or null)      * @return k<sup>e</sup>      * @throws IllegalArgumentException if e is negative      */
DECL|method|pow
specifier|public
specifier|static
name|long
name|pow
parameter_list|(
specifier|final
name|long
name|k
parameter_list|,
name|int
name|e
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"cannot raise an integral value to a negative power ({0}^{1})"
argument_list|,
name|k
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|result
init|=
literal|1l
decl_stmt|;
name|long
name|k2p
init|=
name|k
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|*=
name|k2p
expr_stmt|;
block|}
name|k2p
operator|*=
name|k2p
expr_stmt|;
name|e
operator|=
name|e
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Raise a long to a long power.      *      * @param k number to raise      * @param e exponent (must be positive or null)      * @return k<sup>e</sup>      * @throws IllegalArgumentException if e is negative      */
DECL|method|pow
specifier|public
specifier|static
name|long
name|pow
parameter_list|(
specifier|final
name|long
name|k
parameter_list|,
name|long
name|e
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"cannot raise an integral value to a negative power ({0}^{1})"
argument_list|,
name|k
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|result
init|=
literal|1l
decl_stmt|;
name|long
name|k2p
init|=
name|k
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|*=
name|k2p
expr_stmt|;
block|}
name|k2p
operator|*=
name|k2p
expr_stmt|;
name|e
operator|=
name|e
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Raise a BigInteger to an int power.      *      * @param k number to raise      * @param e exponent (must be positive or null)      * @return k<sup>e</sup>      * @throws IllegalArgumentException if e is negative      */
DECL|method|pow
specifier|public
specifier|static
name|BigInteger
name|pow
parameter_list|(
specifier|final
name|BigInteger
name|k
parameter_list|,
name|int
name|e
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"cannot raise an integral value to a negative power ({0}^{1})"
argument_list|,
name|k
argument_list|,
name|e
argument_list|)
throw|;
block|}
return|return
name|k
operator|.
name|pow
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**      * Raise a BigInteger to a long power.      *      * @param k number to raise      * @param e exponent (must be positive or null)      * @return k<sup>e</sup>      * @throws IllegalArgumentException if e is negative      */
DECL|method|pow
specifier|public
specifier|static
name|BigInteger
name|pow
parameter_list|(
specifier|final
name|BigInteger
name|k
parameter_list|,
name|long
name|e
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|e
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"cannot raise an integral value to a negative power ({0}^{1})"
argument_list|,
name|k
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|BigInteger
name|result
init|=
name|BigInteger
operator|.
name|ONE
decl_stmt|;
name|BigInteger
name|k2p
init|=
name|k
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|result
operator|.
name|multiply
argument_list|(
name|k2p
argument_list|)
expr_stmt|;
block|}
name|k2p
operator|=
name|k2p
operator|.
name|multiply
argument_list|(
name|k2p
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Raise a BigInteger to a BigInteger power.      *      * @param k number to raise      * @param e exponent (must be positive or null)      * @return k<sup>e</sup>      * @throws IllegalArgumentException if e is negative      */
DECL|method|pow
specifier|public
specifier|static
name|BigInteger
name|pow
parameter_list|(
specifier|final
name|BigInteger
name|k
parameter_list|,
name|BigInteger
name|e
parameter_list|)
throws|throws
name|IllegalArgumentException
block|{
if|if
condition|(
name|e
operator|.
name|compareTo
argument_list|(
name|BigInteger
operator|.
name|ZERO
argument_list|)
operator|<
literal|0
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"cannot raise an integral value to a negative power ({0}^{1})"
argument_list|,
name|k
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|BigInteger
name|result
init|=
name|BigInteger
operator|.
name|ONE
decl_stmt|;
name|BigInteger
name|k2p
init|=
name|k
decl_stmt|;
while|while
condition|(
operator|!
name|BigInteger
operator|.
name|ZERO
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|testBit
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|result
operator|=
name|result
operator|.
name|multiply
argument_list|(
name|k2p
argument_list|)
expr_stmt|;
block|}
name|k2p
operator|=
name|k2p
operator|.
name|multiply
argument_list|(
name|k2p
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|.
name|shiftRight
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
comment|/**      * Calculates the L<sub>1</sub> (sum of abs) distance between two points.      *      * @param p1 the first point      * @param p2 the second point      * @return the L<sub>1</sub> distance between the two points      */
DECL|method|distance1
specifier|public
specifier|static
name|double
name|distance1
parameter_list|(
name|double
index|[]
name|p1
parameter_list|,
name|double
index|[]
name|p2
parameter_list|)
block|{
name|double
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|Math
operator|.
name|abs
argument_list|(
name|p1
index|[
name|i
index|]
operator|-
name|p2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|/**      * Calculates the L<sub>1</sub> (sum of abs) distance between two points.      *      * @param p1 the first point      * @param p2 the second point      * @return the L<sub>1</sub> distance between the two points      */
DECL|method|distance1
specifier|public
specifier|static
name|int
name|distance1
parameter_list|(
name|int
index|[]
name|p1
parameter_list|,
name|int
index|[]
name|p2
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|+=
name|Math
operator|.
name|abs
argument_list|(
name|p1
index|[
name|i
index|]
operator|-
name|p2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|/**      * Calculates the L<sub>2</sub> (Euclidean) distance between two points.      *      * @param p1 the first point      * @param p2 the second point      * @return the L<sub>2</sub> distance between the two points      */
DECL|method|distance
specifier|public
specifier|static
name|double
name|distance
parameter_list|(
name|double
index|[]
name|p1
parameter_list|,
name|double
index|[]
name|p2
parameter_list|)
block|{
name|double
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|double
name|dp
init|=
name|p1
index|[
name|i
index|]
operator|-
name|p2
index|[
name|i
index|]
decl_stmt|;
name|sum
operator|+=
name|dp
operator|*
name|dp
expr_stmt|;
block|}
return|return
name|Math
operator|.
name|sqrt
argument_list|(
name|sum
argument_list|)
return|;
block|}
comment|/**      * Calculates the L<sub>2</sub> (Euclidean) distance between two points.      *      * @param p1 the first point      * @param p2 the second point      * @return the L<sub>2</sub> distance between the two points      */
DECL|method|distance
specifier|public
specifier|static
name|double
name|distance
parameter_list|(
name|int
index|[]
name|p1
parameter_list|,
name|int
index|[]
name|p2
parameter_list|)
block|{
name|double
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
specifier|final
name|double
name|dp
init|=
name|p1
index|[
name|i
index|]
operator|-
name|p2
index|[
name|i
index|]
decl_stmt|;
name|sum
operator|+=
name|dp
operator|*
name|dp
expr_stmt|;
block|}
return|return
name|Math
operator|.
name|sqrt
argument_list|(
name|sum
argument_list|)
return|;
block|}
comment|/**      * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.      *      * @param p1 the first point      * @param p2 the second point      * @return the L<sub>&infin;</sub> distance between the two points      */
DECL|method|distanceInf
specifier|public
specifier|static
name|double
name|distanceInf
parameter_list|(
name|double
index|[]
name|p1
parameter_list|,
name|double
index|[]
name|p2
parameter_list|)
block|{
name|double
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|max
argument_list|,
name|Math
operator|.
name|abs
argument_list|(
name|p1
index|[
name|i
index|]
operator|-
name|p2
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
comment|/**      * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.      *      * @param p1 the first point      * @param p2 the second point      * @return the L<sub>&infin;</sub> distance between the two points      */
DECL|method|distanceInf
specifier|public
specifier|static
name|int
name|distanceInf
parameter_list|(
name|int
index|[]
name|p1
parameter_list|,
name|int
index|[]
name|p2
parameter_list|)
block|{
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|p1
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|max
operator|=
name|Math
operator|.
name|max
argument_list|(
name|max
argument_list|,
name|Math
operator|.
name|abs
argument_list|(
name|p1
index|[
name|i
index|]
operator|-
name|p2
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|max
return|;
block|}
comment|/**      * Checks that the given array is sorted.      *      * @param val    Values      * @param dir    Order direction (-1 for decreasing, 1 for increasing)      * @param strict Whether the order should be strict      * @throws IllegalArgumentException if the array is not sorted.      */
DECL|method|checkOrder
specifier|public
specifier|static
name|void
name|checkOrder
parameter_list|(
name|double
index|[]
name|val
parameter_list|,
name|int
name|dir
parameter_list|,
name|boolean
name|strict
parameter_list|)
block|{
name|double
name|previous
init|=
name|val
index|[
literal|0
index|]
decl_stmt|;
name|int
name|max
init|=
name|val
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strict
condition|)
block|{
if|if
condition|(
name|val
index|[
name|i
index|]
operator|<=
name|previous
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"points {0} and {1} are not strictly increasing ({2}>= {3})"
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|previous
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val
index|[
name|i
index|]
operator|<
name|previous
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"points {0} and {1} are not increasing ({2}> {3})"
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|previous
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
throw|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|strict
condition|)
block|{
if|if
condition|(
name|val
index|[
name|i
index|]
operator|>=
name|previous
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"points {0} and {1} are not strictly decreasing ({2}<= {3})"
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|previous
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val
index|[
name|i
index|]
operator|>
name|previous
condition|)
block|{
throw|throw
name|MathRuntimeException
operator|.
name|createIllegalArgumentException
argument_list|(
literal|"points {0} and {1} are not decreasing ({2}< {3})"
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|previous
argument_list|,
name|val
index|[
name|i
index|]
argument_list|)
throw|;
block|}
block|}
block|}
name|previous
operator|=
name|val
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

