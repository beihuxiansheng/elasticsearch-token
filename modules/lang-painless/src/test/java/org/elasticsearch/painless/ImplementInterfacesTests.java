begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|script
operator|.
name|ScriptContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyMap
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|containsString
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|not
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|startsWith
import|;
end_import

begin_comment
comment|/**  * Tests for Painless implementing different interfaces.  */
end_comment

begin_class
DECL|class|ImplementInterfacesTests
specifier|public
class|class
name|ImplementInterfacesTests
extends|extends
name|ScriptTestCase
block|{
DECL|interface|NoArgs
specifier|public
interface|interface
name|NoArgs
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|()
function_decl|;
block|}
DECL|method|testNoArgs
specifier|public
name|void
name|testNoArgs
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|NoArgs
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|NoArgs
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"foo"
argument_list|,
operator|(
operator|(
name|NoArgs
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"'foo'"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"doc"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Variable [doc] is not defined."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// _score was once embedded into painless by deep magic
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"_score"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Variable [_score] is not defined."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|debug
init|=
name|Debugger
operator|.
name|toString
argument_list|(
name|NoArgs
operator|.
name|class
argument_list|,
literal|"int i = 0"
argument_list|,
operator|new
name|CompilerSettings
argument_list|()
argument_list|)
decl_stmt|;
comment|/* Elasticsearch requires that scripts that return nothing return null. We hack that together by returning null from scripts that          * return Object if they don't return anything. */
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"ACONST_NULL"
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"ARETURN"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|OneArg
specifier|public
interface|interface
name|OneArg
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"arg"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|Object
name|arg
parameter_list|)
function_decl|;
block|}
DECL|method|testOneArg
specifier|public
name|void
name|testOneArg
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|OneArg
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Object
name|rando
init|=
name|randomInt
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|OneArg
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"arg"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
name|rando
argument_list|)
argument_list|)
expr_stmt|;
name|rando
operator|=
name|randomAlphaOfLength
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|OneArg
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"arg"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
name|rando
argument_list|)
argument_list|)
expr_stmt|;
name|Compiler
name|noargs
init|=
operator|new
name|Compiler
argument_list|(
name|NoArgs
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|noargs
argument_list|,
literal|null
argument_list|,
literal|"doc"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Variable [doc] is not defined."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
comment|// _score was once embedded into painless by deep magic
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|noargs
argument_list|,
literal|null
argument_list|,
literal|"_score"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Variable [_score] is not defined."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|ArrayArg
specifier|public
interface|interface
name|ArrayArg
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"arg"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
index|[]
name|arg
parameter_list|)
function_decl|;
block|}
DECL|method|testArrayArg
specifier|public
name|void
name|testArrayArg
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|ArrayArg
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|String
name|rando
init|=
name|randomAlphaOfLength
argument_list|(
literal|5
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|ArrayArg
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"arg[0]"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
operator|new
name|String
index|[]
block|{
name|rando
block|,
literal|"foo"
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|PrimitiveArrayArg
specifier|public
interface|interface
name|PrimitiveArrayArg
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"arg"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|int
index|[]
name|arg
parameter_list|)
function_decl|;
block|}
DECL|method|testPrimitiveArrayArg
specifier|public
name|void
name|testPrimitiveArrayArg
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|PrimitiveArrayArg
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|int
name|rando
init|=
name|randomInt
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|PrimitiveArrayArg
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"arg[0]"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
operator|new
name|int
index|[]
block|{
name|rando
block|,
literal|10
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|DefArrayArg
specifier|public
interface|interface
name|DefArrayArg
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"arg"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|Object
index|[]
name|arg
parameter_list|)
function_decl|;
block|}
DECL|method|testDefArrayArg
specifier|public
name|void
name|testDefArrayArg
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|DefArrayArg
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Object
name|rando
init|=
name|randomInt
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|DefArrayArg
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"arg[0]"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
operator|new
name|Object
index|[]
block|{
name|rando
block|,
literal|10
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|rando
operator|=
name|randomAlphaOfLength
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|DefArrayArg
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"arg[0]"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
operator|new
name|Object
index|[]
block|{
name|rando
block|,
literal|10
block|}
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
operator|(
operator|(
name|DefArrayArg
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"arg[0].length()"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
operator|new
name|Object
index|[]
block|{
name|rando
block|,
literal|10
block|}
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|ManyArgs
specifier|public
interface|interface
name|ManyArgs
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|d
parameter_list|)
function_decl|;
DECL|method|uses$a
name|boolean
name|uses$a
parameter_list|()
function_decl|;
DECL|method|uses$b
name|boolean
name|uses$b
parameter_list|()
function_decl|;
DECL|method|uses$c
name|boolean
name|uses$c
parameter_list|()
function_decl|;
DECL|method|uses$d
name|boolean
name|uses$d
parameter_list|()
function_decl|;
block|}
DECL|method|testManyArgs
specifier|public
name|void
name|testManyArgs
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|ManyArgs
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|int
name|rando
init|=
name|randomInt
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|ManyArgs
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
name|rando
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
operator|(
operator|(
name|ManyArgs
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a + b + c + d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|// While we're here we can verify that painless correctly finds used variables
name|ManyArgs
name|script
init|=
operator|(
name|ManyArgs
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
decl_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$a
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|script
operator|.
name|uses$b
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|script
operator|.
name|uses$c
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|script
operator|.
name|uses$d
argument_list|()
argument_list|)
expr_stmt|;
name|script
operator|=
operator|(
name|ManyArgs
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a + b + c"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$a
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$b
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$c
argument_list|()
argument_list|)
expr_stmt|;
name|assertFalse
argument_list|(
name|script
operator|.
name|uses$d
argument_list|()
argument_list|)
expr_stmt|;
name|script
operator|=
operator|(
name|ManyArgs
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a + b + c + d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$a
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$b
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$c
argument_list|()
argument_list|)
expr_stmt|;
name|assertTrue
argument_list|(
name|script
operator|.
name|uses$d
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|VarargTest
specifier|public
interface|interface
name|VarargTest
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"arg"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
modifier|...
name|arg
parameter_list|)
function_decl|;
block|}
DECL|method|testVararg
specifier|public
name|void
name|testVararg
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|VarargTest
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"foo bar baz"
argument_list|,
operator|(
operator|(
name|VarargTest
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"String.join(' ', Arrays.asList(arg))"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
literal|"foo"
argument_list|,
literal|"bar"
argument_list|,
literal|"baz"
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|DefaultMethods
specifier|public
interface|interface
name|DefaultMethods
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"a"
block|,
literal|"b"
block|,
literal|"c"
block|,
literal|"d"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|d
parameter_list|)
function_decl|;
DECL|method|executeWithOne
specifier|default
name|Object
name|executeWithOne
parameter_list|()
block|{
return|return
name|execute
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|method|executeWithASingleOne
specifier|default
name|Object
name|executeWithASingleOne
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|)
block|{
return|return
name|execute
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
DECL|method|testDefaultMethods
specifier|public
name|void
name|testDefaultMethods
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|DefaultMethods
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|int
name|rando
init|=
name|randomInt
argument_list|()
decl_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|DefaultMethods
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
name|rando
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|rando
argument_list|,
operator|(
operator|(
name|DefaultMethods
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|executeWithASingleOne
argument_list|(
name|rando
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
operator|(
operator|(
name|DefaultMethods
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a + b + c + d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|4
argument_list|,
operator|(
operator|(
name|DefaultMethods
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a + b + c + d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|executeWithOne
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|7
argument_list|,
operator|(
operator|(
name|DefaultMethods
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"a + b + c + d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|executeWithASingleOne
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|ReturnsVoid
specifier|public
interface|interface
name|ReturnsVoid
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"map"
block|}
decl_stmt|;
DECL|method|execute
name|void
name|execute
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
parameter_list|)
function_decl|;
block|}
DECL|method|testReturnsVoid
specifier|public
name|void
name|testReturnsVoid
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|ReturnsVoid
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
operator|(
operator|(
name|ReturnsVoid
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"map.a = 'foo'"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|singletonMap
argument_list|(
literal|"a"
argument_list|,
literal|"foo"
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ReturnsVoid
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"map.remove('a')"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|emptyMap
argument_list|()
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|String
name|debug
init|=
name|Debugger
operator|.
name|toString
argument_list|(
name|ReturnsVoid
operator|.
name|class
argument_list|,
literal|"int i = 0"
argument_list|,
operator|new
name|CompilerSettings
argument_list|()
argument_list|)
decl_stmt|;
comment|// The important thing is that this contains the opcode for returning void
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|" RETURN"
argument_list|)
argument_list|)
expr_stmt|;
comment|// We shouldn't contain any weird "default to null" logic
name|assertThat
argument_list|(
name|debug
argument_list|,
name|not
argument_list|(
name|containsString
argument_list|(
literal|"ACONST_NULL"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|ReturnsPrimitiveBoolean
specifier|public
interface|interface
name|ReturnsPrimitiveBoolean
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{}
decl_stmt|;
DECL|method|execute
name|boolean
name|execute
parameter_list|()
function_decl|;
block|}
DECL|method|testReturnsPrimitiveBoolean
specifier|public
name|void
name|testReturnsPrimitiveBoolean
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|ReturnsPrimitiveBoolean
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"true"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|false
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"false"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"Boolean.TRUE"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|false
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"Boolean.FALSE"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = true; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = Boolean.TRUE; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|true
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"true || false"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|debug
init|=
name|Debugger
operator|.
name|toString
argument_list|(
name|ReturnsPrimitiveBoolean
operator|.
name|class
argument_list|,
literal|"false"
argument_list|,
operator|new
name|CompilerSettings
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"ICONST_0"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The important thing here is that we have the bytecode for returning an integer instead of an object. booleans are integers.
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"IRETURN"
argument_list|)
argument_list|)
expr_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1L"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Cannot cast from [long] to [boolean]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1f"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Cannot cast from [float] to [boolean]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Cannot cast from [double] to [boolean]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = 1L; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = 1.1f; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = 1.1d; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|false
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveBoolean
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"int i = 0"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|ReturnsPrimitiveInt
specifier|public
interface|interface
name|ReturnsPrimitiveInt
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{}
decl_stmt|;
DECL|method|execute
name|int
name|execute
parameter_list|()
function_decl|;
block|}
DECL|method|testReturnsPrimitiveInt
specifier|public
name|void
name|testReturnsPrimitiveInt
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|ReturnsPrimitiveInt
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"(int) 1L"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"(int) 1.1d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"(int) 1.1f"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"Integer.valueOf(1)"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = 1; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = Integer.valueOf(1); i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|2
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1 + 1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|debug
init|=
name|Debugger
operator|.
name|toString
argument_list|(
name|ReturnsPrimitiveInt
operator|.
name|class
argument_list|,
literal|"1"
argument_list|,
operator|new
name|CompilerSettings
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"ICONST_1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The important thing here is that we have the bytecode for returning an integer instead of an object
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"IRETURN"
argument_list|)
argument_list|)
expr_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1L"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Cannot cast from [long] to [int]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1f"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Cannot cast from [float] to [int]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|"Cannot cast from [double] to [int]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = 1L; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = 1.1f; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def i = 1.1d; i"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveInt
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"int i = 0"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|ReturnsPrimitiveFloat
specifier|public
interface|interface
name|ReturnsPrimitiveFloat
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{}
decl_stmt|;
DECL|method|execute
name|float
name|execute
parameter_list|()
function_decl|;
block|}
DECL|method|testReturnsPrimitiveFloat
specifier|public
name|void
name|testReturnsPrimitiveFloat
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|ReturnsPrimitiveFloat
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1f"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"(float) 1.1d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = 1.1f; d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = Float.valueOf(1.1f); d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1f
operator|+
literal|6.7f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1f + 6.7f"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Cannot cast from [double] to [float]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = 1.1d; d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|e
operator|=
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = Double.valueOf(1.1); d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|debug
init|=
name|Debugger
operator|.
name|toString
argument_list|(
name|ReturnsPrimitiveFloat
operator|.
name|class
argument_list|,
literal|"1f"
argument_list|,
operator|new
name|CompilerSettings
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"FCONST_1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The important thing here is that we have the bytecode for returning a float instead of an object
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"FRETURN"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0.0f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveFloat
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"int i = 0"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|interface|ReturnsPrimitiveDouble
specifier|public
interface|interface
name|ReturnsPrimitiveDouble
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{}
decl_stmt|;
DECL|method|execute
name|double
name|execute
parameter_list|()
function_decl|;
block|}
DECL|method|testReturnsPrimitiveDouble
specifier|public
name|void
name|testReturnsPrimitiveDouble
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|ReturnsPrimitiveDouble
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|1.0
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.0
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1L"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|double
operator|)
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1f"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"Double.valueOf(1.1)"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|double
operator|)
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"Float.valueOf(1.1f)"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.0
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = 1; d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.0
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = 1L; d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = 1.1d; d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|double
operator|)
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = 1.1f; d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = Double.valueOf(1.1); d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|double
operator|)
literal|1.1f
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"def d = Float.valueOf(1.1f); d"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|1.1
operator|+
literal|6.7
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1.1 + 6.7"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|String
name|debug
init|=
name|Debugger
operator|.
name|toString
argument_list|(
name|ReturnsPrimitiveDouble
operator|.
name|class
argument_list|,
literal|"1"
argument_list|,
operator|new
name|CompilerSettings
argument_list|()
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"DCONST_1"
argument_list|)
argument_list|)
expr_stmt|;
comment|// The important thing here is that we have the bytecode for returning a double instead of an object
name|assertThat
argument_list|(
name|debug
argument_list|,
name|containsString
argument_list|(
literal|"DRETURN"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|0.0
argument_list|,
operator|(
operator|(
name|ReturnsPrimitiveDouble
operator|)
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"int i = 0"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
operator|)
operator|.
name|execute
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|interface|NoArgumentsConstant
specifier|public
interface|interface
name|NoArgumentsConstant
block|{
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testNoArgumentsConstant
specifier|public
name|void
name|testNoArgumentsConstant
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|NoArgumentsConstant
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|startsWith
argument_list|(
literal|"Painless needs a constant [String[] ARGUMENTS] on all interfaces it implements with the "
operator|+
literal|"names of the method arguments but ["
operator|+
name|NoArgumentsConstant
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"] doesn't have one."
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|WrongArgumentsConstant
specifier|public
interface|interface
name|WrongArgumentsConstant
block|{
DECL|field|ARGUMENTS
name|boolean
index|[]
name|ARGUMENTS
init|=
operator|new
name|boolean
index|[]
block|{
literal|false
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testWrongArgumentsConstant
specifier|public
name|void
name|testWrongArgumentsConstant
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|WrongArgumentsConstant
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|startsWith
argument_list|(
literal|"Painless needs a constant [String[] ARGUMENTS] on all interfaces it implements with the "
operator|+
literal|"names of the method arguments but ["
operator|+
name|WrongArgumentsConstant
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"] doesn't have one."
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|WrongLengthOfArgumentConstant
specifier|public
interface|interface
name|WrongLengthOfArgumentConstant
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"bar"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testWrongLengthOfArgumentConstant
specifier|public
name|void
name|testWrongLengthOfArgumentConstant
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|WrongLengthOfArgumentConstant
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|startsWith
argument_list|(
literal|"["
operator|+
name|WrongLengthOfArgumentConstant
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"#ARGUMENTS] has length [2] but ["
operator|+
name|WrongLengthOfArgumentConstant
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"#execute] takes [1] argument."
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|interface|UnknownArgType
specifier|public
interface|interface
name|UnknownArgType
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"foo"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|UnknownArgType
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testUnknownArgType
specifier|public
name|void
name|testUnknownArgType
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|UnknownArgType
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"[foo] is of unknown type ["
operator|+
name|UnknownArgType
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|". Painless interfaces can only accept arguments "
operator|+
literal|"that are of whitelisted types."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|UnknownReturnType
specifier|public
interface|interface
name|UnknownReturnType
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"foo"
block|}
decl_stmt|;
DECL|method|execute
name|UnknownReturnType
name|execute
parameter_list|(
name|String
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testUnknownReturnType
specifier|public
name|void
name|testUnknownReturnType
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|UnknownReturnType
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Painless can only implement execute methods returning a whitelisted type but ["
operator|+
name|UnknownReturnType
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"#execute] returns ["
operator|+
name|UnknownReturnType
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"] which isn't whitelisted."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|UnknownArgTypeInArray
specifier|public
interface|interface
name|UnknownArgTypeInArray
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"foo"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|UnknownArgTypeInArray
index|[]
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testUnknownArgTypeInArray
specifier|public
name|void
name|testUnknownArgTypeInArray
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|UnknownArgTypeInArray
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"1"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"[foo] is of unknown type ["
operator|+
name|UnknownArgTypeInArray
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|". Painless interfaces can only accept "
operator|+
literal|"arguments that are of whitelisted types."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|TwoExecuteMethods
specifier|public
interface|interface
name|TwoExecuteMethods
block|{
DECL|method|execute
name|Object
name|execute
parameter_list|()
function_decl|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|boolean
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testTwoExecuteMethods
specifier|public
name|void
name|testTwoExecuteMethods
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|TwoExecuteMethods
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"null"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Painless can only implement interfaces that have a single method named [execute] but ["
operator|+
name|TwoExecuteMethods
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"] has more than one."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|BadMethod
specifier|public
interface|interface
name|BadMethod
block|{
DECL|method|something
name|Object
name|something
parameter_list|()
function_decl|;
block|}
DECL|method|testBadMethod
specifier|public
name|void
name|testBadMethod
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|BadMethod
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"null"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Painless can only implement methods named [execute] and [uses$argName] but ["
operator|+
name|BadMethod
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"] contains a method named [something]"
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|BadUsesReturn
specifier|public
interface|interface
name|BadUsesReturn
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"foo"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
name|foo
parameter_list|)
function_decl|;
DECL|method|uses$foo
name|Object
name|uses$foo
parameter_list|()
function_decl|;
block|}
DECL|method|testBadUsesReturn
specifier|public
name|void
name|testBadUsesReturn
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|BadUsesReturn
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"null"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Painless can only implement uses$ methods that return boolean but ["
operator|+
name|BadUsesReturn
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"#uses$foo] returns [java.lang.Object]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|BadUsesParameter
specifier|public
interface|interface
name|BadUsesParameter
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"bar"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
name|foo
parameter_list|,
name|String
name|bar
parameter_list|)
function_decl|;
DECL|method|uses$bar
name|boolean
name|uses$bar
parameter_list|(
name|boolean
name|foo
parameter_list|)
function_decl|;
block|}
DECL|method|testBadUsesParameter
specifier|public
name|void
name|testBadUsesParameter
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|BadUsesParameter
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"null"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Painless can only implement uses$ methods that do not take parameters but ["
operator|+
name|BadUsesParameter
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"#uses$bar] does."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|interface|BadUsesName
specifier|public
interface|interface
name|BadUsesName
block|{
DECL|field|ARGUMENTS
name|String
index|[]
name|ARGUMENTS
init|=
operator|new
name|String
index|[]
block|{
literal|"foo"
block|,
literal|"bar"
block|}
decl_stmt|;
DECL|method|execute
name|Object
name|execute
parameter_list|(
name|String
name|foo
parameter_list|,
name|String
name|bar
parameter_list|)
function_decl|;
DECL|method|uses$baz
name|boolean
name|uses$baz
parameter_list|()
function_decl|;
block|}
DECL|method|testBadUsesName
specifier|public
name|void
name|testBadUsesName
parameter_list|()
block|{
name|Compiler
name|compiler
init|=
operator|new
name|Compiler
argument_list|(
name|BadUsesName
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|BUILTINS
argument_list|)
decl_stmt|;
name|Exception
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IllegalArgumentException
operator|.
name|class
argument_list|,
literal|false
argument_list|,
parameter_list|()
lambda|->
name|scriptEngine
operator|.
name|compile
argument_list|(
name|compiler
argument_list|,
literal|null
argument_list|,
literal|"null"
argument_list|,
name|emptyMap
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|assertEquals
argument_list|(
literal|"Painless can only implement uses$ methods that match a parameter name but ["
operator|+
name|BadUsesName
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"#uses$baz] doesn't match any of [foo, bar]."
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

