begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_comment
comment|/** Tests for explicit casts */
end_comment

begin_class
DECL|class|CastTests
specifier|public
class|class
name|CastTests
extends|extends
name|ScriptTestCase
block|{
comment|/**      * Unary operator with explicit cast      */
DECL|method|testUnaryOperator
specifier|public
name|void
name|testUnaryOperator
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (byte) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (short) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (char) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (int) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5F
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (float) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5L
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (long) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5D
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (double) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary operators with explicit cast      */
DECL|method|testBinaryOperator
specifier|public
name|void
name|testBinaryOperator
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (byte) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (short) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (char) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (int) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6F
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (float) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6L
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (long) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6D
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (double) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary compound assignment with explicit cast      */
DECL|method|testBinaryCompoundAssignment
specifier|public
name|void
name|testBinaryCompoundAssignment
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (byte) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (short) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (char) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (int) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6F
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (float) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6L
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (long) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6D
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (double) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary compound prefix with explicit cast      */
DECL|method|testBinaryPrefix
specifier|public
name|void
name|testBinaryPrefix
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (byte) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (short) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (char) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (int) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6F
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (float) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6L
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (long) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6D
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (double) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary compound postifx with explicit cast      */
DECL|method|testBinaryPostfix
specifier|public
name|void
name|testBinaryPostfix
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (byte) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (short) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (char) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (int) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5F
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (float) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5L
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (long) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5D
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (double) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shift operators with explicit cast      */
DECL|method|testShiftOperator
specifier|public
name|void
name|testShiftOperator
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (byte) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (short) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (char) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (int) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10F
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (float) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10L
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (long) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10D
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (double) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shift compound assignment with explicit cast      */
DECL|method|testShiftCompoundAssignment
specifier|public
name|void
name|testShiftCompoundAssignment
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (byte) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (short) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (char) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (int) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10F
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (float) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10L
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (long) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10D
argument_list|,
name|exec
argument_list|(
literal|"long x = 5L; return (double) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test that without a cast, we fail when conversions would narrow.      */
DECL|method|testIllegalConversions
specifier|public
name|void
name|testIllegalConversions
parameter_list|()
block|{
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"long x = 5L; int y = +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"long x = 5L; int y = (x + x); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"boolean x = true; int y = +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"boolean x = true; int y = (x ^ false); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"long x = 5L; boolean y = +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"long x = 5L; boolean y = (x + x); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test that even with a cast, some things aren't allowed.      */
DECL|method|testIllegalExplicitConversions
specifier|public
name|void
name|testIllegalExplicitConversions
parameter_list|()
block|{
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"boolean x = true; int y = (int) +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"boolean x = true; int y = (int) (x ^ false); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"long x = 5L; boolean y = (boolean) +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"long x = 5L; boolean y = (boolean) (x + x); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Currently these do not adopt the return value, we issue a separate cast!      */
DECL|method|testMethodCallDef
specifier|public
name|void
name|testMethodCallDef
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5; return (int)x.longValue();"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Currently these do not adopt the argument value, we issue a separate cast!      */
DECL|method|testArgumentsDef
specifier|public
name|void
name|testArgumentsDef
parameter_list|()
block|{
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (+(int)x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5; def y = 1L; return x + (int)y"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|'b'
argument_list|,
name|exec
argument_list|(
literal|"def x = 'abcdeg'; def y = 1L; x.charAt((int)y)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Unary operators adopt the return value      */
DECL|method|testUnaryOperatorDef
specifier|public
name|void
name|testUnaryOperatorDef
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (byte) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (short) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (char) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (int) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5F
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (float) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5L
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (long) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5D
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (double) (+x);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary operators adopt the return value      */
DECL|method|testBinaryOperatorDef
specifier|public
name|void
name|testBinaryOperatorDef
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (byte) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (short) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (char) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (int) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6F
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (float) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6L
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (long) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6D
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (double) (x + 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary operators don't yet adopt the return value with compound assignment      */
DECL|method|testBinaryCompoundAssignmentDef
specifier|public
name|void
name|testBinaryCompoundAssignmentDef
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (byte) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (short) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (char) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (int) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6F
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (float) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6L
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (long) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6D
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (double) (x += 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary operators don't yet adopt the return value with compound assignment      */
DECL|method|testBinaryCompoundAssignmentPrefix
specifier|public
name|void
name|testBinaryCompoundAssignmentPrefix
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (byte) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (short) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (char) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (int) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6F
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (float) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6L
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (long) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|6D
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (double) (++x);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Binary operators don't yet adopt the return value with compound assignment      */
DECL|method|testBinaryCompoundAssignmentPostfix
specifier|public
name|void
name|testBinaryCompoundAssignmentPostfix
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (byte) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (short) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (char) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (int) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5F
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (float) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5L
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (long) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|5D
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (double) (x++);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shift operators adopt the return value      */
DECL|method|testShiftOperatorDef
specifier|public
name|void
name|testShiftOperatorDef
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (byte) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (short) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (char) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (int) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10F
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (float) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10L
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (long) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10D
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (double) (x<< 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Shift operators don't yet adopt the return value with compound assignment      */
DECL|method|testShiftCompoundAssignmentDef
specifier|public
name|void
name|testShiftCompoundAssignmentDef
parameter_list|()
block|{
name|assertEquals
argument_list|(
operator|(
name|byte
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (byte) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|short
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (short) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
operator|(
name|char
operator|)
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (char) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (int) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10F
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (float) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10L
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (long) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
literal|10D
argument_list|,
name|exec
argument_list|(
literal|"def x = 5L; return (double) (x<<= 1);"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test that without a cast, we fail when conversions would narrow.      */
DECL|method|testIllegalConversionsDef
specifier|public
name|void
name|testIllegalConversionsDef
parameter_list|()
block|{
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = 5L; int y = +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = 5L; int y = (x + x); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = true; int y = +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = true; int y = (x ^ false); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = 5L; boolean y = +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = 5L; boolean y = (x + x); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**      * Test that even with a cast, some things aren't allowed.      * (stuff that methodhandles explicitCastArguments would otherwise allow)      */
DECL|method|testIllegalExplicitConversionsDef
specifier|public
name|void
name|testIllegalExplicitConversionsDef
parameter_list|()
block|{
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = true; int y = (int) +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = true; int y = (int) (x ^ false); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = 5L; boolean y = (boolean) +x; return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
name|expectScriptThrows
argument_list|(
name|ClassCastException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
block|{
name|exec
argument_list|(
literal|"def x = 5L; boolean y = (boolean) (x + x); return y"
argument_list|)
expr_stmt|;
block|}
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

