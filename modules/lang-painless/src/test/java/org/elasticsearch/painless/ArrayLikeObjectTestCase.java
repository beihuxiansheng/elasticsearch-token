begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|hamcrest
operator|.
name|Matcher
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|singletonMap
import|;
end_import

begin_comment
comment|/**  * Superclass for testing array-like objects (arrays and lists).  */
end_comment

begin_class
DECL|class|ArrayLikeObjectTestCase
specifier|public
specifier|abstract
class|class
name|ArrayLikeObjectTestCase
extends|extends
name|ScriptTestCase
block|{
comment|/**      * Build the string for declaring the variable holding the array-like-object to test. So {@code int[]} for arrays and {@code List} for      * lists.      */
DECL|method|declType
specifier|protected
specifier|abstract
name|String
name|declType
parameter_list|(
name|String
name|valueType
parameter_list|)
function_decl|;
comment|/**      * Build the string for calling the constructor for the array-like-object to test. So {@code new int[5]} for arrays and      * {@code [0, 0, 0, 0, 0]} or {@code [null, null, null, null, null]} for lists.      */
DECL|method|valueCtorCall
specifier|protected
specifier|abstract
name|String
name|valueCtorCall
parameter_list|(
name|String
name|valueType
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
comment|/**      * The type of the exception thrown by out of bounds accesses;      */
DECL|method|outOfBoundsExceptionMatcher
specifier|protected
specifier|abstract
name|Matcher
argument_list|<
name|?
super|super
name|IndexOutOfBoundsException
argument_list|>
name|outOfBoundsExceptionMatcher
parameter_list|(
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
DECL|method|arrayLoadStoreTestCase
specifier|private
name|void
name|arrayLoadStoreTestCase
parameter_list|(
name|boolean
name|declareAsDef
parameter_list|,
name|String
name|valueType
parameter_list|,
name|Object
name|val
parameter_list|,
annotation|@
name|Nullable
name|Number
name|valPlusOne
parameter_list|)
block|{
name|String
name|declType
init|=
name|declareAsDef
condition|?
literal|"def"
else|:
name|declType
argument_list|(
name|valueType
argument_list|)
decl_stmt|;
name|String
name|valueCtorCall
init|=
name|valueCtorCall
argument_list|(
name|valueType
argument_list|,
literal|5
argument_list|)
decl_stmt|;
name|String
name|decl
init|=
name|declType
operator|+
literal|" x = "
operator|+
name|valueCtorCall
decl_stmt|;
name|assertEquals
argument_list|(
literal|5
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; return x.length"
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|val
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[ 0] = params.val; return x[ 0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|val
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[ 0] = params.val; return x[-5];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|val
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[-5] = params.val; return x[-5];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
literal|6
argument_list|,
name|decl
operator|+
literal|"; return x[ 6]"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
operator|-
literal|1
argument_list|,
name|decl
operator|+
literal|"; return x[-6]"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
literal|6
argument_list|,
name|decl
operator|+
literal|"; x[ 6] = params.val; return 0"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
operator|-
literal|1
argument_list|,
name|decl
operator|+
literal|"; x[-6] = params.val; return 0"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|valPlusOne
operator|!=
literal|null
condition|)
block|{
name|assertEquals
argument_list|(
name|val
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[ 0] = x[ 0]++; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|val
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[ 0] = x[-5]++; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valPlusOne
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[ 0] = ++x[ 0]; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valPlusOne
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[ 0] = ++x[-5]; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valPlusOne
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[ 0]++        ; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valPlusOne
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[-5]++        ; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valPlusOne
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[ 0] += 1     ; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|assertEquals
argument_list|(
name|valPlusOne
argument_list|,
name|exec
argument_list|(
name|decl
operator|+
literal|"; x[0] = params.val; x[-5] += 1     ; return x[0];"
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
literal|6
argument_list|,
name|decl
operator|+
literal|"; return x[ 6]++"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
operator|-
literal|1
argument_list|,
name|decl
operator|+
literal|"; return x[-6]++"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
literal|6
argument_list|,
name|decl
operator|+
literal|"; return ++x[ 6]"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
operator|-
literal|1
argument_list|,
name|decl
operator|+
literal|"; return ++x[-6]"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
literal|6
argument_list|,
name|decl
operator|+
literal|"; x[ 6] += 1; return 0"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|expectOutOfBounds
argument_list|(
operator|-
literal|1
argument_list|,
name|decl
operator|+
literal|"; x[-6] += 1; return 0"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|expectOutOfBounds
specifier|private
name|void
name|expectOutOfBounds
parameter_list|(
name|int
name|index
parameter_list|,
name|String
name|script
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
name|IndexOutOfBoundsException
name|e
init|=
name|expectScriptThrows
argument_list|(
name|IndexOutOfBoundsException
operator|.
name|class
argument_list|,
parameter_list|()
lambda|->
name|exec
argument_list|(
name|script
argument_list|,
name|singletonMap
argument_list|(
literal|"val"
argument_list|,
name|val
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
decl_stmt|;
try|try
block|{
name|assertThat
argument_list|(
name|e
argument_list|,
name|outOfBoundsExceptionMatcher
argument_list|(
name|index
argument_list|,
literal|5
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|AssertionError
name|ae
parameter_list|)
block|{
name|ae
operator|.
name|addSuppressed
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// Mark the exception we are testing as suppressed so we get its stack trace. If it has one :(
throw|throw
name|ae
throw|;
block|}
block|}
DECL|method|testInts
specifier|public
name|void
name|testInts
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|false
argument_list|,
literal|"int"
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
DECL|method|testIntsInDef
specifier|public
name|void
name|testIntsInDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"int"
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
DECL|method|testLongs
specifier|public
name|void
name|testLongs
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|false
argument_list|,
literal|"long"
argument_list|,
literal|5L
argument_list|,
literal|6L
argument_list|)
expr_stmt|;
block|}
DECL|method|testLongsInDef
specifier|public
name|void
name|testLongsInDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"long"
argument_list|,
literal|5L
argument_list|,
literal|6L
argument_list|)
expr_stmt|;
block|}
DECL|method|testShorts
specifier|public
name|void
name|testShorts
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|false
argument_list|,
literal|"short"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
DECL|method|testShortsInDef
specifier|public
name|void
name|testShortsInDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"short"
argument_list|,
operator|(
name|short
operator|)
literal|5
argument_list|,
operator|(
name|short
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
DECL|method|testBytes
specifier|public
name|void
name|testBytes
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|false
argument_list|,
literal|"byte"
argument_list|,
operator|(
name|byte
operator|)
literal|5
argument_list|,
operator|(
name|byte
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
DECL|method|testBytesInDef
specifier|public
name|void
name|testBytesInDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"byte"
argument_list|,
operator|(
name|byte
operator|)
literal|5
argument_list|,
operator|(
name|byte
operator|)
literal|6
argument_list|)
expr_stmt|;
block|}
DECL|method|testFloats
specifier|public
name|void
name|testFloats
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|false
argument_list|,
literal|"float"
argument_list|,
literal|5.0f
argument_list|,
literal|6.0f
argument_list|)
expr_stmt|;
block|}
DECL|method|testFloatsInDef
specifier|public
name|void
name|testFloatsInDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"float"
argument_list|,
literal|5.0f
argument_list|,
literal|6.0f
argument_list|)
expr_stmt|;
block|}
DECL|method|testDoubles
specifier|public
name|void
name|testDoubles
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|false
argument_list|,
literal|"double"
argument_list|,
literal|5.0d
argument_list|,
literal|6.0d
argument_list|)
expr_stmt|;
block|}
DECL|method|testDoublesInDef
specifier|public
name|void
name|testDoublesInDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"double"
argument_list|,
literal|5.0d
argument_list|,
literal|6.0d
argument_list|)
expr_stmt|;
block|}
DECL|method|testStrings
specifier|public
name|void
name|testStrings
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|false
argument_list|,
literal|"String"
argument_list|,
literal|"cat"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testStringsInDef
specifier|public
name|void
name|testStringsInDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"String"
argument_list|,
literal|"cat"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|testDef
specifier|public
name|void
name|testDef
parameter_list|()
block|{
name|arrayLoadStoreTestCase
argument_list|(
literal|true
argument_list|,
literal|"def"
argument_list|,
literal|5
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
end_class

end_unit

