begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|PathUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Struct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|api
operator|.
name|Augmentation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Files
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|Path
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|file
operator|.
name|StandardOpenOption
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Comparator
operator|.
name|comparing
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
operator|.
name|toList
import|;
end_import

begin_comment
comment|/**  * Generates an API reference from the method and type whitelists in {@link Definition}.  */
end_comment

begin_class
DECL|class|PainlessDocGenerator
specifier|public
class|class
name|PainlessDocGenerator
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|ESLoggerFactory
operator|.
name|getLogger
argument_list|(
name|PainlessDocGenerator
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|FIELD_NAME
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Field
argument_list|>
name|FIELD_NAME
init|=
name|comparing
argument_list|(
name|f
lambda|->
name|f
operator|.
name|name
argument_list|)
decl_stmt|;
DECL|field|METHOD_NAME
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Method
argument_list|>
name|METHOD_NAME
init|=
name|comparing
argument_list|(
name|m
lambda|->
name|m
operator|.
name|name
argument_list|)
decl_stmt|;
DECL|field|NUMBER_OF_ARGS
specifier|private
specifier|static
specifier|final
name|Comparator
argument_list|<
name|Method
argument_list|>
name|NUMBER_OF_ARGS
init|=
name|comparing
argument_list|(
name|m
lambda|->
name|m
operator|.
name|arguments
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
DECL|method|main
specifier|public
specifier|static
name|void
name|main
parameter_list|(
name|String
index|[]
name|args
parameter_list|)
throws|throws
name|IOException
block|{
name|Path
name|apiRootPath
init|=
name|PathUtils
operator|.
name|get
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|// Blow away the last execution and recreate it from scratch
name|IOUtils
operator|.
name|rm
argument_list|(
name|apiRootPath
argument_list|)
expr_stmt|;
name|Files
operator|.
name|createDirectories
argument_list|(
name|apiRootPath
argument_list|)
expr_stmt|;
name|Path
name|indexPath
init|=
name|apiRootPath
operator|.
name|resolve
argument_list|(
literal|"index.asciidoc"
argument_list|)
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Starting to write [index.asciidoc]"
argument_list|)
expr_stmt|;
try|try
init|(
name|PrintStream
name|indexStream
init|=
operator|new
name|PrintStream
argument_list|(
name|Files
operator|.
name|newOutputStream
argument_list|(
name|indexPath
argument_list|,
name|StandardOpenOption
operator|.
name|CREATE_NEW
argument_list|,
name|StandardOpenOption
operator|.
name|WRITE
argument_list|)
argument_list|,
literal|false
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
init|)
block|{
name|emitGeneratedWarning
argument_list|(
name|indexStream
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|Type
argument_list|>
name|types
init|=
name|Definition
operator|.
name|allSimpleTypes
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|comparing
argument_list|(
name|t
lambda|->
name|t
operator|.
name|name
argument_list|)
argument_list|)
operator|.
name|collect
argument_list|(
name|toList
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Type
name|type
range|:
name|types
control|)
block|{
if|if
condition|(
name|type
operator|.
name|sort
operator|.
name|primitive
condition|)
block|{
comment|// Primitives don't have methods to reference
continue|continue;
block|}
if|if
condition|(
literal|"def"
operator|.
name|equals
argument_list|(
name|type
operator|.
name|name
argument_list|)
condition|)
block|{
comment|// def is special but doesn't have any methods all of its own.
continue|continue;
block|}
name|indexStream
operator|.
name|print
argument_list|(
literal|"include::"
argument_list|)
expr_stmt|;
name|indexStream
operator|.
name|print
argument_list|(
name|type
operator|.
name|struct
operator|.
name|name
argument_list|)
expr_stmt|;
name|indexStream
operator|.
name|println
argument_list|(
literal|".asciidoc[]"
argument_list|)
expr_stmt|;
name|Path
name|typePath
init|=
name|apiRootPath
operator|.
name|resolve
argument_list|(
name|type
operator|.
name|struct
operator|.
name|name
operator|+
literal|".asciidoc"
argument_list|)
decl_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Writing [{}.asciidoc]"
argument_list|,
name|type
operator|.
name|name
argument_list|)
expr_stmt|;
try|try
init|(
name|PrintStream
name|typeStream
init|=
operator|new
name|PrintStream
argument_list|(
name|Files
operator|.
name|newOutputStream
argument_list|(
name|typePath
argument_list|,
name|StandardOpenOption
operator|.
name|CREATE_NEW
argument_list|,
name|StandardOpenOption
operator|.
name|WRITE
argument_list|)
argument_list|,
literal|false
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
init|)
block|{
name|emitGeneratedWarning
argument_list|(
name|typeStream
argument_list|)
expr_stmt|;
name|typeStream
operator|.
name|print
argument_list|(
literal|"[["
argument_list|)
expr_stmt|;
name|emitAnchor
argument_list|(
name|typeStream
argument_list|,
name|type
operator|.
name|struct
argument_list|)
expr_stmt|;
name|typeStream
operator|.
name|print
argument_list|(
literal|"]]++"
argument_list|)
expr_stmt|;
name|typeStream
operator|.
name|print
argument_list|(
name|type
operator|.
name|name
argument_list|)
expr_stmt|;
name|typeStream
operator|.
name|println
argument_list|(
literal|"++::"
argument_list|)
expr_stmt|;
name|Consumer
argument_list|<
name|Field
argument_list|>
name|documentField
init|=
name|field
lambda|->
name|PainlessDocGenerator
operator|.
name|documentField
argument_list|(
name|typeStream
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|Consumer
argument_list|<
name|Method
argument_list|>
name|documentMethod
init|=
name|method
lambda|->
name|PainlessDocGenerator
operator|.
name|documentMethod
argument_list|(
name|typeStream
argument_list|,
name|method
argument_list|)
decl_stmt|;
name|type
operator|.
name|struct
operator|.
name|staticMembers
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|FIELD_NAME
argument_list|)
operator|.
name|forEach
argument_list|(
name|documentField
argument_list|)
expr_stmt|;
name|type
operator|.
name|struct
operator|.
name|members
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|FIELD_NAME
argument_list|)
operator|.
name|forEach
argument_list|(
name|documentField
argument_list|)
expr_stmt|;
name|type
operator|.
name|struct
operator|.
name|staticMethods
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|METHOD_NAME
operator|.
name|thenComparing
argument_list|(
name|NUMBER_OF_ARGS
argument_list|)
argument_list|)
operator|.
name|forEach
argument_list|(
name|documentMethod
argument_list|)
expr_stmt|;
name|type
operator|.
name|struct
operator|.
name|constructors
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|NUMBER_OF_ARGS
argument_list|)
operator|.
name|forEach
argument_list|(
name|documentMethod
argument_list|)
expr_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Struct
argument_list|>
name|inherited
init|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
decl_stmt|;
name|type
operator|.
name|struct
operator|.
name|methods
operator|.
name|values
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|sorted
argument_list|(
name|METHOD_NAME
operator|.
name|thenComparing
argument_list|(
name|NUMBER_OF_ARGS
argument_list|)
argument_list|)
operator|.
name|forEach
argument_list|(
name|method
lambda|->
block|{
if|if
condition|(
name|method
operator|.
name|owner
operator|==
name|type
operator|.
name|struct
condition|)
block|{
name|documentMethod
argument_list|(
name|typeStream
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inherited
operator|.
name|put
argument_list|(
name|method
operator|.
name|owner
operator|.
name|name
argument_list|,
name|method
operator|.
name|owner
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
operator|==
name|inherited
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|typeStream
operator|.
name|print
argument_list|(
literal|"* Inherits methods from "
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Struct
name|inheritsFrom
range|:
name|inherited
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|typeStream
operator|.
name|print
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|typeStream
operator|.
name|print
argument_list|(
literal|"++"
argument_list|)
expr_stmt|;
name|emitStruct
argument_list|(
name|typeStream
argument_list|,
name|inheritsFrom
argument_list|)
expr_stmt|;
name|typeStream
operator|.
name|print
argument_list|(
literal|"++"
argument_list|)
expr_stmt|;
block|}
name|typeStream
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"Done writing [index.asciidoc]"
argument_list|)
expr_stmt|;
block|}
DECL|method|documentField
specifier|private
specifier|static
name|void
name|documentField
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|Field
name|field
parameter_list|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"** [["
argument_list|)
expr_stmt|;
name|emitAnchor
argument_list|(
name|stream
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"]]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Modifier
operator|.
name|isStatic
argument_list|(
name|field
operator|.
name|modifiers
argument_list|)
condition|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
block|}
name|emitType
argument_list|(
name|stream
argument_list|,
name|field
operator|.
name|type
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|String
name|javadocRoot
init|=
name|javadocRoot
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|emitJavadocLink
argument_list|(
name|stream
argument_list|,
name|javadocRoot
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|field
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|javadocRoot
operator|.
name|equals
argument_list|(
literal|"java8"
argument_list|)
condition|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
name|emitJavadocLink
argument_list|(
name|stream
argument_list|,
literal|"java9"
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"[java 9])"
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**      * Document a method.      */
DECL|method|documentMethod
specifier|private
specifier|static
name|void
name|documentMethod
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"* ++[["
argument_list|)
expr_stmt|;
name|emitAnchor
argument_list|(
name|stream
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"]]"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
operator|==
name|method
operator|.
name|augmentation
operator|&&
name|Modifier
operator|.
name|isStatic
argument_list|(
name|method
operator|.
name|modifiers
argument_list|)
condition|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"static "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|false
operator|==
name|method
operator|.
name|name
operator|.
name|equals
argument_list|(
literal|"<init>"
argument_list|)
condition|)
block|{
name|emitType
argument_list|(
name|stream
argument_list|,
name|method
operator|.
name|rtn
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|String
name|javadocRoot
init|=
name|javadocRoot
argument_list|(
name|method
argument_list|)
decl_stmt|;
name|emitJavadocLink
argument_list|(
name|stream
argument_list|,
name|javadocRoot
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|methodName
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"]("
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
for|for
control|(
name|Type
name|arg
range|:
name|method
operator|.
name|arguments
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|.
name|print
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|emitType
argument_list|(
name|stream
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|print
argument_list|(
literal|")++"
argument_list|)
expr_stmt|;
if|if
condition|(
name|javadocRoot
operator|.
name|equals
argument_list|(
literal|"java8"
argument_list|)
condition|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
name|emitJavadocLink
argument_list|(
name|stream
argument_list|,
literal|"java9"
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"[java 9])"
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
comment|/**      * Anchor text for a {@link Struct}.      */
DECL|method|emitAnchor
specifier|private
specifier|static
name|void
name|emitAnchor
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|Struct
name|struct
parameter_list|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"painless-api-reference-"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|struct
operator|.
name|name
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'-'
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Anchor text for a {@link Method}.      */
DECL|method|emitAnchor
specifier|private
specifier|static
name|void
name|emitAnchor
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
name|emitAnchor
argument_list|(
name|stream
argument_list|,
name|method
operator|.
name|owner
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|methodName
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|method
operator|.
name|arguments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Anchor text for a {@link Field}.      */
DECL|method|emitAnchor
specifier|private
specifier|static
name|void
name|emitAnchor
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|Field
name|field
parameter_list|)
block|{
name|emitAnchor
argument_list|(
name|stream
argument_list|,
name|field
operator|.
name|owner
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|field
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
DECL|method|methodName
specifier|private
specifier|static
name|String
name|methodName
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
return|return
name|method
operator|.
name|name
operator|.
name|equals
argument_list|(
literal|"<init>"
argument_list|)
condition|?
name|method
operator|.
name|owner
operator|.
name|name
else|:
name|method
operator|.
name|name
return|;
block|}
comment|/**      * Emit a {@link Type}. If the type is primitive or an array of primitives this just emits the name of the type. Otherwise this emits an      * internal link with the text.      */
DECL|method|emitType
specifier|private
specifier|static
name|void
name|emitType
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|Type
name|type
parameter_list|)
block|{
name|emitStruct
argument_list|(
name|stream
argument_list|,
name|type
operator|.
name|struct
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|type
operator|.
name|dimensions
condition|;
name|i
operator|++
control|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"[]"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Emit a {@link Struct}. If the {@linkplain Struct} is primitive or def this just emits the name of the struct. Otherwise this emits an      * internal link with the name.      */
DECL|method|emitStruct
specifier|private
specifier|static
name|void
name|emitStruct
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|Struct
name|struct
parameter_list|)
block|{
if|if
condition|(
literal|false
operator|==
name|struct
operator|.
name|clazz
operator|.
name|isPrimitive
argument_list|()
operator|&&
literal|false
operator|==
name|struct
operator|.
name|name
operator|.
name|equals
argument_list|(
literal|"def"
argument_list|)
condition|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"<<"
argument_list|)
expr_stmt|;
name|emitAnchor
argument_list|(
name|stream
argument_list|,
name|struct
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|struct
operator|.
name|name
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|">>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|.
name|print
argument_list|(
name|struct
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Emit an external link to Javadoc for a {@link Method}.      *      * @param root name of the root uri variable      */
DECL|method|emitJavadocLink
specifier|private
specifier|static
name|void
name|emitJavadocLink
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|String
name|root
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"link:{"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"-javadoc}/"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
operator|(
name|method
operator|.
name|augmentation
condition|?
name|Augmentation
operator|.
name|class
else|:
name|method
operator|.
name|owner
operator|.
name|clazz
operator|)
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|".html#"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|methodName
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"%2D"
argument_list|)
expr_stmt|;
name|boolean
name|first
init|=
literal|true
decl_stmt|;
if|if
condition|(
name|method
operator|.
name|augmentation
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|method
operator|.
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Type
name|arg
range|:
name|method
operator|.
name|arguments
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"%2D"
argument_list|)
expr_stmt|;
block|}
name|stream
operator|.
name|print
argument_list|(
name|arg
operator|.
name|struct
operator|.
name|clazz
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|.
name|dimensions
operator|>
literal|0
condition|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|":A"
argument_list|)
expr_stmt|;
block|}
block|}
name|stream
operator|.
name|print
argument_list|(
literal|"%2D"
argument_list|)
expr_stmt|;
block|}
comment|/**      * Emit an external link to Javadoc for a {@link Field}.      *      * @param root name of the root uri variable      */
DECL|method|emitJavadocLink
specifier|private
specifier|static
name|void
name|emitJavadocLink
parameter_list|(
name|PrintStream
name|stream
parameter_list|,
name|String
name|root
parameter_list|,
name|Field
name|field
parameter_list|)
block|{
name|stream
operator|.
name|print
argument_list|(
literal|"link:{"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|"-javadoc}/"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|field
operator|.
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
literal|".html#"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|print
argument_list|(
name|field
operator|.
name|javaName
argument_list|)
expr_stmt|;
block|}
comment|/**      * Pick the javadoc root for a {@link Method}.      */
DECL|method|javadocRoot
specifier|private
specifier|static
name|String
name|javadocRoot
parameter_list|(
name|Method
name|method
parameter_list|)
block|{
if|if
condition|(
name|method
operator|.
name|augmentation
condition|)
block|{
return|return
literal|"painless"
return|;
block|}
return|return
name|javadocRoot
argument_list|(
name|method
operator|.
name|owner
argument_list|)
return|;
block|}
comment|/**      * Pick the javadoc root for a {@link Field}.      */
DECL|method|javadocRoot
specifier|private
specifier|static
name|String
name|javadocRoot
parameter_list|(
name|Field
name|field
parameter_list|)
block|{
return|return
name|javadocRoot
argument_list|(
name|field
operator|.
name|owner
argument_list|)
return|;
block|}
comment|/**      * Pick the javadoc root for a {@link Struct}.      */
DECL|method|javadocRoot
specifier|private
specifier|static
name|String
name|javadocRoot
parameter_list|(
name|Struct
name|struct
parameter_list|)
block|{
name|String
name|classPackage
init|=
name|struct
operator|.
name|clazz
operator|.
name|getPackage
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|classPackage
operator|.
name|startsWith
argument_list|(
literal|"java"
argument_list|)
condition|)
block|{
return|return
literal|"java8"
return|;
block|}
if|if
condition|(
name|classPackage
operator|.
name|startsWith
argument_list|(
literal|"org.elasticsearch.painless"
argument_list|)
condition|)
block|{
return|return
literal|"painless"
return|;
block|}
if|if
condition|(
name|classPackage
operator|.
name|startsWith
argument_list|(
literal|"org.elasticsearch"
argument_list|)
condition|)
block|{
return|return
literal|"elasticsearch"
return|;
block|}
if|if
condition|(
name|classPackage
operator|.
name|startsWith
argument_list|(
literal|"org.joda.time"
argument_list|)
condition|)
block|{
return|return
literal|"joda-time"
return|;
block|}
if|if
condition|(
name|classPackage
operator|.
name|startsWith
argument_list|(
literal|"org.apache.lucene"
argument_list|)
condition|)
block|{
return|return
literal|"lucene-core"
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unrecognized packge: "
operator|+
name|classPackage
argument_list|)
throw|;
block|}
DECL|method|emitGeneratedWarning
specifier|private
specifier|static
name|void
name|emitGeneratedWarning
parameter_list|(
name|PrintStream
name|stream
parameter_list|)
block|{
name|stream
operator|.
name|println
argument_list|(
literal|"////"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|println
argument_list|(
literal|"Automatically generated by PainlessDocGenerator. Do not edit."
argument_list|)
expr_stmt|;
name|stream
operator|.
name|println
argument_list|(
literal|"Rebuild by running `gradle generatePainlessApi`."
argument_list|)
expr_stmt|;
name|stream
operator|.
name|println
argument_list|(
literal|"////"
argument_list|)
expr_stmt|;
name|stream
operator|.
name|println
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

