begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Constants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|SetOnce
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStreamReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|LineNumberReader
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|charset
operator|.
name|StandardCharsets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|time
operator|.
name|LocalDate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|PrimitiveIterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Spliterator
import|;
end_import

begin_comment
comment|/**  * The entire API for Painless.  Also used as a whitelist for checking for legal  * methods and fields during at both compile-time and runtime.  */
end_comment

begin_class
DECL|class|Definition
specifier|public
specifier|final
class|class
name|Definition
block|{
DECL|field|DEFINITION_FILES
specifier|private
specifier|static
specifier|final
name|List
argument_list|<
name|String
argument_list|>
name|DEFINITION_FILES
init|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
literal|"org.elasticsearch.txt"
argument_list|,
literal|"java.lang.txt"
argument_list|,
literal|"java.math.txt"
argument_list|,
literal|"java.text.txt"
argument_list|,
literal|"java.time.txt"
argument_list|,
literal|"java.time.chrono.txt"
argument_list|,
literal|"java.time.format.txt"
argument_list|,
literal|"java.time.temporal.txt"
argument_list|,
literal|"java.time.zone.txt"
argument_list|,
literal|"java.util.txt"
argument_list|,
literal|"java.util.function.txt"
argument_list|,
literal|"java.util.stream.txt"
argument_list|,
literal|"joda.time.txt"
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|INSTANCE
specifier|private
specifier|static
specifier|final
name|Definition
name|INSTANCE
init|=
operator|new
name|Definition
argument_list|()
decl_stmt|;
comment|/** Some native types as constants: */
DECL|field|VOID_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|VOID_TYPE
init|=
name|getType
argument_list|(
literal|"void"
argument_list|)
decl_stmt|;
DECL|field|BOOLEAN_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|BOOLEAN_TYPE
init|=
name|getType
argument_list|(
literal|"boolean"
argument_list|)
decl_stmt|;
DECL|field|BOOLEAN_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|BOOLEAN_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Boolean"
argument_list|)
decl_stmt|;
DECL|field|BYTE_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|BYTE_TYPE
init|=
name|getType
argument_list|(
literal|"byte"
argument_list|)
decl_stmt|;
DECL|field|BYTE_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|BYTE_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Byte"
argument_list|)
decl_stmt|;
DECL|field|SHORT_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|SHORT_TYPE
init|=
name|getType
argument_list|(
literal|"short"
argument_list|)
decl_stmt|;
DECL|field|SHORT_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|SHORT_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Short"
argument_list|)
decl_stmt|;
DECL|field|INT_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|INT_TYPE
init|=
name|getType
argument_list|(
literal|"int"
argument_list|)
decl_stmt|;
DECL|field|INT_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|INT_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Integer"
argument_list|)
decl_stmt|;
DECL|field|LONG_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|LONG_TYPE
init|=
name|getType
argument_list|(
literal|"long"
argument_list|)
decl_stmt|;
DECL|field|LONG_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|LONG_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Long"
argument_list|)
decl_stmt|;
DECL|field|FLOAT_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|FLOAT_TYPE
init|=
name|getType
argument_list|(
literal|"float"
argument_list|)
decl_stmt|;
DECL|field|FLOAT_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|FLOAT_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Float"
argument_list|)
decl_stmt|;
DECL|field|DOUBLE_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|DOUBLE_TYPE
init|=
name|getType
argument_list|(
literal|"double"
argument_list|)
decl_stmt|;
DECL|field|DOUBLE_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|DOUBLE_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Double"
argument_list|)
decl_stmt|;
DECL|field|CHAR_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|CHAR_TYPE
init|=
name|getType
argument_list|(
literal|"char"
argument_list|)
decl_stmt|;
DECL|field|CHAR_OBJ_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|CHAR_OBJ_TYPE
init|=
name|getType
argument_list|(
literal|"Character"
argument_list|)
decl_stmt|;
DECL|field|OBJECT_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|OBJECT_TYPE
init|=
name|getType
argument_list|(
literal|"Object"
argument_list|)
decl_stmt|;
DECL|field|DEF_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|DEF_TYPE
init|=
name|getType
argument_list|(
literal|"def"
argument_list|)
decl_stmt|;
DECL|field|STRING_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|STRING_TYPE
init|=
name|getType
argument_list|(
literal|"String"
argument_list|)
decl_stmt|;
DECL|field|EXCEPTION_TYPE
specifier|public
specifier|static
specifier|final
name|Type
name|EXCEPTION_TYPE
init|=
name|getType
argument_list|(
literal|"Exception"
argument_list|)
decl_stmt|;
DECL|enum|Sort
specifier|public
enum|enum
name|Sort
block|{
DECL|enum constant|VOID
name|VOID
argument_list|(
name|void
operator|.
name|class
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|BOOL
name|BOOL
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|BYTE
name|BYTE
argument_list|(
name|byte
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|SHORT
name|SHORT
argument_list|(
name|short
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|CHAR
name|CHAR
argument_list|(
name|char
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|INT
name|INT
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|LONG
name|LONG
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|FLOAT
name|FLOAT
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|DOUBLE
name|DOUBLE
argument_list|(
name|double
operator|.
name|class
argument_list|,
literal|2
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|VOID_OBJ
name|VOID_OBJ
argument_list|(
name|Void
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|BOOL_OBJ
name|BOOL_OBJ
argument_list|(
name|Boolean
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|BYTE_OBJ
name|BYTE_OBJ
argument_list|(
name|Byte
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|SHORT_OBJ
name|SHORT_OBJ
argument_list|(
name|Short
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|CHAR_OBJ
name|CHAR_OBJ
argument_list|(
name|Character
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|INT_OBJ
name|INT_OBJ
argument_list|(
name|Integer
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|LONG_OBJ
name|LONG_OBJ
argument_list|(
name|Long
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|FLOAT_OBJ
name|FLOAT_OBJ
argument_list|(
name|Float
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|DOUBLE_OBJ
name|DOUBLE_OBJ
argument_list|(
name|Double
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|NUMBER
name|NUMBER
argument_list|(
name|Number
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|STRING
name|STRING
argument_list|(
name|String
operator|.
name|class
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|)
block|,
DECL|enum constant|OBJECT
name|OBJECT
argument_list|(
literal|null
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|DEF
name|DEF
argument_list|(
literal|null
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|,
DECL|enum constant|ARRAY
name|ARRAY
argument_list|(
literal|null
argument_list|,
literal|1
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
block|;
DECL|field|clazz
specifier|public
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
decl_stmt|;
DECL|field|size
specifier|public
specifier|final
name|int
name|size
decl_stmt|;
DECL|field|primitive
specifier|public
specifier|final
name|boolean
name|primitive
decl_stmt|;
DECL|field|bool
specifier|public
specifier|final
name|boolean
name|bool
decl_stmt|;
DECL|field|numeric
specifier|public
specifier|final
name|boolean
name|numeric
decl_stmt|;
DECL|field|constant
specifier|public
specifier|final
name|boolean
name|constant
decl_stmt|;
DECL|method|Sort
name|Sort
parameter_list|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|boolean
name|primitive
parameter_list|,
specifier|final
name|boolean
name|bool
parameter_list|,
specifier|final
name|boolean
name|numeric
parameter_list|,
specifier|final
name|boolean
name|constant
parameter_list|)
block|{
name|this
operator|.
name|clazz
operator|=
name|clazz
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|bool
operator|=
name|bool
expr_stmt|;
name|this
operator|.
name|primitive
operator|=
name|primitive
expr_stmt|;
name|this
operator|.
name|numeric
operator|=
name|numeric
expr_stmt|;
name|this
operator|.
name|constant
operator|=
name|constant
expr_stmt|;
block|}
block|}
DECL|class|Type
specifier|public
specifier|static
specifier|final
class|class
name|Type
block|{
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|dimensions
specifier|public
specifier|final
name|int
name|dimensions
decl_stmt|;
DECL|field|struct
specifier|public
specifier|final
name|Struct
name|struct
decl_stmt|;
DECL|field|clazz
specifier|public
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
decl_stmt|;
DECL|field|type
specifier|public
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
decl_stmt|;
DECL|field|sort
specifier|public
specifier|final
name|Sort
name|sort
decl_stmt|;
DECL|method|Type
specifier|private
name|Type
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|int
name|dimensions
parameter_list|,
specifier|final
name|Struct
name|struct
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
parameter_list|,
specifier|final
name|Sort
name|sort
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|dimensions
operator|=
name|dimensions
expr_stmt|;
name|this
operator|.
name|struct
operator|=
name|struct
expr_stmt|;
name|this
operator|.
name|clazz
operator|=
name|clazz
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|sort
operator|=
name|sort
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
specifier|final
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|object
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
specifier|final
name|Type
name|type
init|=
operator|(
name|Type
operator|)
name|object
decl_stmt|;
return|return
name|this
operator|.
name|type
operator|.
name|equals
argument_list|(
name|type
operator|.
name|type
argument_list|)
operator|&&
name|struct
operator|.
name|equals
argument_list|(
name|type
operator|.
name|struct
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|result
init|=
name|struct
operator|.
name|hashCode
argument_list|()
decl_stmt|;
name|result
operator|=
literal|31
operator|*
name|result
operator|+
name|type
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|name
return|;
block|}
block|}
DECL|class|Method
specifier|public
specifier|static
class|class
name|Method
block|{
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|owner
specifier|public
specifier|final
name|Struct
name|owner
decl_stmt|;
DECL|field|rtn
specifier|public
specifier|final
name|Type
name|rtn
decl_stmt|;
DECL|field|arguments
specifier|public
specifier|final
name|List
argument_list|<
name|Type
argument_list|>
name|arguments
decl_stmt|;
DECL|field|method
specifier|public
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|method
decl_stmt|;
DECL|field|modifiers
specifier|public
specifier|final
name|int
name|modifiers
decl_stmt|;
DECL|field|handle
specifier|public
specifier|final
name|MethodHandle
name|handle
decl_stmt|;
DECL|method|Method
specifier|private
name|Method
parameter_list|(
name|String
name|name
parameter_list|,
name|Struct
name|owner
parameter_list|,
name|Type
name|rtn
parameter_list|,
name|List
argument_list|<
name|Type
argument_list|>
name|arguments
parameter_list|,
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|method
parameter_list|,
name|int
name|modifiers
parameter_list|,
name|MethodHandle
name|handle
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|this
operator|.
name|rtn
operator|=
name|rtn
expr_stmt|;
name|this
operator|.
name|arguments
operator|=
name|Collections
operator|.
name|unmodifiableList
argument_list|(
name|arguments
argument_list|)
expr_stmt|;
name|this
operator|.
name|method
operator|=
name|method
expr_stmt|;
name|this
operator|.
name|modifiers
operator|=
name|modifiers
expr_stmt|;
name|this
operator|.
name|handle
operator|=
name|handle
expr_stmt|;
block|}
block|}
DECL|class|Field
specifier|public
specifier|static
specifier|final
class|class
name|Field
block|{
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|owner
specifier|public
specifier|final
name|Struct
name|owner
decl_stmt|;
DECL|field|type
specifier|public
specifier|final
name|Type
name|type
decl_stmt|;
DECL|field|javaName
specifier|public
specifier|final
name|String
name|javaName
decl_stmt|;
DECL|field|modifiers
specifier|public
specifier|final
name|int
name|modifiers
decl_stmt|;
DECL|field|getter
specifier|private
specifier|final
name|MethodHandle
name|getter
decl_stmt|;
DECL|field|setter
specifier|private
specifier|final
name|MethodHandle
name|setter
decl_stmt|;
DECL|method|Field
specifier|private
name|Field
parameter_list|(
name|String
name|name
parameter_list|,
name|String
name|javaName
parameter_list|,
name|Struct
name|owner
parameter_list|,
name|Type
name|type
parameter_list|,
name|int
name|modifiers
parameter_list|,
name|MethodHandle
name|getter
parameter_list|,
name|MethodHandle
name|setter
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|javaName
operator|=
name|javaName
expr_stmt|;
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|this
operator|.
name|modifiers
operator|=
name|modifiers
expr_stmt|;
name|this
operator|.
name|getter
operator|=
name|getter
expr_stmt|;
name|this
operator|.
name|setter
operator|=
name|setter
expr_stmt|;
block|}
block|}
comment|// TODO: instead of hashing on this, we could have a 'next' pointer in Method itself, but it would make code more complex
comment|// please do *NOT* under any circumstances change this to be the crappy Tuple from elasticsearch!
comment|/**      * Key for looking up a method.      *<p>      * Methods are keyed on both name and arity, and can be overloaded once per arity.      * This allows signatures such as {@code String.indexOf(String) vs String.indexOf(String, int)}.      *<p>      * It is less flexible than full signature overloading where types can differ too, but      * better than just the name, and overloading types adds complexity to users, too.      */
DECL|class|MethodKey
specifier|public
specifier|static
specifier|final
class|class
name|MethodKey
block|{
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|arity
specifier|public
specifier|final
name|int
name|arity
decl_stmt|;
comment|/**          * Create a new lookup key          * @param name name of the method          * @param arity number of parameters          */
DECL|method|MethodKey
specifier|public
name|MethodKey
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|arity
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|this
operator|.
name|arity
operator|=
name|arity
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|int
name|prime
init|=
literal|31
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|arity
expr_stmt|;
name|result
operator|=
name|prime
operator|*
name|result
operator|+
name|name
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|obj
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|getClass
argument_list|()
operator|!=
name|obj
operator|.
name|getClass
argument_list|()
condition|)
return|return
literal|false
return|;
name|MethodKey
name|other
init|=
operator|(
name|MethodKey
operator|)
name|obj
decl_stmt|;
if|if
condition|(
name|arity
operator|!=
name|other
operator|.
name|arity
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|name
operator|.
name|equals
argument_list|(
name|other
operator|.
name|name
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|arity
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
DECL|class|Struct
specifier|public
specifier|static
specifier|final
class|class
name|Struct
block|{
DECL|field|name
specifier|public
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|clazz
specifier|public
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
decl_stmt|;
DECL|field|type
specifier|public
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
decl_stmt|;
DECL|field|constructors
specifier|public
specifier|final
name|Map
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|constructors
decl_stmt|;
DECL|field|staticMethods
specifier|public
specifier|final
name|Map
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|staticMethods
decl_stmt|;
DECL|field|methods
specifier|public
specifier|final
name|Map
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|methods
decl_stmt|;
DECL|field|staticMembers
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Field
argument_list|>
name|staticMembers
decl_stmt|;
DECL|field|members
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Field
argument_list|>
name|members
decl_stmt|;
DECL|field|functionalMethod
specifier|private
specifier|final
name|SetOnce
argument_list|<
name|Method
argument_list|>
name|functionalMethod
decl_stmt|;
DECL|method|Struct
specifier|private
name|Struct
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|this
operator|.
name|clazz
operator|=
name|clazz
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|constructors
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|staticMethods
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|methods
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|staticMembers
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|members
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|functionalMethod
operator|=
operator|new
name|SetOnce
argument_list|<
name|Method
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|method|Struct
specifier|private
name|Struct
parameter_list|(
specifier|final
name|Struct
name|struct
parameter_list|)
block|{
name|name
operator|=
name|struct
operator|.
name|name
expr_stmt|;
name|clazz
operator|=
name|struct
operator|.
name|clazz
expr_stmt|;
name|type
operator|=
name|struct
operator|.
name|type
expr_stmt|;
name|constructors
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|struct
operator|.
name|constructors
argument_list|)
expr_stmt|;
name|staticMethods
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|struct
operator|.
name|staticMethods
argument_list|)
expr_stmt|;
name|methods
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|struct
operator|.
name|methods
argument_list|)
expr_stmt|;
name|staticMembers
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|struct
operator|.
name|staticMembers
argument_list|)
expr_stmt|;
name|members
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|struct
operator|.
name|members
argument_list|)
expr_stmt|;
name|functionalMethod
operator|=
name|struct
operator|.
name|functionalMethod
expr_stmt|;
block|}
DECL|method|freeze
specifier|private
name|Struct
name|freeze
parameter_list|()
block|{
return|return
operator|new
name|Struct
argument_list|(
name|this
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|object
parameter_list|)
block|{
if|if
condition|(
name|this
operator|==
name|object
condition|)
block|{
return|return
literal|true
return|;
block|}
if|if
condition|(
name|object
operator|==
literal|null
operator|||
name|getClass
argument_list|()
operator|!=
name|object
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|Struct
name|struct
init|=
operator|(
name|Struct
operator|)
name|object
decl_stmt|;
return|return
name|name
operator|.
name|equals
argument_list|(
name|struct
operator|.
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|name
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**           * If this class is a functional interface according to JLS, returns its method.          * Otherwise returns null.          */
DECL|method|getFunctionalMethod
specifier|public
name|Method
name|getFunctionalMethod
parameter_list|()
block|{
return|return
name|functionalMethod
operator|.
name|get
argument_list|()
return|;
block|}
block|}
DECL|class|Cast
specifier|public
specifier|static
class|class
name|Cast
block|{
DECL|field|from
specifier|public
specifier|final
name|Type
name|from
decl_stmt|;
DECL|field|to
specifier|public
specifier|final
name|Type
name|to
decl_stmt|;
DECL|field|explicit
specifier|public
specifier|final
name|boolean
name|explicit
decl_stmt|;
DECL|field|unboxFrom
specifier|public
specifier|final
name|boolean
name|unboxFrom
decl_stmt|;
DECL|field|unboxTo
specifier|public
specifier|final
name|boolean
name|unboxTo
decl_stmt|;
DECL|field|boxFrom
specifier|public
specifier|final
name|boolean
name|boxFrom
decl_stmt|;
DECL|field|boxTo
specifier|public
specifier|final
name|boolean
name|boxTo
decl_stmt|;
DECL|method|Cast
specifier|public
name|Cast
parameter_list|(
specifier|final
name|Type
name|from
parameter_list|,
specifier|final
name|Type
name|to
parameter_list|,
specifier|final
name|boolean
name|explicit
parameter_list|)
block|{
name|this
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|this
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|this
operator|.
name|explicit
operator|=
name|explicit
expr_stmt|;
name|this
operator|.
name|unboxFrom
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|unboxTo
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|boxFrom
operator|=
literal|false
expr_stmt|;
name|this
operator|.
name|boxTo
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|Cast
specifier|public
name|Cast
parameter_list|(
specifier|final
name|Type
name|from
parameter_list|,
specifier|final
name|Type
name|to
parameter_list|,
specifier|final
name|boolean
name|explicit
parameter_list|,
specifier|final
name|boolean
name|unboxFrom
parameter_list|,
specifier|final
name|boolean
name|unboxTo
parameter_list|,
specifier|final
name|boolean
name|boxFrom
parameter_list|,
specifier|final
name|boolean
name|boxTo
parameter_list|)
block|{
name|this
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|this
operator|.
name|to
operator|=
name|to
expr_stmt|;
name|this
operator|.
name|explicit
operator|=
name|explicit
expr_stmt|;
name|this
operator|.
name|unboxFrom
operator|=
name|unboxFrom
expr_stmt|;
name|this
operator|.
name|unboxTo
operator|=
name|unboxTo
expr_stmt|;
name|this
operator|.
name|boxFrom
operator|=
name|boxFrom
expr_stmt|;
name|this
operator|.
name|boxTo
operator|=
name|boxTo
expr_stmt|;
block|}
block|}
DECL|class|RuntimeClass
specifier|public
specifier|static
specifier|final
class|class
name|RuntimeClass
block|{
DECL|field|methods
specifier|public
specifier|final
name|Map
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|methods
decl_stmt|;
DECL|field|getters
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
name|getters
decl_stmt|;
DECL|field|setters
specifier|public
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
name|setters
decl_stmt|;
DECL|method|RuntimeClass
specifier|private
name|RuntimeClass
parameter_list|(
specifier|final
name|Map
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|methods
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
name|getters
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
name|setters
parameter_list|)
block|{
name|this
operator|.
name|methods
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|methods
argument_list|)
expr_stmt|;
name|this
operator|.
name|getters
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|getters
argument_list|)
expr_stmt|;
name|this
operator|.
name|setters
operator|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|setters
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Returns whether or not a non-array type exists. */
DECL|method|isSimpleType
specifier|public
specifier|static
name|boolean
name|isSimpleType
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|INSTANCE
operator|.
name|structsMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/** Returns whether or not a type exists without an exception. */
DECL|method|isType
specifier|public
specifier|static
name|boolean
name|isType
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
try|try
block|{
name|INSTANCE
operator|.
name|getTypeInternal
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|exception
parameter_list|)
block|{
return|return
literal|false
return|;
block|}
block|}
comment|/** Gets the type given by its name */
DECL|method|getType
specifier|public
specifier|static
name|Type
name|getType
parameter_list|(
specifier|final
name|String
name|name
parameter_list|)
block|{
return|return
name|INSTANCE
operator|.
name|getTypeInternal
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/** Creates an array type from the given Struct. */
DECL|method|getType
specifier|public
specifier|static
name|Type
name|getType
parameter_list|(
specifier|final
name|Struct
name|struct
parameter_list|,
specifier|final
name|int
name|dimensions
parameter_list|)
block|{
return|return
name|INSTANCE
operator|.
name|getTypeInternal
argument_list|(
name|struct
argument_list|,
name|dimensions
argument_list|)
return|;
block|}
DECL|method|getRuntimeClass
specifier|public
specifier|static
name|RuntimeClass
name|getRuntimeClass
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
name|INSTANCE
operator|.
name|runtimeMap
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
return|;
block|}
comment|// INTERNAL IMPLEMENTATION:
DECL|field|runtimeMap
specifier|private
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|RuntimeClass
argument_list|>
name|runtimeMap
decl_stmt|;
DECL|field|structsMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Struct
argument_list|>
name|structsMap
decl_stmt|;
DECL|field|simpleTypesMap
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Type
argument_list|>
name|simpleTypesMap
decl_stmt|;
DECL|method|Definition
specifier|private
name|Definition
parameter_list|()
block|{
name|structsMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|simpleTypesMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
name|runtimeMap
operator|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
expr_stmt|;
comment|// parse the classes and return hierarchy (map of class name -> superclasses/interfaces)
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|hierarchy
init|=
name|addStructs
argument_list|()
decl_stmt|;
comment|// add every method for each class
name|addElements
argument_list|()
expr_stmt|;
comment|// apply hierarchy: this means e.g. copying Object's methods into String (thats how subclasses work)
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|clazz
range|:
name|hierarchy
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|copyStruct
argument_list|(
name|clazz
operator|.
name|getKey
argument_list|()
argument_list|,
name|clazz
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// if someone declares an interface type, its still an Object
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Struct
argument_list|>
name|clazz
range|:
name|structsMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|clazz
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|javaPeer
init|=
name|clazz
operator|.
name|getValue
argument_list|()
operator|.
name|clazz
decl_stmt|;
if|if
condition|(
name|javaPeer
operator|.
name|isInterface
argument_list|()
condition|)
block|{
name|copyStruct
argument_list|(
name|name
argument_list|,
name|Collections
operator|.
name|singletonList
argument_list|(
literal|"Object"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
operator|.
name|equals
argument_list|(
literal|"def"
argument_list|)
operator|==
literal|false
operator|&&
name|name
operator|.
name|equals
argument_list|(
literal|"Object"
argument_list|)
operator|==
literal|false
operator|&&
name|javaPeer
operator|.
name|isPrimitive
argument_list|()
operator|==
literal|false
condition|)
block|{
comment|// but otherwise, unless its a primitive type, it really should
assert|assert
name|hierarchy
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|!=
literal|null
operator|:
literal|"class '"
operator|+
name|name
operator|+
literal|"' does not extend Object!"
assert|;
assert|assert
name|hierarchy
operator|.
name|get
argument_list|(
name|name
argument_list|)
operator|.
name|contains
argument_list|(
literal|"Object"
argument_list|)
operator|:
literal|"class '"
operator|+
name|name
operator|+
literal|"' does not extend Object!"
assert|;
block|}
block|}
comment|// mark functional interfaces (or set null, to mark class is not)
for|for
control|(
name|Struct
name|clazz
range|:
name|structsMap
operator|.
name|values
argument_list|()
control|)
block|{
name|clazz
operator|.
name|functionalMethod
operator|.
name|set
argument_list|(
name|computeFunctionalInterfaceMethod
argument_list|(
name|clazz
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// precompute runtime classes
for|for
control|(
name|Struct
name|struct
range|:
name|structsMap
operator|.
name|values
argument_list|()
control|)
block|{
name|addRuntimeClass
argument_list|(
name|struct
argument_list|)
expr_stmt|;
block|}
comment|// copy all structs to make them unmodifiable for outside users:
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Struct
argument_list|>
name|entry
range|:
name|structsMap
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|entry
operator|.
name|setValue
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
operator|.
name|freeze
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** adds classes from definition. returns hierarchy */
DECL|method|addStructs
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|addStructs
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|String
argument_list|>
argument_list|>
name|hierarchy
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|file
range|:
name|DEFINITION_FILES
control|)
block|{
name|int
name|currentLine
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
try|try
init|(
name|InputStream
name|stream
init|=
name|Definition
operator|.
name|class
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
init|;
name|LineNumberReader
name|reader
operator|=
operator|new
name|LineNumberReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|stream
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|currentLine
operator|=
name|reader
operator|.
name|getLineNumber
argument_list|()
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'#'
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"class "
argument_list|)
condition|)
block|{
name|String
name|elements
index|[]
init|=
name|line
operator|.
name|split
argument_list|(
literal|"\u0020"
argument_list|)
decl_stmt|;
assert|assert
name|elements
index|[
literal|2
index|]
operator|.
name|equals
argument_list|(
literal|"->"
argument_list|)
assert|;
if|if
condition|(
name|elements
operator|.
name|length
operator|==
literal|7
condition|)
block|{
name|hierarchy
operator|.
name|put
argument_list|(
name|elements
index|[
literal|1
index|]
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|elements
index|[
literal|5
index|]
operator|.
name|split
argument_list|(
literal|","
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|elements
operator|.
name|length
operator|==
literal|5
assert|;
block|}
name|String
name|className
init|=
name|elements
index|[
literal|1
index|]
decl_stmt|;
name|String
name|javaPeer
init|=
name|elements
index|[
literal|3
index|]
decl_stmt|;
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|javaClazz
decl_stmt|;
switch|switch
condition|(
name|javaPeer
condition|)
block|{
case|case
literal|"void"
case|:
name|javaClazz
operator|=
name|void
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"boolean"
case|:
name|javaClazz
operator|=
name|boolean
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"byte"
case|:
name|javaClazz
operator|=
name|byte
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"short"
case|:
name|javaClazz
operator|=
name|short
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"char"
case|:
name|javaClazz
operator|=
name|char
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"int"
case|:
name|javaClazz
operator|=
name|int
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"long"
case|:
name|javaClazz
operator|=
name|long
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"float"
case|:
name|javaClazz
operator|=
name|float
operator|.
name|class
expr_stmt|;
break|break;
case|case
literal|"double"
case|:
name|javaClazz
operator|=
name|double
operator|.
name|class
expr_stmt|;
break|break;
default|default:
name|javaClazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|javaPeer
argument_list|)
expr_stmt|;
break|break;
block|}
name|addStruct
argument_list|(
name|className
argument_list|,
name|javaClazz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"syntax error in "
operator|+
name|file
operator|+
literal|", line: "
operator|+
name|currentLine
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|hierarchy
return|;
block|}
comment|/** adds class methods/fields/ctors */
DECL|method|addElements
specifier|private
name|void
name|addElements
parameter_list|()
block|{
for|for
control|(
name|String
name|file
range|:
name|DEFINITION_FILES
control|)
block|{
name|int
name|currentLine
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
try|try
init|(
name|InputStream
name|stream
init|=
name|Definition
operator|.
name|class
operator|.
name|getResourceAsStream
argument_list|(
name|file
argument_list|)
init|;
name|LineNumberReader
name|reader
operator|=
operator|new
name|LineNumberReader
argument_list|(
operator|new
name|InputStreamReader
argument_list|(
name|stream
argument_list|,
name|StandardCharsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
init|)
block|{
name|String
name|line
init|=
literal|null
decl_stmt|;
name|String
name|currentClass
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|reader
operator|.
name|readLine
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|currentLine
operator|=
name|reader
operator|.
name|getLineNumber
argument_list|()
expr_stmt|;
name|line
operator|=
name|line
operator|.
name|trim
argument_list|()
expr_stmt|;
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|==
literal|0
operator|||
name|line
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'#'
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|startsWith
argument_list|(
literal|"class "
argument_list|)
condition|)
block|{
assert|assert
name|currentClass
operator|==
literal|null
assert|;
name|currentClass
operator|=
name|line
operator|.
name|split
argument_list|(
literal|"\u0020"
argument_list|)
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
operator|.
name|equals
argument_list|(
literal|"}"
argument_list|)
condition|)
block|{
assert|assert
name|currentClass
operator|!=
literal|null
assert|;
name|currentClass
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|currentClass
operator|!=
literal|null
assert|;
name|addSignature
argument_list|(
name|currentClass
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"syntax error in "
operator|+
name|file
operator|+
literal|", line: "
operator|+
name|currentLine
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|addStruct
specifier|private
specifier|final
name|void
name|addStruct
parameter_list|(
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|matches
argument_list|(
literal|"^[_a-zA-Z][\\.,_a-zA-Z0-9]*$"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid struct name ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|structsMap
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Duplicate struct name ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
specifier|final
name|Struct
name|struct
init|=
operator|new
name|Struct
argument_list|(
name|name
argument_list|,
name|clazz
argument_list|,
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|clazz
argument_list|)
argument_list|)
decl_stmt|;
name|structsMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|struct
argument_list|)
expr_stmt|;
name|simpleTypesMap
operator|.
name|put
argument_list|(
name|name
argument_list|,
name|getTypeInternal
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|addConstructorInternal
specifier|private
specifier|final
name|void
name|addConstructorInternal
parameter_list|(
specifier|final
name|String
name|struct
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Type
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|Struct
name|owner
init|=
name|structsMap
operator|.
name|get
argument_list|(
name|struct
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Owner struct ["
operator|+
name|struct
operator|+
literal|"] not defined for constructor ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|name
operator|.
name|matches
argument_list|(
literal|"<init>"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid constructor name ["
operator|+
name|name
operator|+
literal|"] with the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|MethodKey
name|methodKey
init|=
operator|new
name|MethodKey
argument_list|(
name|name
argument_list|,
name|args
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|.
name|constructors
operator|.
name|containsKey
argument_list|(
name|methodKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Duplicate constructor ["
operator|+
name|methodKey
operator|+
literal|"] found within the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|owner
operator|.
name|staticMethods
operator|.
name|containsKey
argument_list|(
name|methodKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Constructors and static methods may not have the same signature"
operator|+
literal|" ["
operator|+
name|methodKey
operator|+
literal|"] within the same struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|owner
operator|.
name|methods
operator|.
name|containsKey
argument_list|(
name|methodKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Constructors and methods may not have the same signature"
operator|+
literal|" ["
operator|+
name|methodKey
operator|+
literal|"] within the same struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|classes
init|=
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[
name|args
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|classes
operator|.
name|length
condition|;
operator|++
name|count
control|)
block|{
name|classes
index|[
name|count
index|]
operator|=
name|args
index|[
name|count
index|]
operator|.
name|clazz
expr_stmt|;
block|}
specifier|final
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
argument_list|<
name|?
argument_list|>
name|reflect
decl_stmt|;
try|try
block|{
name|reflect
operator|=
name|owner
operator|.
name|clazz
operator|.
name|getConstructor
argument_list|(
name|classes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NoSuchMethodException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Constructor ["
operator|+
name|name
operator|+
literal|"] not found for class"
operator|+
literal|" ["
operator|+
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"] with arguments "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|classes
argument_list|)
operator|+
literal|"."
argument_list|)
throw|;
block|}
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|asm
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
operator|.
name|getMethod
argument_list|(
name|reflect
argument_list|)
decl_stmt|;
specifier|final
name|Type
name|returnType
init|=
name|getTypeInternal
argument_list|(
literal|"void"
argument_list|)
decl_stmt|;
specifier|final
name|MethodHandle
name|handle
decl_stmt|;
try|try
block|{
name|handle
operator|=
name|MethodHandles
operator|.
name|publicLookup
argument_list|()
operator|.
name|in
argument_list|(
name|owner
operator|.
name|clazz
argument_list|)
operator|.
name|unreflectConstructor
argument_list|(
name|reflect
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IllegalAccessException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Constructor "
operator|+
literal|" not found for class ["
operator|+
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
operator|+
literal|" with arguments "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|classes
argument_list|)
operator|+
literal|"."
argument_list|)
throw|;
block|}
specifier|final
name|Method
name|constructor
init|=
operator|new
name|Method
argument_list|(
name|name
argument_list|,
name|owner
argument_list|,
name|returnType
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|,
name|asm
argument_list|,
name|reflect
operator|.
name|getModifiers
argument_list|()
argument_list|,
name|handle
argument_list|)
decl_stmt|;
name|owner
operator|.
name|constructors
operator|.
name|put
argument_list|(
name|methodKey
argument_list|,
name|constructor
argument_list|)
expr_stmt|;
block|}
comment|/**      * Adds a new signature to the definition.      *<p>      * Signatures have the following forms:      *<ul>      *<li>{@code void method(String,int)}      *<li>{@code boolean field}      *<li>{@code Class<init>(String)}      *</ul>      * no spaces allowed.      */
DECL|method|addSignature
specifier|private
specifier|final
name|void
name|addSignature
parameter_list|(
name|String
name|className
parameter_list|,
name|String
name|signature
parameter_list|)
block|{
name|String
name|elements
index|[]
init|=
name|signature
operator|.
name|split
argument_list|(
literal|"\u0020"
argument_list|)
decl_stmt|;
if|if
condition|(
name|elements
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Malformed signature: "
operator|+
name|signature
argument_list|)
throw|;
block|}
comment|// method or field type (e.g. return type)
name|Type
name|rtn
init|=
name|getTypeInternal
argument_list|(
name|elements
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|parenIndex
init|=
name|elements
index|[
literal|1
index|]
operator|.
name|indexOf
argument_list|(
literal|'('
argument_list|)
decl_stmt|;
if|if
condition|(
name|parenIndex
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// method or ctor
name|int
name|parenEnd
init|=
name|elements
index|[
literal|1
index|]
operator|.
name|indexOf
argument_list|(
literal|')'
argument_list|)
decl_stmt|;
specifier|final
name|Type
name|args
index|[]
decl_stmt|;
if|if
condition|(
name|parenEnd
operator|>
name|parenIndex
operator|+
literal|1
condition|)
block|{
name|String
name|arguments
index|[]
init|=
name|elements
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
name|parenIndex
operator|+
literal|1
argument_list|,
name|parenEnd
argument_list|)
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
name|args
operator|=
operator|new
name|Type
index|[
name|arguments
operator|.
name|length
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|arguments
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|=
name|getTypeInternal
argument_list|(
name|arguments
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|args
operator|=
operator|new
name|Type
index|[
literal|0
index|]
expr_stmt|;
block|}
name|String
name|methodName
init|=
name|elements
index|[
literal|1
index|]
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|parenIndex
argument_list|)
decl_stmt|;
if|if
condition|(
name|methodName
operator|.
name|equals
argument_list|(
literal|"<init>"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|elements
index|[
literal|0
index|]
operator|.
name|equals
argument_list|(
name|className
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Constructors must return their own type"
argument_list|)
throw|;
block|}
name|addConstructorInternal
argument_list|(
name|className
argument_list|,
literal|"<init>"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|methodName
operator|.
name|indexOf
argument_list|(
literal|'/'
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|String
name|nameAndAlias
index|[]
init|=
name|methodName
operator|.
name|split
argument_list|(
literal|"/"
argument_list|)
decl_stmt|;
if|if
condition|(
name|nameAndAlias
operator|.
name|length
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Currently only two aliases are allowed!"
argument_list|)
throw|;
block|}
name|addMethodInternal
argument_list|(
name|className
argument_list|,
name|nameAndAlias
index|[
literal|0
index|]
argument_list|,
name|nameAndAlias
index|[
literal|1
index|]
argument_list|,
name|rtn
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addMethodInternal
argument_list|(
name|className
argument_list|,
name|methodName
argument_list|,
literal|null
argument_list|,
name|rtn
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// field
name|addFieldInternal
argument_list|(
name|className
argument_list|,
name|elements
index|[
literal|1
index|]
argument_list|,
literal|null
argument_list|,
name|rtn
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addMethodInternal
specifier|private
specifier|final
name|void
name|addMethodInternal
parameter_list|(
specifier|final
name|String
name|struct
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|String
name|alias
parameter_list|,
specifier|final
name|Type
name|rtn
parameter_list|,
specifier|final
name|Type
index|[]
name|args
parameter_list|)
block|{
specifier|final
name|Struct
name|owner
init|=
name|structsMap
operator|.
name|get
argument_list|(
name|struct
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Owner struct ["
operator|+
name|struct
operator|+
literal|"] not defined"
operator|+
literal|" for method ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|name
operator|.
name|matches
argument_list|(
literal|"^[_a-zA-Z][_a-zA-Z0-9]*$"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid method name"
operator|+
literal|" ["
operator|+
name|name
operator|+
literal|"] with the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|MethodKey
name|methodKey
init|=
operator|new
name|MethodKey
argument_list|(
name|name
argument_list|,
name|args
operator|.
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|.
name|constructors
operator|.
name|containsKey
argument_list|(
name|methodKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Constructors and methods"
operator|+
literal|" may not have the same signature ["
operator|+
name|methodKey
operator|+
literal|"] within the same struct"
operator|+
literal|" ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|owner
operator|.
name|staticMethods
operator|.
name|containsKey
argument_list|(
name|methodKey
argument_list|)
operator|||
name|owner
operator|.
name|methods
operator|.
name|containsKey
argument_list|(
name|methodKey
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Duplicate  method signature ["
operator|+
name|methodKey
operator|+
literal|"] found within the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|classes
init|=
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[
name|args
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|classes
operator|.
name|length
condition|;
operator|++
name|count
control|)
block|{
name|classes
index|[
name|count
index|]
operator|=
name|args
index|[
name|count
index|]
operator|.
name|clazz
expr_stmt|;
block|}
specifier|final
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
name|reflect
decl_stmt|;
try|try
block|{
name|reflect
operator|=
name|owner
operator|.
name|clazz
operator|.
name|getMethod
argument_list|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
argument_list|,
name|classes
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NoSuchMethodException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Method ["
operator|+
operator|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
operator|)
operator|+
literal|"] not found for class ["
operator|+
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
operator|+
literal|" with arguments "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|classes
argument_list|)
operator|+
literal|"."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|reflect
operator|.
name|getReturnType
argument_list|()
operator|.
name|equals
argument_list|(
name|rtn
operator|.
name|clazz
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Specified return type class ["
operator|+
name|rtn
operator|.
name|clazz
operator|+
literal|"]"
operator|+
literal|" does not match the found return type class ["
operator|+
name|reflect
operator|.
name|getReturnType
argument_list|()
operator|+
literal|"] for the"
operator|+
literal|" method ["
operator|+
name|name
operator|+
literal|"]"
operator|+
literal|" within the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|asm
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
operator|.
name|getMethod
argument_list|(
name|reflect
argument_list|)
decl_stmt|;
name|MethodHandle
name|handle
decl_stmt|;
try|try
block|{
name|handle
operator|=
name|MethodHandles
operator|.
name|publicLookup
argument_list|()
operator|.
name|in
argument_list|(
name|owner
operator|.
name|clazz
argument_list|)
operator|.
name|unreflect
argument_list|(
name|reflect
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|IllegalAccessException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Method ["
operator|+
operator|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
operator|)
operator|+
literal|"]"
operator|+
literal|" not found for class ["
operator|+
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
operator|+
literal|" with arguments "
operator|+
name|Arrays
operator|.
name|toString
argument_list|(
name|classes
argument_list|)
operator|+
literal|"."
argument_list|)
throw|;
block|}
specifier|final
name|int
name|modifiers
init|=
name|reflect
operator|.
name|getModifiers
argument_list|()
decl_stmt|;
specifier|final
name|Method
name|method
init|=
operator|new
name|Method
argument_list|(
name|name
argument_list|,
name|owner
argument_list|,
name|rtn
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|args
argument_list|)
argument_list|,
name|asm
argument_list|,
name|modifiers
argument_list|,
name|handle
argument_list|)
decl_stmt|;
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|modifiers
argument_list|)
condition|)
block|{
name|owner
operator|.
name|staticMethods
operator|.
name|put
argument_list|(
name|methodKey
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|owner
operator|.
name|methods
operator|.
name|put
argument_list|(
name|methodKey
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addFieldInternal
specifier|private
specifier|final
name|void
name|addFieldInternal
parameter_list|(
specifier|final
name|String
name|struct
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|String
name|alias
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|)
block|{
specifier|final
name|Struct
name|owner
init|=
name|structsMap
operator|.
name|get
argument_list|(
name|struct
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Owner struct ["
operator|+
name|struct
operator|+
literal|"] not defined for "
operator|+
literal|" field ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|name
operator|.
name|matches
argument_list|(
literal|"^[_a-zA-Z][_a-zA-Z0-9]*$"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid field "
operator|+
literal|" name ["
operator|+
name|name
operator|+
literal|"] with the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|owner
operator|.
name|staticMembers
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
operator|||
name|owner
operator|.
name|members
operator|.
name|containsKey
argument_list|(
name|name
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Duplicate field name ["
operator|+
name|name
operator|+
literal|"]"
operator|+
literal|" found within the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|reflect
decl_stmt|;
try|try
block|{
name|reflect
operator|=
name|owner
operator|.
name|clazz
operator|.
name|getField
argument_list|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NoSuchFieldException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Field ["
operator|+
operator|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
operator|)
operator|+
literal|"]"
operator|+
literal|" not found for class ["
operator|+
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
specifier|final
name|int
name|modifiers
init|=
name|reflect
operator|.
name|getModifiers
argument_list|()
decl_stmt|;
name|boolean
name|isStatic
init|=
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|modifiers
argument_list|)
decl_stmt|;
name|MethodHandle
name|getter
init|=
literal|null
decl_stmt|;
name|MethodHandle
name|setter
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|isStatic
condition|)
block|{
name|getter
operator|=
name|MethodHandles
operator|.
name|publicLookup
argument_list|()
operator|.
name|unreflectGetter
argument_list|(
name|reflect
argument_list|)
expr_stmt|;
name|setter
operator|=
name|MethodHandles
operator|.
name|publicLookup
argument_list|()
operator|.
name|unreflectSetter
argument_list|(
name|reflect
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
specifier|final
name|IllegalAccessException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Getter/Setter ["
operator|+
operator|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
operator|)
operator|+
literal|"]"
operator|+
literal|" not found for class ["
operator|+
name|owner
operator|.
name|clazz
operator|.
name|getName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
specifier|final
name|Field
name|field
init|=
operator|new
name|Field
argument_list|(
name|name
argument_list|,
name|reflect
operator|.
name|getName
argument_list|()
argument_list|,
name|owner
argument_list|,
name|type
argument_list|,
name|modifiers
argument_list|,
name|getter
argument_list|,
name|setter
argument_list|)
decl_stmt|;
if|if
condition|(
name|isStatic
condition|)
block|{
comment|// require that all static fields are static final
if|if
condition|(
operator|!
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isFinal
argument_list|(
name|modifiers
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Static ["
operator|+
name|name
operator|+
literal|"]"
operator|+
literal|" within the struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"] is not final."
argument_list|)
throw|;
block|}
name|owner
operator|.
name|staticMembers
operator|.
name|put
argument_list|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|owner
operator|.
name|members
operator|.
name|put
argument_list|(
name|alias
operator|==
literal|null
condition|?
name|name
else|:
name|alias
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|copyStruct
specifier|private
name|void
name|copyStruct
parameter_list|(
name|String
name|struct
parameter_list|,
name|List
argument_list|<
name|String
argument_list|>
name|children
parameter_list|)
block|{
specifier|final
name|Struct
name|owner
init|=
name|structsMap
operator|.
name|get
argument_list|(
name|struct
argument_list|)
decl_stmt|;
if|if
condition|(
name|owner
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Owner struct ["
operator|+
name|struct
operator|+
literal|"] not defined for copy."
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|children
operator|.
name|size
argument_list|()
condition|;
operator|++
name|count
control|)
block|{
specifier|final
name|Struct
name|child
init|=
name|structsMap
operator|.
name|get
argument_list|(
name|children
operator|.
name|get
argument_list|(
name|count
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Child struct ["
operator|+
name|children
operator|.
name|get
argument_list|(
name|count
argument_list|)
operator|+
literal|"]"
operator|+
literal|" not defined for copy to owner struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|child
operator|.
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|owner
operator|.
name|clazz
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Child struct ["
operator|+
name|child
operator|.
name|name
operator|+
literal|"]"
operator|+
literal|" is not a super type of owner struct ["
operator|+
name|owner
operator|.
name|name
operator|+
literal|"] in copy."
argument_list|)
throw|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|kvPair
range|:
name|child
operator|.
name|methods
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|MethodKey
name|methodKey
init|=
name|kvPair
operator|.
name|getKey
argument_list|()
decl_stmt|;
name|Method
name|method
init|=
name|kvPair
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|owner
operator|.
name|methods
operator|.
name|get
argument_list|(
name|methodKey
argument_list|)
operator|==
literal|null
condition|)
block|{
comment|// sanity check, look for missing covariant/generic override
if|if
condition|(
name|owner
operator|.
name|clazz
operator|.
name|isInterface
argument_list|()
operator|&&
name|child
operator|.
name|clazz
operator|==
name|Object
operator|.
name|class
condition|)
block|{
comment|// ok
block|}
elseif|else
if|if
condition|(
name|child
operator|.
name|clazz
operator|==
name|Spliterator
operator|.
name|OfPrimitive
operator|.
name|class
operator|||
name|child
operator|.
name|clazz
operator|==
name|PrimitiveIterator
operator|.
name|class
condition|)
block|{
comment|// ok, we rely on generics erasure for these (its guaranteed in the javadocs though!!!!)
block|}
elseif|else
if|if
condition|(
name|Constants
operator|.
name|JRE_IS_MINIMUM_JAVA9
operator|&&
name|owner
operator|.
name|clazz
operator|==
name|LocalDate
operator|.
name|class
condition|)
block|{
comment|// ok, java 9 added covariant override for LocalDate.getEra() to return IsoEra:
comment|// https://bugs.openjdk.java.net/browse/JDK-8072746
block|}
else|else
block|{
try|try
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|arguments
index|[]
init|=
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[
name|method
operator|.
name|arguments
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|method
operator|.
name|arguments
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|arguments
index|[
name|i
index|]
operator|=
name|method
operator|.
name|arguments
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|clazz
expr_stmt|;
block|}
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
name|m
init|=
name|owner
operator|.
name|clazz
operator|.
name|getMethod
argument_list|(
name|method
operator|.
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|getReturnType
argument_list|()
operator|!=
name|method
operator|.
name|rtn
operator|.
name|clazz
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"missing covariant override for: "
operator|+
name|m
operator|+
literal|" in "
operator|+
name|owner
operator|.
name|name
argument_list|)
throw|;
block|}
if|if
condition|(
name|m
operator|.
name|isBridge
argument_list|()
operator|&&
operator|!
name|Modifier
operator|.
name|isVolatile
argument_list|(
name|method
operator|.
name|modifiers
argument_list|)
condition|)
block|{
comment|// its a bridge in the destination, but not in the source, but it might still be ok, check generics:
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
name|source
init|=
name|child
operator|.
name|clazz
operator|.
name|getMethod
argument_list|(
name|method
operator|.
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|arguments
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Arrays
operator|.
name|equals
argument_list|(
name|source
operator|.
name|getGenericParameterTypes
argument_list|()
argument_list|,
name|source
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"missing generic override for: "
operator|+
name|m
operator|+
literal|" in "
operator|+
name|owner
operator|.
name|name
argument_list|)
throw|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
name|owner
operator|.
name|methods
operator|.
name|put
argument_list|(
name|methodKey
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Field
name|field
range|:
name|child
operator|.
name|members
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|owner
operator|.
name|members
operator|.
name|get
argument_list|(
name|field
operator|.
name|name
argument_list|)
operator|==
literal|null
condition|)
block|{
name|owner
operator|.
name|members
operator|.
name|put
argument_list|(
name|field
operator|.
name|name
argument_list|,
operator|new
name|Field
argument_list|(
name|field
operator|.
name|name
argument_list|,
name|field
operator|.
name|javaName
argument_list|,
name|owner
argument_list|,
name|field
operator|.
name|type
argument_list|,
name|field
operator|.
name|modifiers
argument_list|,
name|field
operator|.
name|getter
argument_list|,
name|field
operator|.
name|setter
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Precomputes a more efficient structure for dynamic method/field access.      */
DECL|method|addRuntimeClass
specifier|private
name|void
name|addRuntimeClass
parameter_list|(
specifier|final
name|Struct
name|struct
parameter_list|)
block|{
specifier|final
name|Map
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|methods
init|=
name|struct
operator|.
name|methods
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
name|getters
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
name|setters
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
comment|// add all members
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|Field
argument_list|>
name|member
range|:
name|struct
operator|.
name|members
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|getters
operator|.
name|put
argument_list|(
name|member
operator|.
name|getKey
argument_list|()
argument_list|,
name|member
operator|.
name|getValue
argument_list|()
operator|.
name|getter
argument_list|)
expr_stmt|;
name|setters
operator|.
name|put
argument_list|(
name|member
operator|.
name|getKey
argument_list|()
argument_list|,
name|member
operator|.
name|getValue
argument_list|()
operator|.
name|setter
argument_list|)
expr_stmt|;
block|}
comment|// add all getters/setters
for|for
control|(
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|MethodKey
argument_list|,
name|Method
argument_list|>
name|method
range|:
name|methods
operator|.
name|entrySet
argument_list|()
control|)
block|{
specifier|final
name|String
name|name
init|=
name|method
operator|.
name|getKey
argument_list|()
operator|.
name|name
decl_stmt|;
specifier|final
name|Method
name|m
init|=
name|method
operator|.
name|getValue
argument_list|()
decl_stmt|;
if|if
condition|(
name|m
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
literal|"get"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|3
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
specifier|final
name|StringBuilder
name|newName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|name
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|getters
operator|.
name|putIfAbsent
argument_list|(
name|newName
operator|.
name|toString
argument_list|()
argument_list|,
name|m
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
literal|"is"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|2
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|2
argument_list|)
argument_list|)
condition|)
block|{
specifier|final
name|StringBuilder
name|newName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|name
operator|.
name|substring
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|getters
operator|.
name|putIfAbsent
argument_list|(
name|newName
operator|.
name|toString
argument_list|()
argument_list|,
name|m
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|==
literal|1
operator|&&
name|name
operator|.
name|startsWith
argument_list|(
literal|"set"
argument_list|)
operator|&&
name|name
operator|.
name|length
argument_list|()
operator|>
literal|3
operator|&&
name|Character
operator|.
name|isUpperCase
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|3
argument_list|)
argument_list|)
condition|)
block|{
specifier|final
name|StringBuilder
name|newName
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|Character
operator|.
name|toLowerCase
argument_list|(
name|name
operator|.
name|charAt
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|newName
operator|.
name|append
argument_list|(
name|name
operator|.
name|substring
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|setters
operator|.
name|putIfAbsent
argument_list|(
name|newName
operator|.
name|toString
argument_list|()
argument_list|,
name|m
operator|.
name|handle
argument_list|)
expr_stmt|;
block|}
block|}
name|runtimeMap
operator|.
name|put
argument_list|(
name|struct
operator|.
name|clazz
argument_list|,
operator|new
name|RuntimeClass
argument_list|(
name|methods
argument_list|,
name|getters
argument_list|,
name|setters
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** computes the functional interface method for a class, or returns null */
DECL|method|computeFunctionalInterfaceMethod
specifier|private
name|Method
name|computeFunctionalInterfaceMethod
parameter_list|(
name|Struct
name|clazz
parameter_list|)
block|{
if|if
condition|(
operator|!
name|clazz
operator|.
name|clazz
operator|.
name|isInterface
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
comment|// if its marked with this annotation, we fail if the conditions don't hold (means whitelist bug)
comment|// otherwise, this annotation is pretty useless.
name|boolean
name|hasAnnotation
init|=
name|clazz
operator|.
name|clazz
operator|.
name|isAnnotationPresent
argument_list|(
name|FunctionalInterface
operator|.
name|class
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
argument_list|>
name|methods
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
name|m
range|:
name|clazz
operator|.
name|clazz
operator|.
name|getMethods
argument_list|()
control|)
block|{
comment|// default interface methods don't count
if|if
condition|(
name|m
operator|.
name|isDefault
argument_list|()
condition|)
block|{
continue|continue;
block|}
comment|// static methods don't count
if|if
condition|(
name|Modifier
operator|.
name|isStatic
argument_list|(
name|m
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|// if its from Object, it doesn't count
try|try
block|{
name|Object
operator|.
name|class
operator|.
name|getMethod
argument_list|(
name|m
operator|.
name|getName
argument_list|()
argument_list|,
name|m
operator|.
name|getParameterTypes
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
comment|// it counts
block|}
name|methods
operator|.
name|add
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|methods
operator|.
name|size
argument_list|()
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|hasAnnotation
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Class: "
operator|+
name|clazz
operator|.
name|name
operator|+
literal|" is marked with FunctionalInterface but doesn't fit the bill: "
operator|+
name|methods
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
comment|// inspect the one method found from the reflection API, it should match the whitelist!
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Method
name|oneMethod
init|=
name|methods
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|Method
name|painless
init|=
name|clazz
operator|.
name|methods
operator|.
name|get
argument_list|(
operator|new
name|Definition
operator|.
name|MethodKey
argument_list|(
name|oneMethod
operator|.
name|getName
argument_list|()
argument_list|,
name|oneMethod
operator|.
name|getParameterCount
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|painless
operator|==
literal|null
operator|||
name|painless
operator|.
name|method
operator|.
name|equals
argument_list|(
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
operator|.
name|getMethod
argument_list|(
name|oneMethod
argument_list|)
argument_list|)
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Class: "
operator|+
name|clazz
operator|.
name|name
operator|+
literal|" is functional but the functional "
operator|+
literal|"method is not whitelisted!"
argument_list|)
throw|;
block|}
return|return
name|painless
return|;
block|}
DECL|method|getTypeInternal
specifier|private
name|Type
name|getTypeInternal
parameter_list|(
name|String
name|name
parameter_list|)
block|{
comment|// simple types (e.g. 0 array dimensions) are a simple hash lookup for speed
name|Type
name|simple
init|=
name|simpleTypesMap
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|simple
operator|!=
literal|null
condition|)
block|{
return|return
name|simple
return|;
block|}
name|int
name|dimensions
init|=
name|getDimensions
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|String
name|structstr
init|=
name|dimensions
operator|==
literal|0
condition|?
name|name
else|:
name|name
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|name
operator|.
name|indexOf
argument_list|(
literal|'['
argument_list|)
argument_list|)
decl_stmt|;
name|Struct
name|struct
init|=
name|structsMap
operator|.
name|get
argument_list|(
name|structstr
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The struct with name ["
operator|+
name|name
operator|+
literal|"] has not been defined."
argument_list|)
throw|;
block|}
return|return
name|getTypeInternal
argument_list|(
name|struct
argument_list|,
name|dimensions
argument_list|)
return|;
block|}
DECL|method|getTypeInternal
specifier|private
name|Type
name|getTypeInternal
parameter_list|(
name|Struct
name|struct
parameter_list|,
name|int
name|dimensions
parameter_list|)
block|{
name|String
name|name
init|=
name|struct
operator|.
name|name
decl_stmt|;
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
init|=
name|struct
operator|.
name|type
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|struct
operator|.
name|clazz
decl_stmt|;
name|Sort
name|sort
decl_stmt|;
if|if
condition|(
name|dimensions
operator|>
literal|0
condition|)
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
index|[]
name|brackets
init|=
operator|new
name|char
index|[
name|dimensions
index|]
decl_stmt|;
for|for
control|(
name|int
name|count
init|=
literal|0
init|;
name|count
operator|<
name|dimensions
condition|;
operator|++
name|count
control|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"[]"
argument_list|)
expr_stmt|;
name|brackets
index|[
name|count
index|]
operator|=
literal|'['
expr_stmt|;
block|}
name|String
name|descriptor
init|=
operator|new
name|String
argument_list|(
name|brackets
argument_list|)
operator|+
name|struct
operator|.
name|type
operator|.
name|getDescriptor
argument_list|()
decl_stmt|;
name|name
operator|=
name|builder
operator|.
name|toString
argument_list|()
expr_stmt|;
name|type
operator|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
try|try
block|{
name|clazz
operator|=
name|Class
operator|.
name|forName
argument_list|(
name|type
operator|.
name|getInternalName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'/'
argument_list|,
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassNotFoundException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"The class ["
operator|+
name|type
operator|.
name|getInternalName
argument_list|()
operator|+
literal|"]"
operator|+
literal|" could not be found to create type ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|sort
operator|=
name|Sort
operator|.
name|ARRAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"def"
operator|.
name|equals
argument_list|(
name|struct
operator|.
name|name
argument_list|)
condition|)
block|{
name|sort
operator|=
name|Sort
operator|.
name|DEF
expr_stmt|;
block|}
else|else
block|{
name|sort
operator|=
name|Sort
operator|.
name|OBJECT
expr_stmt|;
for|for
control|(
name|Sort
name|value
range|:
name|Sort
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|value
operator|.
name|clazz
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|value
operator|.
name|clazz
operator|.
name|equals
argument_list|(
name|struct
operator|.
name|clazz
argument_list|)
condition|)
block|{
name|sort
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|new
name|Type
argument_list|(
name|name
argument_list|,
name|dimensions
argument_list|,
name|struct
argument_list|,
name|clazz
argument_list|,
name|type
argument_list|,
name|sort
argument_list|)
return|;
block|}
DECL|method|getDimensions
specifier|private
name|int
name|getDimensions
parameter_list|(
name|String
name|name
parameter_list|)
block|{
name|int
name|dimensions
init|=
literal|0
decl_stmt|;
name|int
name|index
init|=
name|name
operator|.
name|indexOf
argument_list|(
literal|'['
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|length
init|=
name|name
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
operator|<
name|length
condition|)
block|{
if|if
condition|(
name|name
operator|.
name|charAt
argument_list|(
name|index
argument_list|)
operator|==
literal|'['
operator|&&
operator|++
name|index
operator|<
name|length
operator|&&
name|name
operator|.
name|charAt
argument_list|(
name|index
operator|++
argument_list|)
operator|==
literal|']'
condition|)
block|{
operator|++
name|dimensions
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid array braces in canonical name ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
block|}
return|return
name|dimensions
return|;
block|}
block|}
end_class

end_unit

