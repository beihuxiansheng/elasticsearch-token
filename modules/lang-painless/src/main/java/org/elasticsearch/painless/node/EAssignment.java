begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless.node
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|AnalyzerCaster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|DefBootstrap
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Cast
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Locals
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|MethodWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * Represents an assignment with the lhs and rhs as child nodes.  */
end_comment

begin_class
DECL|class|EAssignment
specifier|public
specifier|final
class|class
name|EAssignment
extends|extends
name|AExpression
block|{
DECL|field|lhs
specifier|private
name|AExpression
name|lhs
decl_stmt|;
DECL|field|rhs
specifier|private
name|AExpression
name|rhs
decl_stmt|;
DECL|field|pre
specifier|private
specifier|final
name|boolean
name|pre
decl_stmt|;
DECL|field|post
specifier|private
specifier|final
name|boolean
name|post
decl_stmt|;
DECL|field|operation
specifier|private
name|Operation
name|operation
decl_stmt|;
DECL|field|cat
specifier|private
name|boolean
name|cat
init|=
literal|false
decl_stmt|;
DECL|field|promote
specifier|private
name|Type
name|promote
init|=
literal|null
decl_stmt|;
DECL|field|shiftDistance
specifier|private
name|Type
name|shiftDistance
decl_stmt|;
comment|// for shifts, the RHS is promoted independently
DECL|field|there
specifier|private
name|Cast
name|there
init|=
literal|null
decl_stmt|;
DECL|field|back
specifier|private
name|Cast
name|back
init|=
literal|null
decl_stmt|;
DECL|method|EAssignment
specifier|public
name|EAssignment
parameter_list|(
name|Location
name|location
parameter_list|,
name|AExpression
name|lhs
parameter_list|,
name|AExpression
name|rhs
parameter_list|,
name|boolean
name|pre
parameter_list|,
name|boolean
name|post
parameter_list|,
name|Operation
name|operation
parameter_list|)
block|{
name|super
argument_list|(
name|location
argument_list|)
expr_stmt|;
name|this
operator|.
name|lhs
operator|=
name|Objects
operator|.
name|requireNonNull
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|this
operator|.
name|rhs
operator|=
name|rhs
expr_stmt|;
name|this
operator|.
name|pre
operator|=
name|pre
expr_stmt|;
name|this
operator|.
name|post
operator|=
name|post
expr_stmt|;
name|this
operator|.
name|operation
operator|=
name|operation
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|extractVariables
name|void
name|extractVariables
parameter_list|(
name|Set
argument_list|<
name|String
argument_list|>
name|variables
parameter_list|)
block|{
name|lhs
operator|.
name|extractVariables
argument_list|(
name|variables
argument_list|)
expr_stmt|;
name|rhs
operator|.
name|extractVariables
argument_list|(
name|variables
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|analyze
name|void
name|analyze
parameter_list|(
name|Locals
name|locals
parameter_list|)
block|{
name|analyzeLHS
argument_list|(
name|locals
argument_list|)
expr_stmt|;
name|analyzeIncrDecr
argument_list|()
expr_stmt|;
if|if
condition|(
name|operation
operator|!=
literal|null
condition|)
block|{
name|analyzeCompound
argument_list|(
name|locals
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|!=
literal|null
condition|)
block|{
name|analyzeSimple
argument_list|(
name|locals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
throw|;
block|}
block|}
DECL|method|analyzeLHS
specifier|private
name|void
name|analyzeLHS
parameter_list|(
name|Locals
name|locals
parameter_list|)
block|{
if|if
condition|(
name|lhs
operator|instanceof
name|AStoreable
condition|)
block|{
name|AStoreable
name|lhs
init|=
operator|(
name|AStoreable
operator|)
name|this
operator|.
name|lhs
decl_stmt|;
name|lhs
operator|.
name|read
operator|=
name|read
expr_stmt|;
name|lhs
operator|.
name|write
operator|=
literal|true
expr_stmt|;
name|lhs
operator|.
name|analyze
argument_list|(
name|locals
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Left-hand side cannot be assigned a value."
argument_list|)
throw|;
block|}
block|}
DECL|method|analyzeIncrDecr
specifier|private
name|void
name|analyzeIncrDecr
parameter_list|()
block|{
if|if
condition|(
name|pre
operator|&&
name|post
condition|)
block|{
throw|throw
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|pre
operator|||
name|post
condition|)
block|{
if|if
condition|(
name|rhs
operator|!=
literal|null
condition|)
block|{
throw|throw
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
name|Sort
name|sort
init|=
name|lhs
operator|.
name|actual
operator|.
name|sort
decl_stmt|;
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|INCR
condition|)
block|{
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
condition|)
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1D
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1F
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|operation
operator|=
name|Operation
operator|.
name|ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|DECR
condition|)
block|{
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
condition|)
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1D
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1F
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rhs
operator|=
operator|new
name|EConstant
argument_list|(
name|location
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|operation
operator|=
name|Operation
operator|.
name|SUB
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|analyzeCompound
specifier|private
name|void
name|analyzeCompound
parameter_list|(
name|Locals
name|locals
parameter_list|)
block|{
name|rhs
operator|.
name|analyze
argument_list|(
name|locals
argument_list|)
expr_stmt|;
name|boolean
name|shift
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|MUL
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|DIV
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|REM
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|ADD
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteAdd
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|SUB
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|LSH
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|shiftDistance
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|rhs
operator|.
name|actual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|shift
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|RSH
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|shiftDistance
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|rhs
operator|.
name|actual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|shift
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|USH
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|shiftDistance
operator|=
name|AnalyzerCaster
operator|.
name|promoteNumeric
argument_list|(
name|rhs
operator|.
name|actual
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|shift
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|BWAND
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteXor
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|XOR
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteXor
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|operation
operator|==
name|Operation
operator|.
name|BWOR
condition|)
block|{
name|promote
operator|=
name|AnalyzerCaster
operator|.
name|promoteXor
argument_list|(
name|lhs
operator|.
name|actual
argument_list|,
name|rhs
operator|.
name|actual
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|promote
operator|==
literal|null
operator|||
operator|(
name|shift
operator|&&
name|shiftDistance
operator|==
literal|null
operator|)
condition|)
block|{
throw|throw
name|createError
argument_list|(
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply compound assignment "
operator|+
literal|"["
operator|+
name|operation
operator|.
name|symbol
operator|+
literal|"=] to types ["
operator|+
name|lhs
operator|.
name|actual
operator|+
literal|"] and ["
operator|+
name|rhs
operator|.
name|actual
operator|+
literal|"]."
argument_list|)
argument_list|)
throw|;
block|}
name|cat
operator|=
name|operation
operator|==
name|Operation
operator|.
name|ADD
operator|&&
name|promote
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
expr_stmt|;
if|if
condition|(
name|cat
condition|)
block|{
if|if
condition|(
name|rhs
operator|instanceof
name|EBinary
operator|&&
operator|(
operator|(
name|EBinary
operator|)
name|rhs
operator|)
operator|.
name|operation
operator|==
name|Operation
operator|.
name|ADD
operator|&&
name|rhs
operator|.
name|actual
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
condition|)
block|{
operator|(
operator|(
name|EBinary
operator|)
name|rhs
operator|)
operator|.
name|cat
operator|=
literal|true
expr_stmt|;
block|}
name|rhs
operator|.
name|expected
operator|=
name|rhs
operator|.
name|actual
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
condition|)
block|{
if|if
condition|(
name|promote
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
comment|// shifts are promoted independently, but for the def type, we need object.
name|rhs
operator|.
name|expected
operator|=
name|promote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shiftDistance
operator|.
name|sort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|rhs
operator|.
name|expected
operator|=
name|Definition
operator|.
name|INT_TYPE
expr_stmt|;
name|rhs
operator|.
name|explicit
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|rhs
operator|.
name|expected
operator|=
name|shiftDistance
expr_stmt|;
block|}
block|}
else|else
block|{
name|rhs
operator|.
name|expected
operator|=
name|promote
expr_stmt|;
block|}
name|rhs
operator|=
name|rhs
operator|.
name|cast
argument_list|(
name|locals
argument_list|)
expr_stmt|;
name|there
operator|=
name|AnalyzerCaster
operator|.
name|getLegalCast
argument_list|(
name|location
argument_list|,
name|lhs
operator|.
name|actual
argument_list|,
name|promote
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|back
operator|=
name|AnalyzerCaster
operator|.
name|getLegalCast
argument_list|(
name|location
argument_list|,
name|promote
argument_list|,
name|lhs
operator|.
name|actual
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|statement
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|actual
operator|=
name|read
condition|?
name|lhs
operator|.
name|actual
else|:
name|Definition
operator|.
name|VOID_TYPE
expr_stmt|;
block|}
DECL|method|analyzeSimple
specifier|private
name|void
name|analyzeSimple
parameter_list|(
name|Locals
name|locals
parameter_list|)
block|{
name|AStoreable
name|lhs
init|=
operator|(
name|AStoreable
operator|)
name|this
operator|.
name|lhs
decl_stmt|;
comment|// If the lhs node is a def optimized node we update the actual type to remove the need for a cast.
if|if
condition|(
name|lhs
operator|.
name|isDefOptimized
argument_list|()
condition|)
block|{
name|rhs
operator|.
name|analyze
argument_list|(
name|locals
argument_list|)
expr_stmt|;
name|rhs
operator|.
name|expected
operator|=
name|rhs
operator|.
name|actual
expr_stmt|;
name|lhs
operator|.
name|updateActual
argument_list|(
name|rhs
operator|.
name|actual
argument_list|)
expr_stmt|;
comment|// Otherwise, we must adapt the rhs type to the lhs type with a cast.
block|}
else|else
block|{
name|rhs
operator|.
name|expected
operator|=
name|lhs
operator|.
name|actual
expr_stmt|;
name|rhs
operator|.
name|analyze
argument_list|(
name|locals
argument_list|)
expr_stmt|;
block|}
name|rhs
operator|=
name|rhs
operator|.
name|cast
argument_list|(
name|locals
argument_list|)
expr_stmt|;
name|this
operator|.
name|statement
operator|=
literal|true
expr_stmt|;
name|this
operator|.
name|actual
operator|=
name|read
condition|?
name|lhs
operator|.
name|actual
else|:
name|Definition
operator|.
name|VOID_TYPE
expr_stmt|;
block|}
comment|/**      * Handles writing byte code for variable/method chains for all given possibilities      * including String concatenation, compound assignment, regular assignment, and simple      * reads.  Includes proper duplication for chained assignments and assignments that are      * also read from.      */
annotation|@
name|Override
DECL|method|write
name|void
name|write
parameter_list|(
name|MethodWriter
name|writer
parameter_list|,
name|Globals
name|globals
parameter_list|)
block|{
name|writer
operator|.
name|writeDebugInfo
argument_list|(
name|location
argument_list|)
expr_stmt|;
comment|// For the case where the assignment represents a String concatenation
comment|// we must, depending on the Java version, write a StringBuilder or
comment|// track types going onto the stack.  This must be done before the
comment|// lhs is read because we need the StringBuilder to be placed on the
comment|// stack ahead of any potential concatenation arguments.
name|int
name|catElementStackSize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cat
condition|)
block|{
name|catElementStackSize
operator|=
name|writer
operator|.
name|writeNewStrings
argument_list|()
expr_stmt|;
block|}
comment|// Cast the lhs to a storeable to perform the necessary operations to store the rhs.
name|AStoreable
name|lhs
init|=
operator|(
name|AStoreable
operator|)
name|this
operator|.
name|lhs
decl_stmt|;
name|lhs
operator|.
name|setup
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// call the setup method on the lhs to prepare for a load/store operation
if|if
condition|(
name|cat
condition|)
block|{
comment|// Handle the case where we are doing a compound assignment
comment|// representing a String concatenation.
name|writer
operator|.
name|writeDup
argument_list|(
name|lhs
operator|.
name|accessElementCount
argument_list|()
argument_list|,
name|catElementStackSize
argument_list|)
expr_stmt|;
comment|// dup the top element and insert it
comment|// before concat helper on stack
name|lhs
operator|.
name|load
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// read the current lhs's value
name|writer
operator|.
name|writeAppendStrings
argument_list|(
name|lhs
operator|.
name|actual
argument_list|)
expr_stmt|;
comment|// append the lhs's value using the StringBuilder
name|rhs
operator|.
name|write
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// write the bytecode for the rhs
if|if
condition|(
operator|!
operator|(
name|rhs
operator|instanceof
name|EBinary
operator|)
operator|||
operator|!
operator|(
operator|(
name|EBinary
operator|)
name|rhs
operator|)
operator|.
name|cat
condition|)
block|{
comment|// check to see if the rhs has already done a concatenation
name|writer
operator|.
name|writeAppendStrings
argument_list|(
name|rhs
operator|.
name|actual
argument_list|)
expr_stmt|;
comment|// append the rhs's value since it's hasn't already
block|}
name|writer
operator|.
name|writeToStrings
argument_list|()
expr_stmt|;
comment|// put the value for string concat onto the stack
name|writer
operator|.
name|writeCast
argument_list|(
name|back
argument_list|)
expr_stmt|;
comment|// if necessary, cast the String to the lhs actual type
if|if
condition|(
name|lhs
operator|.
name|read
condition|)
block|{
name|writer
operator|.
name|writeDup
argument_list|(
name|lhs
operator|.
name|actual
operator|.
name|sort
operator|.
name|size
argument_list|,
name|lhs
operator|.
name|accessElementCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// if this lhs is also read
comment|// from dup the value onto the stack
block|}
name|lhs
operator|.
name|store
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// store the lhs's value from the stack in its respective variable/field/array
block|}
elseif|else
if|if
condition|(
name|operation
operator|!=
literal|null
condition|)
block|{
comment|// Handle the case where we are doing a compound assignment that
comment|// does not represent a String concatenation.
name|writer
operator|.
name|writeDup
argument_list|(
name|lhs
operator|.
name|accessElementCount
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// if necessary, dup the previous lhs's value
comment|// to be both loaded from and stored to
name|lhs
operator|.
name|load
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// load the current lhs's value
if|if
condition|(
name|lhs
operator|.
name|read
operator|&&
name|post
condition|)
block|{
name|writer
operator|.
name|writeDup
argument_list|(
name|lhs
operator|.
name|actual
operator|.
name|sort
operator|.
name|size
argument_list|,
name|lhs
operator|.
name|accessElementCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// dup the value if the lhs is also
comment|// read from and is a post increment
block|}
name|writer
operator|.
name|writeCast
argument_list|(
name|there
argument_list|)
expr_stmt|;
comment|// if necessary cast the current lhs's value
comment|// to the promotion type between the lhs and rhs types
name|rhs
operator|.
name|write
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// write the bytecode for the rhs
comment|// XXX: fix these types, but first we need def compound assignment tests.
comment|// its tricky here as there are possibly explicit casts, too.
comment|// write the operation instruction for compound assignment
if|if
condition|(
name|promote
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
name|writer
operator|.
name|writeDynamicBinaryInstruction
argument_list|(
name|location
argument_list|,
name|promote
argument_list|,
name|Definition
operator|.
name|DEF_TYPE
argument_list|,
name|Definition
operator|.
name|DEF_TYPE
argument_list|,
name|operation
argument_list|,
name|DefBootstrap
operator|.
name|OPERATOR_COMPOUND_ASSIGNMENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writer
operator|.
name|writeBinaryInstruction
argument_list|(
name|location
argument_list|,
name|promote
argument_list|,
name|operation
argument_list|)
expr_stmt|;
block|}
name|writer
operator|.
name|writeCast
argument_list|(
name|back
argument_list|)
expr_stmt|;
comment|// if necessary cast the promotion type value back to the lhs's type
if|if
condition|(
name|lhs
operator|.
name|read
operator|&&
operator|!
name|post
condition|)
block|{
name|writer
operator|.
name|writeDup
argument_list|(
name|lhs
operator|.
name|actual
operator|.
name|sort
operator|.
name|size
argument_list|,
name|lhs
operator|.
name|accessElementCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// dup the value if the lhs is also
comment|// read from and is not a post increment
block|}
name|lhs
operator|.
name|store
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// store the lhs's value from the stack in its respective variable/field/array
block|}
else|else
block|{
comment|// Handle the case for a simple write.
name|rhs
operator|.
name|write
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// write the bytecode for the rhs rhs
if|if
condition|(
name|lhs
operator|.
name|read
condition|)
block|{
name|writer
operator|.
name|writeDup
argument_list|(
name|lhs
operator|.
name|actual
operator|.
name|sort
operator|.
name|size
argument_list|,
name|lhs
operator|.
name|accessElementCount
argument_list|()
argument_list|)
expr_stmt|;
comment|// dup the value if the lhs is also read from
block|}
name|lhs
operator|.
name|store
argument_list|(
name|writer
argument_list|,
name|globals
argument_list|)
expr_stmt|;
comment|// store the lhs's value from the stack in its respective variable/field/array
block|}
block|}
block|}
end_class

end_unit

