begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
operator|.
name|Lookup
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_comment
comment|/**  * Dynamic operators for painless.   *<p>  * Each operator must "support" the following types:  * {@code int,long,float,double,boolean,Object}. Operators can throw exceptions if   * the type is illegal. The {@code Object} type must be a "generic" handler that  * handles all legal types: it must be convertible to every possible legal signature.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
DECL|class|DefMath
specifier|public
class|class
name|DefMath
block|{
comment|// Unary not: only applicable to integral types
DECL|method|not
specifier|private
specifier|static
name|int
name|not
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
operator|~
name|v
return|;
block|}
DECL|method|not
specifier|private
specifier|static
name|long
name|not
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
operator|~
name|v
return|;
block|}
DECL|method|not
specifier|private
specifier|static
name|float
name|not
parameter_list|(
name|float
name|v
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply not [~] to type [float]"
argument_list|)
throw|;
block|}
DECL|method|not
specifier|private
specifier|static
name|double
name|not
parameter_list|(
name|double
name|v
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply not [~] to type [double]"
argument_list|)
throw|;
block|}
DECL|method|not
specifier|private
specifier|static
name|boolean
name|not
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply not [~] to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|not
specifier|private
specifier|static
name|Object
name|not
parameter_list|(
name|Object
name|unary
parameter_list|)
block|{
if|if
condition|(
name|unary
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|~
operator|(
name|Long
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|~
operator|(
name|Integer
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|~
operator|(
name|Short
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|~
operator|(
name|Character
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|~
operator|(
name|Byte
operator|)
name|unary
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [~] operation to type "
operator|+
literal|"["
operator|+
name|unary
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// unary negation and plus: applicable to all numeric types
DECL|method|neg
specifier|private
specifier|static
name|int
name|neg
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
operator|-
name|v
return|;
block|}
DECL|method|neg
specifier|private
specifier|static
name|long
name|neg
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
operator|-
name|v
return|;
block|}
DECL|method|neg
specifier|private
specifier|static
name|float
name|neg
parameter_list|(
name|float
name|v
parameter_list|)
block|{
return|return
operator|-
name|v
return|;
block|}
DECL|method|neg
specifier|private
specifier|static
name|double
name|neg
parameter_list|(
name|double
name|v
parameter_list|)
block|{
return|return
operator|-
name|v
return|;
block|}
DECL|method|neg
specifier|private
specifier|static
name|boolean
name|neg
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|neg
specifier|private
specifier|static
name|Object
name|neg
parameter_list|(
specifier|final
name|Object
name|unary
parameter_list|)
block|{
if|if
condition|(
name|unary
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|-
operator|(
name|double
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|-
operator|(
name|long
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|-
operator|(
name|int
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|-
operator|(
name|float
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|-
operator|(
name|short
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|-
operator|(
name|char
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|-
operator|(
name|byte
operator|)
name|unary
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to type "
operator|+
literal|"["
operator|+
name|unary
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|plus
specifier|private
specifier|static
name|int
name|plus
parameter_list|(
name|int
name|v
parameter_list|)
block|{
return|return
operator|+
name|v
return|;
block|}
DECL|method|plus
specifier|private
specifier|static
name|long
name|plus
parameter_list|(
name|long
name|v
parameter_list|)
block|{
return|return
operator|+
name|v
return|;
block|}
DECL|method|plus
specifier|private
specifier|static
name|float
name|plus
parameter_list|(
name|float
name|v
parameter_list|)
block|{
return|return
operator|+
name|v
return|;
block|}
DECL|method|plus
specifier|private
specifier|static
name|double
name|plus
parameter_list|(
name|double
name|v
parameter_list|)
block|{
return|return
operator|+
name|v
return|;
block|}
DECL|method|plus
specifier|private
specifier|static
name|boolean
name|plus
parameter_list|(
name|boolean
name|v
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [+] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|plus
specifier|private
specifier|static
name|Object
name|plus
parameter_list|(
specifier|final
name|Object
name|unary
parameter_list|)
block|{
if|if
condition|(
name|unary
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|+
operator|(
name|double
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|+
operator|(
name|long
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|+
operator|(
name|int
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|+
operator|(
name|float
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|+
operator|(
name|short
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|+
operator|(
name|char
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|+
operator|(
name|byte
operator|)
name|unary
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [+] operation to type "
operator|+
literal|"["
operator|+
name|unary
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// multiplication/division/remainder/subtraction: applicable to all integer types
DECL|method|mul
specifier|private
specifier|static
name|int
name|mul
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|*
name|b
return|;
block|}
DECL|method|mul
specifier|private
specifier|static
name|long
name|mul
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|*
name|b
return|;
block|}
DECL|method|mul
specifier|private
specifier|static
name|float
name|mul
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|*
name|b
return|;
block|}
DECL|method|mul
specifier|private
specifier|static
name|double
name|mul
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|*
name|b
return|;
block|}
DECL|method|mul
specifier|private
specifier|static
name|boolean
name|mul
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [*] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|mul
specifier|private
specifier|static
name|Object
name|mul
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [*] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|div
specifier|private
specifier|static
name|int
name|div
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|/
name|b
return|;
block|}
DECL|method|div
specifier|private
specifier|static
name|long
name|div
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|/
name|b
return|;
block|}
DECL|method|div
specifier|private
specifier|static
name|float
name|div
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|/
name|b
return|;
block|}
DECL|method|div
specifier|private
specifier|static
name|double
name|div
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|/
name|b
return|;
block|}
DECL|method|div
specifier|private
specifier|static
name|boolean
name|div
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [/] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|div
specifier|private
specifier|static
name|Object
name|div
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [/] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|rem
specifier|private
specifier|static
name|int
name|rem
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|%
name|b
return|;
block|}
DECL|method|rem
specifier|private
specifier|static
name|long
name|rem
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|%
name|b
return|;
block|}
DECL|method|rem
specifier|private
specifier|static
name|float
name|rem
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|%
name|b
return|;
block|}
DECL|method|rem
specifier|private
specifier|static
name|double
name|rem
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|%
name|b
return|;
block|}
DECL|method|rem
specifier|private
specifier|static
name|boolean
name|rem
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [%] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|rem
specifier|private
specifier|static
name|Object
name|rem
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [%] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// addition: applicable to all numeric types.
comment|// additionally, if either type is a string, the other type can be any arbitrary type (including null)
DECL|method|add
specifier|private
specifier|static
name|int
name|add
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|+
name|b
return|;
block|}
DECL|method|add
specifier|private
specifier|static
name|long
name|add
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|+
name|b
return|;
block|}
DECL|method|add
specifier|private
specifier|static
name|float
name|add
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|+
name|b
return|;
block|}
DECL|method|add
specifier|private
specifier|static
name|double
name|add
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|+
name|b
return|;
block|}
DECL|method|add
specifier|private
specifier|static
name|boolean
name|add
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [+] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|add
specifier|private
specifier|static
name|Object
name|add
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|String
operator|||
name|right
operator|instanceof
name|String
condition|)
block|{
return|return
literal|""
operator|+
name|left
operator|+
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [+] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|sub
specifier|private
specifier|static
name|int
name|sub
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|-
name|b
return|;
block|}
DECL|method|sub
specifier|private
specifier|static
name|long
name|sub
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|-
name|b
return|;
block|}
DECL|method|sub
specifier|private
specifier|static
name|float
name|sub
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|-
name|b
return|;
block|}
DECL|method|sub
specifier|private
specifier|static
name|double
name|sub
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|-
name|b
return|;
block|}
DECL|method|sub
specifier|private
specifier|static
name|boolean
name|sub
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|sub
specifier|private
specifier|static
name|Object
name|sub
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// eq: applicable to any arbitrary type, including nulls for both arguments!!!
DECL|method|eq
specifier|private
specifier|static
name|boolean
name|eq
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
DECL|method|eq
specifier|private
specifier|static
name|boolean
name|eq
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
DECL|method|eq
specifier|private
specifier|static
name|boolean
name|eq
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
DECL|method|eq
specifier|private
specifier|static
name|boolean
name|eq
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
DECL|method|eq
specifier|private
specifier|static
name|boolean
name|eq
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
return|return
name|a
operator|==
name|b
return|;
block|}
DECL|method|eq
specifier|private
specifier|static
name|boolean
name|eq
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|!=
literal|null
operator|&&
name|right
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|double
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|double
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|==
operator|(
name|double
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|==
operator|(
name|float
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|==
operator|(
name|long
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Number
operator|&&
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
operator|&&
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
return|return
name|left
operator|.
name|equals
argument_list|(
name|right
argument_list|)
return|;
block|}
return|return
name|left
operator|==
literal|null
operator|&&
name|right
operator|==
literal|null
return|;
block|}
comment|// comparison operators: applicable for any numeric type
DECL|method|lt
specifier|private
specifier|static
name|boolean
name|lt
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|<
name|b
return|;
block|}
DECL|method|lt
specifier|private
specifier|static
name|boolean
name|lt
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|<
name|b
return|;
block|}
DECL|method|lt
specifier|private
specifier|static
name|boolean
name|lt
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|<
name|b
return|;
block|}
DECL|method|lt
specifier|private
specifier|static
name|boolean
name|lt
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|<
name|b
return|;
block|}
DECL|method|lt
specifier|private
specifier|static
name|boolean
name|lt
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|lt
specifier|private
specifier|static
name|boolean
name|lt
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|lte
specifier|private
specifier|static
name|boolean
name|lte
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|<=
name|b
return|;
block|}
DECL|method|lte
specifier|private
specifier|static
name|boolean
name|lte
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|<=
name|b
return|;
block|}
DECL|method|lte
specifier|private
specifier|static
name|boolean
name|lte
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|<=
name|b
return|;
block|}
DECL|method|lte
specifier|private
specifier|static
name|boolean
name|lte
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|<=
name|b
return|;
block|}
DECL|method|lte
specifier|private
specifier|static
name|boolean
name|lte
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<=] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|lte
specifier|private
specifier|static
name|boolean
name|lte
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<=] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|gt
specifier|private
specifier|static
name|boolean
name|gt
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|>
name|b
return|;
block|}
DECL|method|gt
specifier|private
specifier|static
name|boolean
name|gt
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|>
name|b
return|;
block|}
DECL|method|gt
specifier|private
specifier|static
name|boolean
name|gt
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|>
name|b
return|;
block|}
DECL|method|gt
specifier|private
specifier|static
name|boolean
name|gt
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|>
name|b
return|;
block|}
DECL|method|gt
specifier|private
specifier|static
name|boolean
name|gt
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|gt
specifier|private
specifier|static
name|boolean
name|gt
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|gte
specifier|private
specifier|static
name|boolean
name|gte
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|>=
name|b
return|;
block|}
DECL|method|gte
specifier|private
specifier|static
name|boolean
name|gte
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|>=
name|b
return|;
block|}
DECL|method|gte
specifier|private
specifier|static
name|boolean
name|gte
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
return|return
name|a
operator|>=
name|b
return|;
block|}
DECL|method|gte
specifier|private
specifier|static
name|boolean
name|gte
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
return|return
name|a
operator|>=
name|b
return|;
block|}
DECL|method|gte
specifier|private
specifier|static
name|boolean
name|gte
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>=] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|gte
specifier|private
specifier|static
name|boolean
name|gte
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// helper methods to convert an integral according to numeric promotion
comment|// this is used by the generic code for bitwise and shift operators
DECL|method|longIntegralValue
specifier|private
specifier|static
name|long
name|longIntegralValue
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Integer
operator|||
name|o
operator|instanceof
name|Short
operator|||
name|o
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|o
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|o
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot convert ["
operator|+
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] to an integral value."
argument_list|)
throw|;
block|}
block|}
DECL|method|intIntegralValue
specifier|private
specifier|static
name|int
name|intIntegralValue
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Integer
operator|||
name|o
operator|instanceof
name|Short
operator|||
name|o
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|o
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|o
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot convert ["
operator|+
name|o
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] to an integral value."
argument_list|)
throw|;
block|}
block|}
comment|// bitwise operators: valid only for integral types
DECL|method|and
specifier|private
specifier|static
name|int
name|and
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|&
name|b
return|;
block|}
DECL|method|and
specifier|private
specifier|static
name|long
name|and
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|&
name|b
return|;
block|}
DECL|method|and
specifier|private
specifier|static
name|float
name|and
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [&] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|and
specifier|private
specifier|static
name|double
name|and
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [&] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|and
specifier|private
specifier|static
name|boolean
name|and
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
return|return
name|a
operator|&
name|b
return|;
block|}
DECL|method|and
specifier|private
specifier|static
name|Object
name|and
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|&
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
name|longIntegralValue
argument_list|(
name|left
argument_list|)
operator|&
name|longIntegralValue
argument_list|(
name|right
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|intIntegralValue
argument_list|(
name|left
argument_list|)
operator|&
name|intIntegralValue
argument_list|(
name|right
argument_list|)
return|;
block|}
block|}
DECL|method|xor
specifier|private
specifier|static
name|int
name|xor
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator|^
name|b
return|;
block|}
DECL|method|xor
specifier|private
specifier|static
name|long
name|xor
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|^
name|b
return|;
block|}
DECL|method|xor
specifier|private
specifier|static
name|float
name|xor
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [^] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|xor
specifier|private
specifier|static
name|double
name|xor
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [^] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|xor
specifier|private
specifier|static
name|boolean
name|xor
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
return|return
name|a
operator|^
name|b
return|;
block|}
DECL|method|xor
specifier|private
specifier|static
name|Object
name|xor
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|^
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
name|longIntegralValue
argument_list|(
name|left
argument_list|)
operator|^
name|longIntegralValue
argument_list|(
name|right
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|intIntegralValue
argument_list|(
name|left
argument_list|)
operator|^
name|intIntegralValue
argument_list|(
name|right
argument_list|)
return|;
block|}
block|}
DECL|method|or
specifier|private
specifier|static
name|int
name|or
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
name|a
operator||
name|b
return|;
block|}
DECL|method|or
specifier|private
specifier|static
name|long
name|or
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator||
name|b
return|;
block|}
DECL|method|or
specifier|private
specifier|static
name|float
name|or
parameter_list|(
name|float
name|a
parameter_list|,
name|float
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [|] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|or
specifier|private
specifier|static
name|double
name|or
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [|] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|or
specifier|private
specifier|static
name|boolean
name|or
parameter_list|(
name|boolean
name|a
parameter_list|,
name|boolean
name|b
parameter_list|)
block|{
return|return
name|a
operator||
name|b
return|;
block|}
DECL|method|or
specifier|private
specifier|static
name|Object
name|or
parameter_list|(
name|Object
name|left
parameter_list|,
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator||
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
name|longIntegralValue
argument_list|(
name|left
argument_list|)
operator||
name|longIntegralValue
argument_list|(
name|right
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|intIntegralValue
argument_list|(
name|left
argument_list|)
operator||
name|intIntegralValue
argument_list|(
name|right
argument_list|)
return|;
block|}
block|}
comment|// shift operators, valid for any integral types, but does not promote.
comment|// we implement all shifts as long shifts, because the extra bits are ignored anyway.
DECL|method|lsh
specifier|private
specifier|static
name|int
name|lsh
parameter_list|(
name|int
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|<<
name|b
return|;
block|}
DECL|method|lsh
specifier|private
specifier|static
name|long
name|lsh
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|<<
name|b
return|;
block|}
DECL|method|lsh
specifier|private
specifier|static
name|float
name|lsh
parameter_list|(
name|float
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<<] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|lsh
specifier|private
specifier|static
name|double
name|lsh
parameter_list|(
name|double
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<<] operation to type [double]"
argument_list|)
throw|;
block|}
DECL|method|lsh
specifier|private
specifier|static
name|boolean
name|lsh
parameter_list|(
name|boolean
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<<] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|lsh
specifier|public
specifier|static
name|Object
name|lsh
parameter_list|(
name|Object
name|left
parameter_list|,
name|long
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
name|left
argument_list|)
operator|<<
name|right
return|;
block|}
else|else
block|{
return|return
name|intIntegralValue
argument_list|(
name|left
argument_list|)
operator|<<
name|right
return|;
block|}
block|}
DECL|method|rsh
specifier|private
specifier|static
name|int
name|rsh
parameter_list|(
name|int
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|>>
name|b
return|;
block|}
DECL|method|rsh
specifier|private
specifier|static
name|long
name|rsh
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|>>
name|b
return|;
block|}
DECL|method|rsh
specifier|private
specifier|static
name|float
name|rsh
parameter_list|(
name|float
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|rsh
specifier|private
specifier|static
name|double
name|rsh
parameter_list|(
name|double
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>] operation to type [double]"
argument_list|)
throw|;
block|}
DECL|method|rsh
specifier|private
specifier|static
name|boolean
name|rsh
parameter_list|(
name|boolean
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|rsh
specifier|public
specifier|static
name|Object
name|rsh
parameter_list|(
name|Object
name|left
parameter_list|,
name|long
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|left
operator|>>
name|right
return|;
block|}
else|else
block|{
return|return
name|intIntegralValue
argument_list|(
name|left
argument_list|)
operator|>>
name|right
return|;
block|}
block|}
DECL|method|ush
specifier|private
specifier|static
name|int
name|ush
parameter_list|(
name|int
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|>>>
name|b
return|;
block|}
DECL|method|ush
specifier|private
specifier|static
name|long
name|ush
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|a
operator|>>>
name|b
return|;
block|}
DECL|method|ush
specifier|private
specifier|static
name|float
name|ush
parameter_list|(
name|float
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>>] operation to type [float]"
argument_list|)
throw|;
block|}
DECL|method|ush
specifier|private
specifier|static
name|double
name|ush
parameter_list|(
name|double
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>>] operation to type [double]"
argument_list|)
throw|;
block|}
DECL|method|ush
specifier|private
specifier|static
name|boolean
name|ush
parameter_list|(
name|boolean
name|a
parameter_list|,
name|long
name|b
parameter_list|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>>] operation to type [boolean]"
argument_list|)
throw|;
block|}
DECL|method|ush
specifier|public
specifier|static
name|Object
name|ush
parameter_list|(
name|Object
name|left
parameter_list|,
name|long
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
name|left
argument_list|)
operator|>>>
name|right
return|;
block|}
else|else
block|{
return|return
name|intIntegralValue
argument_list|(
name|left
argument_list|)
operator|>>>
name|right
return|;
block|}
block|}
comment|/**       * unboxes a class to its primitive type, or returns the original       * class if its not a boxed type.      */
DECL|method|unbox
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|unbox
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
return|return
name|MethodType
operator|.
name|methodType
argument_list|(
name|clazz
argument_list|)
operator|.
name|unwrap
argument_list|()
operator|.
name|returnType
argument_list|()
return|;
block|}
comment|/** Unary promotion. All Objects are promoted to Object. */
DECL|method|promote
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|promote
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|)
block|{
comment|// if either is a non-primitive type -> Object.
if|if
condition|(
name|clazz
operator|.
name|isPrimitive
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
name|Object
operator|.
name|class
return|;
block|}
comment|// always promoted to integer
if|if
condition|(
name|clazz
operator|==
name|byte
operator|.
name|class
operator|||
name|clazz
operator|==
name|short
operator|.
name|class
operator|||
name|clazz
operator|==
name|char
operator|.
name|class
operator|||
name|clazz
operator|==
name|int
operator|.
name|class
condition|)
block|{
return|return
name|int
operator|.
name|class
return|;
block|}
else|else
block|{
return|return
name|clazz
return|;
block|}
block|}
comment|/** Binary promotion. */
DECL|method|promote
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|promote
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|a
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|b
parameter_list|)
block|{
comment|// if either is a non-primitive type -> Object.
if|if
condition|(
name|a
operator|.
name|isPrimitive
argument_list|()
operator|==
literal|false
operator|||
name|b
operator|.
name|isPrimitive
argument_list|()
operator|==
literal|false
condition|)
block|{
return|return
name|Object
operator|.
name|class
return|;
block|}
comment|// boolean -> boolean
if|if
condition|(
name|a
operator|==
name|boolean
operator|.
name|class
operator|&&
name|b
operator|==
name|boolean
operator|.
name|class
condition|)
block|{
return|return
name|boolean
operator|.
name|class
return|;
block|}
comment|// ordinary numeric promotion
if|if
condition|(
name|a
operator|==
name|double
operator|.
name|class
operator|||
name|b
operator|==
name|double
operator|.
name|class
condition|)
block|{
return|return
name|double
operator|.
name|class
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|float
operator|.
name|class
operator|||
name|b
operator|==
name|float
operator|.
name|class
condition|)
block|{
return|return
name|float
operator|.
name|class
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|long
operator|.
name|class
operator|||
name|b
operator|==
name|long
operator|.
name|class
condition|)
block|{
return|return
name|long
operator|.
name|class
return|;
block|}
else|else
block|{
return|return
name|int
operator|.
name|class
return|;
block|}
block|}
DECL|field|PRIV_LOOKUP
specifier|private
specifier|static
specifier|final
name|Lookup
name|PRIV_LOOKUP
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
decl_stmt|;
DECL|field|TYPE_OP_MAPPING
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
argument_list|>
name|TYPE_OP_MAPPING
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|long
operator|.
name|class
argument_list|,
name|float
operator|.
name|class
argument_list|,
name|double
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|type
lambda|->
block|{
try|try
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|MethodHandle
argument_list|>
name|map
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
name|MethodType
name|unary
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|MethodType
name|binary
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|type
argument_list|,
name|type
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|MethodType
name|comparison
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
name|type
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|MethodType
name|shift
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|type
argument_list|,
name|type
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|PRIV_LOOKUP
operator|.
name|lookupClass
argument_list|()
decl_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"not"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"not"
argument_list|,
name|unary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"neg"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"neg"
argument_list|,
name|unary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"plus"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"plus"
argument_list|,
name|unary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"mul"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"mul"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"div"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"div"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"rem"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"rem"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"add"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"add"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"sub"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"sub"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"and"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"and"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"or"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"or"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"xor"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"xor"
argument_list|,
name|binary
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"eq"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"eq"
argument_list|,
name|comparison
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"lt"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"lt"
argument_list|,
name|comparison
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"lte"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"lte"
argument_list|,
name|comparison
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"gt"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"gt"
argument_list|,
name|comparison
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"gte"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"gte"
argument_list|,
name|comparison
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"lsh"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"lsh"
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"rsh"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"rsh"
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
literal|"ush"
argument_list|,
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|clazz
argument_list|,
literal|"ush"
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|map
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/** Returns an appropriate method handle for a unary or shift operator, based only on the receiver (LHS) */
DECL|method|lookupUnary
specifier|public
specifier|static
name|MethodHandle
name|lookupUnary
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|MethodHandle
name|handle
init|=
name|TYPE_OP_MAPPING
operator|.
name|get
argument_list|(
name|promote
argument_list|(
name|unbox
argument_list|(
name|receiverClass
argument_list|)
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply operator ["
operator|+
name|name
operator|+
literal|"] to type ["
operator|+
name|receiverClass
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|handle
return|;
block|}
comment|/** Returns an appropriate method handle for a binary operator, based on promotion of the LHS and RHS arguments */
DECL|method|lookupBinary
specifier|public
specifier|static
name|MethodHandle
name|lookupBinary
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|classA
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|classB
parameter_list|,
name|String
name|name
parameter_list|)
block|{
name|MethodHandle
name|handle
init|=
name|TYPE_OP_MAPPING
operator|.
name|get
argument_list|(
name|promote
argument_list|(
name|promote
argument_list|(
name|unbox
argument_list|(
name|classA
argument_list|)
argument_list|)
argument_list|,
name|promote
argument_list|(
name|unbox
argument_list|(
name|classB
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply operator ["
operator|+
name|name
operator|+
literal|"] to types ["
operator|+
name|classA
operator|+
literal|"] and ["
operator|+
name|classB
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|handle
return|;
block|}
comment|/** Returns a generic method handle for any operator, that can handle all valid signatures, nulls, corner cases */
DECL|method|lookupGeneric
specifier|public
specifier|static
name|MethodHandle
name|lookupGeneric
parameter_list|(
name|String
name|name
parameter_list|)
block|{
return|return
name|TYPE_OP_MAPPING
operator|.
name|get
argument_list|(
name|Object
operator|.
name|class
argument_list|)
operator|.
name|get
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|/**      * Slow dynamic cast: casts {@code returnValue} to the runtime type of {@code lhs}      * based upon inspection. If {@code lhs} is null, no cast takes place.      * This is used for the generic fallback case of compound assignment.      */
DECL|method|dynamicReceiverCast
specifier|static
name|Object
name|dynamicReceiverCast
parameter_list|(
name|Object
name|returnValue
parameter_list|,
name|Object
name|lhs
parameter_list|)
block|{
if|if
condition|(
name|lhs
operator|!=
literal|null
condition|)
block|{
return|return
name|dynamicCast
argument_list|(
name|lhs
operator|.
name|getClass
argument_list|()
argument_list|,
name|returnValue
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|returnValue
return|;
block|}
block|}
comment|/**      * Slow dynamic cast: casts {@code value} to an instance of {@code clazz}      * based upon inspection. If {@code lhs} is null, no cast takes place.      */
DECL|method|dynamicCast
specifier|static
name|Object
name|dynamicCast
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|clazz
operator|==
name|value
operator|.
name|getClass
argument_list|()
condition|)
block|{
return|return
name|value
return|;
block|}
if|if
condition|(
name|clazz
operator|==
name|Integer
operator|.
name|class
condition|)
block|{
return|return
name|getNumber
argument_list|(
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
name|Long
operator|.
name|class
condition|)
block|{
return|return
name|getNumber
argument_list|(
name|value
argument_list|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
name|Double
operator|.
name|class
condition|)
block|{
return|return
name|getNumber
argument_list|(
name|value
argument_list|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
name|Float
operator|.
name|class
condition|)
block|{
return|return
name|getNumber
argument_list|(
name|value
argument_list|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
name|Short
operator|.
name|class
condition|)
block|{
return|return
name|getNumber
argument_list|(
name|value
argument_list|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
name|Byte
operator|.
name|class
condition|)
block|{
return|return
name|getNumber
argument_list|(
name|value
argument_list|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|clazz
operator|==
name|Character
operator|.
name|class
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|getNumber
argument_list|(
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
return|return
name|clazz
operator|.
name|cast
argument_list|(
name|value
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|value
return|;
block|}
block|}
comment|/** Slowly returns a Number for o. Just for supporting dynamicCast */
DECL|method|getNumber
specifier|static
name|Number
name|getNumber
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|Number
operator|)
name|o
return|;
block|}
elseif|else
if|if
condition|(
name|o
operator|instanceof
name|Character
condition|)
block|{
return|return
name|Integer
operator|.
name|valueOf
argument_list|(
operator|(
name|char
operator|)
name|o
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot convert ["
operator|+
name|o
operator|.
name|getClass
argument_list|()
operator|+
literal|"] to a Number"
argument_list|)
throw|;
block|}
block|}
DECL|field|DYNAMIC_CAST
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|DYNAMIC_CAST
decl_stmt|;
DECL|field|DYNAMIC_RECEIVER_CAST
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|DYNAMIC_RECEIVER_CAST
decl_stmt|;
static|static
block|{
specifier|final
name|Lookup
name|lookup
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
decl_stmt|;
try|try
block|{
name|DYNAMIC_CAST
operator|=
name|lookup
operator|.
name|findStatic
argument_list|(
name|lookup
operator|.
name|lookupClass
argument_list|()
argument_list|,
literal|"dynamicCast"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Class
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|DYNAMIC_RECEIVER_CAST
operator|=
name|lookup
operator|.
name|findStatic
argument_list|(
name|lookup
operator|.
name|lookupClass
argument_list|()
argument_list|,
literal|"dynamicReceiverCast"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/** Looks up generic method, with a dynamic cast to the receiver's type. (compound assignment) */
DECL|method|dynamicCast
specifier|public
specifier|static
name|MethodHandle
name|dynamicCast
parameter_list|(
name|MethodHandle
name|target
parameter_list|)
block|{
comment|// adapt dynamic receiver cast to the generic method
name|MethodHandle
name|cast
init|=
name|DYNAMIC_RECEIVER_CAST
operator|.
name|asType
argument_list|(
name|MethodType
operator|.
name|methodType
argument_list|(
name|target
operator|.
name|type
argument_list|()
operator|.
name|returnType
argument_list|()
argument_list|,
name|target
operator|.
name|type
argument_list|()
operator|.
name|returnType
argument_list|()
argument_list|,
name|target
operator|.
name|type
argument_list|()
operator|.
name|parameterType
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// drop the RHS parameter
name|cast
operator|=
name|MethodHandles
operator|.
name|dropArguments
argument_list|(
name|cast
argument_list|,
literal|2
argument_list|,
name|target
operator|.
name|type
argument_list|()
operator|.
name|parameterType
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|// combine: f(x,y) -> g(f(x,y), x, y);
return|return
name|MethodHandles
operator|.
name|foldArguments
argument_list|(
name|cast
argument_list|,
name|target
argument_list|)
return|;
block|}
comment|/** Looks up generic method, with a dynamic cast to the specified type. (explicit assignment) */
DECL|method|dynamicCast
specifier|public
specifier|static
name|MethodHandle
name|dynamicCast
parameter_list|(
name|MethodHandle
name|target
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|desired
parameter_list|)
block|{
comment|// adapt dynamic cast to the generic method
name|desired
operator|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|desired
argument_list|)
operator|.
name|wrap
argument_list|()
operator|.
name|returnType
argument_list|()
expr_stmt|;
comment|// bind to the boxed type
name|MethodHandle
name|cast
init|=
name|DYNAMIC_CAST
operator|.
name|bindTo
argument_list|(
name|desired
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|filterReturnValue
argument_list|(
name|target
argument_list|,
name|cast
argument_list|)
return|;
block|}
comment|/** Forces a cast to class A for target (only if types differ) */
DECL|method|cast
specifier|public
specifier|static
name|MethodHandle
name|cast
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|classA
parameter_list|,
name|MethodHandle
name|target
parameter_list|)
block|{
name|MethodType
name|newType
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|classA
argument_list|)
operator|.
name|unwrap
argument_list|()
decl_stmt|;
name|MethodType
name|targetType
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|target
operator|.
name|type
argument_list|()
operator|.
name|returnType
argument_list|()
argument_list|)
operator|.
name|unwrap
argument_list|()
decl_stmt|;
comment|// don't do a conversion if types are the same. explicitCastArguments has this opto,
comment|// but we do it explicitly, to make the boolean check simpler
if|if
condition|(
name|newType
operator|.
name|returnType
argument_list|()
operator|==
name|targetType
operator|.
name|returnType
argument_list|()
condition|)
block|{
return|return
name|target
return|;
block|}
comment|// we don't allow the to/from boolean conversions of explicitCastArguments
if|if
condition|(
name|newType
operator|.
name|returnType
argument_list|()
operator|==
name|boolean
operator|.
name|class
operator|||
name|targetType
operator|.
name|returnType
argument_list|()
operator|==
name|boolean
operator|.
name|class
condition|)
block|{
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot cast "
operator|+
name|targetType
operator|.
name|returnType
argument_list|()
operator|+
literal|" to "
operator|+
name|newType
operator|.
name|returnType
argument_list|()
argument_list|)
throw|;
block|}
comment|// null return values are not possible for our arguments.
return|return
name|MethodHandles
operator|.
name|explicitCastArguments
argument_list|(
name|target
argument_list|,
name|target
operator|.
name|type
argument_list|()
operator|.
name|changeReturnType
argument_list|(
name|newType
operator|.
name|returnType
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

