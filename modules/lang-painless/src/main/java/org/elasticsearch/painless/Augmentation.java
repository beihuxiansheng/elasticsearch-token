begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|TreeMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|BiPredicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Consumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|ObjIntConsumer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|ToDoubleFunction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/** Additional methods added to classes. These must be static methods with receiver as first argument */
end_comment

begin_class
DECL|class|Augmentation
specifier|public
class|class
name|Augmentation
block|{
comment|// static methods only!
DECL|method|Augmentation
specifier|private
name|Augmentation
parameter_list|()
block|{}
comment|/** Exposes List.size() as getLength(), so that .length shortcut works on lists */
DECL|method|getLength
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|getLength
parameter_list|(
name|List
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|)
block|{
return|return
name|receiver
operator|.
name|size
argument_list|()
return|;
block|}
comment|/** Exposes Matcher.group(String) as namedGroup(String), so it doesn't conflict with group(int) */
DECL|method|namedGroup
specifier|public
specifier|static
name|String
name|namedGroup
parameter_list|(
name|Matcher
name|receiver
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|receiver
operator|.
name|group
argument_list|(
name|name
argument_list|)
return|;
block|}
comment|// some groovy methods on iterable
comment|// see http://docs.groovy-lang.org/latest/html/groovy-jdk/java/lang/Iterable.html
comment|/** Iterates over the contents of an iterable, and checks whether a predicate is valid for at least one element. */
DECL|method|any
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|any
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Predicate
argument_list|<
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|t
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/** Converts this Iterable to a Collection. Returns the original Iterable if it is already a Collection. */
DECL|method|asCollection
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|asCollection
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|instanceof
name|Collection
condition|)
block|{
return|return
operator|(
name|Collection
argument_list|<
name|T
argument_list|>
operator|)
name|receiver
return|;
block|}
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** Converts this Iterable to a List. Returns the original Iterable if it is already a List. */
DECL|method|asList
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|asList
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|)
block|{
if|if
condition|(
name|receiver
operator|instanceof
name|List
condition|)
block|{
return|return
operator|(
name|List
argument_list|<
name|T
argument_list|>
operator|)
name|receiver
return|;
block|}
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/** Counts the number of occurrences which satisfy the given predicate from inside this Iterable. */
DECL|method|count
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|int
name|count
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Predicate
argument_list|<
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|// instead of covariant overrides for every possibility, we just return receiver as 'def' for now
comment|// that way if someone chains the calls, everything works.
comment|/** Iterates through an Iterable, passing each item to the given consumer. */
DECL|method|each
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Object
name|each
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Consumer
argument_list|<
name|T
argument_list|>
name|consumer
parameter_list|)
block|{
name|receiver
operator|.
name|forEach
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
return|return
name|receiver
return|;
block|}
comment|/**       * Iterates through an iterable type, passing each item and the item's index       * (a counter starting at zero) to the given consumer.      */
DECL|method|eachWithIndex
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|Object
name|eachWithIndex
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|ObjIntConsumer
argument_list|<
name|T
argument_list|>
name|consumer
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|consumer
operator|.
name|accept
argument_list|(
name|t
argument_list|,
name|count
operator|++
argument_list|)
expr_stmt|;
block|}
return|return
name|receiver
return|;
block|}
comment|/**      * Used to determine if the given predicate is valid (i.e. returns true for all items in this iterable).      */
DECL|method|every
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|boolean
name|every
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Predicate
argument_list|<
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|t
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Iterates through the Iterable transforming items using the supplied function and       * collecting any non-null results.       */
DECL|method|findResults
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
name|List
argument_list|<
name|U
argument_list|>
name|findResults
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|filter
parameter_list|)
block|{
name|List
argument_list|<
name|U
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|U
name|result
init|=
name|filter
operator|.
name|apply
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**      * Sorts all Iterable members into groups determined by the supplied mapping function.       */
DECL|method|groupBy
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
name|Map
argument_list|<
name|U
argument_list|,
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|mapper
parameter_list|)
block|{
name|Map
argument_list|<
name|U
argument_list|,
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|U
name|mapped
init|=
name|mapper
operator|.
name|apply
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|results
init|=
name|map
operator|.
name|get
argument_list|(
name|mapped
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|==
literal|null
condition|)
block|{
name|results
operator|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|mapped
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|/**      * Concatenates the toString() representation of each item in this Iterable,       * with the given String as a separator between each item.       */
DECL|method|join
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|String
name|join
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|String
name|separator
parameter_list|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
if|if
condition|(
name|sb
operator|.
name|length
argument_list|()
operator|>
literal|0
condition|)
block|{
name|sb
operator|.
name|append
argument_list|(
name|separator
argument_list|)
expr_stmt|;
block|}
name|sb
operator|.
name|append
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Sums the result of an Iterable      */
DECL|method|sum
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|Number
parameter_list|>
name|double
name|sum
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|)
block|{
name|double
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|sum
operator|+=
name|t
operator|.
name|doubleValue
argument_list|()
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|/**      * Sums the result of applying a function to each item of an Iterable.       */
DECL|method|sum
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|double
name|sum
parameter_list|(
name|Iterable
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|ToDoubleFunction
argument_list|<
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|double
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|sum
operator|+=
name|function
operator|.
name|applyAsDouble
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
comment|// some groovy methods on collection
comment|// see http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Collection.html
comment|/**      * Iterates through this collection transforming each entry into a new value using       * the function, returning a list of transformed values.       */
DECL|method|collect
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
name|List
argument_list|<
name|U
argument_list|>
name|collect
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|function
parameter_list|)
block|{
name|List
argument_list|<
name|U
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**      * Iterates through this collection transforming each entry into a new value using       * the function, adding the values to the specified collection.      */
DECL|method|collect
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
name|Object
name|collect
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Collection
argument_list|<
name|U
argument_list|>
name|collection
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|function
parameter_list|)
block|{
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|collection
operator|.
name|add
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|collection
return|;
block|}
comment|/**      * Finds the first value matching the predicate, or returns null.      */
DECL|method|find
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|T
name|find
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Predicate
argument_list|<
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|t
argument_list|)
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Finds all values matching the predicate, returns as a list      */
DECL|method|findAll
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|findAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Predicate
argument_list|<
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**      * Iterates through the collection calling the given function for each item       * but stopping once the first non-null result is found and returning that result.       * If all results are null, null is returned.       */
DECL|method|findResult
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
name|Object
name|findResult
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|findResult
argument_list|(
name|receiver
argument_list|,
literal|null
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/**      * Iterates through the collection calling the given function for each item       * but stopping once the first non-null result is found and returning that result.       * If all results are null, defaultResult is returned.      */
DECL|method|findResult
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
name|Object
name|findResult
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Object
name|defaultResult
parameter_list|,
name|Function
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|function
parameter_list|)
block|{
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
name|U
name|value
init|=
name|function
operator|.
name|apply
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
block|}
return|return
name|defaultResult
return|;
block|}
comment|/**      * Splits all items into two collections based on the predicate.       * The first list contains all items which match the closure expression. The second list all those that don't.       */
DECL|method|split
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|split
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|receiver
parameter_list|,
name|Predicate
argument_list|<
name|T
argument_list|>
name|predicate
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|matched
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|T
argument_list|>
name|unmatched
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|List
argument_list|<
name|T
argument_list|>
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|result
operator|.
name|add
argument_list|(
name|matched
argument_list|)
expr_stmt|;
name|result
operator|.
name|add
argument_list|(
name|unmatched
argument_list|)
expr_stmt|;
for|for
control|(
name|T
name|t
range|:
name|receiver
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|matched
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unmatched
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
comment|// some groovy methods on map
comment|// see http://docs.groovy-lang.org/latest/html/groovy-jdk/java/util/Map.html
comment|/**      * Iterates through this map transforming each entry into a new value using       * the function, returning a list of transformed values.       */
DECL|method|collect
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|collect
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|T
argument_list|>
name|function
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|list
operator|.
name|add
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**      * Iterates through this map transforming each entry into a new value using       * the function, adding the values to the specified collection.      */
DECL|method|collect
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|T
parameter_list|>
name|Object
name|collect
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|collection
parameter_list|,
name|BiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|T
argument_list|>
name|function
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|collection
operator|.
name|add
argument_list|(
name|function
operator|.
name|apply
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|collection
return|;
block|}
comment|/** Counts the number of occurrences which satisfy the given predicate from inside this Map */
DECL|method|count
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|int
name|count
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiPredicate
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|predicate
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/** Iterates through a Map, passing each item to the given consumer. */
DECL|method|each
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Object
name|each
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiConsumer
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|consumer
parameter_list|)
block|{
name|receiver
operator|.
name|forEach
argument_list|(
name|consumer
argument_list|)
expr_stmt|;
return|return
name|receiver
return|;
block|}
comment|/**      * Used to determine if the given predicate is valid (i.e. returns true for all items in this map).      */
DECL|method|every
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|every
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiPredicate
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
operator|==
literal|false
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Finds the first entry matching the predicate, or returns null.      */
DECL|method|find
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiPredicate
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|predicate
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|kvPair
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Finds all values matching the predicate, returns as a map.      */
DECL|method|findAll
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|findAll
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiPredicate
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|predicate
parameter_list|)
block|{
comment|// try to preserve some properties of the receiver (see the groovy javadocs)
specifier|final
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
if|if
condition|(
name|receiver
operator|instanceof
name|TreeMap
condition|)
block|{
name|map
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|predicate
operator|.
name|test
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
condition|)
block|{
name|map
operator|.
name|put
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|map
return|;
block|}
comment|/**      * Iterates through the map calling the given function for each item       * but stopping once the first non-null result is found and returning that result.       * If all results are null, null is returned.       */
DECL|method|findResult
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|T
parameter_list|>
name|Object
name|findResult
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|T
argument_list|>
name|function
parameter_list|)
block|{
return|return
name|findResult
argument_list|(
name|receiver
argument_list|,
literal|null
argument_list|,
name|function
argument_list|)
return|;
block|}
comment|/**      * Iterates through the map calling the given function for each item       * but stopping once the first non-null result is found and returning that result.       * If all results are null, defaultResult is returned.      */
DECL|method|findResult
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|T
parameter_list|>
name|Object
name|findResult
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|Object
name|defaultResult
parameter_list|,
name|BiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|T
argument_list|>
name|function
parameter_list|)
block|{
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|T
name|value
init|=
name|function
operator|.
name|apply
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
block|{
return|return
name|value
return|;
block|}
block|}
return|return
name|defaultResult
return|;
block|}
comment|/**      * Iterates through the map transforming items using the supplied function and       * collecting any non-null results.       */
DECL|method|findResults
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|T
parameter_list|>
name|List
argument_list|<
name|T
argument_list|>
name|findResults
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|T
argument_list|>
name|filter
parameter_list|)
block|{
name|List
argument_list|<
name|T
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|T
name|result
init|=
name|filter
operator|.
name|apply
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
block|{
name|list
operator|.
name|add
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|list
return|;
block|}
comment|/**      * Sorts all Map members into groups determined by the supplied mapping function.       */
DECL|method|groupBy
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|T
parameter_list|>
name|Map
argument_list|<
name|T
argument_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|groupBy
parameter_list|(
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|receiver
parameter_list|,
name|BiFunction
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|T
argument_list|>
name|mapper
parameter_list|)
block|{
name|Map
argument_list|<
name|T
argument_list|,
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|map
init|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|kvPair
range|:
name|receiver
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|T
name|mapped
init|=
name|mapper
operator|.
name|apply
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|results
init|=
name|map
operator|.
name|get
argument_list|(
name|mapped
argument_list|)
decl_stmt|;
if|if
condition|(
name|results
operator|==
literal|null
condition|)
block|{
comment|// try to preserve some properties of the receiver (see the groovy javadocs)
if|if
condition|(
name|receiver
operator|instanceof
name|TreeMap
condition|)
block|{
name|results
operator|=
operator|new
name|TreeMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|results
operator|=
operator|new
name|LinkedHashMap
argument_list|<>
argument_list|()
expr_stmt|;
block|}
name|map
operator|.
name|put
argument_list|(
name|mapped
argument_list|,
name|results
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|put
argument_list|(
name|kvPair
operator|.
name|getKey
argument_list|()
argument_list|,
name|kvPair
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
comment|// CharSequence augmentation
comment|/**      * Replace all matches. Similar to {@link Matcher#replaceAll(String)} but allows you to customize the replacement based on the match.      */
DECL|method|replaceAll
specifier|public
specifier|static
name|String
name|replaceAll
parameter_list|(
name|CharSequence
name|receiver
parameter_list|,
name|Pattern
name|pattern
parameter_list|,
name|Function
argument_list|<
name|Matcher
argument_list|,
name|String
argument_list|>
name|replacementBuilder
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
if|if
condition|(
literal|false
operator|==
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// CharSequqence's toString is *supposed* to always return the characters in the sequence as a String
return|return
name|receiver
operator|.
name|toString
argument_list|()
return|;
block|}
name|StringBuffer
name|result
init|=
operator|new
name|StringBuffer
argument_list|(
name|initialBufferForReplaceWith
argument_list|(
name|receiver
argument_list|)
argument_list|)
decl_stmt|;
do|do
block|{
name|m
operator|.
name|appendReplacement
argument_list|(
name|result
argument_list|,
name|Matcher
operator|.
name|quoteReplacement
argument_list|(
name|replacementBuilder
operator|.
name|apply
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|.
name|find
argument_list|()
condition|)
do|;
name|m
operator|.
name|appendTail
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Replace the first match. Similar to {@link Matcher#replaceFirst(String)} but allows you to customize the replacement based on the      * match.      */
DECL|method|replaceFirst
specifier|public
specifier|static
name|String
name|replaceFirst
parameter_list|(
name|CharSequence
name|receiver
parameter_list|,
name|Pattern
name|pattern
parameter_list|,
name|Function
argument_list|<
name|Matcher
argument_list|,
name|String
argument_list|>
name|replacementBuilder
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|receiver
argument_list|)
decl_stmt|;
if|if
condition|(
literal|false
operator|==
name|m
operator|.
name|find
argument_list|()
condition|)
block|{
comment|// CharSequqence's toString is *supposed* to always return the characters in the sequence as a String
return|return
name|receiver
operator|.
name|toString
argument_list|()
return|;
block|}
name|StringBuffer
name|result
init|=
operator|new
name|StringBuffer
argument_list|(
name|initialBufferForReplaceWith
argument_list|(
name|receiver
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|.
name|appendReplacement
argument_list|(
name|result
argument_list|,
name|Matcher
operator|.
name|quoteReplacement
argument_list|(
name|replacementBuilder
operator|.
name|apply
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|.
name|appendTail
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * The initial size of the {@link StringBuilder} used for {@link #replaceFirst(CharSequence, Pattern, Function)} and      * {@link #replaceAll(CharSequence, Pattern, Function)} for a particular sequence. We ape      * {{@link StringBuilder#StringBuilder(CharSequence)} here and add 16 extra chars to the buffer to have a little room for growth.      */
DECL|method|initialBufferForReplaceWith
specifier|private
specifier|static
name|int
name|initialBufferForReplaceWith
parameter_list|(
name|CharSequence
name|seq
parameter_list|)
block|{
return|return
name|seq
operator|.
name|length
argument_list|()
operator|+
literal|16
return|;
block|}
block|}
end_class

end_unit

