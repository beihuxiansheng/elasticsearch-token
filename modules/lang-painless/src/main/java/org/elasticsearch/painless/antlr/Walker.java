begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless.antlr
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
package|;
end_package

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|ANTLRInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|BaseErrorListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|CommonTokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|DiagnosticErrorListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|ParserRuleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|RecognitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|Recognizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|atn
operator|.
name|PredictionMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TerminalNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|CompilerSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Locals
operator|.
name|ExecuteReserved
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Locals
operator|.
name|FunctionReserved
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Locals
operator|.
name|Reserved
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|AfterthoughtContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ArgumentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ArgumentsContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|AssignmentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BinaryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BlockContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BoolContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BraceaccessContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BreakContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CallinvokeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CalllocalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CastContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ChainprecContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CompContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ConditionalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ContinueContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DeclContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DeclarationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DecltypeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DeclvarContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DelimiterContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DoContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DynamicContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|EachContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|EmptyContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ExprContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ExpressionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ExprprecContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|FalseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|FieldaccessContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ForContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|FuncrefContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|FunctionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|IfContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|InitializerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NewarrayContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NewobjectContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NullContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NumericContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|OperatorContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ParametersContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|PostContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|PreContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ReadContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ReturnContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|SecondaryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|SingleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|SourceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|StatementContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|StaticContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|StringContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ThrowContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TrailerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TrapContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TrueContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|UnaryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|VariableContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|WhileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|AExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ALink
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ANode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|AStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EBinary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EBool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ECapturingFunctionRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EChain
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EComp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EConditional
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EExplicit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EFunctionRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ENull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ENumeric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EUnary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LBrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LCallInvoke
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LCallLocal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LCast
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LNewArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LNewObj
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LStatic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|LVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SBreak
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SCatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SContinue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SDeclBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SDeclaration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SDo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SEach
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SFor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SIf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SIfElse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SReturn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SThrow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|STry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SWhile
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Converts the ANTLR tree to a Painless tree.  */
end_comment

begin_class
DECL|class|Walker
specifier|public
specifier|final
class|class
name|Walker
extends|extends
name|PainlessParserBaseVisitor
argument_list|<
name|Object
argument_list|>
block|{
DECL|method|buildPainlessTree
specifier|public
specifier|static
name|SSource
name|buildPainlessTree
parameter_list|(
name|String
name|sourceName
parameter_list|,
name|String
name|sourceText
parameter_list|,
name|CompilerSettings
name|settings
parameter_list|)
block|{
return|return
operator|new
name|Walker
argument_list|(
name|sourceName
argument_list|,
name|sourceText
argument_list|,
name|settings
argument_list|)
operator|.
name|source
return|;
block|}
DECL|field|source
specifier|private
specifier|final
name|SSource
name|source
decl_stmt|;
DECL|field|settings
specifier|private
specifier|final
name|CompilerSettings
name|settings
decl_stmt|;
DECL|field|sourceName
specifier|private
specifier|final
name|String
name|sourceName
decl_stmt|;
DECL|field|sourceText
specifier|private
specifier|final
name|String
name|sourceText
decl_stmt|;
DECL|field|reserved
specifier|private
specifier|final
name|Deque
argument_list|<
name|Reserved
argument_list|>
name|reserved
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|Walker
specifier|private
name|Walker
parameter_list|(
name|String
name|sourceName
parameter_list|,
name|String
name|sourceText
parameter_list|,
name|CompilerSettings
name|settings
parameter_list|)
block|{
name|this
operator|.
name|settings
operator|=
name|settings
expr_stmt|;
name|this
operator|.
name|sourceName
operator|=
name|Location
operator|.
name|computeSourceName
argument_list|(
name|sourceName
argument_list|,
name|sourceText
argument_list|)
expr_stmt|;
name|this
operator|.
name|sourceText
operator|=
name|sourceText
expr_stmt|;
name|this
operator|.
name|source
operator|=
operator|(
name|SSource
operator|)
name|visit
argument_list|(
name|buildAntlrTree
argument_list|(
name|sourceText
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|buildAntlrTree
specifier|private
name|SourceContext
name|buildAntlrTree
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|ANTLRInputStream
name|stream
init|=
operator|new
name|ANTLRInputStream
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|PainlessLexer
name|lexer
init|=
operator|new
name|ErrorHandlingLexer
argument_list|(
name|stream
argument_list|,
name|sourceName
argument_list|)
decl_stmt|;
name|PainlessParser
name|parser
init|=
operator|new
name|PainlessParser
argument_list|(
operator|new
name|CommonTokenStream
argument_list|(
name|lexer
argument_list|)
argument_list|)
decl_stmt|;
name|ParserErrorStrategy
name|strategy
init|=
operator|new
name|ParserErrorStrategy
argument_list|(
name|sourceName
argument_list|)
decl_stmt|;
name|lexer
operator|.
name|removeErrorListeners
argument_list|()
expr_stmt|;
name|parser
operator|.
name|removeErrorListeners
argument_list|()
expr_stmt|;
if|if
condition|(
name|settings
operator|.
name|isPicky
argument_list|()
condition|)
block|{
name|setupPicky
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|parser
operator|.
name|setErrorHandler
argument_list|(
name|strategy
argument_list|)
expr_stmt|;
return|return
name|parser
operator|.
name|source
argument_list|()
return|;
block|}
DECL|method|setupPicky
specifier|private
name|void
name|setupPicky
parameter_list|(
name|PainlessParser
name|parser
parameter_list|)
block|{
comment|// Diagnostic listener invokes syntaxError on other listeners for ambiguity issues,
name|parser
operator|.
name|addErrorListener
argument_list|(
operator|new
name|DiagnosticErrorListener
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// a second listener to fail the test when the above happens.
name|parser
operator|.
name|addErrorListener
argument_list|(
operator|new
name|BaseErrorListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|syntaxError
parameter_list|(
specifier|final
name|Recognizer
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|recognizer
parameter_list|,
specifier|final
name|Object
name|offendingSymbol
parameter_list|,
specifier|final
name|int
name|line
parameter_list|,
specifier|final
name|int
name|charPositionInLine
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|RecognitionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"line: "
operator|+
name|line
operator|+
literal|", offset: "
operator|+
name|charPositionInLine
operator|+
literal|", symbol:"
operator|+
name|offendingSymbol
operator|+
literal|" "
operator|+
name|msg
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Enable exact ambiguity detection (costly). we enable exact since its the default for
comment|// DiagnosticErrorListener, life is too short to think about what 'inexact ambiguity' might mean.
name|parser
operator|.
name|getInterpreter
argument_list|()
operator|.
name|setPredictionMode
argument_list|(
name|PredictionMode
operator|.
name|LL_EXACT_AMBIG_DETECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|location
specifier|private
name|Location
name|location
parameter_list|(
name|ParserRuleContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|Location
argument_list|(
name|sourceName
argument_list|,
name|ctx
operator|.
name|getStart
argument_list|()
operator|.
name|getStartIndex
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitSource
specifier|public
name|Object
name|visitSource
parameter_list|(
name|SourceContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|push
argument_list|(
operator|new
name|ExecuteReserved
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SFunction
argument_list|>
name|functions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FunctionContext
name|function
range|:
name|ctx
operator|.
name|function
argument_list|()
control|)
block|{
name|functions
operator|.
name|add
argument_list|(
operator|(
name|SFunction
operator|)
name|visit
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StatementContext
name|statement
range|:
name|ctx
operator|.
name|statement
argument_list|()
control|)
block|{
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SSource
argument_list|(
name|sourceName
argument_list|,
name|sourceText
argument_list|,
operator|(
name|ExecuteReserved
operator|)
name|reserved
operator|.
name|pop
argument_list|()
argument_list|,
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|functions
argument_list|,
name|statements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFunction
specifier|public
name|Object
name|visitFunction
parameter_list|(
name|FunctionContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|push
argument_list|(
operator|new
name|FunctionReserved
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|rtnType
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paramTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paramNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DecltypeContext
name|decltype
range|:
name|ctx
operator|.
name|parameters
argument_list|()
operator|.
name|decltype
argument_list|()
control|)
block|{
name|paramTypes
operator|.
name|add
argument_list|(
name|decltype
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TerminalNode
name|id
range|:
name|ctx
operator|.
name|parameters
argument_list|()
operator|.
name|ID
argument_list|()
control|)
block|{
name|paramNames
operator|.
name|add
argument_list|(
name|id
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|StatementContext
name|statement
range|:
name|ctx
operator|.
name|block
argument_list|()
operator|.
name|statement
argument_list|()
control|)
block|{
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SFunction
argument_list|(
operator|(
name|FunctionReserved
operator|)
name|reserved
operator|.
name|pop
argument_list|()
argument_list|,
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|rtnType
argument_list|,
name|name
argument_list|,
name|paramTypes
argument_list|,
name|paramNames
argument_list|,
name|statements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitParameters
specifier|public
name|Object
name|visitParameters
parameter_list|(
name|ParametersContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitIf
specifier|public
name|Object
name|visitIf
parameter_list|(
name|IfContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|SBlock
name|ifblock
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|trailer
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|SBlock
name|elseblock
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|SIfElse
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
name|ifblock
argument_list|,
name|elseblock
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|SIf
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
name|ifblock
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitWhile
specifier|public
name|Object
name|visitWhile
parameter_list|(
name|WhileContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|trailer
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SWhile
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
name|block
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|empty
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|SWhile
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|" Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitDo
specifier|public
name|Object
name|visitDo
parameter_list|(
name|DoContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SDo
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|block
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFor
specifier|public
name|Object
name|visitFor
parameter_list|(
name|ForContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|ANode
name|initializer
init|=
name|ctx
operator|.
name|initializer
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|ANode
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|initializer
argument_list|()
argument_list|)
decl_stmt|;
name|AExpression
name|expression
init|=
name|ctx
operator|.
name|expression
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|AExpression
name|afterthought
init|=
name|ctx
operator|.
name|afterthought
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|afterthought
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|trailer
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SFor
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|initializer
argument_list|,
name|expression
argument_list|,
name|afterthought
argument_list|,
name|block
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|empty
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|SFor
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|initializer
argument_list|,
name|expression
argument_list|,
name|afterthought
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitEach
specifier|public
name|Object
name|visitEach
parameter_list|(
name|EachContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SEach
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|expression
argument_list|,
name|block
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDecl
specifier|public
name|Object
name|visitDecl
parameter_list|(
name|DeclContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|declaration
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitContinue
specifier|public
name|Object
name|visitContinue
parameter_list|(
name|ContinueContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|SContinue
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBreak
specifier|public
name|Object
name|visitBreak
parameter_list|(
name|BreakContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|SBreak
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitReturn
specifier|public
name|Object
name|visitReturn
parameter_list|(
name|ReturnContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SReturn
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitTry
specifier|public
name|Object
name|visitTry
parameter_list|(
name|TryContext
name|ctx
parameter_list|)
block|{
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SCatch
argument_list|>
name|catches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TrapContext
name|trap
range|:
name|ctx
operator|.
name|trap
argument_list|()
control|)
block|{
name|catches
operator|.
name|add
argument_list|(
operator|(
name|SCatch
operator|)
name|visit
argument_list|(
name|trap
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|STry
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|block
argument_list|,
name|catches
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitThrow
specifier|public
name|Object
name|visitThrow
parameter_list|(
name|ThrowContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SThrow
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitExpr
specifier|public
name|Object
name|visitExpr
parameter_list|(
name|ExprContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SExpression
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitTrailer
specifier|public
name|Object
name|visitTrailer
parameter_list|(
name|TrailerContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|block
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|statement
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|statement
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SBlock
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|statements
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitBlock
specifier|public
name|Object
name|visitBlock
parameter_list|(
name|BlockContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|statement
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StatementContext
name|statement
range|:
name|ctx
operator|.
name|statement
argument_list|()
control|)
block|{
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SBlock
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|statements
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitEmpty
specifier|public
name|Object
name|visitEmpty
parameter_list|(
name|EmptyContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitInitializer
specifier|public
name|Object
name|visitInitializer
parameter_list|(
name|InitializerContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|declaration
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|declaration
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|expression
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitAfterthought
specifier|public
name|Object
name|visitAfterthought
parameter_list|(
name|AfterthoughtContext
name|ctx
parameter_list|)
block|{
return|return
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDeclaration
specifier|public
name|Object
name|visitDeclaration
parameter_list|(
name|DeclarationContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SDeclaration
argument_list|>
name|declarations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DeclvarContext
name|declvar
range|:
name|ctx
operator|.
name|declvar
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|declvar
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|AExpression
name|expression
init|=
name|declvar
operator|.
name|expression
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|declvar
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|declarations
operator|.
name|add
argument_list|(
operator|new
name|SDeclaration
argument_list|(
name|location
argument_list|(
name|declvar
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SDeclBlock
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|declarations
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDecltype
specifier|public
name|Object
name|visitDecltype
parameter_list|(
name|DecltypeContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitFuncref
specifier|public
name|Object
name|visitFuncref
parameter_list|(
name|FuncrefContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|TYPE
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// non-capturing Type::method or Type::new
specifier|final
name|String
name|methodText
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|NEW
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|methodText
operator|=
name|ctx
operator|.
name|NEW
argument_list|()
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|methodText
operator|=
name|ctx
operator|.
name|ID
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|EFunctionRef
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|,
name|methodText
argument_list|)
return|;
block|}
else|else
block|{
comment|// capturing object::method
return|return
operator|new
name|ECapturingFunctionRef
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|ctx
operator|.
name|ID
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
name|ctx
operator|.
name|ID
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitDeclvar
specifier|public
name|Object
name|visitDeclvar
parameter_list|(
name|DeclvarContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitTrap
specifier|public
name|Object
name|visitTrap
parameter_list|(
name|TrapContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SCatch
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|block
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDelimiter
specifier|public
name|Object
name|visitDelimiter
parameter_list|(
name|DelimiterContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|visitExpression
specifier|private
name|Object
name|visitExpression
parameter_list|(
name|ExpressionContext
name|ctx
parameter_list|)
block|{
name|Object
name|expression
init|=
name|visit
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|expression
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|(
name|List
argument_list|<
name|ALink
argument_list|>
operator|)
name|expression
decl_stmt|;
return|return
operator|new
name|EChain
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|links
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|expression
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitSingle
specifier|public
name|Object
name|visitSingle
parameter_list|(
name|SingleContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBinary
specifier|public
name|Object
name|visitBinary
parameter_list|(
name|BinaryContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|MUL
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|MUL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DIV
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DIV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|REM
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|REM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADD
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|SUB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|LSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|RSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|RSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|USH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|USH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|XOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|XOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWOR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected state."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EBinary
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitComp
specifier|public
name|Object
name|visitComp
parameter_list|(
name|CompContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|LT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|LTE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|GT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|GT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|GTE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|GTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|EQ
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|EQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|EQR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|EQR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|NE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|NE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|NER
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|NER
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected state."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EComp
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBool
specifier|public
name|Object
name|visitBool
parameter_list|(
name|BoolContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|BOOLAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|AND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BOOLOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|OR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Unexpected state."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EBool
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitConditional
specifier|public
name|Object
name|visitConditional
parameter_list|(
name|ConditionalContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|condition
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|EConditional
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|condition
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitAssignment
specifier|public
name|Object
name|visitAssignment
parameter_list|(
name|AssignmentContext
name|ctx
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|(
name|List
argument_list|<
name|ALink
argument_list|>
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|chain
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|ASSIGN
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AMUL
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|MUL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADIV
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DIV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AREM
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|REM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AADD
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ASUB
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|SUB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ALSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ARSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|RSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AUSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|USH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AXOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|XOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWOR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|EChain
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|links
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|operation
argument_list|,
name|expression
argument_list|)
return|;
block|}
DECL|method|visitUnary
specifier|private
name|Object
name|visitUnary
parameter_list|(
name|UnaryContext
name|ctx
parameter_list|)
block|{
name|Object
name|expression
init|=
name|visit
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|expression
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|(
name|List
argument_list|<
name|ALink
argument_list|>
operator|)
name|expression
decl_stmt|;
return|return
operator|new
name|EChain
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|links
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|expression
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitPre
specifier|public
name|Object
name|visitPre
parameter_list|(
name|PreContext
name|ctx
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|(
name|List
argument_list|<
name|ALink
argument_list|>
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|chain
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|INCR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|INCR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DECR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DECR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EChain
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|links
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|operation
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitPost
specifier|public
name|Object
name|visitPost
parameter_list|(
name|PostContext
name|ctx
parameter_list|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|(
name|List
argument_list|<
name|ALink
argument_list|>
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|chain
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|INCR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|INCR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DECR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DECR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EChain
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|links
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|operation
argument_list|,
literal|null
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitRead
specifier|public
name|Object
name|visitRead
parameter_list|(
name|ReadContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|chain
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNumeric
specifier|public
name|Object
name|visitNumeric
parameter_list|(
name|NumericContext
name|ctx
parameter_list|)
block|{
specifier|final
name|boolean
name|negate
init|=
name|ctx
operator|.
name|parent
operator|instanceof
name|OperatorContext
operator|&&
operator|(
operator|(
name|OperatorContext
operator|)
name|ctx
operator|.
name|parent
operator|)
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|DECIMAL
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|EDecimal
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|DECIMAL
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|HEX
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ENumeric
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|HEX
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|16
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|INTEGER
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ENumeric
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|INTEGER
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|,
literal|10
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|OCTAL
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ENumeric
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|OCTAL
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|8
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitTrue
specifier|public
name|Object
name|visitTrue
parameter_list|(
name|TrueContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|EBoolean
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFalse
specifier|public
name|Object
name|visitFalse
parameter_list|(
name|FalseContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|EBoolean
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNull
specifier|public
name|Object
name|visitNull
parameter_list|(
name|NullContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|ENull
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitOperator
specifier|public
name|Object
name|visitOperator
parameter_list|(
name|OperatorContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
operator|&&
name|ctx
operator|.
name|unary
argument_list|()
operator|instanceof
name|NumericContext
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitUnary
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|BOOLNOT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|NOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWNOT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWNOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADD
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|SUB
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EUnary
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|expression
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitCast
specifier|public
name|Object
name|visitCast
parameter_list|(
name|CastContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|Object
name|child
init|=
name|visit
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|(
name|List
argument_list|<
name|ALink
argument_list|>
operator|)
name|child
decl_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|new
name|LCast
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|links
return|;
block|}
else|else
block|{
return|return
operator|new
name|EExplicit
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
operator|(
name|AExpression
operator|)
name|child
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitDynamic
specifier|public
name|Object
name|visitDynamic
parameter_list|(
name|DynamicContext
name|ctx
parameter_list|)
block|{
name|Object
name|child
init|=
name|visit
argument_list|(
name|ctx
operator|.
name|primary
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|instanceof
name|List
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|(
name|List
argument_list|<
name|ALink
argument_list|>
operator|)
name|child
decl_stmt|;
for|for
control|(
name|SecondaryContext
name|secondary
range|:
name|ctx
operator|.
name|secondary
argument_list|()
control|)
block|{
name|links
operator|.
name|add
argument_list|(
operator|(
name|ALink
operator|)
name|visit
argument_list|(
name|secondary
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|links
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ctx
operator|.
name|secondary
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
else|else
block|{
return|return
name|child
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitStatic
specifier|public
name|Object
name|visitStatic
parameter_list|(
name|StaticContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|new
name|LStatic
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|(
name|ALink
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|dot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SecondaryContext
name|secondary
range|:
name|ctx
operator|.
name|secondary
argument_list|()
control|)
block|{
name|links
operator|.
name|add
argument_list|(
operator|(
name|ALink
operator|)
name|visit
argument_list|(
name|secondary
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|links
return|;
block|}
annotation|@
name|Override
DECL|method|visitNewarray
specifier|public
name|Object
name|visitNewarray
parameter_list|(
name|NewarrayContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AExpression
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExpressionContext
name|expression
range|:
name|ctx
operator|.
name|expression
argument_list|()
control|)
block|{
name|expressions
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|new
name|LNewArray
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|expressions
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|dot
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|links
operator|.
name|add
argument_list|(
operator|(
name|ALink
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|dot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|SecondaryContext
name|secondary
range|:
name|ctx
operator|.
name|secondary
argument_list|()
control|)
block|{
name|links
operator|.
name|add
argument_list|(
operator|(
name|ALink
operator|)
name|visit
argument_list|(
name|secondary
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|ctx
operator|.
name|secondary
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
name|links
return|;
block|}
annotation|@
name|Override
DECL|method|visitExprprec
specifier|public
name|Object
name|visitExprprec
parameter_list|(
name|ExprprecContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitChainprec
specifier|public
name|Object
name|visitChainprec
parameter_list|(
name|ChainprecContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitString
specifier|public
name|Object
name|visitString
parameter_list|(
name|StringContext
name|ctx
parameter_list|)
block|{
name|String
name|string
init|=
name|ctx
operator|.
name|STRING
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|ctx
operator|.
name|STRING
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|new
name|LString
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|string
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|links
return|;
block|}
annotation|@
name|Override
DECL|method|visitVariable
specifier|public
name|Object
name|visitVariable
parameter_list|(
name|VariableContext
name|ctx
parameter_list|)
block|{
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|new
name|LVariable
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|markReserved
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|links
return|;
block|}
annotation|@
name|Override
DECL|method|visitCalllocal
specifier|public
name|Object
name|visitCalllocal
parameter_list|(
name|CalllocalContext
name|ctx
parameter_list|)
block|{
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
operator|(
name|List
argument_list|<
name|AExpression
argument_list|>
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|arguments
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|new
name|LCallLocal
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|name
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|links
return|;
block|}
annotation|@
name|Override
DECL|method|visitNewobject
specifier|public
name|Object
name|visitNewobject
parameter_list|(
name|NewobjectContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
operator|(
name|List
argument_list|<
name|AExpression
argument_list|>
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|arguments
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|ALink
argument_list|>
name|links
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|links
operator|.
name|add
argument_list|(
operator|new
name|LNewObj
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|arguments
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|links
return|;
block|}
annotation|@
name|Override
DECL|method|visitSecondary
specifier|public
name|Object
name|visitSecondary
parameter_list|(
name|SecondaryContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|dot
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|dot
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|brace
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|brace
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitCallinvoke
specifier|public
name|Object
name|visitCallinvoke
parameter_list|(
name|CallinvokeContext
name|ctx
parameter_list|)
block|{
name|String
name|name
init|=
name|ctx
operator|.
name|DOTID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
operator|(
name|List
argument_list|<
name|AExpression
argument_list|>
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|arguments
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|LCallInvoke
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|name
argument_list|,
name|arguments
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFieldaccess
specifier|public
name|Object
name|visitFieldaccess
parameter_list|(
name|FieldaccessContext
name|ctx
parameter_list|)
block|{
specifier|final
name|String
name|value
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|DOTID
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|ctx
operator|.
name|DOTID
argument_list|()
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DOTINTEGER
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|ctx
operator|.
name|DOTINTEGER
argument_list|()
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|LField
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBraceaccess
specifier|public
name|Object
name|visitBraceaccess
parameter_list|(
name|BraceaccessContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|LBrace
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitArguments
specifier|public
name|Object
name|visitArguments
parameter_list|(
name|ArgumentsContext
name|ctx
parameter_list|)
block|{
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ArgumentContext
name|argument
range|:
name|ctx
operator|.
name|argument
argument_list|()
control|)
block|{
name|arguments
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arguments
return|;
block|}
annotation|@
name|Override
DECL|method|visitArgument
specifier|public
name|Object
name|visitArgument
parameter_list|(
name|ArgumentContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|expression
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visitExpression
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|funcref
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|funcref
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

