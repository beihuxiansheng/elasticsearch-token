begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless.antlr
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
package|;
end_package

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|ANTLRInputStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|BaseErrorListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|CommonTokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|DiagnosticErrorListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|ParserRuleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|RecognitionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|Recognizer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|atn
operator|.
name|PredictionMode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|tree
operator|.
name|TerminalNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|CompilerSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Globals
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Location
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Operation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|AfterthoughtContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ArgumentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ArgumentsContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|AssignmentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BinaryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BlockContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BoolContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BraceaccessContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|BreakContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CallinvokeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CalllocalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CapturingfuncrefContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CastContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ClassfuncrefContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|CompContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ConditionalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ConstructorfuncrefContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ContinueContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DeclContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DeclarationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DecltypeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DeclvarContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DelimiterContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DoContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|DynamicContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|EachContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|EmptyContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ExprContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ExpressionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|FalseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|FieldaccessContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ForContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|FunctionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|IfContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|IneachContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|InitializerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|InstanceofContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|LambdaContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|LamtypeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ListinitContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ListinitializerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|LocalfuncrefContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|MapinitContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|MapinitializerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|MaptokenContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NewarrayContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NewinitializedarrayContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NewobjectContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NewstandardarrayContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NullContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|NumericContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|OperatorContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ParametersContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|PostContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|PostdotContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|PostfixContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|PreContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|PrecedenceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ReadContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|RegexContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ReturnContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|SingleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|SourceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|StatementContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|StaticContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|StringContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|ThrowContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TrailerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TrapContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TrueContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|TryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|VariableContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|antlr
operator|.
name|PainlessParser
operator|.
name|WhileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|AExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ANode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|AStatement
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EAssignment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EBinary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EBool
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EBoolean
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ECallLocal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ECapturingFunctionRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EComp
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EConditional
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EDecimal
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EExplicit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EFunctionRef
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EInstanceof
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ELambda
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EListInit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EMapInit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ENewArray
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ENewObj
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ENull
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ENumeric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|ERegex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EStatic
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EUnary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|EVariable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|PBrace
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|PCallInvoke
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|PField
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SBreak
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SCatch
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SContinue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SDeclBlock
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SDeclaration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SDo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SEach
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SExpression
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SFor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SFunction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SFunction
operator|.
name|FunctionReserved
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SIf
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SIfElse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SReturn
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SSource
operator|.
name|MainMethodReserved
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SSource
operator|.
name|Reserved
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SThrow
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|STry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|node
operator|.
name|SWhile
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|util
operator|.
name|Printer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Converts the ANTLR tree to a Painless tree.  */
end_comment

begin_class
DECL|class|Walker
specifier|public
specifier|final
class|class
name|Walker
extends|extends
name|PainlessParserBaseVisitor
argument_list|<
name|ANode
argument_list|>
block|{
DECL|method|buildPainlessTree
specifier|public
specifier|static
name|SSource
name|buildPainlessTree
parameter_list|(
name|String
name|sourceName
parameter_list|,
name|String
name|sourceText
parameter_list|,
name|CompilerSettings
name|settings
parameter_list|,
name|Printer
name|debugStream
parameter_list|)
block|{
return|return
operator|new
name|Walker
argument_list|(
name|sourceName
argument_list|,
name|sourceText
argument_list|,
name|settings
argument_list|,
name|debugStream
argument_list|)
operator|.
name|source
return|;
block|}
DECL|field|source
specifier|private
specifier|final
name|SSource
name|source
decl_stmt|;
DECL|field|settings
specifier|private
specifier|final
name|CompilerSettings
name|settings
decl_stmt|;
DECL|field|debugStream
specifier|private
specifier|final
name|Printer
name|debugStream
decl_stmt|;
DECL|field|sourceName
specifier|private
specifier|final
name|String
name|sourceName
decl_stmt|;
DECL|field|sourceText
specifier|private
specifier|final
name|String
name|sourceText
decl_stmt|;
DECL|field|reserved
specifier|private
specifier|final
name|Deque
argument_list|<
name|Reserved
argument_list|>
name|reserved
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|globals
specifier|private
specifier|final
name|Globals
name|globals
decl_stmt|;
DECL|field|syntheticCounter
specifier|private
name|int
name|syntheticCounter
init|=
literal|0
decl_stmt|;
DECL|method|Walker
specifier|private
name|Walker
parameter_list|(
name|String
name|sourceName
parameter_list|,
name|String
name|sourceText
parameter_list|,
name|CompilerSettings
name|settings
parameter_list|,
name|Printer
name|debugStream
parameter_list|)
block|{
name|this
operator|.
name|debugStream
operator|=
name|debugStream
expr_stmt|;
name|this
operator|.
name|settings
operator|=
name|settings
expr_stmt|;
name|this
operator|.
name|sourceName
operator|=
name|Location
operator|.
name|computeSourceName
argument_list|(
name|sourceName
argument_list|,
name|sourceText
argument_list|)
expr_stmt|;
name|this
operator|.
name|sourceText
operator|=
name|sourceText
expr_stmt|;
name|this
operator|.
name|globals
operator|=
operator|new
name|Globals
argument_list|(
operator|new
name|BitSet
argument_list|(
name|sourceText
operator|.
name|length
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|source
operator|=
operator|(
name|SSource
operator|)
name|visit
argument_list|(
name|buildAntlrTree
argument_list|(
name|sourceText
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|buildAntlrTree
specifier|private
name|SourceContext
name|buildAntlrTree
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|ANTLRInputStream
name|stream
init|=
operator|new
name|ANTLRInputStream
argument_list|(
name|source
argument_list|)
decl_stmt|;
name|PainlessLexer
name|lexer
init|=
operator|new
name|EnhancedPainlessLexer
argument_list|(
name|stream
argument_list|,
name|sourceName
argument_list|)
decl_stmt|;
name|PainlessParser
name|parser
init|=
operator|new
name|PainlessParser
argument_list|(
operator|new
name|CommonTokenStream
argument_list|(
name|lexer
argument_list|)
argument_list|)
decl_stmt|;
name|ParserErrorStrategy
name|strategy
init|=
operator|new
name|ParserErrorStrategy
argument_list|(
name|sourceName
argument_list|)
decl_stmt|;
name|lexer
operator|.
name|removeErrorListeners
argument_list|()
expr_stmt|;
name|parser
operator|.
name|removeErrorListeners
argument_list|()
expr_stmt|;
if|if
condition|(
name|settings
operator|.
name|isPicky
argument_list|()
condition|)
block|{
name|setupPicky
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
name|parser
operator|.
name|setErrorHandler
argument_list|(
name|strategy
argument_list|)
expr_stmt|;
return|return
name|parser
operator|.
name|source
argument_list|()
return|;
block|}
DECL|method|setupPicky
specifier|private
name|void
name|setupPicky
parameter_list|(
name|PainlessParser
name|parser
parameter_list|)
block|{
comment|// Diagnostic listener invokes syntaxError on other listeners for ambiguity issues,
name|parser
operator|.
name|addErrorListener
argument_list|(
operator|new
name|DiagnosticErrorListener
argument_list|(
literal|true
argument_list|)
argument_list|)
expr_stmt|;
comment|// a second listener to fail the test when the above happens.
name|parser
operator|.
name|addErrorListener
argument_list|(
operator|new
name|BaseErrorListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|syntaxError
parameter_list|(
specifier|final
name|Recognizer
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|recognizer
parameter_list|,
specifier|final
name|Object
name|offendingSymbol
parameter_list|,
specifier|final
name|int
name|line
parameter_list|,
specifier|final
name|int
name|charPositionInLine
parameter_list|,
specifier|final
name|String
name|msg
parameter_list|,
specifier|final
name|RecognitionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
literal|"line: "
operator|+
name|line
operator|+
literal|", offset: "
operator|+
name|charPositionInLine
operator|+
literal|", symbol:"
operator|+
name|offendingSymbol
operator|+
literal|" "
operator|+
name|msg
argument_list|)
throw|;
block|}
block|}
argument_list|)
expr_stmt|;
comment|// Enable exact ambiguity detection (costly). we enable exact since its the default for
comment|// DiagnosticErrorListener, life is too short to think about what 'inexact ambiguity' might mean.
name|parser
operator|.
name|getInterpreter
argument_list|()
operator|.
name|setPredictionMode
argument_list|(
name|PredictionMode
operator|.
name|LL_EXACT_AMBIG_DETECTION
argument_list|)
expr_stmt|;
block|}
DECL|method|location
specifier|private
name|Location
name|location
parameter_list|(
name|ParserRuleContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|Location
argument_list|(
name|sourceName
argument_list|,
name|ctx
operator|.
name|getStart
argument_list|()
operator|.
name|getStartIndex
argument_list|()
argument_list|)
return|;
block|}
comment|/** Returns name of next lambda */
DECL|method|nextLambda
specifier|private
name|String
name|nextLambda
parameter_list|()
block|{
return|return
literal|"lambda$"
operator|+
name|syntheticCounter
operator|++
return|;
block|}
annotation|@
name|Override
DECL|method|visitSource
specifier|public
name|ANode
name|visitSource
parameter_list|(
name|SourceContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|push
argument_list|(
operator|new
name|MainMethodReserved
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|SFunction
argument_list|>
name|functions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|FunctionContext
name|function
range|:
name|ctx
operator|.
name|function
argument_list|()
control|)
block|{
name|functions
operator|.
name|add
argument_list|(
operator|(
name|SFunction
operator|)
name|visit
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StatementContext
name|statement
range|:
name|ctx
operator|.
name|statement
argument_list|()
control|)
block|{
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SSource
argument_list|(
name|settings
argument_list|,
name|sourceName
argument_list|,
name|sourceText
argument_list|,
name|debugStream
argument_list|,
operator|(
name|MainMethodReserved
operator|)
name|reserved
operator|.
name|pop
argument_list|()
argument_list|,
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|functions
argument_list|,
name|globals
argument_list|,
name|statements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFunction
specifier|public
name|ANode
name|visitFunction
parameter_list|(
name|FunctionContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|push
argument_list|(
operator|new
name|FunctionReserved
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|rtnType
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paramTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paramNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DecltypeContext
name|decltype
range|:
name|ctx
operator|.
name|parameters
argument_list|()
operator|.
name|decltype
argument_list|()
control|)
block|{
name|paramTypes
operator|.
name|add
argument_list|(
name|decltype
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|TerminalNode
name|id
range|:
name|ctx
operator|.
name|parameters
argument_list|()
operator|.
name|ID
argument_list|()
control|)
block|{
name|paramNames
operator|.
name|add
argument_list|(
name|id
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|StatementContext
name|statement
range|:
name|ctx
operator|.
name|block
argument_list|()
operator|.
name|statement
argument_list|()
control|)
block|{
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SFunction
argument_list|(
operator|(
name|FunctionReserved
operator|)
name|reserved
operator|.
name|pop
argument_list|()
argument_list|,
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|rtnType
argument_list|,
name|name
argument_list|,
name|paramTypes
argument_list|,
name|paramNames
argument_list|,
name|statements
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitParameters
specifier|public
name|ANode
name|visitParameters
parameter_list|(
name|ParametersContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitIf
specifier|public
name|ANode
name|visitIf
parameter_list|(
name|IfContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|SBlock
name|ifblock
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|trailer
argument_list|()
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|SBlock
name|elseblock
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|SIfElse
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
name|ifblock
argument_list|,
name|elseblock
argument_list|)
return|;
block|}
else|else
block|{
return|return
operator|new
name|SIf
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
name|ifblock
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitWhile
specifier|public
name|ANode
name|visitWhile
parameter_list|(
name|WhileContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|trailer
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SWhile
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
name|block
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|empty
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|SWhile
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitDo
specifier|public
name|ANode
name|visitDo
parameter_list|(
name|DoContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SDo
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|block
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFor
specifier|public
name|ANode
name|visitFor
parameter_list|(
name|ForContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|ANode
name|initializer
init|=
name|ctx
operator|.
name|initializer
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
name|visit
argument_list|(
name|ctx
operator|.
name|initializer
argument_list|()
argument_list|)
decl_stmt|;
name|AExpression
name|expression
init|=
name|ctx
operator|.
name|expression
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|AExpression
name|afterthought
init|=
name|ctx
operator|.
name|afterthought
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|afterthought
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|trailer
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SFor
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|initializer
argument_list|,
name|expression
argument_list|,
name|afterthought
argument_list|,
name|block
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|empty
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|SFor
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|initializer
argument_list|,
name|expression
argument_list|,
name|afterthought
argument_list|,
literal|null
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitEach
specifier|public
name|ANode
name|visitEach
parameter_list|(
name|EachContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SEach
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|expression
argument_list|,
name|block
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitIneach
specifier|public
name|ANode
name|visitIneach
parameter_list|(
name|IneachContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|setMaxLoopCounter
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|trailer
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SEach
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"def"
argument_list|,
name|name
argument_list|,
name|expression
argument_list|,
name|block
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDecl
specifier|public
name|ANode
name|visitDecl
parameter_list|(
name|DeclContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|declaration
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitContinue
specifier|public
name|ANode
name|visitContinue
parameter_list|(
name|ContinueContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|SContinue
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBreak
specifier|public
name|ANode
name|visitBreak
parameter_list|(
name|BreakContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|SBreak
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitReturn
specifier|public
name|ANode
name|visitReturn
parameter_list|(
name|ReturnContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SReturn
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitTry
specifier|public
name|ANode
name|visitTry
parameter_list|(
name|TryContext
name|ctx
parameter_list|)
block|{
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|SCatch
argument_list|>
name|catches
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|TrapContext
name|trap
range|:
name|ctx
operator|.
name|trap
argument_list|()
control|)
block|{
name|catches
operator|.
name|add
argument_list|(
operator|(
name|SCatch
operator|)
name|visit
argument_list|(
name|trap
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|STry
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|block
argument_list|,
name|catches
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitThrow
specifier|public
name|ANode
name|visitThrow
parameter_list|(
name|ThrowContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SThrow
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitExpr
specifier|public
name|ANode
name|visitExpr
parameter_list|(
name|ExprContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SExpression
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitTrailer
specifier|public
name|ANode
name|visitTrailer
parameter_list|(
name|TrailerContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|block
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|statement
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|statement
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|SBlock
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|statements
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitBlock
specifier|public
name|ANode
name|visitBlock
parameter_list|(
name|BlockContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|statement
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|null
return|;
block|}
else|else
block|{
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|StatementContext
name|statement
range|:
name|ctx
operator|.
name|statement
argument_list|()
control|)
block|{
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SBlock
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|statements
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitEmpty
specifier|public
name|ANode
name|visitEmpty
parameter_list|(
name|EmptyContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitInitializer
specifier|public
name|ANode
name|visitInitializer
parameter_list|(
name|InitializerContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|declaration
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|declaration
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|expression
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitAfterthought
specifier|public
name|ANode
name|visitAfterthought
parameter_list|(
name|AfterthoughtContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDeclaration
specifier|public
name|ANode
name|visitDeclaration
parameter_list|(
name|DeclarationContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SDeclaration
argument_list|>
name|declarations
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|DeclvarContext
name|declvar
range|:
name|ctx
operator|.
name|declvar
argument_list|()
control|)
block|{
name|String
name|name
init|=
name|declvar
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|AExpression
name|expression
init|=
name|declvar
operator|.
name|expression
argument_list|()
operator|==
literal|null
condition|?
literal|null
else|:
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|declvar
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|declarations
operator|.
name|add
argument_list|(
operator|new
name|SDeclaration
argument_list|(
name|location
argument_list|(
name|declvar
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SDeclBlock
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|declarations
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDecltype
specifier|public
name|ANode
name|visitDecltype
parameter_list|(
name|DecltypeContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitDeclvar
specifier|public
name|ANode
name|visitDeclvar
parameter_list|(
name|DeclvarContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitTrap
specifier|public
name|ANode
name|visitTrap
parameter_list|(
name|TrapContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|SBlock
name|block
init|=
operator|(
name|SBlock
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|SCatch
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|block
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDelimiter
specifier|public
name|ANode
name|visitDelimiter
parameter_list|(
name|DelimiterContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitSingle
specifier|public
name|ANode
name|visitSingle
parameter_list|(
name|SingleContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBinary
specifier|public
name|ANode
name|visitBinary
parameter_list|(
name|BinaryContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|MUL
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|MUL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DIV
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DIV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|REM
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|REM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADD
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|SUB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|FIND
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|FIND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|MATCH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|MATCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|LSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|RSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|RSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|USH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|USH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|XOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|XOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWOR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EBinary
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitComp
specifier|public
name|ANode
name|visitComp
parameter_list|(
name|CompContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|LT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|LTE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|GT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|GT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|GTE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|GTE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|EQ
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|EQ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|EQR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|EQR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|NE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|NE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|NER
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|NER
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EComp
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitInstanceof
specifier|public
name|ANode
name|visitInstanceof
parameter_list|(
name|InstanceofContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expr
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
return|return
operator|new
name|EInstanceof
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expr
argument_list|,
name|type
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBool
specifier|public
name|ANode
name|visitBool
parameter_list|(
name|BoolContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|BOOLAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|AND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BOOLOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|OR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EBool
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitConditional
specifier|public
name|ANode
name|visitConditional
parameter_list|(
name|ConditionalContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|condition
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|left
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|right
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|new
name|EConditional
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|condition
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitAssignment
specifier|public
name|ANode
name|visitAssignment
parameter_list|(
name|AssignmentContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|lhs
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|AExpression
name|rhs
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|ASSIGN
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
literal|null
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AMUL
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|MUL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADIV
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DIV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AREM
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|REM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AADD
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ASUB
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|SUB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ALSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|LSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ARSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|RSH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AUSH
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|USH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWAND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AXOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|XOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|AOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWOR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EAssignment
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
name|operation
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitPre
specifier|public
name|ANode
name|visitPre
parameter_list|(
name|PreContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|chain
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|INCR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|INCR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DECR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DECR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EAssignment
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
name|operation
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitPost
specifier|public
name|ANode
name|visitPost
parameter_list|(
name|PostContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|chain
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|INCR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|INCR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DECR
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|DECR
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EAssignment
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
name|operation
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitRead
specifier|public
name|ANode
name|visitRead
parameter_list|(
name|ReadContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|chain
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitOperator
specifier|public
name|ANode
name|visitOperator
parameter_list|(
name|OperatorContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|Operation
name|operation
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|BOOLNOT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|NOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWNOT
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|BWNOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADD
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|operation
operator|=
name|Operation
operator|.
name|ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|unary
argument_list|()
operator|instanceof
name|ReadContext
operator|&&
operator|(
operator|(
name|ReadContext
operator|)
name|ctx
operator|.
name|unary
argument_list|()
operator|)
operator|.
name|chain
argument_list|()
operator|instanceof
name|DynamicContext
operator|&&
operator|(
call|(
name|DynamicContext
call|)
argument_list|(
operator|(
name|ReadContext
operator|)
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
operator|.
name|chain
argument_list|()
operator|)
operator|.
name|primary
argument_list|()
operator|instanceof
name|NumericContext
operator|&&
operator|(
call|(
name|DynamicContext
call|)
argument_list|(
operator|(
name|ReadContext
operator|)
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
operator|.
name|chain
argument_list|()
operator|)
operator|.
name|postfix
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|expression
return|;
block|}
name|operation
operator|=
name|Operation
operator|.
name|SUB
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|EUnary
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|operation
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitCast
specifier|public
name|ANode
name|visitCast
parameter_list|(
name|CastContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|AExpression
name|child
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|unary
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|EExplicit
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|child
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitDynamic
specifier|public
name|ANode
name|visitDynamic
parameter_list|(
name|DynamicContext
name|ctx
parameter_list|)
block|{
name|AExpression
name|primary
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|primary
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|buildPostfixChain
argument_list|(
name|primary
argument_list|,
literal|null
argument_list|,
name|ctx
operator|.
name|postfix
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitStatic
specifier|public
name|ANode
name|visitStatic
parameter_list|(
name|StaticContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
return|return
name|buildPostfixChain
argument_list|(
operator|new
name|EStatic
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|)
argument_list|,
name|ctx
operator|.
name|postdot
argument_list|()
argument_list|,
name|ctx
operator|.
name|postfix
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNewarray
specifier|public
name|ANode
name|visitNewarray
parameter_list|(
name|NewarrayContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|arrayinitializer
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitPrecedence
specifier|public
name|ANode
name|visitPrecedence
parameter_list|(
name|PrecedenceContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNumeric
specifier|public
name|ANode
name|visitNumeric
parameter_list|(
name|NumericContext
name|ctx
parameter_list|)
block|{
specifier|final
name|boolean
name|negate
init|=
operator|(
operator|(
name|DynamicContext
operator|)
name|ctx
operator|.
name|parent
operator|)
operator|.
name|postfix
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|ctx
operator|.
name|parent
operator|.
name|parent
operator|.
name|parent
operator|instanceof
name|OperatorContext
operator|&&
operator|(
operator|(
name|OperatorContext
operator|)
name|ctx
operator|.
name|parent
operator|.
name|parent
operator|.
name|parent
operator|)
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|DECIMAL
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|EDecimal
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|DECIMAL
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|HEX
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ENumeric
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|HEX
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|16
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|INTEGER
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ENumeric
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|INTEGER
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|,
literal|10
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|OCTAL
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|ENumeric
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
operator|(
name|negate
condition|?
literal|"-"
else|:
literal|""
operator|)
operator|+
name|ctx
operator|.
name|OCTAL
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|8
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitTrue
specifier|public
name|ANode
name|visitTrue
parameter_list|(
name|TrueContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|EBoolean
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|true
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFalse
specifier|public
name|ANode
name|visitFalse
parameter_list|(
name|FalseContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|EBoolean
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|false
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNull
specifier|public
name|ANode
name|visitNull
parameter_list|(
name|NullContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|ENull
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitString
specifier|public
name|ANode
name|visitString
parameter_list|(
name|StringContext
name|ctx
parameter_list|)
block|{
name|String
name|string
init|=
name|ctx
operator|.
name|STRING
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|ctx
operator|.
name|STRING
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
operator|new
name|EString
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|string
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitRegex
specifier|public
name|ANode
name|visitRegex
parameter_list|(
name|RegexContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
literal|false
operator|==
name|settings
operator|.
name|areRegexesEnabled
argument_list|()
condition|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Regexes are disabled. Set [script.painless.regex.enabled] to [true] "
operator|+
literal|"in elasticsearch.yaml to allow them. Be careful though, regexes break out of Painless's protection against deep "
operator|+
literal|"recursion and long loops."
argument_list|)
argument_list|)
throw|;
block|}
name|String
name|text
init|=
name|ctx
operator|.
name|REGEX
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|int
name|lastSlash
init|=
name|text
operator|.
name|lastIndexOf
argument_list|(
literal|'/'
argument_list|)
decl_stmt|;
name|String
name|pattern
init|=
name|text
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|lastSlash
argument_list|)
decl_stmt|;
name|String
name|flags
init|=
name|text
operator|.
name|substring
argument_list|(
name|lastSlash
operator|+
literal|1
argument_list|)
decl_stmt|;
return|return
operator|new
name|ERegex
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|pattern
argument_list|,
name|flags
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitListinit
specifier|public
name|ANode
name|visitListinit
parameter_list|(
name|ListinitContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|listinitializer
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitMapinit
specifier|public
name|ANode
name|visitMapinit
parameter_list|(
name|MapinitContext
name|ctx
parameter_list|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|mapinitializer
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitVariable
specifier|public
name|ANode
name|visitVariable
parameter_list|(
name|VariableContext
name|ctx
parameter_list|)
block|{
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|reserved
operator|.
name|peek
argument_list|()
operator|.
name|markReserved
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|new
name|EVariable
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitCalllocal
specifier|public
name|ANode
name|visitCalllocal
parameter_list|(
name|CalllocalContext
name|ctx
parameter_list|)
block|{
name|String
name|name
init|=
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
name|collectArguments
argument_list|(
name|ctx
operator|.
name|arguments
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|ECallLocal
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|name
argument_list|,
name|arguments
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNewobject
specifier|public
name|ANode
name|visitNewobject
parameter_list|(
name|NewobjectContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
name|collectArguments
argument_list|(
name|ctx
operator|.
name|arguments
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|ENewObj
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|arguments
argument_list|)
return|;
block|}
DECL|method|buildPostfixChain
specifier|private
name|AExpression
name|buildPostfixChain
parameter_list|(
name|AExpression
name|primary
parameter_list|,
name|PostdotContext
name|postdot
parameter_list|,
name|List
argument_list|<
name|PostfixContext
argument_list|>
name|postfixes
parameter_list|)
block|{
name|AExpression
name|prefix
init|=
name|primary
decl_stmt|;
if|if
condition|(
name|postdot
operator|!=
literal|null
condition|)
block|{
name|prefix
operator|=
name|visitPostdot
argument_list|(
name|postdot
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|PostfixContext
name|postfix
range|:
name|postfixes
control|)
block|{
name|prefix
operator|=
name|visitPostfix
argument_list|(
name|postfix
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
return|return
name|prefix
return|;
block|}
annotation|@
name|Override
DECL|method|visitPostfix
specifier|public
name|ANode
name|visitPostfix
parameter_list|(
name|PostfixContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|visitPostfix
specifier|public
name|AExpression
name|visitPostfix
parameter_list|(
name|PostfixContext
name|ctx
parameter_list|,
name|AExpression
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|callinvoke
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visitCallinvoke
argument_list|(
name|ctx
operator|.
name|callinvoke
argument_list|()
argument_list|,
name|prefix
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|fieldaccess
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visitFieldaccess
argument_list|(
name|ctx
operator|.
name|fieldaccess
argument_list|()
argument_list|,
name|prefix
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|braceaccess
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visitBraceaccess
argument_list|(
name|ctx
operator|.
name|braceaccess
argument_list|()
argument_list|,
name|prefix
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitPostdot
specifier|public
name|ANode
name|visitPostdot
parameter_list|(
name|PostdotContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|visitPostdot
specifier|public
name|AExpression
name|visitPostdot
parameter_list|(
name|PostdotContext
name|ctx
parameter_list|,
name|AExpression
name|prefix
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|callinvoke
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visitCallinvoke
argument_list|(
name|ctx
operator|.
name|callinvoke
argument_list|()
argument_list|,
name|prefix
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|fieldaccess
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visitFieldaccess
argument_list|(
name|ctx
operator|.
name|fieldaccess
argument_list|()
argument_list|,
name|prefix
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitCallinvoke
specifier|public
name|ANode
name|visitCallinvoke
parameter_list|(
name|CallinvokeContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|visitCallinvoke
specifier|public
name|AExpression
name|visitCallinvoke
parameter_list|(
name|CallinvokeContext
name|ctx
parameter_list|,
name|AExpression
name|prefix
parameter_list|)
block|{
name|String
name|name
init|=
name|ctx
operator|.
name|DOTID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
name|collectArguments
argument_list|(
name|ctx
operator|.
name|arguments
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|PCallInvoke
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|,
name|arguments
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitFieldaccess
specifier|public
name|ANode
name|visitFieldaccess
parameter_list|(
name|FieldaccessContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|visitFieldaccess
specifier|public
name|AExpression
name|visitFieldaccess
parameter_list|(
name|FieldaccessContext
name|ctx
parameter_list|,
name|AExpression
name|prefix
parameter_list|)
block|{
specifier|final
name|String
name|value
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|DOTID
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|ctx
operator|.
name|DOTID
argument_list|()
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DOTINTEGER
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|value
operator|=
name|ctx
operator|.
name|DOTINTEGER
argument_list|()
operator|.
name|getText
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
return|return
operator|new
name|PField
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|value
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitBraceaccess
specifier|public
name|ANode
name|visitBraceaccess
parameter_list|(
name|BraceaccessContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|visitBraceaccess
specifier|public
name|AExpression
name|visitBraceaccess
parameter_list|(
name|BraceaccessContext
name|ctx
parameter_list|,
name|AExpression
name|prefix
parameter_list|)
block|{
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|new
name|PBrace
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|prefix
argument_list|,
name|expression
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNewstandardarray
specifier|public
name|ANode
name|visitNewstandardarray
parameter_list|(
name|NewstandardarrayContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AExpression
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExpressionContext
name|expression
range|:
name|ctx
operator|.
name|expression
argument_list|()
control|)
block|{
name|expressions
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buildPostfixChain
argument_list|(
operator|new
name|ENewArray
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|expressions
argument_list|,
literal|false
argument_list|)
argument_list|,
name|ctx
operator|.
name|postdot
argument_list|()
argument_list|,
name|ctx
operator|.
name|postfix
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitNewinitializedarray
specifier|public
name|ANode
name|visitNewinitializedarray
parameter_list|(
name|NewinitializedarrayContext
name|ctx
parameter_list|)
block|{
name|String
name|type
init|=
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AExpression
argument_list|>
name|expressions
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExpressionContext
name|expression
range|:
name|ctx
operator|.
name|expression
argument_list|()
control|)
block|{
name|expressions
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buildPostfixChain
argument_list|(
operator|new
name|ENewArray
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|type
argument_list|,
name|expressions
argument_list|,
literal|true
argument_list|)
argument_list|,
literal|null
argument_list|,
name|ctx
operator|.
name|postfix
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitListinitializer
specifier|public
name|ANode
name|visitListinitializer
parameter_list|(
name|ListinitializerContext
name|ctx
parameter_list|)
block|{
name|List
argument_list|<
name|AExpression
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ExpressionContext
name|expression
range|:
name|ctx
operator|.
name|expression
argument_list|()
control|)
block|{
name|values
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|EListInit
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|values
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitMapinitializer
specifier|public
name|ANode
name|visitMapinitializer
parameter_list|(
name|MapinitializerContext
name|ctx
parameter_list|)
block|{
name|List
argument_list|<
name|AExpression
argument_list|>
name|keys
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AExpression
argument_list|>
name|values
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|MaptokenContext
name|maptoken
range|:
name|ctx
operator|.
name|maptoken
argument_list|()
control|)
block|{
name|keys
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|maptoken
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|values
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|maptoken
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|EMapInit
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|keys
argument_list|,
name|values
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitMaptoken
specifier|public
name|ANode
name|visitMaptoken
parameter_list|(
name|MaptokenContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitArguments
specifier|public
name|ANode
name|visitArguments
parameter_list|(
name|ArgumentsContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
DECL|method|collectArguments
specifier|private
name|List
argument_list|<
name|AExpression
argument_list|>
name|collectArguments
parameter_list|(
name|ArgumentsContext
name|ctx
parameter_list|)
block|{
name|List
argument_list|<
name|AExpression
argument_list|>
name|arguments
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|ArgumentContext
name|argument
range|:
name|ctx
operator|.
name|argument
argument_list|()
control|)
block|{
name|arguments
operator|.
name|add
argument_list|(
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|arguments
return|;
block|}
annotation|@
name|Override
DECL|method|visitArgument
specifier|public
name|ANode
name|visitArgument
parameter_list|(
name|ArgumentContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|.
name|expression
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|lambda
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|lambda
argument_list|()
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|funcref
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|visit
argument_list|(
name|ctx
operator|.
name|funcref
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitLambda
specifier|public
name|ANode
name|visitLambda
parameter_list|(
name|LambdaContext
name|ctx
parameter_list|)
block|{
name|reserved
operator|.
name|push
argument_list|(
operator|new
name|FunctionReserved
argument_list|()
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paramTypes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|paramNames
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|AStatement
argument_list|>
name|statements
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|LamtypeContext
name|lamtype
range|:
name|ctx
operator|.
name|lamtype
argument_list|()
control|)
block|{
if|if
condition|(
name|lamtype
operator|.
name|decltype
argument_list|()
operator|==
literal|null
condition|)
block|{
name|paramTypes
operator|.
name|add
argument_list|(
literal|"def"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|paramTypes
operator|.
name|add
argument_list|(
name|lamtype
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|paramNames
operator|.
name|add
argument_list|(
name|lamtype
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|.
name|expression
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// single expression
name|AExpression
name|expression
init|=
operator|(
name|AExpression
operator|)
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|statements
operator|.
name|add
argument_list|(
operator|new
name|SReturn
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|expression
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|StatementContext
name|statement
range|:
name|ctx
operator|.
name|block
argument_list|()
operator|.
name|statement
argument_list|()
control|)
block|{
name|statements
operator|.
name|add
argument_list|(
operator|(
name|AStatement
operator|)
name|visit
argument_list|(
name|statement
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|String
name|name
init|=
name|nextLambda
argument_list|()
decl_stmt|;
return|return
operator|new
name|ELambda
argument_list|(
name|name
argument_list|,
operator|(
name|FunctionReserved
operator|)
name|reserved
operator|.
name|pop
argument_list|()
argument_list|,
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|paramTypes
argument_list|,
name|paramNames
argument_list|,
name|statements
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitLamtype
specifier|public
name|ANode
name|visitLamtype
parameter_list|(
name|LamtypeContext
name|ctx
parameter_list|)
block|{
throw|throw
name|location
argument_list|(
name|ctx
argument_list|)
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitClassfuncref
specifier|public
name|ANode
name|visitClassfuncref
parameter_list|(
name|ClassfuncrefContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|EFunctionRef
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|ctx
operator|.
name|TYPE
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|,
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitConstructorfuncref
specifier|public
name|ANode
name|visitConstructorfuncref
parameter_list|(
name|ConstructorfuncrefContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|LBRACE
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// array constructors are special: we need to make a synthetic method
comment|// taking integer as argument and returning a new instance, and return a ref to that.
name|Location
name|location
init|=
name|location
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|String
name|arrayType
init|=
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
name|SReturn
name|code
init|=
operator|new
name|SReturn
argument_list|(
name|location
argument_list|,
operator|new
name|ENewArray
argument_list|(
name|location
argument_list|,
name|arrayType
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
operator|new
name|EVariable
argument_list|(
name|location
argument_list|,
literal|"size"
argument_list|)
argument_list|)
argument_list|,
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|String
name|name
init|=
name|nextLambda
argument_list|()
decl_stmt|;
name|globals
operator|.
name|addSyntheticMethod
argument_list|(
operator|new
name|SFunction
argument_list|(
operator|new
name|FunctionReserved
argument_list|()
argument_list|,
name|location
argument_list|,
name|arrayType
argument_list|,
name|name
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"int"
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
literal|"size"
argument_list|)
argument_list|,
name|Arrays
operator|.
name|asList
argument_list|(
name|code
argument_list|)
argument_list|,
literal|true
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|new
name|EFunctionRef
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
literal|"this"
argument_list|,
name|name
argument_list|)
return|;
block|}
return|return
operator|new
name|EFunctionRef
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|ctx
operator|.
name|decltype
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|,
name|ctx
operator|.
name|NEW
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitCapturingfuncref
specifier|public
name|ANode
name|visitCapturingfuncref
parameter_list|(
name|CapturingfuncrefContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|ECapturingFunctionRef
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|ctx
operator|.
name|ID
argument_list|(
literal|0
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|,
name|ctx
operator|.
name|ID
argument_list|(
literal|1
argument_list|)
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|visitLocalfuncref
specifier|public
name|ANode
name|visitLocalfuncref
parameter_list|(
name|LocalfuncrefContext
name|ctx
parameter_list|)
block|{
return|return
operator|new
name|EFunctionRef
argument_list|(
name|location
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|ctx
operator|.
name|THIS
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|,
name|ctx
operator|.
name|ID
argument_list|()
operator|.
name|getText
argument_list|()
argument_list|)
return|;
block|}
block|}
end_class

end_unit

