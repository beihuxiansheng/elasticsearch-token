begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|ParserRuleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|AnalyzerUtility
operator|.
name|Variable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Struct
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Metadata
operator|.
name|ExpressionMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Metadata
operator|.
name|ExtNodeMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Metadata
operator|.
name|ExternalMetadata
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DecltypeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExpressionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtbraceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtcallContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtcastContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtdotContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtfieldContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtnewContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtprecContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtstartContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtstringContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtvarContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|IdentifierContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ADD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWAND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWXOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DIV
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|MUL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|REM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|SUB
import|;
end_import

begin_class
DECL|class|AnalyzerExternal
class|class
name|AnalyzerExternal
block|{
DECL|field|metadata
specifier|private
specifier|final
name|Metadata
name|metadata
decl_stmt|;
DECL|field|definition
specifier|private
specifier|final
name|Definition
name|definition
decl_stmt|;
DECL|field|analyzer
specifier|private
specifier|final
name|Analyzer
name|analyzer
decl_stmt|;
DECL|field|utility
specifier|private
specifier|final
name|AnalyzerUtility
name|utility
decl_stmt|;
DECL|field|caster
specifier|private
specifier|final
name|AnalyzerCaster
name|caster
decl_stmt|;
DECL|field|promoter
specifier|private
specifier|final
name|AnalyzerPromoter
name|promoter
decl_stmt|;
DECL|method|AnalyzerExternal
name|AnalyzerExternal
parameter_list|(
specifier|final
name|Metadata
name|metadata
parameter_list|,
specifier|final
name|Analyzer
name|analyzer
parameter_list|,
specifier|final
name|AnalyzerUtility
name|utility
parameter_list|,
specifier|final
name|AnalyzerCaster
name|caster
parameter_list|,
specifier|final
name|AnalyzerPromoter
name|promoter
parameter_list|)
block|{
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|this
operator|.
name|definition
operator|=
name|metadata
operator|.
name|definition
expr_stmt|;
name|this
operator|.
name|analyzer
operator|=
name|analyzer
expr_stmt|;
name|this
operator|.
name|utility
operator|=
name|utility
expr_stmt|;
name|this
operator|.
name|caster
operator|=
name|caster
expr_stmt|;
name|this
operator|.
name|promoter
operator|=
name|promoter
expr_stmt|;
block|}
DECL|method|processExtstart
name|void
name|processExtstart
parameter_list|(
specifier|final
name|ExtstartContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtprecContext
name|precctx
init|=
name|ctx
operator|.
name|extprec
argument_list|()
decl_stmt|;
specifier|final
name|ExtcastContext
name|castctx
init|=
name|ctx
operator|.
name|extcast
argument_list|()
decl_stmt|;
specifier|final
name|ExtvarContext
name|varctx
init|=
name|ctx
operator|.
name|extvar
argument_list|()
decl_stmt|;
specifier|final
name|ExtnewContext
name|newctx
init|=
name|ctx
operator|.
name|extnew
argument_list|()
decl_stmt|;
specifier|final
name|ExtstringContext
name|stringctx
init|=
name|ctx
operator|.
name|extstring
argument_list|()
decl_stmt|;
if|if
condition|(
name|precctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|ctx
argument_list|,
name|precctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|precctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|castctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|ctx
argument_list|,
name|castctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|castctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|ctx
argument_list|,
name|varctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|varctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|ctx
argument_list|,
name|newctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|newctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|ctx
argument_list|,
name|stringctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|stringctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
DECL|method|processExtprec
name|void
name|processExtprec
parameter_list|(
specifier|final
name|ExtprecContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|precenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|precenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|ExtprecContext
name|precctx
init|=
name|ctx
operator|.
name|extprec
argument_list|()
decl_stmt|;
specifier|final
name|ExtcastContext
name|castctx
init|=
name|ctx
operator|.
name|extcast
argument_list|()
decl_stmt|;
specifier|final
name|ExtvarContext
name|varctx
init|=
name|ctx
operator|.
name|extvar
argument_list|()
decl_stmt|;
specifier|final
name|ExtnewContext
name|newctx
init|=
name|ctx
operator|.
name|extnew
argument_list|()
decl_stmt|;
specifier|final
name|ExtstringContext
name|stringctx
init|=
name|ctx
operator|.
name|extstring
argument_list|()
decl_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
operator|||
name|bracectx
operator|!=
literal|null
condition|)
block|{
operator|++
name|parentemd
operator|.
name|scope
expr_stmt|;
block|}
if|if
condition|(
name|precctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|precctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|precctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|castctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|castctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|castctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|varctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|varctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|newctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|newctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|ctx
argument_list|,
name|stringctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|stringctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
name|parentemd
operator|.
name|statement
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
operator|--
name|parentemd
operator|.
name|scope
expr_stmt|;
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
operator|--
name|parentemd
operator|.
name|scope
expr_stmt|;
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|bracectx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processExtcast
name|void
name|processExtcast
parameter_list|(
specifier|final
name|ExtcastContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|castenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|castenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|ExtprecContext
name|precctx
init|=
name|ctx
operator|.
name|extprec
argument_list|()
decl_stmt|;
specifier|final
name|ExtcastContext
name|castctx
init|=
name|ctx
operator|.
name|extcast
argument_list|()
decl_stmt|;
specifier|final
name|ExtvarContext
name|varctx
init|=
name|ctx
operator|.
name|extvar
argument_list|()
decl_stmt|;
specifier|final
name|ExtnewContext
name|newctx
init|=
name|ctx
operator|.
name|extnew
argument_list|()
decl_stmt|;
specifier|final
name|ExtstringContext
name|stringctx
init|=
name|ctx
operator|.
name|extstring
argument_list|()
decl_stmt|;
if|if
condition|(
name|precctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|precctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|precctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|castctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|castctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|castctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|varctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|varctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|newctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|newctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|ctx
argument_list|,
name|stringctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|stringctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
specifier|final
name|DecltypeContext
name|declctx
init|=
name|ctx
operator|.
name|decltype
argument_list|()
decl_stmt|;
specifier|final
name|ExpressionMetadata
name|declemd
init|=
name|metadata
operator|.
name|createExpressionMetadata
argument_list|(
name|declctx
argument_list|)
decl_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|declctx
argument_list|)
expr_stmt|;
name|castenmd
operator|.
name|castTo
operator|=
name|caster
operator|.
name|getLegalCast
argument_list|(
name|ctx
argument_list|,
name|parentemd
operator|.
name|current
argument_list|,
name|declemd
operator|.
name|from
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|castenmd
operator|.
name|type
operator|=
name|declemd
operator|.
name|from
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|declemd
operator|.
name|from
expr_stmt|;
name|parentemd
operator|.
name|statement
operator|=
literal|false
expr_stmt|;
block|}
DECL|method|processExtbrace
name|void
name|processExtbrace
parameter_list|(
specifier|final
name|ExtbraceContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|braceenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|braceenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|array
init|=
name|parentemd
operator|.
name|current
operator|.
name|sort
operator|==
name|Sort
operator|.
name|ARRAY
decl_stmt|;
specifier|final
name|boolean
name|def
init|=
name|parentemd
operator|.
name|current
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DEF
decl_stmt|;
name|boolean
name|map
init|=
literal|false
decl_stmt|;
name|boolean
name|list
init|=
literal|false
decl_stmt|;
try|try
block|{
name|parentemd
operator|.
name|current
operator|.
name|clazz
operator|.
name|asSubclass
argument_list|(
name|Map
operator|.
name|class
argument_list|)
expr_stmt|;
name|map
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassCastException
name|exception
parameter_list|)
block|{
comment|// Do nothing.
block|}
try|try
block|{
name|parentemd
operator|.
name|current
operator|.
name|clazz
operator|.
name|asSubclass
argument_list|(
name|List
operator|.
name|class
argument_list|)
expr_stmt|;
name|list
operator|=
literal|true
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ClassCastException
name|exception
parameter_list|)
block|{
comment|// Do nothing.
block|}
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
name|braceenmd
operator|.
name|last
operator|=
name|parentemd
operator|.
name|scope
operator|==
literal|0
operator|&&
name|dotctx
operator|==
literal|null
operator|&&
name|bracectx
operator|==
literal|null
expr_stmt|;
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|AnalyzerUtility
operator|.
name|updateExpressionTree
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|createExpressionMetadata
argument_list|(
name|exprctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|array
operator|||
name|def
condition|)
block|{
name|expremd
operator|.
name|to
operator|=
name|array
condition|?
name|definition
operator|.
name|intType
else|:
name|definition
operator|.
name|objectType
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|caster
operator|.
name|markCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
name|braceenmd
operator|.
name|target
operator|=
literal|"#brace"
expr_stmt|;
name|braceenmd
operator|.
name|type
operator|=
name|def
condition|?
name|definition
operator|.
name|defType
else|:
name|definition
operator|.
name|getType
argument_list|(
name|parentemd
operator|.
name|current
operator|.
name|struct
argument_list|,
name|parentemd
operator|.
name|current
operator|.
name|type
operator|.
name|getDimensions
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|analyzeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|braceenmd
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|boolean
name|store
init|=
name|braceenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|get
init|=
name|parentemd
operator|.
name|read
operator|||
name|parentemd
operator|.
name|token
operator|>
literal|0
operator|||
operator|!
name|braceenmd
operator|.
name|last
decl_stmt|;
specifier|final
name|boolean
name|set
init|=
name|braceenmd
operator|.
name|last
operator|&&
name|store
decl_stmt|;
name|Method
name|getter
decl_stmt|;
name|Method
name|setter
decl_stmt|;
name|Type
name|valuetype
decl_stmt|;
name|Type
name|settype
decl_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|getter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"get"
argument_list|)
expr_stmt|;
name|setter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"put"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
operator|(
name|getter
operator|.
name|rtn
operator|.
name|sort
operator|==
name|Sort
operator|.
name|VOID
operator|||
name|getter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal map get shortcut for type ["
operator|+
name|parentemd
operator|.
name|current
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|setter
operator|!=
literal|null
operator|&&
name|setter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal map set shortcut for type ["
operator|+
name|parentemd
operator|.
name|current
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
name|setter
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|getter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|getter
operator|.
name|rtn
operator|.
name|equals
argument_list|(
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Shortcut argument types must match."
argument_list|)
throw|;
block|}
name|valuetype
operator|=
name|setter
operator|!=
literal|null
condition|?
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
name|getter
operator|!=
literal|null
condition|?
name|getter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
else|:
literal|null
expr_stmt|;
name|settype
operator|=
name|setter
operator|==
literal|null
condition|?
literal|null
else|:
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list
condition|)
block|{
name|getter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"get"
argument_list|)
expr_stmt|;
name|setter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
operator|(
name|getter
operator|.
name|rtn
operator|.
name|sort
operator|==
name|Sort
operator|.
name|VOID
operator|||
name|getter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|getter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|INT
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal list get shortcut for type ["
operator|+
name|parentemd
operator|.
name|current
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|setter
operator|!=
literal|null
operator|&&
operator|(
name|setter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|||
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|INT
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal list set shortcut for type ["
operator|+
name|parentemd
operator|.
name|current
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
name|setter
operator|!=
literal|null
operator|&&
operator|(
operator|!
name|getter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|equals
argument_list|(
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|||
operator|!
name|getter
operator|.
name|rtn
operator|.
name|equals
argument_list|(
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Shortcut argument types must match."
argument_list|)
throw|;
block|}
name|valuetype
operator|=
name|definition
operator|.
name|intType
expr_stmt|;
name|settype
operator|=
name|setter
operator|==
literal|null
condition|?
literal|null
else|:
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|get
operator|||
name|set
operator|)
operator|&&
operator|(
operator|!
name|get
operator|||
name|getter
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|set
operator|||
name|setter
operator|!=
literal|null
operator|)
condition|)
block|{
name|expremd
operator|.
name|to
operator|=
name|valuetype
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|caster
operator|.
name|markCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
name|braceenmd
operator|.
name|target
operator|=
operator|new
name|Object
index|[]
block|{
name|getter
block|,
name|setter
block|,
literal|true
block|,
literal|null
block|}
expr_stmt|;
name|braceenmd
operator|.
name|type
operator|=
name|get
condition|?
name|getter
operator|.
name|rtn
else|:
name|settype
expr_stmt|;
name|analyzeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|get
condition|?
name|getter
operator|.
name|rtn
else|:
name|setter
operator|.
name|rtn
expr_stmt|;
block|}
block|}
if|if
condition|(
name|braceenmd
operator|.
name|target
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Attempting to address a non-array type ["
operator|+
name|parentemd
operator|.
name|current
operator|.
name|name
operator|+
literal|"] as an array."
argument_list|)
throw|;
block|}
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|bracectx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processExtdot
name|void
name|processExtdot
parameter_list|(
specifier|final
name|ExtdotContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|dotemnd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|dotemnd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExtcallContext
name|callctx
init|=
name|ctx
operator|.
name|extcall
argument_list|()
decl_stmt|;
specifier|final
name|ExtfieldContext
name|fieldctx
init|=
name|ctx
operator|.
name|extfield
argument_list|()
decl_stmt|;
if|if
condition|(
name|callctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|callctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|callctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fieldctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|fieldctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|fieldctx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processExtcall
name|void
name|processExtcall
parameter_list|(
specifier|final
name|ExtcallContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|callenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|callenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
name|callenmd
operator|.
name|last
operator|=
name|parentemd
operator|.
name|scope
operator|==
literal|0
operator|&&
name|dotctx
operator|==
literal|null
operator|&&
name|bracectx
operator|==
literal|null
expr_stmt|;
specifier|final
name|String
name|name
init|=
name|ctx
operator|.
name|EXTID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|current
operator|.
name|sort
operator|==
name|Sort
operator|.
name|ARRAY
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected call ["
operator|+
name|name
operator|+
literal|"] on an array."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|callenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Cannot assign a value to a call ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
specifier|final
name|Struct
name|struct
init|=
name|parentemd
operator|.
name|current
operator|.
name|struct
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ExpressionContext
argument_list|>
name|arguments
init|=
name|ctx
operator|.
name|arguments
argument_list|()
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|arguments
operator|.
name|size
argument_list|()
decl_stmt|;
name|Type
index|[]
name|types
decl_stmt|;
specifier|final
name|Method
name|method
init|=
name|parentemd
operator|.
name|statik
condition|?
name|struct
operator|.
name|functions
operator|.
name|get
argument_list|(
name|name
argument_list|)
else|:
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|def
init|=
name|parentemd
operator|.
name|current
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DEF
decl_stmt|;
if|if
condition|(
name|method
operator|==
literal|null
operator|&&
operator|!
name|def
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unknown call ["
operator|+
name|name
operator|+
literal|"] on type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|method
operator|!=
literal|null
condition|)
block|{
name|types
operator|=
operator|new
name|Type
index|[
name|method
operator|.
name|arguments
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|method
operator|.
name|arguments
operator|.
name|toArray
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|callenmd
operator|.
name|target
operator|=
name|method
expr_stmt|;
name|callenmd
operator|.
name|type
operator|=
name|method
operator|.
name|rtn
expr_stmt|;
name|parentemd
operator|.
name|statement
operator|=
operator|!
name|parentemd
operator|.
name|read
operator|&&
name|callenmd
operator|.
name|last
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|method
operator|.
name|rtn
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|types
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"When calling ["
operator|+
name|name
operator|+
literal|"] on type "
operator|+
literal|"["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"] expected ["
operator|+
name|types
operator|.
name|length
operator|+
literal|"] arguments,"
operator|+
literal|" but found ["
operator|+
name|arguments
operator|.
name|size
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|types
operator|=
operator|new
name|Type
index|[
name|arguments
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|types
argument_list|,
name|definition
operator|.
name|defType
argument_list|)
expr_stmt|;
name|callenmd
operator|.
name|target
operator|=
name|name
expr_stmt|;
name|callenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|defType
expr_stmt|;
name|parentemd
operator|.
name|statement
operator|=
operator|!
name|parentemd
operator|.
name|read
operator|&&
name|callenmd
operator|.
name|last
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|callenmd
operator|.
name|type
expr_stmt|;
block|}
for|for
control|(
name|int
name|argument
init|=
literal|0
init|;
name|argument
operator|<
name|size
condition|;
operator|++
name|argument
control|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|AnalyzerUtility
operator|.
name|updateExpressionTree
argument_list|(
name|arguments
operator|.
name|get
argument_list|(
name|argument
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|createExpressionMetadata
argument_list|(
name|exprctx
argument_list|)
decl_stmt|;
name|expremd
operator|.
name|to
operator|=
name|types
index|[
name|argument
index|]
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|caster
operator|.
name|markCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
block|}
name|parentemd
operator|.
name|statik
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|bracectx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processExtvar
name|void
name|processExtvar
parameter_list|(
specifier|final
name|ExtvarContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|varenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|varenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|IdentifierContext
name|idctx
init|=
name|ctx
operator|.
name|identifier
argument_list|()
decl_stmt|;
specifier|final
name|String
name|id
init|=
name|idctx
operator|.
name|getText
argument_list|()
decl_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|type
init|=
name|utility
operator|.
name|isValidType
argument_list|(
name|idctx
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|parentemd
operator|.
name|current
operator|!=
literal|null
operator|||
name|dotctx
operator|==
literal|null
operator|||
name|bracectx
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected static type ["
operator|+
name|id
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|varenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|getType
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|varenmd
operator|.
name|type
expr_stmt|;
name|parentemd
operator|.
name|statik
operator|=
literal|true
expr_stmt|;
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|utility
operator|.
name|isValidIdentifier
argument_list|(
name|idctx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|current
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected variable ["
operator|+
name|id
operator|+
literal|"] load."
argument_list|)
throw|;
block|}
name|varenmd
operator|.
name|last
operator|=
name|parentemd
operator|.
name|scope
operator|==
literal|0
operator|&&
name|dotctx
operator|==
literal|null
operator|&&
name|bracectx
operator|==
literal|null
expr_stmt|;
specifier|final
name|Variable
name|variable
init|=
name|utility
operator|.
name|getVariable
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unknown variable ["
operator|+
name|id
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// special cases: reserved words
if|if
condition|(
literal|"_score"
operator|.
name|equals
argument_list|(
name|id
argument_list|)
operator|||
literal|"_value"
operator|.
name|equals
argument_list|(
name|id
argument_list|)
operator|||
literal|"doc"
operator|.
name|equals
argument_list|(
name|id
argument_list|)
operator|||
literal|"ctx"
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// read-only: don't allow stores to ourself
if|if
condition|(
name|varenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Variable ["
operator|+
name|id
operator|+
literal|"] is read-only."
argument_list|)
throw|;
block|}
if|if
condition|(
literal|"_score"
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// track if the _score value is ever used, we will invoke Scorer.score() only once if so.
name|metadata
operator|.
name|scoreValueUsed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|"ctx"
operator|.
name|equals
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|// track if ctx value is ever used, we will invoke Map.get() only once if so.
name|metadata
operator|.
name|ctxValueUsed
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|varenmd
operator|.
name|target
operator|=
name|variable
operator|.
name|slot
expr_stmt|;
name|varenmd
operator|.
name|type
operator|=
name|variable
operator|.
name|type
expr_stmt|;
name|analyzeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|varenmd
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|bracectx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|processExtfield
name|void
name|processExtfield
parameter_list|(
specifier|final
name|ExtfieldContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|memberenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|memberenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|EXTID
argument_list|()
operator|==
literal|null
operator|&&
name|ctx
operator|.
name|EXTINTEGER
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
specifier|final
name|String
name|value
init|=
name|ctx
operator|.
name|EXTID
argument_list|()
operator|==
literal|null
condition|?
name|ctx
operator|.
name|EXTINTEGER
argument_list|()
operator|.
name|getText
argument_list|()
else|:
name|ctx
operator|.
name|EXTID
argument_list|()
operator|.
name|getText
argument_list|()
decl_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
name|memberenmd
operator|.
name|last
operator|=
name|parentemd
operator|.
name|scope
operator|==
literal|0
operator|&&
name|dotctx
operator|==
literal|null
operator|&&
name|bracectx
operator|==
literal|null
expr_stmt|;
specifier|final
name|boolean
name|store
init|=
name|memberenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|current
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected field ["
operator|+
name|value
operator|+
literal|"] load."
argument_list|)
throw|;
block|}
if|if
condition|(
name|parentemd
operator|.
name|current
operator|.
name|sort
operator|==
name|Sort
operator|.
name|ARRAY
condition|)
block|{
if|if
condition|(
literal|"length"
operator|.
name|equals
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|parentemd
operator|.
name|read
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Must read array field [length]."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|store
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Cannot write to read-only array field [length]."
argument_list|)
throw|;
block|}
name|memberenmd
operator|.
name|target
operator|=
literal|"#length"
expr_stmt|;
name|memberenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|intType
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|definition
operator|.
name|intType
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected array field ["
operator|+
name|value
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|parentemd
operator|.
name|current
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
name|memberenmd
operator|.
name|target
operator|=
name|value
expr_stmt|;
name|memberenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|defType
expr_stmt|;
name|analyzeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|memberenmd
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|Struct
name|struct
init|=
name|parentemd
operator|.
name|current
operator|.
name|struct
decl_stmt|;
specifier|final
name|Field
name|field
init|=
name|parentemd
operator|.
name|statik
condition|?
name|struct
operator|.
name|statics
operator|.
name|get
argument_list|(
name|value
argument_list|)
else|:
name|struct
operator|.
name|members
operator|.
name|get
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|store
operator|&&
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isFinal
argument_list|(
name|field
operator|.
name|reflect
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Cannot write to read-only"
operator|+
literal|" field ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|memberenmd
operator|.
name|target
operator|=
name|field
expr_stmt|;
name|memberenmd
operator|.
name|type
operator|=
name|field
operator|.
name|type
expr_stmt|;
name|analyzeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|memberenmd
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|boolean
name|get
init|=
name|parentemd
operator|.
name|read
operator|||
name|parentemd
operator|.
name|token
operator|>
literal|0
operator|||
operator|!
name|memberenmd
operator|.
name|last
decl_stmt|;
specifier|final
name|boolean
name|set
init|=
name|memberenmd
operator|.
name|last
operator|&&
name|store
decl_stmt|;
name|Method
name|getter
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"get"
operator|+
name|Character
operator|.
name|toUpperCase
argument_list|(
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Method
name|setter
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"set"
operator|+
name|Character
operator|.
name|toUpperCase
argument_list|(
name|value
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|+
name|value
operator|.
name|substring
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Object
name|constant
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
operator|(
name|getter
operator|.
name|rtn
operator|.
name|sort
operator|==
name|Sort
operator|.
name|VOID
operator|||
operator|!
name|getter
operator|.
name|arguments
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal get shortcut on field ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|setter
operator|!=
literal|null
operator|&&
operator|(
name|setter
operator|.
name|rtn
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|VOID
operator|||
name|setter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal set shortcut on field ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|Type
name|settype
init|=
name|setter
operator|==
literal|null
condition|?
literal|null
else|:
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|getter
operator|==
literal|null
operator|&&
name|setter
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|EXTID
argument_list|()
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parentemd
operator|.
name|current
operator|.
name|clazz
operator|.
name|asSubclass
argument_list|(
name|Map
operator|.
name|class
argument_list|)
expr_stmt|;
name|getter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"get"
argument_list|)
expr_stmt|;
name|setter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"put"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
operator|(
name|getter
operator|.
name|rtn
operator|.
name|sort
operator|==
name|Sort
operator|.
name|VOID
operator|||
name|getter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|getter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|STRING
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal map get shortcut ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|setter
operator|!=
literal|null
operator|&&
operator|(
name|setter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|||
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|STRING
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal map set shortcut ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
name|setter
operator|!=
literal|null
operator|&&
operator|!
name|getter
operator|.
name|rtn
operator|.
name|equals
argument_list|(
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Shortcut argument types must match."
argument_list|)
throw|;
block|}
name|settype
operator|=
name|setter
operator|==
literal|null
condition|?
literal|null
else|:
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|constant
operator|=
name|value
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|exception
parameter_list|)
block|{
comment|//Do nothing.
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|EXTINTEGER
argument_list|()
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|parentemd
operator|.
name|current
operator|.
name|clazz
operator|.
name|asSubclass
argument_list|(
name|List
operator|.
name|class
argument_list|)
expr_stmt|;
name|getter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"get"
argument_list|)
expr_stmt|;
name|setter
operator|=
name|parentemd
operator|.
name|current
operator|.
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
literal|"set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
operator|(
name|getter
operator|.
name|rtn
operator|.
name|sort
operator|==
name|Sort
operator|.
name|VOID
operator|||
name|getter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|1
operator|||
name|getter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|INT
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal list get shortcut ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|setter
operator|!=
literal|null
operator|&&
operator|(
name|setter
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|!=
literal|2
operator|||
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|INT
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal list set shortcut ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
name|getter
operator|!=
literal|null
operator|&&
name|setter
operator|!=
literal|null
operator|&&
operator|!
name|getter
operator|.
name|rtn
operator|.
name|equals
argument_list|(
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Shortcut argument types must match."
argument_list|)
throw|;
block|}
name|settype
operator|=
name|setter
operator|==
literal|null
condition|?
literal|null
else|:
name|setter
operator|.
name|arguments
operator|.
name|get
argument_list|(
literal|1
argument_list|)
expr_stmt|;
try|try
block|{
name|constant
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Illegal list shortcut value ["
operator|+
name|value
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|exception
parameter_list|)
block|{
comment|//Do nothing.
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
operator|(
name|get
operator|||
name|set
operator|)
operator|&&
operator|(
operator|!
name|get
operator|||
name|getter
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|!
name|set
operator|||
name|setter
operator|!=
literal|null
operator|)
condition|)
block|{
name|memberenmd
operator|.
name|target
operator|=
operator|new
name|Object
index|[]
block|{
name|getter
block|,
name|setter
block|,
name|constant
operator|!=
literal|null
block|,
name|constant
block|}
expr_stmt|;
name|memberenmd
operator|.
name|type
operator|=
name|get
condition|?
name|getter
operator|.
name|rtn
else|:
name|settype
expr_stmt|;
name|analyzeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|get
condition|?
name|getter
operator|.
name|rtn
else|:
name|setter
operator|.
name|rtn
expr_stmt|;
block|}
block|}
if|if
condition|(
name|memberenmd
operator|.
name|target
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unknown field ["
operator|+
name|value
operator|+
literal|"] for type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
name|parentemd
operator|.
name|statik
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|bracectx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processExtnew
name|void
name|processExtnew
parameter_list|(
specifier|final
name|ExtnewContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|newenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|newenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
name|newenmd
operator|.
name|last
operator|=
name|parentemd
operator|.
name|scope
operator|==
literal|0
operator|&&
name|dotctx
operator|==
literal|null
expr_stmt|;
specifier|final
name|IdentifierContext
name|idctx
init|=
name|ctx
operator|.
name|identifier
argument_list|()
decl_stmt|;
specifier|final
name|String
name|type
init|=
name|idctx
operator|.
name|getText
argument_list|()
decl_stmt|;
name|utility
operator|.
name|isValidType
argument_list|(
name|idctx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|current
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected new call."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|newenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Cannot assign a value to a new call."
argument_list|)
throw|;
block|}
specifier|final
name|Struct
name|struct
init|=
name|definition
operator|.
name|structs
operator|.
name|get
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|newclass
init|=
name|ctx
operator|.
name|arguments
argument_list|()
operator|!=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|newarray
init|=
operator|!
name|ctx
operator|.
name|expression
argument_list|()
operator|.
name|isEmpty
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|ExpressionContext
argument_list|>
name|arguments
init|=
name|newclass
condition|?
name|ctx
operator|.
name|arguments
argument_list|()
operator|.
name|expression
argument_list|()
else|:
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|int
name|size
init|=
name|arguments
operator|.
name|size
argument_list|()
decl_stmt|;
name|Type
index|[]
name|types
decl_stmt|;
if|if
condition|(
name|newarray
condition|)
block|{
if|if
condition|(
operator|!
name|parentemd
operator|.
name|read
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"A newly created array must be assigned."
argument_list|)
throw|;
block|}
name|types
operator|=
operator|new
name|Type
index|[
name|size
index|]
expr_stmt|;
name|Arrays
operator|.
name|fill
argument_list|(
name|types
argument_list|,
name|definition
operator|.
name|intType
argument_list|)
expr_stmt|;
name|newenmd
operator|.
name|target
operator|=
literal|"#makearray"
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
name|newenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|getType
argument_list|(
name|struct
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|newenmd
operator|.
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|newenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|getType
argument_list|(
name|struct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|definition
operator|.
name|getType
argument_list|(
name|struct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"A newly created array cannot have zero dimensions."
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|newclass
condition|)
block|{
specifier|final
name|Constructor
name|constructor
init|=
name|struct
operator|.
name|constructors
operator|.
name|get
argument_list|(
literal|"new"
argument_list|)
decl_stmt|;
if|if
condition|(
name|constructor
operator|!=
literal|null
condition|)
block|{
name|types
operator|=
operator|new
name|Type
index|[
name|constructor
operator|.
name|arguments
operator|.
name|size
argument_list|()
index|]
expr_stmt|;
name|constructor
operator|.
name|arguments
operator|.
name|toArray
argument_list|(
name|types
argument_list|)
expr_stmt|;
name|newenmd
operator|.
name|target
operator|=
name|constructor
expr_stmt|;
name|newenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|getType
argument_list|(
name|struct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|parentemd
operator|.
name|statement
operator|=
operator|!
name|parentemd
operator|.
name|read
operator|&&
name|newenmd
operator|.
name|last
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|newenmd
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unknown new call on type ["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unknown state."
argument_list|)
throw|;
block|}
if|if
condition|(
name|size
operator|!=
name|types
operator|.
name|length
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"When calling constructor on type "
operator|+
literal|"["
operator|+
name|struct
operator|.
name|name
operator|+
literal|"] expected ["
operator|+
name|types
operator|.
name|length
operator|+
literal|"] arguments,"
operator|+
literal|" but found ["
operator|+
name|arguments
operator|.
name|size
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
for|for
control|(
name|int
name|argument
init|=
literal|0
init|;
name|argument
operator|<
name|size
condition|;
operator|++
name|argument
control|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|AnalyzerUtility
operator|.
name|updateExpressionTree
argument_list|(
name|arguments
operator|.
name|get
argument_list|(
name|argument
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|createExpressionMetadata
argument_list|(
name|exprctx
argument_list|)
decl_stmt|;
name|expremd
operator|.
name|to
operator|=
name|types
index|[
name|argument
index|]
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|caster
operator|.
name|markCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|processExtstring
name|void
name|processExtstring
parameter_list|(
specifier|final
name|ExtstringContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|memberenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|memberenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|String
name|string
init|=
name|ctx
operator|.
name|STRING
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|ctx
operator|.
name|STRING
argument_list|()
operator|.
name|getText
argument_list|()
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
name|memberenmd
operator|.
name|last
operator|=
name|parentemd
operator|.
name|scope
operator|==
literal|0
operator|&&
name|dotctx
operator|==
literal|null
operator|&&
name|bracectx
operator|==
literal|null
expr_stmt|;
specifier|final
name|boolean
name|store
init|=
name|memberenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
decl_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|current
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected String constant ["
operator|+
name|string
operator|+
literal|"]."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|parentemd
operator|.
name|read
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Must read String constant ["
operator|+
name|string
operator|+
literal|"]."
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|store
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|AnalyzerUtility
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Cannot write to read-only String constant ["
operator|+
name|string
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|memberenmd
operator|.
name|target
operator|=
name|string
expr_stmt|;
name|memberenmd
operator|.
name|type
operator|=
name|definition
operator|.
name|stringType
expr_stmt|;
name|parentemd
operator|.
name|current
operator|=
name|definition
operator|.
name|stringType
expr_stmt|;
if|if
condition|(
name|memberenmd
operator|.
name|last
condition|)
block|{
name|parentemd
operator|.
name|constant
operator|=
name|string
expr_stmt|;
block|}
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|dotctx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|metadata
operator|.
name|createExtNodeMetadata
argument_list|(
name|parent
argument_list|,
name|bracectx
argument_list|)
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|analyzeLoadStoreExternal
specifier|private
name|void
name|analyzeLoadStoreExternal
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
specifier|final
name|ExtNodeMetadata
name|extenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|ParserRuleContext
name|parent
init|=
name|extenmd
operator|.
name|parent
decl_stmt|;
specifier|final
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|extenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
condition|)
block|{
specifier|final
name|ParserRuleContext
name|store
init|=
name|parentemd
operator|.
name|storeExpr
decl_stmt|;
specifier|final
name|ExpressionMetadata
name|storeemd
init|=
name|metadata
operator|.
name|createExpressionMetadata
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
decl_stmt|;
specifier|final
name|int
name|token
init|=
name|parentemd
operator|.
name|token
decl_stmt|;
if|if
condition|(
name|token
operator|>
literal|0
condition|)
block|{
name|analyzer
operator|.
name|visit
argument_list|(
name|store
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|add
init|=
name|token
operator|==
name|ADD
decl_stmt|;
specifier|final
name|boolean
name|xor
init|=
name|token
operator|==
name|BWAND
operator|||
name|token
operator|==
name|BWXOR
operator|||
name|token
operator|==
name|BWOR
decl_stmt|;
specifier|final
name|boolean
name|decimal
init|=
name|token
operator|==
name|MUL
operator|||
name|token
operator|==
name|DIV
operator|||
name|token
operator|==
name|REM
operator|||
name|token
operator|==
name|SUB
decl_stmt|;
name|extenmd
operator|.
name|promote
operator|=
name|add
condition|?
name|promoter
operator|.
name|promoteAdd
argument_list|(
name|extenmd
operator|.
name|type
argument_list|,
name|storeemd
operator|.
name|from
argument_list|)
else|:
name|xor
condition|?
name|promoter
operator|.
name|promoteXor
argument_list|(
name|extenmd
operator|.
name|type
argument_list|,
name|storeemd
operator|.
name|from
argument_list|)
else|:
name|promoter
operator|.
name|promoteNumeric
argument_list|(
name|extenmd
operator|.
name|type
argument_list|,
name|storeemd
operator|.
name|from
argument_list|,
name|decimal
argument_list|,
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|extenmd
operator|.
name|promote
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot apply compound assignment to "
operator|+
literal|"types ["
operator|+
name|extenmd
operator|.
name|type
operator|.
name|name
operator|+
literal|"] and ["
operator|+
name|storeemd
operator|.
name|from
operator|.
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
name|extenmd
operator|.
name|castFrom
operator|=
name|caster
operator|.
name|getLegalCast
argument_list|(
name|source
argument_list|,
name|extenmd
operator|.
name|type
argument_list|,
name|extenmd
operator|.
name|promote
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|extenmd
operator|.
name|castTo
operator|=
name|caster
operator|.
name|getLegalCast
argument_list|(
name|source
argument_list|,
name|extenmd
operator|.
name|promote
argument_list|,
name|extenmd
operator|.
name|type
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|storeemd
operator|.
name|to
operator|=
name|add
operator|&&
name|extenmd
operator|.
name|promote
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
condition|?
name|storeemd
operator|.
name|from
else|:
name|extenmd
operator|.
name|promote
expr_stmt|;
name|caster
operator|.
name|markCast
argument_list|(
name|storeemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|storeemd
operator|.
name|to
operator|=
name|extenmd
operator|.
name|type
expr_stmt|;
name|analyzer
operator|.
name|visit
argument_list|(
name|store
argument_list|)
expr_stmt|;
name|caster
operator|.
name|markCast
argument_list|(
name|storeemd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

