begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Cast
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Transform
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Label
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|GeneratorAdapter
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_ADD_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_AND_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_DIV_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_LSH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_MUL_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_OR_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_REM_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_RSH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_SUB_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_USH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_XOR_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|PAINLESS_ERROR_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|REMWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|REMWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_BOOLEAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_CHAR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_OBJECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_STRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_CONSTRUCTOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_TOSTRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOBYTEEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOBYTEEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOBYTEWOOVERFLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOBYTEWOOVERFLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOCHAREXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOCHAREXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOCHARWOOVERFLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOCHARWOOVERFLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOFLOATWOOVERFLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOINTEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOINTWOOVERFLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOINTWOOVERFLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOLONGWOOVERFLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOLONGWOOVERFLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOSHORTEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOSHORTEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOSHORTWOOVERFLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|TOSHORTWOOVERFLOW_FLOAT
import|;
end_import

begin_comment
comment|/**  * Set of methods used during the writing phase of compilation  * shared by the nodes of the Painless tree.  */
end_comment

begin_class
DECL|class|WriterUtility
specifier|public
specifier|final
class|class
name|WriterUtility
block|{
DECL|method|writeLoopCounter
specifier|public
specifier|static
name|void
name|writeLoopCounter
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|int
name|slot
parameter_list|,
specifier|final
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|>
operator|-
literal|1
condition|)
block|{
specifier|final
name|Label
name|end
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|adapter
operator|.
name|iinc
argument_list|(
name|slot
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|visitVarInsn
argument_list|(
name|Opcodes
operator|.
name|ILOAD
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|push
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|ifICmp
argument_list|(
name|GeneratorAdapter
operator|.
name|GT
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|throwException
argument_list|(
name|PAINLESS_ERROR_TYPE
argument_list|,
literal|"The maximum number of statements that can be executed in a loop has been reached."
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|mark
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeCast
specifier|public
specifier|static
name|void
name|writeCast
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|Cast
name|cast
parameter_list|)
block|{
if|if
condition|(
name|cast
operator|instanceof
name|Transform
condition|)
block|{
specifier|final
name|Transform
name|transform
init|=
operator|(
name|Transform
operator|)
name|cast
decl_stmt|;
if|if
condition|(
name|transform
operator|.
name|upcast
operator|!=
literal|null
condition|)
block|{
name|adapter
operator|.
name|checkCast
argument_list|(
name|transform
operator|.
name|upcast
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|transform
operator|.
name|method
operator|.
name|reflect
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|transform
operator|.
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isInterface
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|clazz
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|adapter
operator|.
name|invokeInterface
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|transform
operator|.
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|transform
operator|.
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transform
operator|.
name|downcast
operator|!=
literal|null
condition|)
block|{
name|adapter
operator|.
name|checkCast
argument_list|(
name|transform
operator|.
name|downcast
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cast
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Type
name|from
init|=
name|cast
operator|.
name|from
decl_stmt|;
specifier|final
name|Type
name|to
init|=
name|cast
operator|.
name|to
decl_stmt|;
if|if
condition|(
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|from
operator|.
name|sort
operator|.
name|numeric
operator|&&
name|from
operator|.
name|sort
operator|.
name|primitive
operator|&&
name|to
operator|.
name|sort
operator|.
name|numeric
operator|&&
name|to
operator|.
name|sort
operator|.
name|primitive
condition|)
block|{
name|adapter
operator|.
name|cast
argument_list|(
name|from
operator|.
name|type
argument_list|,
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|from
operator|.
name|clazz
operator|.
name|asSubclass
argument_list|(
name|to
operator|.
name|clazz
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|exception
parameter_list|)
block|{
name|adapter
operator|.
name|checkCast
argument_list|(
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|writeBranch
specifier|public
specifier|static
name|void
name|writeBranch
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|Label
name|tru
parameter_list|,
specifier|final
name|Label
name|fals
parameter_list|)
block|{
if|if
condition|(
name|tru
operator|!=
literal|null
condition|)
block|{
name|adapter
operator|.
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFNE
argument_list|,
name|tru
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fals
operator|!=
literal|null
condition|)
block|{
name|adapter
operator|.
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFEQ
argument_list|,
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeNewStrings
specifier|public
specifier|static
name|void
name|writeNewStrings
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|)
block|{
name|adapter
operator|.
name|newInstance
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|dup
argument_list|()
expr_stmt|;
name|adapter
operator|.
name|invokeConstructor
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_CONSTRUCTOR
argument_list|)
expr_stmt|;
block|}
DECL|method|writeAppendStrings
specifier|public
specifier|static
name|void
name|writeAppendStrings
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|Sort
name|sort
parameter_list|)
block|{
switch|switch
condition|(
name|sort
condition|)
block|{
case|case
name|BOOL
case|:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_BOOLEAN
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_STRING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_OBJECT
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeToStrings
specifier|public
specifier|static
name|void
name|writeToStrings
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|)
block|{
name|adapter
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_TOSTRING
argument_list|)
expr_stmt|;
block|}
DECL|method|writeBinaryInstruction
specifier|public
specifier|static
name|void
name|writeBinaryInstruction
parameter_list|(
specifier|final
name|CompilerSettings
name|settings
parameter_list|,
specifier|final
name|Definition
name|definition
parameter_list|,
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|String
name|location
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|Operation
name|operation
parameter_list|)
block|{
specifier|final
name|Sort
name|sort
init|=
name|type
operator|.
name|sort
decl_stmt|;
name|boolean
name|exact
init|=
operator|!
name|settings
operator|.
name|getNumericOverflow
argument_list|()
operator|&&
operator|(
operator|(
name|sort
operator|==
name|Sort
operator|.
name|INT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|LONG
operator|)
operator|&&
operator|(
name|operation
operator|==
name|Operation
operator|.
name|MUL
operator|||
name|operation
operator|==
name|Operation
operator|.
name|DIV
operator|||
name|operation
operator|==
name|Operation
operator|.
name|ADD
operator|||
name|operation
operator|==
name|Operation
operator|.
name|SUB
operator|)
operator|||
operator|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
operator|)
operator|&&
operator|(
name|operation
operator|==
name|Operation
operator|.
name|MUL
operator|||
name|operation
operator|==
name|Operation
operator|.
name|DIV
operator|||
name|operation
operator|==
name|Operation
operator|.
name|REM
operator|||
name|operation
operator|==
name|Operation
operator|.
name|ADD
operator|||
name|operation
operator|==
name|Operation
operator|.
name|SUB
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|exact
condition|)
block|{
switch|switch
condition|(
name|sort
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|MULEXACT_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|ADDEXACT_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|SUBEXACT_INT
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LONG
case|:
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|MULEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|ADDEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|SUBEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FLOAT
case|:
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|MULWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|REMWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|ADDWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|SUBWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error "
operator|+
name|location
operator|+
literal|": Illegal tree structure."
argument_list|)
throw|;
block|}
break|break;
case|case
name|DOUBLE
case|:
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|MULWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|REMWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|ADDWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|SUBWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error "
operator|+
name|location
operator|+
literal|": Illegal tree structure."
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error "
operator|+
name|location
operator|+
literal|": Illegal tree structure."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
operator|)
operator|&&
operator|(
name|operation
operator|==
name|Operation
operator|.
name|LSH
operator|||
name|operation
operator|==
name|Operation
operator|.
name|USH
operator|||
name|operation
operator|==
name|Operation
operator|.
name|RSH
operator|||
name|operation
operator|==
name|Operation
operator|.
name|BWAND
operator|||
name|operation
operator|==
name|Operation
operator|.
name|XOR
operator|||
name|operation
operator|==
name|Operation
operator|.
name|BWOR
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error "
operator|+
name|location
operator|+
literal|": Illegal tree structure."
argument_list|)
throw|;
block|}
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_MUL_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_DIV_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_REM_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_ADD_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_SUB_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_LSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_RSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_USH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_AND_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_XOR_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_OR_CALL
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error "
operator|+
name|location
operator|+
literal|": Illegal tree structure."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|MUL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|DIV
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|REM
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|ADD
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SUB
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|USHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|AND
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|XOR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|adapter
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|OR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Error "
operator|+
name|location
operator|+
literal|": Illegal tree structure."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * Called for any compound assignment (including increment/decrement instructions).      * We have to be stricter than writeBinary and do overflow checks against the original type's size      * instead of the promoted type's size, since the result will be implicitly cast back.      *      * @return This will be true if an instruction is written, false otherwise.      */
DECL|method|writeExactInstruction
specifier|public
specifier|static
name|boolean
name|writeExactInstruction
parameter_list|(
specifier|final
name|Definition
name|definition
parameter_list|,
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|Sort
name|fsort
parameter_list|,
specifier|final
name|Sort
name|tsort
parameter_list|)
block|{
if|if
condition|(
name|fsort
operator|==
name|Sort
operator|.
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOFLOATWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|FLOAT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOFLOATWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|floatobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|LONG_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|longobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|INT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|intobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|fsort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
block|{
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|LONG_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|longobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|INT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|intobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|fsort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|TOINTEXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|INT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|TOINTEXACT_LONG
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|intobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_LONG
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_LONG
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_LONG
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|fsort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_INT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_INT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_INT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_INT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_INT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|adapter
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_INT
argument_list|)
expr_stmt|;
name|adapter
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|writeDup
specifier|public
specifier|static
name|void
name|writeDup
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|int
name|xsize
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|xsize
operator|==
literal|2
condition|)
block|{
name|adapter
operator|.
name|dupX2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xsize
operator|==
literal|1
condition|)
block|{
name|adapter
operator|.
name|dupX1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|adapter
operator|.
name|dup
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|xsize
operator|==
literal|2
condition|)
block|{
name|adapter
operator|.
name|dup2X2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xsize
operator|==
literal|1
condition|)
block|{
name|adapter
operator|.
name|dup2X1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|adapter
operator|.
name|dup2
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|writePop
specifier|public
specifier|static
name|void
name|writePop
parameter_list|(
specifier|final
name|GeneratorAdapter
name|adapter
parameter_list|,
specifier|final
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|adapter
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|adapter
operator|.
name|pop2
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|WriterUtility
specifier|private
name|WriterUtility
parameter_list|()
block|{}
block|}
end_class

end_unit

