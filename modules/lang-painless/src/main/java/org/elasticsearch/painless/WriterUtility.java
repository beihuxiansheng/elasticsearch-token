begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|ParserRuleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Label
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|GeneratorAdapter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ADD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWAND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWXOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DIV
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|LSH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|MUL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|REM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|RSH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|SUB
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|USH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|ADDWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_ADD_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_AND_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_DIV_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_LSH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_MUL_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_OR_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_REM_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_RSH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_SUB_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_USH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_XOR_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DIVWOOVERLOW_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MULWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|REMWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|REMWOOVERLOW_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_BOOLEAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_CHAR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_OBJECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_STRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_CONSTRUCTOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_TOSTRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBEXACT_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBEXACT_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBWOOVERLOW_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|SUBWOOVERLOW_FLOAT
import|;
end_import

begin_class
DECL|class|WriterUtility
class|class
name|WriterUtility
block|{
DECL|class|Branch
specifier|static
class|class
name|Branch
block|{
DECL|field|source
specifier|final
name|ParserRuleContext
name|source
decl_stmt|;
DECL|field|begin
name|Label
name|begin
init|=
literal|null
decl_stmt|;
DECL|field|end
name|Label
name|end
init|=
literal|null
decl_stmt|;
DECL|field|tru
name|Label
name|tru
init|=
literal|null
decl_stmt|;
DECL|field|fals
name|Label
name|fals
init|=
literal|null
decl_stmt|;
DECL|method|Branch
specifier|private
name|Branch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
block|}
comment|/**      * A utility method to output consistent error messages.      * @param ctx The ANTLR node the error occurred in.      * @return The error message with tacked on line number and character position.      */
DECL|method|error
specifier|static
name|String
name|error
parameter_list|(
specifier|final
name|ParserRuleContext
name|ctx
parameter_list|)
block|{
return|return
literal|"Writer Error ["
operator|+
name|ctx
operator|.
name|getStart
argument_list|()
operator|.
name|getLine
argument_list|()
operator|+
literal|":"
operator|+
name|ctx
operator|.
name|getStart
argument_list|()
operator|.
name|getCharPositionInLine
argument_list|()
operator|+
literal|"]: "
return|;
block|}
DECL|field|definition
specifier|private
specifier|final
name|Definition
name|definition
decl_stmt|;
DECL|field|settings
specifier|private
specifier|final
name|CompilerSettings
name|settings
decl_stmt|;
DECL|field|execute
specifier|private
specifier|final
name|GeneratorAdapter
name|execute
decl_stmt|;
DECL|field|branches
specifier|private
specifier|final
name|Map
argument_list|<
name|ParserRuleContext
argument_list|,
name|Branch
argument_list|>
name|branches
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|jumps
specifier|private
specifier|final
name|Deque
argument_list|<
name|Branch
argument_list|>
name|jumps
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|strings
specifier|private
specifier|final
name|Set
argument_list|<
name|ParserRuleContext
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|WriterUtility
name|WriterUtility
parameter_list|(
specifier|final
name|Metadata
name|metadata
parameter_list|,
specifier|final
name|GeneratorAdapter
name|execute
parameter_list|)
block|{
name|definition
operator|=
name|metadata
operator|.
name|definition
expr_stmt|;
name|settings
operator|=
name|metadata
operator|.
name|settings
expr_stmt|;
name|this
operator|.
name|execute
operator|=
name|execute
expr_stmt|;
block|}
DECL|method|markBranch
name|Branch
name|markBranch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|ParserRuleContext
modifier|...
name|nodes
parameter_list|)
block|{
specifier|final
name|Branch
name|branch
init|=
operator|new
name|Branch
argument_list|(
name|source
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|ParserRuleContext
name|node
range|:
name|nodes
control|)
block|{
name|branches
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
return|return
name|branch
return|;
block|}
DECL|method|copyBranch
name|void
name|copyBranch
parameter_list|(
specifier|final
name|Branch
name|branch
parameter_list|,
specifier|final
name|ParserRuleContext
modifier|...
name|nodes
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ParserRuleContext
name|node
range|:
name|nodes
control|)
block|{
name|branches
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getBranch
name|Branch
name|getBranch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
return|return
name|branches
operator|.
name|get
argument_list|(
name|source
argument_list|)
return|;
block|}
DECL|method|checkWriteBranch
name|void
name|checkWriteBranch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|branch
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|.
name|tru
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFNE
argument_list|,
name|branch
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|branch
operator|.
name|fals
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFEQ
argument_list|,
name|branch
operator|.
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|pushJump
name|void
name|pushJump
parameter_list|(
specifier|final
name|Branch
name|branch
parameter_list|)
block|{
name|jumps
operator|.
name|push
argument_list|(
name|branch
argument_list|)
expr_stmt|;
block|}
DECL|method|peekJump
name|Branch
name|peekJump
parameter_list|()
block|{
return|return
name|jumps
operator|.
name|peek
argument_list|()
return|;
block|}
DECL|method|popJump
name|void
name|popJump
parameter_list|()
block|{
name|jumps
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
DECL|method|addStrings
name|void
name|addStrings
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
name|strings
operator|.
name|add
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
DECL|method|containsStrings
name|boolean
name|containsStrings
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
return|return
name|strings
operator|.
name|contains
argument_list|(
name|source
argument_list|)
return|;
block|}
DECL|method|removeStrings
name|void
name|removeStrings
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
name|strings
operator|.
name|remove
argument_list|(
name|source
argument_list|)
expr_stmt|;
block|}
DECL|method|writeDup
name|void
name|writeDup
parameter_list|(
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|boolean
name|x1
parameter_list|,
specifier|final
name|boolean
name|x2
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|x2
condition|)
block|{
name|execute
operator|.
name|dupX2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
condition|)
block|{
name|execute
operator|.
name|dupX1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|x2
condition|)
block|{
name|execute
operator|.
name|dup2X2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
condition|)
block|{
name|execute
operator|.
name|dup2X1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|dup2
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|writePop
name|void
name|writePop
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|execute
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|execute
operator|.
name|pop2
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|writeConstant
name|void
name|writeConstant
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|constant
parameter_list|)
block|{
if|if
condition|(
name|constant
operator|instanceof
name|Number
condition|)
block|{
name|writeNumeric
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|instanceof
name|Character
condition|)
block|{
name|writeNumeric
argument_list|(
name|source
argument_list|,
call|(
name|int
call|)
argument_list|(
name|char
argument_list|)
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|instanceof
name|String
condition|)
block|{
name|writeString
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|instanceof
name|Boolean
condition|)
block|{
name|writeBoolean
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeNumeric
name|void
name|writeNumeric
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|numeric
parameter_list|)
block|{
if|if
condition|(
name|numeric
operator|instanceof
name|Double
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|double
operator|)
name|numeric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numeric
operator|instanceof
name|Float
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|float
operator|)
name|numeric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numeric
operator|instanceof
name|Long
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|long
operator|)
name|numeric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numeric
operator|instanceof
name|Number
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|numeric
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeString
name|void
name|writeString
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|string
parameter_list|)
block|{
if|if
condition|(
name|string
operator|instanceof
name|String
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|String
operator|)
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeBoolean
name|void
name|writeBoolean
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|bool
parameter_list|)
block|{
if|if
condition|(
name|bool
operator|instanceof
name|Boolean
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|boolean
operator|)
name|bool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeNewStrings
name|void
name|writeNewStrings
parameter_list|()
block|{
name|execute
operator|.
name|newInstance
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
name|execute
operator|.
name|invokeConstructor
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_CONSTRUCTOR
argument_list|)
expr_stmt|;
block|}
DECL|method|writeAppendStrings
name|void
name|writeAppendStrings
parameter_list|(
specifier|final
name|Sort
name|sort
parameter_list|)
block|{
switch|switch
condition|(
name|sort
condition|)
block|{
case|case
name|BOOL
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_BOOLEAN
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_STRING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_OBJECT
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeToStrings
name|void
name|writeToStrings
parameter_list|()
block|{
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_TOSTRING
argument_list|)
expr_stmt|;
block|}
DECL|method|writeBinaryInstruction
name|void
name|writeBinaryInstruction
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|token
parameter_list|)
block|{
specifier|final
name|Sort
name|sort
init|=
name|type
operator|.
name|sort
decl_stmt|;
specifier|final
name|boolean
name|exact
init|=
operator|!
name|settings
operator|.
name|getNumericOverflow
argument_list|()
operator|&&
operator|(
operator|(
name|sort
operator|==
name|Sort
operator|.
name|INT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|LONG
operator|)
operator|&&
operator|(
name|token
operator|==
name|MUL
operator|||
name|token
operator|==
name|DIV
operator|||
name|token
operator|==
name|ADD
operator|||
name|token
operator|==
name|SUB
operator|)
operator|||
operator|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
operator|)
operator|&&
operator|(
name|token
operator|==
name|MUL
operator|||
name|token
operator|==
name|DIV
operator|||
name|token
operator|==
name|REM
operator|||
name|token
operator|==
name|ADD
operator|||
name|token
operator|==
name|SUB
operator|)
operator|)
decl_stmt|;
comment|// If it's a 64-bit shift, fix-up the last argument to truncate to 32-bits.
comment|// Note that unlike java, this means we still do binary promotion of shifts,
comment|// but it keeps things simple, and this check works because we promote shifts.
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|LONG
operator|&&
operator|(
name|token
operator|==
name|LSH
operator|||
name|token
operator|==
name|USH
operator|||
name|token
operator|==
name|RSH
operator|)
condition|)
block|{
name|execute
operator|.
name|cast
argument_list|(
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|LONG_TYPE
argument_list|,
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|INT_TYPE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exact
condition|)
block|{
switch|switch
condition|(
name|sort
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|MULEXACT_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|ADDEXACT_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|SUBEXACT_INT
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|LONG
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|MULEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|ADDEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|SUBEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|FLOAT
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|MULWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|REMWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|ADDWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|SUBWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|DOUBLE
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|MULWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|REMWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|ADDWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|SUBWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
operator|)
operator|&&
operator|(
name|token
operator|==
name|LSH
operator|||
name|token
operator|==
name|USH
operator|||
name|token
operator|==
name|RSH
operator|||
name|token
operator|==
name|BWAND
operator|||
name|token
operator|==
name|BWXOR
operator|||
name|token
operator|==
name|BWOR
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_MUL_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_DIV_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_REM_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_ADD_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_SUB_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_LSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_RSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_USH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_AND_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWXOR
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_XOR_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_OR_CALL
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|MUL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|DIV
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|REM
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|ADD
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SUB
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|USHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|AND
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWXOR
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|XOR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|OR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|WriterUtility
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected state."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
block|}
end_class

end_unit

