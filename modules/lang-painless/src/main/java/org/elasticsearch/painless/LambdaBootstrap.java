begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|ClassWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|FieldVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Handle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|GeneratorAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|CallSite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|ConstantCallSite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|LambdaConversionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|InvocationTargetException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
operator|.
name|Lookup
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Compiler
operator|.
name|Loader
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|CLASS_VERSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DELEGATE_BOOTSTRAP_HANDLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_FINAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_PRIVATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_PUBLIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_STATIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_SUPER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_SYNTHETIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_INVOKEINTERFACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_INVOKESTATIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_INVOKEVIRTUAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_NEWINVOKESPECIAL
import|;
end_import

begin_comment
comment|/**  * LambdaBootstrap is used to generate all the code necessary to execute  * lambda functions and method references within Painless.  The code generation  * used here is based upon the following article:  * http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html  * However, it is a simplified version as Painless has no concept of generics  * or serialization.  LambdaBootstrap is being used as a replacement for  * {@link java.lang.invoke.LambdaMetafactory} since the Painless casting model  * cannot be fully supported through this class.  *  * For each lambda function/method reference used within a Painless script  * a class will be generated at link-time using the  * {@link LambdaBootstrap#lambdaBootstrap} method that contains the following:  * 1. member fields for any captured variables  * 2. a constructor that will take in captured variables and assign them to  * their respective member fields  * 3. if there are captures, a factory method that will take in captured  * variables and delegate them to the constructor  * 4. a method that will load the member fields representing captured variables  * and take in any other necessary values based on the arguments passed into the  * lambda function/reference method; it will then make a delegated call to the  * actual lambda function/reference method  *  * Take for example the following Painless script:  *  * {@code  * List list1 = new ArrayList(); "  * list1.add(2); "  * List list2 = new ArrayList(); "  * list1.forEach(x -> list2.add(x));"  * return list[0]"  * }  *  * The script contains a lambda function with a captured variable.  * The following Lambda class would be generated:  *  * {@code  *     public static final class $$Lambda0 implements Consumer {  *         private List arg$0;  *  *         public $$Lambda0(List arg$0) {  *             this.arg$0 = arg$0;  *         }  *  *         public static $$Lambda0 get$Lambda(List arg$0) {  *             return $$Lambda0(arg$0);  *         }  *  *         public void accept(Object val$0) {  *             Painless$Script.lambda$0(this.arg$0, val$0);  *         }  *     }  *  *     public class Painless$Script implements ... {  *         ...  *         public static lambda$0(List list2, Object x) {  *             list2.add(x);  *         }  *         ...  *     }  * }  *  * Note if the above didn't have a captured variable then  * the factory method get$Lambda would not have been generated.  * Also the accept method actually uses an invokedynamic  * instruction to call the lambda$0 method so that  * {@link MethodHandle#asType} can be used to do the necessary  * conversions between argument types without having to hard  * code them.  *  * When the {@link CallSite} is linked the linked method depends  * on whether or not there are captures.  If there are no captures  * the same instance of the generated lambda class will be  * returned each time by the factory method as there are no  * changing values other than the arguments.  If there are  * captures a new instance of the generated lambda class will  * be returned each time with the captures passed into the  * factory method to be stored in the member fields.  */
end_comment

begin_class
DECL|class|LambdaBootstrap
specifier|public
specifier|final
class|class
name|LambdaBootstrap
block|{
comment|/**      * Metadata for a captured variable used during code generation.      */
DECL|class|Capture
specifier|private
specifier|static
specifier|final
class|class
name|Capture
block|{
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|type
specifier|private
specifier|final
name|Type
name|type
decl_stmt|;
DECL|field|desc
specifier|private
specifier|final
name|String
name|desc
decl_stmt|;
comment|/**          * Converts incoming parameters into the name, type, and          * descriptor for the captured argument.          * @param count The captured argument count          * @param type The class type of the captured argument          */
DECL|method|Capture
specifier|private
name|Capture
parameter_list|(
name|int
name|count
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
literal|"arg$"
operator|+
name|count
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|Type
operator|.
name|getType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|desc
operator|=
name|this
operator|.
name|type
operator|.
name|getDescriptor
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * A counter used to generate a unique name      * for each lambda function/reference class.      */
DECL|field|COUNTER
specifier|private
specifier|static
specifier|final
name|AtomicLong
name|COUNTER
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/**      * Generates a lambda class for a lambda function/method reference      * within a Painless script.  Variables with the prefix interface are considered      * to represent values for code generated for the lambda class. Variables with      * the prefix delegate are considered to represent values for code generated      * within the Painless script.  The interface method delegates (calls) to the      * delegate method.      * @param lookup Standard {@link MethodHandles#lookup}      * @param interfaceMethodName Name of functional interface method that is called      * @param factoryMethodType The type of method to be linked to this CallSite; note that      *                          captured types are based on the parameters for this method      * @param interfaceMethodType The type of method representing the functional interface method      * @param delegateClassName The name of the Painless script class      * @param delegateInvokeType The type of method call to be made      *                           (static, virtual, interface, or constructor)      * @param delegateMethodName The name of the method to be called in the Painless script class      * @param delegateMethodType The type of method call in the Painless script class without      *                           the captured types      * @return A {@link CallSite} linked to a factory method for creating a lambda class      * that implements the expected functional interface      * @throws LambdaConversionException Thrown when an illegal type conversion occurs at link time      */
DECL|method|lambdaBootstrap
specifier|public
specifier|static
name|CallSite
name|lambdaBootstrap
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|String
name|interfaceMethodName
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|MethodType
name|interfaceMethodType
parameter_list|,
name|String
name|delegateClassName
parameter_list|,
name|int
name|delegateInvokeType
parameter_list|,
name|String
name|delegateMethodName
parameter_list|,
name|MethodType
name|delegateMethodType
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
name|String
name|factoryMethodName
init|=
literal|"get$lambda"
decl_stmt|;
name|String
name|lambdaClassName
init|=
name|lookup
operator|.
name|lookupClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|"$$Lambda"
operator|+
name|COUNTER
operator|.
name|getAndIncrement
argument_list|()
decl_stmt|;
name|Type
name|lambdaClassType
init|=
name|Type
operator|.
name|getType
argument_list|(
literal|"L"
operator|+
name|lambdaClassName
operator|+
literal|";"
argument_list|)
decl_stmt|;
name|validateTypes
argument_list|(
name|interfaceMethodType
argument_list|,
name|delegateMethodType
argument_list|)
expr_stmt|;
name|ClassWriter
name|cw
init|=
name|beginLambdaClass
argument_list|(
name|lambdaClassName
argument_list|,
name|factoryMethodType
operator|.
name|returnType
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
name|Capture
index|[]
name|captures
init|=
name|generateCaptureFields
argument_list|(
name|cw
argument_list|,
name|factoryMethodType
argument_list|)
decl_stmt|;
name|Method
name|constructorMethod
init|=
name|generateLambdaConstructor
argument_list|(
name|cw
argument_list|,
name|lambdaClassType
argument_list|,
name|factoryMethodType
argument_list|,
name|captures
argument_list|)
decl_stmt|;
if|if
condition|(
name|captures
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|generateFactoryMethod
argument_list|(
name|cw
argument_list|,
name|factoryMethodName
argument_list|,
name|factoryMethodType
argument_list|,
name|lambdaClassType
argument_list|,
name|constructorMethod
argument_list|)
expr_stmt|;
block|}
name|generateInterfaceMethod
argument_list|(
name|cw
argument_list|,
name|factoryMethodType
argument_list|,
name|lambdaClassName
argument_list|,
name|lambdaClassType
argument_list|,
name|interfaceMethodName
argument_list|,
name|interfaceMethodType
argument_list|,
name|delegateClassName
argument_list|,
name|delegateInvokeType
argument_list|,
name|delegateMethodName
argument_list|,
name|delegateMethodType
argument_list|,
name|captures
argument_list|)
expr_stmt|;
name|endLambdaClass
argument_list|(
name|cw
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|lambdaClass
init|=
name|createLambdaClass
argument_list|(
operator|(
name|Loader
operator|)
name|lookup
operator|.
name|lookupClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
argument_list|,
name|cw
argument_list|,
name|lambdaClassName
argument_list|)
decl_stmt|;
if|if
condition|(
name|captures
operator|.
name|length
operator|>
literal|0
condition|)
block|{
return|return
name|createCaptureCallSite
argument_list|(
name|lookup
argument_list|,
name|factoryMethodName
argument_list|,
name|factoryMethodType
argument_list|,
name|lambdaClass
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createNoCaptureCallSite
argument_list|(
name|factoryMethodType
argument_list|,
name|lambdaClass
argument_list|)
return|;
block|}
block|}
comment|/**      * Validates some conversions at link time.  Currently, only ensures that the lambda method      * with a return value cannot delegate to a delegate method with no return type.      */
DECL|method|validateTypes
specifier|private
specifier|static
name|void
name|validateTypes
parameter_list|(
name|MethodType
name|interfaceMethodType
parameter_list|,
name|MethodType
name|delegateMethodType
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
if|if
condition|(
name|interfaceMethodType
operator|.
name|returnType
argument_list|()
operator|!=
name|void
operator|.
name|class
operator|&&
name|delegateMethodType
operator|.
name|returnType
argument_list|()
operator|==
name|void
operator|.
name|class
condition|)
block|{
throw|throw
operator|new
name|LambdaConversionException
argument_list|(
literal|"lambda expects return type ["
operator|+
name|interfaceMethodType
operator|.
name|returnType
argument_list|()
operator|+
literal|"], but found return type [void]"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates the {@link ClassWriter} to be used for the lambda class generation.      */
DECL|method|beginLambdaClass
specifier|private
specifier|static
name|ClassWriter
name|beginLambdaClass
parameter_list|(
name|String
name|lambdaClassName
parameter_list|,
name|String
name|lambdaInterface
parameter_list|)
block|{
name|String
name|baseClass
init|=
name|Object
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|lambdaInterface
operator|=
name|lambdaInterface
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|int
name|modifiers
init|=
name|ACC_PUBLIC
operator||
name|ACC_STATIC
operator||
name|ACC_SUPER
operator||
name|ACC_FINAL
operator||
name|ACC_SYNTHETIC
decl_stmt|;
name|ClassWriter
name|cw
init|=
operator|new
name|ClassWriter
argument_list|(
name|ClassWriter
operator|.
name|COMPUTE_MAXS
argument_list|)
decl_stmt|;
name|cw
operator|.
name|visit
argument_list|(
name|CLASS_VERSION
argument_list|,
name|modifiers
argument_list|,
name|lambdaClassName
argument_list|,
literal|null
argument_list|,
name|baseClass
argument_list|,
operator|new
name|String
index|[]
block|{
name|lambdaInterface
block|}
argument_list|)
expr_stmt|;
return|return
name|cw
return|;
block|}
comment|/**      * Generates member fields for captured variables      * based on the parameters for the factory method.      * @return An array of captured variable metadata      * for generating method arguments later on      */
DECL|method|generateCaptureFields
specifier|private
specifier|static
name|Capture
index|[]
name|generateCaptureFields
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|)
block|{
name|int
name|captureTotal
init|=
name|factoryMethodType
operator|.
name|parameterCount
argument_list|()
decl_stmt|;
name|Capture
index|[]
name|captures
init|=
operator|new
name|Capture
index|[
name|captureTotal
index|]
decl_stmt|;
for|for
control|(
name|int
name|captureCount
init|=
literal|0
init|;
name|captureCount
operator|<
name|captureTotal
condition|;
operator|++
name|captureCount
control|)
block|{
name|captures
index|[
name|captureCount
index|]
operator|=
operator|new
name|Capture
argument_list|(
name|captureCount
argument_list|,
name|factoryMethodType
operator|.
name|parameterType
argument_list|(
name|captureCount
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|modifiers
init|=
name|ACC_PRIVATE
operator|+
name|ACC_FINAL
decl_stmt|;
name|FieldVisitor
name|fv
init|=
name|cw
operator|.
name|visitField
argument_list|(
name|modifiers
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|name
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|desc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|fv
operator|.
name|visitEnd
argument_list|()
expr_stmt|;
block|}
return|return
name|captures
return|;
block|}
comment|/**      * Generates a constructor that will take in captured      * arguments if any and store them in their respective      * member fields.      * @return The constructor {@link Method} used to      * call this method from a potential factory method      * if there are captured arguments      */
DECL|method|generateLambdaConstructor
specifier|private
specifier|static
name|Method
name|generateLambdaConstructor
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|Type
name|lambdaClassType
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|Capture
index|[]
name|captures
parameter_list|)
block|{
name|String
name|conName
init|=
literal|"<init>"
decl_stmt|;
name|String
name|conDesc
init|=
name|factoryMethodType
operator|.
name|changeReturnType
argument_list|(
name|void
operator|.
name|class
argument_list|)
operator|.
name|toMethodDescriptorString
argument_list|()
decl_stmt|;
name|Method
name|conMeth
init|=
operator|new
name|Method
argument_list|(
name|conName
argument_list|,
name|conDesc
argument_list|)
decl_stmt|;
name|Type
name|baseConType
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Method
name|baseConMeth
init|=
operator|new
name|Method
argument_list|(
name|conName
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|void
operator|.
name|class
argument_list|)
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|modifiers
init|=
name|ACC_PUBLIC
decl_stmt|;
name|GeneratorAdapter
name|constructor
init|=
operator|new
name|GeneratorAdapter
argument_list|(
name|modifiers
argument_list|,
name|conMeth
argument_list|,
name|cw
operator|.
name|visitMethod
argument_list|(
name|modifiers
argument_list|,
name|conName
argument_list|,
name|conDesc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|constructor
operator|.
name|visitCode
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|invokeConstructor
argument_list|(
name|baseConType
argument_list|,
name|baseConMeth
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|captureCount
init|=
literal|0
init|;
name|captureCount
operator|<
name|captures
operator|.
name|length
condition|;
operator|++
name|captureCount
control|)
block|{
name|constructor
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|loadArg
argument_list|(
name|captureCount
argument_list|)
expr_stmt|;
name|constructor
operator|.
name|putField
argument_list|(
name|lambdaClassType
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|name
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|constructor
operator|.
name|returnValue
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|endMethod
argument_list|()
expr_stmt|;
return|return
name|conMeth
return|;
block|}
comment|/**      * Generates a factory method that can be used to create the lambda class      * if there are captured variables.      */
DECL|method|generateFactoryMethod
specifier|private
specifier|static
name|void
name|generateFactoryMethod
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|String
name|factoryMethodName
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|Type
name|lambdaClassType
parameter_list|,
name|Method
name|constructorMethod
parameter_list|)
block|{
name|String
name|facDesc
init|=
name|factoryMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
decl_stmt|;
name|Method
name|facMeth
init|=
operator|new
name|Method
argument_list|(
name|factoryMethodName
argument_list|,
name|facDesc
argument_list|)
decl_stmt|;
name|int
name|modifiers
init|=
name|ACC_PUBLIC
operator||
name|ACC_STATIC
decl_stmt|;
name|GeneratorAdapter
name|factory
init|=
operator|new
name|GeneratorAdapter
argument_list|(
name|modifiers
argument_list|,
name|facMeth
argument_list|,
name|cw
operator|.
name|visitMethod
argument_list|(
name|modifiers
argument_list|,
name|factoryMethodName
argument_list|,
name|facDesc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|factory
operator|.
name|visitCode
argument_list|()
expr_stmt|;
name|factory
operator|.
name|newInstance
argument_list|(
name|lambdaClassType
argument_list|)
expr_stmt|;
name|factory
operator|.
name|dup
argument_list|()
expr_stmt|;
name|factory
operator|.
name|loadArgs
argument_list|()
expr_stmt|;
name|factory
operator|.
name|invokeConstructor
argument_list|(
name|lambdaClassType
argument_list|,
name|constructorMethod
argument_list|)
expr_stmt|;
name|factory
operator|.
name|returnValue
argument_list|()
expr_stmt|;
name|factory
operator|.
name|endMethod
argument_list|()
expr_stmt|;
block|}
comment|/**      * Generates the interface method that will delegate (call) to the delegate method.      */
DECL|method|generateInterfaceMethod
specifier|private
specifier|static
name|void
name|generateInterfaceMethod
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|String
name|lambdaClassName
parameter_list|,
name|Type
name|lambdaClassType
parameter_list|,
name|String
name|interfaceMethodName
parameter_list|,
name|MethodType
name|interfaceMethodType
parameter_list|,
name|String
name|delegateClassName
parameter_list|,
name|int
name|delegateInvokeType
parameter_list|,
name|String
name|delegateMethodName
parameter_list|,
name|MethodType
name|delegateMethodType
parameter_list|,
name|Capture
index|[]
name|captures
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
name|String
name|lamDesc
init|=
name|interfaceMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
decl_stmt|;
name|Method
name|lamMeth
init|=
operator|new
name|Method
argument_list|(
name|lambdaClassName
argument_list|,
name|lamDesc
argument_list|)
decl_stmt|;
name|int
name|modifiers
init|=
name|ACC_PUBLIC
decl_stmt|;
name|GeneratorAdapter
name|iface
init|=
operator|new
name|GeneratorAdapter
argument_list|(
name|modifiers
argument_list|,
name|lamMeth
argument_list|,
name|cw
operator|.
name|visitMethod
argument_list|(
name|modifiers
argument_list|,
name|interfaceMethodName
argument_list|,
name|lamDesc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|iface
operator|.
name|visitCode
argument_list|()
expr_stmt|;
comment|// Handles the case where a reference method refers to a constructor.
comment|// A new instance of the requested type will be created and the
comment|// constructor with no parameters will be called.
comment|// Example: String::new
if|if
condition|(
name|delegateInvokeType
operator|==
name|H_NEWINVOKESPECIAL
condition|)
block|{
name|String
name|conName
init|=
literal|"<init>"
decl_stmt|;
name|String
name|conDesc
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|void
operator|.
name|class
argument_list|)
operator|.
name|toMethodDescriptorString
argument_list|()
decl_stmt|;
name|Method
name|conMeth
init|=
operator|new
name|Method
argument_list|(
name|conName
argument_list|,
name|conDesc
argument_list|)
decl_stmt|;
name|Type
name|conType
init|=
name|Type
operator|.
name|getType
argument_list|(
name|delegateMethodType
operator|.
name|returnType
argument_list|()
argument_list|)
decl_stmt|;
name|iface
operator|.
name|newInstance
argument_list|(
name|conType
argument_list|)
expr_stmt|;
name|iface
operator|.
name|dup
argument_list|()
expr_stmt|;
name|iface
operator|.
name|invokeConstructor
argument_list|(
name|conType
argument_list|,
name|conMeth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Loads any captured variables onto the stack.
for|for
control|(
name|int
name|captureCount
init|=
literal|0
init|;
name|captureCount
operator|<
name|captures
operator|.
name|length
condition|;
operator|++
name|captureCount
control|)
block|{
name|iface
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|iface
operator|.
name|getField
argument_list|(
name|lambdaClassType
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|name
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
comment|// Loads any passed in arguments onto the stack.
name|iface
operator|.
name|loadArgs
argument_list|()
expr_stmt|;
comment|// Handles the case for a lambda function or a static reference method.
comment|// interfaceMethodType and delegateMethodType both have the captured types
comment|// inserted into their type signatures.  This later allows the delegate
comment|// method to be invoked dynamically and have the interface method types
comment|// appropriately converted to the delegate method types.
comment|// Example: Integer::parseInt
comment|// Example: something.each(x -> x + 1)
if|if
condition|(
name|delegateInvokeType
operator|==
name|H_INVOKESTATIC
condition|)
block|{
name|interfaceMethodType
operator|=
name|interfaceMethodType
operator|.
name|insertParameterTypes
argument_list|(
literal|0
argument_list|,
name|factoryMethodType
operator|.
name|parameterArray
argument_list|()
argument_list|)
expr_stmt|;
name|delegateMethodType
operator|=
name|delegateMethodType
operator|.
name|insertParameterTypes
argument_list|(
literal|0
argument_list|,
name|factoryMethodType
operator|.
name|parameterArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delegateInvokeType
operator|==
name|H_INVOKEVIRTUAL
operator|||
name|delegateInvokeType
operator|==
name|H_INVOKEINTERFACE
condition|)
block|{
comment|// Handles the case for a virtual or interface reference method with no captures.
comment|// delegateMethodType drops the 'this' parameter because it will be re-inserted
comment|// when the method handle for the dynamically invoked delegate method is created.
comment|// Example: Object::toString
if|if
condition|(
name|captures
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|delegateMethodType
operator|.
name|parameterType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|delegateClassName
operator|=
name|clazz
operator|.
name|getName
argument_list|()
expr_stmt|;
name|delegateMethodType
operator|=
name|delegateMethodType
operator|.
name|dropParameterTypes
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Handles the case for a virtual or interface reference method with 'this'
comment|// captured. interfaceMethodType inserts the 'this' type into its
comment|// method signature. This later allows the delegate
comment|// method to be invoked dynamically and have the interface method types
comment|// appropriately converted to the delegate method types.
comment|// Example: something::toString
block|}
elseif|else
if|if
condition|(
name|captures
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|factoryMethodType
operator|.
name|parameterType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|delegateClassName
operator|=
name|clazz
operator|.
name|getName
argument_list|()
expr_stmt|;
name|interfaceMethodType
operator|=
name|interfaceMethodType
operator|.
name|insertParameterTypes
argument_list|(
literal|0
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|LambdaConversionException
argument_list|(
literal|"unexpected number of captures [ "
operator|+
name|captures
operator|.
name|length
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unexpected invocation type ["
operator|+
name|delegateInvokeType
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|Handle
name|delegateHandle
init|=
operator|new
name|Handle
argument_list|(
name|delegateInvokeType
argument_list|,
name|delegateClassName
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|delegateMethodName
argument_list|,
name|delegateMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|,
name|delegateInvokeType
operator|==
name|H_INVOKEINTERFACE
argument_list|)
decl_stmt|;
name|iface
operator|.
name|invokeDynamic
argument_list|(
name|delegateMethodName
argument_list|,
name|Type
operator|.
name|getMethodType
argument_list|(
name|interfaceMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|)
operator|.
name|getDescriptor
argument_list|()
argument_list|,
name|DELEGATE_BOOTSTRAP_HANDLE
argument_list|,
name|delegateHandle
argument_list|)
expr_stmt|;
block|}
name|iface
operator|.
name|returnValue
argument_list|()
expr_stmt|;
name|iface
operator|.
name|endMethod
argument_list|()
expr_stmt|;
block|}
comment|/**      * Closes the {@link ClassWriter}.      */
DECL|method|endLambdaClass
specifier|private
specifier|static
name|void
name|endLambdaClass
parameter_list|(
name|ClassWriter
name|cw
parameter_list|)
block|{
name|cw
operator|.
name|visitEnd
argument_list|()
expr_stmt|;
block|}
comment|/**      * Defines the {@link Class} for the lambda class using the same {@link Loader}      * that originally defined the class for the Painless script.      */
DECL|method|createLambdaClass
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|createLambdaClass
parameter_list|(
name|Loader
name|loader
parameter_list|,
name|ClassWriter
name|cw
parameter_list|,
name|String
name|lambdaClassName
parameter_list|)
block|{
name|byte
index|[]
name|classBytes
init|=
name|cw
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
return|return
name|AccessController
operator|.
name|doPrivileged
argument_list|(
call|(
name|PrivilegedAction
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
call|)
argument_list|()
operator|->
name|loader
operator|.
name|defineLambda
argument_list|(
name|lambdaClassName
operator|.
name|replace
argument_list|(
literal|'/'
argument_list|,
literal|'.'
argument_list|)
argument_list|,
name|classBytes
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates an {@link ConstantCallSite} that will return the same instance      * of the generated lambda class every time this linked factory method is called.      */
DECL|method|createNoCaptureCallSite
specifier|private
specifier|static
name|CallSite
name|createNoCaptureCallSite
parameter_list|(
name|MethodType
name|factoryMethodType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|lambdaClass
parameter_list|)
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|constructor
init|=
name|AccessController
operator|.
name|doPrivileged
argument_list|(
call|(
name|PrivilegedAction
argument_list|<
name|Constructor
argument_list|<
name|?
argument_list|>
argument_list|>
call|)
argument_list|()
operator|->
block|{
try|try
block|{
return|return
name|lambdaClass
operator|.
name|getConstructor
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
name|nsme
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unable to create lambda class"
argument_list|,
name|nsme
argument_list|)
throw|;
block|}
block|}
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|new
name|ConstantCallSite
argument_list|(
name|MethodHandles
operator|.
name|constant
argument_list|(
name|factoryMethodType
operator|.
name|returnType
argument_list|()
argument_list|,
name|constructor
operator|.
name|newInstance
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|InstantiationException
decl||
name|IllegalAccessException
decl||
name|InvocationTargetException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unable to create lambda class"
argument_list|,
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates an {@link ConstantCallSite}      */
DECL|method|createCaptureCallSite
specifier|private
specifier|static
name|CallSite
name|createCaptureCallSite
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|String
name|factoryMethodName
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|lambdaClass
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|ConstantCallSite
argument_list|(
name|lookup
operator|.
name|findStatic
argument_list|(
name|lambdaClass
argument_list|,
name|factoryMethodName
argument_list|,
name|factoryMethodType
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NoSuchMethodException
decl||
name|IllegalAccessException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unable to create lambda factory class"
argument_list|,
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      * Links the delegate method to the returned {@link CallSite}.  The linked      * delegate method will use converted types from the interface method.  Using      * invokedynamic to make the delegate method call allows      * {@link MethodHandle#asType} to be used to do the type conversion instead      * of either a lot more code or requiring many {@link Definition.Type}s to be looked      * up at link-time.      */
DECL|method|delegateBootstrap
specifier|public
specifier|static
name|CallSite
name|delegateBootstrap
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|String
name|delegateMethodName
parameter_list|,
name|MethodType
name|interfaceMethodType
parameter_list|,
name|MethodHandle
name|delegateMethodHandle
parameter_list|)
block|{
return|return
operator|new
name|ConstantCallSite
argument_list|(
name|delegateMethodHandle
operator|.
name|asType
argument_list|(
name|interfaceMethodType
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

