begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|ClassWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|FieldVisitor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Handle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|GeneratorAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|CallSite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|ConstantCallSite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|LambdaConversionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|AccessController
import|;
end_import

begin_import
import|import
name|java
operator|.
name|security
operator|.
name|PrivilegedAction
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
operator|.
name|Lookup
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Compiler
operator|.
name|Loader
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|CLASS_VERSION
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|CTOR_METHOD_NAME
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DELEGATE_BOOTSTRAP_HANDLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_FINAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_PRIVATE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_PUBLIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_STATIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_SUPER
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|ACC_SYNTHETIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_INVOKEINTERFACE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_INVOKESTATIC
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_INVOKEVIRTUAL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
operator|.
name|H_NEWINVOKESPECIAL
import|;
end_import

begin_comment
comment|/**  * LambdaBootstrap is used to generate all the code necessary to execute  * lambda functions and method references within Painless.  The code generation  * used here is based upon the following article:  * http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html  * However, it is a simplified version as Painless has no concept of generics  * or serialization.  LambdaBootstrap is being used as a replacement for  * {@link java.lang.invoke.LambdaMetafactory} since the Painless casting model  * cannot be fully supported through this class.  *  * For each lambda function/method reference used within a Painless script  * a class will be generated at link-time using the  * {@link LambdaBootstrap#lambdaBootstrap} method that contains the following:  * 1. member fields for any captured variables  * 2. a constructor that will take in captured variables and assign them to  * their respective member fields  * 3. a static ctor delegation method, if the lambda function is a ctor.  * 4. a method that will load the member fields representing captured variables  * and take in any other necessary values based on the arguments passed into the  * lambda function/reference method; it will then make a delegated call to the  * actual lambda function/reference method  *  * Take for example the following Painless script:  *  * {@code  * List list1 = new ArrayList(); "  * list1.add(2); "  * List list2 = new ArrayList(); "  * list1.forEach(x -> list2.add(x));"  * return list[0]"  * }  *  * The script contains a lambda function with a captured variable.  * The following Lambda class would be generated:  *  * {@code  *     public static final class $$Lambda0 implements Consumer {  *         private List arg$0;  *  *         private $$Lambda0(List arg$0) {  *             this.arg$0 = arg$0;  *         }  *           *         public static Consumer create$lambda(List arg$0) {  *             return new $$Lambda0(arg$0);  *         }  *  *         public void accept(Object val$0) {  *             Painless$Script.lambda$0(this.arg$0, val$0);  *         }  *     }  *  *     public class Painless$Script implements ... {  *         ...  *         public static lambda$0(List list2, Object x) {  *             list2.add(x);  *         }  *         ...  *     }  * }  *  * Also the accept method actually uses an invokedynamic  * instruction to call the lambda$0 method so that  * {@link MethodHandle#asType} can be used to do the necessary  * conversions between argument types without having to hard  * code them. For method references to a constructor, a static  * wrapper method is created, that creates a class instance and  * calls the constructor. This method is used by the  * invokedynamic call to initialize the instance.  *  * When the {@link CallSite} is linked the linked method depends  * on whether or not there are captures.  If there are no captures  * the same instance of the generated lambda class will be  * returned each time by the factory method as there are no  * changing values other than the arguments, the lambda is a singleton.  * If there are captures, a new instance of the generated lambda class  * will be returned each time with the captures passed into the  * factory method to be stored in the member fields.  * Instead of calling the ctor, a static factory method is created  * in the lambda class, because a method handle to the ctor directly  * is (currently) preventing Hotspot optimizer from correctly doing  * escape analysis. Escape analysis is important to optimize the  * code in a way, that a new instance is not created on each lambda  * invocation with captures, stressing garbage collector (thanks  * to RÃ©mi Forax for the explanation about this on Jaxcon 2017!).  */
end_comment

begin_class
DECL|class|LambdaBootstrap
specifier|public
specifier|final
class|class
name|LambdaBootstrap
block|{
comment|/**      * Metadata for a captured variable used during code generation.      */
DECL|class|Capture
specifier|private
specifier|static
specifier|final
class|class
name|Capture
block|{
DECL|field|name
specifier|private
specifier|final
name|String
name|name
decl_stmt|;
DECL|field|type
specifier|private
specifier|final
name|Type
name|type
decl_stmt|;
DECL|field|desc
specifier|private
specifier|final
name|String
name|desc
decl_stmt|;
comment|/**          * Converts incoming parameters into the name, type, and          * descriptor for the captured argument.          * @param count The captured argument count          * @param type The class type of the captured argument          */
DECL|method|Capture
specifier|private
name|Capture
parameter_list|(
name|int
name|count
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|type
parameter_list|)
block|{
name|this
operator|.
name|name
operator|=
literal|"arg$"
operator|+
name|count
expr_stmt|;
name|this
operator|.
name|type
operator|=
name|Type
operator|.
name|getType
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|this
operator|.
name|desc
operator|=
name|this
operator|.
name|type
operator|.
name|getDescriptor
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * This method name is used to generate a static wrapper method to handle delegation of ctors.      */
DECL|field|DELEGATED_CTOR_WRAPPER_NAME
specifier|private
specifier|static
specifier|final
name|String
name|DELEGATED_CTOR_WRAPPER_NAME
init|=
literal|"delegate$ctor"
decl_stmt|;
comment|/**      * This method name is used to generate the static factory for capturing lambdas.      */
DECL|field|LAMBDA_FACTORY_METHOD_NAME
specifier|private
specifier|static
specifier|final
name|String
name|LAMBDA_FACTORY_METHOD_NAME
init|=
literal|"create$lambda"
decl_stmt|;
comment|/**      * Generates a lambda class for a lambda function/method reference      * within a Painless script.  Variables with the prefix interface are considered      * to represent values for code generated for the lambda class. Variables with      * the prefix delegate are considered to represent values for code generated      * within the Painless script.  The interface method delegates (calls) to the      * delegate method.      * @param lookup Standard {@link MethodHandles#lookup}      * @param interfaceMethodName Name of functional interface method that is called      * @param factoryMethodType The type of method to be linked to this CallSite; note that      *                          captured types are based on the parameters for this method      * @param interfaceMethodType The type of method representing the functional interface method      * @param delegateClassName The name of the class to delegate method call to      * @param delegateInvokeType The type of method call to be made      *                           (static, virtual, interface, or constructor)      * @param delegateMethodName The name of the method to be called in the Painless script class      * @param delegateMethodType The type of method call in the Painless script class without      *                           the captured types      * @return A {@link CallSite} linked to a factory method for creating a lambda class      * that implements the expected functional interface      * @throws LambdaConversionException Thrown when an illegal type conversion occurs at link time      */
DECL|method|lambdaBootstrap
specifier|public
specifier|static
name|CallSite
name|lambdaBootstrap
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|String
name|interfaceMethodName
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|MethodType
name|interfaceMethodType
parameter_list|,
name|String
name|delegateClassName
parameter_list|,
name|int
name|delegateInvokeType
parameter_list|,
name|String
name|delegateMethodName
parameter_list|,
name|MethodType
name|delegateMethodType
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
name|Loader
name|loader
init|=
operator|(
name|Loader
operator|)
name|lookup
operator|.
name|lookupClass
argument_list|()
operator|.
name|getClassLoader
argument_list|()
decl_stmt|;
name|String
name|lambdaClassName
init|=
name|Type
operator|.
name|getInternalName
argument_list|(
name|lookup
operator|.
name|lookupClass
argument_list|()
argument_list|)
operator|+
literal|"$$Lambda"
operator|+
name|loader
operator|.
name|newLambdaIdentifier
argument_list|()
decl_stmt|;
name|Type
name|lambdaClassType
init|=
name|Type
operator|.
name|getObjectType
argument_list|(
name|lambdaClassName
argument_list|)
decl_stmt|;
name|Type
name|delegateClassType
init|=
name|Type
operator|.
name|getObjectType
argument_list|(
name|delegateClassName
operator|.
name|replace
argument_list|(
literal|'.'
argument_list|,
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|validateTypes
argument_list|(
name|interfaceMethodType
argument_list|,
name|delegateMethodType
argument_list|)
expr_stmt|;
name|ClassWriter
name|cw
init|=
name|beginLambdaClass
argument_list|(
name|lambdaClassName
argument_list|,
name|factoryMethodType
operator|.
name|returnType
argument_list|()
argument_list|)
decl_stmt|;
name|Capture
index|[]
name|captures
init|=
name|generateCaptureFields
argument_list|(
name|cw
argument_list|,
name|factoryMethodType
argument_list|)
decl_stmt|;
name|generateLambdaConstructor
argument_list|(
name|cw
argument_list|,
name|lambdaClassType
argument_list|,
name|factoryMethodType
argument_list|,
name|captures
argument_list|)
expr_stmt|;
comment|// Handles the special case where a method reference refers to a ctor (we need a static wrapper method):
if|if
condition|(
name|delegateInvokeType
operator|==
name|H_NEWINVOKESPECIAL
condition|)
block|{
assert|assert
name|CTOR_METHOD_NAME
operator|.
name|equals
argument_list|(
name|delegateMethodName
argument_list|)
assert|;
name|generateStaticCtorDelegator
argument_list|(
name|cw
argument_list|,
name|ACC_PRIVATE
argument_list|,
name|DELEGATED_CTOR_WRAPPER_NAME
argument_list|,
name|delegateClassType
argument_list|,
name|delegateMethodType
argument_list|)
expr_stmt|;
comment|// replace the delegate with our static wrapper:
name|delegateMethodName
operator|=
name|DELEGATED_CTOR_WRAPPER_NAME
expr_stmt|;
name|delegateClassType
operator|=
name|lambdaClassType
expr_stmt|;
name|delegateInvokeType
operator|=
name|H_INVOKESTATIC
expr_stmt|;
block|}
name|generateInterfaceMethod
argument_list|(
name|cw
argument_list|,
name|factoryMethodType
argument_list|,
name|lambdaClassType
argument_list|,
name|interfaceMethodName
argument_list|,
name|interfaceMethodType
argument_list|,
name|delegateClassType
argument_list|,
name|delegateInvokeType
argument_list|,
name|delegateMethodName
argument_list|,
name|delegateMethodType
argument_list|,
name|captures
argument_list|)
expr_stmt|;
name|endLambdaClass
argument_list|(
name|cw
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|lambdaClass
init|=
name|createLambdaClass
argument_list|(
name|loader
argument_list|,
name|cw
argument_list|,
name|lambdaClassType
argument_list|)
decl_stmt|;
if|if
condition|(
name|captures
operator|.
name|length
operator|>
literal|0
condition|)
block|{
return|return
name|createCaptureCallSite
argument_list|(
name|lookup
argument_list|,
name|factoryMethodType
argument_list|,
name|lambdaClass
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|createNoCaptureCallSite
argument_list|(
name|factoryMethodType
argument_list|,
name|lambdaClass
argument_list|)
return|;
block|}
block|}
comment|/**      * Validates some conversions at link time.  Currently, only ensures that the lambda method      * with a return value cannot delegate to a delegate method with no return type.      */
DECL|method|validateTypes
specifier|private
specifier|static
name|void
name|validateTypes
parameter_list|(
name|MethodType
name|interfaceMethodType
parameter_list|,
name|MethodType
name|delegateMethodType
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
if|if
condition|(
name|interfaceMethodType
operator|.
name|returnType
argument_list|()
operator|!=
name|void
operator|.
name|class
operator|&&
name|delegateMethodType
operator|.
name|returnType
argument_list|()
operator|==
name|void
operator|.
name|class
condition|)
block|{
throw|throw
operator|new
name|LambdaConversionException
argument_list|(
literal|"lambda expects return type ["
operator|+
name|interfaceMethodType
operator|.
name|returnType
argument_list|()
operator|+
literal|"], but found return type [void]"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates the {@link ClassWriter} to be used for the lambda class generation.      */
DECL|method|beginLambdaClass
specifier|private
specifier|static
name|ClassWriter
name|beginLambdaClass
parameter_list|(
name|String
name|lambdaClassName
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|lambdaInterface
parameter_list|)
block|{
name|String
name|baseClass
init|=
name|Type
operator|.
name|getInternalName
argument_list|(
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|int
name|modifiers
init|=
name|ACC_PUBLIC
operator||
name|ACC_SUPER
operator||
name|ACC_FINAL
operator||
name|ACC_SYNTHETIC
decl_stmt|;
name|ClassWriter
name|cw
init|=
operator|new
name|ClassWriter
argument_list|(
name|ClassWriter
operator|.
name|COMPUTE_MAXS
argument_list|)
decl_stmt|;
name|cw
operator|.
name|visit
argument_list|(
name|CLASS_VERSION
argument_list|,
name|modifiers
argument_list|,
name|lambdaClassName
argument_list|,
literal|null
argument_list|,
name|baseClass
argument_list|,
operator|new
name|String
index|[]
block|{
name|Type
operator|.
name|getInternalName
argument_list|(
name|lambdaInterface
argument_list|)
block|}
argument_list|)
expr_stmt|;
return|return
name|cw
return|;
block|}
comment|/**      * Generates member fields for captured variables      * based on the parameters for the factory method.      * @return An array of captured variable metadata      * for generating method arguments later on      */
DECL|method|generateCaptureFields
specifier|private
specifier|static
name|Capture
index|[]
name|generateCaptureFields
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|)
block|{
name|int
name|captureTotal
init|=
name|factoryMethodType
operator|.
name|parameterCount
argument_list|()
decl_stmt|;
name|Capture
index|[]
name|captures
init|=
operator|new
name|Capture
index|[
name|captureTotal
index|]
decl_stmt|;
for|for
control|(
name|int
name|captureCount
init|=
literal|0
init|;
name|captureCount
operator|<
name|captureTotal
condition|;
operator|++
name|captureCount
control|)
block|{
name|captures
index|[
name|captureCount
index|]
operator|=
operator|new
name|Capture
argument_list|(
name|captureCount
argument_list|,
name|factoryMethodType
operator|.
name|parameterType
argument_list|(
name|captureCount
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|modifiers
init|=
name|ACC_PRIVATE
operator||
name|ACC_FINAL
decl_stmt|;
name|FieldVisitor
name|fv
init|=
name|cw
operator|.
name|visitField
argument_list|(
name|modifiers
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|name
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|desc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|fv
operator|.
name|visitEnd
argument_list|()
expr_stmt|;
block|}
return|return
name|captures
return|;
block|}
comment|/**      * Generates a constructor that will take in captured      * arguments if any and store them in their respective      * member fields.      */
DECL|method|generateLambdaConstructor
specifier|private
specifier|static
name|void
name|generateLambdaConstructor
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|Type
name|lambdaClassType
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|Capture
index|[]
name|captures
parameter_list|)
block|{
name|String
name|conDesc
init|=
name|factoryMethodType
operator|.
name|changeReturnType
argument_list|(
name|void
operator|.
name|class
argument_list|)
operator|.
name|toMethodDescriptorString
argument_list|()
decl_stmt|;
name|Method
name|conMeth
init|=
operator|new
name|Method
argument_list|(
name|CTOR_METHOD_NAME
argument_list|,
name|conDesc
argument_list|)
decl_stmt|;
name|Type
name|baseConType
init|=
name|Type
operator|.
name|getType
argument_list|(
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
name|Method
name|baseConMeth
init|=
operator|new
name|Method
argument_list|(
name|CTOR_METHOD_NAME
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|void
operator|.
name|class
argument_list|)
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|modifiers
init|=
operator|(
name|captures
operator|.
name|length
operator|>
literal|0
operator|)
condition|?
name|ACC_PRIVATE
else|:
name|ACC_PUBLIC
decl_stmt|;
name|GeneratorAdapter
name|constructor
init|=
operator|new
name|GeneratorAdapter
argument_list|(
name|modifiers
argument_list|,
name|conMeth
argument_list|,
name|cw
operator|.
name|visitMethod
argument_list|(
name|modifiers
argument_list|,
name|CTOR_METHOD_NAME
argument_list|,
name|conDesc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|constructor
operator|.
name|visitCode
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|invokeConstructor
argument_list|(
name|baseConType
argument_list|,
name|baseConMeth
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|captureCount
init|=
literal|0
init|;
name|captureCount
operator|<
name|captures
operator|.
name|length
condition|;
operator|++
name|captureCount
control|)
block|{
name|constructor
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|loadArg
argument_list|(
name|captureCount
argument_list|)
expr_stmt|;
name|constructor
operator|.
name|putField
argument_list|(
name|lambdaClassType
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|name
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|constructor
operator|.
name|returnValue
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|endMethod
argument_list|()
expr_stmt|;
comment|// Add a factory method, if lambda takes captures.
comment|// @uschindler says: I talked with RÃ©mi Forax about this. Technically, a plain ctor
comment|// and a MethodHandle to the ctor would be enough - BUT: Hotspot is unable to
comment|// do escape analysis through a MethodHandles.findConstructor generated handle.
comment|// Because of this we create a factory method. With this factory method, the
comment|// escape analysis can figure out that everything is final and we don't need
comment|// an instance, so it can omit object creation on heap!
if|if
condition|(
name|captures
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|generateStaticCtorDelegator
argument_list|(
name|cw
argument_list|,
name|ACC_PUBLIC
argument_list|,
name|LAMBDA_FACTORY_METHOD_NAME
argument_list|,
name|lambdaClassType
argument_list|,
name|factoryMethodType
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Generates a factory method to delegate to constructors.      */
DECL|method|generateStaticCtorDelegator
specifier|private
specifier|static
name|void
name|generateStaticCtorDelegator
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|int
name|access
parameter_list|,
name|String
name|delegatorMethodName
parameter_list|,
name|Type
name|delegateClassType
parameter_list|,
name|MethodType
name|delegateMethodType
parameter_list|)
block|{
name|Method
name|wrapperMethod
init|=
operator|new
name|Method
argument_list|(
name|delegatorMethodName
argument_list|,
name|delegateMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|)
decl_stmt|;
name|Method
name|constructorMethod
init|=
operator|new
name|Method
argument_list|(
name|CTOR_METHOD_NAME
argument_list|,
name|delegateMethodType
operator|.
name|changeReturnType
argument_list|(
name|void
operator|.
name|class
argument_list|)
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|modifiers
init|=
name|access
operator||
name|ACC_STATIC
decl_stmt|;
name|GeneratorAdapter
name|factory
init|=
operator|new
name|GeneratorAdapter
argument_list|(
name|modifiers
argument_list|,
name|wrapperMethod
argument_list|,
name|cw
operator|.
name|visitMethod
argument_list|(
name|modifiers
argument_list|,
name|delegatorMethodName
argument_list|,
name|delegateMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|factory
operator|.
name|visitCode
argument_list|()
expr_stmt|;
name|factory
operator|.
name|newInstance
argument_list|(
name|delegateClassType
argument_list|)
expr_stmt|;
name|factory
operator|.
name|dup
argument_list|()
expr_stmt|;
name|factory
operator|.
name|loadArgs
argument_list|()
expr_stmt|;
name|factory
operator|.
name|invokeConstructor
argument_list|(
name|delegateClassType
argument_list|,
name|constructorMethod
argument_list|)
expr_stmt|;
name|factory
operator|.
name|returnValue
argument_list|()
expr_stmt|;
name|factory
operator|.
name|endMethod
argument_list|()
expr_stmt|;
block|}
comment|/**      * Generates the interface method that will delegate (call) to the delegate method      * with {@code INVOKEDYNAMIC} using the {@link #delegateBootstrap} type converter.      */
DECL|method|generateInterfaceMethod
specifier|private
specifier|static
name|void
name|generateInterfaceMethod
parameter_list|(
name|ClassWriter
name|cw
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|Type
name|lambdaClassType
parameter_list|,
name|String
name|interfaceMethodName
parameter_list|,
name|MethodType
name|interfaceMethodType
parameter_list|,
name|Type
name|delegateClassType
parameter_list|,
name|int
name|delegateInvokeType
parameter_list|,
name|String
name|delegateMethodName
parameter_list|,
name|MethodType
name|delegateMethodType
parameter_list|,
name|Capture
index|[]
name|captures
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
name|String
name|lamDesc
init|=
name|interfaceMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
decl_stmt|;
name|Method
name|lamMeth
init|=
operator|new
name|Method
argument_list|(
name|lambdaClassType
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|lamDesc
argument_list|)
decl_stmt|;
name|int
name|modifiers
init|=
name|ACC_PUBLIC
decl_stmt|;
name|GeneratorAdapter
name|iface
init|=
operator|new
name|GeneratorAdapter
argument_list|(
name|modifiers
argument_list|,
name|lamMeth
argument_list|,
name|cw
operator|.
name|visitMethod
argument_list|(
name|modifiers
argument_list|,
name|interfaceMethodName
argument_list|,
name|lamDesc
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
decl_stmt|;
name|iface
operator|.
name|visitCode
argument_list|()
expr_stmt|;
comment|// Loads any captured variables onto the stack.
for|for
control|(
name|int
name|captureCount
init|=
literal|0
init|;
name|captureCount
operator|<
name|captures
operator|.
name|length
condition|;
operator|++
name|captureCount
control|)
block|{
name|iface
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|iface
operator|.
name|getField
argument_list|(
name|lambdaClassType
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|name
argument_list|,
name|captures
index|[
name|captureCount
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
comment|// Loads any passed in arguments onto the stack.
name|iface
operator|.
name|loadArgs
argument_list|()
expr_stmt|;
comment|// Handles the case for a lambda function or a static reference method.
comment|// interfaceMethodType and delegateMethodType both have the captured types
comment|// inserted into their type signatures.  This later allows the delegate
comment|// method to be invoked dynamically and have the interface method types
comment|// appropriately converted to the delegate method types.
comment|// Example: Integer::parseInt
comment|// Example: something.each(x -> x + 1)
if|if
condition|(
name|delegateInvokeType
operator|==
name|H_INVOKESTATIC
condition|)
block|{
name|interfaceMethodType
operator|=
name|interfaceMethodType
operator|.
name|insertParameterTypes
argument_list|(
literal|0
argument_list|,
name|factoryMethodType
operator|.
name|parameterArray
argument_list|()
argument_list|)
expr_stmt|;
name|delegateMethodType
operator|=
name|delegateMethodType
operator|.
name|insertParameterTypes
argument_list|(
literal|0
argument_list|,
name|factoryMethodType
operator|.
name|parameterArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delegateInvokeType
operator|==
name|H_INVOKEVIRTUAL
operator|||
name|delegateInvokeType
operator|==
name|H_INVOKEINTERFACE
condition|)
block|{
comment|// Handles the case for a virtual or interface reference method with no captures.
comment|// delegateMethodType drops the 'this' parameter because it will be re-inserted
comment|// when the method handle for the dynamically invoked delegate method is created.
comment|// Example: Object::toString
if|if
condition|(
name|captures
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|delegateMethodType
operator|.
name|parameterType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|delegateClassType
operator|=
name|Type
operator|.
name|getType
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|delegateMethodType
operator|=
name|delegateMethodType
operator|.
name|dropParameterTypes
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// Handles the case for a virtual or interface reference method with 'this'
comment|// captured. interfaceMethodType inserts the 'this' type into its
comment|// method signature. This later allows the delegate
comment|// method to be invoked dynamically and have the interface method types
comment|// appropriately converted to the delegate method types.
comment|// Example: something::toString
block|}
elseif|else
if|if
condition|(
name|captures
operator|.
name|length
operator|==
literal|1
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|factoryMethodType
operator|.
name|parameterType
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|delegateClassType
operator|=
name|Type
operator|.
name|getType
argument_list|(
name|clazz
argument_list|)
expr_stmt|;
name|interfaceMethodType
operator|=
name|interfaceMethodType
operator|.
name|insertParameterTypes
argument_list|(
literal|0
argument_list|,
name|clazz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|LambdaConversionException
argument_list|(
literal|"unexpected number of captures [ "
operator|+
name|captures
operator|.
name|length
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unexpected invocation type ["
operator|+
name|delegateInvokeType
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|Handle
name|delegateHandle
init|=
operator|new
name|Handle
argument_list|(
name|delegateInvokeType
argument_list|,
name|delegateClassType
operator|.
name|getInternalName
argument_list|()
argument_list|,
name|delegateMethodName
argument_list|,
name|delegateMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|,
name|delegateInvokeType
operator|==
name|H_INVOKEINTERFACE
argument_list|)
decl_stmt|;
name|iface
operator|.
name|invokeDynamic
argument_list|(
name|delegateMethodName
argument_list|,
name|Type
operator|.
name|getMethodType
argument_list|(
name|interfaceMethodType
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|)
operator|.
name|getDescriptor
argument_list|()
argument_list|,
name|DELEGATE_BOOTSTRAP_HANDLE
argument_list|,
name|delegateHandle
argument_list|)
expr_stmt|;
name|iface
operator|.
name|returnValue
argument_list|()
expr_stmt|;
name|iface
operator|.
name|endMethod
argument_list|()
expr_stmt|;
block|}
comment|/**      * Closes the {@link ClassWriter}.      */
DECL|method|endLambdaClass
specifier|private
specifier|static
name|void
name|endLambdaClass
parameter_list|(
name|ClassWriter
name|cw
parameter_list|)
block|{
name|cw
operator|.
name|visitEnd
argument_list|()
expr_stmt|;
block|}
comment|/**      * Defines the {@link Class} for the lambda class using the same {@link Loader}      * that originally defined the class for the Painless script.      */
DECL|method|createLambdaClass
specifier|private
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|createLambdaClass
parameter_list|(
name|Loader
name|loader
parameter_list|,
name|ClassWriter
name|cw
parameter_list|,
name|Type
name|lambdaClassType
parameter_list|)
block|{
name|byte
index|[]
name|classBytes
init|=
name|cw
operator|.
name|toByteArray
argument_list|()
decl_stmt|;
comment|// DEBUG:
comment|// new ClassReader(classBytes).accept(new TraceClassVisitor(new PrintWriter(System.out)), ClassReader.SKIP_DEBUG);
return|return
name|AccessController
operator|.
name|doPrivileged
argument_list|(
call|(
name|PrivilegedAction
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|>
call|)
argument_list|()
operator|->
name|loader
operator|.
name|defineLambda
argument_list|(
name|lambdaClassType
operator|.
name|getClassName
argument_list|()
argument_list|,
name|classBytes
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Creates an {@link ConstantCallSite} that will return the same instance      * of the generated lambda class every time this linked factory method is called.      */
DECL|method|createNoCaptureCallSite
specifier|private
specifier|static
name|CallSite
name|createNoCaptureCallSite
parameter_list|(
name|MethodType
name|factoryMethodType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|lambdaClass
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|ConstantCallSite
argument_list|(
name|MethodHandles
operator|.
name|constant
argument_list|(
name|factoryMethodType
operator|.
name|returnType
argument_list|()
argument_list|,
name|lambdaClass
operator|.
name|getConstructor
argument_list|()
operator|.
name|newInstance
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unable to instantiate lambda class"
argument_list|,
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates an {@link ConstantCallSite}      */
DECL|method|createCaptureCallSite
specifier|private
specifier|static
name|CallSite
name|createCaptureCallSite
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|MethodType
name|factoryMethodType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|lambdaClass
parameter_list|)
block|{
try|try
block|{
return|return
operator|new
name|ConstantCallSite
argument_list|(
name|lookup
operator|.
name|findStatic
argument_list|(
name|lambdaClass
argument_list|,
name|LAMBDA_FACTORY_METHOD_NAME
argument_list|,
name|factoryMethodType
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"unable to create lambda class"
argument_list|,
name|exception
argument_list|)
throw|;
block|}
block|}
comment|/**      * Links the delegate method to the returned {@link CallSite}.  The linked      * delegate method will use converted types from the interface method.  Using      * invokedynamic to make the delegate method call allows      * {@link MethodHandle#asType} to be used to do the type conversion instead      * of either a lot more code or requiring many {@link Definition.Type}s to be looked      * up at link-time.      */
DECL|method|delegateBootstrap
specifier|public
specifier|static
name|CallSite
name|delegateBootstrap
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|String
name|delegateMethodName
parameter_list|,
name|MethodType
name|interfaceMethodType
parameter_list|,
name|MethodHandle
name|delegateMethodHandle
parameter_list|)
block|{
return|return
operator|new
name|ConstantCallSite
argument_list|(
name|delegateMethodHandle
operator|.
name|asType
argument_list|(
name|interfaceMethodType
argument_list|)
argument_list|)
return|;
block|}
block|}
end_class

end_unit

