begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|ParserRuleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|antlr
operator|.
name|v4
operator|.
name|runtime
operator|.
name|tree
operator|.
name|ParseTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Cast
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Constructor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Transform
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|AfterthoughtContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ArgumentsContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|AssignmentContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BinaryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BlockContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BoolContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BreakContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|CastContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|CharContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|CompContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ConditionalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ContinueContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DeclContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DeclarationContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DecltypeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DeclvarContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DoContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|EmptyContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|EmptyscopeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExprContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExpressionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtbraceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtcallContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtcastContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtdotContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExternalContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtfieldContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtnewContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtprecContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtstartContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtstringContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExttypeContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ExtvarContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|FalseContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ForContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|IfContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|IncrementContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|InitializerContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|MultipleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|NullContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|NumericContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|PostincContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|PrecedenceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|PreincContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ReturnContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|SingleContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|SourceContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|StatementContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ThrowContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|TrapContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|TrueContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|TryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|UnaryContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|WhileContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|script
operator|.
name|ScoreAccessor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|ClassWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Label
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|GeneratorAdapter
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|ADD
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWAND
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|BWXOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|DIV
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|LSH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|MUL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|REM
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|RSH
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|SUB
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|PainlessParser
operator|.
name|USH
import|;
end_import

begin_class
DECL|class|Writer
class|class
name|Writer
extends|extends
name|PainlessParserBaseVisitor
argument_list|<
name|Void
argument_list|>
block|{
DECL|class|Branch
specifier|private
specifier|static
class|class
name|Branch
block|{
DECL|field|source
specifier|final
name|ParserRuleContext
name|source
decl_stmt|;
DECL|field|begin
name|Label
name|begin
init|=
literal|null
decl_stmt|;
DECL|field|end
name|Label
name|end
init|=
literal|null
decl_stmt|;
DECL|field|tru
name|Label
name|tru
init|=
literal|null
decl_stmt|;
DECL|field|fals
name|Label
name|fals
init|=
literal|null
decl_stmt|;
DECL|method|Branch
specifier|private
name|Branch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
name|this
operator|.
name|source
operator|=
name|source
expr_stmt|;
block|}
block|}
DECL|field|BASE_CLASS_NAME
specifier|final
specifier|static
name|String
name|BASE_CLASS_NAME
init|=
name|Executable
operator|.
name|class
operator|.
name|getName
argument_list|()
decl_stmt|;
DECL|field|CLASS_NAME
specifier|final
specifier|static
name|String
name|CLASS_NAME
init|=
name|BASE_CLASS_NAME
operator|+
literal|"$CompiledPainlessExecutable"
decl_stmt|;
DECL|field|BASE_CLASS_TYPE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|BASE_CLASS_TYPE
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|Executable
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CLASS_TYPE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|CLASS_TYPE
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
literal|"L"
operator|+
name|CLASS_NAME
operator|.
name|replace
argument_list|(
literal|"."
argument_list|,
literal|"/"
argument_list|)
operator|+
literal|";"
argument_list|)
decl_stmt|;
DECL|field|CONSTRUCTOR
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|CONSTRUCTOR
init|=
name|getAsmMethod
argument_list|(
name|void
operator|.
name|class
argument_list|,
literal|"<init>"
argument_list|,
name|Definition
operator|.
name|class
argument_list|,
name|String
operator|.
name|class
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|EXECUTE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|EXECUTE
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"execute"
argument_list|,
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SIGNATURE
specifier|private
specifier|final
specifier|static
name|String
name|SIGNATURE
init|=
literal|"(Ljava/util/Map<Ljava/lang/String;Ljava/lang/Object;>;)Ljava/lang/Object;"
decl_stmt|;
DECL|field|PAINLESS_ERROR_TYPE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|PAINLESS_ERROR_TYPE
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|PainlessError
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEFINITION_TYPE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|DEFINITION_TYPE
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|Definition
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MAP_TYPE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|MAP_TYPE
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|Map
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MAP_GET
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|MAP_GET
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"get"
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SCORE_ACCESSOR_TYPE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|SCORE_ACCESSOR_TYPE
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|ScoreAccessor
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SCORE_ACCESSOR_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|SCORE_ACCESSOR_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|"floatValue"
argument_list|)
decl_stmt|;
DECL|field|DEF_METHOD_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_METHOD_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"methodCall"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|String
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|,
name|boolean
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|field|DEF_ARRAY_STORE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_ARRAY_STORE
init|=
name|getAsmMethod
argument_list|(
name|void
operator|.
name|class
argument_list|,
literal|"arrayStore"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_ARRAY_LOAD
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_ARRAY_LOAD
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"arrayLoad"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_FIELD_STORE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_FIELD_STORE
init|=
name|getAsmMethod
argument_list|(
name|void
operator|.
name|class
argument_list|,
literal|"fieldStore"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|String
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|class
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_FIELD_LOAD
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_FIELD_LOAD
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"fieldLoad"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|String
operator|.
name|class
argument_list|,
name|Definition
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_NOT_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_NOT_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"not"
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_NEG_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_NEG_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"neg"
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_MUL_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_MUL_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"mul"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_DIV_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_DIV_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"div"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_REM_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_REM_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"rem"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_ADD_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_ADD_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"add"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_SUB_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_SUB_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"sub"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_LSH_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_LSH_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"lsh"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_RSH_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_RSH_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"rsh"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_USH_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_USH_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"ush"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_AND_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_AND_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"and"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_XOR_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_XOR_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"xor"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_OR_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_OR_CALL
init|=
name|getAsmMethod
argument_list|(
name|Object
operator|.
name|class
argument_list|,
literal|"or"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_EQ_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_EQ_CALL
init|=
name|getAsmMethod
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
literal|"eq"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_LT_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_LT_CALL
init|=
name|getAsmMethod
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
literal|"lt"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_LTE_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_LTE_CALL
init|=
name|getAsmMethod
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
literal|"lte"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_GT_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_GT_CALL
init|=
name|getAsmMethod
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
literal|"gt"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DEF_GTE_CALL
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DEF_GTE_CALL
init|=
name|getAsmMethod
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
literal|"gte"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_TYPE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|STRINGBUILDER_TYPE
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_CONSTRUCTOR
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_CONSTRUCTOR
init|=
name|getAsmMethod
argument_list|(
name|void
operator|.
name|class
argument_list|,
literal|"<init>"
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_BOOLEAN
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_BOOLEAN
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|boolean
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_CHAR
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_CHAR
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|char
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_INT
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_LONG
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_STRING
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_STRING
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|String
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_APPEND_OBJECT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_APPEND_OBJECT
init|=
name|getAsmMethod
argument_list|(
name|StringBuilder
operator|.
name|class
argument_list|,
literal|"append"
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|STRINGBUILDER_TOSTRING
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|STRINGBUILDER_TOSTRING
init|=
name|getAsmMethod
argument_list|(
name|String
operator|.
name|class
argument_list|,
literal|"toString"
argument_list|)
decl_stmt|;
DECL|field|TOINTEXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOINTEXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"toIntExact"
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NEGATEEXACT_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|NEGATEEXACT_INT
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"negateExact"
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|NEGATEEXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|NEGATEEXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|"negateExact"
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MULEXACT_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|MULEXACT_INT
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"multiplyExact"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MULEXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|MULEXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|"multiplyExact"
argument_list|,
name|long
operator|.
name|class
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ADDEXACT_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|ADDEXACT_INT
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"addExact"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ADDEXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|ADDEXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|"addExact"
argument_list|,
name|long
operator|.
name|class
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SUBEXACT_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|SUBEXACT_INT
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"subtractExact"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SUBEXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|SUBEXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|"subtractExact"
argument_list|,
name|long
operator|.
name|class
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|CHECKEQUALS
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|CHECKEQUALS
init|=
name|getAsmMethod
argument_list|(
name|boolean
operator|.
name|class
argument_list|,
literal|"checkEquals"
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOBYTEEXACT_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOBYTEEXACT_INT
init|=
name|getAsmMethod
argument_list|(
name|byte
operator|.
name|class
argument_list|,
literal|"toByteExact"
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOBYTEEXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOBYTEEXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|byte
operator|.
name|class
argument_list|,
literal|"toByteExact"
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOBYTEWOOVERFLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOBYTEWOOVERFLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|byte
operator|.
name|class
argument_list|,
literal|"toByteWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOBYTEWOOVERFLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOBYTEWOOVERFLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|byte
operator|.
name|class
argument_list|,
literal|"toByteWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOSHORTEXACT_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOSHORTEXACT_INT
init|=
name|getAsmMethod
argument_list|(
name|short
operator|.
name|class
argument_list|,
literal|"toShortExact"
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOSHORTEXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOSHORTEXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|short
operator|.
name|class
argument_list|,
literal|"toShortExact"
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOSHORTWOOVERFLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOSHORTWOOVERFLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|short
operator|.
name|class
argument_list|,
literal|"toShortWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOSHORTWOOVERFLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOSHORTWOOVERFLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|short
operator|.
name|class
argument_list|,
literal|"toShortWihtoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOCHAREXACT_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOCHAREXACT_INT
init|=
name|getAsmMethod
argument_list|(
name|char
operator|.
name|class
argument_list|,
literal|"toCharExact"
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOCHAREXACT_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOCHAREXACT_LONG
init|=
name|getAsmMethod
argument_list|(
name|char
operator|.
name|class
argument_list|,
literal|"toCharExact"
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOCHARWOOVERFLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOCHARWOOVERFLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|char
operator|.
name|class
argument_list|,
literal|"toCharWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOCHARWOOVERFLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOCHARWOOVERFLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|char
operator|.
name|class
argument_list|,
literal|"toCharWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOINTWOOVERFLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOINTWOOVERFLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"toIntWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOINTWOOVERFLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOINTWOOVERFLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"toIntWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOLONGWOOVERFLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOLONGWOOVERFLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|"toLongWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOLONGWOOVERFLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOLONGWOOVERFLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|"toLongWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|TOFLOATWOOVERFLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|TOFLOATWOOVERFLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|"toFloatWihtoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MULWOOVERLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|MULWOOVERLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|"multiplyWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|MULWOOVERLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|MULWOOVERLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|double
operator|.
name|class
argument_list|,
literal|"multiplyWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DIVWOOVERLOW_INT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DIVWOOVERLOW_INT
init|=
name|getAsmMethod
argument_list|(
name|int
operator|.
name|class
argument_list|,
literal|"divideWithoutOverflow"
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DIVWOOVERLOW_LONG
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DIVWOOVERLOW_LONG
init|=
name|getAsmMethod
argument_list|(
name|long
operator|.
name|class
argument_list|,
literal|"divideWithoutOverflow"
argument_list|,
name|long
operator|.
name|class
argument_list|,
name|long
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DIVWOOVERLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DIVWOOVERLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|"divideWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|DIVWOOVERLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|DIVWOOVERLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|double
operator|.
name|class
argument_list|,
literal|"divideWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|REMWOOVERLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|REMWOOVERLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|"remainderWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|REMWOOVERLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|REMWOOVERLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|double
operator|.
name|class
argument_list|,
literal|"remainderWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ADDWOOVERLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|ADDWOOVERLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|"addWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|ADDWOOVERLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|ADDWOOVERLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|double
operator|.
name|class
argument_list|,
literal|"addWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SUBWOOVERLOW_FLOAT
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|SUBWOOVERLOW_FLOAT
init|=
name|getAsmMethod
argument_list|(
name|float
operator|.
name|class
argument_list|,
literal|"subtractWithoutOverflow"
argument_list|,
name|float
operator|.
name|class
argument_list|,
name|float
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|SUBWOOVERLOW_DOUBLE
specifier|private
specifier|final
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|SUBWOOVERLOW_DOUBLE
init|=
name|getAsmMethod
argument_list|(
name|double
operator|.
name|class
argument_list|,
literal|"subtractWithoutOverflow"
argument_list|,
name|double
operator|.
name|class
argument_list|,
name|double
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|getAsmMethod
specifier|private
specifier|static
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
name|getAsmMethod
parameter_list|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|rtype
parameter_list|,
specifier|final
name|String
name|name
parameter_list|,
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|ptypes
parameter_list|)
block|{
return|return
operator|new
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
argument_list|(
name|name
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|rtype
argument_list|,
name|ptypes
argument_list|)
operator|.
name|toMethodDescriptorString
argument_list|()
argument_list|)
return|;
block|}
DECL|method|write
specifier|static
name|byte
index|[]
name|write
parameter_list|(
name|Metadata
name|metadata
parameter_list|)
block|{
name|Writer
name|writer
init|=
operator|new
name|Writer
argument_list|(
name|metadata
argument_list|)
decl_stmt|;
return|return
name|writer
operator|.
name|getBytes
argument_list|()
return|;
block|}
DECL|field|metadata
specifier|private
specifier|final
name|Metadata
name|metadata
decl_stmt|;
DECL|field|definition
specifier|private
specifier|final
name|Definition
name|definition
decl_stmt|;
DECL|field|root
specifier|private
specifier|final
name|ParseTree
name|root
decl_stmt|;
DECL|field|source
specifier|private
specifier|final
name|String
name|source
decl_stmt|;
DECL|field|settings
specifier|private
specifier|final
name|CompilerSettings
name|settings
decl_stmt|;
DECL|field|branches
specifier|private
specifier|final
name|Map
argument_list|<
name|ParserRuleContext
argument_list|,
name|Branch
argument_list|>
name|branches
init|=
operator|new
name|HashMap
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|jumps
specifier|private
specifier|final
name|Deque
argument_list|<
name|Branch
argument_list|>
name|jumps
init|=
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|strings
specifier|private
specifier|final
name|Set
argument_list|<
name|ParserRuleContext
argument_list|>
name|strings
init|=
operator|new
name|HashSet
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|writer
specifier|private
name|ClassWriter
name|writer
decl_stmt|;
DECL|field|execute
specifier|private
name|GeneratorAdapter
name|execute
decl_stmt|;
DECL|method|Writer
specifier|private
name|Writer
parameter_list|(
specifier|final
name|Metadata
name|metadata
parameter_list|)
block|{
name|this
operator|.
name|metadata
operator|=
name|metadata
expr_stmt|;
name|definition
operator|=
name|metadata
operator|.
name|definition
expr_stmt|;
name|root
operator|=
name|metadata
operator|.
name|root
expr_stmt|;
name|source
operator|=
name|metadata
operator|.
name|source
expr_stmt|;
name|settings
operator|=
name|metadata
operator|.
name|settings
expr_stmt|;
name|writeBegin
argument_list|()
expr_stmt|;
name|writeConstructor
argument_list|()
expr_stmt|;
name|writeExecute
argument_list|()
expr_stmt|;
name|writeEnd
argument_list|()
expr_stmt|;
block|}
DECL|method|markBranch
specifier|private
name|Branch
name|markBranch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|ParserRuleContext
modifier|...
name|nodes
parameter_list|)
block|{
specifier|final
name|Branch
name|branch
init|=
operator|new
name|Branch
argument_list|(
name|source
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|ParserRuleContext
name|node
range|:
name|nodes
control|)
block|{
name|branches
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
return|return
name|branch
return|;
block|}
DECL|method|copyBranch
specifier|private
name|void
name|copyBranch
parameter_list|(
specifier|final
name|Branch
name|branch
parameter_list|,
specifier|final
name|ParserRuleContext
modifier|...
name|nodes
parameter_list|)
block|{
for|for
control|(
specifier|final
name|ParserRuleContext
name|node
range|:
name|nodes
control|)
block|{
name|branches
operator|.
name|put
argument_list|(
name|node
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getBranch
specifier|private
name|Branch
name|getBranch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
return|return
name|branches
operator|.
name|get
argument_list|(
name|source
argument_list|)
return|;
block|}
DECL|method|writeBegin
specifier|private
name|void
name|writeBegin
parameter_list|()
block|{
specifier|final
name|int
name|compute
init|=
name|ClassWriter
operator|.
name|COMPUTE_FRAMES
operator||
name|ClassWriter
operator|.
name|COMPUTE_MAXS
decl_stmt|;
specifier|final
name|int
name|version
init|=
name|Opcodes
operator|.
name|V1_7
decl_stmt|;
specifier|final
name|int
name|access
init|=
name|Opcodes
operator|.
name|ACC_PUBLIC
operator||
name|Opcodes
operator|.
name|ACC_SUPER
operator||
name|Opcodes
operator|.
name|ACC_FINAL
decl_stmt|;
specifier|final
name|String
name|base
init|=
name|BASE_CLASS_TYPE
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
specifier|final
name|String
name|name
init|=
name|CLASS_TYPE
operator|.
name|getInternalName
argument_list|()
decl_stmt|;
name|writer
operator|=
operator|new
name|ClassWriter
argument_list|(
name|compute
argument_list|)
expr_stmt|;
name|writer
operator|.
name|visit
argument_list|(
name|version
argument_list|,
name|access
argument_list|,
name|name
argument_list|,
literal|null
argument_list|,
name|base
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|writer
operator|.
name|visitSource
argument_list|(
name|source
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|writeConstructor
specifier|private
name|void
name|writeConstructor
parameter_list|()
block|{
specifier|final
name|int
name|access
init|=
name|Opcodes
operator|.
name|ACC_PUBLIC
decl_stmt|;
specifier|final
name|GeneratorAdapter
name|constructor
init|=
operator|new
name|GeneratorAdapter
argument_list|(
name|access
argument_list|,
name|CONSTRUCTOR
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
name|writer
argument_list|)
decl_stmt|;
name|constructor
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|loadArgs
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|invokeConstructor
argument_list|(
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getType
argument_list|(
name|Executable
operator|.
name|class
argument_list|)
argument_list|,
name|CONSTRUCTOR
argument_list|)
expr_stmt|;
name|constructor
operator|.
name|returnValue
argument_list|()
expr_stmt|;
name|constructor
operator|.
name|endMethod
argument_list|()
expr_stmt|;
block|}
DECL|method|writeExecute
specifier|private
name|void
name|writeExecute
parameter_list|()
block|{
specifier|final
name|int
name|access
init|=
name|Opcodes
operator|.
name|ACC_PUBLIC
decl_stmt|;
name|execute
operator|=
operator|new
name|GeneratorAdapter
argument_list|(
name|access
argument_list|,
name|EXECUTE
argument_list|,
name|SIGNATURE
argument_list|,
literal|null
argument_list|,
name|writer
argument_list|)
expr_stmt|;
specifier|final
name|Label
name|fals
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
specifier|final
name|Label
name|end
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|execute
operator|.
name|visitVarInsn
argument_list|(
name|Opcodes
operator|.
name|ALOAD
argument_list|,
name|metadata
operator|.
name|inputValueSlot
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|"#score"
argument_list|)
expr_stmt|;
name|execute
operator|.
name|invokeInterface
argument_list|(
name|MAP_TYPE
argument_list|,
name|MAP_GET
argument_list|)
expr_stmt|;
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
name|execute
operator|.
name|ifNull
argument_list|(
name|fals
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|SCORE_ACCESSOR_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|SCORE_ACCESSOR_TYPE
argument_list|,
name|SCORE_ACCESSOR_FLOAT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|fals
argument_list|)
expr_stmt|;
name|execute
operator|.
name|pop
argument_list|()
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|0F
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|execute
operator|.
name|visitVarInsn
argument_list|(
name|Opcodes
operator|.
name|FSTORE
argument_list|,
name|metadata
operator|.
name|scoreValueSlot
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|settings
operator|.
name|getMaxLoopCounter
argument_list|()
argument_list|)
expr_stmt|;
name|execute
operator|.
name|visitVarInsn
argument_list|(
name|Opcodes
operator|.
name|ISTORE
argument_list|,
name|metadata
operator|.
name|loopCounterSlot
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|execute
operator|.
name|endMethod
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|visitSource
specifier|public
name|Void
name|visitSource
parameter_list|(
specifier|final
name|SourceContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|StatementMetadata
name|sourcesmd
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
for|for
control|(
specifier|final
name|StatementContext
name|sctx
range|:
name|ctx
operator|.
name|statement
argument_list|()
control|)
block|{
name|visit
argument_list|(
name|sctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sourcesmd
operator|.
name|methodEscape
condition|)
block|{
name|execute
operator|.
name|visitInsn
argument_list|(
name|Opcodes
operator|.
name|ACONST_NULL
argument_list|)
expr_stmt|;
name|execute
operator|.
name|returnValue
argument_list|()
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitIf
specifier|public
name|Void
name|visitIf
parameter_list|(
specifier|final
name|IfContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|els
init|=
name|ctx
operator|.
name|ELSE
argument_list|()
operator|!=
literal|null
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx
argument_list|)
decl_stmt|;
name|branch
operator|.
name|end
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|fals
operator|=
name|els
condition|?
operator|new
name|Label
argument_list|()
else|:
name|branch
operator|.
name|end
expr_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
specifier|final
name|BlockContext
name|blockctx0
init|=
name|ctx
operator|.
name|block
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|StatementMetadata
name|blockmd0
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|blockctx0
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|blockctx0
argument_list|)
expr_stmt|;
if|if
condition|(
name|els
condition|)
block|{
if|if
condition|(
operator|!
name|blockmd0
operator|.
name|allLast
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|branch
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|fals
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|end
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitWhile
specifier|public
name|Void
name|visitWhile
parameter_list|(
specifier|final
name|WhileContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx
argument_list|)
decl_stmt|;
name|branch
operator|.
name|begin
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|end
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|fals
operator|=
name|branch
operator|.
name|end
expr_stmt|;
name|jumps
operator|.
name|push
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|begin
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
specifier|final
name|BlockContext
name|blockctx
init|=
name|ctx
operator|.
name|block
argument_list|()
decl_stmt|;
name|boolean
name|allLast
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|blockctx
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Metadata
operator|.
name|StatementMetadata
name|blocksmd
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|blockctx
argument_list|)
decl_stmt|;
name|allLast
operator|=
name|blocksmd
operator|.
name|allLast
expr_stmt|;
name|writeLoopCounter
argument_list|(
name|blocksmd
operator|.
name|count
operator|>
literal|0
condition|?
name|blocksmd
operator|.
name|count
else|:
literal|1
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|blockctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|empty
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|writeLoopCounter
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
if|if
condition|(
operator|!
name|allLast
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|branch
operator|.
name|begin
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|end
argument_list|)
expr_stmt|;
name|jumps
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitDo
specifier|public
name|Void
name|visitDo
parameter_list|(
specifier|final
name|DoContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx
argument_list|)
decl_stmt|;
name|Label
name|start
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|branch
operator|.
name|begin
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|end
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|fals
operator|=
name|branch
operator|.
name|end
expr_stmt|;
specifier|final
name|BlockContext
name|blockctx
init|=
name|ctx
operator|.
name|block
argument_list|()
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|StatementMetadata
name|blocksmd
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|blockctx
argument_list|)
decl_stmt|;
name|jumps
operator|.
name|push
argument_list|(
name|branch
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|blockctx
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|begin
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|writeLoopCounter
argument_list|(
name|blocksmd
operator|.
name|count
operator|>
literal|0
condition|?
name|blocksmd
operator|.
name|count
else|:
literal|1
argument_list|)
expr_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|end
argument_list|)
expr_stmt|;
name|jumps
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitFor
specifier|public
name|Void
name|visitFor
parameter_list|(
specifier|final
name|ForContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|AfterthoughtContext
name|atctx
init|=
name|ctx
operator|.
name|afterthought
argument_list|()
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx
argument_list|)
decl_stmt|;
specifier|final
name|Label
name|start
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|branch
operator|.
name|begin
operator|=
name|atctx
operator|==
literal|null
condition|?
name|start
else|:
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|end
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|fals
operator|=
name|branch
operator|.
name|end
expr_stmt|;
name|jumps
operator|.
name|push
argument_list|(
name|branch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|initializer
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|initializer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|mark
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
block|}
specifier|final
name|BlockContext
name|blockctx
init|=
name|ctx
operator|.
name|block
argument_list|()
decl_stmt|;
name|boolean
name|allLast
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|blockctx
operator|!=
literal|null
condition|)
block|{
name|Metadata
operator|.
name|StatementMetadata
name|blocksmd
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|blockctx
argument_list|)
decl_stmt|;
name|allLast
operator|=
name|blocksmd
operator|.
name|allLast
expr_stmt|;
name|int
name|count
init|=
name|blocksmd
operator|.
name|count
operator|>
literal|0
condition|?
name|blocksmd
operator|.
name|count
else|:
literal|1
decl_stmt|;
if|if
condition|(
name|atctx
operator|!=
literal|null
condition|)
block|{
operator|++
name|count
expr_stmt|;
block|}
name|writeLoopCounter
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|blockctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|empty
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|writeLoopCounter
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
if|if
condition|(
name|atctx
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|begin
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|atctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atctx
operator|!=
literal|null
operator|||
operator|!
name|allLast
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|end
argument_list|)
expr_stmt|;
name|jumps
operator|.
name|pop
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitDecl
specifier|public
name|Void
name|visitDecl
parameter_list|(
specifier|final
name|DeclContext
name|ctx
parameter_list|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|declaration
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitContinue
specifier|public
name|Void
name|visitContinue
parameter_list|(
specifier|final
name|ContinueContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Branch
name|jump
init|=
name|jumps
operator|.
name|peek
argument_list|()
decl_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|jump
operator|.
name|begin
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitBreak
specifier|public
name|Void
name|visitBreak
parameter_list|(
specifier|final
name|BreakContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Branch
name|jump
init|=
name|jumps
operator|.
name|peek
argument_list|()
decl_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|jump
operator|.
name|end
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitReturn
specifier|public
name|Void
name|visitReturn
parameter_list|(
specifier|final
name|ReturnContext
name|ctx
parameter_list|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
expr_stmt|;
name|execute
operator|.
name|returnValue
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitTry
specifier|public
name|Void
name|visitTry
parameter_list|(
specifier|final
name|TryContext
name|ctx
parameter_list|)
block|{
specifier|final
name|TrapContext
index|[]
name|trapctxs
init|=
operator|new
name|TrapContext
index|[
name|ctx
operator|.
name|trap
argument_list|()
operator|.
name|size
argument_list|()
index|]
decl_stmt|;
name|ctx
operator|.
name|trap
argument_list|()
operator|.
name|toArray
argument_list|(
name|trapctxs
argument_list|)
expr_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|trapctxs
argument_list|)
decl_stmt|;
name|Label
name|end
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|branch
operator|.
name|begin
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|end
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|branch
operator|.
name|tru
operator|=
name|trapctxs
operator|.
name|length
operator|>
literal|1
condition|?
name|end
else|:
literal|null
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|begin
argument_list|)
expr_stmt|;
specifier|final
name|BlockContext
name|blockctx
init|=
name|ctx
operator|.
name|block
argument_list|()
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|StatementMetadata
name|blocksmd
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|blockctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|blockctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blocksmd
operator|.
name|allLast
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|end
argument_list|)
expr_stmt|;
for|for
control|(
specifier|final
name|TrapContext
name|trapctx
range|:
name|trapctxs
control|)
block|{
name|visit
argument_list|(
name|trapctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|blocksmd
operator|.
name|allLast
operator|||
name|trapctxs
operator|.
name|length
operator|>
literal|1
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitThrow
specifier|public
name|Void
name|visitThrow
parameter_list|(
specifier|final
name|ThrowContext
name|ctx
parameter_list|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
expr_stmt|;
name|execute
operator|.
name|throwException
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExpr
specifier|public
name|Void
name|visitExpr
parameter_list|(
specifier|final
name|ExprContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|StatementMetadata
name|exprsmd
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|exprctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprsmd
operator|.
name|methodEscape
condition|)
block|{
name|execute
operator|.
name|returnValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|writePop
argument_list|(
name|expremd
operator|.
name|to
operator|.
name|type
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitMultiple
specifier|public
name|Void
name|visitMultiple
parameter_list|(
specifier|final
name|MultipleContext
name|ctx
parameter_list|)
block|{
for|for
control|(
specifier|final
name|StatementContext
name|sctx
range|:
name|ctx
operator|.
name|statement
argument_list|()
control|)
block|{
name|visit
argument_list|(
name|sctx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitSingle
specifier|public
name|Void
name|visitSingle
parameter_list|(
specifier|final
name|SingleContext
name|ctx
parameter_list|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|statement
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitEmpty
specifier|public
name|Void
name|visitEmpty
parameter_list|(
specifier|final
name|EmptyContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitInitializer
specifier|public
name|Void
name|visitInitializer
parameter_list|(
name|InitializerContext
name|ctx
parameter_list|)
block|{
specifier|final
name|DeclarationContext
name|declctx
init|=
name|ctx
operator|.
name|declaration
argument_list|()
decl_stmt|;
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|declctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|declctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exprctx
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|exprctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|writePop
argument_list|(
name|expremd
operator|.
name|to
operator|.
name|type
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitAfterthought
specifier|public
name|Void
name|visitAfterthought
parameter_list|(
name|AfterthoughtContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|exprctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
expr_stmt|;
name|writePop
argument_list|(
name|expremd
operator|.
name|to
operator|.
name|type
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitDeclaration
specifier|public
name|Void
name|visitDeclaration
parameter_list|(
name|DeclarationContext
name|ctx
parameter_list|)
block|{
for|for
control|(
specifier|final
name|DeclvarContext
name|declctx
range|:
name|ctx
operator|.
name|declvar
argument_list|()
control|)
block|{
name|visit
argument_list|(
name|declctx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitDecltype
specifier|public
name|Void
name|visitDecltype
parameter_list|(
specifier|final
name|DecltypeContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitDeclvar
specifier|public
name|Void
name|visitDeclvar
parameter_list|(
specifier|final
name|DeclvarContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|declvaremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
init|=
name|declvaremd
operator|.
name|to
operator|.
name|type
decl_stmt|;
specifier|final
name|Sort
name|sort
init|=
name|declvaremd
operator|.
name|to
operator|.
name|sort
decl_stmt|;
specifier|final
name|int
name|slot
init|=
operator|(
name|int
operator|)
name|declvaremd
operator|.
name|postConst
decl_stmt|;
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|initialize
init|=
name|exprctx
operator|==
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|initialize
condition|)
block|{
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sort
condition|)
block|{
case|case
name|VOID
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
case|case
name|BOOL
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|CHAR
case|:
case|case
name|INT
case|:
if|if
condition|(
name|initialize
condition|)
name|execute
operator|.
name|push
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
if|if
condition|(
name|initialize
condition|)
name|execute
operator|.
name|push
argument_list|(
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
if|if
condition|(
name|initialize
condition|)
name|execute
operator|.
name|push
argument_list|(
literal|0.0F
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
if|if
condition|(
name|initialize
condition|)
name|execute
operator|.
name|push
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|initialize
condition|)
name|execute
operator|.
name|visitInsn
argument_list|(
name|Opcodes
operator|.
name|ACONST_NULL
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|visitVarInsn
argument_list|(
name|type
operator|.
name|getOpcode
argument_list|(
name|Opcodes
operator|.
name|ISTORE
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitTrap
specifier|public
name|Void
name|visitTrap
parameter_list|(
specifier|final
name|TrapContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|StatementMetadata
name|trapsmd
init|=
name|metadata
operator|.
name|getStatementMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Label
name|jump
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
specifier|final
name|BlockContext
name|blockctx
init|=
name|ctx
operator|.
name|block
argument_list|()
decl_stmt|;
specifier|final
name|EmptyscopeContext
name|emptyctx
init|=
name|ctx
operator|.
name|emptyscope
argument_list|()
decl_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|writeLoadStoreVariable
argument_list|(
name|ctx
argument_list|,
literal|true
argument_list|,
name|trapsmd
operator|.
name|exception
argument_list|,
name|trapsmd
operator|.
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|blockctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|block
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|emptyctx
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
name|execute
operator|.
name|visitTryCatchBlock
argument_list|(
name|branch
operator|.
name|begin
argument_list|,
name|branch
operator|.
name|end
argument_list|,
name|jump
argument_list|,
name|trapsmd
operator|.
name|exception
operator|.
name|type
operator|.
name|getInternalName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|.
name|tru
operator|!=
literal|null
operator|&&
operator|!
name|trapsmd
operator|.
name|allLast
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|branch
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitPrecedence
specifier|public
name|Void
name|visitPrecedence
parameter_list|(
specifier|final
name|PrecedenceContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitNumeric
specifier|public
name|Void
name|visitNumeric
parameter_list|(
specifier|final
name|NumericContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|numericemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|numericemd
operator|.
name|postConst
decl_stmt|;
if|if
condition|(
name|postConst
operator|==
literal|null
condition|)
block|{
name|writeNumeric
argument_list|(
name|ctx
argument_list|,
name|numericemd
operator|.
name|preConst
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|numericemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitChar
specifier|public
name|Void
name|visitChar
parameter_list|(
specifier|final
name|CharContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|charemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|charemd
operator|.
name|postConst
decl_stmt|;
if|if
condition|(
name|postConst
operator|==
literal|null
condition|)
block|{
name|writeNumeric
argument_list|(
name|ctx
argument_list|,
call|(
name|int
call|)
argument_list|(
name|char
argument_list|)
name|charemd
operator|.
name|preConst
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|charemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitTrue
specifier|public
name|Void
name|visitTrue
parameter_list|(
specifier|final
name|TrueContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|trueemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|trueemd
operator|.
name|postConst
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|postConst
operator|==
literal|null
condition|)
block|{
name|writeBoolean
argument_list|(
name|ctx
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|trueemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|branch
operator|.
name|tru
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|branch
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitFalse
specifier|public
name|Void
name|visitFalse
parameter_list|(
specifier|final
name|FalseContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|falseemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|falseemd
operator|.
name|postConst
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|postConst
operator|==
literal|null
condition|)
block|{
name|writeBoolean
argument_list|(
name|ctx
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|falseemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|branch
operator|.
name|fals
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|branch
operator|.
name|fals
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitNull
specifier|public
name|Void
name|visitNull
parameter_list|(
specifier|final
name|NullContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|nullemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|execute
operator|.
name|visitInsn
argument_list|(
name|Opcodes
operator|.
name|ACONST_NULL
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|nullemd
argument_list|)
expr_stmt|;
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExternal
specifier|public
name|Void
name|visitExternal
parameter_list|(
specifier|final
name|ExternalContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|ctx
operator|.
name|extstart
argument_list|()
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitPostinc
specifier|public
name|Void
name|visitPostinc
parameter_list|(
specifier|final
name|PostincContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|ctx
operator|.
name|extstart
argument_list|()
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitPreinc
specifier|public
name|Void
name|visitPreinc
parameter_list|(
specifier|final
name|PreincContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|ctx
operator|.
name|extstart
argument_list|()
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitUnary
specifier|public
name|Void
name|visitUnary
parameter_list|(
specifier|final
name|UnaryContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|unaryemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|unaryemd
operator|.
name|postConst
decl_stmt|;
specifier|final
name|Object
name|preConst
init|=
name|unaryemd
operator|.
name|preConst
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|postConst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|BOOLNOT
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|boolean
operator|)
name|postConst
operator|&&
name|branch
operator|.
name|tru
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|branch
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|boolean
operator|)
name|postConst
operator|&&
name|branch
operator|.
name|fals
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|goTo
argument_list|(
name|branch
operator|.
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|preConst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|preConst
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|unaryemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|ctx
operator|.
name|expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|BOOLNOT
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Branch
name|local
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|local
operator|.
name|fals
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
specifier|final
name|Label
name|aend
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|aend
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|local
operator|.
name|fals
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|aend
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|unaryemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|local
operator|.
name|tru
operator|=
name|branch
operator|.
name|fals
expr_stmt|;
name|local
operator|.
name|fals
operator|=
name|branch
operator|.
name|tru
expr_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
init|=
name|unaryemd
operator|.
name|from
operator|.
name|type
decl_stmt|;
specifier|final
name|Sort
name|sort
init|=
name|unaryemd
operator|.
name|from
operator|.
name|sort
decl_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|.
name|BWNOT
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_NOT_CALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
operator|-
literal|1L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|XOR
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_NEG_CALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|settings
operator|.
name|getNumericOverflow
argument_list|()
condition|)
block|{
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|NEG
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|NEGATEEXACT_INT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|NEGATEEXACT_LONG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADD
argument_list|()
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
name|checkWriteCast
argument_list|(
name|unaryemd
argument_list|)
expr_stmt|;
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitCast
specifier|public
name|Void
name|visitCast
parameter_list|(
specifier|final
name|CastContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|castemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|castemd
operator|.
name|postConst
decl_stmt|;
if|if
condition|(
name|postConst
operator|==
literal|null
condition|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|castemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitBinary
specifier|public
name|Void
name|visitBinary
parameter_list|(
specifier|final
name|BinaryContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|binaryemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|binaryemd
operator|.
name|postConst
decl_stmt|;
specifier|final
name|Object
name|preConst
init|=
name|binaryemd
operator|.
name|preConst
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|postConst
operator|!=
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|preConst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|preConst
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|binaryemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|binaryemd
operator|.
name|from
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
condition|)
block|{
specifier|final
name|boolean
name|marked
init|=
name|strings
operator|.
name|contains
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|marked
condition|)
block|{
name|writeNewStrings
argument_list|()
expr_stmt|;
block|}
specifier|final
name|ExpressionContext
name|exprctx0
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd0
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|exprctx0
argument_list|)
decl_stmt|;
name|strings
operator|.
name|add
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|.
name|contains
argument_list|(
name|exprctx0
argument_list|)
condition|)
block|{
name|writeAppendStrings
argument_list|(
name|expremd0
operator|.
name|from
operator|.
name|sort
argument_list|)
expr_stmt|;
name|strings
operator|.
name|remove
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
block|}
specifier|final
name|ExpressionContext
name|exprctx1
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd1
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|exprctx1
argument_list|)
decl_stmt|;
name|strings
operator|.
name|add
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|.
name|contains
argument_list|(
name|exprctx1
argument_list|)
condition|)
block|{
name|writeAppendStrings
argument_list|(
name|expremd1
operator|.
name|from
operator|.
name|sort
argument_list|)
expr_stmt|;
name|strings
operator|.
name|remove
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|marked
condition|)
block|{
name|strings
operator|.
name|remove
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeToStrings
argument_list|()
expr_stmt|;
block|}
name|checkWriteCast
argument_list|(
name|binaryemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|ExpressionContext
name|exprctx0
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionContext
name|exprctx1
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
specifier|final
name|Type
name|type
init|=
name|binaryemd
operator|.
name|from
decl_stmt|;
if|if
condition|(
name|ctx
operator|.
name|MUL
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|MUL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|DIV
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|DIV
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|REM
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|REM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|ADD
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|ADD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|SUB
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|SUB
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|LSH
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|LSH
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|USH
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|USH
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|RSH
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|RSH
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWAND
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|BWAND
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWXOR
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|BWXOR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BWOR
argument_list|()
operator|!=
literal|null
condition|)
name|writeBinaryInstruction
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|,
name|BWOR
argument_list|)
expr_stmt|;
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
name|checkWriteCast
argument_list|(
name|binaryemd
argument_list|)
expr_stmt|;
block|}
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitComp
specifier|public
name|Void
name|visitComp
parameter_list|(
specifier|final
name|CompContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|compemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|compemd
operator|.
name|postConst
decl_stmt|;
specifier|final
name|Object
name|preConst
init|=
name|compemd
operator|.
name|preConst
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|postConst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|boolean
operator|)
name|postConst
operator|&&
name|branch
operator|.
name|tru
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|boolean
operator|)
name|postConst
operator|&&
name|branch
operator|.
name|fals
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|preConst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|preConst
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|compemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|ExpressionContext
name|exprctx0
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd0
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|exprctx0
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionContext
name|exprctx1
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd1
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|exprctx1
argument_list|)
decl_stmt|;
specifier|final
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
init|=
name|expremd1
operator|.
name|to
operator|.
name|type
decl_stmt|;
specifier|final
name|Sort
name|sort1
init|=
name|expremd1
operator|.
name|to
operator|.
name|sort
decl_stmt|;
name|visit
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expremd1
operator|.
name|isNull
condition|)
block|{
name|visit
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|tru
init|=
name|branch
operator|!=
literal|null
operator|&&
name|branch
operator|.
name|tru
operator|!=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|fals
init|=
name|branch
operator|!=
literal|null
operator|&&
name|branch
operator|.
name|fals
operator|!=
literal|null
decl_stmt|;
specifier|final
name|Label
name|jump
init|=
name|tru
condition|?
name|branch
operator|.
name|tru
else|:
name|fals
condition|?
name|branch
operator|.
name|fals
else|:
operator|new
name|Label
argument_list|()
decl_stmt|;
specifier|final
name|Label
name|end
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
specifier|final
name|boolean
name|eq
init|=
operator|(
name|ctx
operator|.
name|EQ
argument_list|()
operator|!=
literal|null
operator|||
name|ctx
operator|.
name|EQR
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|tru
operator|||
operator|!
name|fals
operator|)
operator|||
operator|(
name|ctx
operator|.
name|NE
argument_list|()
operator|!=
literal|null
operator|||
name|ctx
operator|.
name|NER
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
name|fals
decl_stmt|;
specifier|final
name|boolean
name|ne
init|=
operator|(
name|ctx
operator|.
name|NE
argument_list|()
operator|!=
literal|null
operator|||
name|ctx
operator|.
name|NER
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|tru
operator|||
operator|!
name|fals
operator|)
operator|||
operator|(
name|ctx
operator|.
name|EQ
argument_list|()
operator|!=
literal|null
operator|||
name|ctx
operator|.
name|EQR
argument_list|()
operator|!=
literal|null
operator|)
operator|&&
name|fals
decl_stmt|;
specifier|final
name|boolean
name|lt
init|=
name|ctx
operator|.
name|LT
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|tru
operator|||
operator|!
name|fals
operator|)
operator|||
name|ctx
operator|.
name|GTE
argument_list|()
operator|!=
literal|null
operator|&&
name|fals
decl_stmt|;
specifier|final
name|boolean
name|lte
init|=
name|ctx
operator|.
name|LTE
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|tru
operator|||
operator|!
name|fals
operator|)
operator|||
name|ctx
operator|.
name|GT
argument_list|()
operator|!=
literal|null
operator|&&
name|fals
decl_stmt|;
specifier|final
name|boolean
name|gt
init|=
name|ctx
operator|.
name|GT
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|tru
operator|||
operator|!
name|fals
operator|)
operator|||
name|ctx
operator|.
name|LTE
argument_list|()
operator|!=
literal|null
operator|&&
name|fals
decl_stmt|;
specifier|final
name|boolean
name|gte
init|=
name|ctx
operator|.
name|GTE
argument_list|()
operator|!=
literal|null
operator|&&
operator|(
name|tru
operator|||
operator|!
name|fals
operator|)
operator|||
name|ctx
operator|.
name|LT
argument_list|()
operator|!=
literal|null
operator|&&
name|fals
decl_stmt|;
name|boolean
name|writejump
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|sort1
condition|)
block|{
case|case
name|VOID
case|:
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|CHAR
case|:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
case|case
name|BOOL
case|:
if|if
condition|(
name|eq
condition|)
name|execute
operator|.
name|ifZCmp
argument_list|(
name|GeneratorAdapter
operator|.
name|EQ
argument_list|,
name|jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ne
condition|)
name|execute
operator|.
name|ifZCmp
argument_list|(
name|GeneratorAdapter
operator|.
name|NE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|INT
case|:
case|case
name|LONG
case|:
case|case
name|FLOAT
case|:
case|case
name|DOUBLE
case|:
if|if
condition|(
name|eq
condition|)
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|EQ
argument_list|,
name|jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ne
condition|)
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|NE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lt
condition|)
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|LT
argument_list|,
name|jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lte
condition|)
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|LE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gt
condition|)
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|GT
argument_list|,
name|jump
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gte
condition|)
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|GE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|DEF
case|:
if|if
condition|(
name|eq
condition|)
block|{
if|if
condition|(
name|expremd1
operator|.
name|isNull
condition|)
block|{
name|execute
operator|.
name|ifNull
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|expremd0
operator|.
name|isNull
operator|&&
name|ctx
operator|.
name|EQ
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_EQ_CALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|EQ
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ne
condition|)
block|{
if|if
condition|(
name|expremd1
operator|.
name|isNull
condition|)
block|{
name|execute
operator|.
name|ifNonNull
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|expremd0
operator|.
name|isNull
operator|&&
name|ctx
operator|.
name|NE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_EQ_CALL
argument_list|)
expr_stmt|;
name|execute
operator|.
name|ifZCmp
argument_list|(
name|GeneratorAdapter
operator|.
name|EQ
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|NE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lt
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_LT_CALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lte
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_LTE_CALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gt
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_GT_CALL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gte
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_GTE_CALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
name|writejump
operator|=
name|expremd1
operator|.
name|isNull
operator|||
name|ne
operator|||
name|ctx
operator|.
name|EQR
argument_list|()
operator|!=
literal|null
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
literal|null
operator|&&
operator|!
name|writejump
condition|)
block|{
name|execute
operator|.
name|ifZCmp
argument_list|(
name|GeneratorAdapter
operator|.
name|NE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|eq
condition|)
block|{
if|if
condition|(
name|expremd1
operator|.
name|isNull
condition|)
block|{
name|execute
operator|.
name|ifNull
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|EQ
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|CHECKEQUALS
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|ifZCmp
argument_list|(
name|GeneratorAdapter
operator|.
name|NE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
name|writejump
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|EQ
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ne
condition|)
block|{
if|if
condition|(
name|expremd1
operator|.
name|isNull
condition|)
block|{
name|execute
operator|.
name|ifNonNull
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|NE
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|CHECKEQUALS
argument_list|)
expr_stmt|;
name|execute
operator|.
name|ifZCmp
argument_list|(
name|GeneratorAdapter
operator|.
name|EQ
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|ifCmp
argument_list|(
name|type
argument_list|,
name|GeneratorAdapter
operator|.
name|NE
argument_list|,
name|jump
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|writejump
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
name|checkWriteCast
argument_list|(
name|compemd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitBool
specifier|public
name|Void
name|visitBool
parameter_list|(
specifier|final
name|BoolContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|boolemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|boolemd
operator|.
name|postConst
decl_stmt|;
specifier|final
name|Object
name|preConst
init|=
name|boolemd
operator|.
name|preConst
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|postConst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|boolean
operator|)
name|postConst
operator|&&
name|branch
operator|.
name|tru
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|boolean
operator|)
name|postConst
operator|&&
name|branch
operator|.
name|fals
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|branch
operator|.
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|preConst
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|preConst
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|boolemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
specifier|final
name|ExpressionContext
name|exprctx0
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionContext
name|exprctx1
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ctx
operator|.
name|BOOLAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Branch
name|local
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx0
argument_list|,
name|exprctx1
argument_list|)
decl_stmt|;
name|local
operator|.
name|fals
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
specifier|final
name|Label
name|end
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|visit
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|local
operator|.
name|fals
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BOOLOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Branch
name|branch0
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx0
argument_list|)
decl_stmt|;
name|branch0
operator|.
name|tru
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
specifier|final
name|Branch
name|branch1
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx1
argument_list|)
decl_stmt|;
name|branch1
operator|.
name|fals
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
specifier|final
name|Label
name|aend
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|visit
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|branch0
operator|.
name|tru
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|aend
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|branch1
operator|.
name|fals
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|aend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
name|checkWriteCast
argument_list|(
name|boolemd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctx
operator|.
name|BOOLAND
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Branch
name|branch0
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx0
argument_list|)
decl_stmt|;
name|branch0
operator|.
name|fals
operator|=
name|branch
operator|.
name|fals
operator|==
literal|null
condition|?
operator|new
name|Label
argument_list|()
else|:
name|branch
operator|.
name|fals
expr_stmt|;
specifier|final
name|Branch
name|branch1
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx1
argument_list|)
decl_stmt|;
name|branch1
operator|.
name|tru
operator|=
name|branch
operator|.
name|tru
expr_stmt|;
name|branch1
operator|.
name|fals
operator|=
name|branch
operator|.
name|fals
expr_stmt|;
name|visit
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|.
name|fals
operator|==
literal|null
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|branch0
operator|.
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctx
operator|.
name|BOOLOR
argument_list|()
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Branch
name|branch0
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx0
argument_list|)
decl_stmt|;
name|branch0
operator|.
name|tru
operator|=
name|branch
operator|.
name|tru
operator|==
literal|null
condition|?
operator|new
name|Label
argument_list|()
else|:
name|branch
operator|.
name|tru
expr_stmt|;
specifier|final
name|Branch
name|branch1
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|exprctx1
argument_list|)
decl_stmt|;
name|branch1
operator|.
name|tru
operator|=
name|branch
operator|.
name|tru
expr_stmt|;
name|branch1
operator|.
name|fals
operator|=
name|branch
operator|.
name|fals
expr_stmt|;
name|visit
argument_list|(
name|exprctx0
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|exprctx1
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|.
name|tru
operator|==
literal|null
condition|)
block|{
name|execute
operator|.
name|mark
argument_list|(
name|branch0
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitConditional
specifier|public
name|Void
name|visitConditional
parameter_list|(
specifier|final
name|ConditionalContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|condemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionContext
name|expr0
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionContext
name|expr1
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|1
argument_list|)
decl_stmt|;
specifier|final
name|ExpressionContext
name|expr2
init|=
name|ctx
operator|.
name|expression
argument_list|(
literal|2
argument_list|)
decl_stmt|;
specifier|final
name|Branch
name|local
init|=
name|markBranch
argument_list|(
name|ctx
argument_list|,
name|expr0
argument_list|)
decl_stmt|;
name|local
operator|.
name|fals
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
name|local
operator|.
name|end
operator|=
operator|new
name|Label
argument_list|()
expr_stmt|;
if|if
condition|(
name|branch
operator|!=
literal|null
condition|)
block|{
name|copyBranch
argument_list|(
name|branch
argument_list|,
name|expr1
argument_list|,
name|expr2
argument_list|)
expr_stmt|;
block|}
name|visit
argument_list|(
name|expr0
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|expr1
argument_list|)
expr_stmt|;
name|execute
operator|.
name|goTo
argument_list|(
name|local
operator|.
name|end
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|local
operator|.
name|fals
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|expr2
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|local
operator|.
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|branch
operator|==
literal|null
condition|)
block|{
name|checkWriteCast
argument_list|(
name|condemd
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitAssignment
specifier|public
name|Void
name|visitAssignment
parameter_list|(
specifier|final
name|AssignmentContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|ctx
operator|.
name|extstart
argument_list|()
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|expremd
argument_list|)
expr_stmt|;
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtstart
specifier|public
name|Void
name|visitExtstart
parameter_list|(
name|ExtstartContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExternalMetadata
name|startemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
if|if
condition|(
name|startemd
operator|.
name|token
operator|==
name|ADD
condition|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|storeemd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|startemd
operator|.
name|storeExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|startemd
operator|.
name|current
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
operator|||
name|storeemd
operator|.
name|from
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
condition|)
block|{
name|writeNewStrings
argument_list|()
expr_stmt|;
name|strings
operator|.
name|add
argument_list|(
name|startemd
operator|.
name|storeExpr
argument_list|)
expr_stmt|;
block|}
block|}
specifier|final
name|ExtprecContext
name|precctx
init|=
name|ctx
operator|.
name|extprec
argument_list|()
decl_stmt|;
specifier|final
name|ExtcastContext
name|castctx
init|=
name|ctx
operator|.
name|extcast
argument_list|()
decl_stmt|;
specifier|final
name|ExttypeContext
name|typectx
init|=
name|ctx
operator|.
name|exttype
argument_list|()
decl_stmt|;
specifier|final
name|ExtvarContext
name|varctx
init|=
name|ctx
operator|.
name|extvar
argument_list|()
decl_stmt|;
specifier|final
name|ExtnewContext
name|newctx
init|=
name|ctx
operator|.
name|extnew
argument_list|()
decl_stmt|;
specifier|final
name|ExtstringContext
name|stringctx
init|=
name|ctx
operator|.
name|extstring
argument_list|()
decl_stmt|;
if|if
condition|(
name|precctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|precctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|castctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|castctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|typectx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|varctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|newctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|stringctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtprec
specifier|public
name|Void
name|visitExtprec
parameter_list|(
specifier|final
name|ExtprecContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtprecContext
name|precctx
init|=
name|ctx
operator|.
name|extprec
argument_list|()
decl_stmt|;
specifier|final
name|ExtcastContext
name|castctx
init|=
name|ctx
operator|.
name|extcast
argument_list|()
decl_stmt|;
specifier|final
name|ExttypeContext
name|typectx
init|=
name|ctx
operator|.
name|exttype
argument_list|()
decl_stmt|;
specifier|final
name|ExtvarContext
name|varctx
init|=
name|ctx
operator|.
name|extvar
argument_list|()
decl_stmt|;
specifier|final
name|ExtnewContext
name|newctx
init|=
name|ctx
operator|.
name|extnew
argument_list|()
decl_stmt|;
specifier|final
name|ExtstringContext
name|stringctx
init|=
name|ctx
operator|.
name|extstring
argument_list|()
decl_stmt|;
if|if
condition|(
name|precctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|precctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|castctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|castctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|typectx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|varctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|newctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|stringctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtcast
specifier|public
name|Void
name|visitExtcast
parameter_list|(
specifier|final
name|ExtcastContext
name|ctx
parameter_list|)
block|{
name|Metadata
operator|.
name|ExtNodeMetadata
name|castenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|ExtprecContext
name|precctx
init|=
name|ctx
operator|.
name|extprec
argument_list|()
decl_stmt|;
specifier|final
name|ExtcastContext
name|castctx
init|=
name|ctx
operator|.
name|extcast
argument_list|()
decl_stmt|;
specifier|final
name|ExttypeContext
name|typectx
init|=
name|ctx
operator|.
name|exttype
argument_list|()
decl_stmt|;
specifier|final
name|ExtvarContext
name|varctx
init|=
name|ctx
operator|.
name|extvar
argument_list|()
decl_stmt|;
specifier|final
name|ExtnewContext
name|newctx
init|=
name|ctx
operator|.
name|extnew
argument_list|()
decl_stmt|;
specifier|final
name|ExtstringContext
name|stringctx
init|=
name|ctx
operator|.
name|extstring
argument_list|()
decl_stmt|;
if|if
condition|(
name|precctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|precctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|castctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|castctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|typectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|typectx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|varctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|newctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stringctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|stringctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
name|checkWriteCast
argument_list|(
name|ctx
argument_list|,
name|castenmd
operator|.
name|castTo
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtbrace
specifier|public
name|Void
name|visitExtbrace
parameter_list|(
specifier|final
name|ExtbraceContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExpressionContext
name|exprctx
init|=
name|metadata
operator|.
name|updateExpressionTree
argument_list|(
name|ctx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
name|writeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtdot
specifier|public
name|Void
name|visitExtdot
parameter_list|(
specifier|final
name|ExtdotContext
name|ctx
parameter_list|)
block|{
specifier|final
name|ExtcallContext
name|callctx
init|=
name|ctx
operator|.
name|extcall
argument_list|()
decl_stmt|;
specifier|final
name|ExtfieldContext
name|fieldctx
init|=
name|ctx
operator|.
name|extfield
argument_list|()
decl_stmt|;
if|if
condition|(
name|callctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|callctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fieldctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|fieldctx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExttype
specifier|public
name|Void
name|visitExttype
parameter_list|(
specifier|final
name|ExttypeContext
name|ctx
parameter_list|)
block|{
name|visit
argument_list|(
name|ctx
operator|.
name|extdot
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtcall
specifier|public
name|Void
name|visitExtcall
parameter_list|(
specifier|final
name|ExtcallContext
name|ctx
parameter_list|)
block|{
name|writeCallExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtvar
specifier|public
name|Void
name|visitExtvar
parameter_list|(
specifier|final
name|ExtvarContext
name|ctx
parameter_list|)
block|{
name|writeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtfield
specifier|public
name|Void
name|visitExtfield
parameter_list|(
specifier|final
name|ExtfieldContext
name|ctx
parameter_list|)
block|{
name|writeLoadStoreExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtnew
specifier|public
name|Void
name|visitExtnew
parameter_list|(
name|ExtnewContext
name|ctx
parameter_list|)
block|{
name|writeNewExternal
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitExtstring
specifier|public
name|Void
name|visitExtstring
parameter_list|(
name|ExtstringContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExtNodeMetadata
name|stringenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|stringenmd
operator|.
name|target
argument_list|)
expr_stmt|;
specifier|final
name|ExtdotContext
name|dotctx
init|=
name|ctx
operator|.
name|extdot
argument_list|()
decl_stmt|;
specifier|final
name|ExtbraceContext
name|bracectx
init|=
name|ctx
operator|.
name|extbrace
argument_list|()
decl_stmt|;
if|if
condition|(
name|dotctx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|dotctx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bracectx
operator|!=
literal|null
condition|)
block|{
name|visit
argument_list|(
name|bracectx
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
annotation|@
name|Override
DECL|method|visitArguments
specifier|public
name|Void
name|visitArguments
parameter_list|(
specifier|final
name|ArgumentsContext
name|ctx
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|ctx
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
annotation|@
name|Override
DECL|method|visitIncrement
specifier|public
name|Void
name|visitIncrement
parameter_list|(
name|IncrementContext
name|ctx
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|incremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
specifier|final
name|Object
name|postConst
init|=
name|incremd
operator|.
name|postConst
decl_stmt|;
if|if
condition|(
name|postConst
operator|==
literal|null
condition|)
block|{
name|writeNumeric
argument_list|(
name|ctx
argument_list|,
name|incremd
operator|.
name|preConst
argument_list|)
expr_stmt|;
name|checkWriteCast
argument_list|(
name|incremd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeConstant
argument_list|(
name|ctx
argument_list|,
name|postConst
argument_list|)
expr_stmt|;
block|}
name|checkWriteBranch
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
DECL|method|writeLoopCounter
specifier|private
name|void
name|writeLoopCounter
parameter_list|(
specifier|final
name|int
name|count
parameter_list|)
block|{
specifier|final
name|Label
name|end
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|execute
operator|.
name|iinc
argument_list|(
name|metadata
operator|.
name|loopCounterSlot
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
name|execute
operator|.
name|visitVarInsn
argument_list|(
name|Opcodes
operator|.
name|ILOAD
argument_list|,
name|metadata
operator|.
name|loopCounterSlot
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|execute
operator|.
name|ifICmp
argument_list|(
name|GeneratorAdapter
operator|.
name|GT
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|execute
operator|.
name|throwException
argument_list|(
name|PAINLESS_ERROR_TYPE
argument_list|,
literal|"The maximum number of statements that can be executed in a loop has been reached."
argument_list|)
expr_stmt|;
name|execute
operator|.
name|mark
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
DECL|method|writeConstant
specifier|private
name|void
name|writeConstant
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|constant
parameter_list|)
block|{
if|if
condition|(
name|constant
operator|instanceof
name|Number
condition|)
block|{
name|writeNumeric
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|instanceof
name|Character
condition|)
block|{
name|writeNumeric
argument_list|(
name|source
argument_list|,
call|(
name|int
call|)
argument_list|(
name|char
argument_list|)
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|instanceof
name|String
condition|)
block|{
name|writeString
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|instanceof
name|Boolean
condition|)
block|{
name|writeBoolean
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeNumeric
specifier|private
name|void
name|writeNumeric
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|numeric
parameter_list|)
block|{
if|if
condition|(
name|numeric
operator|instanceof
name|Double
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|double
operator|)
name|numeric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numeric
operator|instanceof
name|Float
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|float
operator|)
name|numeric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numeric
operator|instanceof
name|Long
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|long
operator|)
name|numeric
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numeric
operator|instanceof
name|Number
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
operator|(
name|Number
operator|)
name|numeric
operator|)
operator|.
name|intValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeString
specifier|private
name|void
name|writeString
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|string
parameter_list|)
block|{
if|if
condition|(
name|string
operator|instanceof
name|String
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|String
operator|)
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeBoolean
specifier|private
name|void
name|writeBoolean
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Object
name|bool
parameter_list|)
block|{
if|if
condition|(
name|bool
operator|instanceof
name|Boolean
condition|)
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|boolean
operator|)
name|bool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeNewStrings
specifier|private
name|void
name|writeNewStrings
parameter_list|()
block|{
name|execute
operator|.
name|newInstance
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
name|execute
operator|.
name|invokeConstructor
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_CONSTRUCTOR
argument_list|)
expr_stmt|;
block|}
DECL|method|writeAppendStrings
specifier|private
name|void
name|writeAppendStrings
parameter_list|(
specifier|final
name|Sort
name|sort
parameter_list|)
block|{
switch|switch
condition|(
name|sort
condition|)
block|{
case|case
name|BOOL
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_BOOLEAN
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_STRING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_OBJECT
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeToStrings
specifier|private
name|void
name|writeToStrings
parameter_list|()
block|{
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_TOSTRING
argument_list|)
expr_stmt|;
block|}
DECL|method|writeBinaryInstruction
specifier|private
name|void
name|writeBinaryInstruction
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|token
parameter_list|)
block|{
specifier|final
name|Sort
name|sort
init|=
name|type
operator|.
name|sort
decl_stmt|;
specifier|final
name|boolean
name|exact
init|=
operator|!
name|settings
operator|.
name|getNumericOverflow
argument_list|()
operator|&&
operator|(
operator|(
name|sort
operator|==
name|Sort
operator|.
name|INT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|LONG
operator|)
operator|&&
operator|(
name|token
operator|==
name|MUL
operator|||
name|token
operator|==
name|DIV
operator|||
name|token
operator|==
name|ADD
operator|||
name|token
operator|==
name|SUB
operator|)
operator|||
operator|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
operator|)
operator|&&
operator|(
name|token
operator|==
name|MUL
operator|||
name|token
operator|==
name|DIV
operator|||
name|token
operator|==
name|REM
operator|||
name|token
operator|==
name|ADD
operator|||
name|token
operator|==
name|SUB
operator|)
operator|)
decl_stmt|;
comment|// if its a 64-bit shift, fixup the lastSource argument to truncate to 32-bits
comment|// note unlike java, this means we still do binary promotion of shifts,
comment|// but it keeps things simple -- this check works because we promote shifts.
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|LONG
operator|&&
operator|(
name|token
operator|==
name|LSH
operator|||
name|token
operator|==
name|USH
operator|||
name|token
operator|==
name|RSH
operator|)
condition|)
block|{
name|execute
operator|.
name|cast
argument_list|(
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|LONG_TYPE
argument_list|,
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|INT_TYPE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exact
condition|)
block|{
switch|switch
condition|(
name|sort
condition|)
block|{
case|case
name|INT
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|MULEXACT_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|ADDEXACT_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|SUBEXACT_INT
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|LONG
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|MULEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|ADDEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|SUBEXACT_LONG
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|FLOAT
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|MULWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|REMWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|ADDWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|SUBWOOVERLOW_FLOAT
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
break|break;
case|case
name|DOUBLE
case|:
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|MULWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|DIVWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|REMWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|ADDWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|SUBWOOVERLOW_DOUBLE
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
operator|)
operator|&&
operator|(
name|token
operator|==
name|LSH
operator|||
name|token
operator|==
name|USH
operator|||
name|token
operator|==
name|RSH
operator|||
name|token
operator|==
name|BWAND
operator|||
name|token
operator|==
name|BWXOR
operator|||
name|token
operator|==
name|BWOR
operator|)
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_MUL_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_DIV_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_REM_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_ADD_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_SUB_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_LSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_RSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_USH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_AND_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWXOR
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_XOR_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_OR_CALL
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|token
condition|)
block|{
case|case
name|MUL
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|MUL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|DIV
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|REM
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|ADD
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SUB
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|USHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|AND
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWXOR
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|XOR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|execute
operator|.
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|OR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected writer state."
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * Called for any compound assignment (including increment/decrement instructions).      * We have to be stricter than writeBinary, and do overflow checks against the original type's size      * instead of the promoted type's size, since the result will be implicitly cast back.      *      * @return true if an instruction is written, false otherwise      */
DECL|method|writeExactInstruction
specifier|private
name|boolean
name|writeExactInstruction
parameter_list|(
specifier|final
name|Sort
name|osort
parameter_list|,
specifier|final
name|Sort
name|psort
parameter_list|)
block|{
if|if
condition|(
name|psort
operator|==
name|Sort
operator|.
name|DOUBLE
condition|)
block|{
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOFLOATWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|FLOAT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOFLOATWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|floatobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|LONG_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|longobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|INT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|intobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_DOUBLE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|psort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
block|{
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|LONG_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOLONGWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|longobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|INT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOINTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|intobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHARWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEWOOVERFLOW_FLOAT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|psort
operator|==
name|Sort
operator|.
name|LONG
condition|)
block|{
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|TOINTEXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|INT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|mathType
operator|.
name|type
argument_list|,
name|TOINTEXACT_LONG
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|intobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_LONG
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_LONG
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_LONG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_LONG
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|psort
operator|==
name|Sort
operator|.
name|INT
condition|)
block|{
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_INT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|CHAR_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOCHAREXACT_INT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|charobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_INT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|SHORT_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOSHORTEXACT_INT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|shortobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_INT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osort
operator|==
name|Sort
operator|.
name|BYTE_OBJ
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|utilityType
operator|.
name|type
argument_list|,
name|TOBYTEEXACT_INT
argument_list|)
expr_stmt|;
name|execute
operator|.
name|checkCast
argument_list|(
name|definition
operator|.
name|byteobjType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|writeLoadStoreExternal
specifier|private
name|void
name|writeLoadStoreExternal
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExtNodeMetadata
name|sourceenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|sourceenmd
operator|.
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|length
init|=
literal|"#length"
operator|.
name|equals
argument_list|(
name|sourceenmd
operator|.
name|target
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|array
init|=
literal|"#brace"
operator|.
name|equals
argument_list|(
name|sourceenmd
operator|.
name|target
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|name
init|=
name|sourceenmd
operator|.
name|target
operator|instanceof
name|String
operator|&&
operator|!
name|length
operator|&&
operator|!
name|array
decl_stmt|;
specifier|final
name|boolean
name|variable
init|=
name|sourceenmd
operator|.
name|target
operator|instanceof
name|Integer
decl_stmt|;
specifier|final
name|boolean
name|field
init|=
name|sourceenmd
operator|.
name|target
operator|instanceof
name|Field
decl_stmt|;
specifier|final
name|boolean
name|shortcut
init|=
name|sourceenmd
operator|.
name|target
operator|instanceof
name|Object
index|[]
decl_stmt|;
if|if
condition|(
operator|!
name|length
operator|&&
operator|!
name|variable
operator|&&
operator|!
name|field
operator|&&
operator|!
name|array
operator|&&
operator|!
name|name
operator|&&
operator|!
name|shortcut
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Target not found for load/store."
argument_list|)
throw|;
block|}
specifier|final
name|boolean
name|maplist
init|=
name|shortcut
operator|&&
call|(
name|boolean
call|)
argument_list|(
operator|(
name|Object
index|[]
operator|)
name|sourceenmd
operator|.
name|target
argument_list|)
index|[
literal|2
index|]
decl_stmt|;
specifier|final
name|Object
name|constant
init|=
name|shortcut
condition|?
operator|(
operator|(
name|Object
index|[]
operator|)
name|sourceenmd
operator|.
name|target
operator|)
index|[
literal|3
index|]
else|:
literal|null
decl_stmt|;
specifier|final
name|boolean
name|x1
init|=
name|field
operator|||
name|name
operator|||
operator|(
name|shortcut
operator|&&
operator|!
name|maplist
operator|)
decl_stmt|;
specifier|final
name|boolean
name|x2
init|=
name|array
operator|||
operator|(
name|shortcut
operator|&&
name|maplist
operator|)
decl_stmt|;
if|if
condition|(
name|length
condition|)
block|{
name|execute
operator|.
name|arrayLength
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sourceenmd
operator|.
name|last
operator|&&
name|parentemd
operator|.
name|storeExpr
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|cat
init|=
name|strings
operator|.
name|contains
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cat
condition|)
block|{
if|if
condition|(
name|field
operator|||
name|name
operator|||
name|shortcut
condition|)
block|{
name|execute
operator|.
name|dupX1
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|array
condition|)
block|{
name|execute
operator|.
name|dup2X1
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|maplist
condition|)
block|{
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|dupX2
argument_list|()
expr_stmt|;
block|}
name|writeLoadStoreInstruction
argument_list|(
name|source
argument_list|,
literal|false
argument_list|,
name|variable
argument_list|,
name|field
argument_list|,
name|name
argument_list|,
name|array
argument_list|,
name|shortcut
argument_list|)
expr_stmt|;
name|writeAppendStrings
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|sort
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strings
operator|.
name|contains
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
condition|)
block|{
name|writeAppendStrings
argument_list|(
name|expremd
operator|.
name|to
operator|.
name|sort
argument_list|)
expr_stmt|;
name|strings
operator|.
name|remove
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
expr_stmt|;
block|}
name|writeToStrings
argument_list|()
expr_stmt|;
name|checkWriteCast
argument_list|(
name|source
argument_list|,
name|sourceenmd
operator|.
name|castTo
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|read
condition|)
block|{
name|writeDup
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|sort
operator|.
name|size
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
block|}
name|writeLoadStoreInstruction
argument_list|(
name|source
argument_list|,
literal|true
argument_list|,
name|variable
argument_list|,
name|field
argument_list|,
name|name
argument_list|,
name|array
argument_list|,
name|shortcut
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parentemd
operator|.
name|token
operator|>
literal|0
condition|)
block|{
specifier|final
name|int
name|token
init|=
name|parentemd
operator|.
name|token
decl_stmt|;
if|if
condition|(
name|field
operator|||
name|name
operator|||
name|shortcut
condition|)
block|{
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|array
condition|)
block|{
name|execute
operator|.
name|dup2
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|maplist
condition|)
block|{
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|dupX1
argument_list|()
expr_stmt|;
block|}
name|writeLoadStoreInstruction
argument_list|(
name|source
argument_list|,
literal|false
argument_list|,
name|variable
argument_list|,
name|field
argument_list|,
name|name
argument_list|,
name|array
argument_list|,
name|shortcut
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|read
operator|&&
name|parentemd
operator|.
name|post
condition|)
block|{
name|writeDup
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|sort
operator|.
name|size
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
block|}
name|checkWriteCast
argument_list|(
name|source
argument_list|,
name|sourceenmd
operator|.
name|castFrom
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
expr_stmt|;
name|writeBinaryInstruction
argument_list|(
name|source
argument_list|,
name|sourceenmd
operator|.
name|promote
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|boolean
name|exact
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|settings
operator|.
name|getNumericOverflow
argument_list|()
operator|&&
name|expremd
operator|.
name|typesafe
operator|&&
name|sourceenmd
operator|.
name|type
operator|.
name|sort
operator|!=
name|Sort
operator|.
name|DEF
operator|&&
operator|(
name|token
operator|==
name|MUL
operator|||
name|token
operator|==
name|DIV
operator|||
name|token
operator|==
name|REM
operator|||
name|token
operator|==
name|ADD
operator|||
name|token
operator|==
name|SUB
operator|)
condition|)
block|{
name|exact
operator|=
name|writeExactInstruction
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|sort
argument_list|,
name|sourceenmd
operator|.
name|promote
operator|.
name|sort
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|checkWriteCast
argument_list|(
name|source
argument_list|,
name|sourceenmd
operator|.
name|castTo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parentemd
operator|.
name|read
operator|&&
operator|!
name|parentemd
operator|.
name|post
condition|)
block|{
name|writeDup
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|sort
operator|.
name|size
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
block|}
name|writeLoadStoreInstruction
argument_list|(
name|source
argument_list|,
literal|true
argument_list|,
name|variable
argument_list|,
name|field
argument_list|,
name|name
argument_list|,
name|array
argument_list|,
name|shortcut
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
name|visit
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|read
condition|)
block|{
name|writeDup
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|sort
operator|.
name|size
argument_list|,
name|x1
argument_list|,
name|x2
argument_list|)
expr_stmt|;
block|}
name|writeLoadStoreInstruction
argument_list|(
name|source
argument_list|,
literal|true
argument_list|,
name|variable
argument_list|,
name|field
argument_list|,
name|name
argument_list|,
name|array
argument_list|,
name|shortcut
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|constant
operator|!=
literal|null
condition|)
block|{
name|writeConstant
argument_list|(
name|source
argument_list|,
name|constant
argument_list|)
expr_stmt|;
block|}
name|writeLoadStoreInstruction
argument_list|(
name|source
argument_list|,
literal|false
argument_list|,
name|variable
argument_list|,
name|field
argument_list|,
name|name
argument_list|,
name|array
argument_list|,
name|shortcut
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeLoadStoreInstruction
specifier|private
name|void
name|writeLoadStoreInstruction
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|boolean
name|store
parameter_list|,
specifier|final
name|boolean
name|variable
parameter_list|,
specifier|final
name|boolean
name|field
parameter_list|,
specifier|final
name|boolean
name|name
parameter_list|,
specifier|final
name|boolean
name|array
parameter_list|,
specifier|final
name|boolean
name|shortcut
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExtNodeMetadata
name|sourceemd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|variable
condition|)
block|{
name|writeLoadStoreVariable
argument_list|(
name|source
argument_list|,
name|store
argument_list|,
name|sourceemd
operator|.
name|type
argument_list|,
operator|(
name|int
operator|)
name|sourceemd
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
condition|)
block|{
name|writeLoadStoreField
argument_list|(
name|store
argument_list|,
operator|(
name|Field
operator|)
name|sourceemd
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
condition|)
block|{
name|writeLoadStoreField
argument_list|(
name|source
argument_list|,
name|store
argument_list|,
operator|(
name|String
operator|)
name|sourceemd
operator|.
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|array
condition|)
block|{
name|writeLoadStoreArray
argument_list|(
name|source
argument_list|,
name|store
argument_list|,
name|sourceemd
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shortcut
condition|)
block|{
name|Object
index|[]
name|targets
init|=
operator|(
name|Object
index|[]
operator|)
name|sourceemd
operator|.
name|target
decl_stmt|;
name|writeLoadStoreShortcut
argument_list|(
name|store
argument_list|,
operator|(
name|Method
operator|)
name|targets
index|[
literal|0
index|]
argument_list|,
operator|(
name|Method
operator|)
name|targets
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Load/Store requires a variable, field, or array."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeLoadStoreVariable
specifier|private
name|void
name|writeLoadStoreVariable
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|boolean
name|store
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|,
specifier|final
name|int
name|slot
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|sort
operator|==
name|Sort
operator|.
name|VOID
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Cannot load/store void type."
argument_list|)
throw|;
block|}
if|if
condition|(
name|store
condition|)
block|{
name|execute
operator|.
name|visitVarInsn
argument_list|(
name|type
operator|.
name|type
operator|.
name|getOpcode
argument_list|(
name|Opcodes
operator|.
name|ISTORE
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|visitVarInsn
argument_list|(
name|type
operator|.
name|type
operator|.
name|getOpcode
argument_list|(
name|Opcodes
operator|.
name|ILOAD
argument_list|)
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeLoadStoreField
specifier|private
name|void
name|writeLoadStoreField
parameter_list|(
specifier|final
name|boolean
name|store
parameter_list|,
specifier|final
name|Field
name|field
parameter_list|)
block|{
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|field
operator|.
name|reflect
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|store
condition|)
block|{
name|execute
operator|.
name|putStatic
argument_list|(
name|field
operator|.
name|owner
operator|.
name|type
argument_list|,
name|field
operator|.
name|reflect
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|getStatic
argument_list|(
name|field
operator|.
name|owner
operator|.
name|type
argument_list|,
name|field
operator|.
name|reflect
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|generic
operator|.
name|clazz
operator|.
name|equals
argument_list|(
name|field
operator|.
name|type
operator|.
name|clazz
argument_list|)
condition|)
block|{
name|execute
operator|.
name|checkCast
argument_list|(
name|field
operator|.
name|generic
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|store
condition|)
block|{
name|execute
operator|.
name|putField
argument_list|(
name|field
operator|.
name|owner
operator|.
name|type
argument_list|,
name|field
operator|.
name|reflect
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|getField
argument_list|(
name|field
operator|.
name|owner
operator|.
name|type
argument_list|,
name|field
operator|.
name|reflect
operator|.
name|getName
argument_list|()
argument_list|,
name|field
operator|.
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
operator|.
name|generic
operator|.
name|clazz
operator|.
name|equals
argument_list|(
name|field
operator|.
name|type
operator|.
name|clazz
argument_list|)
condition|)
block|{
name|execute
operator|.
name|checkCast
argument_list|(
name|field
operator|.
name|generic
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|writeLoadStoreField
specifier|private
name|void
name|writeLoadStoreField
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|boolean
name|store
parameter_list|,
specifier|final
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|store
condition|)
block|{
specifier|final
name|Metadata
operator|.
name|ExtNodeMetadata
name|sourceemd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|sourceemd
operator|.
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
decl_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|execute
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|execute
operator|.
name|getField
argument_list|(
name|CLASS_TYPE
argument_list|,
literal|"definition"
argument_list|,
name|DEFINITION_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|parentemd
operator|.
name|token
operator|==
literal|0
operator|&&
name|expremd
operator|.
name|typesafe
argument_list|)
expr_stmt|;
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_FIELD_STORE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|push
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|execute
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|execute
operator|.
name|getField
argument_list|(
name|CLASS_TYPE
argument_list|,
literal|"definition"
argument_list|,
name|DEFINITION_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_FIELD_LOAD
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeLoadStoreArray
specifier|private
name|void
name|writeLoadStoreArray
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|boolean
name|store
parameter_list|,
specifier|final
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|.
name|sort
operator|==
name|Sort
operator|.
name|VOID
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Cannot load/store void type."
argument_list|)
throw|;
block|}
if|if
condition|(
name|type
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
specifier|final
name|ExtbraceContext
name|bracectx
init|=
operator|(
name|ExtbraceContext
operator|)
name|source
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd0
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|bracectx
operator|.
name|expression
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|store
condition|)
block|{
specifier|final
name|Metadata
operator|.
name|ExtNodeMetadata
name|braceenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|bracectx
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|braceenmd
operator|.
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|expremd1
init|=
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|parentemd
operator|.
name|storeExpr
argument_list|)
decl_stmt|;
name|execute
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|execute
operator|.
name|getField
argument_list|(
name|CLASS_TYPE
argument_list|,
literal|"definition"
argument_list|,
name|DEFINITION_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|expremd0
operator|.
name|typesafe
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|parentemd
operator|.
name|token
operator|==
literal|0
operator|&&
name|expremd1
operator|.
name|typesafe
argument_list|)
expr_stmt|;
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_ARRAY_STORE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|execute
operator|.
name|getField
argument_list|(
name|CLASS_TYPE
argument_list|,
literal|"definition"
argument_list|,
name|DEFINITION_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|expremd0
operator|.
name|typesafe
argument_list|)
expr_stmt|;
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_ARRAY_LOAD
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|store
condition|)
block|{
name|execute
operator|.
name|arrayStore
argument_list|(
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|arrayLoad
argument_list|(
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeLoadStoreShortcut
specifier|private
name|void
name|writeLoadStoreShortcut
parameter_list|(
specifier|final
name|boolean
name|store
parameter_list|,
specifier|final
name|Method
name|getter
parameter_list|,
specifier|final
name|Method
name|setter
parameter_list|)
block|{
specifier|final
name|Method
name|method
init|=
name|store
condition|?
name|setter
else|:
name|getter
decl_stmt|;
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isInterface
argument_list|(
name|getter
operator|.
name|owner
operator|.
name|clazz
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|execute
operator|.
name|invokeInterface
argument_list|(
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|store
condition|)
block|{
name|writePop
argument_list|(
name|method
operator|.
name|rtn
operator|.
name|type
operator|.
name|getSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|method
operator|.
name|rtn
operator|.
name|clazz
operator|.
name|equals
argument_list|(
name|method
operator|.
name|handle
operator|.
name|type
argument_list|()
operator|.
name|returnType
argument_list|()
argument_list|)
condition|)
block|{
name|execute
operator|.
name|checkCast
argument_list|(
name|method
operator|.
name|rtn
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeDup
specifier|private
name|void
name|writeDup
parameter_list|(
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|boolean
name|x1
parameter_list|,
specifier|final
name|boolean
name|x2
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|x2
condition|)
block|{
name|execute
operator|.
name|dupX2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
condition|)
block|{
name|execute
operator|.
name|dupX1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|x2
condition|)
block|{
name|execute
operator|.
name|dup2X2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x1
condition|)
block|{
name|execute
operator|.
name|dup2X1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|dup2
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeNewExternal
specifier|private
name|void
name|writeNewExternal
parameter_list|(
specifier|final
name|ExtnewContext
name|source
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExtNodeMetadata
name|sourceenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|Metadata
operator|.
name|ExternalMetadata
name|parentemd
init|=
name|metadata
operator|.
name|getExternalMetadata
argument_list|(
name|sourceenmd
operator|.
name|parent
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|makearray
init|=
literal|"#makearray"
operator|.
name|equals
argument_list|(
name|sourceenmd
operator|.
name|target
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|constructor
init|=
name|sourceenmd
operator|.
name|target
operator|instanceof
name|Constructor
decl_stmt|;
if|if
condition|(
operator|!
name|makearray
operator|&&
operator|!
name|constructor
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Target not found for new call."
argument_list|)
throw|;
block|}
if|if
condition|(
name|makearray
condition|)
block|{
for|for
control|(
specifier|final
name|ExpressionContext
name|exprctx
range|:
name|source
operator|.
name|expression
argument_list|()
control|)
block|{
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sourceenmd
operator|.
name|type
operator|.
name|sort
operator|==
name|Sort
operator|.
name|ARRAY
condition|)
block|{
name|execute
operator|.
name|visitMultiANewArrayInsn
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|type
operator|.
name|getDescriptor
argument_list|()
argument_list|,
name|sourceenmd
operator|.
name|type
operator|.
name|type
operator|.
name|getDimensions
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|newArray
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|execute
operator|.
name|newInstance
argument_list|(
name|sourceenmd
operator|.
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|parentemd
operator|.
name|read
condition|)
block|{
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
block|}
for|for
control|(
specifier|final
name|ExpressionContext
name|exprctx
range|:
name|source
operator|.
name|arguments
argument_list|()
operator|.
name|expression
argument_list|()
control|)
block|{
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Constructor
name|target
init|=
operator|(
name|Constructor
operator|)
name|sourceenmd
operator|.
name|target
decl_stmt|;
name|execute
operator|.
name|invokeConstructor
argument_list|(
name|target
operator|.
name|owner
operator|.
name|type
argument_list|,
name|target
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeCallExternal
specifier|private
name|void
name|writeCallExternal
parameter_list|(
specifier|final
name|ExtcallContext
name|source
parameter_list|)
block|{
specifier|final
name|Metadata
operator|.
name|ExtNodeMetadata
name|sourceenmd
init|=
name|metadata
operator|.
name|getExtNodeMetadata
argument_list|(
name|source
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|method
init|=
name|sourceenmd
operator|.
name|target
operator|instanceof
name|Method
decl_stmt|;
specifier|final
name|boolean
name|def
init|=
name|sourceenmd
operator|.
name|target
operator|instanceof
name|String
decl_stmt|;
if|if
condition|(
operator|!
name|method
operator|&&
operator|!
name|def
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Target not found for call."
argument_list|)
throw|;
block|}
specifier|final
name|List
argument_list|<
name|ExpressionContext
argument_list|>
name|arguments
init|=
name|source
operator|.
name|arguments
argument_list|()
operator|.
name|expression
argument_list|()
decl_stmt|;
if|if
condition|(
name|method
condition|)
block|{
for|for
control|(
specifier|final
name|ExpressionContext
name|exprctx
range|:
name|arguments
control|)
block|{
name|visit
argument_list|(
name|exprctx
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Method
name|target
init|=
operator|(
name|Method
operator|)
name|sourceenmd
operator|.
name|target
decl_stmt|;
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|target
operator|.
name|reflect
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|target
operator|.
name|owner
operator|.
name|type
argument_list|,
name|target
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isInterface
argument_list|(
name|target
operator|.
name|owner
operator|.
name|clazz
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|execute
operator|.
name|invokeInterface
argument_list|(
name|target
operator|.
name|owner
operator|.
name|type
argument_list|,
name|target
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|target
operator|.
name|owner
operator|.
name|type
argument_list|,
name|target
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
operator|.
name|rtn
operator|.
name|clazz
operator|.
name|equals
argument_list|(
name|target
operator|.
name|handle
operator|.
name|type
argument_list|()
operator|.
name|returnType
argument_list|()
argument_list|)
condition|)
block|{
name|execute
operator|.
name|checkCast
argument_list|(
name|target
operator|.
name|rtn
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|execute
operator|.
name|push
argument_list|(
operator|(
name|String
operator|)
name|sourceenmd
operator|.
name|target
argument_list|)
expr_stmt|;
name|execute
operator|.
name|loadThis
argument_list|()
expr_stmt|;
name|execute
operator|.
name|getField
argument_list|(
name|CLASS_TYPE
argument_list|,
literal|"definition"
argument_list|,
name|DEFINITION_TYPE
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|arguments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|execute
operator|.
name|newArray
argument_list|(
name|definition
operator|.
name|defType
operator|.
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|argument
init|=
literal|0
init|;
name|argument
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|argument
control|)
block|{
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|argument
argument_list|)
expr_stmt|;
name|visit
argument_list|(
name|arguments
operator|.
name|get
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
name|execute
operator|.
name|arrayStore
argument_list|(
name|definition
operator|.
name|defType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|push
argument_list|(
name|arguments
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|execute
operator|.
name|newArray
argument_list|(
name|definition
operator|.
name|booleanType
operator|.
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|argument
init|=
literal|0
init|;
name|argument
operator|<
name|arguments
operator|.
name|size
argument_list|()
condition|;
operator|++
name|argument
control|)
block|{
name|execute
operator|.
name|dup
argument_list|()
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|argument
argument_list|)
expr_stmt|;
name|execute
operator|.
name|push
argument_list|(
name|metadata
operator|.
name|getExpressionMetadata
argument_list|(
name|arguments
operator|.
name|get
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|.
name|typesafe
argument_list|)
expr_stmt|;
name|execute
operator|.
name|arrayStore
argument_list|(
name|definition
operator|.
name|booleanType
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|execute
operator|.
name|invokeStatic
argument_list|(
name|definition
operator|.
name|defobjType
operator|.
name|type
argument_list|,
name|DEF_METHOD_CALL
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writePop
specifier|private
name|void
name|writePop
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|execute
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|execute
operator|.
name|pop2
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|checkWriteCast
specifier|private
name|void
name|checkWriteCast
parameter_list|(
specifier|final
name|Metadata
operator|.
name|ExpressionMetadata
name|sort
parameter_list|)
block|{
name|checkWriteCast
argument_list|(
name|sort
operator|.
name|source
argument_list|,
name|sort
operator|.
name|cast
argument_list|)
expr_stmt|;
block|}
DECL|method|checkWriteCast
specifier|private
name|void
name|checkWriteCast
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|,
specifier|final
name|Cast
name|cast
parameter_list|)
block|{
if|if
condition|(
name|cast
operator|instanceof
name|Transform
condition|)
block|{
name|writeTransform
argument_list|(
operator|(
name|Transform
operator|)
name|cast
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cast
operator|!=
literal|null
condition|)
block|{
name|writeCast
argument_list|(
name|cast
argument_list|)
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|Metadata
operator|.
name|error
argument_list|(
name|source
argument_list|)
operator|+
literal|"Unexpected cast object."
argument_list|)
throw|;
block|}
block|}
DECL|method|writeCast
specifier|private
name|void
name|writeCast
parameter_list|(
specifier|final
name|Cast
name|cast
parameter_list|)
block|{
specifier|final
name|Type
name|from
init|=
name|cast
operator|.
name|from
decl_stmt|;
specifier|final
name|Type
name|to
init|=
name|cast
operator|.
name|to
decl_stmt|;
if|if
condition|(
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|from
operator|.
name|sort
operator|.
name|numeric
operator|&&
name|from
operator|.
name|sort
operator|.
name|primitive
operator|&&
name|to
operator|.
name|sort
operator|.
name|numeric
operator|&&
name|to
operator|.
name|sort
operator|.
name|primitive
condition|)
block|{
name|execute
operator|.
name|cast
argument_list|(
name|from
operator|.
name|type
argument_list|,
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|from
operator|.
name|clazz
operator|.
name|asSubclass
argument_list|(
name|to
operator|.
name|clazz
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|ClassCastException
name|exception
parameter_list|)
block|{
name|execute
operator|.
name|checkCast
argument_list|(
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeTransform
specifier|private
name|void
name|writeTransform
parameter_list|(
specifier|final
name|Transform
name|transform
parameter_list|)
block|{
if|if
condition|(
name|transform
operator|.
name|upcast
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|checkCast
argument_list|(
name|transform
operator|.
name|upcast
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isStatic
argument_list|(
name|transform
operator|.
name|method
operator|.
name|reflect
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|execute
operator|.
name|invokeStatic
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|transform
operator|.
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Modifier
operator|.
name|isInterface
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|clazz
operator|.
name|getModifiers
argument_list|()
argument_list|)
condition|)
block|{
name|execute
operator|.
name|invokeInterface
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|transform
operator|.
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute
operator|.
name|invokeVirtual
argument_list|(
name|transform
operator|.
name|method
operator|.
name|owner
operator|.
name|type
argument_list|,
name|transform
operator|.
name|method
operator|.
name|method
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|transform
operator|.
name|downcast
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|checkCast
argument_list|(
name|transform
operator|.
name|downcast
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|checkWriteBranch
name|void
name|checkWriteBranch
parameter_list|(
specifier|final
name|ParserRuleContext
name|source
parameter_list|)
block|{
specifier|final
name|Branch
name|branch
init|=
name|getBranch
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|branch
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|branch
operator|.
name|tru
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFNE
argument_list|,
name|branch
operator|.
name|tru
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|branch
operator|.
name|fals
operator|!=
literal|null
condition|)
block|{
name|execute
operator|.
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFEQ
argument_list|,
name|branch
operator|.
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeEnd
specifier|private
name|void
name|writeEnd
parameter_list|()
block|{
name|writer
operator|.
name|visitEnd
argument_list|()
expr_stmt|;
block|}
DECL|method|getBytes
specifier|private
name|byte
index|[]
name|getBytes
parameter_list|()
block|{
return|return
name|writer
operator|.
name|toByteArray
argument_list|()
return|;
block|}
block|}
end_class

end_unit

