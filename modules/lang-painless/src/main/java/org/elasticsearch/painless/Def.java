begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|RuntimeClass
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|CallSite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|LambdaConversionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|LambdaMetafactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
operator|.
name|Lookup
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_comment
comment|/**  * Support for dynamic type (def).  *<p>  * Dynamic types can invoke methods, load/store fields, and be passed as parameters to operators without  * compile-time type information.  *<p>  * Dynamic methods, loads, stores, and array/list/map load/stores involve locating the appropriate field  * or method depending on the receiver's class. For these, we emit an {@code invokedynamic} instruction that,  * for each new type encountered will query a corresponding {@code lookupXXX} method to retrieve the appropriate  * method. In most cases, the {@code lookupXXX} methods here will only be called once for a given call site, because  * caching ({@link DefBootstrap}) generally works: usually all objects at any call site will be consistently  * the same type (or just a few types).  In extreme cases, if there is type explosion, they may be called every  * single time, but simplicity is still more valuable than performance in this code.  */
end_comment

begin_class
DECL|class|Def
specifier|public
specifier|final
class|class
name|Def
block|{
comment|// TODO: Once Java has a factory for those in java.lang.invoke.MethodHandles, use it:
comment|/** Helper class for isolating MethodHandles and methods to get the length of arrays      * (to emulate a "arraystore" bytecode using MethodHandles).      * See: https://bugs.openjdk.java.net/browse/JDK-8156915      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
comment|// getArrayLength() methods are are actually used, javac just does not know :)
DECL|class|ArrayLengthHelper
specifier|private
specifier|static
specifier|final
class|class
name|ArrayLengthHelper
block|{
DECL|field|PRIV_LOOKUP
specifier|private
specifier|static
specifier|final
name|Lookup
name|PRIV_LOOKUP
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
decl_stmt|;
DECL|field|ARRAY_TYPE_MH_MAPPING
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|MethodHandle
argument_list|>
name|ARRAY_TYPE_MH_MAPPING
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
name|boolean
index|[]
operator|.
expr|class
argument_list|,
name|byte
index|[]
operator|.
expr|class
argument_list|,
name|short
index|[]
operator|.
expr|class
argument_list|,
name|int
index|[]
operator|.
expr|class
argument_list|,
name|long
index|[]
operator|.
expr|class
argument_list|,
name|char
index|[]
operator|.
expr|class
argument_list|,
name|float
index|[]
operator|.
expr|class
argument_list|,
name|double
index|[]
operator|.
expr|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|type
lambda|->
block|{
try|try
block|{
return|return
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|PRIV_LOOKUP
operator|.
name|lookupClass
argument_list|()
argument_list|,
literal|"getArrayLength"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|int
operator|.
name|class
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|OBJECT_ARRAY_MH
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|OBJECT_ARRAY_MH
init|=
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|boolean
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|short
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|int
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|long
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|char
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|float
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|double
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|Object
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|arrayLengthGetter
specifier|static
name|MethodHandle
name|arrayLengthGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arrayType
operator|.
name|isArray
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"type must be an array"
argument_list|)
throw|;
block|}
return|return
operator|(
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|containsKey
argument_list|(
name|arrayType
argument_list|)
operator|)
condition|?
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|arrayType
argument_list|)
else|:
name|OBJECT_ARRAY_MH
operator|.
name|asType
argument_list|(
name|OBJECT_ARRAY_MH
operator|.
name|type
argument_list|()
operator|.
name|changeParameterType
argument_list|(
literal|0
argument_list|,
name|arrayType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ArrayLengthHelper
specifier|private
name|ArrayLengthHelper
parameter_list|()
block|{}
block|}
comment|/** pointer to Map.get(Object) */
DECL|field|MAP_GET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|MAP_GET
decl_stmt|;
comment|/** pointer to Map.put(Object,Object) */
DECL|field|MAP_PUT
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|MAP_PUT
decl_stmt|;
comment|/** pointer to List.get(int) */
DECL|field|LIST_GET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|LIST_GET
decl_stmt|;
comment|/** pointer to List.set(int,Object) */
DECL|field|LIST_SET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|LIST_SET
decl_stmt|;
comment|/** pointer to Iterable.iterator() */
DECL|field|ITERATOR
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|ITERATOR
decl_stmt|;
comment|/** factory for arraylength MethodHandle (intrinsic) from Java 9 */
DECL|field|JAVA9_ARRAY_LENGTH_MH_FACTORY
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
decl_stmt|;
static|static
block|{
specifier|final
name|Lookup
name|lookup
init|=
name|MethodHandles
operator|.
name|publicLookup
argument_list|()
decl_stmt|;
try|try
block|{
name|MAP_GET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Map
operator|.
name|class
argument_list|,
literal|"get"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|MAP_PUT
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Map
operator|.
name|class
argument_list|,
literal|"put"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_GET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|List
operator|.
name|class
argument_list|,
literal|"get"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_SET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|List
operator|.
name|class
argument_list|,
literal|"set"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|ITERATOR
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Iterable
operator|.
name|class
argument_list|,
literal|"iterator"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Iterator
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReflectiveOperationException
name|roe
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|roe
argument_list|)
throw|;
block|}
comment|// lookup up the factory for arraylength MethodHandle (intrinsic) from Java 9:
comment|// https://bugs.openjdk.java.net/browse/JDK-8156915
name|MethodHandle
name|arrayLengthMHFactory
decl_stmt|;
try|try
block|{
name|arrayLengthMHFactory
operator|=
name|lookup
operator|.
name|findStatic
argument_list|(
name|MethodHandles
operator|.
name|class
argument_list|,
literal|"arrayLength"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|MethodHandle
operator|.
name|class
argument_list|,
name|Class
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReflectiveOperationException
name|roe
parameter_list|)
block|{
name|arrayLengthMHFactory
operator|=
literal|null
expr_stmt|;
block|}
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
operator|=
name|arrayLengthMHFactory
expr_stmt|;
block|}
comment|/** Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}: */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|rethrow
specifier|private
specifier|static
parameter_list|<
name|T
extends|extends
name|Throwable
parameter_list|>
name|void
name|rethrow
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|T
block|{
throw|throw
operator|(
name|T
operator|)
name|t
throw|;
block|}
comment|/** Returns an array length getter MethodHandle for the given array type */
DECL|method|arrayLengthGetter
specifier|static
name|MethodHandle
name|arrayLengthGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
if|if
condition|(
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
operator|!=
literal|null
condition|)
block|{
try|try
block|{
return|return
operator|(
name|MethodHandle
operator|)
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
operator|.
name|invokeExact
argument_list|(
name|arrayType
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|rethrow
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|ArrayLengthHelper
operator|.
name|arrayLengthGetter
argument_list|(
name|arrayType
argument_list|)
return|;
block|}
block|}
comment|/**      * Looks up method entry for a dynamic method call.      *<p>      * A dynamic method call for variable {@code x} of type {@code def} looks like:      * {@code x.method(args...)}      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted method. If one is not found, it throws an exception.      * Otherwise it returns the matching method.      *<p>      * @param receiverClass Class of the object to invoke the method on.      * @param name Name of the method.      * @param arity arity of method      * @return matching method to invoke. never returns null.      * @throws IllegalArgumentException if no matching whitelisted method was found.      */
DECL|method|lookupMethodInternal
specifier|static
name|Method
name|lookupMethodInternal
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|,
name|int
name|arity
parameter_list|)
block|{
name|Definition
operator|.
name|MethodKey
name|key
init|=
operator|new
name|Definition
operator|.
name|MethodKey
argument_list|(
name|name
argument_list|,
name|arity
argument_list|)
decl_stmt|;
comment|// check whitelist for matching method
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|Method
name|method
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|!=
literal|null
condition|)
block|{
return|return
name|method
return|;
block|}
block|}
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|Method
name|method
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|!=
literal|null
condition|)
block|{
return|return
name|method
return|;
block|}
block|}
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic method ["
operator|+
name|name
operator|+
literal|"] with ["
operator|+
name|arity
operator|+
literal|"] arguments "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Looks up handle for a dynamic method call, with lambda replacement      *<p>      * A dynamic method call for variable {@code x} of type {@code def} looks like:      * {@code x.method(args...)}      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted method. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching method.      *<p>      * @param receiverClass Class of the object to invoke the method on.      * @param name Name of the method.      * @param args args passed to callsite      * @param recipe bitset marking functional parameters      * @return pointer to matching method to invoke. never returns null.      * @throws LambdaConversionException if a method reference cannot be converted to an functional interface      * @throws IllegalArgumentException if no matching whitelisted method was found.      */
DECL|method|lookupMethod
specifier|static
name|MethodHandle
name|lookupMethod
parameter_list|(
name|MethodHandles
operator|.
name|Lookup
name|lookup
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|,
name|Object
name|args
index|[]
parameter_list|,
name|long
name|recipe
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
name|Method
name|method
init|=
name|lookupMethodInternal
argument_list|(
name|receiverClass
argument_list|,
name|name
argument_list|,
name|args
operator|.
name|length
operator|-
literal|1
argument_list|)
decl_stmt|;
name|MethodHandle
name|handle
init|=
name|method
operator|.
name|handle
decl_stmt|;
if|if
condition|(
name|recipe
operator|!=
literal|0
condition|)
block|{
name|MethodHandle
name|filters
index|[]
init|=
operator|new
name|MethodHandle
index|[
name|args
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|args
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|// its a functional reference, replace the argument with an impl
if|if
condition|(
operator|(
name|recipe
operator|&
operator|(
literal|1L
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|filters
index|[
name|i
index|]
operator|=
name|lookupReference
argument_list|(
name|lookup
argument_list|,
name|method
operator|.
name|arguments
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|.
name|clazz
argument_list|,
operator|(
name|String
operator|)
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|handle
operator|=
name|MethodHandles
operator|.
name|filterArguments
argument_list|(
name|handle
argument_list|,
literal|0
argument_list|,
name|filters
argument_list|)
expr_stmt|;
block|}
return|return
name|handle
return|;
block|}
comment|/** Returns a method handle to an implementation of clazz, given method reference signature        * @throws LambdaConversionException if a method reference cannot be converted to an functional interface       */
DECL|method|lookupReference
specifier|private
specifier|static
name|MethodHandle
name|lookupReference
parameter_list|(
name|MethodHandles
operator|.
name|Lookup
name|lookup
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
parameter_list|,
name|String
name|signature
parameter_list|)
throws|throws
name|LambdaConversionException
block|{
name|int
name|separator
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|FunctionRef
name|ref
init|=
operator|new
name|FunctionRef
argument_list|(
name|clazz
argument_list|,
name|signature
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|separator
argument_list|)
argument_list|,
name|signature
operator|.
name|substring
argument_list|(
name|separator
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|CallSite
name|callSite
decl_stmt|;
comment|// XXX: clean all this up to use handles in FunctionRef, deal with ASM in EFunctionRef differently
name|MethodType
name|invokedType
init|=
name|MethodType
operator|.
name|fromMethodDescriptorString
argument_list|(
name|ref
operator|.
name|invokedType
operator|.
name|getDescriptor
argument_list|()
argument_list|,
name|Def
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
decl_stmt|;
name|MethodType
name|samMethodType
init|=
name|MethodType
operator|.
name|fromMethodDescriptorString
argument_list|(
name|ref
operator|.
name|samMethodType
operator|.
name|getDescriptor
argument_list|()
argument_list|,
name|Def
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
decl_stmt|;
name|MethodType
name|interfaceType
init|=
name|MethodType
operator|.
name|fromMethodDescriptorString
argument_list|(
name|ref
operator|.
name|interfaceType
operator|.
name|getDescriptor
argument_list|()
argument_list|,
name|Def
operator|.
name|class
operator|.
name|getClassLoader
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|interfaceType
operator|.
name|equals
argument_list|(
name|ref
operator|.
name|samMethodType
argument_list|)
condition|)
block|{
name|callSite
operator|=
name|LambdaMetafactory
operator|.
name|altMetafactory
argument_list|(
name|lookup
argument_list|,
name|ref
operator|.
name|invokedName
argument_list|,
name|invokedType
argument_list|,
name|samMethodType
argument_list|,
name|ref
operator|.
name|implMethodHandle
argument_list|,
name|samMethodType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callSite
operator|=
name|LambdaMetafactory
operator|.
name|altMetafactory
argument_list|(
name|lookup
argument_list|,
name|ref
operator|.
name|invokedName
argument_list|,
name|invokedType
argument_list|,
name|samMethodType
argument_list|,
name|ref
operator|.
name|implMethodHandle
argument_list|,
name|samMethodType
argument_list|,
name|LambdaMetafactory
operator|.
name|FLAG_BRIDGES
argument_list|,
literal|1
argument_list|,
name|interfaceType
argument_list|)
expr_stmt|;
block|}
comment|// we could actually invoke and cache here (in non-capturing cases), but this is not a speedup.
name|MethodHandle
name|factory
init|=
name|callSite
operator|.
name|dynamicInvoker
argument_list|()
operator|.
name|asType
argument_list|(
name|MethodType
operator|.
name|methodType
argument_list|(
name|clazz
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|dropArguments
argument_list|(
name|factory
argument_list|,
literal|0
argument_list|,
name|Object
operator|.
name|class
argument_list|)
return|;
block|}
comment|/**      * Looks up handle for a dynamic field getter (field load)      *<p>      * A dynamic field load for variable {@code x} of type {@code def} looks like:      * {@code y = x.field}      *<p>      * The following field loads are allowed:      *<ul>      *<li>Whitelisted {@code field} from receiver's class or any superclasses.      *<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces.      *<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces.      *<li>The {@code length} field of an array.      *<li>The value corresponding to a map key named {@code field} when the receiver is a Map.      *<li>The value in a list at element {@code field} (integer) when the receiver is a List.      *</ul>      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted getter. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching getter.      *<p>      * @param receiverClass Class of the object to retrieve the field from.      * @param name Name of the field.      * @return pointer to matching field. never returns null.      * @throws IllegalArgumentException if no matching whitelisted field was found.      */
DECL|method|lookupGetter
specifier|static
name|MethodHandle
name|lookupGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|)
block|{
comment|// first try whitelist
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|getters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|getters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
block|}
block|}
comment|// special case: arrays, maps, and lists
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
operator|&&
literal|"length"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// arrays expose .length as a read-only getter
return|return
name|arrayLengthGetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap.key
comment|// wire 'key' as a parameter, its a constant in painless
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|MAP_GET
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// lists allow access like mylist.0
comment|// wire '0' (index) as a parameter, its a constant. this also avoids
comment|// parsing the same integer millions of times!
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|LIST_GET
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal list shortcut value ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic field ["
operator|+
name|name
operator|+
literal|"] "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Looks up handle for a dynamic field setter (field store)      *<p>      * A dynamic field store for variable {@code x} of type {@code def} looks like:      * {@code x.field = y}      *<p>      * The following field stores are allowed:      *<ul>      *<li>Whitelisted {@code field} from receiver's class or any superclasses.      *<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces.      *<li>The value corresponding to a map key named {@code field} when the receiver is a Map.      *<li>The value in a list at element {@code field} (integer) when the receiver is a List.      *</ul>      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted setter. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching setter.      *<p>      * @param receiverClass Class of the object to retrieve the field from.      * @param name Name of the field.      * @return pointer to matching field. never returns null.      * @throws IllegalArgumentException if no matching whitelisted field was found.      */
DECL|method|lookupSetter
specifier|static
name|MethodHandle
name|lookupSetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|)
block|{
comment|// first try whitelist
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|setters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|setters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
block|}
block|}
comment|// special case: maps, and lists
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap.key
comment|// wire 'key' as a parameter, its a constant in painless
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|MAP_PUT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// lists allow access like mylist.0
comment|// wire '0' (index) as a parameter, its a constant. this also avoids
comment|// parsing the same integer millions of times!
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|LIST_SET
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NumberFormatException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal list shortcut value ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic field ["
operator|+
name|name
operator|+
literal|"] "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Returns a method handle to do an array store.      * @param receiverClass Class of the array to store the value in      * @return a MethodHandle that accepts the receiver as first argument, the index as second argument,      *   and the value to set as 3rd argument. Return value is undefined and should be ignored.      */
DECL|method|lookupArrayStore
specifier|static
name|MethodHandle
name|lookupArrayStore
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|MethodHandles
operator|.
name|arrayElementSetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap[key]
return|return
name|MAP_PUT
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|LIST_SET
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempting to address a non-array type "
operator|+
literal|"["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] as an array."
argument_list|)
throw|;
block|}
comment|/**      * Returns a method handle to do an array load.      * @param receiverClass Class of the array to load the value from      * @return a MethodHandle that accepts the receiver as first argument, the index as second argument.      *   It returns the loaded value.      */
DECL|method|lookupArrayLoad
specifier|static
name|MethodHandle
name|lookupArrayLoad
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|MethodHandles
operator|.
name|arrayElementGetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap[key]
return|return
name|MAP_GET
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|LIST_GET
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempting to address a non-array type "
operator|+
literal|"["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] as an array."
argument_list|)
throw|;
block|}
comment|/** Helper class for isolating MethodHandles and methods to get iterators over arrays      * (to emulate "enhanced for loop" using MethodHandles). These cause boxing, and are not as efficient      * as they could be, but works.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
comment|// iterator() methods are are actually used, javac just does not know :)
DECL|class|ArrayIteratorHelper
specifier|private
specifier|static
specifier|final
class|class
name|ArrayIteratorHelper
block|{
DECL|field|PRIV_LOOKUP
specifier|private
specifier|static
specifier|final
name|Lookup
name|PRIV_LOOKUP
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
decl_stmt|;
DECL|field|ARRAY_TYPE_MH_MAPPING
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|MethodHandle
argument_list|>
name|ARRAY_TYPE_MH_MAPPING
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
name|boolean
index|[]
operator|.
expr|class
argument_list|,
name|byte
index|[]
operator|.
expr|class
argument_list|,
name|short
index|[]
operator|.
expr|class
argument_list|,
name|int
index|[]
operator|.
expr|class
argument_list|,
name|long
index|[]
operator|.
expr|class
argument_list|,
name|char
index|[]
operator|.
expr|class
argument_list|,
name|float
index|[]
operator|.
expr|class
argument_list|,
name|double
index|[]
operator|.
expr|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|type
lambda|->
block|{
try|try
block|{
return|return
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|PRIV_LOOKUP
operator|.
name|lookupClass
argument_list|()
argument_list|,
literal|"iterator"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Iterator
operator|.
name|class
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|OBJECT_ARRAY_MH
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|OBJECT_ARRAY_MH
init|=
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Boolean
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|boolean
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Byte
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Byte
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Byte
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Short
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|short
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Short
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Short
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|int
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Long
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|long
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Long
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Character
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|char
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Character
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Character
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Float
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|float
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Float
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Float
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Double
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|double
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Double
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Double
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|Object
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|newIterator
specifier|static
name|MethodHandle
name|newIterator
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arrayType
operator|.
name|isArray
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"type must be an array"
argument_list|)
throw|;
block|}
return|return
operator|(
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|containsKey
argument_list|(
name|arrayType
argument_list|)
operator|)
condition|?
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|arrayType
argument_list|)
else|:
name|OBJECT_ARRAY_MH
operator|.
name|asType
argument_list|(
name|OBJECT_ARRAY_MH
operator|.
name|type
argument_list|()
operator|.
name|changeParameterType
argument_list|(
literal|0
argument_list|,
name|arrayType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ArrayIteratorHelper
specifier|private
name|ArrayIteratorHelper
parameter_list|()
block|{}
block|}
comment|/**      * Returns a method handle to do iteration (for enhanced for loop)      * @param receiverClass Class of the array to load the value from      * @return a MethodHandle that accepts the receiver as first argument, returns iterator      */
DECL|method|lookupIterator
specifier|static
name|MethodHandle
name|lookupIterator
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|Iterable
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|ITERATOR
return|;
block|}
elseif|else
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|ArrayIteratorHelper
operator|.
name|newIterator
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot iterate over ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
comment|// NOTE: Below methods are not cached, instead invoked directly because they are performant.
comment|//       We also check for Long values first when possible since the type is more
comment|//       likely to be a Long than a Float.
DECL|method|not
specifier|public
specifier|static
name|Object
name|not
parameter_list|(
specifier|final
name|Object
name|unary
parameter_list|)
block|{
if|if
condition|(
name|unary
operator|instanceof
name|Double
operator|||
name|unary
operator|instanceof
name|Long
operator|||
name|unary
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|~
operator|(
operator|(
name|Number
operator|)
name|unary
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|~
operator|(
operator|(
name|Number
operator|)
name|unary
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|~
call|(
name|int
call|)
argument_list|(
name|char
argument_list|)
name|unary
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [~] operation to type "
operator|+
literal|"["
operator|+
name|unary
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|neg
specifier|public
specifier|static
name|Object
name|neg
parameter_list|(
specifier|final
name|Object
name|unary
parameter_list|)
block|{
if|if
condition|(
name|unary
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|-
operator|(
name|double
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|-
operator|(
name|float
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|-
operator|(
name|long
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|-
operator|(
operator|(
name|Number
operator|)
name|unary
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|-
operator|(
name|char
operator|)
name|unary
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to type "
operator|+
literal|"["
operator|+
name|unary
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|mul
specifier|public
specifier|static
name|Object
name|mul
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [*] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|div
specifier|public
specifier|static
name|Object
name|div
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [/] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|rem
specifier|public
specifier|static
name|Object
name|rem
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [%] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|add
specifier|public
specifier|static
name|Object
name|add
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|String
operator|||
name|right
operator|instanceof
name|String
condition|)
block|{
return|return
literal|""
operator|+
name|left
operator|+
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [+] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|sub
specifier|public
specifier|static
name|Object
name|sub
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|lsh
specifier|public
specifier|static
name|Object
name|lsh
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|int
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<<
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<<
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<<
name|right
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<<] operation to types ["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and [int]."
argument_list|)
throw|;
block|}
DECL|method|rsh
specifier|public
specifier|static
name|Object
name|rsh
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|int
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>>
name|right
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>] operation to types ["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and [int]."
argument_list|)
throw|;
block|}
DECL|method|ush
specifier|public
specifier|static
name|Object
name|ush
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|int
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>>>
name|right
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>>] operation to types ["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and [int]."
argument_list|)
throw|;
block|}
DECL|method|and
specifier|public
specifier|static
name|Object
name|and
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|&&
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|&
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|&
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|&
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [&] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|xor
specifier|public
specifier|static
name|Object
name|xor
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|^
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|^
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|^
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|^
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [^] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|or
specifier|public
specifier|static
name|Object
name|or
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|||
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator||
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator||
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator||
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [|] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|eq
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|!=
literal|null
operator|&&
name|right
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|double
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|double
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|==
operator|(
name|double
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|==
operator|(
name|float
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|==
operator|(
name|long
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Number
operator|&&
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
operator|&&
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
return|return
name|left
operator|.
name|equals
argument_list|(
name|right
argument_list|)
return|;
block|}
return|return
name|left
operator|==
literal|null
operator|&&
name|right
operator|==
literal|null
return|;
block|}
DECL|method|lt
specifier|public
specifier|static
name|boolean
name|lt
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|lte
specifier|public
specifier|static
name|boolean
name|lte
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<=] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|gt
specifier|public
specifier|static
name|boolean
name|gt
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|gte
specifier|public
specifier|static
name|boolean
name|gte
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// Conversion methods for Def to primitive types.
DECL|method|DefToboolean
specifier|public
specifier|static
name|boolean
name|DefToboolean
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
return|return
operator|(
name|boolean
operator|)
name|value
return|;
block|}
DECL|method|DefTobyteImplicit
specifier|public
specifier|static
name|byte
name|DefTobyteImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|DefToshortImplicit
specifier|public
specifier|static
name|short
name|DefToshortImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTocharImplicit
specifier|public
specifier|static
name|char
name|DefTocharImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|byte
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTointImplicit
specifier|public
specifier|static
name|int
name|DefTointImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTolongImplicit
specifier|public
specifier|static
name|long
name|DefTolongImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTofloatImplicit
specifier|public
specifier|static
name|float
name|DefTofloatImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTodoubleImplicit
specifier|public
specifier|static
name|double
name|DefTodoubleImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTobyteExplicit
specifier|public
specifier|static
name|byte
name|DefTobyteExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToshortExplicit
specifier|public
specifier|static
name|short
name|DefToshortExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTocharExplicit
specifier|public
specifier|static
name|char
name|DefTocharExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|Character
operator|)
name|value
operator|)
return|;
block|}
else|else
block|{
return|return
call|(
name|char
call|)
argument_list|(
operator|(
name|Number
operator|)
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTointExplicit
specifier|public
specifier|static
name|int
name|DefTointExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTolongExplicit
specifier|public
specifier|static
name|long
name|DefTolongExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTofloatExplicit
specifier|public
specifier|static
name|float
name|DefTofloatExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTodoubleExplicit
specifier|public
specifier|static
name|double
name|DefTodoubleExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

