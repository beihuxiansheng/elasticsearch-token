begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|RuntimeClass
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
operator|.
name|Lookup
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_comment
comment|/**  * Support for dynamic type (def).  *<p>  * Dynamic types can invoke methods, load/store fields, and be passed as parameters to operators without  * compile-time type information.  *<p>  * Dynamic methods, loads, stores, and array/list/map load/stores involve locating the appropriate field  * or method depending on the receiver's class. For these, we emit an {@code invokedynamic} instruction that,  * for each new type encountered will query a corresponding {@code lookupXXX} method to retrieve the appropriate  * method. In most cases, the {@code lookupXXX} methods here will only be called once for a given call site, because  * caching ({@link DefBootstrap}) generally works: usually all objects at any call site will be consistently  * the same type (or just a few types).  In extreme cases, if there is type explosion, they may be called every  * single time, but simplicity is still more valuable than performance in this code.  */
end_comment

begin_class
DECL|class|Def
specifier|public
specifier|final
class|class
name|Def
block|{
comment|// TODO: Once Java has a factory for those in java.lang.invoke.MethodHandles, use it:
comment|/** Helper class for isolating MethodHandles and methods to get the length of arrays      * (to emulate a "arraystore" byteoode using MethodHandles).      * This should really be a method in {@link MethodHandles} class!      */
DECL|class|ArrayLengthHelper
specifier|private
specifier|static
specifier|final
class|class
name|ArrayLengthHelper
block|{
DECL|field|PRIV_LOOKUP
specifier|private
specifier|static
specifier|final
name|Lookup
name|PRIV_LOOKUP
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
decl_stmt|;
DECL|field|ARRAY_TYPE_MH_MAPPING
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|MethodHandle
argument_list|>
name|ARRAY_TYPE_MH_MAPPING
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
name|boolean
index|[]
operator|.
expr|class
argument_list|,
name|byte
index|[]
operator|.
expr|class
argument_list|,
name|short
index|[]
operator|.
expr|class
argument_list|,
name|int
index|[]
operator|.
expr|class
argument_list|,
name|long
index|[]
operator|.
expr|class
argument_list|,
name|char
index|[]
operator|.
expr|class
argument_list|,
name|float
index|[]
operator|.
expr|class
argument_list|,
name|double
index|[]
operator|.
expr|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|type
lambda|->
block|{
try|try
block|{
return|return
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|PRIV_LOOKUP
operator|.
name|lookupClass
argument_list|()
argument_list|,
literal|"getArrayLength"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|int
operator|.
name|class
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|OBJECT_ARRAY_MH
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|OBJECT_ARRAY_MH
init|=
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|boolean
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|short
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|int
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|long
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|char
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|float
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|double
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|Object
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|arrayLengthGetter
specifier|static
name|MethodHandle
name|arrayLengthGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arrayType
operator|.
name|isArray
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"type must be an array"
argument_list|)
throw|;
block|}
return|return
operator|(
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|containsKey
argument_list|(
name|arrayType
argument_list|)
operator|)
condition|?
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|arrayType
argument_list|)
else|:
name|OBJECT_ARRAY_MH
operator|.
name|asType
argument_list|(
name|OBJECT_ARRAY_MH
operator|.
name|type
argument_list|()
operator|.
name|changeParameterType
argument_list|(
literal|0
argument_list|,
name|arrayType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ArrayLengthHelper
specifier|private
name|ArrayLengthHelper
parameter_list|()
block|{}
block|}
comment|/** pointer to Map.get(Object) */
DECL|field|MAP_GET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|MAP_GET
decl_stmt|;
comment|/** pointer to Map.put(Object,Object) */
DECL|field|MAP_PUT
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|MAP_PUT
decl_stmt|;
comment|/** pointer to List.get(int) */
DECL|field|LIST_GET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|LIST_GET
decl_stmt|;
comment|/** pointer to List.set(int,Object) */
DECL|field|LIST_SET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|LIST_SET
decl_stmt|;
static|static
block|{
specifier|final
name|Lookup
name|lookup
init|=
name|MethodHandles
operator|.
name|publicLookup
argument_list|()
decl_stmt|;
try|try
block|{
name|MAP_GET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Map
operator|.
name|class
argument_list|,
literal|"get"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|MAP_PUT
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Map
operator|.
name|class
argument_list|,
literal|"put"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_GET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|List
operator|.
name|class
argument_list|,
literal|"get"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_SET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|List
operator|.
name|class
argument_list|,
literal|"set"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReflectiveOperationException
name|roe
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|roe
argument_list|)
throw|;
block|}
block|}
comment|/** Returns an array length getter MethodHandle for the given array type */
DECL|method|arrayLengthGetter
specifier|static
name|MethodHandle
name|arrayLengthGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
return|return
name|ArrayLengthHelper
operator|.
name|arrayLengthGetter
argument_list|(
name|arrayType
argument_list|)
return|;
block|}
comment|/**      * Looks up handle for a dynamic method call.      *<p>      * A dynamic method call for variable {@code x} of type {@code def} looks like:      * {@code x.method(args...)}      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted method. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching method.      *<p>      * @param receiverClass Class of the object to invoke the method on.      * @param name Name of the method.      * @param definition Whitelist to check.      * @return pointer to matching method to invoke. never returns null.      * @throws IllegalArgumentException if no matching whitelisted method was found.      */
DECL|method|lookupMethod
specifier|static
name|MethodHandle
name|lookupMethod
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|,
name|Definition
name|definition
parameter_list|)
block|{
comment|// check whitelist for matching method
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|definition
operator|.
name|runtimeMap
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|Method
name|method
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|!=
literal|null
condition|)
block|{
return|return
name|method
operator|.
name|handle
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|definition
operator|.
name|runtimeMap
operator|.
name|get
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|Method
name|method
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|!=
literal|null
condition|)
block|{
return|return
name|method
operator|.
name|handle
return|;
block|}
block|}
block|}
block|}
comment|// no matching methods in whitelist found
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic method ["
operator|+
name|name
operator|+
literal|"] "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Looks up handle for a dynamic field getter (field load)      *<p>      * A dynamic field load for variable {@code x} of type {@code def} looks like:      * {@code y = x.field}      *<p>      * The following field loads are allowed:      *<ul>      *<li>Whitelisted {@code field} from receiver's class or any superclasses.      *<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces.      *<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces.      *<li>The {@code length} field of an array.      *<li>The value corresponding to a map key named {@code field} when the receiver is a Map.      *<li>The value in a list at element {@code field} (integer) when the receiver is a List.      *</ul>      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted getter. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching getter.      *<p>      * @param receiverClass Class of the object to retrieve the field from.      * @param name Name of the field.      * @param definition Whitelist to check.      * @return pointer to matching field. never returns null.      * @throws IllegalArgumentException if no matching whitelisted field was found.      */
DECL|method|lookupGetter
specifier|static
name|MethodHandle
name|lookupGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|,
name|Definition
name|definition
parameter_list|)
block|{
comment|// first try whitelist
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|definition
operator|.
name|runtimeMap
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|getters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|definition
operator|.
name|runtimeMap
operator|.
name|get
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|getters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
block|}
block|}
comment|// special case: arrays, maps, and lists
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
operator|&&
literal|"length"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// arrays expose .length as a read-only getter
return|return
name|arrayLengthGetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap.key
comment|// wire 'key' as a parameter, its a constant in painless
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|MAP_GET
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// lists allow access like mylist.0
comment|// wire '0' (index) as a parameter, its a constant. this also avoids
comment|// parsing the same integer millions of times!
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|LIST_GET
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal list shortcut value ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic field ["
operator|+
name|name
operator|+
literal|"] "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Looks up handle for a dynamic field setter (field store)      *<p>      * A dynamic field store for variable {@code x} of type {@code def} looks like:      * {@code x.field = y}      *<p>      * The following field stores are allowed:      *<ul>      *<li>Whitelisted {@code field} from receiver's class or any superclasses.      *<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces.      *<li>The value corresponding to a map key named {@code field} when the receiver is a Map.      *<li>The value in a list at element {@code field} (integer) when the receiver is a List.      *</ul>      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted setter. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching setter.      *<p>      * @param receiverClass Class of the object to retrieve the field from.      * @param name Name of the field.      * @param definition Whitelist to check.      * @return pointer to matching field. never returns null.      * @throws IllegalArgumentException if no matching whitelisted field was found.      */
DECL|method|lookupSetter
specifier|static
name|MethodHandle
name|lookupSetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|,
name|Definition
name|definition
parameter_list|)
block|{
comment|// first try whitelist
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|definition
operator|.
name|runtimeMap
operator|.
name|get
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|setters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|definition
operator|.
name|runtimeMap
operator|.
name|get
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|setters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
block|}
block|}
comment|// special case: maps, and lists
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap.key
comment|// wire 'key' as a parameter, its a constant in painless
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|MAP_PUT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// lists allow access like mylist.0
comment|// wire '0' (index) as a parameter, its a constant. this also avoids
comment|// parsing the same integer millions of times!
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|LIST_SET
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NumberFormatException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal list shortcut value ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic field ["
operator|+
name|name
operator|+
literal|"] "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Returns a method handle to do an array store.      * @param receiverClass Class of the array to store the value in      * @return a MethodHandle that accepts the receiver as first argument, the index as second argument,      *   and the value to set as 3rd argument. Return value is undefined and should be ignored.      */
DECL|method|lookupArrayStore
specifier|static
name|MethodHandle
name|lookupArrayStore
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|MethodHandles
operator|.
name|arrayElementSetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap[key]
return|return
name|MAP_PUT
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|LIST_SET
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempting to address a non-array type "
operator|+
literal|"["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] as an array."
argument_list|)
throw|;
block|}
comment|/**      * Returns a method handle to do an array load.      * @param receiverClass Class of the array to load the value from      * @return a MethodHandle that accepts the receiver as first argument, the index as second argument.      *   It returns the loaded value.      */
DECL|method|lookupArrayLoad
specifier|static
name|MethodHandle
name|lookupArrayLoad
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|MethodHandles
operator|.
name|arrayElementGetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap[key]
return|return
name|MAP_GET
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|LIST_GET
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempting to address a non-array type "
operator|+
literal|"["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] as an array."
argument_list|)
throw|;
block|}
comment|// NOTE: Below methods are not cached, instead invoked directly because they are performant.
comment|//       We also check for Long values first when possible since the type is more
comment|//       likely to be a Long than a Float.
DECL|method|not
specifier|public
specifier|static
name|Object
name|not
parameter_list|(
specifier|final
name|Object
name|unary
parameter_list|)
block|{
if|if
condition|(
name|unary
operator|instanceof
name|Double
operator|||
name|unary
operator|instanceof
name|Long
operator|||
name|unary
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|~
operator|(
operator|(
name|Number
operator|)
name|unary
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|~
operator|(
operator|(
name|Number
operator|)
name|unary
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|~
call|(
name|int
call|)
argument_list|(
name|char
argument_list|)
name|unary
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [~] operation to type "
operator|+
literal|"["
operator|+
name|unary
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|neg
specifier|public
specifier|static
name|Object
name|neg
parameter_list|(
specifier|final
name|Object
name|unary
parameter_list|)
block|{
if|if
condition|(
name|unary
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|-
operator|(
name|double
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|-
operator|(
name|float
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|-
operator|(
name|long
operator|)
name|unary
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|-
operator|(
operator|(
name|Number
operator|)
name|unary
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|unary
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|-
operator|(
name|char
operator|)
name|unary
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to type "
operator|+
literal|"["
operator|+
name|unary
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|mul
specifier|public
specifier|static
name|Object
name|mul
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|*
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [*] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|div
specifier|public
specifier|static
name|Object
name|div
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|/
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [/] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|rem
specifier|public
specifier|static
name|Object
name|rem
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|%
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [%] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|add
specifier|public
specifier|static
name|Object
name|add
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|String
operator|||
name|right
operator|instanceof
name|String
condition|)
block|{
return|return
literal|""
operator|+
name|left
operator|+
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|+
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [+] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|sub
specifier|public
specifier|static
name|Object
name|sub
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|-
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [-] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|lsh
specifier|public
specifier|static
name|Object
name|lsh
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|int
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<<
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<<
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<<
name|right
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<<] operation to types ["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and [int]."
argument_list|)
throw|;
block|}
DECL|method|rsh
specifier|public
specifier|static
name|Object
name|rsh
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|int
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>>
name|right
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>] operation to types ["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and [int]."
argument_list|)
throw|;
block|}
DECL|method|ush
specifier|public
specifier|static
name|Object
name|ush
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|int
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>>>
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>>>
name|right
return|;
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>>>] operation to types ["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and [int]."
argument_list|)
throw|;
block|}
DECL|method|and
specifier|public
specifier|static
name|Object
name|and
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|&&
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|&
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|&
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|&
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|&
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [&] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|xor
specifier|public
specifier|static
name|Object
name|xor
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|^
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|^
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|^
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|^
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|^
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [^] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|or
specifier|public
specifier|static
name|Object
name|or
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Boolean
operator|&&
name|right
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|left
operator|||
operator|(
name|boolean
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|left
operator|instanceof
name|Long
operator|||
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator||
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator||
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator||
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator||
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [|] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|eq
specifier|public
specifier|static
name|boolean
name|eq
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|!=
literal|null
operator|&&
name|right
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|double
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|double
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|==
operator|(
name|double
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|==
operator|(
name|float
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|==
operator|(
name|long
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Number
operator|&&
name|left
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
operator|&&
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|==
operator|(
name|char
operator|)
name|right
return|;
block|}
return|return
name|left
operator|.
name|equals
argument_list|(
name|right
argument_list|)
return|;
block|}
return|return
name|left
operator|==
literal|null
operator|&&
name|right
operator|==
literal|null
return|;
block|}
DECL|method|lt
specifier|public
specifier|static
name|boolean
name|lt
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|lte
specifier|public
specifier|static
name|boolean
name|lte
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|<=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [<=] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|gt
specifier|public
specifier|static
name|boolean
name|gt
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
DECL|method|gte
specifier|public
specifier|static
name|boolean
name|gte
parameter_list|(
specifier|final
name|Object
name|left
parameter_list|,
specifier|final
name|Object
name|right
parameter_list|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
operator|||
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
operator|||
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
operator|||
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|left
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|doubleValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|longValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|floatValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|left
operator|)
operator|.
name|intValue
argument_list|()
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|left
operator|instanceof
name|Character
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Number
condition|)
block|{
if|if
condition|(
name|right
operator|instanceof
name|Double
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
operator|(
name|Number
operator|)
name|right
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|right
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|left
operator|>=
operator|(
name|char
operator|)
name|right
return|;
block|}
block|}
throw|throw
operator|new
name|ClassCastException
argument_list|(
literal|"Cannot apply [>] operation to types "
operator|+
literal|"["
operator|+
name|left
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] and ["
operator|+
name|right
operator|.
name|getClass
argument_list|()
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|// Conversion methods for Def to primitive types.
DECL|method|DefToboolean
specifier|public
specifier|static
name|boolean
name|DefToboolean
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|)
name|value
operator|)
operator|!=
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
operator|!=
literal|0
return|;
block|}
block|}
DECL|method|DefTobyte
specifier|public
specifier|static
name|byte
name|DefTobyte
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|byte
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToshort
specifier|public
specifier|static
name|short
name|DefToshort
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|short
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTochar
specifier|public
specifier|static
name|char
name|DefTochar
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|char
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|Character
operator|)
name|value
operator|)
return|;
block|}
else|else
block|{
return|return
call|(
name|char
call|)
argument_list|(
operator|(
name|Number
operator|)
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToint
specifier|public
specifier|static
name|int
name|DefToint
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTolong
specifier|public
specifier|static
name|long
name|DefTolong
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
literal|1L
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTofloat
specifier|public
specifier|static
name|float
name|DefTofloat
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|float
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTodouble
specifier|public
specifier|static
name|double
name|DefTodouble
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|double
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToBoolean
specifier|public
specifier|static
name|Boolean
name|DefToBoolean
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
name|boolean
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|)
name|value
operator|)
operator|!=
literal|0
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
operator|!=
literal|0
return|;
block|}
block|}
DECL|method|DefToByte
specifier|public
specifier|static
name|Byte
name|DefToByte
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|byte
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToShort
specifier|public
specifier|static
name|Short
name|DefToShort
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|short
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToCharacter
specifier|public
specifier|static
name|Character
name|DefToCharacter
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|char
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|Character
operator|)
name|value
operator|)
return|;
block|}
else|else
block|{
return|return
call|(
name|char
call|)
argument_list|(
operator|(
name|Number
operator|)
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToInteger
specifier|public
specifier|static
name|Integer
name|DefToInteger
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToLong
specifier|public
specifier|static
name|Long
name|DefToLong
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
literal|1L
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|long
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToFloat
specifier|public
specifier|static
name|Float
name|DefToFloat
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|float
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|float
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToDouble
specifier|public
specifier|static
name|Double
name|DefToDouble
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Boolean
condition|)
block|{
return|return
operator|(
operator|(
name|Boolean
operator|)
name|value
operator|)
condition|?
operator|(
name|double
operator|)
literal|1
else|:
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|double
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

