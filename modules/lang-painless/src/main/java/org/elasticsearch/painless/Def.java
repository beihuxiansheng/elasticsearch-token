begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|RuntimeClass
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|CallSite
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|LambdaMetafactory
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandle
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodHandles
operator|.
name|Lookup
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|invoke
operator|.
name|MethodType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|Function
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Collectors
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|stream
operator|.
name|Stream
import|;
end_import

begin_comment
comment|/**  * Support for dynamic type (def).  *<p>  * Dynamic types can invoke methods, load/store fields, and be passed as parameters to operators without  * compile-time type information.  *<p>  * Dynamic methods, loads, stores, and array/list/map load/stores involve locating the appropriate field  * or method depending on the receiver's class. For these, we emit an {@code invokedynamic} instruction that,  * for each new type encountered will query a corresponding {@code lookupXXX} method to retrieve the appropriate  * method. In most cases, the {@code lookupXXX} methods here will only be called once for a given call site, because  * caching ({@link DefBootstrap}) generally works: usually all objects at any call site will be consistently  * the same type (or just a few types).  In extreme cases, if there is type explosion, they may be called every  * single time, but simplicity is still more valuable than performance in this code.  */
end_comment

begin_class
DECL|class|Def
specifier|public
specifier|final
class|class
name|Def
block|{
comment|// TODO: Once Java has a factory for those in java.lang.invoke.MethodHandles, use it:
comment|/** Helper class for isolating MethodHandles and methods to get the length of arrays      * (to emulate a "arraystore" bytecode using MethodHandles).      * See: https://bugs.openjdk.java.net/browse/JDK-8156915      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
comment|// getArrayLength() methods are are actually used, javac just does not know :)
DECL|class|ArrayLengthHelper
specifier|private
specifier|static
specifier|final
class|class
name|ArrayLengthHelper
block|{
DECL|field|PRIV_LOOKUP
specifier|private
specifier|static
specifier|final
name|Lookup
name|PRIV_LOOKUP
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
decl_stmt|;
DECL|field|ARRAY_TYPE_MH_MAPPING
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|MethodHandle
argument_list|>
name|ARRAY_TYPE_MH_MAPPING
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
name|boolean
index|[]
operator|.
expr|class
argument_list|,
name|byte
index|[]
operator|.
expr|class
argument_list|,
name|short
index|[]
operator|.
expr|class
argument_list|,
name|int
index|[]
operator|.
expr|class
argument_list|,
name|long
index|[]
operator|.
expr|class
argument_list|,
name|char
index|[]
operator|.
expr|class
argument_list|,
name|float
index|[]
operator|.
expr|class
argument_list|,
name|double
index|[]
operator|.
expr|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|type
lambda|->
block|{
try|try
block|{
return|return
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|PRIV_LOOKUP
operator|.
name|lookupClass
argument_list|()
argument_list|,
literal|"getArrayLength"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|int
operator|.
name|class
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|OBJECT_ARRAY_MH
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|OBJECT_ARRAY_MH
init|=
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|boolean
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|short
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|int
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|long
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|char
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|float
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|double
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|getArrayLength
specifier|static
name|int
name|getArrayLength
parameter_list|(
specifier|final
name|Object
index|[]
name|array
parameter_list|)
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
DECL|method|arrayLengthGetter
specifier|static
name|MethodHandle
name|arrayLengthGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arrayType
operator|.
name|isArray
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"type must be an array"
argument_list|)
throw|;
block|}
return|return
operator|(
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|containsKey
argument_list|(
name|arrayType
argument_list|)
operator|)
condition|?
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|arrayType
argument_list|)
else|:
name|OBJECT_ARRAY_MH
operator|.
name|asType
argument_list|(
name|OBJECT_ARRAY_MH
operator|.
name|type
argument_list|()
operator|.
name|changeParameterType
argument_list|(
literal|0
argument_list|,
name|arrayType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ArrayLengthHelper
specifier|private
name|ArrayLengthHelper
parameter_list|()
block|{}
block|}
comment|/** pointer to Map.get(Object) */
DECL|field|MAP_GET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|MAP_GET
decl_stmt|;
comment|/** pointer to Map.put(Object,Object) */
DECL|field|MAP_PUT
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|MAP_PUT
decl_stmt|;
comment|/** pointer to List.get(int) */
DECL|field|LIST_GET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|LIST_GET
decl_stmt|;
comment|/** pointer to List.set(int,Object) */
DECL|field|LIST_SET
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|LIST_SET
decl_stmt|;
comment|/** pointer to Iterable.iterator() */
DECL|field|ITERATOR
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|ITERATOR
decl_stmt|;
comment|/** factory for arraylength MethodHandle (intrinsic) from Java 9 */
DECL|field|JAVA9_ARRAY_LENGTH_MH_FACTORY
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
decl_stmt|;
static|static
block|{
specifier|final
name|Lookup
name|lookup
init|=
name|MethodHandles
operator|.
name|publicLookup
argument_list|()
decl_stmt|;
try|try
block|{
name|MAP_GET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Map
operator|.
name|class
argument_list|,
literal|"get"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|MAP_PUT
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Map
operator|.
name|class
argument_list|,
literal|"put"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_GET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|List
operator|.
name|class
argument_list|,
literal|"get"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_SET
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|List
operator|.
name|class
argument_list|,
literal|"set"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Object
operator|.
name|class
argument_list|,
name|int
operator|.
name|class
argument_list|,
name|Object
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|ITERATOR
operator|=
name|lookup
operator|.
name|findVirtual
argument_list|(
name|Iterable
operator|.
name|class
argument_list|,
literal|"iterator"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Iterator
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReflectiveOperationException
name|roe
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|roe
argument_list|)
throw|;
block|}
comment|// lookup up the factory for arraylength MethodHandle (intrinsic) from Java 9:
comment|// https://bugs.openjdk.java.net/browse/JDK-8156915
name|MethodHandle
name|arrayLengthMHFactory
decl_stmt|;
try|try
block|{
name|arrayLengthMHFactory
operator|=
name|lookup
operator|.
name|findStatic
argument_list|(
name|MethodHandles
operator|.
name|class
argument_list|,
literal|"arrayLength"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|MethodHandle
operator|.
name|class
argument_list|,
name|Class
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
specifier|final
name|ReflectiveOperationException
name|roe
parameter_list|)
block|{
name|arrayLengthMHFactory
operator|=
literal|null
expr_stmt|;
block|}
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
operator|=
name|arrayLengthMHFactory
expr_stmt|;
block|}
comment|/** Hack to rethrow unknown Exceptions from {@link MethodHandle#invokeExact}: */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|rethrow
specifier|static
parameter_list|<
name|T
extends|extends
name|Throwable
parameter_list|>
name|void
name|rethrow
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|T
block|{
throw|throw
operator|(
name|T
operator|)
name|t
throw|;
block|}
comment|/** Returns an array length getter MethodHandle for the given array type */
DECL|method|arrayLengthGetter
specifier|static
name|MethodHandle
name|arrayLengthGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
if|if
condition|(
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
operator|!=
literal|null
condition|)
block|{
try|try
block|{
return|return
operator|(
name|MethodHandle
operator|)
name|JAVA9_ARRAY_LENGTH_MH_FACTORY
operator|.
name|invokeExact
argument_list|(
name|arrayType
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|rethrow
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|AssertionError
argument_list|(
name|t
argument_list|)
throw|;
block|}
block|}
else|else
block|{
return|return
name|ArrayLengthHelper
operator|.
name|arrayLengthGetter
argument_list|(
name|arrayType
argument_list|)
return|;
block|}
block|}
comment|/**      * Looks up method entry for a dynamic method call.      *<p>      * A dynamic method call for variable {@code x} of type {@code def} looks like:      * {@code x.method(args...)}      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted method. If one is not found, it throws an exception.      * Otherwise it returns the matching method.      *<p>      * @param receiverClass Class of the object to invoke the method on.      * @param name Name of the method.      * @param arity arity of method      * @return matching method to invoke. never returns null.      * @throws IllegalArgumentException if no matching whitelisted method was found.      */
DECL|method|lookupMethodInternal
specifier|static
name|Method
name|lookupMethodInternal
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|,
name|int
name|arity
parameter_list|)
block|{
name|Definition
operator|.
name|MethodKey
name|key
init|=
operator|new
name|Definition
operator|.
name|MethodKey
argument_list|(
name|name
argument_list|,
name|arity
argument_list|)
decl_stmt|;
comment|// check whitelist for matching method
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|Method
name|method
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|!=
literal|null
condition|)
block|{
return|return
name|method
return|;
block|}
block|}
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|Method
name|method
init|=
name|struct
operator|.
name|methods
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
operator|!=
literal|null
condition|)
block|{
return|return
name|method
return|;
block|}
block|}
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic method ["
operator|+
name|name
operator|+
literal|"] with ["
operator|+
name|arity
operator|+
literal|"] arguments "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Looks up handle for a dynamic method call, with lambda replacement      *<p>      * A dynamic method call for variable {@code x} of type {@code def} looks like:      * {@code x.method(args...)}      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted method. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching method.      *<p>      * @param lookup caller's lookup      * @param callSiteType callsite's type      * @param receiverClass Class of the object to invoke the method on.      * @param name Name of the method.      * @param args bootstrap args passed to callsite      * @return pointer to matching method to invoke. never returns null.      * @throws IllegalArgumentException if no matching whitelisted method was found.      * @throws Throwable if a method reference cannot be converted to an functional interface      */
DECL|method|lookupMethod
specifier|static
name|MethodHandle
name|lookupMethod
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|MethodType
name|callSiteType
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|,
name|Object
name|args
index|[]
parameter_list|)
throws|throws
name|Throwable
block|{
name|String
name|recipeString
init|=
operator|(
name|String
operator|)
name|args
index|[
literal|0
index|]
decl_stmt|;
name|int
name|numArguments
init|=
name|callSiteType
operator|.
name|parameterCount
argument_list|()
decl_stmt|;
comment|// simple case: no lambdas
if|if
condition|(
name|recipeString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|lookupMethodInternal
argument_list|(
name|receiverClass
argument_list|,
name|name
argument_list|,
name|numArguments
operator|-
literal|1
argument_list|)
operator|.
name|handle
return|;
block|}
comment|// convert recipe string to a bitset for convenience (the code below should be refactored...)
name|BitSet
name|lambdaArgs
init|=
operator|new
name|BitSet
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|recipeString
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|lambdaArgs
operator|.
name|set
argument_list|(
name|recipeString
operator|.
name|charAt
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// otherwise: first we have to compute the "real" arity. This is because we have extra arguments:
comment|// e.g. f(a, g(x), b, h(y), i()) looks like f(a, g, x, b, h, y, i).
name|int
name|arity
init|=
name|callSiteType
operator|.
name|parameterCount
argument_list|()
operator|-
literal|1
decl_stmt|;
name|int
name|upTo
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numArguments
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lambdaArgs
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
condition|)
block|{
name|String
name|signature
init|=
operator|(
name|String
operator|)
name|args
index|[
name|upTo
operator|++
index|]
decl_stmt|;
name|int
name|numCaptures
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|signature
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|arity
operator|-=
name|numCaptures
expr_stmt|;
block|}
block|}
comment|// lookup the method with the proper arity, then we know everything (e.g. interface types of parameters).
comment|// based on these we can finally link any remaining lambdas that were deferred.
name|Method
name|method
init|=
name|lookupMethodInternal
argument_list|(
name|receiverClass
argument_list|,
name|name
argument_list|,
name|arity
argument_list|)
decl_stmt|;
name|MethodHandle
name|handle
init|=
name|method
operator|.
name|handle
decl_stmt|;
name|int
name|replaced
init|=
literal|0
decl_stmt|;
name|upTo
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|numArguments
condition|;
name|i
operator|++
control|)
block|{
comment|// its a functional reference, replace the argument with an impl
if|if
condition|(
name|lambdaArgs
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// decode signature of form 'type.call,2'
name|String
name|signature
init|=
operator|(
name|String
operator|)
name|args
index|[
name|upTo
operator|++
index|]
decl_stmt|;
name|int
name|separator
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|'.'
argument_list|)
decl_stmt|;
name|int
name|separator2
init|=
name|signature
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
decl_stmt|;
name|String
name|type
init|=
name|signature
operator|.
name|substring
argument_list|(
literal|1
argument_list|,
name|separator
argument_list|)
decl_stmt|;
name|String
name|call
init|=
name|signature
operator|.
name|substring
argument_list|(
name|separator
operator|+
literal|1
argument_list|,
name|separator2
argument_list|)
decl_stmt|;
name|int
name|numCaptures
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|signature
operator|.
name|substring
argument_list|(
name|separator2
operator|+
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|captures
index|[]
init|=
operator|new
name|Class
argument_list|<
name|?
argument_list|>
index|[
name|numCaptures
index|]
decl_stmt|;
for|for
control|(
name|int
name|capture
init|=
literal|0
init|;
name|capture
operator|<
name|captures
operator|.
name|length
condition|;
name|capture
operator|++
control|)
block|{
name|captures
index|[
name|capture
index|]
operator|=
name|callSiteType
operator|.
name|parameterType
argument_list|(
name|i
operator|+
literal|1
operator|+
name|capture
argument_list|)
expr_stmt|;
block|}
name|MethodHandle
name|filter
decl_stmt|;
name|Definition
operator|.
name|Type
name|interfaceType
init|=
name|method
operator|.
name|arguments
operator|.
name|get
argument_list|(
name|i
operator|-
literal|1
operator|-
name|replaced
argument_list|)
decl_stmt|;
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'S'
condition|)
block|{
comment|// the implementation is strongly typed, now that we know the interface type,
comment|// we have everything.
name|filter
operator|=
name|lookupReferenceInternal
argument_list|(
name|lookup
argument_list|,
name|interfaceType
argument_list|,
name|type
argument_list|,
name|call
argument_list|,
name|captures
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|signature
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'D'
condition|)
block|{
comment|// the interface type is now known, but we need to get the implementation.
comment|// this is dynamically based on the receiver type (and cached separately, underneath
comment|// this cache). It won't blow up since we never nest here (just references)
name|MethodType
name|nestedType
init|=
name|MethodType
operator|.
name|methodType
argument_list|(
name|interfaceType
operator|.
name|clazz
argument_list|,
name|captures
argument_list|)
decl_stmt|;
name|CallSite
name|nested
init|=
name|DefBootstrap
operator|.
name|bootstrap
argument_list|(
name|lookup
argument_list|,
name|call
argument_list|,
name|nestedType
argument_list|,
literal|0
argument_list|,
name|DefBootstrap
operator|.
name|REFERENCE
argument_list|,
name|interfaceType
operator|.
name|name
argument_list|)
decl_stmt|;
name|filter
operator|=
name|nested
operator|.
name|dynamicInvoker
argument_list|()
expr_stmt|;
block|}
else|else
block|{
throw|throw
operator|new
name|AssertionError
argument_list|()
throw|;
block|}
comment|// the filter now ignores the signature (placeholder) on the stack
name|filter
operator|=
name|MethodHandles
operator|.
name|dropArguments
argument_list|(
name|filter
argument_list|,
literal|0
argument_list|,
name|String
operator|.
name|class
argument_list|)
expr_stmt|;
name|handle
operator|=
name|MethodHandles
operator|.
name|collectArguments
argument_list|(
name|handle
argument_list|,
name|i
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|i
operator|+=
name|numCaptures
expr_stmt|;
name|replaced
operator|+=
name|numCaptures
expr_stmt|;
block|}
block|}
return|return
name|handle
return|;
block|}
comment|/**       * Returns an implementation of interfaceClass that calls receiverClass.name       *<p>       * This is just like LambdaMetaFactory, only with a dynamic type. The interface type is known,       * so we simply need to lookup the matching implementation method based on receiver type.       */
DECL|method|lookupReference
specifier|static
name|MethodHandle
name|lookupReference
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|String
name|interfaceClass
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|)
throws|throws
name|Throwable
block|{
name|Definition
operator|.
name|Type
name|interfaceType
init|=
name|Definition
operator|.
name|getType
argument_list|(
name|interfaceClass
argument_list|)
decl_stmt|;
name|Method
name|interfaceMethod
init|=
name|interfaceType
operator|.
name|struct
operator|.
name|getFunctionalMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|interfaceMethod
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Class ["
operator|+
name|interfaceClass
operator|+
literal|"] is not a functional interface"
argument_list|)
throw|;
block|}
name|int
name|arity
init|=
name|interfaceMethod
operator|.
name|arguments
operator|.
name|size
argument_list|()
decl_stmt|;
name|Method
name|implMethod
init|=
name|lookupMethodInternal
argument_list|(
name|receiverClass
argument_list|,
name|name
argument_list|,
name|arity
argument_list|)
decl_stmt|;
return|return
name|lookupReferenceInternal
argument_list|(
name|lookup
argument_list|,
name|interfaceType
argument_list|,
name|implMethod
operator|.
name|owner
operator|.
name|name
argument_list|,
name|implMethod
operator|.
name|name
argument_list|,
name|receiverClass
argument_list|)
return|;
block|}
comment|/** Returns a method handle to an implementation of clazz, given method reference signature. */
DECL|method|lookupReferenceInternal
specifier|private
specifier|static
name|MethodHandle
name|lookupReferenceInternal
parameter_list|(
name|Lookup
name|lookup
parameter_list|,
name|Definition
operator|.
name|Type
name|clazz
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|call
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
modifier|...
name|captures
parameter_list|)
throws|throws
name|Throwable
block|{
specifier|final
name|FunctionRef
name|ref
decl_stmt|;
if|if
condition|(
literal|"this"
operator|.
name|equals
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|// user written method
name|Method
name|interfaceMethod
init|=
name|clazz
operator|.
name|struct
operator|.
name|getFunctionalMethod
argument_list|()
decl_stmt|;
if|if
condition|(
name|interfaceMethod
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot convert function reference ["
operator|+
name|type
operator|+
literal|"::"
operator|+
name|call
operator|+
literal|"] "
operator|+
literal|"to ["
operator|+
name|clazz
operator|.
name|name
operator|+
literal|"], not a functional interface"
argument_list|)
throw|;
block|}
name|int
name|arity
init|=
name|interfaceMethod
operator|.
name|arguments
operator|.
name|size
argument_list|()
operator|+
name|captures
operator|.
name|length
decl_stmt|;
specifier|final
name|MethodHandle
name|handle
decl_stmt|;
try|try
block|{
name|MethodHandle
name|accessor
init|=
name|lookup
operator|.
name|findStaticGetter
argument_list|(
name|lookup
operator|.
name|lookupClass
argument_list|()
argument_list|,
name|getUserFunctionHandleFieldName
argument_list|(
name|call
argument_list|,
name|arity
argument_list|)
argument_list|,
name|MethodHandle
operator|.
name|class
argument_list|)
decl_stmt|;
name|handle
operator|=
operator|(
name|MethodHandle
operator|)
name|accessor
operator|.
name|invokeExact
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NoSuchFieldException
decl||
name|IllegalAccessException
name|e
parameter_list|)
block|{
comment|// is it a synthetic method? If we generated the method ourselves, be more helpful. It can only fail
comment|// because the arity does not match the expected interface type.
if|if
condition|(
name|call
operator|.
name|contains
argument_list|(
literal|"$"
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Incorrect number of parameters for ["
operator|+
name|interfaceMethod
operator|.
name|name
operator|+
literal|"] in ["
operator|+
name|clazz
operator|.
name|clazz
operator|+
literal|"]"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown call ["
operator|+
name|call
operator|+
literal|"] with ["
operator|+
name|arity
operator|+
literal|"] arguments."
argument_list|)
throw|;
block|}
name|ref
operator|=
operator|new
name|FunctionRef
argument_list|(
name|clazz
argument_list|,
name|interfaceMethod
argument_list|,
name|handle
argument_list|,
name|captures
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// whitelist lookup
name|ref
operator|=
operator|new
name|FunctionRef
argument_list|(
name|clazz
argument_list|,
name|type
argument_list|,
name|call
argument_list|,
name|captures
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CallSite
name|callSite
decl_stmt|;
if|if
condition|(
name|ref
operator|.
name|needsBridges
argument_list|()
condition|)
block|{
name|callSite
operator|=
name|LambdaMetafactory
operator|.
name|altMetafactory
argument_list|(
name|lookup
argument_list|,
name|ref
operator|.
name|invokedName
argument_list|,
name|ref
operator|.
name|invokedType
argument_list|,
name|ref
operator|.
name|samMethodType
argument_list|,
name|ref
operator|.
name|implMethod
argument_list|,
name|ref
operator|.
name|samMethodType
argument_list|,
name|LambdaMetafactory
operator|.
name|FLAG_BRIDGES
argument_list|,
literal|1
argument_list|,
name|ref
operator|.
name|interfaceMethodType
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|callSite
operator|=
name|LambdaMetafactory
operator|.
name|altMetafactory
argument_list|(
name|lookup
argument_list|,
name|ref
operator|.
name|invokedName
argument_list|,
name|ref
operator|.
name|invokedType
argument_list|,
name|ref
operator|.
name|samMethodType
argument_list|,
name|ref
operator|.
name|implMethod
argument_list|,
name|ref
operator|.
name|samMethodType
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|callSite
operator|.
name|dynamicInvoker
argument_list|()
operator|.
name|asType
argument_list|(
name|MethodType
operator|.
name|methodType
argument_list|(
name|clazz
operator|.
name|clazz
argument_list|,
name|captures
argument_list|)
argument_list|)
return|;
block|}
comment|/** gets the field name used to lookup up the MethodHandle for a function. */
DECL|method|getUserFunctionHandleFieldName
specifier|public
specifier|static
name|String
name|getUserFunctionHandleFieldName
parameter_list|(
name|String
name|name
parameter_list|,
name|int
name|arity
parameter_list|)
block|{
return|return
literal|"handle$"
operator|+
name|name
operator|+
literal|"$"
operator|+
name|arity
return|;
block|}
comment|/**      * Looks up handle for a dynamic field getter (field load)      *<p>      * A dynamic field load for variable {@code x} of type {@code def} looks like:      * {@code y = x.field}      *<p>      * The following field loads are allowed:      *<ul>      *<li>Whitelisted {@code field} from receiver's class or any superclasses.      *<li>Whitelisted method named {@code getField()} from receiver's class/superclasses/interfaces.      *<li>Whitelisted method named {@code isField()} from receiver's class/superclasses/interfaces.      *<li>The {@code length} field of an array.      *<li>The value corresponding to a map key named {@code field} when the receiver is a Map.      *<li>The value in a list at element {@code field} (integer) when the receiver is a List.      *</ul>      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted getter. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching getter.      *<p>      * @param receiverClass Class of the object to retrieve the field from.      * @param name Name of the field.      * @return pointer to matching field. never returns null.      * @throws IllegalArgumentException if no matching whitelisted field was found.      */
DECL|method|lookupGetter
specifier|static
name|MethodHandle
name|lookupGetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|)
block|{
comment|// first try whitelist
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|getters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|getters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
block|}
block|}
comment|// special case: arrays, maps, and lists
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
operator|&&
literal|"length"
operator|.
name|equals
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|// arrays expose .length as a read-only getter
return|return
name|arrayLengthGetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap.key
comment|// wire 'key' as a parameter, its a constant in painless
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|MAP_GET
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// lists allow access like mylist.0
comment|// wire '0' (index) as a parameter, its a constant. this also avoids
comment|// parsing the same integer millions of times!
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|LIST_GET
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal list shortcut value ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic field ["
operator|+
name|name
operator|+
literal|"] "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Looks up handle for a dynamic field setter (field store)      *<p>      * A dynamic field store for variable {@code x} of type {@code def} looks like:      * {@code x.field = y}      *<p>      * The following field stores are allowed:      *<ul>      *<li>Whitelisted {@code field} from receiver's class or any superclasses.      *<li>Whitelisted method named {@code setField()} from receiver's class/superclasses/interfaces.      *<li>The value corresponding to a map key named {@code field} when the receiver is a Map.      *<li>The value in a list at element {@code field} (integer) when the receiver is a List.      *</ul>      *<p>      * This method traverses {@code recieverClass}'s class hierarchy (including interfaces)      * until it finds a matching whitelisted setter. If one is not found, it throws an exception.      * Otherwise it returns a handle to the matching setter.      *<p>      * @param receiverClass Class of the object to retrieve the field from.      * @param name Name of the field.      * @return pointer to matching field. never returns null.      * @throws IllegalArgumentException if no matching whitelisted field was found.      */
DECL|method|lookupSetter
specifier|static
name|MethodHandle
name|lookupSetter
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|,
name|String
name|name
parameter_list|)
block|{
comment|// first try whitelist
for|for
control|(
name|Class
argument_list|<
name|?
argument_list|>
name|clazz
init|=
name|receiverClass
init|;
name|clazz
operator|!=
literal|null
condition|;
name|clazz
operator|=
name|clazz
operator|.
name|getSuperclass
argument_list|()
control|)
block|{
name|RuntimeClass
name|struct
init|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|clazz
argument_list|)
decl_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|setters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
for|for
control|(
specifier|final
name|Class
argument_list|<
name|?
argument_list|>
name|iface
range|:
name|clazz
operator|.
name|getInterfaces
argument_list|()
control|)
block|{
name|struct
operator|=
name|Definition
operator|.
name|getRuntimeClass
argument_list|(
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct
operator|!=
literal|null
condition|)
block|{
name|MethodHandle
name|handle
init|=
name|struct
operator|.
name|setters
operator|.
name|get
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|handle
operator|!=
literal|null
condition|)
block|{
return|return
name|handle
return|;
block|}
block|}
block|}
block|}
comment|// special case: maps, and lists
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap.key
comment|// wire 'key' as a parameter, its a constant in painless
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|MAP_PUT
argument_list|,
literal|1
argument_list|,
name|name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// lists allow access like mylist.0
comment|// wire '0' (index) as a parameter, its a constant. this also avoids
comment|// parsing the same integer millions of times!
try|try
block|{
name|int
name|index
init|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|name
argument_list|)
decl_stmt|;
return|return
name|MethodHandles
operator|.
name|insertArguments
argument_list|(
name|LIST_SET
argument_list|,
literal|1
argument_list|,
name|index
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
specifier|final
name|NumberFormatException
name|exception
parameter_list|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal list shortcut value ["
operator|+
name|name
operator|+
literal|"]."
argument_list|)
throw|;
block|}
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unable to find dynamic field ["
operator|+
name|name
operator|+
literal|"] "
operator|+
literal|"for class ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]."
argument_list|)
throw|;
block|}
comment|/**      * Returns a method handle to do an array store.      * @param receiverClass Class of the array to store the value in      * @return a MethodHandle that accepts the receiver as first argument, the index as second argument,      *   and the value to set as 3rd argument. Return value is undefined and should be ignored.      */
DECL|method|lookupArrayStore
specifier|static
name|MethodHandle
name|lookupArrayStore
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|MethodHandles
operator|.
name|arrayElementSetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap[key]
return|return
name|MAP_PUT
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|LIST_SET
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempting to address a non-array type "
operator|+
literal|"["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] as an array."
argument_list|)
throw|;
block|}
comment|/**      * Returns a method handle to do an array load.      * @param receiverClass Class of the array to load the value from      * @return a MethodHandle that accepts the receiver as first argument, the index as second argument.      *   It returns the loaded value.      */
DECL|method|lookupArrayLoad
specifier|static
name|MethodHandle
name|lookupArrayLoad
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|MethodHandles
operator|.
name|arrayElementGetter
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|Map
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
comment|// maps allow access like mymap[key]
return|return
name|MAP_GET
return|;
block|}
elseif|else
if|if
condition|(
name|List
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|LIST_GET
return|;
block|}
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Attempting to address a non-array type "
operator|+
literal|"["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"] as an array."
argument_list|)
throw|;
block|}
comment|/** Helper class for isolating MethodHandles and methods to get iterators over arrays      * (to emulate "enhanced for loop" using MethodHandles). These cause boxing, and are not as efficient      * as they could be, but works.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unused"
argument_list|)
comment|// iterator() methods are are actually used, javac just does not know :)
DECL|class|ArrayIteratorHelper
specifier|private
specifier|static
specifier|final
class|class
name|ArrayIteratorHelper
block|{
DECL|field|PRIV_LOOKUP
specifier|private
specifier|static
specifier|final
name|Lookup
name|PRIV_LOOKUP
init|=
name|MethodHandles
operator|.
name|lookup
argument_list|()
decl_stmt|;
DECL|field|ARRAY_TYPE_MH_MAPPING
specifier|private
specifier|static
specifier|final
name|Map
argument_list|<
name|Class
argument_list|<
name|?
argument_list|>
argument_list|,
name|MethodHandle
argument_list|>
name|ARRAY_TYPE_MH_MAPPING
init|=
name|Collections
operator|.
name|unmodifiableMap
argument_list|(
name|Stream
operator|.
name|of
argument_list|(
name|boolean
index|[]
operator|.
expr|class
argument_list|,
name|byte
index|[]
operator|.
expr|class
argument_list|,
name|short
index|[]
operator|.
expr|class
argument_list|,
name|int
index|[]
operator|.
expr|class
argument_list|,
name|long
index|[]
operator|.
expr|class
argument_list|,
name|char
index|[]
operator|.
expr|class
argument_list|,
name|float
index|[]
operator|.
expr|class
argument_list|,
name|double
index|[]
operator|.
expr|class
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
operator|.
name|collect
argument_list|(
name|Collectors
operator|.
name|toMap
argument_list|(
name|Function
operator|.
name|identity
argument_list|()
argument_list|,
name|type
lambda|->
block|{
try|try
block|{
return|return
name|PRIV_LOOKUP
operator|.
name|findStatic
argument_list|(
name|PRIV_LOOKUP
operator|.
name|lookupClass
argument_list|()
argument_list|,
literal|"iterator"
argument_list|,
name|MethodType
operator|.
name|methodType
argument_list|(
name|Iterator
operator|.
name|class
argument_list|,
name|type
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|ReflectiveOperationException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|AssertionError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
DECL|field|OBJECT_ARRAY_MH
specifier|private
specifier|static
specifier|final
name|MethodHandle
name|OBJECT_ARRAY_MH
init|=
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|Object
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Boolean
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|boolean
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Boolean
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Boolean
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Byte
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|byte
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Byte
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Byte
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Short
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|short
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Short
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Short
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Integer
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|int
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Integer
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Integer
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Long
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|long
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Long
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Long
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Character
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|char
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Character
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Character
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Float
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|float
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Float
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Float
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Double
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|double
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Double
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Double
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|iterator
specifier|static
name|Iterator
argument_list|<
name|Object
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|Object
index|[]
name|array
parameter_list|)
block|{
return|return
operator|new
name|Iterator
argument_list|<
name|Object
argument_list|>
argument_list|()
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|index
operator|<
name|array
operator|.
name|length
return|;
block|}
annotation|@
name|Override
specifier|public
name|Object
name|next
parameter_list|()
block|{
return|return
name|array
index|[
name|index
operator|++
index|]
return|;
block|}
block|}
return|;
block|}
DECL|method|newIterator
specifier|static
name|MethodHandle
name|newIterator
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|arrayType
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arrayType
operator|.
name|isArray
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"type must be an array"
argument_list|)
throw|;
block|}
return|return
operator|(
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|containsKey
argument_list|(
name|arrayType
argument_list|)
operator|)
condition|?
name|ARRAY_TYPE_MH_MAPPING
operator|.
name|get
argument_list|(
name|arrayType
argument_list|)
else|:
name|OBJECT_ARRAY_MH
operator|.
name|asType
argument_list|(
name|OBJECT_ARRAY_MH
operator|.
name|type
argument_list|()
operator|.
name|changeParameterType
argument_list|(
literal|0
argument_list|,
name|arrayType
argument_list|)
argument_list|)
return|;
block|}
DECL|method|ArrayIteratorHelper
specifier|private
name|ArrayIteratorHelper
parameter_list|()
block|{}
block|}
comment|/**      * Returns a method handle to do iteration (for enhanced for loop)      * @param receiverClass Class of the array to load the value from      * @return a MethodHandle that accepts the receiver as first argument, returns iterator      */
DECL|method|lookupIterator
specifier|static
name|MethodHandle
name|lookupIterator
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|receiverClass
parameter_list|)
block|{
if|if
condition|(
name|Iterable
operator|.
name|class
operator|.
name|isAssignableFrom
argument_list|(
name|receiverClass
argument_list|)
condition|)
block|{
return|return
name|ITERATOR
return|;
block|}
elseif|else
if|if
condition|(
name|receiverClass
operator|.
name|isArray
argument_list|()
condition|)
block|{
return|return
name|ArrayIteratorHelper
operator|.
name|newIterator
argument_list|(
name|receiverClass
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Cannot iterate over ["
operator|+
name|receiverClass
operator|.
name|getCanonicalName
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
comment|// Conversion methods for Def to primitive types.
DECL|method|DefToboolean
specifier|public
specifier|static
name|boolean
name|DefToboolean
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
return|return
operator|(
name|boolean
operator|)
name|value
return|;
block|}
DECL|method|DefTobyteImplicit
specifier|public
specifier|static
name|byte
name|DefTobyteImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
DECL|method|DefToshortImplicit
specifier|public
specifier|static
name|short
name|DefToshortImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTocharImplicit
specifier|public
specifier|static
name|char
name|DefTocharImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
call|(
name|char
call|)
argument_list|(
name|byte
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTointImplicit
specifier|public
specifier|static
name|int
name|DefTointImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTolongImplicit
specifier|public
specifier|static
name|long
name|DefTolongImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTofloatImplicit
specifier|public
specifier|static
name|float
name|DefTofloatImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTodoubleImplicit
specifier|public
specifier|static
name|double
name|DefTodoubleImplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Byte
condition|)
block|{
return|return
operator|(
name|byte
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Short
condition|)
block|{
return|return
operator|(
name|short
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Integer
condition|)
block|{
return|return
operator|(
name|int
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Long
condition|)
block|{
return|return
operator|(
name|long
operator|)
name|value
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|instanceof
name|Float
condition|)
block|{
return|return
operator|(
name|float
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
name|double
operator|)
name|value
return|;
block|}
block|}
DECL|method|DefTobyteExplicit
specifier|public
specifier|static
name|byte
name|DefTobyteExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|byte
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|byteValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefToshortExplicit
specifier|public
specifier|static
name|short
name|DefToshortExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
call|(
name|short
call|)
argument_list|(
name|char
argument_list|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|shortValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTocharExplicit
specifier|public
specifier|static
name|char
name|DefTocharExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
operator|(
name|Character
operator|)
name|value
operator|)
return|;
block|}
else|else
block|{
return|return
call|(
name|char
call|)
argument_list|(
operator|(
name|Number
operator|)
name|value
argument_list|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTointExplicit
specifier|public
specifier|static
name|int
name|DefTointExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|intValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTolongExplicit
specifier|public
specifier|static
name|long
name|DefTolongExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|longValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTofloatExplicit
specifier|public
specifier|static
name|float
name|DefTofloatExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|floatValue
argument_list|()
return|;
block|}
block|}
DECL|method|DefTodoubleExplicit
specifier|public
specifier|static
name|double
name|DefTodoubleExplicit
parameter_list|(
specifier|final
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|instanceof
name|Character
condition|)
block|{
return|return
operator|(
name|char
operator|)
name|value
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|Number
operator|)
name|value
operator|)
operator|.
name|doubleValue
argument_list|()
return|;
block|}
block|}
block|}
end_class

end_unit

