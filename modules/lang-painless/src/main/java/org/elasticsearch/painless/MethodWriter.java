begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.painless
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|painless
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Cast
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Sort
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|Definition
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|ClassWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Label
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Opcodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|GeneratorAdapter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|commons
operator|.
name|Method
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayDeque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|BitSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|CHAR_TO_STRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_ADD_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_AND_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_DIV_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_LSH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_MUL_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_OR_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_REM_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_RSH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_SUB_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_BOOLEAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_BYTE_EXPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_BYTE_IMPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_CHAR_EXPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_CHAR_IMPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_DOUBLE_EXPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_DOUBLE_IMPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_FLOAT_EXPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_FLOAT_IMPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_INT_EXPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_INT_IMPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_LONG_EXPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_LONG_IMPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_SHORT_EXPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_TO_SHORT_IMPLICIT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_USH_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_UTIL_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|DEF_XOR_CALL
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|INDY_STRING_CONCAT_BOOTSTRAP_HANDLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|MAX_INDY_STRING_CONCAT_ARGS
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|PAINLESS_ERROR_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_BOOLEAN
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_CHAR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_DOUBLE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_FLOAT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_INT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_LONG
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_OBJECT
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_APPEND_STRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_CONSTRUCTOR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_TOSTRING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRINGBUILDER_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRING_TO_CHAR
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|STRING_TYPE
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|painless
operator|.
name|WriterConstants
operator|.
name|UTILITY_TYPE
import|;
end_import

begin_comment
comment|/**  * Extension of {@link GeneratorAdapter} with some utility methods.  *<p>  * Set of methods used during the writing phase of compilation  * shared by the nodes of the Painless tree.  */
end_comment

begin_class
DECL|class|MethodWriter
specifier|public
specifier|final
class|class
name|MethodWriter
extends|extends
name|GeneratorAdapter
block|{
DECL|field|parent
specifier|private
specifier|final
name|ClassWriter
name|parent
decl_stmt|;
DECL|field|statements
specifier|private
specifier|final
name|BitSet
name|statements
decl_stmt|;
DECL|field|stringConcatArgs
specifier|private
specifier|final
name|Deque
argument_list|<
name|List
argument_list|<
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
argument_list|>
argument_list|>
name|stringConcatArgs
init|=
operator|(
name|INDY_STRING_CONCAT_BOOTSTRAP_HANDLE
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
operator|new
name|ArrayDeque
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|MethodWriter
specifier|public
name|MethodWriter
parameter_list|(
name|int
name|access
parameter_list|,
name|Method
name|method
parameter_list|,
name|ClassWriter
name|cw
parameter_list|,
name|BitSet
name|statements
parameter_list|)
block|{
name|super
argument_list|(
name|Opcodes
operator|.
name|ASM5
argument_list|,
name|cw
operator|.
name|visitMethod
argument_list|(
name|access
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|method
operator|.
name|getDescriptor
argument_list|()
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|,
name|access
argument_list|,
name|method
operator|.
name|getName
argument_list|()
argument_list|,
name|method
operator|.
name|getDescriptor
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|cw
expr_stmt|;
name|this
operator|.
name|statements
operator|=
name|statements
expr_stmt|;
block|}
comment|/**      * @return A new {@link MethodWriter} with the specified access and signature.      */
DECL|method|newMethodWriter
specifier|public
name|MethodWriter
name|newMethodWriter
parameter_list|(
name|int
name|access
parameter_list|,
name|Method
name|method
parameter_list|)
block|{
return|return
operator|new
name|MethodWriter
argument_list|(
name|access
argument_list|,
name|method
argument_list|,
name|parent
argument_list|,
name|statements
argument_list|)
return|;
block|}
comment|/**      * Marks a new statement boundary.      *<p>      * This is invoked for each statement boundary (leaf {@code S*} nodes).      */
DECL|method|writeStatementOffset
specifier|public
name|void
name|writeStatementOffset
parameter_list|(
name|Location
name|location
parameter_list|)
block|{
name|int
name|offset
init|=
name|location
operator|.
name|getOffset
argument_list|()
decl_stmt|;
comment|// ensure we don't have duplicate stuff going in here. can catch bugs
comment|// (e.g. nodes get assigned wrong offsets by antlr walker)
assert|assert
name|statements
operator|.
name|get
argument_list|(
name|offset
argument_list|)
operator|==
literal|false
assert|;
name|statements
operator|.
name|set
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/**      * Encodes the offset into the line number table as {@code offset + 1}.      *<p>      * This is invoked before instructions that can hit exceptions.      */
DECL|method|writeDebugInfo
specifier|public
name|void
name|writeDebugInfo
parameter_list|(
name|Location
name|location
parameter_list|)
block|{
comment|// TODO: maybe track these in bitsets too? this is trickier...
name|Label
name|label
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|visitLabel
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|visitLineNumber
argument_list|(
name|location
operator|.
name|getOffset
argument_list|()
operator|+
literal|1
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
DECL|method|writeLoopCounter
specifier|public
name|void
name|writeLoopCounter
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|count
parameter_list|,
name|Location
name|location
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|>
operator|-
literal|1
condition|)
block|{
name|writeDebugInfo
argument_list|(
name|location
argument_list|)
expr_stmt|;
specifier|final
name|Label
name|end
init|=
operator|new
name|Label
argument_list|()
decl_stmt|;
name|iinc
argument_list|(
name|slot
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
name|visitVarInsn
argument_list|(
name|Opcodes
operator|.
name|ILOAD
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ifICmp
argument_list|(
name|GeneratorAdapter
operator|.
name|GT
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|throwException
argument_list|(
name|PAINLESS_ERROR_TYPE
argument_list|,
literal|"The maximum number of statements that can be executed in a loop has been reached."
argument_list|)
expr_stmt|;
name|mark
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeCast
specifier|public
name|void
name|writeCast
parameter_list|(
specifier|final
name|Cast
name|cast
parameter_list|)
block|{
if|if
condition|(
name|cast
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Type
name|from
init|=
name|cast
operator|.
name|from
decl_stmt|;
specifier|final
name|Type
name|to
init|=
name|cast
operator|.
name|to
decl_stmt|;
if|if
condition|(
name|from
operator|.
name|sort
operator|==
name|Sort
operator|.
name|CHAR
operator|&&
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
condition|)
block|{
name|invokeStatic
argument_list|(
name|UTILITY_TYPE
argument_list|,
name|CHAR_TO_STRING
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from
operator|.
name|sort
operator|==
name|Sort
operator|.
name|STRING
operator|&&
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
block|{
name|invokeStatic
argument_list|(
name|UTILITY_TYPE
argument_list|,
name|STRING_TO_CHAR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cast
operator|.
name|unboxFrom
condition|)
block|{
if|if
condition|(
name|from
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
if|if
condition|(
name|cast
operator|.
name|explicit
condition|)
block|{
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|BOOL
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_BOOLEAN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_BYTE_EXPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_SHORT_EXPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_CHAR_EXPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|INT
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_INT_EXPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|LONG
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_LONG_EXPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_FLOAT_EXPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_DOUBLE_EXPLICIT
argument_list|)
expr_stmt|;
else|else
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
throw|;
block|}
else|else
block|{
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|BOOL
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_BOOLEAN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|BYTE
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_BYTE_IMPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|SHORT
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_SHORT_IMPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|CHAR
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_CHAR_IMPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|INT
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_INT_IMPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|LONG
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_LONG_IMPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_FLOAT_IMPLICIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|to
operator|.
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
condition|)
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_TO_DOUBLE_IMPLICIT
argument_list|)
expr_stmt|;
else|else
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
throw|;
block|}
block|}
else|else
block|{
name|unbox
argument_list|(
name|from
operator|.
name|type
argument_list|)
expr_stmt|;
name|writeCast
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cast
operator|.
name|unboxTo
condition|)
block|{
name|writeCast
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|unbox
argument_list|(
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cast
operator|.
name|boxFrom
condition|)
block|{
name|box
argument_list|(
name|from
operator|.
name|type
argument_list|)
expr_stmt|;
name|writeCast
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cast
operator|.
name|boxTo
condition|)
block|{
name|writeCast
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|writeCast
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeCast
specifier|private
name|void
name|writeCast
parameter_list|(
specifier|final
name|Type
name|from
parameter_list|,
specifier|final
name|Type
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|.
name|equals
argument_list|(
name|to
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|from
operator|.
name|sort
operator|.
name|numeric
operator|&&
name|from
operator|.
name|sort
operator|.
name|primitive
operator|&&
name|to
operator|.
name|sort
operator|.
name|numeric
operator|&&
name|to
operator|.
name|sort
operator|.
name|primitive
condition|)
block|{
name|cast
argument_list|(
name|from
operator|.
name|type
argument_list|,
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|to
operator|.
name|clazz
operator|.
name|isAssignableFrom
argument_list|(
name|from
operator|.
name|clazz
argument_list|)
condition|)
block|{
name|checkCast
argument_list|(
name|to
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Proxy the box method to use valueOf instead to ensure that the modern boxing methods are used.      */
annotation|@
name|Override
DECL|method|box
specifier|public
name|void
name|box
parameter_list|(
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
name|type
parameter_list|)
block|{
name|valueOf
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
DECL|method|writeBranch
specifier|public
name|void
name|writeBranch
parameter_list|(
specifier|final
name|Label
name|tru
parameter_list|,
specifier|final
name|Label
name|fals
parameter_list|)
block|{
if|if
condition|(
name|tru
operator|!=
literal|null
condition|)
block|{
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFNE
argument_list|,
name|tru
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fals
operator|!=
literal|null
condition|)
block|{
name|visitJumpInsn
argument_list|(
name|Opcodes
operator|.
name|IFEQ
argument_list|,
name|fals
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeNewStrings
specifier|public
name|void
name|writeNewStrings
parameter_list|()
block|{
if|if
condition|(
name|INDY_STRING_CONCAT_BOOTSTRAP_HANDLE
operator|!=
literal|null
condition|)
block|{
comment|// Java 9+: we just push our argument collector onto deque
name|stringConcatArgs
operator|.
name|push
argument_list|(
operator|new
name|ArrayList
argument_list|<>
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Java 8: create a StringBuilder in bytecode
name|newInstance
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|)
expr_stmt|;
name|dup
argument_list|()
expr_stmt|;
name|invokeConstructor
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_CONSTRUCTOR
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeAppendStrings
specifier|public
name|void
name|writeAppendStrings
parameter_list|(
specifier|final
name|Type
name|type
parameter_list|)
block|{
if|if
condition|(
name|INDY_STRING_CONCAT_BOOTSTRAP_HANDLE
operator|!=
literal|null
condition|)
block|{
comment|// Java 9+: record type information
name|stringConcatArgs
operator|.
name|peek
argument_list|()
operator|.
name|add
argument_list|(
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
comment|// prevent too many concat args.
comment|// If there are too many, do the actual concat:
if|if
condition|(
name|stringConcatArgs
operator|.
name|peek
argument_list|()
operator|.
name|size
argument_list|()
operator|>=
name|MAX_INDY_STRING_CONCAT_ARGS
condition|)
block|{
name|writeToStrings
argument_list|()
expr_stmt|;
name|writeNewStrings
argument_list|()
expr_stmt|;
comment|// add the return value type as new first param for next concat:
name|stringConcatArgs
operator|.
name|peek
argument_list|()
operator|.
name|add
argument_list|(
name|STRING_TYPE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Java 8: push a StringBuilder append
switch|switch
condition|(
name|type
operator|.
name|sort
condition|)
block|{
case|case
name|BOOL
case|:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_BOOLEAN
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR
case|:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|BYTE
case|:
case|case
name|SHORT
case|:
case|case
name|INT
case|:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|LONG
case|:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLOAT
case|:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUBLE
case|:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_DOUBLE
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_STRING
argument_list|)
expr_stmt|;
break|break;
default|default:
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_APPEND_OBJECT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|writeToStrings
specifier|public
name|void
name|writeToStrings
parameter_list|()
block|{
if|if
condition|(
name|INDY_STRING_CONCAT_BOOTSTRAP_HANDLE
operator|!=
literal|null
condition|)
block|{
comment|// Java 9+: use type information and push invokeDynamic
specifier|final
name|String
name|desc
init|=
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
operator|.
name|getMethodDescriptor
argument_list|(
name|STRING_TYPE
argument_list|,
name|stringConcatArgs
operator|.
name|pop
argument_list|()
operator|.
name|stream
argument_list|()
operator|.
name|toArray
argument_list|(
name|org
operator|.
name|objectweb
operator|.
name|asm
operator|.
name|Type
index|[]
operator|::
operator|new
argument_list|)
argument_list|)
decl_stmt|;
name|invokeDynamic
argument_list|(
literal|"concat"
argument_list|,
name|desc
argument_list|,
name|INDY_STRING_CONCAT_BOOTSTRAP_HANDLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Java 8: call toString() on StringBuilder
name|invokeVirtual
argument_list|(
name|STRINGBUILDER_TYPE
argument_list|,
name|STRINGBUILDER_TOSTRING
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|writeBinaryInstruction
specifier|public
name|void
name|writeBinaryInstruction
parameter_list|(
name|Location
name|location
parameter_list|,
name|Type
name|type
parameter_list|,
name|Operation
name|operation
parameter_list|)
block|{
specifier|final
name|Sort
name|sort
init|=
name|type
operator|.
name|sort
decl_stmt|;
if|if
condition|(
operator|(
name|sort
operator|==
name|Sort
operator|.
name|FLOAT
operator|||
name|sort
operator|==
name|Sort
operator|.
name|DOUBLE
operator|)
operator|&&
operator|(
name|operation
operator|==
name|Operation
operator|.
name|LSH
operator|||
name|operation
operator|==
name|Operation
operator|.
name|USH
operator|||
name|operation
operator|==
name|Operation
operator|.
name|RSH
operator|||
name|operation
operator|==
name|Operation
operator|.
name|BWAND
operator|||
name|operation
operator|==
name|Operation
operator|.
name|XOR
operator|||
name|operation
operator|==
name|Operation
operator|.
name|BWOR
operator|)
condition|)
block|{
throw|throw
name|location
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
if|if
condition|(
name|sort
operator|==
name|Sort
operator|.
name|DEF
condition|)
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_MUL_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_DIV_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_REM_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_ADD_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_SUB_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_LSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_RSH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_USH_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_AND_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_XOR_CALL
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|invokeStatic
argument_list|(
name|DEF_UTIL_TYPE
argument_list|,
name|DEF_OR_CALL
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|location
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|MUL
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|MUL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|DIV
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|REM
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADD
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|ADD
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SUB
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SUB
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|LSH
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHL
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|USH
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|USHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|SHR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWAND
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|AND
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|XOR
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|XOR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|BWOR
case|:
name|math
argument_list|(
name|GeneratorAdapter
operator|.
name|OR
argument_list|,
name|type
operator|.
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
throw|throw
name|location
operator|.
name|createError
argument_list|(
operator|new
name|IllegalStateException
argument_list|(
literal|"Illegal tree structure."
argument_list|)
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|writeDup
specifier|public
name|void
name|writeDup
parameter_list|(
specifier|final
name|int
name|size
parameter_list|,
specifier|final
name|int
name|xsize
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|xsize
operator|==
literal|2
condition|)
block|{
name|dupX2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xsize
operator|==
literal|1
condition|)
block|{
name|dupX1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dup
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|xsize
operator|==
literal|2
condition|)
block|{
name|dup2X2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xsize
operator|==
literal|1
condition|)
block|{
name|dup2X1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dup2
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|writePop
specifier|public
name|void
name|writePop
parameter_list|(
specifier|final
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
name|pop2
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|visitEnd
specifier|public
name|void
name|visitEnd
parameter_list|()
block|{
if|if
condition|(
name|stringConcatArgs
operator|!=
literal|null
operator|&&
operator|!
name|stringConcatArgs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"String concat bytecode not completed."
argument_list|)
throw|;
block|}
name|super
operator|.
name|visitEnd
argument_list|()
expr_stmt|;
block|}
block|}
end_class

end_unit

