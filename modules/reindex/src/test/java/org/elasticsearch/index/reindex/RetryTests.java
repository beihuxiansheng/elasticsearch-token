begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.reindex
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|reindex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|LuceneTestCase
operator|.
name|AwaitsFix
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|ListenableActionFuture
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|bulk
operator|.
name|BackoffPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|bulk
operator|.
name|BulkRequestBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|bulk
operator|.
name|BulkResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|bulk
operator|.
name|Retry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|health
operator|.
name|ClusterHealthStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|EsRejectedExecutionException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|plugins
operator|.
name|Plugin
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|MockSearchService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|function
operator|.
name|IntFunction
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
operator|.
name|timeValueMillis
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|hamcrest
operator|.
name|ElasticsearchAssertions
operator|.
name|assertAcked
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|greaterThan
import|;
end_import

begin_comment
comment|/**  * Integration test for retry behavior. Useful because retrying relies on the way that the rest of Elasticsearch throws exceptions and unit  * tests won't verify that.  */
end_comment

begin_class
annotation|@
name|AwaitsFix
argument_list|(
name|bugUrl
operator|=
literal|"https://github.com/elastic/elasticsearch/pull/18456"
argument_list|)
DECL|class|RetryTests
specifier|public
class|class
name|RetryTests
extends|extends
name|ReindexTestCase
block|{
comment|/**      * The number of concurrent requests to test.      */
DECL|field|CONCURRENT
specifier|private
specifier|static
specifier|final
name|int
name|CONCURRENT
init|=
literal|12
decl_stmt|;
comment|/**      * Enough docs that the requests will likely step on each other.      */
DECL|field|DOC_COUNT
specifier|private
specifier|static
specifier|final
name|int
name|DOC_COUNT
init|=
literal|200
decl_stmt|;
comment|/**      * Maximum number of times to attempt the test case before bailing with a failure if we don't see both a bulk and a search retry.      */
DECL|field|ATTEMPTS
specifier|private
specifier|static
specifier|final
name|int
name|ATTEMPTS
init|=
literal|10
decl_stmt|;
comment|/**      * Lower the queue sizes to be small enough that both bulk and searches will time out and have to be retried.      */
annotation|@
name|Override
DECL|method|nodeSettings
specifier|protected
name|Settings
name|nodeSettings
parameter_list|(
name|int
name|nodeOrdinal
parameter_list|)
block|{
name|Settings
operator|.
name|Builder
name|settings
init|=
name|Settings
operator|.
name|builder
argument_list|()
operator|.
name|put
argument_list|(
name|super
operator|.
name|nodeSettings
argument_list|(
name|nodeOrdinal
argument_list|)
argument_list|)
decl_stmt|;
name|settings
operator|.
name|put
argument_list|(
literal|"threadpool.bulk.queue_size"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|settings
operator|.
name|put
argument_list|(
literal|"threadpool.bulk.size"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|settings
operator|.
name|put
argument_list|(
literal|"threadpool.search.queue_size"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|settings
operator|.
name|put
argument_list|(
literal|"threadpool.search.size"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|settings
operator|.
name|build
argument_list|()
return|;
block|}
comment|/**      * Disable search context leak detection because we expect leaks when there is an {@link EsRejectedExecutionException} queueing the      * reduce phase.      */
annotation|@
name|Override
DECL|method|getMockPlugins
specifier|protected
name|Collection
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Plugin
argument_list|>
argument_list|>
name|getMockPlugins
parameter_list|()
block|{
name|List
argument_list|<
name|Class
argument_list|<
name|?
extends|extends
name|Plugin
argument_list|>
argument_list|>
name|mockPlugins
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|Class
argument_list|<
name|?
extends|extends
name|Plugin
argument_list|>
name|plugin
range|:
name|super
operator|.
name|getMockPlugins
argument_list|()
control|)
block|{
if|if
condition|(
name|plugin
operator|.
name|equals
argument_list|(
name|MockSearchService
operator|.
name|TestPlugin
operator|.
name|class
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|mockPlugins
operator|.
name|add
argument_list|(
name|plugin
argument_list|)
expr_stmt|;
block|}
return|return
name|mockPlugins
return|;
block|}
DECL|method|testReindex
specifier|public
name|void
name|testReindex
parameter_list|()
throws|throws
name|Exception
block|{
name|testCase
argument_list|(
literal|true
argument_list|,
parameter_list|()
lambda|->
name|setupSourceIndex
argument_list|(
literal|"source"
argument_list|)
argument_list|,
name|i
lambda|->
name|reindex
argument_list|()
operator|.
name|source
argument_list|(
literal|"source"
argument_list|)
operator|.
name|destination
argument_list|(
literal|"dest"
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|testUpdateByQuery
specifier|public
name|void
name|testUpdateByQuery
parameter_list|()
throws|throws
name|Exception
block|{
name|Runnable
name|setup
init|=
parameter_list|()
lambda|->
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CONCURRENT
condition|;
name|i
operator|++
control|)
block|{
name|setupSourceIndex
argument_list|(
literal|"source"
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
decl_stmt|;
name|testCase
argument_list|(
literal|false
argument_list|,
name|setup
argument_list|,
name|i
lambda|->
name|updateByQuery
argument_list|()
operator|.
name|source
argument_list|(
literal|"source"
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Repeatedly attempts to cause bulk and search retries, failing if any of the requests fail and if after 5 attempts it isn't able to      * cause at least one of both types of retries across all attempts.      *      * @param expectCreated should the number of effected documents be created (true) or updated (false)      * @param setup called before every request attempt to create the test data      * @param requestBuilder called to build each parallel request.      */
DECL|method|testCase
specifier|private
name|void
name|testCase
parameter_list|(
name|boolean
name|expectCreated
parameter_list|,
name|Runnable
name|setup
parameter_list|,
name|IntFunction
argument_list|<
name|AbstractBulkIndexByScrollRequestBuilder
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|requestBuilder
parameter_list|)
throws|throws
name|Exception
block|{
name|long
name|bulkRetries
init|=
literal|0
decl_stmt|;
name|long
name|searchRetries
init|=
literal|0
decl_stmt|;
name|int
name|attempt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|attempt
operator|<
name|ATTEMPTS
condition|)
block|{
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareDelete
argument_list|(
literal|"*"
argument_list|)
operator|.
name|get
argument_list|()
expr_stmt|;
name|setup
operator|.
name|run
argument_list|()
expr_stmt|;
name|Tuple
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|result
init|=
name|attemptTestCase
argument_list|(
name|expectCreated
argument_list|,
name|requestBuilder
argument_list|)
decl_stmt|;
name|bulkRetries
operator|+=
name|result
operator|.
name|v1
argument_list|()
expr_stmt|;
name|searchRetries
operator|+=
name|result
operator|.
name|v2
argument_list|()
expr_stmt|;
name|attempt
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|bulkRetries
operator|==
literal|0
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Didn't get any bulk retries after {} attempts"
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|searchRetries
operator|==
literal|0
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Didn't get any search retries after {} attempts"
argument_list|,
name|attempt
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|// We expect at least one retry or this test isn't very useful
name|assertThat
argument_list|(
name|bulkRetries
argument_list|,
name|greaterThan
argument_list|(
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|searchRetries
argument_list|,
name|greaterThan
argument_list|(
literal|0L
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Attempts to cause retries for the requests provided by requestBuilder, failing if the requests fail. Returns a tuple of (number of      * bulk retries, number of search retries).      */
DECL|method|attemptTestCase
specifier|private
name|Tuple
argument_list|<
name|Long
argument_list|,
name|Long
argument_list|>
name|attemptTestCase
parameter_list|(
name|boolean
name|expectCreated
parameter_list|,
name|IntFunction
argument_list|<
name|AbstractBulkIndexByScrollRequestBuilder
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
argument_list|>
name|requestBuilder
parameter_list|)
throws|throws
name|Exception
block|{
name|List
argument_list|<
name|ListenableActionFuture
argument_list|<
name|BulkIndexByScrollResponse
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|CONCURRENT
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|CONCURRENT
condition|;
name|i
operator|++
control|)
block|{
name|AbstractBulkIndexByScrollRequestBuilder
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|request
init|=
name|requestBuilder
operator|.
name|apply
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Make sure we use more than one batch so we get the full reindex behavior
name|request
operator|.
name|source
argument_list|()
operator|.
name|setSize
argument_list|(
name|DOC_COUNT
operator|/
name|randomIntBetween
argument_list|(
literal|2
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
comment|// Use a low, random initial wait so we are unlikely collide with others retrying.
name|request
operator|.
name|setRetryBackoffInitialTime
argument_list|(
name|timeValueMillis
argument_list|(
name|randomIntBetween
argument_list|(
literal|10
argument_list|,
literal|300
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|futures
operator|.
name|add
argument_list|(
name|request
operator|.
name|execute
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Finish all the requests
name|List
argument_list|<
name|BulkIndexByScrollResponse
argument_list|>
name|responses
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|CONCURRENT
argument_list|)
decl_stmt|;
for|for
control|(
name|ListenableActionFuture
argument_list|<
name|BulkIndexByScrollResponse
argument_list|>
name|future
range|:
name|futures
control|)
block|{
name|responses
operator|.
name|add
argument_list|(
name|future
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Now check them
name|long
name|bulkRetries
init|=
literal|0
decl_stmt|;
name|long
name|searchRetries
init|=
literal|0
decl_stmt|;
name|BulkIndexByScrollResponseMatcher
name|matcher
init|=
name|matcher
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectCreated
condition|)
block|{
name|matcher
operator|.
name|created
argument_list|(
name|DOC_COUNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matcher
operator|.
name|updated
argument_list|(
name|DOC_COUNT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|BulkIndexByScrollResponse
name|response
range|:
name|responses
control|)
block|{
name|assertThat
argument_list|(
name|response
argument_list|,
name|matcher
argument_list|)
expr_stmt|;
name|bulkRetries
operator|+=
name|response
operator|.
name|getBulkRetries
argument_list|()
expr_stmt|;
name|searchRetries
operator|+=
name|response
operator|.
name|getSearchRetries
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|bulkRetries
argument_list|,
name|searchRetries
argument_list|)
return|;
block|}
DECL|method|setupSourceIndex
specifier|private
name|void
name|setupSourceIndex
parameter_list|(
name|String
name|name
parameter_list|)
block|{
try|try
block|{
comment|// Build the test index with a single shard so we can be sure that a search request *can* complete with the one thread
name|assertAcked
argument_list|(
name|client
argument_list|()
operator|.
name|admin
argument_list|()
operator|.
name|indices
argument_list|()
operator|.
name|prepareCreate
argument_list|(
name|name
argument_list|)
operator|.
name|setSettings
argument_list|(
literal|"index.number_of_shards"
argument_list|,
literal|1
argument_list|,
literal|"index.number_of_replicas"
argument_list|,
literal|0
argument_list|)
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|waitForRelocation
argument_list|(
name|ClusterHealthStatus
operator|.
name|GREEN
argument_list|)
expr_stmt|;
comment|// Build the test data. Don't use indexRandom because that won't work consistently with such small thread pools.
name|BulkRequestBuilder
name|bulk
init|=
name|client
argument_list|()
operator|.
name|prepareBulk
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|DOC_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|bulk
operator|.
name|add
argument_list|(
name|client
argument_list|()
operator|.
name|prepareIndex
argument_list|(
name|name
argument_list|,
literal|"test"
argument_list|)
operator|.
name|setSource
argument_list|(
literal|"foo"
argument_list|,
literal|"bar "
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Retry
name|retry
init|=
name|Retry
operator|.
name|on
argument_list|(
name|EsRejectedExecutionException
operator|.
name|class
argument_list|)
operator|.
name|policy
argument_list|(
name|BackoffPolicy
operator|.
name|exponentialBackoff
argument_list|()
argument_list|)
decl_stmt|;
name|BulkResponse
name|response
init|=
name|retry
operator|.
name|withSyncBackoff
argument_list|(
name|client
argument_list|()
argument_list|,
name|bulk
operator|.
name|request
argument_list|()
argument_list|)
decl_stmt|;
name|assertFalse
argument_list|(
name|response
operator|.
name|buildFailureMessage
argument_list|()
argument_list|,
name|response
operator|.
name|hasFailures
argument_list|()
argument_list|)
expr_stmt|;
name|refresh
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

