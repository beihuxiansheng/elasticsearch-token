begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.reindex
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|reindex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|StreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|Writeable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ToXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|CancellableTask
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|Task
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|TaskId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|TaskInfo
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Objects
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|min
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|util
operator|.
name|Collections
operator|.
name|emptyList
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
operator|.
name|timeValueNanos
import|;
end_import

begin_comment
comment|/**  * Task storing information about a currently running BulkByScroll request.  */
end_comment

begin_class
DECL|class|BulkByScrollTask
specifier|public
specifier|abstract
class|class
name|BulkByScrollTask
extends|extends
name|CancellableTask
block|{
DECL|method|BulkByScrollTask
specifier|public
name|BulkByScrollTask
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|action
parameter_list|,
name|String
name|description
parameter_list|,
name|TaskId
name|parentTaskId
parameter_list|)
block|{
name|super
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|action
argument_list|,
name|description
argument_list|,
name|parentTaskId
argument_list|)
expr_stmt|;
block|}
comment|/**      * The number of sub-slices that are still running. {@link WorkingBulkByScrollTask} will always have 0 and      * {@link ParentBulkByScrollTask} will return the number of waiting tasks. Used by {@link TransportRethrottleAction} to decide how to      * perform the rethrottling.      */
DECL|method|runningSliceSubTasks
specifier|abstract
name|int
name|runningSliceSubTasks
parameter_list|()
function_decl|;
comment|/**      * Apply the {@code newRequestsPerSecond}.      */
DECL|method|rethrottle
specifier|abstract
name|void
name|rethrottle
parameter_list|(
name|float
name|newRequestsPerSecond
parameter_list|)
function_decl|;
comment|/*      * Overridden to force children to return compatible status.      */
DECL|method|getStatus
specifier|public
specifier|abstract
name|BulkByScrollTask
operator|.
name|Status
name|getStatus
parameter_list|()
function_decl|;
comment|/**      * Build the status for this task given a snapshot of the information of running slices.      */
DECL|method|getInfoGivenSliceInfo
specifier|public
specifier|abstract
name|TaskInfo
name|getInfoGivenSliceInfo
parameter_list|(
name|String
name|localNodeId
parameter_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|sliceInfo
parameter_list|)
function_decl|;
DECL|class|Status
specifier|public
specifier|static
class|class
name|Status
implements|implements
name|Task
operator|.
name|Status
implements|,
name|SuccessfullyProcessed
block|{
DECL|field|NAME
specifier|public
specifier|static
specifier|final
name|String
name|NAME
init|=
literal|"bulk-by-scroll"
decl_stmt|;
comment|/**          * XContent param name to indicate if "created" count must be included          * in the response.          */
DECL|field|INCLUDE_CREATED
specifier|public
specifier|static
specifier|final
name|String
name|INCLUDE_CREATED
init|=
literal|"include_created"
decl_stmt|;
comment|/**          * XContent param name to indicate if "updated" count must be included          * in the response.          */
DECL|field|INCLUDE_UPDATED
specifier|public
specifier|static
specifier|final
name|String
name|INCLUDE_UPDATED
init|=
literal|"include_updated"
decl_stmt|;
DECL|field|sliceId
specifier|private
specifier|final
name|Integer
name|sliceId
decl_stmt|;
DECL|field|total
specifier|private
specifier|final
name|long
name|total
decl_stmt|;
DECL|field|updated
specifier|private
specifier|final
name|long
name|updated
decl_stmt|;
DECL|field|created
specifier|private
specifier|final
name|long
name|created
decl_stmt|;
DECL|field|deleted
specifier|private
specifier|final
name|long
name|deleted
decl_stmt|;
DECL|field|batches
specifier|private
specifier|final
name|int
name|batches
decl_stmt|;
DECL|field|versionConflicts
specifier|private
specifier|final
name|long
name|versionConflicts
decl_stmt|;
DECL|field|noops
specifier|private
specifier|final
name|long
name|noops
decl_stmt|;
DECL|field|bulkRetries
specifier|private
specifier|final
name|long
name|bulkRetries
decl_stmt|;
DECL|field|searchRetries
specifier|private
specifier|final
name|long
name|searchRetries
decl_stmt|;
DECL|field|throttled
specifier|private
specifier|final
name|TimeValue
name|throttled
decl_stmt|;
DECL|field|requestsPerSecond
specifier|private
specifier|final
name|float
name|requestsPerSecond
decl_stmt|;
DECL|field|reasonCancelled
specifier|private
specifier|final
name|String
name|reasonCancelled
decl_stmt|;
DECL|field|throttledUntil
specifier|private
specifier|final
name|TimeValue
name|throttledUntil
decl_stmt|;
DECL|field|sliceStatuses
specifier|private
specifier|final
name|List
argument_list|<
name|StatusOrException
argument_list|>
name|sliceStatuses
decl_stmt|;
DECL|method|Status
specifier|public
name|Status
parameter_list|(
name|Integer
name|sliceId
parameter_list|,
name|long
name|total
parameter_list|,
name|long
name|updated
parameter_list|,
name|long
name|created
parameter_list|,
name|long
name|deleted
parameter_list|,
name|int
name|batches
parameter_list|,
name|long
name|versionConflicts
parameter_list|,
name|long
name|noops
parameter_list|,
name|long
name|bulkRetries
parameter_list|,
name|long
name|searchRetries
parameter_list|,
name|TimeValue
name|throttled
parameter_list|,
name|float
name|requestsPerSecond
parameter_list|,
annotation|@
name|Nullable
name|String
name|reasonCancelled
parameter_list|,
name|TimeValue
name|throttledUntil
parameter_list|)
block|{
name|this
operator|.
name|sliceId
operator|=
name|sliceId
operator|==
literal|null
condition|?
literal|null
else|:
name|checkPositive
argument_list|(
name|sliceId
argument_list|,
literal|"sliceId"
argument_list|)
expr_stmt|;
name|this
operator|.
name|total
operator|=
name|checkPositive
argument_list|(
name|total
argument_list|,
literal|"total"
argument_list|)
expr_stmt|;
name|this
operator|.
name|updated
operator|=
name|checkPositive
argument_list|(
name|updated
argument_list|,
literal|"updated"
argument_list|)
expr_stmt|;
name|this
operator|.
name|created
operator|=
name|checkPositive
argument_list|(
name|created
argument_list|,
literal|"created"
argument_list|)
expr_stmt|;
name|this
operator|.
name|deleted
operator|=
name|checkPositive
argument_list|(
name|deleted
argument_list|,
literal|"deleted"
argument_list|)
expr_stmt|;
name|this
operator|.
name|batches
operator|=
name|checkPositive
argument_list|(
name|batches
argument_list|,
literal|"batches"
argument_list|)
expr_stmt|;
name|this
operator|.
name|versionConflicts
operator|=
name|checkPositive
argument_list|(
name|versionConflicts
argument_list|,
literal|"versionConflicts"
argument_list|)
expr_stmt|;
name|this
operator|.
name|noops
operator|=
name|checkPositive
argument_list|(
name|noops
argument_list|,
literal|"noops"
argument_list|)
expr_stmt|;
name|this
operator|.
name|bulkRetries
operator|=
name|checkPositive
argument_list|(
name|bulkRetries
argument_list|,
literal|"bulkRetries"
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchRetries
operator|=
name|checkPositive
argument_list|(
name|searchRetries
argument_list|,
literal|"searchRetries"
argument_list|)
expr_stmt|;
name|this
operator|.
name|throttled
operator|=
name|throttled
expr_stmt|;
name|this
operator|.
name|requestsPerSecond
operator|=
name|requestsPerSecond
expr_stmt|;
name|this
operator|.
name|reasonCancelled
operator|=
name|reasonCancelled
expr_stmt|;
name|this
operator|.
name|throttledUntil
operator|=
name|throttledUntil
expr_stmt|;
name|this
operator|.
name|sliceStatuses
operator|=
name|emptyList
argument_list|()
expr_stmt|;
block|}
comment|/**          * Constructor merging many statuses.          *          * @param sliceStatuses Statuses of sub requests that this task was sliced into.          * @param reasonCancelled Reason that this *this* task was cancelled. Note that each entry in {@code sliceStatuses} can be cancelled          *        independently of this task but if this task is cancelled then the workers *should* be cancelled.          */
DECL|method|Status
specifier|public
name|Status
parameter_list|(
name|List
argument_list|<
name|StatusOrException
argument_list|>
name|sliceStatuses
parameter_list|,
annotation|@
name|Nullable
name|String
name|reasonCancelled
parameter_list|)
block|{
name|sliceId
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|reasonCancelled
operator|=
name|reasonCancelled
expr_stmt|;
name|long
name|mergedTotal
init|=
literal|0
decl_stmt|;
name|long
name|mergedUpdated
init|=
literal|0
decl_stmt|;
name|long
name|mergedCreated
init|=
literal|0
decl_stmt|;
name|long
name|mergedDeleted
init|=
literal|0
decl_stmt|;
name|int
name|mergedBatches
init|=
literal|0
decl_stmt|;
name|long
name|mergedVersionConflicts
init|=
literal|0
decl_stmt|;
name|long
name|mergedNoops
init|=
literal|0
decl_stmt|;
name|long
name|mergedBulkRetries
init|=
literal|0
decl_stmt|;
name|long
name|mergedSearchRetries
init|=
literal|0
decl_stmt|;
name|long
name|mergedThrottled
init|=
literal|0
decl_stmt|;
name|float
name|mergedRequestsPerSecond
init|=
literal|0
decl_stmt|;
name|long
name|mergedThrottledUntil
init|=
name|Long
operator|.
name|MAX_VALUE
decl_stmt|;
for|for
control|(
name|StatusOrException
name|slice
range|:
name|sliceStatuses
control|)
block|{
if|if
condition|(
name|slice
operator|==
literal|null
condition|)
block|{
comment|// Hasn't returned yet.
continue|continue;
block|}
if|if
condition|(
name|slice
operator|.
name|status
operator|==
literal|null
condition|)
block|{
comment|// This slice failed catastrophically so it doesn't count towards the status
continue|continue;
block|}
name|mergedTotal
operator|+=
name|slice
operator|.
name|status
operator|.
name|getTotal
argument_list|()
expr_stmt|;
name|mergedUpdated
operator|+=
name|slice
operator|.
name|status
operator|.
name|getUpdated
argument_list|()
expr_stmt|;
name|mergedCreated
operator|+=
name|slice
operator|.
name|status
operator|.
name|getCreated
argument_list|()
expr_stmt|;
name|mergedDeleted
operator|+=
name|slice
operator|.
name|status
operator|.
name|getDeleted
argument_list|()
expr_stmt|;
name|mergedBatches
operator|+=
name|slice
operator|.
name|status
operator|.
name|getBatches
argument_list|()
expr_stmt|;
name|mergedVersionConflicts
operator|+=
name|slice
operator|.
name|status
operator|.
name|getVersionConflicts
argument_list|()
expr_stmt|;
name|mergedNoops
operator|+=
name|slice
operator|.
name|status
operator|.
name|getNoops
argument_list|()
expr_stmt|;
name|mergedBulkRetries
operator|+=
name|slice
operator|.
name|status
operator|.
name|getBulkRetries
argument_list|()
expr_stmt|;
name|mergedSearchRetries
operator|+=
name|slice
operator|.
name|status
operator|.
name|getSearchRetries
argument_list|()
expr_stmt|;
name|mergedThrottled
operator|+=
name|slice
operator|.
name|status
operator|.
name|getThrottled
argument_list|()
operator|.
name|nanos
argument_list|()
expr_stmt|;
name|mergedRequestsPerSecond
operator|+=
name|slice
operator|.
name|status
operator|.
name|getRequestsPerSecond
argument_list|()
expr_stmt|;
name|mergedThrottledUntil
operator|=
name|min
argument_list|(
name|mergedThrottledUntil
argument_list|,
name|slice
operator|.
name|status
operator|.
name|getThrottledUntil
argument_list|()
operator|.
name|nanos
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|total
operator|=
name|mergedTotal
expr_stmt|;
name|updated
operator|=
name|mergedUpdated
expr_stmt|;
name|created
operator|=
name|mergedCreated
expr_stmt|;
name|deleted
operator|=
name|mergedDeleted
expr_stmt|;
name|batches
operator|=
name|mergedBatches
expr_stmt|;
name|versionConflicts
operator|=
name|mergedVersionConflicts
expr_stmt|;
name|noops
operator|=
name|mergedNoops
expr_stmt|;
name|bulkRetries
operator|=
name|mergedBulkRetries
expr_stmt|;
name|searchRetries
operator|=
name|mergedSearchRetries
expr_stmt|;
name|throttled
operator|=
name|timeValueNanos
argument_list|(
name|mergedThrottled
argument_list|)
expr_stmt|;
name|requestsPerSecond
operator|=
name|mergedRequestsPerSecond
expr_stmt|;
name|throttledUntil
operator|=
name|timeValueNanos
argument_list|(
name|mergedThrottledUntil
operator|==
name|Long
operator|.
name|MAX_VALUE
condition|?
literal|0
else|:
name|mergedThrottledUntil
argument_list|)
expr_stmt|;
name|this
operator|.
name|sliceStatuses
operator|=
name|sliceStatuses
expr_stmt|;
block|}
DECL|method|Status
specifier|public
name|Status
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_5_1_0_UNRELEASED
argument_list|)
condition|)
block|{
name|sliceId
operator|=
name|in
operator|.
name|readOptionalVInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|sliceId
operator|=
literal|null
expr_stmt|;
block|}
name|total
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|updated
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|created
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|deleted
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|batches
operator|=
name|in
operator|.
name|readVInt
argument_list|()
expr_stmt|;
name|versionConflicts
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|noops
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|bulkRetries
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|searchRetries
operator|=
name|in
operator|.
name|readVLong
argument_list|()
expr_stmt|;
name|throttled
operator|=
operator|new
name|TimeValue
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|requestsPerSecond
operator|=
name|in
operator|.
name|readFloat
argument_list|()
expr_stmt|;
name|reasonCancelled
operator|=
name|in
operator|.
name|readOptionalString
argument_list|()
expr_stmt|;
name|throttledUntil
operator|=
operator|new
name|TimeValue
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_5_1_0_UNRELEASED
argument_list|)
condition|)
block|{
name|sliceStatuses
operator|=
name|in
operator|.
name|readList
argument_list|(
name|stream
lambda|->
name|stream
operator|.
name|readOptionalWriteable
argument_list|(
name|StatusOrException
operator|::
operator|new
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sliceStatuses
operator|=
name|emptyList
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|out
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_5_1_0_UNRELEASED
argument_list|)
condition|)
block|{
name|out
operator|.
name|writeOptionalVInt
argument_list|(
name|sliceId
argument_list|)
expr_stmt|;
block|}
name|out
operator|.
name|writeVLong
argument_list|(
name|total
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|updated
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|created
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|deleted
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVInt
argument_list|(
name|batches
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|versionConflicts
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|noops
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|bulkRetries
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeVLong
argument_list|(
name|searchRetries
argument_list|)
expr_stmt|;
name|throttled
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeFloat
argument_list|(
name|requestsPerSecond
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeOptionalString
argument_list|(
name|reasonCancelled
argument_list|)
expr_stmt|;
name|throttledUntil
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|.
name|getVersion
argument_list|()
operator|.
name|onOrAfter
argument_list|(
name|Version
operator|.
name|V_5_1_0_UNRELEASED
argument_list|)
condition|)
block|{
name|out
operator|.
name|writeVInt
argument_list|(
name|sliceStatuses
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|StatusOrException
name|sliceStatus
range|:
name|sliceStatuses
control|)
block|{
name|out
operator|.
name|writeOptionalWriteable
argument_list|(
name|sliceStatus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|Override
DECL|method|getWriteableName
specifier|public
name|String
name|getWriteableName
parameter_list|()
block|{
return|return
name|NAME
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
name|innerXContent
argument_list|(
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|endObject
argument_list|()
return|;
block|}
DECL|method|innerXContent
specifier|public
name|XContentBuilder
name|innerXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|sliceId
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"slice_id"
argument_list|,
name|sliceId
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|field
argument_list|(
literal|"total"
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|paramAsBoolean
argument_list|(
name|INCLUDE_UPDATED
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"updated"
argument_list|,
name|updated
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|params
operator|.
name|paramAsBoolean
argument_list|(
name|INCLUDE_CREATED
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"created"
argument_list|,
name|created
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|field
argument_list|(
literal|"deleted"
argument_list|,
name|deleted
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"batches"
argument_list|,
name|batches
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"version_conflicts"
argument_list|,
name|versionConflicts
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"noops"
argument_list|,
name|noops
argument_list|)
expr_stmt|;
name|builder
operator|.
name|startObject
argument_list|(
literal|"retries"
argument_list|)
expr_stmt|;
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"bulk"
argument_list|,
name|bulkRetries
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"search"
argument_list|,
name|searchRetries
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
name|builder
operator|.
name|timeValueField
argument_list|(
literal|"throttled_millis"
argument_list|,
literal|"throttled"
argument_list|,
name|throttled
argument_list|)
expr_stmt|;
name|builder
operator|.
name|field
argument_list|(
literal|"requests_per_second"
argument_list|,
name|requestsPerSecond
operator|==
name|Float
operator|.
name|POSITIVE_INFINITY
condition|?
operator|-
literal|1
else|:
name|requestsPerSecond
argument_list|)
expr_stmt|;
if|if
condition|(
name|reasonCancelled
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|field
argument_list|(
literal|"canceled"
argument_list|,
name|reasonCancelled
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|timeValueField
argument_list|(
literal|"throttled_until_millis"
argument_list|,
literal|"throttled_until"
argument_list|,
name|throttledUntil
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
operator|==
name|sliceStatuses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|startArray
argument_list|(
literal|"slices"
argument_list|)
expr_stmt|;
for|for
control|(
name|StatusOrException
name|slice
range|:
name|sliceStatuses
control|)
block|{
if|if
condition|(
name|slice
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|nullValue
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|slice
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
block|}
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|builder
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|"BulkIndexByScrollResponse["
argument_list|)
expr_stmt|;
name|innerToString
argument_list|(
name|builder
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|innerToString
specifier|public
name|void
name|innerToString
parameter_list|(
name|StringBuilder
name|builder
parameter_list|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|"sliceId="
argument_list|)
operator|.
name|append
argument_list|(
name|sliceId
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|",updated="
argument_list|)
operator|.
name|append
argument_list|(
name|updated
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|",created="
argument_list|)
operator|.
name|append
argument_list|(
name|created
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|",deleted="
argument_list|)
operator|.
name|append
argument_list|(
name|deleted
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|",batches="
argument_list|)
operator|.
name|append
argument_list|(
name|batches
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|",versionConflicts="
argument_list|)
operator|.
name|append
argument_list|(
name|versionConflicts
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|",noops="
argument_list|)
operator|.
name|append
argument_list|(
name|noops
argument_list|)
expr_stmt|;
name|builder
operator|.
name|append
argument_list|(
literal|",retries="
argument_list|)
operator|.
name|append
argument_list|(
name|bulkRetries
argument_list|)
expr_stmt|;
if|if
condition|(
name|reasonCancelled
operator|!=
literal|null
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|",canceled="
argument_list|)
operator|.
name|append
argument_list|(
name|reasonCancelled
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|append
argument_list|(
literal|",throttledUntil="
argument_list|)
operator|.
name|append
argument_list|(
name|throttledUntil
argument_list|)
expr_stmt|;
if|if
condition|(
literal|false
operator|==
name|sliceStatuses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|builder
operator|.
name|append
argument_list|(
literal|",workers="
argument_list|)
operator|.
name|append
argument_list|(
name|sliceStatuses
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * The id of the slice that this status is reporting or {@code null} if this isn't the status of a sub-slice.          */
DECL|method|getSliceId
name|Integer
name|getSliceId
parameter_list|()
block|{
return|return
name|sliceId
return|;
block|}
comment|/**          * The total number of documents this request will process. 0 means we don't yet know or, possibly, there are actually 0 documents          * to process. Its ok that these have the same meaning because any request with 0 actual documents should be quite short lived.          */
DECL|method|getTotal
specifier|public
name|long
name|getTotal
parameter_list|()
block|{
return|return
name|total
return|;
block|}
annotation|@
name|Override
DECL|method|getUpdated
specifier|public
name|long
name|getUpdated
parameter_list|()
block|{
return|return
name|updated
return|;
block|}
annotation|@
name|Override
DECL|method|getCreated
specifier|public
name|long
name|getCreated
parameter_list|()
block|{
return|return
name|created
return|;
block|}
annotation|@
name|Override
DECL|method|getDeleted
specifier|public
name|long
name|getDeleted
parameter_list|()
block|{
return|return
name|deleted
return|;
block|}
comment|/**          * Number of scan responses this request has processed.          */
DECL|method|getBatches
specifier|public
name|int
name|getBatches
parameter_list|()
block|{
return|return
name|batches
return|;
block|}
comment|/**          * Number of version conflicts this request has hit.          */
DECL|method|getVersionConflicts
specifier|public
name|long
name|getVersionConflicts
parameter_list|()
block|{
return|return
name|versionConflicts
return|;
block|}
comment|/**          * Number of noops (skipped bulk items) as part of this request.          */
DECL|method|getNoops
specifier|public
name|long
name|getNoops
parameter_list|()
block|{
return|return
name|noops
return|;
block|}
comment|/**          * Number of retries that had to be attempted due to bulk actions being rejected.          */
DECL|method|getBulkRetries
specifier|public
name|long
name|getBulkRetries
parameter_list|()
block|{
return|return
name|bulkRetries
return|;
block|}
comment|/**          * Number of retries that had to be attempted due to search actions being rejected.          */
DECL|method|getSearchRetries
specifier|public
name|long
name|getSearchRetries
parameter_list|()
block|{
return|return
name|searchRetries
return|;
block|}
comment|/**          * The total time this request has throttled itself not including the current throttle time if it is currently sleeping.          */
DECL|method|getThrottled
specifier|public
name|TimeValue
name|getThrottled
parameter_list|()
block|{
return|return
name|throttled
return|;
block|}
comment|/**          * The number of requests per second to which to throttle the request. Float.POSITIVE_INFINITY means unlimited.          */
DECL|method|getRequestsPerSecond
specifier|public
name|float
name|getRequestsPerSecond
parameter_list|()
block|{
return|return
name|requestsPerSecond
return|;
block|}
comment|/**          * The reason that the request was canceled or null if it hasn't been.          */
DECL|method|getReasonCancelled
specifier|public
name|String
name|getReasonCancelled
parameter_list|()
block|{
return|return
name|reasonCancelled
return|;
block|}
comment|/**          * Remaining delay of any current throttle sleep or 0 if not sleeping.          */
DECL|method|getThrottledUntil
specifier|public
name|TimeValue
name|getThrottledUntil
parameter_list|()
block|{
return|return
name|throttledUntil
return|;
block|}
comment|/**          * Statuses of the sub requests into which this sub-request was sliced. Empty if this request wasn't sliced into sub-requests.          */
DECL|method|getSliceStatuses
specifier|public
name|List
argument_list|<
name|StatusOrException
argument_list|>
name|getSliceStatuses
parameter_list|()
block|{
return|return
name|sliceStatuses
return|;
block|}
DECL|method|checkPositive
specifier|private
name|int
name|checkPositive
parameter_list|(
name|int
name|value
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|name
operator|+
literal|" must be greater than 0 but was ["
operator|+
name|value
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
DECL|method|checkPositive
specifier|private
name|long
name|checkPositive
parameter_list|(
name|long
name|value
parameter_list|,
name|String
name|name
parameter_list|)
block|{
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
name|name
operator|+
literal|" must be greater than 0 but was ["
operator|+
name|value
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|value
return|;
block|}
block|}
comment|/**      * The status of a slice of the request. Successful requests store the {@link StatusOrException#status} while failing requests store a      * {@link StatusOrException#exception}.      */
DECL|class|StatusOrException
specifier|public
specifier|static
class|class
name|StatusOrException
implements|implements
name|Writeable
implements|,
name|ToXContent
block|{
DECL|field|status
specifier|private
specifier|final
name|Status
name|status
decl_stmt|;
DECL|field|exception
specifier|private
specifier|final
name|Exception
name|exception
decl_stmt|;
DECL|method|StatusOrException
specifier|public
name|StatusOrException
parameter_list|(
name|Status
name|status
parameter_list|)
block|{
name|this
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|exception
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|StatusOrException
specifier|public
name|StatusOrException
parameter_list|(
name|Exception
name|exception
parameter_list|)
block|{
name|status
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|exception
operator|=
name|exception
expr_stmt|;
block|}
comment|/**          * Read from a stream.          */
DECL|method|StatusOrException
specifier|public
name|StatusOrException
parameter_list|(
name|StreamInput
name|in
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|in
operator|.
name|readBoolean
argument_list|()
condition|)
block|{
name|status
operator|=
operator|new
name|Status
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|exception
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
literal|null
expr_stmt|;
name|exception
operator|=
name|in
operator|.
name|readException
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|writeTo
specifier|public
name|void
name|writeTo
parameter_list|(
name|StreamOutput
name|out
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|exception
operator|==
literal|null
condition|)
block|{
name|out
operator|.
name|writeBoolean
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|status
operator|.
name|writeTo
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|out
operator|.
name|writeBoolean
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|out
operator|.
name|writeException
argument_list|(
name|exception
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|getStatus
specifier|public
name|Status
name|getStatus
parameter_list|()
block|{
return|return
name|status
return|;
block|}
DECL|method|getException
specifier|public
name|Exception
name|getException
parameter_list|()
block|{
return|return
name|exception
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|exception
operator|==
literal|null
condition|)
block|{
name|status
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|startObject
argument_list|()
expr_stmt|;
name|ElasticsearchException
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|params
argument_list|,
name|exception
argument_list|)
expr_stmt|;
name|builder
operator|.
name|endObject
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
name|obj
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|obj
operator|.
name|getClass
argument_list|()
operator|!=
name|BulkByScrollTask
operator|.
name|StatusOrException
operator|.
name|class
condition|)
block|{
return|return
literal|false
return|;
block|}
name|BulkByScrollTask
operator|.
name|StatusOrException
name|other
init|=
operator|(
name|StatusOrException
operator|)
name|obj
decl_stmt|;
return|return
name|Objects
operator|.
name|equals
argument_list|(
name|status
argument_list|,
name|other
operator|.
name|status
argument_list|)
operator|&&
name|Objects
operator|.
name|equals
argument_list|(
name|exception
argument_list|,
name|other
operator|.
name|exception
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|Objects
operator|.
name|hash
argument_list|(
name|status
argument_list|,
name|exception
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

