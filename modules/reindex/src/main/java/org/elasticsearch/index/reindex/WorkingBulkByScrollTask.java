begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.reindex
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|reindex
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|logging
operator|.
name|log4j
operator|.
name|Logger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRunnable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|TaskId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|tasks
operator|.
name|TaskInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicBoolean
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|max
import|;
end_import

begin_import
import|import static
name|java
operator|.
name|lang
operator|.
name|Math
operator|.
name|round
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
operator|.
name|timeValueNanos
import|;
end_import

begin_comment
comment|/**  * {@link BulkByScrollTask} subclass for tasks that actually perform the work. Compare to {@link ParentBulkByScrollTask}.  */
end_comment

begin_class
DECL|class|WorkingBulkByScrollTask
specifier|public
class|class
name|WorkingBulkByScrollTask
extends|extends
name|BulkByScrollTask
implements|implements
name|SuccessfullyProcessed
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|Logger
name|logger
init|=
name|ESLoggerFactory
operator|.
name|getLogger
argument_list|(
name|BulkByScrollTask
operator|.
name|class
operator|.
name|getPackage
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
comment|/**      * The id of the slice that this task is processing or {@code null} if this task isn't for a sliced request.      */
DECL|field|sliceId
specifier|private
specifier|final
name|Integer
name|sliceId
decl_stmt|;
comment|/**      * The total number of documents this request will process. 0 means we don't yet know or, possibly, there are actually 0 documents      * to process. Its ok that these have the same meaning because any request with 0 actual documents should be quite short lived.      */
DECL|field|total
specifier|private
specifier|final
name|AtomicLong
name|total
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|updated
specifier|private
specifier|final
name|AtomicLong
name|updated
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|created
specifier|private
specifier|final
name|AtomicLong
name|created
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|deleted
specifier|private
specifier|final
name|AtomicLong
name|deleted
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|noops
specifier|private
specifier|final
name|AtomicLong
name|noops
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|batch
specifier|private
specifier|final
name|AtomicInteger
name|batch
init|=
operator|new
name|AtomicInteger
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|versionConflicts
specifier|private
specifier|final
name|AtomicLong
name|versionConflicts
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|bulkRetries
specifier|private
specifier|final
name|AtomicLong
name|bulkRetries
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|searchRetries
specifier|private
specifier|final
name|AtomicLong
name|searchRetries
init|=
operator|new
name|AtomicLong
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|throttledNanos
specifier|private
specifier|final
name|AtomicLong
name|throttledNanos
init|=
operator|new
name|AtomicLong
argument_list|()
decl_stmt|;
comment|/**      * The number of requests per second to which to throttle the request that this task represents. The other variables are all AtomicXXX      * style variables but there isn't an AtomicFloat so we just use a volatile.      */
DECL|field|requestsPerSecond
specifier|private
specifier|volatile
name|float
name|requestsPerSecond
decl_stmt|;
comment|/**      * Reference to any the last delayed prepareBulkRequest call. Used during rethrottling and canceling to reschedule the request.      */
DECL|field|delayedPrepareBulkRequestReference
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|DelayedPrepareBulkRequest
argument_list|>
name|delayedPrepareBulkRequestReference
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|method|WorkingBulkByScrollTask
specifier|public
name|WorkingBulkByScrollTask
parameter_list|(
name|long
name|id
parameter_list|,
name|String
name|type
parameter_list|,
name|String
name|action
parameter_list|,
name|String
name|description
parameter_list|,
name|TaskId
name|parentTask
parameter_list|,
name|Integer
name|sliceId
parameter_list|,
name|float
name|requestsPerSecond
parameter_list|)
block|{
name|super
argument_list|(
name|id
argument_list|,
name|type
argument_list|,
name|action
argument_list|,
name|description
argument_list|,
name|parentTask
argument_list|)
expr_stmt|;
name|this
operator|.
name|sliceId
operator|=
name|sliceId
expr_stmt|;
name|setRequestsPerSecond
argument_list|(
name|requestsPerSecond
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getStatus
specifier|public
name|Status
name|getStatus
parameter_list|()
block|{
return|return
operator|new
name|Status
argument_list|(
name|sliceId
argument_list|,
name|total
operator|.
name|get
argument_list|()
argument_list|,
name|updated
operator|.
name|get
argument_list|()
argument_list|,
name|created
operator|.
name|get
argument_list|()
argument_list|,
name|deleted
operator|.
name|get
argument_list|()
argument_list|,
name|batch
operator|.
name|get
argument_list|()
argument_list|,
name|versionConflicts
operator|.
name|get
argument_list|()
argument_list|,
name|noops
operator|.
name|get
argument_list|()
argument_list|,
name|bulkRetries
operator|.
name|get
argument_list|()
argument_list|,
name|searchRetries
operator|.
name|get
argument_list|()
argument_list|,
name|timeValueNanos
argument_list|(
name|throttledNanos
operator|.
name|get
argument_list|()
argument_list|)
argument_list|,
name|getRequestsPerSecond
argument_list|()
argument_list|,
name|getReasonCancelled
argument_list|()
argument_list|,
name|throttledUntil
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|onCancelled
specifier|protected
name|void
name|onCancelled
parameter_list|()
block|{
comment|// Drop the throttle to 0, immediately rescheduling all outstanding tasks so the task will wake up and cancel itself.
name|rethrottle
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|runningSliceSubTasks
name|int
name|runningSliceSubTasks
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
annotation|@
name|Override
DECL|method|getInfoGivenSliceInfo
specifier|public
name|TaskInfo
name|getInfoGivenSliceInfo
parameter_list|(
name|String
name|localNodeId
parameter_list|,
name|List
argument_list|<
name|TaskInfo
argument_list|>
name|sliceInfo
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"This is only supported by "
operator|+
name|ParentBulkByScrollTask
operator|.
name|class
operator|.
name|getName
argument_list|()
operator|+
literal|"."
argument_list|)
throw|;
block|}
DECL|method|throttledUntil
name|TimeValue
name|throttledUntil
parameter_list|()
block|{
name|DelayedPrepareBulkRequest
name|delayed
init|=
name|delayedPrepareBulkRequestReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|delayed
operator|==
literal|null
condition|)
block|{
return|return
name|timeValueNanos
argument_list|(
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|delayed
operator|.
name|future
operator|==
literal|null
condition|)
block|{
return|return
name|timeValueNanos
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|timeValueNanos
argument_list|(
name|max
argument_list|(
literal|0
argument_list|,
name|delayed
operator|.
name|future
operator|.
name|getDelay
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
DECL|method|setTotal
name|void
name|setTotal
parameter_list|(
name|long
name|totalHits
parameter_list|)
block|{
name|total
operator|.
name|set
argument_list|(
name|totalHits
argument_list|)
expr_stmt|;
block|}
DECL|method|countBatch
name|void
name|countBatch
parameter_list|()
block|{
name|batch
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|countNoop
name|void
name|countNoop
parameter_list|()
block|{
name|noops
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getCreated
specifier|public
name|long
name|getCreated
parameter_list|()
block|{
return|return
name|created
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|countCreated
name|void
name|countCreated
parameter_list|()
block|{
name|created
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getUpdated
specifier|public
name|long
name|getUpdated
parameter_list|()
block|{
return|return
name|updated
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|countUpdated
name|void
name|countUpdated
parameter_list|()
block|{
name|updated
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getDeleted
specifier|public
name|long
name|getDeleted
parameter_list|()
block|{
return|return
name|deleted
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|countDeleted
name|void
name|countDeleted
parameter_list|()
block|{
name|deleted
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|countVersionConflict
name|void
name|countVersionConflict
parameter_list|()
block|{
name|versionConflicts
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|countBulkRetry
name|void
name|countBulkRetry
parameter_list|()
block|{
name|bulkRetries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|countSearchRetry
name|void
name|countSearchRetry
parameter_list|()
block|{
name|searchRetries
operator|.
name|incrementAndGet
argument_list|()
expr_stmt|;
block|}
DECL|method|getRequestsPerSecond
name|float
name|getRequestsPerSecond
parameter_list|()
block|{
return|return
name|requestsPerSecond
return|;
block|}
comment|/**      * Schedule prepareBulkRequestRunnable to run after some delay. This is where throttling plugs into reindexing so the request can be      * rescheduled over and over again.      */
DECL|method|delayPrepareBulkRequest
name|void
name|delayPrepareBulkRequest
parameter_list|(
name|ThreadPool
name|threadPool
parameter_list|,
name|TimeValue
name|lastBatchStartTime
parameter_list|,
name|int
name|lastBatchSize
parameter_list|,
name|AbstractRunnable
name|prepareBulkRequestRunnable
parameter_list|)
block|{
comment|// Synchronize so we are less likely to schedule the same request twice.
synchronized|synchronized
init|(
name|delayedPrepareBulkRequestReference
init|)
block|{
name|TimeValue
name|delay
init|=
name|throttleWaitTime
argument_list|(
name|lastBatchStartTime
argument_list|,
name|lastBatchSize
argument_list|)
decl_stmt|;
name|delayedPrepareBulkRequestReference
operator|.
name|set
argument_list|(
operator|new
name|DelayedPrepareBulkRequest
argument_list|(
name|threadPool
argument_list|,
name|getRequestsPerSecond
argument_list|()
argument_list|,
name|delay
argument_list|,
operator|new
name|RunOnce
argument_list|(
name|prepareBulkRequestRunnable
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|throttleWaitTime
name|TimeValue
name|throttleWaitTime
parameter_list|(
name|TimeValue
name|lastBatchStartTime
parameter_list|,
name|int
name|lastBatchSize
parameter_list|)
block|{
name|long
name|earliestNextBatchStartTime
init|=
name|lastBatchStartTime
operator|.
name|nanos
argument_list|()
operator|+
operator|(
name|long
operator|)
name|perfectlyThrottledBatchTime
argument_list|(
name|lastBatchSize
argument_list|)
decl_stmt|;
return|return
name|timeValueNanos
argument_list|(
name|max
argument_list|(
literal|0
argument_list|,
name|earliestNextBatchStartTime
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * How many nanoseconds should a batch of lastBatchSize have taken if it were perfectly throttled? Package private for testing.      */
DECL|method|perfectlyThrottledBatchTime
name|float
name|perfectlyThrottledBatchTime
parameter_list|(
name|int
name|lastBatchSize
parameter_list|)
block|{
if|if
condition|(
name|requestsPerSecond
operator|==
name|Float
operator|.
name|POSITIVE_INFINITY
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|//       requests
comment|// ------------------- == seconds
comment|// request per seconds
name|float
name|targetBatchTimeInSeconds
init|=
name|lastBatchSize
operator|/
name|requestsPerSecond
decl_stmt|;
comment|// nanoseconds per seconds * seconds == nanoseconds
return|return
name|TimeUnit
operator|.
name|SECONDS
operator|.
name|toNanos
argument_list|(
literal|1
argument_list|)
operator|*
name|targetBatchTimeInSeconds
return|;
block|}
DECL|method|setRequestsPerSecond
specifier|private
name|void
name|setRequestsPerSecond
parameter_list|(
name|float
name|requestsPerSecond
parameter_list|)
block|{
name|this
operator|.
name|requestsPerSecond
operator|=
name|requestsPerSecond
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|rethrottle
name|void
name|rethrottle
parameter_list|(
name|float
name|newRequestsPerSecond
parameter_list|)
block|{
synchronized|synchronized
init|(
name|delayedPrepareBulkRequestReference
init|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}]: Rethrottling to [{}] requests per second"
argument_list|,
name|getId
argument_list|()
argument_list|,
name|newRequestsPerSecond
argument_list|)
expr_stmt|;
block|}
name|setRequestsPerSecond
argument_list|(
name|newRequestsPerSecond
argument_list|)
expr_stmt|;
name|DelayedPrepareBulkRequest
name|delayedPrepareBulkRequest
init|=
name|this
operator|.
name|delayedPrepareBulkRequestReference
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
name|delayedPrepareBulkRequest
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}]: Skipping rescheduling because there is no scheduled task"
argument_list|,
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// No request has been queued yet so nothing to reschedule.
return|return;
block|}
name|this
operator|.
name|delayedPrepareBulkRequestReference
operator|.
name|set
argument_list|(
name|delayedPrepareBulkRequest
operator|.
name|rethrottle
argument_list|(
name|newRequestsPerSecond
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|DelayedPrepareBulkRequest
class|class
name|DelayedPrepareBulkRequest
block|{
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|command
specifier|private
specifier|final
name|AbstractRunnable
name|command
decl_stmt|;
DECL|field|requestsPerSecond
specifier|private
specifier|final
name|float
name|requestsPerSecond
decl_stmt|;
DECL|field|future
specifier|private
specifier|final
name|ScheduledFuture
argument_list|<
name|?
argument_list|>
name|future
decl_stmt|;
DECL|method|DelayedPrepareBulkRequest
name|DelayedPrepareBulkRequest
parameter_list|(
name|ThreadPool
name|threadPool
parameter_list|,
name|float
name|requestsPerSecond
parameter_list|,
name|TimeValue
name|delay
parameter_list|,
name|AbstractRunnable
name|command
parameter_list|)
block|{
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|requestsPerSecond
operator|=
name|requestsPerSecond
expr_stmt|;
name|this
operator|.
name|command
operator|=
name|command
expr_stmt|;
name|this
operator|.
name|future
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|delay
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|GENERIC
argument_list|,
operator|new
name|AbstractRunnable
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
name|throttledNanos
operator|.
name|addAndGet
argument_list|(
name|delay
operator|.
name|nanos
argument_list|()
argument_list|)
expr_stmt|;
name|command
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|command
operator|.
name|onFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
DECL|method|rethrottle
name|DelayedPrepareBulkRequest
name|rethrottle
parameter_list|(
name|float
name|newRequestsPerSecond
parameter_list|)
block|{
if|if
condition|(
name|newRequestsPerSecond
operator|!=
literal|0
operator|&&
name|newRequestsPerSecond
operator|<
name|requestsPerSecond
condition|)
block|{
comment|/*                  * The user is attempting to slow the request down. We'll let the change in throttle take effect the next time we delay                  * prepareBulkRequest. We can't just reschedule the request further out in the future the bulk context might time out.                  */
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}]: Skipping rescheduling because the new throttle [{}] is slower than the old one [{}]."
argument_list|,
name|getId
argument_list|()
argument_list|,
name|newRequestsPerSecond
argument_list|,
name|requestsPerSecond
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
name|long
name|remainingDelay
init|=
name|future
operator|.
name|getDelay
argument_list|(
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
decl_stmt|;
comment|// Actually reschedule the task
if|if
condition|(
literal|false
operator|==
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|future
argument_list|)
condition|)
block|{
comment|// Couldn't cancel, probably because the task has finished or been scheduled. Either way we have nothing to do here.
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}]: Skipping rescheduling we couldn't cancel the task."
argument_list|,
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
comment|/*              * Strangely enough getting here doesn't mean that you actually cancelled the request, just that you probably did. If you stress              * test it you'll find that requests sneak through. So each request is given a runOnce boolean to prevent that.              */
name|TimeValue
name|newDelay
init|=
name|newDelay
argument_list|(
name|remainingDelay
argument_list|,
name|newRequestsPerSecond
argument_list|)
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}]: Rescheduling for [{}] in the future."
argument_list|,
name|getId
argument_list|()
argument_list|,
name|newDelay
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|DelayedPrepareBulkRequest
argument_list|(
name|threadPool
argument_list|,
name|requestsPerSecond
argument_list|,
name|newDelay
argument_list|,
name|command
argument_list|)
return|;
block|}
comment|/**          * Scale back remaining delay to fit the new delay.          */
DECL|method|newDelay
name|TimeValue
name|newDelay
parameter_list|(
name|long
name|remainingDelay
parameter_list|,
name|float
name|newRequestsPerSecond
parameter_list|)
block|{
if|if
condition|(
name|remainingDelay
operator|<
literal|0
operator|||
name|newRequestsPerSecond
operator|==
literal|0
condition|)
block|{
return|return
name|timeValueNanos
argument_list|(
literal|0
argument_list|)
return|;
block|}
return|return
name|timeValueNanos
argument_list|(
name|round
argument_list|(
name|remainingDelay
operator|*
name|requestsPerSecond
operator|/
name|newRequestsPerSecond
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/**      * Runnable that can only be run one time. This is paranoia to prevent furiously rethrottling from running the command multiple times.      * Without it the command would be run multiple times.      */
DECL|class|RunOnce
specifier|private
specifier|static
class|class
name|RunOnce
extends|extends
name|AbstractRunnable
block|{
DECL|field|hasRun
specifier|private
specifier|final
name|AtomicBoolean
name|hasRun
init|=
operator|new
name|AtomicBoolean
argument_list|(
literal|false
argument_list|)
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
name|AbstractRunnable
name|delegate
decl_stmt|;
DECL|method|RunOnce
specifier|public
name|RunOnce
parameter_list|(
name|AbstractRunnable
name|delegate
parameter_list|)
block|{
name|this
operator|.
name|delegate
operator|=
name|delegate
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doRun
specifier|protected
name|void
name|doRun
parameter_list|()
throws|throws
name|Exception
block|{
if|if
condition|(
name|hasRun
operator|.
name|compareAndSet
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
condition|)
block|{
name|delegate
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|onFailure
specifier|public
name|void
name|onFailure
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|delegate
operator|.
name|onFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

