begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.indices.cluster
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|cluster
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntOpenHashSet
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|ObjectContainer
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|ObjectCursor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchIllegalStateException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterChangedEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterStateListener
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|NodeIndexDeletedAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|index
operator|.
name|NodeMappingRefreshAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|action
operator|.
name|shard
operator|.
name|ShardStateAction
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|AliasMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MappingMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNodes
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractLifecycleComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|CompressedString
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexShardAlreadyExistsException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexShardMissingException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|aliases
operator|.
name|IndexAlias
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|aliases
operator|.
name|IndexAliasesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|Engine
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|gateway
operator|.
name|IndexShardGatewayRecoveryException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|gateway
operator|.
name|IndexShardGatewayService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|DocumentMapper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|MapperService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|settings
operator|.
name|IndexSettingsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShard
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryFailedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryTarget
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Maps
operator|.
name|newHashMap
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
operator|.
name|detailedMessage
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|IndicesClusterStateService
specifier|public
class|class
name|IndicesClusterStateService
extends|extends
name|AbstractLifecycleComponent
argument_list|<
name|IndicesClusterStateService
argument_list|>
implements|implements
name|ClusterStateListener
block|{
DECL|field|indicesService
specifier|private
specifier|final
name|IndicesService
name|indicesService
decl_stmt|;
DECL|field|clusterService
specifier|private
specifier|final
name|ClusterService
name|clusterService
decl_stmt|;
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|recoveryTarget
specifier|private
specifier|final
name|RecoveryTarget
name|recoveryTarget
decl_stmt|;
DECL|field|shardStateAction
specifier|private
specifier|final
name|ShardStateAction
name|shardStateAction
decl_stmt|;
DECL|field|nodeIndexDeletedAction
specifier|private
specifier|final
name|NodeIndexDeletedAction
name|nodeIndexDeletedAction
decl_stmt|;
DECL|field|nodeMappingRefreshAction
specifier|private
specifier|final
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
decl_stmt|;
comment|// a map of mappings type we have seen per index due to cluster state
comment|// we need this so we won't remove types automatically created as part of the indexing process
DECL|field|seenMappings
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Tuple
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|,
name|Boolean
argument_list|>
name|seenMappings
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
comment|// a list of shards that failed during recovery
comment|// we keep track of these shards in order to prevent repeated recovery of these shards on each cluster state update
DECL|field|failedShards
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|ShardId
argument_list|,
name|FailedShard
argument_list|>
name|failedShards
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|class|FailedShard
specifier|static
class|class
name|FailedShard
block|{
DECL|field|version
specifier|public
specifier|final
name|long
name|version
decl_stmt|;
DECL|field|timestamp
specifier|public
specifier|final
name|long
name|timestamp
decl_stmt|;
DECL|method|FailedShard
name|FailedShard
parameter_list|(
name|long
name|version
parameter_list|)
block|{
name|this
operator|.
name|version
operator|=
name|version
expr_stmt|;
name|this
operator|.
name|timestamp
operator|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|failedEngineHandler
specifier|private
specifier|final
name|FailedEngineHandler
name|failedEngineHandler
init|=
operator|new
name|FailedEngineHandler
argument_list|()
decl_stmt|;
DECL|field|sendRefreshMapping
specifier|private
specifier|final
name|boolean
name|sendRefreshMapping
decl_stmt|;
annotation|@
name|Inject
DECL|method|IndicesClusterStateService
specifier|public
name|IndicesClusterStateService
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|RecoveryTarget
name|recoveryTarget
parameter_list|,
name|ShardStateAction
name|shardStateAction
parameter_list|,
name|NodeIndexDeletedAction
name|nodeIndexDeletedAction
parameter_list|,
name|NodeMappingRefreshAction
name|nodeMappingRefreshAction
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
name|this
operator|.
name|clusterService
operator|=
name|clusterService
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|recoveryTarget
operator|=
name|recoveryTarget
expr_stmt|;
name|this
operator|.
name|shardStateAction
operator|=
name|shardStateAction
expr_stmt|;
name|this
operator|.
name|nodeIndexDeletedAction
operator|=
name|nodeIndexDeletedAction
expr_stmt|;
name|this
operator|.
name|nodeMappingRefreshAction
operator|=
name|nodeMappingRefreshAction
expr_stmt|;
name|this
operator|.
name|sendRefreshMapping
operator|=
name|this
operator|.
name|settings
operator|.
name|getAsBoolean
argument_list|(
literal|"indices.cluster.send_refresh_mapping"
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStart
specifier|protected
name|void
name|doStart
parameter_list|()
throws|throws
name|ElasticsearchException
block|{
name|clusterService
operator|.
name|addFirst
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doStop
specifier|protected
name|void
name|doStop
parameter_list|()
throws|throws
name|ElasticsearchException
block|{
name|clusterService
operator|.
name|remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|doClose
specifier|protected
name|void
name|doClose
parameter_list|()
throws|throws
name|ElasticsearchException
block|{     }
annotation|@
name|Override
DECL|method|clusterChanged
specifier|public
name|void
name|clusterChanged
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|changesAllowed
argument_list|()
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|lifecycle
operator|.
name|started
argument_list|()
condition|)
block|{
return|return;
block|}
synchronized|synchronized
init|(
name|mutex
init|)
block|{
comment|// we need to clean the shards and indices we have on this node, since we
comment|// are going to recover them again once state persistence is disabled (no master / not recovered)
comment|// TODO: this feels a bit hacky here, a block disables state persistence, and then we clean the allocated shards, maybe another flag in blocks?
if|if
condition|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
condition|)
block|{
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
for|for
control|(
name|Integer
name|shardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (disabled block persistence)"
argument_list|,
name|index
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
argument_list|,
literal|"removing shard (disabled block persistence)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to remove shard (disabled block persistence)"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"cleaning index (disabled block persistence)"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|cleanFailedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyDeletedIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyNewIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyMappings
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyAliases
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyNewOrUpdatedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyDeletedShards
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applyCleanedIndices
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|applySettings
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyCleanedIndices
specifier|private
name|void
name|applyCleanedIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// handle closed indices, since they are not allocated on a node once they are closed
comment|// so applyDeletedIndices might not take them into account
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|!=
literal|null
operator|&&
name|indexMetaData
operator|.
name|state
argument_list|()
operator|==
name|IndexMetaData
operator|.
name|State
operator|.
name|CLOSE
condition|)
block|{
for|for
control|(
name|Integer
name|shardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (index is closed)"
argument_list|,
name|index
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
argument_list|,
literal|"removing shard (index is closed)"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to remove shard (index is closed)"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexService
operator|.
name|shardIds
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] cleaning index (no shards allocated)"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|// clean the index
name|removeIndex
argument_list|(
name|index
argument_list|,
literal|"removing index (no shards allocated)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyDeletedIndices
specifier|private
name|void
name|applyDeletedIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
specifier|final
name|ClusterState
name|previousState
init|=
name|event
operator|.
name|previousState
argument_list|()
decl_stmt|;
specifier|final
name|String
name|localNodeId
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
decl_stmt|;
assert|assert
name|localNodeId
operator|!=
literal|null
assert|;
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|indexMetaData
operator|.
name|isSameUUID
argument_list|(
name|indexService
operator|.
name|indexUUID
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] mismatch on index UUIDs between cluster state and local state, cleaning the index so it will be recreated"
argument_list|,
name|indexMetaData
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
name|deleteIndex
argument_list|(
name|indexMetaData
operator|.
name|index
argument_list|()
argument_list|,
literal|"mismatch on index UUIDs between cluster state and local state, cleaning the index so it will be recreated"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|String
name|index
range|:
name|event
operator|.
name|indicesDeleted
argument_list|()
control|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] cleaning index, no longer part of the metadata"
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Settings
name|indexSettings
decl_stmt|;
specifier|final
name|IndexService
name|idxService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|idxService
operator|!=
literal|null
condition|)
block|{
name|indexSettings
operator|=
name|idxService
operator|.
name|getIndexSettings
argument_list|()
expr_stmt|;
name|deleteIndex
argument_list|(
name|index
argument_list|,
literal|"index no longer part of the metadata"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|final
name|IndexMetaData
name|metaData
init|=
name|previousState
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
assert|assert
name|metaData
operator|!=
literal|null
assert|;
name|indexSettings
operator|=
name|metaData
operator|.
name|settings
argument_list|()
expr_stmt|;
name|indicesService
operator|.
name|deleteClosedIndex
argument_list|(
literal|"closed index no longer part of the metadata"
argument_list|,
name|metaData
argument_list|,
name|event
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|nodeIndexDeletedAction
operator|.
name|nodeIndexDeleted
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
name|index
argument_list|,
name|indexSettings
argument_list|,
name|localNodeId
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to send to master index {} deleted event"
argument_list|,
name|e
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|applyDeletedShards
specifier|private
name|void
name|applyDeletedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|readOnlyRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
name|IntOpenHashSet
name|newShardIds
init|=
operator|new
name|IntOpenHashSet
argument_list|()
decl_stmt|;
for|for
control|(
name|IndexService
name|indexService
range|:
name|indicesService
control|)
block|{
name|String
name|index
init|=
name|indexService
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
decl_stmt|;
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|==
literal|null
condition|)
block|{
continue|continue;
block|}
comment|// now, go over and delete shards that needs to get deleted
name|newShardIds
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|MutableShardRouting
name|shard
range|:
name|routingNode
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|index
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|newShardIds
operator|.
name|add
argument_list|(
name|shard
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|Integer
name|existingShardId
range|:
name|indexService
operator|.
name|shardIds
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|newShardIds
operator|.
name|contains
argument_list|(
name|existingShardId
argument_list|)
condition|)
block|{
if|if
condition|(
name|indexMetaData
operator|.
name|state
argument_list|()
operator|==
name|IndexMetaData
operator|.
name|State
operator|.
name|CLOSE
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (index is closed)"
argument_list|,
name|index
argument_list|,
name|existingShardId
argument_list|)
expr_stmt|;
block|}
name|indexService
operator|.
name|removeShard
argument_list|(
name|existingShardId
argument_list|,
literal|"removing shard (index is closed)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we can just remove the shard, without cleaning it locally, since we will clean it
comment|// when all shards are allocated in the IndicesStore
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (not allocated)"
argument_list|,
name|index
argument_list|,
name|existingShardId
argument_list|)
expr_stmt|;
block|}
name|indexService
operator|.
name|removeShard
argument_list|(
name|existingShardId
argument_list|,
literal|"removing shard (not allocated)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|applyNewIndices
specifier|private
name|void
name|applyNewIndices
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// we only create indices for shards that are allocated
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|readOnlyRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
return|return;
block|}
for|for
control|(
name|MutableShardRouting
name|shard
range|:
name|routingNode
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
condition|)
block|{
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] creating index"
argument_list|,
name|indexMetaData
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|indicesService
operator|.
name|createIndex
argument_list|(
name|indexMetaData
operator|.
name|index
argument_list|()
argument_list|,
name|indexMetaData
operator|.
name|settings
argument_list|()
argument_list|,
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNode
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|sendFailShard
argument_list|(
name|shard
argument_list|,
name|indexMetaData
operator|.
name|getUUID
argument_list|()
argument_list|,
literal|"failed to create index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|applySettings
specifier|private
name|void
name|applySettings
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|event
operator|.
name|metaDataChanged
argument_list|()
condition|)
block|{
return|return;
block|}
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|indexMetaData
operator|.
name|index
argument_list|()
argument_list|)
condition|)
block|{
comment|// we only create / update here
continue|continue;
block|}
comment|// if the index meta data didn't change, no need check for refreshed settings
if|if
condition|(
operator|!
name|event
operator|.
name|indexMetaDataChanged
argument_list|(
name|indexMetaData
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|String
name|index
init|=
name|indexMetaData
operator|.
name|index
argument_list|()
decl_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// already deleted on us, ignore it
continue|continue;
block|}
name|IndexSettingsService
name|indexSettingsService
init|=
name|indexService
operator|.
name|injector
argument_list|()
operator|.
name|getInstance
argument_list|(
name|IndexSettingsService
operator|.
name|class
argument_list|)
decl_stmt|;
name|indexSettingsService
operator|.
name|refreshSettings
argument_list|(
name|indexMetaData
operator|.
name|settings
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|applyMappings
specifier|private
name|void
name|applyMappings
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// go over and update mappings
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|hasIndex
argument_list|(
name|indexMetaData
operator|.
name|index
argument_list|()
argument_list|)
condition|)
block|{
comment|// we only create / update here
continue|continue;
block|}
name|List
argument_list|<
name|String
argument_list|>
name|typesToRefresh
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|String
name|index
init|=
name|indexMetaData
operator|.
name|index
argument_list|()
decl_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// got deleted on us, ignore (closing the node)
return|return;
block|}
try|try
block|{
name|MapperService
name|mapperService
init|=
name|indexService
operator|.
name|mapperService
argument_list|()
decl_stmt|;
comment|// first, go over and update the _default_ mapping (if exists)
if|if
condition|(
name|indexMetaData
operator|.
name|mappings
argument_list|()
operator|.
name|containsKey
argument_list|(
name|MapperService
operator|.
name|DEFAULT_MAPPING
argument_list|)
condition|)
block|{
name|boolean
name|requireRefresh
init|=
name|processMapping
argument_list|(
name|index
argument_list|,
name|mapperService
argument_list|,
name|MapperService
operator|.
name|DEFAULT_MAPPING
argument_list|,
name|indexMetaData
operator|.
name|mapping
argument_list|(
name|MapperService
operator|.
name|DEFAULT_MAPPING
argument_list|)
operator|.
name|source
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|requireRefresh
condition|)
block|{
name|typesToRefresh
operator|.
name|add
argument_list|(
name|MapperService
operator|.
name|DEFAULT_MAPPING
argument_list|)
expr_stmt|;
block|}
block|}
comment|// go over and add the relevant mappings (or update them)
for|for
control|(
name|ObjectCursor
argument_list|<
name|MappingMetaData
argument_list|>
name|cursor
range|:
name|indexMetaData
operator|.
name|mappings
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|MappingMetaData
name|mappingMd
init|=
name|cursor
operator|.
name|value
decl_stmt|;
name|String
name|mappingType
init|=
name|mappingMd
operator|.
name|type
argument_list|()
decl_stmt|;
name|CompressedString
name|mappingSource
init|=
name|mappingMd
operator|.
name|source
argument_list|()
decl_stmt|;
if|if
condition|(
name|mappingType
operator|.
name|equals
argument_list|(
name|MapperService
operator|.
name|DEFAULT_MAPPING
argument_list|)
condition|)
block|{
comment|// we processed _default_ first
continue|continue;
block|}
name|boolean
name|requireRefresh
init|=
name|processMapping
argument_list|(
name|index
argument_list|,
name|mapperService
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|)
decl_stmt|;
if|if
condition|(
name|requireRefresh
condition|)
block|{
name|typesToRefresh
operator|.
name|add
argument_list|(
name|mappingType
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|typesToRefresh
operator|.
name|isEmpty
argument_list|()
operator|&&
name|sendRefreshMapping
condition|)
block|{
name|nodeMappingRefreshAction
operator|.
name|nodeMappingRefresh
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
operator|new
name|NodeMappingRefreshAction
operator|.
name|NodeMappingRefreshRequest
argument_list|(
name|index
argument_list|,
name|indexMetaData
operator|.
name|uuid
argument_list|()
argument_list|,
name|typesToRefresh
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|typesToRefresh
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|,
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// go over and remove mappings
for|for
control|(
name|DocumentMapper
name|documentMapper
range|:
name|mapperService
operator|.
name|docMappers
argument_list|(
literal|true
argument_list|)
control|)
block|{
if|if
condition|(
name|seenMappings
operator|.
name|containsKey
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|index
argument_list|,
name|documentMapper
operator|.
name|type
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|indexMetaData
operator|.
name|mappings
argument_list|()
operator|.
name|containsKey
argument_list|(
name|documentMapper
operator|.
name|type
argument_list|()
argument_list|)
condition|)
block|{
comment|// we have it in our mappings, but not in the metadata, and we have seen it in the cluster state, remove it
name|mapperService
operator|.
name|remove
argument_list|(
name|documentMapper
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
name|seenMappings
operator|.
name|remove
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|index
argument_list|,
name|documentMapper
operator|.
name|type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
comment|// if we failed the mappings anywhere, we need to fail the shards for this index, note, we safeguard
comment|// by creating the processing the mappings on the master, or on the node the mapping was introduced on,
comment|// so this failure typically means wrong node level configuration or something similar
for|for
control|(
name|IndexShard
name|indexShard
range|:
name|indexService
control|)
block|{
name|ShardRouting
name|shardRouting
init|=
name|indexShard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"failed to update mappings"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|processMapping
specifier|private
name|boolean
name|processMapping
parameter_list|(
name|String
name|index
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|String
name|mappingType
parameter_list|,
name|CompressedString
name|mappingSource
parameter_list|)
throws|throws
name|Throwable
block|{
if|if
condition|(
operator|!
name|seenMappings
operator|.
name|containsKey
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|index
argument_list|,
name|mappingType
argument_list|)
argument_list|)
condition|)
block|{
name|seenMappings
operator|.
name|put
argument_list|(
operator|new
name|Tuple
argument_list|<>
argument_list|(
name|index
argument_list|,
name|mappingType
argument_list|)
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// refresh mapping can happen for 2 reasons. The first is less urgent, and happens when the mapping on this
comment|// node is ahead of what there is in the cluster state (yet an update-mapping has been sent to it already,
comment|// it just hasn't been processed yet and published). Eventually, the mappings will converge, and the refresh
comment|// mapping sent is more of a safe keeping (assuming the update mapping failed to reach the master, ...)
comment|// the second case is where the parsing/merging of the mapping from the metadata doesn't result in the same
comment|// mapping, in this case, we send to the master to refresh its own version of the mappings (to conform with the
comment|// merge version of it, which it does when refreshing the mappings), and warn log it.
name|boolean
name|requiresRefresh
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|mapperService
operator|.
name|hasMapping
argument_list|(
name|mappingType
argument_list|)
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|mappingSource
operator|.
name|compressed
argument_list|()
operator|.
name|length
operator|<
literal|512
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] adding mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] adding mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] adding mapping [{}] (source suppressed due to length, use TRACE level if needed)"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|)
expr_stmt|;
block|}
comment|// we don't apply default, since it has been applied when the mappings were parsed initially
name|mapperService
operator|.
name|merge
argument_list|(
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
operator|.
name|equals
argument_list|(
name|mappingSource
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
argument_list|)
expr_stmt|;
name|requiresRefresh
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|DocumentMapper
name|existingMapper
init|=
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mappingSource
operator|.
name|equals
argument_list|(
name|existingMapper
operator|.
name|mappingSource
argument_list|()
argument_list|)
condition|)
block|{
comment|// mapping changed, update it
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
operator|&&
name|mappingSource
operator|.
name|compressed
argument_list|()
operator|.
name|length
operator|<
literal|512
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] updating mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] updating mapping [{}], source [{}]"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
operator|.
name|string
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] updating mapping [{}] (source suppressed due to length, use TRACE level if needed)"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|)
expr_stmt|;
block|}
comment|// we don't apply default, since it has been applied when the mappings were parsed initially
name|mapperService
operator|.
name|merge
argument_list|(
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
operator|.
name|equals
argument_list|(
name|mappingSource
argument_list|)
condition|)
block|{
name|requiresRefresh
operator|=
literal|true
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}"
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|,
name|mapperService
operator|.
name|documentMapper
argument_list|(
name|mappingType
argument_list|)
operator|.
name|mappingSource
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to add mapping [{}], source [{}]"
argument_list|,
name|e
argument_list|,
name|index
argument_list|,
name|mappingType
argument_list|,
name|mappingSource
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
return|return
name|requiresRefresh
return|;
block|}
DECL|method|aliasesChanged
specifier|private
name|boolean
name|aliasesChanged
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
return|return
operator|!
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|aliases
argument_list|()
operator|.
name|equals
argument_list|(
name|event
operator|.
name|previousState
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|aliases
argument_list|()
argument_list|)
operator|||
operator|!
name|event
operator|.
name|state
argument_list|()
operator|.
name|routingTable
argument_list|()
operator|.
name|equals
argument_list|(
name|event
operator|.
name|previousState
argument_list|()
operator|.
name|routingTable
argument_list|()
argument_list|)
return|;
block|}
DECL|method|applyAliases
specifier|private
name|void
name|applyAliases
parameter_list|(
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
comment|// check if aliases changed
if|if
condition|(
name|aliasesChanged
argument_list|(
name|event
argument_list|)
condition|)
block|{
comment|// go over and update aliases
for|for
control|(
name|IndexMetaData
name|indexMetaData
range|:
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
control|)
block|{
name|String
name|index
init|=
name|indexMetaData
operator|.
name|index
argument_list|()
decl_stmt|;
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// we only create / update here
continue|continue;
block|}
name|IndexAliasesService
name|indexAliasesService
init|=
name|indexService
operator|.
name|aliasesService
argument_list|()
decl_stmt|;
name|processAliases
argument_list|(
name|index
argument_list|,
name|indexMetaData
operator|.
name|aliases
argument_list|()
operator|.
name|values
argument_list|()
argument_list|,
name|indexAliasesService
argument_list|)
expr_stmt|;
comment|// go over and remove aliases
for|for
control|(
name|IndexAlias
name|indexAlias
range|:
name|indexAliasesService
control|)
block|{
if|if
condition|(
operator|!
name|indexMetaData
operator|.
name|aliases
argument_list|()
operator|.
name|containsKey
argument_list|(
name|indexAlias
operator|.
name|alias
argument_list|()
argument_list|)
condition|)
block|{
comment|// we have it in our aliases, but not in the metadata, remove it
name|indexAliasesService
operator|.
name|remove
argument_list|(
name|indexAlias
operator|.
name|alias
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|processAliases
specifier|private
name|void
name|processAliases
parameter_list|(
name|String
name|index
parameter_list|,
name|ObjectContainer
argument_list|<
name|AliasMetaData
argument_list|>
name|aliases
parameter_list|,
name|IndexAliasesService
name|indexAliasesService
parameter_list|)
block|{
name|HashMap
argument_list|<
name|String
argument_list|,
name|IndexAlias
argument_list|>
name|newAliases
init|=
name|newHashMap
argument_list|()
decl_stmt|;
for|for
control|(
name|ObjectCursor
argument_list|<
name|AliasMetaData
argument_list|>
name|cursor
range|:
name|aliases
control|)
block|{
name|AliasMetaData
name|aliasMd
init|=
name|cursor
operator|.
name|value
decl_stmt|;
name|String
name|alias
init|=
name|aliasMd
operator|.
name|alias
argument_list|()
decl_stmt|;
name|CompressedString
name|filter
init|=
name|aliasMd
operator|.
name|filter
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|!
name|indexAliasesService
operator|.
name|hasAlias
argument_list|(
name|alias
argument_list|)
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] adding alias [{}], filter [{}]"
argument_list|,
name|index
argument_list|,
name|alias
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
name|newAliases
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|indexAliasesService
operator|.
name|create
argument_list|(
name|alias
argument_list|,
name|filter
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|filter
operator|==
literal|null
operator|&&
name|indexAliasesService
operator|.
name|alias
argument_list|(
name|alias
argument_list|)
operator|.
name|filter
argument_list|()
operator|!=
literal|null
operator|)
operator|||
operator|(
name|filter
operator|!=
literal|null
operator|&&
operator|!
name|filter
operator|.
name|equals
argument_list|(
name|indexAliasesService
operator|.
name|alias
argument_list|(
name|alias
argument_list|)
operator|.
name|filter
argument_list|()
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] updating alias [{}], filter [{}]"
argument_list|,
name|index
argument_list|,
name|alias
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
name|newAliases
operator|.
name|put
argument_list|(
name|alias
argument_list|,
name|indexAliasesService
operator|.
name|create
argument_list|(
name|alias
argument_list|,
name|filter
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] failed to add alias [{}], filter [{}]"
argument_list|,
name|e
argument_list|,
name|index
argument_list|,
name|alias
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
block|}
name|indexAliasesService
operator|.
name|addAll
argument_list|(
name|newAliases
argument_list|)
expr_stmt|;
block|}
DECL|method|applyNewOrUpdatedShards
specifier|private
name|void
name|applyNewOrUpdatedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
throws|throws
name|ElasticsearchException
block|{
if|if
condition|(
operator|!
name|indicesService
operator|.
name|changesAllowed
argument_list|()
condition|)
block|{
return|return;
block|}
name|RoutingTable
name|routingTable
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|routingTable
argument_list|()
decl_stmt|;
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|readOnlyRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
name|failedShards
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|DiscoveryNodes
name|nodes
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|ShardRouting
name|shardRouting
range|:
name|routingNode
control|)
block|{
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// got deleted on us, ignore
continue|continue;
block|}
specifier|final
name|IndexMetaData
name|indexMetaData
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|metaData
argument_list|()
operator|.
name|index
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexMetaData
operator|==
literal|null
condition|)
block|{
comment|// the index got deleted on the metadata, we will clean it later in the apply deleted method call
continue|continue;
block|}
specifier|final
name|int
name|shardId
init|=
name|shardRouting
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
operator|&&
name|shardRouting
operator|.
name|started
argument_list|()
condition|)
block|{
if|if
condition|(
name|failedShards
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|masterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|resendShardFailed
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getUUID
argument_list|()
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|" marked shard as started, but shard has previous failed. resending shard failure."
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// the master thinks we are started, but we don't have this shard at all, mark it as failed
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getUUID
argument_list|()
argument_list|,
literal|"master ["
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|"] marked shard as started, but shard has not been created, mark shard as failed"
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|shard
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|!=
literal|null
condition|)
block|{
name|ShardRouting
name|currentRoutingEntry
init|=
name|indexShard
operator|.
name|routingEntry
argument_list|()
decl_stmt|;
comment|// if the current and global routing are initializing, but are still not the same, its a different "shard" being allocated
comment|// for example: a shard that recovers from one node and now needs to recover to another node,
comment|//              or a replica allocated and then allocating a primary because the primary failed on another node
name|boolean
name|shardHasBeenRemoved
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|currentRoutingEntry
operator|.
name|initializing
argument_list|()
operator|&&
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|&&
operator|!
name|currentRoutingEntry
operator|.
name|equals
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (different instance of it allocated on this node, current [{}], global [{}])"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
name|currentRoutingEntry
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
comment|// closing the shard will also cancel any ongoing recovery.
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (different instance of it allocated on this node)"
argument_list|)
expr_stmt|;
name|shardHasBeenRemoved
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isPeerRecovery
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
specifier|final
name|DiscoveryNode
name|sourceNode
init|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|shardRouting
argument_list|)
decl_stmt|;
comment|// check if there is an existing recovery going, and if so, and the source node is not the same, cancel the recovery to restart it
specifier|final
name|Predicate
argument_list|<
name|RecoveryStatus
argument_list|>
name|shouldCancel
init|=
operator|new
name|Predicate
argument_list|<
name|RecoveryStatus
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
annotation|@
name|Nullable
name|RecoveryStatus
name|status
parameter_list|)
block|{
return|return
name|status
operator|.
name|sourceNode
argument_list|()
operator|.
name|equals
argument_list|(
name|sourceNode
argument_list|)
operator|==
literal|false
return|;
block|}
block|}
decl_stmt|;
if|if
condition|(
name|recoveryTarget
operator|.
name|cancelRecoveriesForShard
argument_list|(
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
literal|"recovery source node changed"
argument_list|,
name|shouldCancel
argument_list|)
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] removing shard (recovery source changed), current [{}], global [{}])"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
name|currentRoutingEntry
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
comment|// closing the shard will also cancel any ongoing recovery.
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|,
literal|"removing shard (recovery source node changed)"
argument_list|)
expr_stmt|;
name|shardHasBeenRemoved
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shardHasBeenRemoved
operator|==
literal|false
operator|&&
operator|(
name|shardRouting
operator|.
name|equals
argument_list|(
name|indexShard
operator|.
name|routingEntry
argument_list|()
argument_list|)
operator|==
literal|false
operator|||
name|shardRouting
operator|.
name|version
argument_list|()
operator|>
name|indexShard
operator|.
name|routingEntry
argument_list|()
operator|.
name|version
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|shardRouting
operator|.
name|primary
argument_list|()
operator|&&
name|indexShard
operator|.
name|routingEntry
argument_list|()
operator|.
name|primary
argument_list|()
operator|==
literal|false
operator|&&
name|shardRouting
operator|.
name|initializing
argument_list|()
operator|&&
name|indexShard
operator|.
name|allowsPrimaryPromotion
argument_list|()
operator|==
literal|false
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"{} reinitialize shard on primary promotion"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardId
argument_list|,
literal|"promoted to primary"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if we happen to remove the shardRouting by id above we don't need to jump in here!
name|indexShard
operator|.
name|updateRoutingEntry
argument_list|(
name|shardRouting
argument_list|,
name|event
operator|.
name|state
argument_list|()
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
operator|==
literal|false
argument_list|)
expr_stmt|;
name|indexService
operator|.
name|shardInjectorSafe
argument_list|(
name|shardId
argument_list|)
operator|.
name|getInstance
argument_list|(
name|IndexShardGatewayService
operator|.
name|class
argument_list|)
operator|.
name|routingStateChanged
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|shardRouting
operator|.
name|initializing
argument_list|()
condition|)
block|{
name|applyInitializingShard
argument_list|(
name|event
operator|.
name|state
argument_list|()
argument_list|,
name|indexMetaData
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|cleanFailedShards
specifier|private
name|void
name|cleanFailedShards
parameter_list|(
specifier|final
name|ClusterChangedEvent
name|event
parameter_list|)
block|{
name|RoutingTable
name|routingTable
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|routingTable
argument_list|()
decl_stmt|;
name|RoutingNodes
operator|.
name|RoutingNodeIterator
name|routingNode
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|readOnlyRoutingNodes
argument_list|()
operator|.
name|routingNodeIter
argument_list|(
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
operator|.
name|localNodeId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|routingNode
operator|==
literal|null
condition|)
block|{
name|failedShards
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
name|DiscoveryNodes
name|nodes
init|=
name|event
operator|.
name|state
argument_list|()
operator|.
name|nodes
argument_list|()
decl_stmt|;
name|long
name|now
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|String
name|localNodeId
init|=
name|nodes
operator|.
name|localNodeId
argument_list|()
decl_stmt|;
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|FailedShard
argument_list|>
argument_list|>
name|iterator
init|=
name|failedShards
operator|.
name|entrySet
argument_list|()
operator|.
name|iterator
argument_list|()
decl_stmt|;
name|shards
label|:
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|ShardId
argument_list|,
name|FailedShard
argument_list|>
name|entry
init|=
name|iterator
operator|.
name|next
argument_list|()
decl_stmt|;
name|FailedShard
name|failedShard
init|=
name|entry
operator|.
name|getValue
argument_list|()
decl_stmt|;
name|IndexRoutingTable
name|indexRoutingTable
init|=
name|routingTable
operator|.
name|index
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexRoutingTable
operator|!=
literal|null
condition|)
block|{
name|IndexShardRoutingTable
name|shardRoutingTable
init|=
name|indexRoutingTable
operator|.
name|shard
argument_list|(
name|entry
operator|.
name|getKey
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|shardRoutingTable
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|ShardRouting
name|shardRouting
range|:
name|shardRoutingTable
operator|.
name|assignedShards
argument_list|()
control|)
block|{
if|if
condition|(
name|localNodeId
operator|.
name|equals
argument_list|(
name|shardRouting
operator|.
name|currentNodeId
argument_list|()
argument_list|)
condition|)
block|{
comment|// we have a timeout here just to make sure we don't have dangled failed shards for some reason
comment|// its just another safely layer
if|if
condition|(
name|shardRouting
operator|.
name|version
argument_list|()
operator|==
name|failedShard
operator|.
name|version
operator|&&
operator|(
operator|(
name|now
operator|-
name|failedShard
operator|.
name|timestamp
operator|)
operator|<
name|TimeValue
operator|.
name|timeValueMinutes
argument_list|(
literal|60
argument_list|)
operator|.
name|millis
argument_list|()
operator|)
condition|)
block|{
comment|// It's the same failed shard - keep it if it hasn't timed out
continue|continue
name|shards
continue|;
block|}
else|else
block|{
comment|// Different version or expired, remove it
break|break;
block|}
block|}
block|}
block|}
block|}
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
DECL|method|applyInitializingShard
specifier|private
name|void
name|applyInitializingShard
parameter_list|(
specifier|final
name|ClusterState
name|state
parameter_list|,
specifier|final
name|IndexMetaData
name|indexMetaData
parameter_list|,
specifier|final
name|ShardRouting
name|shardRouting
parameter_list|)
throws|throws
name|ElasticsearchException
block|{
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|==
literal|null
condition|)
block|{
comment|// got deleted on us, ignore
return|return;
block|}
specifier|final
name|RoutingTable
name|routingTable
init|=
name|state
operator|.
name|routingTable
argument_list|()
decl_stmt|;
specifier|final
name|DiscoveryNodes
name|nodes
init|=
name|state
operator|.
name|getNodes
argument_list|()
decl_stmt|;
specifier|final
name|int
name|shardId
init|=
name|shardRouting
operator|.
name|id
argument_list|()
decl_stmt|;
if|if
condition|(
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|shardSafe
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|indexShard
operator|.
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
comment|// the master thinks we are initializing, but we are already started or on POST_RECOVERY and waiting
comment|// for master to confirm a shard started message (either master failover, or a cluster event before
comment|// we managed to tell the master we started), mark us as started
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"{} master marked shard as initializing, but shard has state [{}], resending shard started to {}"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nodes
operator|.
name|masterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getUUID
argument_list|()
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|" marked shard as initializing, but shard state is ["
operator|+
name|indexShard
operator|.
name|state
argument_list|()
operator|+
literal|"], mark shard as started"
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
if|if
condition|(
name|indexShard
operator|.
name|ignoreRecoveryAttempt
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring recovery instruction for an existing shard {} (shard state: [{}])"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// if we're in peer recovery, try to find out the source node now so in case it fails, we will not create the index shard
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|isPeerRecovery
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
name|sourceNode
operator|=
name|findSourceNodeForPeerRecovery
argument_list|(
name|routingTable
argument_list|,
name|nodes
argument_list|,
name|shardRouting
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring initializing shard {} - no source node can be found."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// if there is no shard, create it
if|if
condition|(
operator|!
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardId
argument_list|)
condition|)
block|{
if|if
condition|(
name|failedShards
operator|.
name|containsKey
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
name|nodes
operator|.
name|masterNode
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|shardStateAction
operator|.
name|resendShardFailed
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getUUID
argument_list|()
argument_list|,
literal|"master "
operator|+
name|nodes
operator|.
name|masterNode
argument_list|()
operator|+
literal|" marked shard as initializing, but shard is marked as failed, resend shard failure"
argument_list|,
name|nodes
operator|.
name|masterNode
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}][{}] creating shard"
argument_list|,
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|createShard
argument_list|(
name|shardId
argument_list|,
name|shardRouting
operator|.
name|primary
argument_list|()
argument_list|)
decl_stmt|;
name|indexShard
operator|.
name|updateRoutingEntry
argument_list|(
name|shardRouting
argument_list|,
name|state
operator|.
name|blocks
argument_list|()
operator|.
name|disableStatePersistence
argument_list|()
operator|==
literal|false
argument_list|)
expr_stmt|;
name|indexShard
operator|.
name|addFailedEngineListener
argument_list|(
name|failedEngineHandler
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexShardAlreadyExistsException
name|e
parameter_list|)
block|{
comment|// ignore this, the method call can happen several times
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"failed to create shard"
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
specifier|final
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|shardSafe
argument_list|(
name|shardId
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|.
name|ignoreRecoveryAttempt
argument_list|()
condition|)
block|{
comment|// we are already recovering (we can get to this state since the cluster event can happen several
comment|// times while we recover)
name|logger
operator|.
name|trace
argument_list|(
literal|"ignoring recovery instruction for shard {} (shard state: [{}])"
argument_list|,
name|indexShard
operator|.
name|shardId
argument_list|()
argument_list|,
name|indexShard
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isPeerRecovery
argument_list|(
name|shardRouting
argument_list|)
condition|)
block|{
try|try
block|{
assert|assert
name|sourceNode
operator|!=
literal|null
operator|:
literal|"peer recovery started but sourceNode is null"
assert|;
comment|// we don't mark this one as relocated at the end.
comment|// For primaries: requests in any case are routed to both when its relocating and that way we handle
comment|//    the edge case where its mark as relocated, and we might need to roll it back...
comment|// For replicas: we are recovering a backup from a primary
name|RecoveryState
operator|.
name|Type
name|type
init|=
name|shardRouting
operator|.
name|primary
argument_list|()
condition|?
name|RecoveryState
operator|.
name|Type
operator|.
name|RELOCATION
else|:
name|RecoveryState
operator|.
name|Type
operator|.
name|REPLICA
decl_stmt|;
name|recoveryTarget
operator|.
name|startRecovery
argument_list|(
name|indexShard
argument_list|,
name|type
argument_list|,
name|sourceNode
argument_list|,
operator|new
name|PeerRecoveryListener
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
name|indexMetaData
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|indexShard
operator|.
name|failShard
argument_list|(
literal|"corrupted preexisting index"
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
literal|true
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|final
name|IndexShardRoutingTable
name|indexShardRouting
init|=
name|routingTable
operator|.
name|index
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|shard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
comment|// we are the first primary, recover from the gateway
comment|// if its post api allocation, the index should exists
name|boolean
name|indexShouldExists
init|=
name|indexShardRouting
operator|.
name|primaryAllocatedPostApi
argument_list|()
decl_stmt|;
name|IndexShardGatewayService
name|shardGatewayService
init|=
name|indexService
operator|.
name|shardInjectorSafe
argument_list|(
name|shardId
argument_list|)
operator|.
name|getInstance
argument_list|(
name|IndexShardGatewayService
operator|.
name|class
argument_list|)
decl_stmt|;
name|shardGatewayService
operator|.
name|recover
argument_list|(
name|indexShouldExists
argument_list|,
operator|new
name|IndexShardGatewayService
operator|.
name|RecoveryListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onRecoveryDone
parameter_list|()
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getUUID
argument_list|()
argument_list|,
literal|"after recovery from gateway"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onIgnoreRecovery
parameter_list|(
name|String
name|reason
parameter_list|)
block|{                 }
annotation|@
name|Override
specifier|public
name|void
name|onRecoveryFailed
parameter_list|(
name|IndexShardGatewayRecoveryException
name|e
parameter_list|)
block|{
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
literal|true
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard      * routing to *require* peer recovery, use {@link #isPeerRecovery(org.elasticsearch.cluster.routing.ShardRouting)} to      * check if its needed or not.      */
DECL|method|findSourceNodeForPeerRecovery
specifier|private
name|DiscoveryNode
name|findSourceNodeForPeerRecovery
parameter_list|(
name|RoutingTable
name|routingTable
parameter_list|,
name|DiscoveryNodes
name|nodes
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
name|DiscoveryNode
name|sourceNode
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|IndexShardRoutingTable
name|shardRoutingTable
init|=
name|routingTable
operator|.
name|index
argument_list|(
name|shardRouting
operator|.
name|index
argument_list|()
argument_list|)
operator|.
name|shard
argument_list|(
name|shardRouting
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|ShardRouting
name|entry
range|:
name|shardRoutingTable
control|)
block|{
if|if
condition|(
name|entry
operator|.
name|primary
argument_list|()
operator|&&
name|entry
operator|.
name|active
argument_list|()
condition|)
block|{
comment|// only recover from started primary, if we can't find one, we will do it next round
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|entry
operator|.
name|currentNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node because primary shard {} is assigned to an unknown node."
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find replica source node for {} because a primary shard can not be found."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|sourceNode
operator|=
name|nodes
operator|.
name|get
argument_list|(
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|sourceNode
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"can't find relocation source node for shard {} because it is assigned to an unknown node [{}]."
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
throw|throw
operator|new
name|ElasticsearchIllegalStateException
argument_list|(
literal|"trying to find source node for peer recovery when routing state means no peer recovery: "
operator|+
name|shardRouting
argument_list|)
throw|;
block|}
return|return
name|sourceNode
return|;
block|}
DECL|method|isPeerRecovery
specifier|private
name|boolean
name|isPeerRecovery
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|)
block|{
return|return
operator|!
name|shardRouting
operator|.
name|primary
argument_list|()
operator|||
name|shardRouting
operator|.
name|relocatingNodeId
argument_list|()
operator|!=
literal|null
return|;
block|}
DECL|class|PeerRecoveryListener
specifier|private
class|class
name|PeerRecoveryListener
implements|implements
name|RecoveryTarget
operator|.
name|RecoveryListener
block|{
DECL|field|shardRouting
specifier|private
specifier|final
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|field|indexService
specifier|private
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|field|indexMetaData
specifier|private
specifier|final
name|IndexMetaData
name|indexMetaData
decl_stmt|;
DECL|method|PeerRecoveryListener
specifier|private
name|PeerRecoveryListener
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|IndexService
name|indexService
parameter_list|,
name|IndexMetaData
name|indexMetaData
parameter_list|)
block|{
name|this
operator|.
name|shardRouting
operator|=
name|shardRouting
expr_stmt|;
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
name|this
operator|.
name|indexMetaData
operator|=
name|indexMetaData
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onRecoveryDone
specifier|public
name|void
name|onRecoveryDone
parameter_list|(
name|RecoveryState
name|state
parameter_list|)
block|{
name|shardStateAction
operator|.
name|shardStarted
argument_list|(
name|shardRouting
argument_list|,
name|indexMetaData
operator|.
name|getUUID
argument_list|()
argument_list|,
literal|"after recovery (replica) from node ["
operator|+
name|state
operator|.
name|getSourceNode
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|onRecoveryFailure
specifier|public
name|void
name|onRecoveryFailure
parameter_list|(
name|RecoveryState
name|state
parameter_list|,
name|RecoveryFailedException
name|e
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|)
block|{
name|handleRecoveryFailure
argument_list|(
name|indexService
argument_list|,
name|shardRouting
argument_list|,
name|sendShardFailure
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|handleRecoveryFailure
specifier|private
name|void
name|handleRecoveryFailure
parameter_list|(
name|IndexService
name|indexService
parameter_list|,
name|ShardRouting
name|shardRouting
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|Throwable
name|failure
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|failAndRemoveShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
argument_list|,
name|sendShardFailure
argument_list|,
literal|"failed recovery"
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeIndex
specifier|private
name|void
name|removeIndex
parameter_list|(
name|String
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
try|try
block|{
name|indicesService
operator|.
name|removeIndex
argument_list|(
name|index
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to clean index ({})"
argument_list|,
name|e
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
name|clearSeenMappings
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
DECL|method|clearSeenMappings
specifier|private
name|void
name|clearSeenMappings
parameter_list|(
name|String
name|index
parameter_list|)
block|{
comment|// clear seen mappings as well
for|for
control|(
name|Tuple
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|tuple
range|:
name|seenMappings
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|tuple
operator|.
name|v1
argument_list|()
operator|.
name|equals
argument_list|(
name|index
argument_list|)
condition|)
block|{
name|seenMappings
operator|.
name|remove
argument_list|(
name|tuple
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|deleteIndex
specifier|private
name|void
name|deleteIndex
parameter_list|(
name|String
name|index
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
try|try
block|{
name|indicesService
operator|.
name|deleteIndex
argument_list|(
name|index
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to delete index ({})"
argument_list|,
name|e
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
comment|// clear seen mappings as well
name|clearSeenMappings
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
DECL|method|failAndRemoveShard
specifier|private
name|void
name|failAndRemoveShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|IndexService
name|indexService
parameter_list|,
name|boolean
name|sendShardFailure
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
if|if
condition|(
name|indexService
operator|.
name|hasShard
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
try|try
block|{
name|indexService
operator|.
name|removeShard
argument_list|(
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IndexShardMissingException
name|e
parameter_list|)
block|{
comment|// the node got closed on us, ignore it
block|}
catch|catch
parameter_list|(
name|Throwable
name|e1
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] failed to remove shard after failure ([{}])"
argument_list|,
name|e1
argument_list|,
name|shardRouting
operator|.
name|getIndex
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sendShardFailure
condition|)
block|{
name|sendFailShard
argument_list|(
name|shardRouting
argument_list|,
name|indexService
operator|.
name|indexUUID
argument_list|()
argument_list|,
name|message
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sendFailShard
specifier|private
name|void
name|sendFailShard
parameter_list|(
name|ShardRouting
name|shardRouting
parameter_list|,
name|String
name|indexUUID
parameter_list|,
name|String
name|message
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
try|try
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}] marking and sending shard failed due to [{}]"
argument_list|,
name|failure
argument_list|,
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|failedShards
operator|.
name|put
argument_list|(
name|shardRouting
operator|.
name|shardId
argument_list|()
argument_list|,
operator|new
name|FailedShard
argument_list|(
name|shardRouting
operator|.
name|version
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|shardStateAction
operator|.
name|shardFailed
argument_list|(
name|shardRouting
argument_list|,
name|indexUUID
argument_list|,
literal|"shard failure ["
operator|+
name|message
operator|+
literal|"]"
operator|+
operator|(
name|failure
operator|==
literal|null
condition|?
literal|""
else|:
literal|"["
operator|+
name|detailedMessage
argument_list|(
name|failure
argument_list|)
operator|+
literal|"]"
operator|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e1
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] failed to mark shard as failed (because of [{}])"
argument_list|,
name|e1
argument_list|,
name|shardRouting
operator|.
name|getIndex
argument_list|()
argument_list|,
name|shardRouting
operator|.
name|getId
argument_list|()
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|FailedEngineHandler
specifier|private
class|class
name|FailedEngineHandler
implements|implements
name|Engine
operator|.
name|FailedEngineListener
block|{
annotation|@
name|Override
DECL|method|onFailedEngine
specifier|public
name|void
name|onFailedEngine
parameter_list|(
specifier|final
name|ShardId
name|shardId
parameter_list|,
specifier|final
name|String
name|reason
parameter_list|,
specifier|final
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
name|ShardRouting
name|shardRouting
init|=
literal|null
decl_stmt|;
specifier|final
name|IndexService
name|indexService
init|=
name|indicesService
operator|.
name|indexService
argument_list|(
name|shardId
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexService
operator|!=
literal|null
condition|)
block|{
name|IndexShard
name|indexShard
init|=
name|indexService
operator|.
name|shard
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|indexShard
operator|!=
literal|null
condition|)
block|{
name|shardRouting
operator|=
name|indexShard
operator|.
name|routingEntry
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|shardRouting
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"[{}][{}] engine failed, but can't find index shard. failure reason: [{}]"
argument_list|,
name|failure
argument_list|,
name|shardId
operator|.
name|index
argument_list|()
operator|.
name|name
argument_list|()
argument_list|,
name|shardId
operator|.
name|id
argument_list|()
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|final
name|ShardRouting
name|fShardRouting
init|=
name|shardRouting
decl_stmt|;
name|threadPool
operator|.
name|generic
argument_list|()
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|failAndRemoveShard
argument_list|(
name|fShardRouting
argument_list|,
name|indexService
argument_list|,
literal|true
argument_list|,
literal|"engine failure, reason ["
operator|+
name|reason
operator|+
literal|"]"
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

