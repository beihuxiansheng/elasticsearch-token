begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to ElasticSearch and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. ElasticSearch licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.indices.analysis
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|analysis
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheBuilder
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|CacheLoader
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|cache
operator|.
name|LoadingCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|analysis
operator|.
name|hunspell
operator|.
name|HunspellDictionary
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticSearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|ImmutableSettings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|Environment
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|net
operator|.
name|MalformedURLException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Serves as a node level registry for hunspell dictionaries. This services expects all dictionaries to be located under  * the {@code<path.conf>/hunspell} directory, where each locale has its dedicated sub-directory which holds the dictionary  * files. For example, the dictionary files for {@code en_US} locale must be placed under {@code<path.conf>/hunspell/en_US}  * directory.  *  * The following settings can be set for each dictionary:  *<ul>  *<li>{@code ignore_case} - If true, dictionary matching will be case insensitive (defaults to {@code false})</li>  *<li>{@code strict_affix_parsing} - Determines whether errors while reading a affix rules file will cause exception or simple be ignored (defaults to {@code true})</li>  *</ul>  *  * These settings can either be configured as node level configuration, such as:  *<br/><br/>  *<pre><code>  *     indices.analysis.hunspell.dictionary.en_US.ignore_case: true  *     indices.analysis.hunspell.dictionary.en_US.strict_affix_parsing: false  *</code></pre>  *  * or, as dedicated configuration per dictionary, placed in a {@code settings.yml} file under the dictionary directory. For  * example, the following can be the content of the {@code<path.config>/hunspell/en_US/settings.yml} file:  *<br/><br/>  *<pre><code>  *     ignore_case: true  *     strict_affix_parsing: false  *</code></pre>  *  * @see org.elasticsearch.index.analysis.HunspellTokenFilterFactory  */
end_comment

begin_class
DECL|class|HunspellService
specifier|public
class|class
name|HunspellService
extends|extends
name|AbstractComponent
block|{
DECL|field|DIC_FILE_FILTER
specifier|private
specifier|final
specifier|static
name|DictionaryFileFilter
name|DIC_FILE_FILTER
init|=
operator|new
name|DictionaryFileFilter
argument_list|()
decl_stmt|;
DECL|field|AFFIX_FILE_FILTER
specifier|private
specifier|final
specifier|static
name|AffixFileFilter
name|AFFIX_FILE_FILTER
init|=
operator|new
name|AffixFileFilter
argument_list|()
decl_stmt|;
DECL|field|dictionaries
specifier|private
specifier|final
name|LoadingCache
argument_list|<
name|String
argument_list|,
name|HunspellDictionary
argument_list|>
name|dictionaries
decl_stmt|;
DECL|field|knownDicitionaries
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HunspellDictionary
argument_list|>
name|knownDicitionaries
decl_stmt|;
DECL|field|defaultIgnoreCase
specifier|private
specifier|final
name|boolean
name|defaultIgnoreCase
decl_stmt|;
DECL|field|defaultStrictAffixParsing
specifier|private
specifier|final
name|boolean
name|defaultStrictAffixParsing
decl_stmt|;
DECL|field|hunspellDir
specifier|private
specifier|final
name|File
name|hunspellDir
decl_stmt|;
DECL|method|HunspellService
specifier|public
name|HunspellService
parameter_list|(
specifier|final
name|Settings
name|settings
parameter_list|,
specifier|final
name|Environment
name|env
parameter_list|)
block|{
name|this
argument_list|(
name|settings
argument_list|,
name|env
argument_list|,
name|Collections
operator|.
expr|<
name|String
argument_list|,
name|HunspellDictionary
operator|>
name|emptyMap
argument_list|()
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Inject
DECL|method|HunspellService
specifier|public
name|HunspellService
parameter_list|(
specifier|final
name|Settings
name|settings
parameter_list|,
specifier|final
name|Environment
name|env
parameter_list|,
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|HunspellDictionary
argument_list|>
name|knownDicitionaries
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|knownDicitionaries
operator|=
name|knownDicitionaries
expr_stmt|;
name|this
operator|.
name|hunspellDir
operator|=
name|resolveHunspellDirectory
argument_list|(
name|settings
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultIgnoreCase
operator|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
literal|"indices.analysis.hunspell.dictionary.ignore_case"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|this
operator|.
name|defaultStrictAffixParsing
operator|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
literal|"indices.analysis.hunspell.dictionary.strict_affix_parsing"
argument_list|,
literal|false
argument_list|)
expr_stmt|;
specifier|final
name|Version
name|version
init|=
name|Lucene
operator|.
name|parseVersion
argument_list|(
name|settings
operator|.
name|get
argument_list|(
literal|"version"
argument_list|)
argument_list|,
name|Lucene
operator|.
name|ANALYZER_VERSION
argument_list|,
name|logger
argument_list|)
decl_stmt|;
name|dictionaries
operator|=
name|CacheBuilder
operator|.
name|newBuilder
argument_list|()
operator|.
name|build
argument_list|(
operator|new
name|CacheLoader
argument_list|<
name|String
argument_list|,
name|HunspellDictionary
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|HunspellDictionary
name|load
parameter_list|(
name|String
name|locale
parameter_list|)
throws|throws
name|Exception
block|{
name|HunspellDictionary
name|dictionary
init|=
name|knownDicitionaries
operator|.
name|get
argument_list|(
name|locale
argument_list|)
decl_stmt|;
if|if
condition|(
name|dictionary
operator|==
literal|null
condition|)
block|{
name|dictionary
operator|=
name|loadDictionary
argument_list|(
name|locale
argument_list|,
name|settings
argument_list|,
name|env
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
return|return
name|dictionary
return|;
block|}
block|}
argument_list|)
expr_stmt|;
name|scanAndLoadDictionaries
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the hunspell dictionary for the given locale.      *      * @param locale The name of the locale      */
DECL|method|getDictionary
specifier|public
name|HunspellDictionary
name|getDictionary
parameter_list|(
name|String
name|locale
parameter_list|)
block|{
return|return
name|dictionaries
operator|.
name|getUnchecked
argument_list|(
name|locale
argument_list|)
return|;
block|}
DECL|method|resolveHunspellDirectory
specifier|private
name|File
name|resolveHunspellDirectory
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|Environment
name|env
parameter_list|)
block|{
name|String
name|location
init|=
name|settings
operator|.
name|get
argument_list|(
literal|"indices.analysis.hunspell.dictionary.location"
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|location
operator|!=
literal|null
condition|)
block|{
return|return
operator|new
name|File
argument_list|(
name|location
argument_list|)
return|;
block|}
return|return
operator|new
name|File
argument_list|(
name|env
operator|.
name|configFile
argument_list|()
argument_list|,
literal|"hunspell"
argument_list|)
return|;
block|}
comment|/**      * Scans the hunspell directory and loads all found dictionaries      */
DECL|method|scanAndLoadDictionaries
specifier|private
name|void
name|scanAndLoadDictionaries
parameter_list|()
block|{
if|if
condition|(
name|hunspellDir
operator|.
name|exists
argument_list|()
operator|&&
name|hunspellDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
for|for
control|(
name|File
name|file
range|:
name|hunspellDir
operator|.
name|listFiles
argument_list|()
control|)
block|{
if|if
condition|(
name|file
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
if|if
condition|(
name|file
operator|.
name|list
argument_list|(
name|AFFIX_FILE_FILTER
argument_list|)
operator|.
name|length
operator|>
literal|0
condition|)
block|{
comment|// just making sure it's indeed a dictionary dir
name|dictionaries
operator|.
name|getUnchecked
argument_list|(
name|file
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Loads the hunspell dictionary for the given local.      *      * @param locale The locale of the hunspell dictionary to be loaded.      * @param nodeSettings The node level settings      * @param env The node environment (from which the conf path will be resolved)      * @param version The lucene version      * @return The loaded Hunspell dictionary      * @throws Exception when loading fails (due to IO erros or malformed dictionary files)      */
DECL|method|loadDictionary
specifier|private
name|HunspellDictionary
name|loadDictionary
parameter_list|(
name|String
name|locale
parameter_list|,
name|Settings
name|nodeSettings
parameter_list|,
name|Environment
name|env
parameter_list|,
name|Version
name|version
parameter_list|)
throws|throws
name|Exception
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"Loading huspell dictionary [{}]..."
argument_list|,
name|locale
argument_list|)
expr_stmt|;
block|}
name|File
name|hunspellConfDir
init|=
operator|new
name|File
argument_list|(
name|env
operator|.
name|configFile
argument_list|()
argument_list|,
literal|"hunspell"
argument_list|)
decl_stmt|;
name|File
name|dicDir
init|=
operator|new
name|File
argument_list|(
name|hunspellConfDir
argument_list|,
name|locale
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dicDir
operator|.
name|exists
argument_list|()
operator|||
operator|!
name|dicDir
operator|.
name|isDirectory
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ElasticSearchException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not find hunspell dictionary [%s]"
argument_list|,
name|locale
argument_list|)
argument_list|)
throw|;
block|}
comment|// merging node settings with hunspell dictionary specific settings
name|nodeSettings
operator|=
name|loadDictionarySettings
argument_list|(
name|dicDir
argument_list|,
name|nodeSettings
operator|.
name|getByPrefix
argument_list|(
literal|"indices.analysis.hunspell.dictionary."
operator|+
name|locale
operator|+
literal|"."
argument_list|)
argument_list|)
expr_stmt|;
name|boolean
name|ignoreCase
init|=
name|nodeSettings
operator|.
name|getAsBoolean
argument_list|(
literal|"ignore_case"
argument_list|,
name|defaultIgnoreCase
argument_list|)
decl_stmt|;
name|boolean
name|strictAffixParsing
init|=
name|nodeSettings
operator|.
name|getAsBoolean
argument_list|(
literal|"strict_affix_parsing"
argument_list|,
name|defaultStrictAffixParsing
argument_list|)
decl_stmt|;
name|File
index|[]
name|affixFiles
init|=
name|dicDir
operator|.
name|listFiles
argument_list|(
name|AFFIX_FILE_FILTER
argument_list|)
decl_stmt|;
if|if
condition|(
name|affixFiles
operator|.
name|length
operator|!=
literal|1
condition|)
block|{
throw|throw
operator|new
name|ElasticSearchException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Missing affix file for hunspell dictionary [%s]"
argument_list|,
name|locale
argument_list|)
argument_list|)
throw|;
block|}
name|InputStream
name|affixStream
init|=
literal|null
decl_stmt|;
name|File
index|[]
name|dicFiles
init|=
name|dicDir
operator|.
name|listFiles
argument_list|(
name|DIC_FILE_FILTER
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|InputStream
argument_list|>
name|dicStreams
init|=
operator|new
name|ArrayList
argument_list|<
name|InputStream
argument_list|>
argument_list|(
name|dicFiles
operator|.
name|length
argument_list|)
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dicFiles
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|dicStreams
operator|.
name|add
argument_list|(
operator|new
name|FileInputStream
argument_list|(
name|dicFiles
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|affixStream
operator|=
operator|new
name|FileInputStream
argument_list|(
name|affixFiles
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|new
name|HunspellDictionary
argument_list|(
name|affixStream
argument_list|,
name|dicStreams
argument_list|,
name|version
argument_list|,
name|ignoreCase
argument_list|,
name|strictAffixParsing
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|error
argument_list|(
literal|"Could not load hunspell dictionary [{}]"
argument_list|,
name|e
argument_list|,
name|locale
argument_list|)
expr_stmt|;
throw|throw
name|e
throw|;
block|}
finally|finally
block|{
if|if
condition|(
name|affixStream
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|affixStream
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// nothing much we can do here
block|}
block|}
for|for
control|(
name|InputStream
name|in
range|:
name|dicStreams
control|)
block|{
if|if
condition|(
name|in
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|in
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// nothing much we can do here
block|}
block|}
block|}
block|}
block|}
comment|/**      * Each hunspell dictionary directory may contain a {@code settings.yml} which holds dictionary specific settings. Default      * values for these settings are defined in the given default settings.      *      * @param dir The directory of the dictionary      * @param defaults The default settings for this dictionary      * @return The resolved settings.      */
DECL|method|loadDictionarySettings
specifier|private
specifier|static
name|Settings
name|loadDictionarySettings
parameter_list|(
name|File
name|dir
parameter_list|,
name|Settings
name|defaults
parameter_list|)
block|{
name|File
name|file
init|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"settings.yml"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
try|try
block|{
return|return
name|ImmutableSettings
operator|.
name|settingsBuilder
argument_list|()
operator|.
name|loadFromUrl
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
name|defaults
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticSearchException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not load hunspell dictionary settings from [%s]"
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
name|file
operator|=
operator|new
name|File
argument_list|(
name|dir
argument_list|,
literal|"settings.json"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|exists
argument_list|()
condition|)
block|{
try|try
block|{
return|return
name|ImmutableSettings
operator|.
name|settingsBuilder
argument_list|()
operator|.
name|loadFromUrl
argument_list|(
name|file
operator|.
name|toURI
argument_list|()
operator|.
name|toURL
argument_list|()
argument_list|)
operator|.
name|put
argument_list|(
name|defaults
argument_list|)
operator|.
name|build
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|MalformedURLException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticSearchException
argument_list|(
name|String
operator|.
name|format
argument_list|(
literal|"Could not load hunspell dictionary settings from [%s]"
argument_list|,
name|file
operator|.
name|getAbsolutePath
argument_list|()
argument_list|)
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
return|return
name|defaults
return|;
block|}
comment|/**      * Only accepts {@code *.dic} files      */
DECL|class|DictionaryFileFilter
specifier|static
class|class
name|DictionaryFileFilter
implements|implements
name|FilenameFilter
block|{
annotation|@
name|Override
DECL|method|accept
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|toLowerCase
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".dic"
argument_list|)
return|;
block|}
block|}
comment|/**      * Only accepts {@code *.aff} files      */
DECL|class|AffixFileFilter
specifier|static
class|class
name|AffixFileFilter
implements|implements
name|FilenameFilter
block|{
annotation|@
name|Override
DECL|method|accept
specifier|public
name|boolean
name|accept
parameter_list|(
name|File
name|dir
parameter_list|,
name|String
name|name
parameter_list|)
block|{
return|return
name|name
operator|.
name|toLowerCase
argument_list|()
operator|.
name|endsWith
argument_list|(
literal|".aff"
argument_list|)
return|;
block|}
block|}
block|}
end_class

end_unit

