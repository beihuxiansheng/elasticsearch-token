begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to ElasticSearch and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. ElasticSearch licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.search.lookup
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|lookup
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|CollectionStatistics
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|MinimalMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_comment
comment|/**  * Script interface to all information regarding a field.  * */
end_comment

begin_class
DECL|class|IndexField
specifier|public
class|class
name|IndexField
extends|extends
name|MinimalMap
argument_list|<
name|String
argument_list|,
name|IndexFieldTerm
argument_list|>
block|{
comment|/*      * TermsInfo Objects that represent the Terms are stored in this map when      * requested. Information such as frequency, doc frequency and positions      * information can be retrieved from the TermInfo objects in this map.      */
DECL|field|terms
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|IndexFieldTerm
argument_list|>
name|terms
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|IndexFieldTerm
argument_list|>
argument_list|()
decl_stmt|;
comment|// the name of this field
DECL|field|fieldName
specifier|private
specifier|final
name|String
name|fieldName
decl_stmt|;
comment|/*      * The holds the current reader. We need it to populate the field      * statistics. We just delegate all requests there      */
DECL|field|indexLookup
specifier|private
name|IndexLookup
name|indexLookup
decl_stmt|;
comment|/*      * General field statistics such as number of documents containing the      * field.      */
DECL|field|fieldStats
specifier|private
specifier|final
name|CollectionStatistics
name|fieldStats
decl_stmt|;
comment|/*      * Uodate posting lists in all TermInfo objects      */
DECL|method|setReader
name|void
name|setReader
parameter_list|(
name|AtomicReader
name|reader
parameter_list|)
block|{
for|for
control|(
name|IndexFieldTerm
name|ti
range|:
name|terms
operator|.
name|values
argument_list|()
control|)
block|{
name|ti
operator|.
name|setNextReader
argument_list|(
name|reader
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Represents a field in a document. Can be used to return information on      * statistics of this field. Information on specific terms in this field can      * be accessed by calling get(String term).      */
DECL|method|IndexField
specifier|public
name|IndexField
parameter_list|(
name|String
name|fieldName
parameter_list|,
name|IndexLookup
name|indexLookup
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|fieldName
operator|!=
literal|null
assert|;
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
assert|assert
name|indexLookup
operator|!=
literal|null
assert|;
name|this
operator|.
name|indexLookup
operator|=
name|indexLookup
expr_stmt|;
name|fieldStats
operator|=
name|this
operator|.
name|indexLookup
operator|.
name|getIndexSearcher
argument_list|()
operator|.
name|collectionStatistics
argument_list|(
name|fieldName
argument_list|)
expr_stmt|;
block|}
comment|/* get number of documents containing the field */
DECL|method|docCount
specifier|public
name|long
name|docCount
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fieldStats
operator|.
name|docCount
argument_list|()
return|;
block|}
comment|/* get sum of the number of words over all documents that were indexed */
DECL|method|sumttf
specifier|public
name|long
name|sumttf
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fieldStats
operator|.
name|sumTotalTermFreq
argument_list|()
return|;
block|}
comment|/*      * get the sum of doc frequencies over all words that appear in any document      * that has the field.      */
DECL|method|sumdf
specifier|public
name|long
name|sumdf
parameter_list|()
throws|throws
name|IOException
block|{
return|return
name|fieldStats
operator|.
name|sumDocFreq
argument_list|()
return|;
block|}
comment|// TODO: might be good to get the field lengths here somewhere?
comment|/*      * Returns a TermInfo object that can be used to access information on      * specific terms. flags can be set as described in TermInfo.      *       * TODO: here might be potential for running time improvement? If we knew in      * advance which terms are requested, we could provide an array which the      * user could then iterate over.      */
DECL|method|get
specifier|public
name|IndexFieldTerm
name|get
parameter_list|(
name|Object
name|key
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|String
name|termString
init|=
operator|(
name|String
operator|)
name|key
decl_stmt|;
name|IndexFieldTerm
name|indexFieldTerm
init|=
name|terms
operator|.
name|get
argument_list|(
name|termString
argument_list|)
decl_stmt|;
comment|// see if we initialized already...
if|if
condition|(
name|indexFieldTerm
operator|==
literal|null
condition|)
block|{
name|indexFieldTerm
operator|=
operator|new
name|IndexFieldTerm
argument_list|(
name|termString
argument_list|,
name|fieldName
argument_list|,
name|indexLookup
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|terms
operator|.
name|put
argument_list|(
name|termString
argument_list|,
name|indexFieldTerm
argument_list|)
expr_stmt|;
block|}
name|indexFieldTerm
operator|.
name|validateFlags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|indexFieldTerm
return|;
block|}
comment|/*      * Returns a TermInfo object that can be used to access information on      * specific terms. flags can be set as described in TermInfo.      */
DECL|method|get
specifier|public
name|IndexFieldTerm
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
comment|// per default, do not initialize any positions info
return|return
name|get
argument_list|(
name|key
argument_list|,
name|IndexLookup
operator|.
name|FLAG_FREQUENCIES
argument_list|)
return|;
block|}
DECL|method|setDocIdInTerms
specifier|public
name|void
name|setDocIdInTerms
parameter_list|(
name|int
name|docId
parameter_list|)
block|{
for|for
control|(
name|IndexFieldTerm
name|ti
range|:
name|terms
operator|.
name|values
argument_list|()
control|)
block|{
name|ti
operator|.
name|setNextDoc
argument_list|(
name|docId
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

