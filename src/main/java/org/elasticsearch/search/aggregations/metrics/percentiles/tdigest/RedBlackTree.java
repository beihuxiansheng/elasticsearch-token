begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.search.aggregations.metrics.percentiles.tdigest
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|aggregations
operator|.
name|metrics
operator|.
name|percentiles
operator|.
name|tdigest
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|IntArrayDeque
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|cursors
operator|.
name|IntCursor
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|UnmodifiableIterator
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ArrayUtil
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|OpenBitSet
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|RamUsageEstimator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_comment
comment|/**  * A red-black tree that identifies every node with a unique dense integer ID to make it easy to store node-specific data into  * parallel arrays. This implementation doesn't support more than 2B nodes.  */
end_comment

begin_class
DECL|class|RedBlackTree
specifier|public
specifier|abstract
class|class
name|RedBlackTree
implements|implements
name|Iterable
argument_list|<
name|IntCursor
argument_list|>
block|{
DECL|field|NIL
specifier|protected
specifier|static
specifier|final
name|int
name|NIL
init|=
literal|0
decl_stmt|;
DECL|field|BLACK
DECL|field|RED
specifier|private
specifier|static
specifier|final
name|boolean
name|BLACK
init|=
literal|false
decl_stmt|,
name|RED
init|=
literal|true
decl_stmt|;
DECL|field|size
specifier|private
name|int
name|size
decl_stmt|;
DECL|field|maxNode
specifier|private
name|int
name|maxNode
decl_stmt|;
DECL|field|root
specifier|private
name|int
name|root
decl_stmt|;
DECL|field|unusedSlots
specifier|private
specifier|final
name|IntArrayDeque
name|unusedSlots
decl_stmt|;
DECL|field|leftNodes
DECL|field|rightNodes
DECL|field|parentNodes
specifier|private
name|int
index|[]
name|leftNodes
decl_stmt|,
name|rightNodes
decl_stmt|,
name|parentNodes
decl_stmt|;
DECL|field|colors
specifier|private
specifier|final
name|OpenBitSet
name|colors
decl_stmt|;
comment|/** Create a new instance able to store<code>capacity</code> without resizing. */
DECL|method|RedBlackTree
specifier|protected
name|RedBlackTree
parameter_list|(
name|int
name|capacity
parameter_list|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|maxNode
operator|=
literal|1
expr_stmt|;
name|root
operator|=
name|NIL
expr_stmt|;
name|leftNodes
operator|=
operator|new
name|int
index|[
literal|1
operator|+
name|capacity
index|]
expr_stmt|;
name|rightNodes
operator|=
operator|new
name|int
index|[
literal|1
operator|+
name|capacity
index|]
expr_stmt|;
name|parentNodes
operator|=
operator|new
name|int
index|[
literal|1
operator|+
name|capacity
index|]
expr_stmt|;
name|colors
operator|=
operator|new
name|OpenBitSet
argument_list|(
literal|1
operator|+
name|capacity
argument_list|)
expr_stmt|;
name|unusedSlots
operator|=
operator|new
name|IntArrayDeque
argument_list|()
expr_stmt|;
block|}
comment|/** Return the identifier of the root of the tree. */
DECL|method|root
specifier|protected
specifier|final
name|int
name|root
parameter_list|()
block|{
assert|assert
name|size
operator|>
literal|0
operator|||
name|root
operator|==
name|NIL
assert|;
return|return
name|root
return|;
block|}
comment|/** Release a node */
DECL|method|releaseNode
specifier|protected
name|void
name|releaseNode
parameter_list|(
name|int
name|node
parameter_list|)
block|{
name|unusedSlots
operator|.
name|addLast
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|node
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|left
argument_list|(
name|node
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
name|right
argument_list|(
name|node
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
comment|/** Create a new node in this tree. */
DECL|method|newNode
specifier|protected
name|int
name|newNode
parameter_list|()
block|{
if|if
condition|(
name|unusedSlots
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
specifier|final
name|int
name|slot
init|=
name|maxNode
operator|++
decl_stmt|;
if|if
condition|(
name|maxNode
operator|>
name|leftNodes
operator|.
name|length
condition|)
block|{
specifier|final
name|int
name|minSize
init|=
name|ArrayUtil
operator|.
name|oversize
argument_list|(
name|maxNode
argument_list|,
name|RamUsageEstimator
operator|.
name|NUM_BYTES_INT
argument_list|)
decl_stmt|;
name|leftNodes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|leftNodes
argument_list|,
name|minSize
argument_list|)
expr_stmt|;
name|rightNodes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|rightNodes
argument_list|,
name|minSize
argument_list|)
expr_stmt|;
name|parentNodes
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|parentNodes
argument_list|,
name|minSize
argument_list|)
expr_stmt|;
name|colors
operator|.
name|ensureCapacity
argument_list|(
name|leftNodes
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
return|return
name|slot
return|;
block|}
else|else
block|{
return|return
name|unusedSlots
operator|.
name|removeLast
argument_list|()
return|;
block|}
block|}
comment|/** Return the number of nodes in this tree. */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
assert|assert
name|size
operator|==
name|maxNode
operator|-
name|unusedSlots
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|:
name|size
operator|+
literal|" != "
operator|+
operator|(
name|maxNode
operator|-
name|unusedSlots
operator|.
name|size
argument_list|()
operator|-
literal|1
operator|)
assert|;
return|return
name|size
return|;
block|}
DECL|method|color
specifier|private
name|boolean
name|color
parameter_list|(
name|int
name|node
parameter_list|)
block|{
return|return
name|colors
operator|.
name|get
argument_list|(
name|node
argument_list|)
return|;
block|}
DECL|method|color
specifier|private
name|void
name|color
parameter_list|(
name|int
name|node
parameter_list|,
name|boolean
name|color
parameter_list|)
block|{
assert|assert
name|node
operator|!=
name|NIL
assert|;
if|if
condition|(
name|color
condition|)
block|{
name|colors
operator|.
name|fastSet
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|colors
operator|.
name|fastClear
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Return the parent of the given node. */
DECL|method|parent
specifier|protected
specifier|final
name|int
name|parent
parameter_list|(
name|int
name|node
parameter_list|)
block|{
return|return
name|parentNodes
index|[
name|node
index|]
return|;
block|}
DECL|method|parent
specifier|private
name|void
name|parent
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|parent
parameter_list|)
block|{
assert|assert
name|node
operator|!=
name|NIL
assert|;
name|parentNodes
index|[
name|node
index|]
operator|=
name|parent
expr_stmt|;
block|}
comment|/** Return the left child of the given node. */
DECL|method|left
specifier|protected
specifier|final
name|int
name|left
parameter_list|(
name|int
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|!=
name|NIL
assert|;
return|return
name|leftNodes
index|[
name|node
index|]
return|;
block|}
DECL|method|left
specifier|protected
name|void
name|left
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|leftNode
parameter_list|)
block|{
assert|assert
name|node
operator|!=
name|NIL
assert|;
name|leftNodes
index|[
name|node
index|]
operator|=
name|leftNode
expr_stmt|;
block|}
comment|/** Return the right child of the given node. */
DECL|method|right
specifier|protected
specifier|final
name|int
name|right
parameter_list|(
name|int
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|!=
name|NIL
assert|;
return|return
name|rightNodes
index|[
name|node
index|]
return|;
block|}
DECL|method|right
specifier|private
name|void
name|right
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|rightNode
parameter_list|)
block|{
assert|assert
name|node
operator|!=
name|NIL
assert|;
name|rightNodes
index|[
name|node
index|]
operator|=
name|rightNode
expr_stmt|;
block|}
comment|// return the number of black nodes to go through up to leaves
comment|// to use within assertions only
DECL|method|numBlackNode
specifier|private
name|int
name|numBlackNode
parameter_list|(
name|int
name|node
parameter_list|)
block|{
assert|assert
name|assertConsistent
argument_list|(
name|node
argument_list|)
assert|;
if|if
condition|(
name|node
operator|==
name|NIL
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
specifier|final
name|int
name|numLeft
init|=
name|numBlackNode
argument_list|(
name|left
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
specifier|final
name|int
name|numRight
init|=
name|numBlackNode
argument_list|(
name|right
argument_list|(
name|node
argument_list|)
argument_list|)
decl_stmt|;
assert|assert
name|numLeft
operator|==
name|numRight
operator|:
name|numLeft
operator|+
literal|" "
operator|+
name|numRight
assert|;
name|int
name|num
init|=
name|numLeft
decl_stmt|;
if|if
condition|(
name|color
argument_list|(
name|node
argument_list|)
operator|==
name|BLACK
condition|)
block|{
operator|++
name|num
expr_stmt|;
block|}
return|return
name|num
return|;
block|}
block|}
comment|// check consistency of parent/left/right
DECL|method|assertConsistent
specifier|private
name|boolean
name|assertConsistent
parameter_list|(
name|int
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|NIL
condition|)
block|{
return|return
literal|true
return|;
block|}
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|NIL
condition|)
block|{
assert|assert
name|node
operator|==
name|root
assert|;
block|}
else|else
block|{
assert|assert
name|node
operator|==
name|left
argument_list|(
name|parent
argument_list|)
operator|||
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
assert|;
block|}
specifier|final
name|int
name|left
init|=
name|left
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|!=
name|NIL
condition|)
block|{
assert|assert
name|parent
argument_list|(
name|left
argument_list|)
operator|==
name|node
assert|;
block|}
specifier|final
name|int
name|right
init|=
name|right
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|!=
name|NIL
condition|)
block|{
assert|assert
name|parent
argument_list|(
name|right
argument_list|)
operator|==
name|node
assert|;
block|}
return|return
literal|true
return|;
block|}
comment|// for testing
DECL|method|assertConsistent
specifier|public
name|void
name|assertConsistent
parameter_list|()
block|{
name|numBlackNode
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
comment|/** Rotate left the subtree under<code>n</code> */
DECL|method|rotateLeft
specifier|protected
name|void
name|rotateLeft
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|final
name|int
name|r
init|=
name|right
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|int
name|lr
init|=
name|left
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|right
argument_list|(
name|n
argument_list|,
name|left
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|!=
name|NIL
condition|)
block|{
name|parent
argument_list|(
name|lr
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|p
init|=
name|parent
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|parent
argument_list|(
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NIL
condition|)
block|{
name|root
operator|=
name|r
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left
argument_list|(
name|p
argument_list|)
operator|==
name|n
condition|)
block|{
name|left
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|right
argument_list|(
name|p
argument_list|)
operator|==
name|n
assert|;
name|right
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|left
argument_list|(
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|n
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
comment|/** Rotate right the subtree under<code>n</code> */
DECL|method|rotateRight
specifier|protected
name|void
name|rotateRight
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|final
name|int
name|l
init|=
name|left
argument_list|(
name|n
argument_list|)
decl_stmt|;
specifier|final
name|int
name|rl
init|=
name|right
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|left
argument_list|(
name|n
argument_list|,
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NIL
condition|)
block|{
name|parent
argument_list|(
name|rl
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|p
init|=
name|parent
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|parent
argument_list|(
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NIL
condition|)
block|{
name|root
operator|=
name|l
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|right
argument_list|(
name|p
argument_list|)
operator|==
name|n
condition|)
block|{
name|right
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|left
argument_list|(
name|p
argument_list|)
operator|==
name|n
assert|;
name|left
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|right
argument_list|(
name|l
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|n
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
comment|/** Called after insertions. Base implementation just balances the tree,      *  see http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Insertion */
DECL|method|afterInsertion
specifier|protected
name|void
name|afterInsertion
parameter_list|(
name|int
name|node
parameter_list|)
block|{
name|color
argument_list|(
name|node
argument_list|,
name|RED
argument_list|)
expr_stmt|;
name|insertCase1
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
DECL|method|insertCase1
specifier|private
name|void
name|insertCase1
parameter_list|(
name|int
name|node
parameter_list|)
block|{
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|NIL
condition|)
block|{
assert|assert
name|node
operator|==
name|root
assert|;
name|color
argument_list|(
name|node
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insertCase2
argument_list|(
name|node
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|insertCase2
specifier|private
name|void
name|insertCase2
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|parent
parameter_list|)
block|{
if|if
condition|(
name|color
argument_list|(
name|parent
argument_list|)
operator|!=
name|BLACK
condition|)
block|{
name|insertCase3
argument_list|(
name|node
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|insertCase3
specifier|private
name|void
name|insertCase3
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|parent
parameter_list|)
block|{
specifier|final
name|int
name|grandParent
init|=
name|parent
argument_list|(
name|parent
argument_list|)
decl_stmt|;
assert|assert
name|grandParent
operator|!=
name|NIL
assert|;
specifier|final
name|int
name|uncle
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|left
argument_list|(
name|grandParent
argument_list|)
condition|)
block|{
name|uncle
operator|=
name|right
argument_list|(
name|grandParent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|parent
operator|==
name|right
argument_list|(
name|grandParent
argument_list|)
assert|;
name|uncle
operator|=
name|left
argument_list|(
name|grandParent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uncle
operator|!=
name|NIL
operator|&&
name|color
argument_list|(
name|uncle
argument_list|)
operator|==
name|RED
condition|)
block|{
name|color
argument_list|(
name|parent
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|uncle
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|grandParent
argument_list|,
name|RED
argument_list|)
expr_stmt|;
name|insertCase1
argument_list|(
name|grandParent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insertCase4
argument_list|(
name|node
argument_list|,
name|parent
argument_list|,
name|grandParent
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|insertCase4
specifier|private
name|void
name|insertCase4
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|parent
parameter_list|,
name|int
name|grandParent
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
operator|&&
name|parent
operator|==
name|left
argument_list|(
name|grandParent
argument_list|)
condition|)
block|{
name|rotateLeft
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|node
operator|=
name|left
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
name|left
argument_list|(
name|parent
argument_list|)
operator|&&
name|parent
operator|==
name|right
argument_list|(
name|grandParent
argument_list|)
condition|)
block|{
name|rotateRight
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|node
operator|=
name|right
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|insertCase5
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
DECL|method|insertCase5
specifier|private
name|void
name|insertCase5
parameter_list|(
name|int
name|node
parameter_list|)
block|{
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|grandParent
init|=
name|parent
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|color
argument_list|(
name|parent
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|grandParent
argument_list|,
name|RED
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|left
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|rotateRight
argument_list|(
name|grandParent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
assert|;
name|rotateLeft
argument_list|(
name|grandParent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Called before the removal of a node. */
DECL|method|beforeRemoval
specifier|protected
name|void
name|beforeRemoval
parameter_list|(
name|int
name|node
parameter_list|)
block|{}
comment|// see http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal
comment|/** Called after removal. Base implementation just balances the tree,      *  see http://en.wikipedia.org/wiki/Red%E2%80%93black_tree#Removal */
DECL|method|afterRemoval
specifier|protected
name|void
name|afterRemoval
parameter_list|(
name|int
name|node
parameter_list|)
block|{
assert|assert
name|node
operator|!=
name|NIL
assert|;
if|if
condition|(
name|color
argument_list|(
name|node
argument_list|)
operator|==
name|BLACK
condition|)
block|{
name|removeCase1
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|sibling
specifier|private
name|int
name|sibling
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|parent
parameter_list|)
block|{
specifier|final
name|int
name|left
init|=
name|left
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|left
condition|)
block|{
return|return
name|right
argument_list|(
name|parent
argument_list|)
return|;
block|}
else|else
block|{
assert|assert
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
assert|;
return|return
name|left
return|;
block|}
block|}
DECL|method|removeCase1
specifier|private
name|void
name|removeCase1
parameter_list|(
name|int
name|node
parameter_list|)
block|{
if|if
condition|(
name|parent
argument_list|(
name|node
argument_list|)
operator|!=
name|NIL
condition|)
block|{
name|removeCase2
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeCase2
specifier|private
name|void
name|removeCase2
parameter_list|(
name|int
name|node
parameter_list|)
block|{
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|sibling
init|=
name|sibling
argument_list|(
name|node
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|color
argument_list|(
name|sibling
argument_list|)
operator|==
name|RED
condition|)
block|{
name|color
argument_list|(
name|sibling
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|,
name|RED
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|left
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|rotateLeft
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
assert|;
name|rotateRight
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
name|removeCase3
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
DECL|method|removeCase3
specifier|private
name|void
name|removeCase3
parameter_list|(
name|int
name|node
parameter_list|)
block|{
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|sibling
init|=
name|sibling
argument_list|(
name|node
argument_list|,
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|color
argument_list|(
name|parent
argument_list|)
operator|==
name|BLACK
operator|&&
name|sibling
operator|!=
name|NIL
operator|&&
name|color
argument_list|(
name|sibling
argument_list|)
operator|==
name|BLACK
operator|&&
name|color
argument_list|(
name|left
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|BLACK
operator|&&
name|color
argument_list|(
name|right
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|BLACK
condition|)
block|{
name|color
argument_list|(
name|sibling
argument_list|,
name|RED
argument_list|)
expr_stmt|;
name|removeCase1
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeCase4
argument_list|(
name|node
argument_list|,
name|parent
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeCase4
specifier|private
name|void
name|removeCase4
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|parent
parameter_list|,
name|int
name|sibling
parameter_list|)
block|{
if|if
condition|(
name|color
argument_list|(
name|parent
argument_list|)
operator|==
name|RED
operator|&&
name|sibling
operator|!=
name|NIL
operator|&&
name|color
argument_list|(
name|sibling
argument_list|)
operator|==
name|BLACK
operator|&&
name|color
argument_list|(
name|left
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|BLACK
operator|&&
name|color
argument_list|(
name|right
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|BLACK
condition|)
block|{
name|color
argument_list|(
name|sibling
argument_list|,
name|RED
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|removeCase5
argument_list|(
name|node
argument_list|,
name|parent
argument_list|,
name|sibling
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeCase5
specifier|private
name|void
name|removeCase5
parameter_list|(
name|int
name|node
parameter_list|,
name|int
name|parent
parameter_list|,
name|int
name|sibling
parameter_list|)
block|{
if|if
condition|(
name|color
argument_list|(
name|sibling
argument_list|)
operator|==
name|BLACK
condition|)
block|{
if|if
condition|(
name|node
operator|==
name|left
argument_list|(
name|parent
argument_list|)
operator|&&
name|sibling
operator|!=
name|NIL
operator|&&
name|color
argument_list|(
name|left
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|RED
operator|&&
name|color
argument_list|(
name|right
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|BLACK
condition|)
block|{
name|color
argument_list|(
name|sibling
argument_list|,
name|RED
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|left
argument_list|(
name|sibling
argument_list|)
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|rotateRight
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
operator|&&
name|sibling
operator|!=
name|NIL
operator|&&
name|color
argument_list|(
name|left
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|BLACK
operator|&&
name|color
argument_list|(
name|right
argument_list|(
name|sibling
argument_list|)
argument_list|)
operator|==
name|RED
condition|)
block|{
name|color
argument_list|(
name|sibling
argument_list|,
name|RED
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|right
argument_list|(
name|sibling
argument_list|)
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|rotateLeft
argument_list|(
name|sibling
argument_list|)
expr_stmt|;
block|}
block|}
name|removeCase6
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
DECL|method|removeCase6
specifier|private
name|void
name|removeCase6
parameter_list|(
name|int
name|node
parameter_list|)
block|{
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|final
name|int
name|sibling
init|=
name|sibling
argument_list|(
name|node
argument_list|,
name|parent
argument_list|)
decl_stmt|;
name|color
argument_list|(
name|sibling
argument_list|,
name|color
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|parent
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|left
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|color
argument_list|(
name|right
argument_list|(
name|sibling
argument_list|)
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|rotateLeft
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
assert|;
name|color
argument_list|(
name|left
argument_list|(
name|sibling
argument_list|)
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
name|rotateRight
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** Compare to<code>node</code>. */
DECL|method|compare
specifier|protected
specifier|abstract
name|int
name|compare
parameter_list|(
name|int
name|node
parameter_list|)
function_decl|;
comment|/** Copy data used for comparison into<code>node</code>. */
DECL|method|copy
specifier|protected
specifier|abstract
name|void
name|copy
parameter_list|(
name|int
name|node
parameter_list|)
function_decl|;
comment|/** Merge data used for comparison into<code>node</code>. */
DECL|method|merge
specifier|protected
specifier|abstract
name|void
name|merge
parameter_list|(
name|int
name|node
parameter_list|)
function_decl|;
comment|/** Add a node to the tree. */
DECL|method|addNode
specifier|public
name|boolean
name|addNode
parameter_list|()
block|{
name|int
name|newNode
init|=
name|NIL
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|newNode
operator|=
name|root
operator|=
name|newNode
argument_list|()
expr_stmt|;
name|copy
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|parent
init|=
name|NIL
decl_stmt|,
name|node
init|=
name|root
decl_stmt|;
name|int
name|cmp
decl_stmt|;
do|do
block|{
name|cmp
operator|=
name|compare
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|parent
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|left
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|right
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|merge
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
do|while
condition|(
name|node
operator|!=
name|NIL
condition|)
do|;
name|newNode
operator|=
name|newNode
argument_list|()
expr_stmt|;
name|copy
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|left
argument_list|(
name|parent
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|cmp
operator|>
literal|0
assert|;
name|right
argument_list|(
name|parent
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
block|}
name|parent
argument_list|(
name|newNode
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
operator|++
name|size
expr_stmt|;
name|afterInsertion
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|getNode
specifier|public
name|int
name|getNode
parameter_list|()
block|{
if|if
condition|(
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|NIL
return|;
block|}
name|int
name|node
init|=
name|root
decl_stmt|;
do|do
block|{
specifier|final
name|int
name|cmp
init|=
name|compare
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|node
operator|=
name|left
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
block|{
name|node
operator|=
name|right
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|node
return|;
block|}
block|}
do|while
condition|(
name|node
operator|!=
name|NIL
condition|)
do|;
return|return
name|NIL
return|;
block|}
comment|/** Swap two nodes. */
DECL|method|swap
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|node1
parameter_list|,
name|int
name|node2
parameter_list|)
block|{
specifier|final
name|int
name|parent1
init|=
name|parent
argument_list|(
name|node1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|parent2
init|=
name|parent
argument_list|(
name|node2
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent1
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|node1
operator|==
name|left
argument_list|(
name|parent1
argument_list|)
condition|)
block|{
name|left
argument_list|(
name|parent1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|node1
operator|==
name|right
argument_list|(
name|parent1
argument_list|)
assert|;
name|right
argument_list|(
name|parent1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|root
operator|==
name|node1
assert|;
name|root
operator|=
name|node2
expr_stmt|;
block|}
if|if
condition|(
name|parent2
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|node2
operator|==
name|left
argument_list|(
name|parent2
argument_list|)
condition|)
block|{
name|left
argument_list|(
name|parent2
argument_list|,
name|node1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|node2
operator|==
name|right
argument_list|(
name|parent2
argument_list|)
assert|;
name|right
argument_list|(
name|parent2
argument_list|,
name|node1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|root
operator|==
name|node2
assert|;
name|root
operator|=
name|node1
expr_stmt|;
block|}
name|parent
argument_list|(
name|node1
argument_list|,
name|parent2
argument_list|)
expr_stmt|;
name|parent
argument_list|(
name|node2
argument_list|,
name|parent1
argument_list|)
expr_stmt|;
specifier|final
name|int
name|left1
init|=
name|left
argument_list|(
name|node1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|left2
init|=
name|left
argument_list|(
name|node2
argument_list|)
decl_stmt|;
name|left
argument_list|(
name|node1
argument_list|,
name|left2
argument_list|)
expr_stmt|;
if|if
condition|(
name|left2
operator|!=
name|NIL
condition|)
block|{
name|parent
argument_list|(
name|left2
argument_list|,
name|node1
argument_list|)
expr_stmt|;
block|}
name|left
argument_list|(
name|node2
argument_list|,
name|left1
argument_list|)
expr_stmt|;
if|if
condition|(
name|left1
operator|!=
name|NIL
condition|)
block|{
name|parent
argument_list|(
name|left1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
block|}
specifier|final
name|int
name|right1
init|=
name|right
argument_list|(
name|node1
argument_list|)
decl_stmt|;
specifier|final
name|int
name|right2
init|=
name|right
argument_list|(
name|node2
argument_list|)
decl_stmt|;
name|right
argument_list|(
name|node1
argument_list|,
name|right2
argument_list|)
expr_stmt|;
if|if
condition|(
name|right2
operator|!=
name|NIL
condition|)
block|{
name|parent
argument_list|(
name|right2
argument_list|,
name|node1
argument_list|)
expr_stmt|;
block|}
name|right
argument_list|(
name|node2
argument_list|,
name|right1
argument_list|)
expr_stmt|;
if|if
condition|(
name|right1
operator|!=
name|NIL
condition|)
block|{
name|parent
argument_list|(
name|right1
argument_list|,
name|node2
argument_list|)
expr_stmt|;
block|}
specifier|final
name|boolean
name|color1
init|=
name|color
argument_list|(
name|node1
argument_list|)
decl_stmt|;
specifier|final
name|boolean
name|color2
init|=
name|color
argument_list|(
name|node2
argument_list|)
decl_stmt|;
name|color
argument_list|(
name|node1
argument_list|,
name|color2
argument_list|)
expr_stmt|;
name|color
argument_list|(
name|node2
argument_list|,
name|color1
argument_list|)
expr_stmt|;
name|assertConsistent
argument_list|(
name|node1
argument_list|)
expr_stmt|;
name|assertConsistent
argument_list|(
name|node2
argument_list|)
expr_stmt|;
block|}
comment|/** Remove a node from the tree. */
DECL|method|removeNode
specifier|public
name|void
name|removeNode
parameter_list|(
name|int
name|nodeToRemove
parameter_list|)
block|{
assert|assert
name|nodeToRemove
operator|!=
name|NIL
assert|;
if|if
condition|(
name|left
argument_list|(
name|nodeToRemove
argument_list|)
operator|!=
name|NIL
operator|&&
name|right
argument_list|(
name|nodeToRemove
argument_list|)
operator|!=
name|NIL
condition|)
block|{
specifier|final
name|int
name|next
init|=
name|nextNode
argument_list|(
name|nodeToRemove
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|NIL
condition|)
block|{
name|swap
argument_list|(
name|nodeToRemove
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|//copy(next, nodeToRemove);
comment|//nodeToRemove = next;
block|}
block|}
assert|assert
name|left
argument_list|(
name|nodeToRemove
argument_list|)
operator|==
name|NIL
operator|||
name|right
argument_list|(
name|nodeToRemove
argument_list|)
operator|==
name|NIL
assert|;
specifier|final
name|int
name|left
init|=
name|left
argument_list|(
name|nodeToRemove
argument_list|)
decl_stmt|;
name|int
name|child
init|=
name|left
operator|!=
name|NIL
condition|?
name|left
else|:
name|right
argument_list|(
name|nodeToRemove
argument_list|)
decl_stmt|;
name|beforeRemoval
argument_list|(
name|nodeToRemove
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|NIL
condition|)
block|{
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|nodeToRemove
argument_list|)
decl_stmt|;
name|parent
argument_list|(
name|child
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|nodeToRemove
operator|==
name|left
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|left
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|nodeToRemove
operator|==
name|right
argument_list|(
name|parent
argument_list|)
assert|;
name|right
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
assert|assert
name|nodeToRemove
operator|==
name|root
assert|;
name|root
operator|=
name|child
expr_stmt|;
block|}
if|if
condition|(
name|color
argument_list|(
name|nodeToRemove
argument_list|)
operator|==
name|BLACK
condition|)
block|{
name|color
argument_list|(
name|child
argument_list|,
name|BLACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|afterRemoval
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// no children
specifier|final
name|int
name|parent
init|=
name|parent
argument_list|(
name|nodeToRemove
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|NIL
condition|)
block|{
assert|assert
name|nodeToRemove
operator|==
name|root
assert|;
name|root
operator|=
name|NIL
expr_stmt|;
block|}
else|else
block|{
name|afterRemoval
argument_list|(
name|nodeToRemove
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeToRemove
operator|==
name|left
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|left
argument_list|(
name|parent
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|nodeToRemove
operator|==
name|right
argument_list|(
name|parent
argument_list|)
assert|;
name|right
argument_list|(
name|parent
argument_list|,
name|NIL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|releaseNode
argument_list|(
name|nodeToRemove
argument_list|)
expr_stmt|;
operator|--
name|size
expr_stmt|;
block|}
comment|/** Return the least node under<code>node</code>. */
DECL|method|first
specifier|protected
specifier|final
name|int
name|first
parameter_list|(
name|int
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|NIL
condition|)
block|{
return|return
name|NIL
return|;
block|}
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|left
init|=
name|left
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|NIL
condition|)
block|{
break|break;
block|}
name|node
operator|=
name|left
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/** Return the largest node under<code>node</code>. */
DECL|method|last
specifier|protected
specifier|final
name|int
name|last
parameter_list|(
name|int
name|node
parameter_list|)
block|{
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|int
name|right
init|=
name|right
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|==
name|NIL
condition|)
block|{
break|break;
block|}
name|node
operator|=
name|right
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
comment|/** Return the previous node. */
DECL|method|prevNode
specifier|public
specifier|final
name|int
name|prevNode
parameter_list|(
name|int
name|node
parameter_list|)
block|{
specifier|final
name|int
name|left
init|=
name|left
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|left
operator|!=
name|NIL
condition|)
block|{
return|return
name|last
argument_list|(
name|left
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|parent
operator|!=
name|NIL
operator|&&
name|node
operator|==
name|left
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|node
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|parent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
name|parent
return|;
block|}
block|}
comment|/** Return the next node. */
DECL|method|nextNode
specifier|public
specifier|final
name|int
name|nextNode
parameter_list|(
name|int
name|node
parameter_list|)
block|{
specifier|final
name|int
name|right
init|=
name|right
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|right
operator|!=
name|NIL
condition|)
block|{
return|return
name|first
argument_list|(
name|right
argument_list|)
return|;
block|}
else|else
block|{
name|int
name|parent
init|=
name|parent
argument_list|(
name|node
argument_list|)
decl_stmt|;
while|while
condition|(
name|parent
operator|!=
name|NIL
operator|&&
name|node
operator|==
name|right
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|node
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|parent
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
return|return
name|parent
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|IntCursor
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|iterator
argument_list|(
name|first
argument_list|(
name|root
argument_list|)
argument_list|)
return|;
block|}
DECL|method|iterator
specifier|private
name|Iterator
argument_list|<
name|IntCursor
argument_list|>
name|iterator
parameter_list|(
specifier|final
name|int
name|startNode
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|IntCursor
argument_list|>
argument_list|()
block|{
name|boolean
name|nextSet
decl_stmt|;
specifier|final
name|IntCursor
name|cursor
decl_stmt|;
block|{
name|cursor
operator|=
operator|new
name|IntCursor
argument_list|()
expr_stmt|;
name|cursor
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|cursor
operator|.
name|value
operator|=
name|startNode
expr_stmt|;
name|nextSet
operator|=
name|cursor
operator|.
name|value
operator|!=
name|NIL
expr_stmt|;
block|}
name|boolean
name|computeNext
parameter_list|()
block|{
if|if
condition|(
name|cursor
operator|.
name|value
operator|!=
name|NIL
condition|)
block|{
name|cursor
operator|.
name|value
operator|=
name|RedBlackTree
operator|.
name|this
operator|.
name|nextNode
argument_list|(
name|cursor
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|nextSet
operator|=
operator|(
name|cursor
operator|.
name|value
operator|!=
name|NIL
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextSet
operator|||
name|computeNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|IntCursor
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|nextSet
operator|=
literal|false
expr_stmt|;
return|return
name|cursor
return|;
block|}
block|}
return|;
block|}
DECL|method|reverseIterator
specifier|public
name|Iterator
argument_list|<
name|IntCursor
argument_list|>
name|reverseIterator
parameter_list|()
block|{
return|return
name|reverseIterator
argument_list|(
name|last
argument_list|(
name|root
argument_list|)
argument_list|)
return|;
block|}
DECL|method|reverseIterator
specifier|private
name|Iterator
argument_list|<
name|IntCursor
argument_list|>
name|reverseIterator
parameter_list|(
specifier|final
name|int
name|startNode
parameter_list|)
block|{
return|return
operator|new
name|UnmodifiableIterator
argument_list|<
name|IntCursor
argument_list|>
argument_list|()
block|{
name|boolean
name|nextSet
decl_stmt|;
specifier|final
name|IntCursor
name|cursor
decl_stmt|;
block|{
name|cursor
operator|=
operator|new
name|IntCursor
argument_list|()
expr_stmt|;
name|cursor
operator|.
name|index
operator|=
operator|-
literal|1
expr_stmt|;
name|cursor
operator|.
name|value
operator|=
name|startNode
expr_stmt|;
name|nextSet
operator|=
name|cursor
operator|.
name|value
operator|!=
name|NIL
expr_stmt|;
block|}
name|boolean
name|computeNext
parameter_list|()
block|{
if|if
condition|(
name|cursor
operator|.
name|value
operator|!=
name|NIL
condition|)
block|{
name|cursor
operator|.
name|value
operator|=
name|RedBlackTree
operator|.
name|this
operator|.
name|prevNode
argument_list|(
name|cursor
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|nextSet
operator|=
operator|(
name|cursor
operator|.
name|value
operator|!=
name|NIL
operator|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextSet
operator|||
name|computeNext
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|IntCursor
name|next
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hasNext
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
name|nextSet
operator|=
literal|false
expr_stmt|;
return|return
name|cursor
return|;
block|}
block|}
return|;
block|}
comment|/** Return a view over the nodes that are stored after<code>startNode</code> in the tree. */
DECL|method|tailSet
specifier|public
name|Iterable
argument_list|<
name|IntCursor
argument_list|>
name|tailSet
parameter_list|(
specifier|final
name|int
name|startNode
parameter_list|)
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|IntCursor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|IntCursor
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|RedBlackTree
operator|.
name|this
operator|.
name|iterator
argument_list|(
name|startNode
argument_list|)
return|;
block|}
block|}
return|;
block|}
comment|/** Return a reversed view over the elements of this tree. */
DECL|method|reverseSet
specifier|public
name|Iterable
argument_list|<
name|IntCursor
argument_list|>
name|reverseSet
parameter_list|()
block|{
return|return
operator|new
name|Iterable
argument_list|<
name|IntCursor
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|Iterator
argument_list|<
name|IntCursor
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|RedBlackTree
operator|.
name|this
operator|.
name|reverseIterator
argument_list|()
return|;
block|}
block|}
return|;
block|}
block|}
end_class

end_unit

