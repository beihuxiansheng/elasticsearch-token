begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.shard
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Charsets
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Preconditions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|codecs
operator|.
name|PostingsFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|CheckIndex
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|join
operator|.
name|BitDocIdSetFilter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|AlreadyClosedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|ThreadInterruptedException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|Version
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|flush
operator|.
name|FlushRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|action
operator|.
name|admin
operator|.
name|indices
operator|.
name|optimize
operator|.
name|OptimizeRequest
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|ClusterService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|IndexMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|node
operator|.
name|DiscoveryNode
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|RestoreSource
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRouting
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Booleans
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|collect
operator|.
name|Tuple
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|search
operator|.
name|Queries
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|metrics
operator|.
name|MeanMetric
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|TimeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|BigArrays
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractRefCounted
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|env
operator|.
name|NodeEnvironment
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|gateway
operator|.
name|MetaDataStateFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|IndexService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|VersionType
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|aliases
operator|.
name|IndexAliasesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|IndexCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|bitset
operator|.
name|ShardBitsetFilterCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|filter
operator|.
name|FilterCacheStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|filter
operator|.
name|ShardFilterCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|cache
operator|.
name|query
operator|.
name|ShardQueryCache
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|codec
operator|.
name|CodecService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|deletionpolicy
operator|.
name|SnapshotDeletionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|deletionpolicy
operator|.
name|SnapshotIndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|engine
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|FieldDataStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|IndexFieldDataService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|fielddata
operator|.
name|ShardFieldData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|flush
operator|.
name|FlushStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|get
operator|.
name|GetStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|get
operator|.
name|ShardGetService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|indexing
operator|.
name|IndexingStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|indexing
operator|.
name|ShardIndexingService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|merge
operator|.
name|MergeStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|merge
operator|.
name|policy
operator|.
name|MergePolicyProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|merge
operator|.
name|scheduler
operator|.
name|MergeSchedulerProvider
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|percolator
operator|.
name|PercolatorQueriesRegistry
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|percolator
operator|.
name|stats
operator|.
name|ShardPercolateService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|IndexQueryParserService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|recovery
operator|.
name|RecoveryStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|refresh
operator|.
name|RefreshStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|search
operator|.
name|stats
operator|.
name|SearchStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|search
operator|.
name|stats
operator|.
name|ShardSearchService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|settings
operator|.
name|IndexSettingsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|similarity
operator|.
name|SimilarityService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
operator|.
name|MetadataSnapshot
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|suggest
operator|.
name|stats
operator|.
name|ShardSuggestService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|suggest
operator|.
name|stats
operator|.
name|SuggestStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|termvectors
operator|.
name|ShardTermVectorsService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|Translog
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogConfig
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|translog
operator|.
name|TranslogWriter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|warmer
operator|.
name|ShardIndexWarmerService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|warmer
operator|.
name|WarmerStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesLifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesWarmer
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|InternalIndicesLifecycle
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|recovery
operator|.
name|RecoveryState
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|suggest
operator|.
name|completion
operator|.
name|Completion090PostingsFormat
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|search
operator|.
name|suggest
operator|.
name|completion
operator|.
name|CompletionStats
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|threadpool
operator|.
name|ThreadPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|PrintStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|nio
operator|.
name|channels
operator|.
name|ClosedByInterruptException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Locale
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ScheduledFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_comment
comment|/**  *  */
end_comment

begin_class
DECL|class|IndexShard
specifier|public
class|class
name|IndexShard
extends|extends
name|AbstractIndexShardComponent
block|{
DECL|field|threadPool
specifier|private
specifier|final
name|ThreadPool
name|threadPool
decl_stmt|;
DECL|field|indexSettingsService
specifier|private
specifier|final
name|IndexSettingsService
name|indexSettingsService
decl_stmt|;
DECL|field|mapperService
specifier|private
specifier|final
name|MapperService
name|mapperService
decl_stmt|;
DECL|field|queryParserService
specifier|private
specifier|final
name|IndexQueryParserService
name|queryParserService
decl_stmt|;
DECL|field|indexCache
specifier|private
specifier|final
name|IndexCache
name|indexCache
decl_stmt|;
DECL|field|indicesLifecycle
specifier|private
specifier|final
name|InternalIndicesLifecycle
name|indicesLifecycle
decl_stmt|;
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|mergeScheduler
specifier|private
specifier|final
name|MergeSchedulerProvider
name|mergeScheduler
decl_stmt|;
DECL|field|indexAliasesService
specifier|private
specifier|final
name|IndexAliasesService
name|indexAliasesService
decl_stmt|;
DECL|field|indexingService
specifier|private
specifier|final
name|ShardIndexingService
name|indexingService
decl_stmt|;
DECL|field|searchService
specifier|private
specifier|final
name|ShardSearchService
name|searchService
decl_stmt|;
DECL|field|getService
specifier|private
specifier|final
name|ShardGetService
name|getService
decl_stmt|;
DECL|field|shardWarmerService
specifier|private
specifier|final
name|ShardIndexWarmerService
name|shardWarmerService
decl_stmt|;
DECL|field|shardFilterCache
specifier|private
specifier|final
name|ShardFilterCache
name|shardFilterCache
decl_stmt|;
DECL|field|shardQueryCache
specifier|private
specifier|final
name|ShardQueryCache
name|shardQueryCache
decl_stmt|;
DECL|field|shardFieldData
specifier|private
specifier|final
name|ShardFieldData
name|shardFieldData
decl_stmt|;
DECL|field|percolatorQueriesRegistry
specifier|private
specifier|final
name|PercolatorQueriesRegistry
name|percolatorQueriesRegistry
decl_stmt|;
DECL|field|shardPercolateService
specifier|private
specifier|final
name|ShardPercolateService
name|shardPercolateService
decl_stmt|;
DECL|field|termVectorsService
specifier|private
specifier|final
name|ShardTermVectorsService
name|termVectorsService
decl_stmt|;
DECL|field|indexFieldDataService
specifier|private
specifier|final
name|IndexFieldDataService
name|indexFieldDataService
decl_stmt|;
DECL|field|indexService
specifier|private
specifier|final
name|IndexService
name|indexService
decl_stmt|;
DECL|field|shardSuggestService
specifier|private
specifier|final
name|ShardSuggestService
name|shardSuggestService
decl_stmt|;
DECL|field|shardBitsetFilterCache
specifier|private
specifier|final
name|ShardBitsetFilterCache
name|shardBitsetFilterCache
decl_stmt|;
DECL|field|localNode
specifier|private
specifier|final
name|DiscoveryNode
name|localNode
decl_stmt|;
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|checkIndexOnStartup
specifier|private
specifier|final
name|String
name|checkIndexOnStartup
decl_stmt|;
DECL|field|nodeEnv
specifier|private
specifier|final
name|NodeEnvironment
name|nodeEnv
decl_stmt|;
DECL|field|codecService
specifier|private
specifier|final
name|CodecService
name|codecService
decl_stmt|;
DECL|field|warmer
specifier|private
specifier|final
name|IndicesWarmer
name|warmer
decl_stmt|;
DECL|field|deletionPolicy
specifier|private
specifier|final
name|SnapshotDeletionPolicy
name|deletionPolicy
decl_stmt|;
DECL|field|similarityService
specifier|private
specifier|final
name|SimilarityService
name|similarityService
decl_stmt|;
DECL|field|mergePolicyProvider
specifier|private
specifier|final
name|MergePolicyProvider
name|mergePolicyProvider
decl_stmt|;
DECL|field|bigArrays
specifier|private
specifier|final
name|BigArrays
name|bigArrays
decl_stmt|;
DECL|field|engineConfig
specifier|private
specifier|final
name|EngineConfig
name|engineConfig
decl_stmt|;
DECL|field|translogConfig
specifier|private
specifier|final
name|TranslogConfig
name|translogConfig
decl_stmt|;
DECL|field|refreshInterval
specifier|private
name|TimeValue
name|refreshInterval
decl_stmt|;
DECL|field|refreshScheduledFuture
specifier|private
specifier|volatile
name|ScheduledFuture
name|refreshScheduledFuture
decl_stmt|;
DECL|field|mergeScheduleFuture
specifier|private
specifier|volatile
name|ScheduledFuture
name|mergeScheduleFuture
decl_stmt|;
DECL|field|shardRouting
specifier|protected
specifier|volatile
name|ShardRouting
name|shardRouting
decl_stmt|;
DECL|field|state
specifier|protected
specifier|volatile
name|IndexShardState
name|state
decl_stmt|;
DECL|field|currentEngineReference
specifier|protected
specifier|final
name|AtomicReference
argument_list|<
name|Engine
argument_list|>
name|currentEngineReference
init|=
operator|new
name|AtomicReference
argument_list|<>
argument_list|()
decl_stmt|;
DECL|field|engineFactory
specifier|protected
specifier|final
name|EngineFactory
name|engineFactory
decl_stmt|;
annotation|@
name|Nullable
DECL|field|recoveryState
specifier|private
name|RecoveryState
name|recoveryState
decl_stmt|;
DECL|field|recoveryStats
specifier|private
specifier|final
name|RecoveryStats
name|recoveryStats
init|=
operator|new
name|RecoveryStats
argument_list|()
decl_stmt|;
DECL|field|applyRefreshSettings
specifier|private
name|ApplyRefreshSettings
name|applyRefreshSettings
init|=
operator|new
name|ApplyRefreshSettings
argument_list|()
decl_stmt|;
DECL|field|refreshMetric
specifier|private
specifier|final
name|MeanMetric
name|refreshMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|field|flushMetric
specifier|private
specifier|final
name|MeanMetric
name|flushMetric
init|=
operator|new
name|MeanMetric
argument_list|()
decl_stmt|;
DECL|field|failedEngineListener
specifier|private
specifier|final
name|ShardEngineFailListener
name|failedEngineListener
init|=
operator|new
name|ShardEngineFailListener
argument_list|()
decl_stmt|;
DECL|field|mapperAnalyzer
specifier|private
specifier|final
name|MapperAnalyzer
name|mapperAnalyzer
decl_stmt|;
DECL|field|flushOnClose
specifier|private
specifier|volatile
name|boolean
name|flushOnClose
init|=
literal|true
decl_stmt|;
comment|/**      * Index setting to control if a flush is executed before engine is closed      * This setting is realtime updateable.      */
DECL|field|INDEX_FLUSH_ON_CLOSE
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_FLUSH_ON_CLOSE
init|=
literal|"index.flush_on_close"
decl_stmt|;
DECL|field|path
specifier|private
specifier|final
name|ShardPath
name|path
decl_stmt|;
DECL|field|indexShardOperationCounter
specifier|private
specifier|final
name|IndexShardOperationCounter
name|indexShardOperationCounter
decl_stmt|;
annotation|@
name|Inject
DECL|method|IndexShard
specifier|public
name|IndexShard
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|IndexSettingsService
name|indexSettingsService
parameter_list|,
name|IndicesLifecycle
name|indicesLifecycle
parameter_list|,
name|Store
name|store
parameter_list|,
name|MergeSchedulerProvider
name|mergeScheduler
parameter_list|,
name|ThreadPool
name|threadPool
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|IndexQueryParserService
name|queryParserService
parameter_list|,
name|IndexCache
name|indexCache
parameter_list|,
name|IndexAliasesService
name|indexAliasesService
parameter_list|,
name|ShardIndexingService
name|indexingService
parameter_list|,
name|ShardGetService
name|getService
parameter_list|,
name|ShardSearchService
name|searchService
parameter_list|,
name|ShardIndexWarmerService
name|shardWarmerService
parameter_list|,
name|ShardFilterCache
name|shardFilterCache
parameter_list|,
name|ShardFieldData
name|shardFieldData
parameter_list|,
name|PercolatorQueriesRegistry
name|percolatorQueriesRegistry
parameter_list|,
name|ShardPercolateService
name|shardPercolateService
parameter_list|,
name|CodecService
name|codecService
parameter_list|,
name|ShardTermVectorsService
name|termVectorsService
parameter_list|,
name|IndexFieldDataService
name|indexFieldDataService
parameter_list|,
name|IndexService
name|indexService
parameter_list|,
name|ShardSuggestService
name|shardSuggestService
parameter_list|,
name|ShardQueryCache
name|shardQueryCache
parameter_list|,
name|ShardBitsetFilterCache
name|shardBitsetFilterCache
parameter_list|,
annotation|@
name|Nullable
name|IndicesWarmer
name|warmer
parameter_list|,
name|SnapshotDeletionPolicy
name|deletionPolicy
parameter_list|,
name|SimilarityService
name|similarityService
parameter_list|,
name|MergePolicyProvider
name|mergePolicyProvider
parameter_list|,
name|EngineFactory
name|factory
parameter_list|,
name|ClusterService
name|clusterService
parameter_list|,
name|NodeEnvironment
name|nodeEnv
parameter_list|,
name|ShardPath
name|path
parameter_list|,
name|BigArrays
name|bigArrays
parameter_list|)
block|{
name|super
argument_list|(
name|shardId
argument_list|,
name|indexSettingsService
operator|.
name|getSettings
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|codecService
operator|=
name|codecService
expr_stmt|;
name|this
operator|.
name|warmer
operator|=
name|warmer
expr_stmt|;
name|this
operator|.
name|deletionPolicy
operator|=
name|deletionPolicy
expr_stmt|;
name|this
operator|.
name|similarityService
operator|=
name|similarityService
expr_stmt|;
name|this
operator|.
name|mergePolicyProvider
operator|=
name|mergePolicyProvider
expr_stmt|;
name|this
operator|.
name|bigArrays
operator|=
name|bigArrays
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|store
argument_list|,
literal|"Store must be provided to the index shard"
argument_list|)
expr_stmt|;
name|Preconditions
operator|.
name|checkNotNull
argument_list|(
name|deletionPolicy
argument_list|,
literal|"Snapshot deletion policy must be provided to the index shard"
argument_list|)
expr_stmt|;
name|this
operator|.
name|engineFactory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|indicesLifecycle
operator|=
operator|(
name|InternalIndicesLifecycle
operator|)
name|indicesLifecycle
expr_stmt|;
name|this
operator|.
name|indexSettingsService
operator|=
name|indexSettingsService
expr_stmt|;
name|this
operator|.
name|store
operator|=
name|store
expr_stmt|;
name|this
operator|.
name|mergeScheduler
operator|=
name|mergeScheduler
expr_stmt|;
name|this
operator|.
name|threadPool
operator|=
name|threadPool
expr_stmt|;
name|this
operator|.
name|mapperService
operator|=
name|mapperService
expr_stmt|;
name|this
operator|.
name|queryParserService
operator|=
name|queryParserService
expr_stmt|;
name|this
operator|.
name|indexCache
operator|=
name|indexCache
expr_stmt|;
name|this
operator|.
name|indexAliasesService
operator|=
name|indexAliasesService
expr_stmt|;
name|this
operator|.
name|indexingService
operator|=
name|indexingService
expr_stmt|;
name|this
operator|.
name|getService
operator|=
name|getService
operator|.
name|setIndexShard
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|termVectorsService
operator|=
name|termVectorsService
operator|.
name|setIndexShard
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchService
operator|=
name|searchService
expr_stmt|;
name|this
operator|.
name|shardWarmerService
operator|=
name|shardWarmerService
expr_stmt|;
name|this
operator|.
name|shardFilterCache
operator|=
name|shardFilterCache
expr_stmt|;
name|this
operator|.
name|shardQueryCache
operator|=
name|shardQueryCache
expr_stmt|;
name|this
operator|.
name|shardFieldData
operator|=
name|shardFieldData
expr_stmt|;
name|this
operator|.
name|percolatorQueriesRegistry
operator|=
name|percolatorQueriesRegistry
expr_stmt|;
name|this
operator|.
name|shardPercolateService
operator|=
name|shardPercolateService
expr_stmt|;
name|this
operator|.
name|indexFieldDataService
operator|=
name|indexFieldDataService
expr_stmt|;
name|this
operator|.
name|indexService
operator|=
name|indexService
expr_stmt|;
name|this
operator|.
name|shardSuggestService
operator|=
name|shardSuggestService
expr_stmt|;
name|this
operator|.
name|shardBitsetFilterCache
operator|=
name|shardBitsetFilterCache
expr_stmt|;
assert|assert
name|clusterService
operator|.
name|localNode
argument_list|()
operator|!=
literal|null
operator|:
literal|"Local node is null lifecycle state is: "
operator|+
name|clusterService
operator|.
name|lifecycleState
argument_list|()
assert|;
name|this
operator|.
name|localNode
operator|=
name|clusterService
operator|.
name|localNode
argument_list|()
expr_stmt|;
name|state
operator|=
name|IndexShardState
operator|.
name|CREATED
expr_stmt|;
name|this
operator|.
name|refreshInterval
operator|=
name|indexSettings
operator|.
name|getAsTime
argument_list|(
name|INDEX_REFRESH_INTERVAL
argument_list|,
name|EngineConfig
operator|.
name|DEFAULT_REFRESH_INTERVAL
argument_list|)
expr_stmt|;
name|this
operator|.
name|flushOnClose
operator|=
name|indexSettings
operator|.
name|getAsBoolean
argument_list|(
name|INDEX_FLUSH_ON_CLOSE
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|this
operator|.
name|nodeEnv
operator|=
name|nodeEnv
expr_stmt|;
name|indexSettingsService
operator|.
name|addListener
argument_list|(
name|applyRefreshSettings
argument_list|)
expr_stmt|;
name|this
operator|.
name|mapperAnalyzer
operator|=
operator|new
name|MapperAnalyzer
argument_list|(
name|mapperService
argument_list|)
expr_stmt|;
name|this
operator|.
name|path
operator|=
name|path
expr_stmt|;
comment|/* create engine config */
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [CREATED]"
argument_list|)
expr_stmt|;
name|this
operator|.
name|checkIndexOnStartup
operator|=
name|indexSettings
operator|.
name|get
argument_list|(
literal|"index.shard.check_on_startup"
argument_list|,
literal|"false"
argument_list|)
expr_stmt|;
name|this
operator|.
name|translogConfig
operator|=
operator|new
name|TranslogConfig
argument_list|(
name|shardId
argument_list|,
name|shardPath
argument_list|()
operator|.
name|resolveTranslog
argument_list|()
argument_list|,
name|indexSettings
argument_list|,
name|getFromSettings
argument_list|(
name|logger
argument_list|,
name|indexSettings
argument_list|,
name|Translog
operator|.
name|Durabilty
operator|.
name|REQUEST
argument_list|)
argument_list|,
name|bigArrays
argument_list|,
name|threadPool
argument_list|)
expr_stmt|;
name|this
operator|.
name|engineConfig
operator|=
name|newEngineConfig
argument_list|(
name|translogConfig
argument_list|)
expr_stmt|;
name|this
operator|.
name|indexShardOperationCounter
operator|=
operator|new
name|IndexShardOperationCounter
argument_list|(
name|logger
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
DECL|method|store
specifier|public
name|Store
name|store
parameter_list|()
block|{
return|return
name|this
operator|.
name|store
return|;
block|}
comment|/** returns true if this shard supports indexing (i.e., write) operations. */
DECL|method|canIndex
specifier|public
name|boolean
name|canIndex
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
DECL|method|indexingService
specifier|public
name|ShardIndexingService
name|indexingService
parameter_list|()
block|{
return|return
name|this
operator|.
name|indexingService
return|;
block|}
DECL|method|getService
specifier|public
name|ShardGetService
name|getService
parameter_list|()
block|{
return|return
name|this
operator|.
name|getService
return|;
block|}
DECL|method|termVectorsService
specifier|public
name|ShardTermVectorsService
name|termVectorsService
parameter_list|()
block|{
return|return
name|termVectorsService
return|;
block|}
DECL|method|shardSuggestService
specifier|public
name|ShardSuggestService
name|shardSuggestService
parameter_list|()
block|{
return|return
name|shardSuggestService
return|;
block|}
DECL|method|shardBitsetFilterCache
specifier|public
name|ShardBitsetFilterCache
name|shardBitsetFilterCache
parameter_list|()
block|{
return|return
name|shardBitsetFilterCache
return|;
block|}
DECL|method|indexFieldDataService
specifier|public
name|IndexFieldDataService
name|indexFieldDataService
parameter_list|()
block|{
return|return
name|indexFieldDataService
return|;
block|}
DECL|method|mapperService
specifier|public
name|MapperService
name|mapperService
parameter_list|()
block|{
return|return
name|mapperService
return|;
block|}
DECL|method|indexService
specifier|public
name|IndexService
name|indexService
parameter_list|()
block|{
return|return
name|indexService
return|;
block|}
DECL|method|searchService
specifier|public
name|ShardSearchService
name|searchService
parameter_list|()
block|{
return|return
name|this
operator|.
name|searchService
return|;
block|}
DECL|method|warmerService
specifier|public
name|ShardIndexWarmerService
name|warmerService
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardWarmerService
return|;
block|}
DECL|method|filterCache
specifier|public
name|ShardFilterCache
name|filterCache
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardFilterCache
return|;
block|}
DECL|method|queryCache
specifier|public
name|ShardQueryCache
name|queryCache
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardQueryCache
return|;
block|}
DECL|method|fieldData
specifier|public
name|ShardFieldData
name|fieldData
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardFieldData
return|;
block|}
comment|/**      * Returns the latest cluster routing entry received with this shard. Might be null if the      * shard was just created.      */
DECL|method|routingEntry
specifier|public
name|ShardRouting
name|routingEntry
parameter_list|()
block|{
return|return
name|this
operator|.
name|shardRouting
return|;
block|}
comment|/**      * Updates the shards routing entry. This mutate the shards internal state depending      * on the changes that get introduced by the new routing value. This method will persist shard level metadata      * unless explicitly disabled.      */
DECL|method|updateRoutingEntry
specifier|public
name|void
name|updateRoutingEntry
parameter_list|(
specifier|final
name|ShardRouting
name|newRouting
parameter_list|,
specifier|final
name|boolean
name|persistState
parameter_list|)
block|{
specifier|final
name|ShardRouting
name|currentRouting
init|=
name|this
operator|.
name|shardRouting
decl_stmt|;
if|if
condition|(
operator|!
name|newRouting
operator|.
name|shardId
argument_list|()
operator|.
name|equals
argument_list|(
name|shardId
argument_list|()
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Trying to set a routing entry with shardId ["
operator|+
name|newRouting
operator|.
name|shardId
argument_list|()
operator|+
literal|"] on a shard with shardId ["
operator|+
name|shardId
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
try|try
block|{
if|if
condition|(
name|currentRouting
operator|!=
literal|null
condition|)
block|{
assert|assert
name|newRouting
operator|.
name|version
argument_list|()
operator|>
name|currentRouting
operator|.
name|version
argument_list|()
operator|:
literal|"expected: "
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"> "
operator|+
name|currentRouting
operator|.
name|version
argument_list|()
assert|;
if|if
condition|(
operator|!
name|newRouting
operator|.
name|primary
argument_list|()
operator|&&
name|currentRouting
operator|.
name|primary
argument_list|()
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"suspect illegal state: trying to move shard from primary mode to replica mode"
argument_list|)
expr_stmt|;
block|}
comment|// if its the same routing, return
if|if
condition|(
name|currentRouting
operator|.
name|equals
argument_list|(
name|newRouting
argument_list|)
condition|)
block|{
name|this
operator|.
name|shardRouting
operator|=
name|newRouting
expr_stmt|;
comment|// might have a new version
return|return;
block|}
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
comment|// if the state is started or relocating (cause it might move right away from started to relocating)
comment|// then move to STARTED
if|if
condition|(
name|newRouting
operator|.
name|state
argument_list|()
operator|==
name|ShardRoutingState
operator|.
name|STARTED
operator|||
name|newRouting
operator|.
name|state
argument_list|()
operator|==
name|ShardRoutingState
operator|.
name|RELOCATING
condition|)
block|{
comment|// we want to refresh *before* we move to internal STARTED state
try|try
block|{
name|engine
argument_list|()
operator|.
name|refresh
argument_list|(
literal|"cluster_state_started"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to refresh due to move to cluster wide started"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|boolean
name|movedToStarted
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
comment|// do the check under a mutex, so we make sure to only change to STARTED if in POST_RECOVERY
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|STARTED
argument_list|,
literal|"global state is ["
operator|+
name|newRouting
operator|.
name|state
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
name|movedToStarted
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"state [{}] not changed, not in POST_RECOVERY, global state is [{}]"
argument_list|,
name|state
argument_list|,
name|newRouting
operator|.
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|movedToStarted
condition|)
block|{
name|indicesLifecycle
operator|.
name|afterIndexShardStarted
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|this
operator|.
name|shardRouting
operator|=
name|newRouting
expr_stmt|;
name|indicesLifecycle
operator|.
name|shardRoutingChanged
argument_list|(
name|this
argument_list|,
name|currentRouting
argument_list|,
name|newRouting
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|persistState
condition|)
block|{
name|persistMetadata
argument_list|(
name|newRouting
argument_list|,
name|currentRouting
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Marks the shard as recovering based on a remote or local node, fails with exception is recovering is not allowed to be set.      */
DECL|method|recovering
specifier|public
name|IndexShardState
name|recovering
parameter_list|(
name|String
name|reason
parameter_list|,
name|RecoveryState
operator|.
name|Type
name|type
parameter_list|,
name|DiscoveryNode
name|sourceNode
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardRecoveringException
throws|,
name|IndexShardClosedException
block|{
return|return
name|recovering
argument_list|(
name|reason
argument_list|,
operator|new
name|RecoveryState
argument_list|(
name|shardId
argument_list|,
name|shardRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|type
argument_list|,
name|sourceNode
argument_list|,
name|localNode
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Marks the shard as recovering based on a restore, fails with exception is recovering is not allowed to be set.      */
DECL|method|recovering
specifier|public
name|IndexShardState
name|recovering
parameter_list|(
name|String
name|reason
parameter_list|,
name|RecoveryState
operator|.
name|Type
name|type
parameter_list|,
name|RestoreSource
name|restoreSource
parameter_list|)
throws|throws
name|IndexShardStartedException
block|{
return|return
name|recovering
argument_list|(
name|reason
argument_list|,
operator|new
name|RecoveryState
argument_list|(
name|shardId
argument_list|,
name|shardRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|type
argument_list|,
name|restoreSource
argument_list|,
name|localNode
argument_list|)
argument_list|)
return|;
block|}
DECL|method|recovering
specifier|private
name|IndexShardState
name|recovering
parameter_list|(
name|String
name|reason
parameter_list|,
name|RecoveryState
name|recoveryState
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardRecoveringException
throws|,
name|IndexShardClosedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardRecoveringException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IndexShardRecoveringException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
name|this
operator|.
name|recoveryState
operator|=
name|recoveryState
expr_stmt|;
return|return
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|RECOVERING
argument_list|,
name|reason
argument_list|)
return|;
block|}
block|}
DECL|method|relocated
specifier|public
name|IndexShard
name|relocated
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardNotStartedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|RELOCATED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
return|return
name|this
return|;
block|}
DECL|method|state
specifier|public
name|IndexShardState
name|state
parameter_list|()
block|{
return|return
name|state
return|;
block|}
comment|/**      * Changes the state of the current shard      *      * @param newState the new shard state      * @param reason   the reason for the state change      * @return the previous shard state      */
DECL|method|changeState
specifier|private
name|IndexShardState
name|changeState
parameter_list|(
name|IndexShardState
name|newState
parameter_list|,
name|String
name|reason
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"state: [{}]->[{}], reason [{}]"
argument_list|,
name|state
argument_list|,
name|newState
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|IndexShardState
name|previousState
init|=
name|state
decl_stmt|;
name|state
operator|=
name|newState
expr_stmt|;
name|this
operator|.
name|indicesLifecycle
operator|.
name|indexShardStateChanged
argument_list|(
name|this
argument_list|,
name|previousState
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return
name|previousState
return|;
block|}
DECL|method|prepareCreate
specifier|public
name|Engine
operator|.
name|Create
name|prepareCreate
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|,
name|boolean
name|canHaveDuplicates
parameter_list|,
name|boolean
name|autoGeneratedId
parameter_list|)
block|{
try|try
block|{
return|return
name|prepareCreate
argument_list|(
name|docMapper
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
argument_list|,
name|source
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|||
name|canHaveDuplicates
argument_list|,
name|autoGeneratedId
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|verifyNotClosed
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
DECL|method|prepareCreate
specifier|static
name|Engine
operator|.
name|Create
name|prepareCreate
parameter_list|(
name|Tuple
argument_list|<
name|DocumentMapper
argument_list|,
name|Mapping
argument_list|>
name|docMapper
parameter_list|,
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|,
name|boolean
name|canHaveDuplicates
parameter_list|,
name|boolean
name|autoGeneratedId
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|v1
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|docMapper
operator|.
name|v2
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|docMapper
operator|.
name|v2
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Engine
operator|.
name|Create
argument_list|(
name|docMapper
operator|.
name|v1
argument_list|()
argument_list|,
name|docMapper
operator|.
name|v1
argument_list|()
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|doc
operator|.
name|uid
argument_list|()
operator|.
name|stringValue
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|,
name|canHaveDuplicates
argument_list|,
name|autoGeneratedId
argument_list|)
return|;
block|}
DECL|method|create
specifier|public
name|void
name|create
parameter_list|(
name|Engine
operator|.
name|Create
name|create
parameter_list|)
block|{
name|writeAllowed
argument_list|(
name|create
operator|.
name|origin
argument_list|()
argument_list|)
expr_stmt|;
name|create
operator|=
name|indexingService
operator|.
name|preCreate
argument_list|(
name|create
argument_list|)
expr_stmt|;
name|mapperAnalyzer
operator|.
name|setType
argument_list|(
name|create
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"index [{}][{}]{}"
argument_list|,
name|create
operator|.
name|type
argument_list|()
argument_list|,
name|create
operator|.
name|id
argument_list|()
argument_list|,
name|create
operator|.
name|docs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
argument_list|()
operator|.
name|create
argument_list|(
name|create
argument_list|)
expr_stmt|;
name|create
operator|.
name|endTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|indexingService
operator|.
name|postCreate
argument_list|(
name|create
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|indexingService
operator|.
name|postCreate
argument_list|(
name|create
argument_list|)
expr_stmt|;
block|}
DECL|method|prepareIndex
specifier|public
name|Engine
operator|.
name|Index
name|prepareIndex
parameter_list|(
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|,
name|boolean
name|canHaveDuplicates
parameter_list|)
block|{
try|try
block|{
return|return
name|prepareIndex
argument_list|(
name|docMapper
argument_list|(
name|source
operator|.
name|type
argument_list|()
argument_list|)
argument_list|,
name|source
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|||
name|canHaveDuplicates
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|verifyNotClosed
argument_list|(
name|t
argument_list|)
expr_stmt|;
throw|throw
name|t
throw|;
block|}
block|}
DECL|method|prepareIndex
specifier|static
name|Engine
operator|.
name|Index
name|prepareIndex
parameter_list|(
name|Tuple
argument_list|<
name|DocumentMapper
argument_list|,
name|Mapping
argument_list|>
name|docMapper
parameter_list|,
name|SourceToParse
name|source
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|,
name|boolean
name|canHaveDuplicates
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|ParsedDocument
name|doc
init|=
name|docMapper
operator|.
name|v1
argument_list|()
operator|.
name|parse
argument_list|(
name|source
argument_list|)
decl_stmt|;
if|if
condition|(
name|docMapper
operator|.
name|v2
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|doc
operator|.
name|addDynamicMappingsUpdate
argument_list|(
name|docMapper
operator|.
name|v2
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|Engine
operator|.
name|Index
argument_list|(
name|docMapper
operator|.
name|v1
argument_list|()
argument_list|,
name|docMapper
operator|.
name|v1
argument_list|()
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|doc
operator|.
name|uid
argument_list|()
operator|.
name|stringValue
argument_list|()
argument_list|)
argument_list|,
name|doc
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|,
name|canHaveDuplicates
argument_list|)
return|;
block|}
comment|/**      * Index a document and return whether it was created, as opposed to just      * updated.      */
DECL|method|index
specifier|public
name|boolean
name|index
parameter_list|(
name|Engine
operator|.
name|Index
name|index
parameter_list|)
block|{
name|writeAllowed
argument_list|(
name|index
operator|.
name|origin
argument_list|()
argument_list|)
expr_stmt|;
name|index
operator|=
name|indexingService
operator|.
name|preIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|mapperAnalyzer
operator|.
name|setType
argument_list|(
name|index
operator|.
name|type
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|created
decl_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"index [{}][{}]{}"
argument_list|,
name|index
operator|.
name|type
argument_list|()
argument_list|,
name|index
operator|.
name|id
argument_list|()
argument_list|,
name|index
operator|.
name|docs
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|created
operator|=
name|engine
argument_list|()
operator|.
name|index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|index
operator|.
name|endTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|indexingService
operator|.
name|postIndex
argument_list|(
name|index
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|indexingService
operator|.
name|postIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|created
return|;
block|}
DECL|method|prepareDelete
specifier|public
name|Engine
operator|.
name|Delete
name|prepareDelete
parameter_list|(
name|String
name|type
parameter_list|,
name|String
name|id
parameter_list|,
name|long
name|version
parameter_list|,
name|VersionType
name|versionType
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
specifier|final
name|DocumentMapper
name|documentMapper
init|=
name|docMapper
argument_list|(
name|type
argument_list|)
operator|.
name|v1
argument_list|()
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|Delete
argument_list|(
name|type
argument_list|,
name|id
argument_list|,
name|documentMapper
operator|.
name|uidMapper
argument_list|()
operator|.
name|term
argument_list|(
name|Uid
operator|.
name|createUid
argument_list|(
name|type
argument_list|,
name|id
argument_list|)
argument_list|)
argument_list|,
name|version
argument_list|,
name|versionType
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|Engine
operator|.
name|Delete
name|delete
parameter_list|)
block|{
name|writeAllowed
argument_list|(
name|delete
operator|.
name|origin
argument_list|()
argument_list|)
expr_stmt|;
name|delete
operator|=
name|indexingService
operator|.
name|preDelete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"delete [{}]"
argument_list|,
name|delete
operator|.
name|uid
argument_list|()
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|engine
argument_list|()
operator|.
name|delete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|delete
operator|.
name|endTime
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|indexingService
operator|.
name|postDelete
argument_list|(
name|delete
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
name|ex
throw|;
block|}
name|indexingService
operator|.
name|postDelete
argument_list|(
name|delete
argument_list|)
expr_stmt|;
block|}
DECL|method|prepareDeleteByQuery
specifier|public
name|Engine
operator|.
name|DeleteByQuery
name|prepareDeleteByQuery
parameter_list|(
name|BytesReference
name|source
parameter_list|,
annotation|@
name|Nullable
name|String
index|[]
name|filteringAliases
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|,
name|String
modifier|...
name|types
parameter_list|)
block|{
return|return
name|prepareDeleteByQuery
argument_list|(
name|queryParserService
argument_list|,
name|mapperService
argument_list|,
name|indexAliasesService
argument_list|,
name|indexCache
argument_list|,
name|source
argument_list|,
name|filteringAliases
argument_list|,
name|origin
argument_list|,
name|types
argument_list|)
return|;
block|}
DECL|method|prepareDeleteByQuery
specifier|static
name|Engine
operator|.
name|DeleteByQuery
name|prepareDeleteByQuery
parameter_list|(
name|IndexQueryParserService
name|queryParserService
parameter_list|,
name|MapperService
name|mapperService
parameter_list|,
name|IndexAliasesService
name|indexAliasesService
parameter_list|,
name|IndexCache
name|indexCache
parameter_list|,
name|BytesReference
name|source
parameter_list|,
annotation|@
name|Nullable
name|String
index|[]
name|filteringAliases
parameter_list|,
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|,
name|String
modifier|...
name|types
parameter_list|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
name|types
operator|==
literal|null
condition|)
block|{
name|types
operator|=
name|Strings
operator|.
name|EMPTY_ARRAY
expr_stmt|;
block|}
name|Query
name|query
init|=
name|queryParserService
operator|.
name|parseQuery
argument_list|(
name|source
argument_list|)
operator|.
name|query
argument_list|()
decl_stmt|;
name|Query
name|searchFilter
init|=
name|mapperService
operator|.
name|searchFilter
argument_list|(
name|types
argument_list|)
decl_stmt|;
if|if
condition|(
name|searchFilter
operator|!=
literal|null
condition|)
block|{
name|query
operator|=
name|Queries
operator|.
name|filtered
argument_list|(
name|query
argument_list|,
name|searchFilter
argument_list|)
expr_stmt|;
block|}
name|Query
name|aliasFilter
init|=
name|indexAliasesService
operator|.
name|aliasFilter
argument_list|(
name|filteringAliases
argument_list|)
decl_stmt|;
name|BitDocIdSetFilter
name|parentFilter
init|=
name|mapperService
operator|.
name|hasNested
argument_list|()
condition|?
name|indexCache
operator|.
name|bitsetFilterCache
argument_list|()
operator|.
name|getBitDocIdSetFilter
argument_list|(
name|Queries
operator|.
name|newNonNestedFilter
argument_list|()
argument_list|)
else|:
literal|null
decl_stmt|;
return|return
operator|new
name|Engine
operator|.
name|DeleteByQuery
argument_list|(
name|query
argument_list|,
name|source
argument_list|,
name|filteringAliases
argument_list|,
name|aliasFilter
argument_list|,
name|parentFilter
argument_list|,
name|origin
argument_list|,
name|startTime
argument_list|,
name|types
argument_list|)
return|;
block|}
DECL|method|get
specifier|public
name|Engine
operator|.
name|GetResult
name|get
parameter_list|(
name|Engine
operator|.
name|Get
name|get
parameter_list|)
block|{
name|readAllowed
argument_list|()
expr_stmt|;
return|return
name|engine
argument_list|()
operator|.
name|get
argument_list|(
name|get
argument_list|)
return|;
block|}
DECL|method|refresh
specifier|public
name|void
name|refresh
parameter_list|(
name|String
name|source
parameter_list|)
block|{
name|verifyNotClosed
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"refresh with source: {}"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|engine
argument_list|()
operator|.
name|refresh
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|refreshMetric
operator|.
name|inc
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|time
argument_list|)
expr_stmt|;
block|}
DECL|method|refreshStats
specifier|public
name|RefreshStats
name|refreshStats
parameter_list|()
block|{
return|return
operator|new
name|RefreshStats
argument_list|(
name|refreshMetric
operator|.
name|count
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|refreshMetric
operator|.
name|sum
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|flushStats
specifier|public
name|FlushStats
name|flushStats
parameter_list|()
block|{
return|return
operator|new
name|FlushStats
argument_list|(
name|flushMetric
operator|.
name|count
argument_list|()
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|flushMetric
operator|.
name|sum
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
DECL|method|docStats
specifier|public
name|DocsStats
name|docStats
parameter_list|()
block|{
specifier|final
name|Engine
operator|.
name|Searcher
name|searcher
init|=
name|acquireSearcher
argument_list|(
literal|"doc_stats"
argument_list|)
decl_stmt|;
try|try
block|{
return|return
operator|new
name|DocsStats
argument_list|(
name|searcher
operator|.
name|reader
argument_list|()
operator|.
name|numDocs
argument_list|()
argument_list|,
name|searcher
operator|.
name|reader
argument_list|()
operator|.
name|numDeletedDocs
argument_list|()
argument_list|)
return|;
block|}
finally|finally
block|{
name|searcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * @return {@link CommitStats} if engine is open, otherwise null      */
annotation|@
name|Nullable
DECL|method|commitStats
specifier|public
name|CommitStats
name|commitStats
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
return|return
name|engine
operator|==
literal|null
condition|?
literal|null
else|:
name|engine
operator|.
name|commitStats
argument_list|()
return|;
block|}
DECL|method|indexingStats
specifier|public
name|IndexingStats
name|indexingStats
parameter_list|(
name|String
modifier|...
name|types
parameter_list|)
block|{
return|return
name|indexingService
operator|.
name|stats
argument_list|(
name|types
argument_list|)
return|;
block|}
DECL|method|searchStats
specifier|public
name|SearchStats
name|searchStats
parameter_list|(
name|String
modifier|...
name|groups
parameter_list|)
block|{
return|return
name|searchService
operator|.
name|stats
argument_list|(
name|groups
argument_list|)
return|;
block|}
DECL|method|getStats
specifier|public
name|GetStats
name|getStats
parameter_list|()
block|{
return|return
name|getService
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|storeStats
specifier|public
name|StoreStats
name|storeStats
parameter_list|()
block|{
try|try
block|{
return|return
name|store
operator|.
name|stats
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"io exception while building 'store stats'"
argument_list|,
name|e
argument_list|)
throw|;
block|}
catch|catch
parameter_list|(
name|AlreadyClosedException
name|ex
parameter_list|)
block|{
return|return
literal|null
return|;
comment|// already closed
block|}
block|}
DECL|method|mergeStats
specifier|public
name|MergeStats
name|mergeStats
parameter_list|()
block|{
return|return
name|mergeScheduler
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|segmentStats
specifier|public
name|SegmentsStats
name|segmentStats
parameter_list|()
block|{
name|SegmentsStats
name|segmentsStats
init|=
name|engine
argument_list|()
operator|.
name|segmentsStats
argument_list|()
decl_stmt|;
name|segmentsStats
operator|.
name|addBitsetMemoryInBytes
argument_list|(
name|shardBitsetFilterCache
operator|.
name|getMemorySizeInBytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|segmentsStats
return|;
block|}
DECL|method|warmerStats
specifier|public
name|WarmerStats
name|warmerStats
parameter_list|()
block|{
return|return
name|shardWarmerService
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|filterCacheStats
specifier|public
name|FilterCacheStats
name|filterCacheStats
parameter_list|()
block|{
return|return
name|shardFilterCache
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|fieldDataStats
specifier|public
name|FieldDataStats
name|fieldDataStats
parameter_list|(
name|String
modifier|...
name|fields
parameter_list|)
block|{
return|return
name|shardFieldData
operator|.
name|stats
argument_list|(
name|fields
argument_list|)
return|;
block|}
DECL|method|percolateRegistry
specifier|public
name|PercolatorQueriesRegistry
name|percolateRegistry
parameter_list|()
block|{
return|return
name|percolatorQueriesRegistry
return|;
block|}
DECL|method|shardPercolateService
specifier|public
name|ShardPercolateService
name|shardPercolateService
parameter_list|()
block|{
return|return
name|shardPercolateService
return|;
block|}
DECL|method|translogStats
specifier|public
name|TranslogStats
name|translogStats
parameter_list|()
block|{
return|return
name|engine
argument_list|()
operator|.
name|getTranslog
argument_list|()
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|suggestStats
specifier|public
name|SuggestStats
name|suggestStats
parameter_list|()
block|{
return|return
name|shardSuggestService
operator|.
name|stats
argument_list|()
return|;
block|}
DECL|method|completionStats
specifier|public
name|CompletionStats
name|completionStats
parameter_list|(
name|String
modifier|...
name|fields
parameter_list|)
block|{
name|CompletionStats
name|completionStats
init|=
operator|new
name|CompletionStats
argument_list|()
decl_stmt|;
specifier|final
name|Engine
operator|.
name|Searcher
name|currentSearcher
init|=
name|acquireSearcher
argument_list|(
literal|"completion_stats"
argument_list|)
decl_stmt|;
try|try
block|{
name|PostingsFormat
name|postingsFormat
init|=
name|PostingsFormat
operator|.
name|forName
argument_list|(
name|Completion090PostingsFormat
operator|.
name|CODEC_NAME
argument_list|)
decl_stmt|;
if|if
condition|(
name|postingsFormat
operator|instanceof
name|Completion090PostingsFormat
condition|)
block|{
name|Completion090PostingsFormat
name|completionPostingsFormat
init|=
operator|(
name|Completion090PostingsFormat
operator|)
name|postingsFormat
decl_stmt|;
name|completionStats
operator|.
name|add
argument_list|(
name|completionPostingsFormat
operator|.
name|completionStats
argument_list|(
name|currentSearcher
operator|.
name|reader
argument_list|()
argument_list|,
name|fields
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|currentSearcher
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
return|return
name|completionStats
return|;
block|}
DECL|method|syncFlush
specifier|public
name|Engine
operator|.
name|SyncedFlushResult
name|syncFlush
parameter_list|(
name|String
name|syncId
parameter_list|,
name|Engine
operator|.
name|CommitId
name|expectedCommitId
parameter_list|)
block|{
name|verifyStartedOrRecovering
argument_list|()
expr_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"trying to sync flush. sync id [{}]. expected commit id [{}]]"
argument_list|,
name|syncId
argument_list|,
name|expectedCommitId
argument_list|)
expr_stmt|;
return|return
name|engine
argument_list|()
operator|.
name|syncFlush
argument_list|(
name|syncId
argument_list|,
name|expectedCommitId
argument_list|)
return|;
block|}
DECL|method|flush
specifier|public
name|Engine
operator|.
name|CommitId
name|flush
parameter_list|(
name|FlushRequest
name|request
parameter_list|)
throws|throws
name|ElasticsearchException
block|{
name|boolean
name|waitIfOngoing
init|=
name|request
operator|.
name|waitIfOngoing
argument_list|()
decl_stmt|;
name|boolean
name|force
init|=
name|request
operator|.
name|force
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"flush with {}"
argument_list|,
name|request
argument_list|)
expr_stmt|;
block|}
comment|// we allows flush while recovering, since we allow for operations to happen
comment|// while recovering, and we want to keep the translog at bay (up to deletes, which
comment|// we don't gc).
name|verifyStartedOrRecovering
argument_list|()
expr_stmt|;
name|long
name|time
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|Engine
operator|.
name|CommitId
name|commitId
init|=
name|engine
argument_list|()
operator|.
name|flush
argument_list|(
name|force
argument_list|,
name|waitIfOngoing
argument_list|)
decl_stmt|;
name|flushMetric
operator|.
name|inc
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|time
argument_list|)
expr_stmt|;
return|return
name|commitId
return|;
block|}
DECL|method|optimize
specifier|public
name|void
name|optimize
parameter_list|(
name|OptimizeRequest
name|optimize
parameter_list|)
block|{
name|verifyStarted
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"optimize with {}"
argument_list|,
name|optimize
argument_list|)
expr_stmt|;
block|}
name|engine
argument_list|()
operator|.
name|forceMerge
argument_list|(
name|optimize
operator|.
name|flush
argument_list|()
argument_list|,
name|optimize
operator|.
name|maxNumSegments
argument_list|()
argument_list|,
name|optimize
operator|.
name|onlyExpungeDeletes
argument_list|()
argument_list|,
name|optimize
operator|.
name|upgrade
argument_list|()
argument_list|,
name|optimize
operator|.
name|upgradeOnlyAncientSegments
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|snapshotIndex
specifier|public
name|SnapshotIndexCommit
name|snapshotIndex
parameter_list|(
name|boolean
name|flushFirst
parameter_list|)
throws|throws
name|EngineException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
comment|// we allow snapshot on closed index shard, since we want to do one after we close the shard and before we close the engine
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
return|return
name|engine
argument_list|()
operator|.
name|snapshotIndex
argument_list|(
name|flushFirst
argument_list|)
return|;
block|}
else|else
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"snapshot is not allowed"
argument_list|)
throw|;
block|}
block|}
DECL|method|failShard
specifier|public
name|void
name|failShard
parameter_list|(
name|String
name|reason
parameter_list|,
name|Throwable
name|e
parameter_list|)
block|{
comment|// fail the engine. This will cause this shard to also be removed from the node's index service.
name|engine
argument_list|()
operator|.
name|failEngine
argument_list|(
name|reason
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|acquireSearcher
specifier|public
name|Engine
operator|.
name|Searcher
name|acquireSearcher
parameter_list|(
name|String
name|source
parameter_list|)
block|{
return|return
name|acquireSearcher
argument_list|(
name|source
argument_list|,
literal|false
argument_list|)
return|;
block|}
DECL|method|acquireSearcher
specifier|public
name|Engine
operator|.
name|Searcher
name|acquireSearcher
parameter_list|(
name|String
name|source
parameter_list|,
name|boolean
name|searcherForWriteOperation
parameter_list|)
block|{
name|readAllowed
argument_list|(
name|searcherForWriteOperation
argument_list|)
expr_stmt|;
return|return
name|engine
argument_list|()
operator|.
name|acquireSearcher
argument_list|(
name|source
argument_list|)
return|;
block|}
DECL|method|close
specifier|public
name|void
name|close
parameter_list|(
name|String
name|reason
parameter_list|,
name|boolean
name|flushEngine
parameter_list|)
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
try|try
block|{
name|indexSettingsService
operator|.
name|removeListener
argument_list|(
name|applyRefreshSettings
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|refreshScheduledFuture
argument_list|)
expr_stmt|;
name|refreshScheduledFuture
operator|=
literal|null
expr_stmt|;
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|mergeScheduleFuture
argument_list|)
expr_stmt|;
name|mergeScheduleFuture
operator|=
literal|null
expr_stmt|;
block|}
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|CLOSED
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|indexShardOperationCounter
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
specifier|final
name|Engine
name|engine
init|=
name|this
operator|.
name|currentEngineReference
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
try|try
block|{
if|if
condition|(
name|engine
operator|!=
literal|null
operator|&&
name|flushEngine
operator|&&
name|this
operator|.
name|flushOnClose
condition|)
block|{
name|engine
operator|.
name|flushAndClose
argument_list|()
expr_stmt|;
block|}
block|}
finally|finally
block|{
comment|// playing safe here and close the engine even if the above succeeds - close can be called multiple times
name|IOUtils
operator|.
name|close
argument_list|(
name|engine
argument_list|,
name|shardFilterCache
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|postRecovery
specifier|public
name|IndexShard
name|postRecovery
parameter_list|(
name|String
name|reason
parameter_list|)
throws|throws
name|IndexShardStartedException
throws|,
name|IndexShardRelocatedException
throws|,
name|IndexShardClosedException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardStartedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IndexShardRelocatedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
name|changeState
argument_list|(
name|IndexShardState
operator|.
name|POST_RECOVERY
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
name|indicesLifecycle
operator|.
name|afterIndexShardPostRecovery
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * called before starting to copy index files over      */
DECL|method|prepareForIndexRecovery
specifier|public
name|void
name|prepareForIndexRecovery
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|INDEX
argument_list|)
expr_stmt|;
assert|assert
name|currentEngineReference
operator|.
name|get
argument_list|()
operator|==
literal|null
assert|;
block|}
comment|/**      * Applies all operations in the iterable to the current engine and returns the number of operations applied.      * This operation will stop applying operations once an opertion failed to apply.      * Note: This method is typically used in peer recovery to replay remote tansaction log entries.      */
DECL|method|performBatchRecovery
specifier|public
name|int
name|performBatchRecovery
parameter_list|(
name|Iterable
argument_list|<
name|Translog
operator|.
name|Operation
argument_list|>
name|operations
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
return|return
name|engineConfig
operator|.
name|getTranslogRecoveryPerformer
argument_list|()
operator|.
name|performBatchRecovery
argument_list|(
name|engine
argument_list|()
argument_list|,
name|operations
argument_list|)
return|;
block|}
comment|/**      * After the store has been recovered, we need to start the engine in order to apply operations      */
DECL|method|performTranslogRecovery
specifier|public
name|Map
argument_list|<
name|String
argument_list|,
name|Mapping
argument_list|>
name|performTranslogRecovery
parameter_list|()
block|{
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|Mapping
argument_list|>
name|recoveredTypes
init|=
name|internalPerformTranslogRecovery
argument_list|(
literal|false
argument_list|)
decl_stmt|;
assert|assert
name|recoveryState
operator|.
name|getStage
argument_list|()
operator|==
name|RecoveryState
operator|.
name|Stage
operator|.
name|TRANSLOG
operator|:
literal|"TRANSLOG stage expected but was: "
operator|+
name|recoveryState
operator|.
name|getStage
argument_list|()
assert|;
return|return
name|recoveredTypes
return|;
block|}
DECL|method|internalPerformTranslogRecovery
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|Mapping
argument_list|>
name|internalPerformTranslogRecovery
parameter_list|(
name|boolean
name|skipTranslogRecovery
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|VERIFY_INDEX
argument_list|)
expr_stmt|;
comment|// also check here, before we apply the translog
if|if
condition|(
name|Booleans
operator|.
name|parseBoolean
argument_list|(
name|checkIndexOnStartup
argument_list|,
literal|false
argument_list|)
condition|)
block|{
name|checkIndex
argument_list|()
expr_stmt|;
block|}
name|recoveryState
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|TRANSLOG
argument_list|)
expr_stmt|;
comment|// we disable deletes since we allow for operations to be executed against the shard while recovering
comment|// but we need to make sure we don't loose deletes until we are done recovering
name|engineConfig
operator|.
name|setEnableGcDeletes
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|createNewEngine
argument_list|(
name|skipTranslogRecovery
argument_list|,
name|engineConfig
argument_list|)
expr_stmt|;
return|return
name|engineConfig
operator|.
name|getTranslogRecoveryPerformer
argument_list|()
operator|.
name|getRecoveredTypes
argument_list|()
return|;
block|}
comment|/**      * After the store has been recovered, we need to start the engine. This method starts a new engine but skips      * the replay of the transaction log which is required in cases where we restore a previous index or recover from      * a remote peer.      *      * @param wipeTranslogs if set to<code>true</code> all skipped / uncommitted translogs are removed.      */
DECL|method|skipTranslogRecovery
specifier|public
name|void
name|skipTranslogRecovery
parameter_list|(
name|boolean
name|wipeTranslogs
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
name|engineUnsafe
argument_list|()
operator|==
literal|null
operator|:
literal|"engine was already created"
assert|;
name|Map
argument_list|<
name|String
argument_list|,
name|Mapping
argument_list|>
name|recoveredTypes
init|=
name|internalPerformTranslogRecovery
argument_list|(
literal|true
argument_list|)
decl_stmt|;
assert|assert
name|recoveredTypes
operator|.
name|isEmpty
argument_list|()
assert|;
assert|assert
name|recoveryState
operator|.
name|getTranslog
argument_list|()
operator|.
name|recoveredOperations
argument_list|()
operator|==
literal|0
assert|;
block|}
comment|/**      * called if recovery has to be restarted after network error / delay **      */
DECL|method|performRecoveryRestart
specifier|public
name|void
name|performRecoveryRestart
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotRecoveringException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
specifier|final
name|Engine
name|engine
init|=
name|this
operator|.
name|currentEngineReference
operator|.
name|getAndSet
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|IOUtils
operator|.
name|close
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|recoveryState
argument_list|()
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|INIT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * returns stats about ongoing recoveries, both source and target      */
DECL|method|recoveryStats
specifier|public
name|RecoveryStats
name|recoveryStats
parameter_list|()
block|{
return|return
name|recoveryStats
return|;
block|}
comment|/**      * Returns the current {@link RecoveryState} if this shard is recovering or has been recovering.      * Returns null if the recovery has not yet started or shard was not recovered (created via an API).      */
DECL|method|recoveryState
specifier|public
name|RecoveryState
name|recoveryState
parameter_list|()
block|{
return|return
name|this
operator|.
name|recoveryState
return|;
block|}
comment|/**      * perform the last stages of recovery once all translog operations are done.      * note that you should still call {@link #postRecovery(String)}.      */
DECL|method|finalizeRecovery
specifier|public
name|void
name|finalizeRecovery
parameter_list|()
block|{
name|recoveryState
argument_list|()
operator|.
name|setStage
argument_list|(
name|RecoveryState
operator|.
name|Stage
operator|.
name|FINALIZE
argument_list|)
expr_stmt|;
name|engine
argument_list|()
operator|.
name|refresh
argument_list|(
literal|"recovery_finalization"
argument_list|)
expr_stmt|;
name|startScheduledTasksIfNeeded
argument_list|()
expr_stmt|;
name|engineConfig
operator|.
name|setEnableGcDeletes
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns<tt>true</tt> if this shard can ignore a recovery attempt made to it (since the already doing/done it)      */
DECL|method|ignoreRecoveryAttempt
specifier|public
name|boolean
name|ignoreRecoveryAttempt
parameter_list|()
block|{
name|IndexShardState
name|state
init|=
name|state
argument_list|()
decl_stmt|;
comment|// one time volatile read
return|return
name|state
operator|==
name|IndexShardState
operator|.
name|POST_RECOVERY
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RECOVERING
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|STARTED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|RELOCATED
operator|||
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
return|;
block|}
DECL|method|readAllowed
specifier|public
name|void
name|readAllowed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|readAllowed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
DECL|method|readAllowed
specifier|private
name|void
name|readAllowed
parameter_list|(
name|boolean
name|writeOperation
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|writeOperation
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operations only allowed when started/relocated"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operations only allowed when started/relocated"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|writeAllowed
specifier|private
name|void
name|writeAllowed
parameter_list|(
name|Engine
operator|.
name|Operation
operator|.
name|Origin
name|origin
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|origin
operator|==
name|Engine
operator|.
name|Operation
operator|.
name|Origin
operator|.
name|PRIMARY
condition|)
block|{
comment|// for primaries, we only allow to write when actually started (so the cluster has decided we started)
comment|// otherwise, we need to retry, we also want to still allow to index if we are relocated in case it fails
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when started/recovering, origin ["
operator|+
name|origin
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// for replicas, we allow to write also while recovering, since we index also during recovery to replicas
comment|// and rely on version checks to make sure its consistent
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RELOCATED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when started/recovering, origin ["
operator|+
name|origin
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|verifyStartedOrRecovering
specifier|protected
specifier|final
name|void
name|verifyStartedOrRecovering
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|RECOVERING
operator|&&
name|state
operator|!=
name|IndexShardState
operator|.
name|POST_RECOVERY
condition|)
block|{
throw|throw
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when started/recovering"
argument_list|)
throw|;
block|}
block|}
DECL|method|verifyNotClosed
specifier|private
name|void
name|verifyNotClosed
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|verifyNotClosed
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|verifyNotClosed
specifier|private
name|void
name|verifyNotClosed
parameter_list|(
name|Throwable
name|suppressed
parameter_list|)
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
specifier|final
name|IllegalIndexShardStateException
name|exc
init|=
operator|new
name|IllegalIndexShardStateException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|,
literal|"operation only allowed when not closed"
argument_list|)
decl_stmt|;
if|if
condition|(
name|suppressed
operator|!=
literal|null
condition|)
block|{
name|exc
operator|.
name|addSuppressed
argument_list|(
name|suppressed
argument_list|)
expr_stmt|;
block|}
throw|throw
name|exc
throw|;
block|}
block|}
DECL|method|verifyStarted
specifier|protected
specifier|final
name|void
name|verifyStarted
parameter_list|()
throws|throws
name|IllegalIndexShardStateException
block|{
name|IndexShardState
name|state
init|=
name|this
operator|.
name|state
decl_stmt|;
comment|// one time volatile read
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|STARTED
condition|)
block|{
throw|throw
operator|new
name|IndexShardNotStartedException
argument_list|(
name|shardId
argument_list|,
name|state
argument_list|)
throw|;
block|}
block|}
DECL|method|startScheduledTasksIfNeeded
specifier|private
name|void
name|startScheduledTasksIfNeeded
parameter_list|()
block|{
if|if
condition|(
name|refreshInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
operator|new
name|EngineRefresher
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduling refresher every {}"
argument_list|,
name|refreshInterval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"scheduled refresher disabled"
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|INDEX_REFRESH_INTERVAL
specifier|public
specifier|static
specifier|final
name|String
name|INDEX_REFRESH_INTERVAL
init|=
literal|"index.refresh_interval"
decl_stmt|;
DECL|method|addFailedEngineListener
specifier|public
name|void
name|addFailedEngineListener
parameter_list|(
name|Engine
operator|.
name|FailedEngineListener
name|failedEngineListener
parameter_list|)
block|{
name|this
operator|.
name|failedEngineListener
operator|.
name|delegates
operator|.
name|add
argument_list|(
name|failedEngineListener
argument_list|)
expr_stmt|;
block|}
DECL|method|updateBufferSize
specifier|public
name|void
name|updateBufferSize
parameter_list|(
name|ByteSizeValue
name|shardIndexingBufferSize
parameter_list|,
name|ByteSizeValue
name|shardTranslogBufferSize
parameter_list|)
block|{
specifier|final
name|EngineConfig
name|config
init|=
name|engineConfig
decl_stmt|;
specifier|final
name|ByteSizeValue
name|preValue
init|=
name|config
operator|.
name|getIndexingBufferSize
argument_list|()
decl_stmt|;
name|config
operator|.
name|setIndexingBufferSize
argument_list|(
name|shardIndexingBufferSize
argument_list|)
expr_stmt|;
comment|// update engine if it is already started.
if|if
condition|(
name|preValue
operator|.
name|bytes
argument_list|()
operator|!=
name|shardIndexingBufferSize
operator|.
name|bytes
argument_list|()
operator|&&
name|engineUnsafe
argument_list|()
operator|!=
literal|null
condition|)
block|{
comment|// its inactive, make sure we do a refresh / full IW flush in this case, since the memory
comment|// changes only after a "data" change has happened to the writer
comment|// the index writer lazily allocates memory and a refresh will clean it all up.
if|if
condition|(
name|shardIndexingBufferSize
operator|==
name|EngineConfig
operator|.
name|INACTIVE_SHARD_INDEXING_BUFFER
operator|&&
name|preValue
operator|!=
name|EngineConfig
operator|.
name|INACTIVE_SHARD_INDEXING_BUFFER
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updating index_buffer_size from [{}] to (inactive) [{}]"
argument_list|,
name|preValue
argument_list|,
name|shardIndexingBufferSize
argument_list|)
expr_stmt|;
try|try
block|{
name|refresh
argument_list|(
literal|"update index buffer"
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to refresh after setting shard to inactive"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"updating index_buffer_size from [{}] to [{}]"
argument_list|,
name|preValue
argument_list|,
name|shardIndexingBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|!=
literal|null
condition|)
block|{
name|engine
operator|.
name|getTranslog
argument_list|()
operator|.
name|updateBuffer
argument_list|(
name|shardTranslogBufferSize
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|markAsInactive
specifier|public
name|void
name|markAsInactive
parameter_list|()
block|{
name|updateBufferSize
argument_list|(
name|EngineConfig
operator|.
name|INACTIVE_SHARD_INDEXING_BUFFER
argument_list|,
name|TranslogConfig
operator|.
name|INACTIVE_SHARD_TRANSLOG_BUFFER
argument_list|)
expr_stmt|;
name|indicesLifecycle
operator|.
name|onShardInactive
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
DECL|method|isFlushOnClose
specifier|public
specifier|final
name|boolean
name|isFlushOnClose
parameter_list|()
block|{
return|return
name|flushOnClose
return|;
block|}
comment|/**      * Deletes the shards metadata state. This method can only be executed if the shard is not active.      *      * @throws IOException if the delete fails      */
DECL|method|deleteShardState
specifier|public
name|void
name|deleteShardState
parameter_list|()
throws|throws
name|IOException
block|{
if|if
condition|(
name|this
operator|.
name|routingEntry
argument_list|()
operator|!=
literal|null
operator|&&
name|this
operator|.
name|routingEntry
argument_list|()
operator|.
name|active
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Can't delete shard state on an active shard"
argument_list|)
throw|;
block|}
name|MetaDataStateFormat
operator|.
name|deleteMetaState
argument_list|(
name|shardPath
argument_list|()
operator|.
name|getDataPath
argument_list|()
argument_list|)
expr_stmt|;
block|}
DECL|method|shardPath
specifier|public
name|ShardPath
name|shardPath
parameter_list|()
block|{
return|return
name|path
return|;
block|}
DECL|class|ApplyRefreshSettings
specifier|private
class|class
name|ApplyRefreshSettings
implements|implements
name|IndexSettingsService
operator|.
name|Listener
block|{
annotation|@
name|Override
DECL|method|onRefreshSettings
specifier|public
name|void
name|onRefreshSettings
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|boolean
name|change
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
argument_list|()
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// no need to update anything if we are closed
return|return;
block|}
specifier|final
name|EngineConfig
name|config
init|=
name|engineConfig
decl_stmt|;
specifier|final
name|boolean
name|flushOnClose
init|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|INDEX_FLUSH_ON_CLOSE
argument_list|,
name|IndexShard
operator|.
name|this
operator|.
name|flushOnClose
argument_list|)
decl_stmt|;
if|if
condition|(
name|flushOnClose
operator|!=
name|IndexShard
operator|.
name|this
operator|.
name|flushOnClose
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating {} from [{}] to [{}]"
argument_list|,
name|INDEX_FLUSH_ON_CLOSE
argument_list|,
name|IndexShard
operator|.
name|this
operator|.
name|flushOnClose
argument_list|,
name|flushOnClose
argument_list|)
expr_stmt|;
name|IndexShard
operator|.
name|this
operator|.
name|flushOnClose
operator|=
name|flushOnClose
expr_stmt|;
block|}
name|TranslogWriter
operator|.
name|Type
name|type
init|=
name|TranslogWriter
operator|.
name|Type
operator|.
name|fromString
argument_list|(
name|settings
operator|.
name|get
argument_list|(
name|TranslogConfig
operator|.
name|INDEX_TRANSLOG_FS_TYPE
argument_list|,
name|translogConfig
operator|.
name|getType
argument_list|()
operator|.
name|name
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|translogConfig
operator|.
name|getType
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating type from [{}] to [{}]"
argument_list|,
name|translogConfig
operator|.
name|getType
argument_list|()
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|translogConfig
operator|.
name|setType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
specifier|final
name|Translog
operator|.
name|Durabilty
name|durabilty
init|=
name|getFromSettings
argument_list|(
name|logger
argument_list|,
name|settings
argument_list|,
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|durabilty
operator|!=
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating durability from [{}] to [{}]"
argument_list|,
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
argument_list|,
name|durabilty
argument_list|)
expr_stmt|;
name|translogConfig
operator|.
name|setDurabilty
argument_list|(
name|durabilty
argument_list|)
expr_stmt|;
block|}
name|TimeValue
name|refreshInterval
init|=
name|settings
operator|.
name|getAsTime
argument_list|(
name|INDEX_REFRESH_INTERVAL
argument_list|,
name|IndexShard
operator|.
name|this
operator|.
name|refreshInterval
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|refreshInterval
operator|.
name|equals
argument_list|(
name|IndexShard
operator|.
name|this
operator|.
name|refreshInterval
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating refresh_interval from [{}] to [{}]"
argument_list|,
name|IndexShard
operator|.
name|this
operator|.
name|refreshInterval
argument_list|,
name|refreshInterval
argument_list|)
expr_stmt|;
if|if
condition|(
name|refreshScheduledFuture
operator|!=
literal|null
condition|)
block|{
comment|// NOTE: we pass false here so we do NOT attempt Thread.interrupt if EngineRefresher.run is currently running.  This is
comment|// very important, because doing so can cause files to suddenly be closed if they were doing IO when the interrupt
comment|// hit.  See https://issues.apache.org/jira/browse/LUCENE-2239
name|FutureUtils
operator|.
name|cancel
argument_list|(
name|refreshScheduledFuture
argument_list|)
expr_stmt|;
name|refreshScheduledFuture
operator|=
literal|null
expr_stmt|;
block|}
name|IndexShard
operator|.
name|this
operator|.
name|refreshInterval
operator|=
name|refreshInterval
expr_stmt|;
if|if
condition|(
name|refreshInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
operator|new
name|EngineRefresher
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|gcDeletesInMillis
init|=
name|settings
operator|.
name|getAsTime
argument_list|(
name|EngineConfig
operator|.
name|INDEX_GC_DELETES_SETTING
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|config
operator|.
name|getGcDeletesInMillis
argument_list|()
argument_list|)
argument_list|)
operator|.
name|millis
argument_list|()
decl_stmt|;
if|if
condition|(
name|gcDeletesInMillis
operator|!=
name|config
operator|.
name|getGcDeletesInMillis
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating {} from [{}] to [{}]"
argument_list|,
name|EngineConfig
operator|.
name|INDEX_GC_DELETES_SETTING
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|config
operator|.
name|getGcDeletesInMillis
argument_list|()
argument_list|)
argument_list|,
name|TimeValue
operator|.
name|timeValueMillis
argument_list|(
name|gcDeletesInMillis
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|setGcDeletesInMillis
argument_list|(
name|gcDeletesInMillis
argument_list|)
expr_stmt|;
name|change
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|boolean
name|compoundOnFlush
init|=
name|settings
operator|.
name|getAsBoolean
argument_list|(
name|EngineConfig
operator|.
name|INDEX_COMPOUND_ON_FLUSH
argument_list|,
name|config
operator|.
name|isCompoundOnFlush
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|compoundOnFlush
operator|!=
name|config
operator|.
name|isCompoundOnFlush
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"updating {} from [{}] to [{}]"
argument_list|,
name|EngineConfig
operator|.
name|INDEX_COMPOUND_ON_FLUSH
argument_list|,
name|config
operator|.
name|isCompoundOnFlush
argument_list|()
argument_list|,
name|compoundOnFlush
argument_list|)
expr_stmt|;
name|config
operator|.
name|setCompoundOnFlush
argument_list|(
name|compoundOnFlush
argument_list|)
expr_stmt|;
name|change
operator|=
literal|true
expr_stmt|;
block|}
specifier|final
name|String
name|versionMapSize
init|=
name|settings
operator|.
name|get
argument_list|(
name|EngineConfig
operator|.
name|INDEX_VERSION_MAP_SIZE
argument_list|,
name|config
operator|.
name|getVersionMapSizeSetting
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|getVersionMapSizeSetting
argument_list|()
operator|.
name|equals
argument_list|(
name|versionMapSize
argument_list|)
operator|==
literal|false
condition|)
block|{
name|config
operator|.
name|setVersionMapSizeSetting
argument_list|(
name|versionMapSize
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|change
condition|)
block|{
name|refresh
argument_list|(
literal|"apply settings"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|EngineRefresher
class|class
name|EngineRefresher
implements|implements
name|Runnable
block|{
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|()
block|{
comment|// we check before if a refresh is needed, if not, we reschedule, otherwise, we fork, refresh, and then reschedule
if|if
condition|(
operator|!
name|engine
argument_list|()
operator|.
name|refreshNeeded
argument_list|()
condition|)
block|{
name|reschedule
argument_list|()
expr_stmt|;
return|return;
block|}
name|threadPool
operator|.
name|executor
argument_list|(
name|ThreadPool
operator|.
name|Names
operator|.
name|REFRESH
argument_list|)
operator|.
name|execute
argument_list|(
operator|new
name|Runnable
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
if|if
condition|(
name|engine
argument_list|()
operator|.
name|refreshNeeded
argument_list|()
condition|)
block|{
name|refresh
argument_list|(
literal|"schedule"
argument_list|)
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|EngineClosedException
name|e
parameter_list|)
block|{
comment|// we are being closed, ignore
block|}
catch|catch
parameter_list|(
name|RefreshFailedEngineException
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|InterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ClosedByInterruptException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|getCause
argument_list|()
operator|instanceof
name|ThreadInterruptedException
condition|)
block|{
comment|// ignore, we are being shutdown
block|}
else|else
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Failed to perform scheduled engine refresh"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|reschedule
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
comment|/**          * Schedules another (future) refresh, if refresh_interval is still enabled.          */
DECL|method|reschedule
specifier|private
name|void
name|reschedule
parameter_list|()
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|!=
name|IndexShardState
operator|.
name|CLOSED
operator|&&
name|refreshInterval
operator|.
name|millis
argument_list|()
operator|>
literal|0
condition|)
block|{
name|refreshScheduledFuture
operator|=
name|threadPool
operator|.
name|schedule
argument_list|(
name|refreshInterval
argument_list|,
name|ThreadPool
operator|.
name|Names
operator|.
name|SAME
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
DECL|method|checkIndex
specifier|private
name|void
name|checkIndex
parameter_list|()
throws|throws
name|IndexShardException
block|{
if|if
condition|(
name|store
operator|.
name|tryIncRef
argument_list|()
condition|)
block|{
try|try
block|{
name|doCheckIndex
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardException
argument_list|(
name|shardId
argument_list|,
literal|"exception during checkindex"
argument_list|,
name|e
argument_list|)
throw|;
block|}
finally|finally
block|{
name|store
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|method|doCheckIndex
specifier|private
name|void
name|doCheckIndex
parameter_list|()
throws|throws
name|IndexShardException
throws|,
name|IOException
block|{
name|long
name|timeNS
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|Lucene
operator|.
name|indexExists
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
condition|)
block|{
return|return;
block|}
name|BytesStreamOutput
name|os
init|=
operator|new
name|BytesStreamOutput
argument_list|()
decl_stmt|;
name|PrintStream
name|out
init|=
operator|new
name|PrintStream
argument_list|(
name|os
argument_list|,
literal|false
argument_list|,
name|Charsets
operator|.
name|UTF_8
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
literal|"checksum"
operator|.
name|equalsIgnoreCase
argument_list|(
name|checkIndexOnStartup
argument_list|)
condition|)
block|{
comment|// physical verification only: verify all checksums for the latest commit
name|boolean
name|corrupt
init|=
literal|false
decl_stmt|;
name|MetadataSnapshot
name|metadata
init|=
name|store
operator|.
name|getMetadata
argument_list|()
decl_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|String
argument_list|,
name|StoreFileMetaData
argument_list|>
name|entry
range|:
name|metadata
operator|.
name|asMap
argument_list|()
operator|.
name|entrySet
argument_list|()
control|)
block|{
try|try
block|{
name|Store
operator|.
name|checkIntegrity
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|,
name|store
operator|.
name|directory
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|.
name|println
argument_list|(
literal|"checksum passed: "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|exc
parameter_list|)
block|{
name|out
operator|.
name|println
argument_list|(
literal|"checksum failed: "
operator|+
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|exc
operator|.
name|printStackTrace
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|corrupt
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|corrupt
condition|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardException
argument_list|(
name|shardId
argument_list|,
literal|"index check failure"
argument_list|)
throw|;
block|}
block|}
else|else
block|{
comment|// full checkindex
try|try
init|(
name|CheckIndex
name|checkIndex
init|=
operator|new
name|CheckIndex
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
init|)
block|{
name|checkIndex
operator|.
name|setInfoStream
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|CheckIndex
operator|.
name|Status
name|status
init|=
name|checkIndex
operator|.
name|checkIndex
argument_list|()
decl_stmt|;
name|out
operator|.
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|status
operator|.
name|clean
condition|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
comment|// ignore if closed....
return|return;
block|}
name|logger
operator|.
name|warn
argument_list|(
literal|"check index [failure]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
literal|"fix"
operator|.
name|equalsIgnoreCase
argument_list|(
name|checkIndexOnStartup
argument_list|)
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"fixing index, writing new segments file ..."
argument_list|)
expr_stmt|;
block|}
name|checkIndex
operator|.
name|exorciseIndex
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"index fixed, wrote new segments file \"{}\""
argument_list|,
name|status
operator|.
name|segmentsFileName
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// only throw a failure if we are not going to fix the index
throw|throw
operator|new
name|IndexShardException
argument_list|(
name|shardId
argument_list|,
literal|"index check failure"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isDebugEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"check index [success]\n{}"
argument_list|,
operator|new
name|String
argument_list|(
name|os
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
argument_list|,
name|Charsets
operator|.
name|UTF_8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|recoveryState
operator|.
name|getVerifyIndex
argument_list|()
operator|.
name|checkIndexTime
argument_list|(
name|Math
operator|.
name|max
argument_list|(
literal|0
argument_list|,
name|TimeValue
operator|.
name|nsecToMSec
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|timeNS
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|engine
specifier|public
name|Engine
name|engine
parameter_list|()
block|{
name|Engine
name|engine
init|=
name|engineUnsafe
argument_list|()
decl_stmt|;
if|if
condition|(
name|engine
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|EngineClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
return|return
name|engine
return|;
block|}
DECL|method|engineUnsafe
specifier|protected
name|Engine
name|engineUnsafe
parameter_list|()
block|{
return|return
name|this
operator|.
name|currentEngineReference
operator|.
name|get
argument_list|()
return|;
block|}
DECL|class|ShardEngineFailListener
class|class
name|ShardEngineFailListener
implements|implements
name|Engine
operator|.
name|FailedEngineListener
block|{
DECL|field|delegates
specifier|private
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|Engine
operator|.
name|FailedEngineListener
argument_list|>
name|delegates
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<>
argument_list|()
decl_stmt|;
comment|// called by the current engine
annotation|@
name|Override
DECL|method|onFailedEngine
specifier|public
name|void
name|onFailedEngine
parameter_list|(
name|ShardId
name|shardId
parameter_list|,
name|String
name|reason
parameter_list|,
annotation|@
name|Nullable
name|Throwable
name|failure
parameter_list|)
block|{
try|try
block|{
comment|// delete the shard state so this folder will not be reused
name|MetaDataStateFormat
operator|.
name|deleteMetaState
argument_list|(
name|nodeEnv
operator|.
name|availableShardPaths
argument_list|(
name|shardId
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to delete shard state"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
for|for
control|(
name|Engine
operator|.
name|FailedEngineListener
name|listener
range|:
name|delegates
control|)
block|{
try|try
block|{
name|listener
operator|.
name|onFailedEngine
argument_list|(
name|shardId
argument_list|,
name|reason
argument_list|,
name|failure
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"exception while notifying engine failure"
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|method|createNewEngine
specifier|private
name|void
name|createNewEngine
parameter_list|(
name|boolean
name|skipTranslogRecovery
parameter_list|,
name|EngineConfig
name|config
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|state
operator|==
name|IndexShardState
operator|.
name|CLOSED
condition|)
block|{
throw|throw
operator|new
name|EngineClosedException
argument_list|(
name|shardId
argument_list|)
throw|;
block|}
assert|assert
name|this
operator|.
name|currentEngineReference
operator|.
name|get
argument_list|()
operator|==
literal|null
assert|;
name|this
operator|.
name|currentEngineReference
operator|.
name|set
argument_list|(
name|newEngine
argument_list|(
name|skipTranslogRecovery
argument_list|,
name|config
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|newEngine
specifier|protected
name|Engine
name|newEngine
parameter_list|(
name|boolean
name|skipTranslogRecovery
parameter_list|,
name|EngineConfig
name|config
parameter_list|)
block|{
return|return
name|engineFactory
operator|.
name|newReadWriteEngine
argument_list|(
name|config
argument_list|,
name|skipTranslogRecovery
argument_list|)
return|;
block|}
comment|/**      * Returns<code>true</code> iff this shard allows primary promotion, otherwise<code>false</code>      */
DECL|method|allowsPrimaryPromotion
specifier|public
name|boolean
name|allowsPrimaryPromotion
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
comment|// pkg private for testing
DECL|method|persistMetadata
name|void
name|persistMetadata
parameter_list|(
name|ShardRouting
name|newRouting
parameter_list|,
name|ShardRouting
name|currentRouting
parameter_list|)
block|{
assert|assert
name|newRouting
operator|!=
literal|null
operator|:
literal|"newRouting must not be null"
assert|;
if|if
condition|(
name|newRouting
operator|.
name|active
argument_list|()
condition|)
block|{
try|try
block|{
specifier|final
name|String
name|writeReason
decl_stmt|;
if|if
condition|(
name|currentRouting
operator|==
literal|null
condition|)
block|{
name|writeReason
operator|=
literal|"freshly started, version ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentRouting
operator|.
name|version
argument_list|()
operator|<
name|newRouting
operator|.
name|version
argument_list|()
condition|)
block|{
name|writeReason
operator|=
literal|"version changed from ["
operator|+
name|currentRouting
operator|.
name|version
argument_list|()
operator|+
literal|"] to ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentRouting
operator|.
name|equals
argument_list|(
name|newRouting
argument_list|)
operator|==
literal|false
condition|)
block|{
name|writeReason
operator|=
literal|"routing changed from "
operator|+
name|currentRouting
operator|+
literal|" to "
operator|+
name|newRouting
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"skip writing shard state, has been written before; previous version:  ["
operator|+
name|currentRouting
operator|.
name|version
argument_list|()
operator|+
literal|"] current version ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
argument_list|)
expr_stmt|;
assert|assert
name|currentRouting
operator|.
name|version
argument_list|()
operator|<=
name|newRouting
operator|.
name|version
argument_list|()
operator|:
literal|"version should not go backwards for shardID: "
operator|+
name|shardId
operator|+
literal|" previous version:  ["
operator|+
name|currentRouting
operator|.
name|version
argument_list|()
operator|+
literal|"] current version ["
operator|+
name|newRouting
operator|.
name|version
argument_list|()
operator|+
literal|"]"
assert|;
return|return;
block|}
specifier|final
name|ShardStateMetaData
name|newShardStateMetadata
init|=
operator|new
name|ShardStateMetaData
argument_list|(
name|newRouting
operator|.
name|version
argument_list|()
argument_list|,
name|newRouting
operator|.
name|primary
argument_list|()
argument_list|,
name|getIndexUUID
argument_list|()
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"{} writing shard state, reason [{}]"
argument_list|,
name|shardId
argument_list|,
name|writeReason
argument_list|)
expr_stmt|;
name|ShardStateMetaData
operator|.
name|FORMAT
operator|.
name|write
argument_list|(
name|newShardStateMetadata
argument_list|,
name|newShardStateMetadata
operator|.
name|version
argument_list|,
name|shardPath
argument_list|()
operator|.
name|getShardStatePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// this is how we used to handle it.... :(
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to write shard state"
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|// we failed to write the shard state, we will try and write
comment|// it next time...
block|}
block|}
block|}
DECL|method|getIndexUUID
specifier|private
name|String
name|getIndexUUID
parameter_list|()
block|{
assert|assert
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_UUID
argument_list|)
operator|!=
literal|null
operator|||
name|indexSettings
operator|.
name|getAsVersion
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_VERSION_CREATED
argument_list|,
name|Version
operator|.
name|CURRENT
argument_list|)
operator|.
name|before
argument_list|(
name|Version
operator|.
name|V_0_90_6
argument_list|)
operator|:
literal|"version: "
operator|+
name|indexSettings
operator|.
name|getAsVersion
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_VERSION_CREATED
argument_list|,
literal|null
argument_list|)
operator|+
literal|" uuid: "
operator|+
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_UUID
argument_list|)
assert|;
return|return
name|indexSettings
operator|.
name|get
argument_list|(
name|IndexMetaData
operator|.
name|SETTING_UUID
argument_list|,
name|IndexMetaData
operator|.
name|INDEX_UUID_NA_VALUE
argument_list|)
return|;
block|}
DECL|method|docMapper
specifier|private
name|Tuple
argument_list|<
name|DocumentMapper
argument_list|,
name|Mapping
argument_list|>
name|docMapper
parameter_list|(
name|String
name|type
parameter_list|)
block|{
return|return
name|mapperService
operator|.
name|documentMapperWithAutoCreate
argument_list|(
name|type
argument_list|)
return|;
block|}
DECL|method|newEngineConfig
specifier|private
specifier|final
name|EngineConfig
name|newEngineConfig
parameter_list|(
name|TranslogConfig
name|translogConfig
parameter_list|)
block|{
specifier|final
name|TranslogRecoveryPerformer
name|translogRecoveryPerformer
init|=
operator|new
name|TranslogRecoveryPerformer
argument_list|(
name|mapperService
argument_list|,
name|mapperAnalyzer
argument_list|,
name|queryParserService
argument_list|,
name|indexAliasesService
argument_list|,
name|indexCache
argument_list|)
block|{
annotation|@
name|Override
specifier|protected
name|void
name|operationProcessed
parameter_list|()
block|{
assert|assert
name|recoveryState
operator|!=
literal|null
assert|;
name|recoveryState
operator|.
name|getTranslog
argument_list|()
operator|.
name|incrementRecoveredOperations
argument_list|()
expr_stmt|;
block|}
block|}
decl_stmt|;
return|return
operator|new
name|EngineConfig
argument_list|(
name|shardId
argument_list|,
name|threadPool
argument_list|,
name|indexingService
argument_list|,
name|indexSettingsService
argument_list|,
name|warmer
argument_list|,
name|store
argument_list|,
name|deletionPolicy
argument_list|,
name|mergePolicyProvider
argument_list|,
name|mergeScheduler
argument_list|,
name|mapperAnalyzer
argument_list|,
name|similarityService
operator|.
name|similarity
argument_list|()
argument_list|,
name|codecService
argument_list|,
name|failedEngineListener
argument_list|,
name|translogRecoveryPerformer
argument_list|,
name|indexCache
operator|.
name|filter
argument_list|()
argument_list|,
name|indexCache
operator|.
name|filterPolicy
argument_list|()
argument_list|,
name|translogConfig
argument_list|)
return|;
block|}
DECL|class|IndexShardOperationCounter
specifier|private
specifier|static
class|class
name|IndexShardOperationCounter
extends|extends
name|AbstractRefCounted
block|{
DECL|field|logger
specifier|final
specifier|private
name|ESLogger
name|logger
decl_stmt|;
DECL|field|shardId
specifier|private
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|method|IndexShardOperationCounter
specifier|public
name|IndexShardOperationCounter
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|super
argument_list|(
literal|"index-shard-operations-counter"
argument_list|)
expr_stmt|;
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|closeInternal
specifier|protected
name|void
name|closeInternal
parameter_list|()
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"operations counter reached 0, will not accept any further writes"
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|alreadyClosed
specifier|protected
name|void
name|alreadyClosed
parameter_list|()
block|{
throw|throw
operator|new
name|IndexShardClosedException
argument_list|(
name|shardId
argument_list|,
literal|"could not increment operation counter. shard is closed."
argument_list|)
throw|;
block|}
block|}
DECL|method|incrementOperationCounter
specifier|public
name|void
name|incrementOperationCounter
parameter_list|()
block|{
name|indexShardOperationCounter
operator|.
name|incRef
argument_list|()
expr_stmt|;
block|}
DECL|method|decrementOperationCounter
specifier|public
name|void
name|decrementOperationCounter
parameter_list|()
block|{
name|indexShardOperationCounter
operator|.
name|decRef
argument_list|()
expr_stmt|;
block|}
DECL|method|getOperationsCount
specifier|public
name|int
name|getOperationsCount
parameter_list|()
block|{
return|return
name|indexShardOperationCounter
operator|.
name|refCount
argument_list|()
return|;
block|}
comment|/**      * Syncs the given location with the underlying storage unless already synced.      */
DECL|method|sync
specifier|public
name|void
name|sync
parameter_list|(
name|Translog
operator|.
name|Location
name|location
parameter_list|)
block|{
specifier|final
name|Engine
name|engine
init|=
name|engine
argument_list|()
decl_stmt|;
try|try
block|{
name|engine
operator|.
name|getTranslog
argument_list|()
operator|.
name|ensureSynced
argument_list|(
name|location
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
comment|// if this fails we are in deep shit - fail the request
name|logger
operator|.
name|debug
argument_list|(
literal|"failed to sync translog"
argument_list|,
name|ex
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|ElasticsearchException
argument_list|(
literal|"failed to sync translog"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns the current translog durability mode      */
DECL|method|getTranslogDurability
specifier|public
name|Translog
operator|.
name|Durabilty
name|getTranslogDurability
parameter_list|()
block|{
return|return
name|translogConfig
operator|.
name|getDurabilty
argument_list|()
return|;
block|}
DECL|method|getFromSettings
specifier|private
specifier|static
name|Translog
operator|.
name|Durabilty
name|getFromSettings
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|Settings
name|settings
parameter_list|,
name|Translog
operator|.
name|Durabilty
name|defaultValue
parameter_list|)
block|{
specifier|final
name|String
name|value
init|=
name|settings
operator|.
name|get
argument_list|(
name|TranslogConfig
operator|.
name|INDEX_TRANSLOG_DURABILITY
argument_list|,
name|defaultValue
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
try|try
block|{
return|return
name|Translog
operator|.
name|Durabilty
operator|.
name|valueOf
argument_list|(
name|value
operator|.
name|toUpperCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|IllegalArgumentException
name|ex
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"Can't apply {} illegal value: {} using {} instead, use one of: {}"
argument_list|,
name|TranslogConfig
operator|.
name|INDEX_TRANSLOG_DURABILITY
argument_list|,
name|value
argument_list|,
name|defaultValue
argument_list|,
name|Arrays
operator|.
name|toString
argument_list|(
name|Translog
operator|.
name|Durabilty
operator|.
name|values
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|defaultValue
return|;
block|}
block|}
block|}
end_class

end_unit

