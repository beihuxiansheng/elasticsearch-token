begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.deletionpolicy
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|deletionpolicy
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexDeletionPolicy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|name
operator|.
name|Named
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentCollections
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|AbstractIndexShardComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|IndexShardComponent
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_comment
comment|/**  * Snapshot deletion policy allows to get snapshots of an index state (last commit or all commits)  * and if the deletion policy is used with all open index writers (JVM level) then the snapshot  * state will not be deleted until it will be released.  *  *  */
end_comment

begin_class
DECL|class|SnapshotDeletionPolicy
specifier|public
class|class
name|SnapshotDeletionPolicy
extends|extends
name|AbstractESDeletionPolicy
block|{
DECL|field|primary
specifier|private
specifier|final
name|IndexDeletionPolicy
name|primary
decl_stmt|;
DECL|field|snapshots
specifier|private
specifier|final
name|ConcurrentMap
argument_list|<
name|Long
argument_list|,
name|SnapshotHolder
argument_list|>
name|snapshots
init|=
name|ConcurrentCollections
operator|.
name|newConcurrentMap
argument_list|()
decl_stmt|;
DECL|field|commits
specifier|private
specifier|volatile
name|List
argument_list|<
name|SnapshotIndexCommit
argument_list|>
name|commits
decl_stmt|;
DECL|field|mutex
specifier|private
specifier|final
name|Object
name|mutex
init|=
operator|new
name|Object
argument_list|()
decl_stmt|;
DECL|field|lastCommit
specifier|private
name|SnapshotIndexCommit
name|lastCommit
decl_stmt|;
comment|/**      * Constructs a new snapshot deletion policy that wraps the provided deletion policy.      */
annotation|@
name|Inject
DECL|method|SnapshotDeletionPolicy
specifier|public
name|SnapshotDeletionPolicy
parameter_list|(
annotation|@
name|Named
argument_list|(
literal|"actual"
argument_list|)
name|IndexDeletionPolicy
name|primary
parameter_list|)
block|{
name|super
argument_list|(
operator|(
operator|(
name|IndexShardComponent
operator|)
name|primary
operator|)
operator|.
name|shardId
argument_list|()
argument_list|,
operator|(
operator|(
name|IndexShardComponent
operator|)
name|primary
operator|)
operator|.
name|indexSettings
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|primary
operator|=
name|primary
expr_stmt|;
block|}
comment|/**      * Called by Lucene. Same as {@link #onCommit(java.util.List)}.      */
DECL|method|onInit
specifier|public
name|void
name|onInit
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|IndexCommit
argument_list|>
name|commits
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|commits
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// this might be empty if we create a new index.
comment|// the behavior has changed in Lucene 4.4 that calls onInit even with an empty commits list.
name|onCommit
argument_list|(
name|commits
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Called by Lucene.. Wraps the provided commits with {@link SnapshotIndexCommit}      * and delegates to the wrapped deletion policy.      */
DECL|method|onCommit
specifier|public
name|void
name|onCommit
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|IndexCommit
argument_list|>
name|commits
parameter_list|)
throws|throws
name|IOException
block|{
assert|assert
operator|!
name|commits
operator|.
name|isEmpty
argument_list|()
operator|:
literal|"Commits must not be empty"
assert|;
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|List
argument_list|<
name|SnapshotIndexCommit
argument_list|>
name|snapshotCommits
init|=
name|wrapCommits
argument_list|(
name|commits
argument_list|)
decl_stmt|;
name|primary
operator|.
name|onCommit
argument_list|(
name|snapshotCommits
argument_list|)
expr_stmt|;
comment|// clean snapshots that their respective counts are 0 (should not really happen)
for|for
control|(
name|Iterator
argument_list|<
name|SnapshotHolder
argument_list|>
name|it
init|=
name|snapshots
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|SnapshotHolder
name|holder
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|holder
operator|.
name|counter
operator|<=
literal|0
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
comment|// build the current commits list (all the ones that are not deleted by the primary)
name|List
argument_list|<
name|SnapshotIndexCommit
argument_list|>
name|newCommits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
for|for
control|(
name|SnapshotIndexCommit
name|commit
range|:
name|snapshotCommits
control|)
block|{
if|if
condition|(
operator|!
name|commit
operator|.
name|isDeleted
argument_list|()
condition|)
block|{
name|newCommits
operator|.
name|add
argument_list|(
name|commit
argument_list|)
expr_stmt|;
block|}
block|}
name|this
operator|.
name|commits
operator|=
name|newCommits
expr_stmt|;
comment|// the last commit that is not deleted
name|this
operator|.
name|lastCommit
operator|=
name|newCommits
operator|.
name|get
argument_list|(
name|newCommits
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Snapshots all the current commits in the index. Make sure to call      * {@link SnapshotIndexCommits#release()} to release it.      */
DECL|method|snapshots
specifier|public
name|SnapshotIndexCommits
name|snapshots
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|snapshots
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Snapshot deletion policy has not been init yet..."
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|SnapshotIndexCommit
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|commits
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|SnapshotIndexCommit
name|commit
range|:
name|commits
control|)
block|{
name|result
operator|.
name|add
argument_list|(
name|snapshot
argument_list|(
name|commit
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|SnapshotIndexCommits
argument_list|(
name|result
argument_list|)
return|;
block|}
block|}
comment|/**      * Returns a snapshot of the index (for the last commit point). Make      * sure to call {@link SnapshotIndexCommit#release()} in order to release it.      */
DECL|method|snapshot
specifier|public
name|SnapshotIndexCommit
name|snapshot
parameter_list|()
throws|throws
name|IOException
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
if|if
condition|(
name|lastCommit
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"Snapshot deletion policy has not been init yet..."
argument_list|)
throw|;
block|}
return|return
name|snapshot
argument_list|(
name|lastCommit
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|clone
specifier|public
name|IndexDeletionPolicy
name|clone
parameter_list|()
block|{
comment|// Lucene IW makes a clone internally but since we hold on to this instance
comment|// the clone will just be the identity. See InternalEngine recovery why we need this.
return|return
name|this
return|;
block|}
comment|/**      * Helper method to snapshot a give commit.      */
DECL|method|snapshot
specifier|private
name|SnapshotIndexCommit
name|snapshot
parameter_list|(
name|SnapshotIndexCommit
name|commit
parameter_list|)
throws|throws
name|IOException
block|{
name|SnapshotHolder
name|snapshotHolder
init|=
name|snapshots
operator|.
name|get
argument_list|(
name|commit
operator|.
name|getGeneration
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|snapshotHolder
operator|==
literal|null
condition|)
block|{
name|snapshotHolder
operator|=
operator|new
name|SnapshotHolder
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|snapshots
operator|.
name|put
argument_list|(
name|commit
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|snapshotHolder
argument_list|)
expr_stmt|;
block|}
name|snapshotHolder
operator|.
name|counter
operator|++
expr_stmt|;
return|return
operator|new
name|OneTimeReleaseSnapshotIndexCommit
argument_list|(
name|this
argument_list|,
name|commit
argument_list|)
return|;
block|}
comment|/**      * Returns<tt>true</tt> if the version has been snapshotted.      */
DECL|method|isHeld
name|boolean
name|isHeld
parameter_list|(
name|long
name|version
parameter_list|)
block|{
name|SnapshotDeletionPolicy
operator|.
name|SnapshotHolder
name|holder
init|=
name|snapshots
operator|.
name|get
argument_list|(
name|version
argument_list|)
decl_stmt|;
return|return
name|holder
operator|!=
literal|null
operator|&&
name|holder
operator|.
name|counter
operator|>
literal|0
return|;
block|}
comment|/**      * Releases the version provided. Returns<tt>true</tt> if the release was successful.      */
DECL|method|release
name|boolean
name|release
parameter_list|(
name|long
name|version
parameter_list|)
block|{
synchronized|synchronized
init|(
name|mutex
init|)
block|{
name|SnapshotDeletionPolicy
operator|.
name|SnapshotHolder
name|holder
init|=
name|snapshots
operator|.
name|get
argument_list|(
name|version
argument_list|)
decl_stmt|;
if|if
condition|(
name|holder
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|holder
operator|.
name|counter
operator|<=
literal|0
condition|)
block|{
name|snapshots
operator|.
name|remove
argument_list|(
name|version
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|--
name|holder
operator|.
name|counter
operator|==
literal|0
condition|)
block|{
name|snapshots
operator|.
name|remove
argument_list|(
name|version
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
comment|/**      * A class that wraps an {@link SnapshotIndexCommit} and makes sure that release will only      * be called once on it.      */
DECL|class|OneTimeReleaseSnapshotIndexCommit
specifier|private
specifier|static
class|class
name|OneTimeReleaseSnapshotIndexCommit
extends|extends
name|SnapshotIndexCommit
block|{
DECL|field|released
specifier|private
specifier|volatile
name|boolean
name|released
init|=
literal|false
decl_stmt|;
DECL|method|OneTimeReleaseSnapshotIndexCommit
name|OneTimeReleaseSnapshotIndexCommit
parameter_list|(
name|SnapshotDeletionPolicy
name|deletionPolicy
parameter_list|,
name|IndexCommit
name|cp
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|deletionPolicy
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|release
specifier|public
name|boolean
name|release
parameter_list|()
block|{
if|if
condition|(
name|released
condition|)
block|{
return|return
literal|false
return|;
block|}
name|released
operator|=
literal|true
expr_stmt|;
return|return
operator|(
operator|(
name|SnapshotIndexCommit
operator|)
name|delegate
operator|)
operator|.
name|release
argument_list|()
return|;
block|}
block|}
DECL|class|SnapshotHolder
specifier|private
specifier|static
class|class
name|SnapshotHolder
block|{
DECL|field|counter
name|int
name|counter
decl_stmt|;
DECL|method|SnapshotHolder
specifier|private
name|SnapshotHolder
parameter_list|(
name|int
name|counter
parameter_list|)
block|{
name|this
operator|.
name|counter
operator|=
name|counter
expr_stmt|;
block|}
block|}
DECL|method|wrapCommits
specifier|private
name|List
argument_list|<
name|SnapshotIndexCommit
argument_list|>
name|wrapCommits
parameter_list|(
name|List
argument_list|<
name|?
extends|extends
name|IndexCommit
argument_list|>
name|commits
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|int
name|count
init|=
name|commits
operator|.
name|size
argument_list|()
decl_stmt|;
name|List
argument_list|<
name|SnapshotIndexCommit
argument_list|>
name|snapshotCommits
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|count
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|snapshotCommits
operator|.
name|add
argument_list|(
operator|new
name|SnapshotIndexCommit
argument_list|(
name|this
argument_list|,
name|commits
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|snapshotCommits
return|;
block|}
block|}
end_class

end_unit

