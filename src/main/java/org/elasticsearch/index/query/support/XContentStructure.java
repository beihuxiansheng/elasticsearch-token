begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.query.support
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|support
package|;
end_package

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Nullable
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|bytes
operator|.
name|BytesReference
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|query
operator|.
name|QueryParseContext
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_comment
comment|/**  * XContentStructure is a class used to capture a subset of query, to be parsed  * at a later time when more information (in this case, types) is available.  * Note that using this class requires copying the parser's data, which will  * result in additional overhead versus parsing the inner query/filter  * immediately, however, the extra overhead means that the type not be  * extracted prior to query parsing (in the case of unordered JSON).  */
end_comment

begin_class
DECL|class|XContentStructure
specifier|public
specifier|abstract
class|class
name|XContentStructure
block|{
DECL|field|parseContext
specifier|private
specifier|final
name|QueryParseContext
name|parseContext
decl_stmt|;
DECL|field|innerBytes
specifier|private
name|BytesReference
name|innerBytes
decl_stmt|;
comment|/**      * Create a new XContentStructure for the current parsing context.      */
DECL|method|XContentStructure
specifier|public
name|XContentStructure
parameter_list|(
name|QueryParseContext
name|queryParseContext
parameter_list|)
block|{
name|this
operator|.
name|parseContext
operator|=
name|queryParseContext
expr_stmt|;
block|}
comment|/**      * "Freeze" the parsing content, which means copying the current parser's      * structure into an internal {@link BytesReference} to be parsed later.      * @return the original XContentStructure object      */
DECL|method|freeze
specifier|public
name|XContentStructure
name|freeze
parameter_list|()
throws|throws
name|IOException
block|{
name|this
operator|.
name|bytes
argument_list|(
name|XContentFactory
operator|.
name|smileBuilder
argument_list|()
operator|.
name|copyCurrentStructure
argument_list|(
name|parseContext
operator|.
name|parser
argument_list|()
argument_list|)
operator|.
name|bytes
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Set the bytes to be used for parsing      */
DECL|method|bytes
specifier|public
name|void
name|bytes
parameter_list|(
name|BytesReference
name|innerBytes
parameter_list|)
block|{
name|this
operator|.
name|innerBytes
operator|=
name|innerBytes
expr_stmt|;
block|}
comment|/**      * Return the bytes that are going to be used for parsing      */
DECL|method|bytes
specifier|public
name|BytesReference
name|bytes
parameter_list|()
block|{
return|return
name|this
operator|.
name|innerBytes
return|;
block|}
comment|/**      * Use the captured bytes to parse the inner query using the specified      * types. The original QueryParseContext's parser is switched during this      * parsing, so this method is NOT thread-safe.      * @param types types to be used during the inner query parsing      * @return {@link Query} parsed from the bytes captured in {@code freeze()}      */
DECL|method|asQuery
specifier|public
name|Query
name|asQuery
parameter_list|(
name|String
modifier|...
name|types
parameter_list|)
throws|throws
name|IOException
block|{
name|BytesReference
name|br
init|=
name|this
operator|.
name|bytes
argument_list|()
decl_stmt|;
assert|assert
name|br
operator|!=
literal|null
operator|:
literal|"innerBytes must be set with .bytes(bytes) or .freeze() before parsing"
assert|;
name|XContentParser
name|innerParser
init|=
name|XContentHelper
operator|.
name|createParser
argument_list|(
name|br
argument_list|)
decl_stmt|;
name|String
index|[]
name|origTypes
init|=
name|QueryParseContext
operator|.
name|setTypesWithPrevious
argument_list|(
name|types
argument_list|)
decl_stmt|;
name|XContentParser
name|old
init|=
name|parseContext
operator|.
name|parser
argument_list|()
decl_stmt|;
name|parseContext
operator|.
name|parser
argument_list|(
name|innerParser
argument_list|)
expr_stmt|;
try|try
block|{
return|return
name|parseContext
operator|.
name|parseInnerQuery
argument_list|()
return|;
block|}
finally|finally
block|{
name|parseContext
operator|.
name|parser
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|QueryParseContext
operator|.
name|setTypes
argument_list|(
name|origTypes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * InnerQuery is an extension of {@code XContentStructure} that eagerly      * parses the query in a streaming manner if the types are available at      * construction time.      */
DECL|class|InnerQuery
specifier|public
specifier|static
class|class
name|InnerQuery
extends|extends
name|XContentStructure
block|{
DECL|field|query
specifier|private
name|Query
name|query
init|=
literal|null
decl_stmt|;
DECL|field|queryParsed
specifier|private
name|boolean
name|queryParsed
init|=
literal|false
decl_stmt|;
DECL|method|InnerQuery
specifier|public
name|InnerQuery
parameter_list|(
name|QueryParseContext
name|parseContext1
parameter_list|,
annotation|@
name|Nullable
name|String
modifier|...
name|types
parameter_list|)
throws|throws
name|IOException
block|{
name|super
argument_list|(
name|parseContext1
argument_list|)
expr_stmt|;
if|if
condition|(
name|types
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|origTypes
init|=
name|QueryParseContext
operator|.
name|setTypesWithPrevious
argument_list|(
name|types
argument_list|)
decl_stmt|;
try|try
block|{
name|query
operator|=
name|parseContext1
operator|.
name|parseInnerQuery
argument_list|()
expr_stmt|;
name|queryParsed
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|QueryParseContext
operator|.
name|setTypes
argument_list|(
name|origTypes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|BytesReference
name|innerBytes
init|=
name|XContentFactory
operator|.
name|smileBuilder
argument_list|()
operator|.
name|copyCurrentStructure
argument_list|(
name|parseContext1
operator|.
name|parser
argument_list|()
argument_list|)
operator|.
name|bytes
argument_list|()
decl_stmt|;
name|super
operator|.
name|bytes
argument_list|(
name|innerBytes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Return the query represented by the XContentStructure object,          * returning the cached Query if it has already been parsed.          * @param types types to be used during the inner query parsing          */
annotation|@
name|Override
DECL|method|asQuery
specifier|public
name|Query
name|asQuery
parameter_list|(
name|String
modifier|...
name|types
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
operator|!
name|queryParsed
condition|)
block|{
comment|// query can be null
name|this
operator|.
name|query
operator|=
name|super
operator|.
name|asQuery
argument_list|(
name|types
argument_list|)
expr_stmt|;
block|}
return|return
name|this
operator|.
name|query
return|;
block|}
block|}
block|}
end_class

end_unit

