begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.index.snapshots.blobstore
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|ImmutableMap
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IOContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|IndexOutput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|store
operator|.
name|RateLimiter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|IOUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ExceptionsHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|SnapshotId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|blobstore
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|io
operator|.
name|stream
operator|.
name|BytesStreamInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|Lucene
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|InputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|store
operator|.
name|ThreadSafeInputStreamIndexInput
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|ByteSizeValue
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|deletionpolicy
operator|.
name|SnapshotIndexCommit
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|gateway
operator|.
name|RecoveryStatus
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|shard
operator|.
name|ShardId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|snapshots
operator|.
name|blobstore
operator|.
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|Store
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|store
operator|.
name|StoreFileMetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|indices
operator|.
name|IndicesService
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|repositories
operator|.
name|RepositoryName
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|FilterInputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CopyOnWriteArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CountDownLatch
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
operator|.
name|newArrayList
import|;
end_import

begin_comment
comment|/**  * Blob store based implementation of IndexShardRepository  */
end_comment

begin_class
DECL|class|BlobStoreIndexShardRepository
specifier|public
class|class
name|BlobStoreIndexShardRepository
extends|extends
name|AbstractComponent
implements|implements
name|IndexShardRepository
block|{
DECL|field|blobStore
specifier|private
name|BlobStore
name|blobStore
decl_stmt|;
DECL|field|basePath
specifier|private
name|BlobPath
name|basePath
decl_stmt|;
DECL|field|repositoryName
specifier|private
specifier|final
name|String
name|repositoryName
decl_stmt|;
DECL|field|chunkSize
specifier|private
name|ByteSizeValue
name|chunkSize
decl_stmt|;
DECL|field|indicesService
specifier|private
specifier|final
name|IndicesService
name|indicesService
decl_stmt|;
DECL|field|snapshotRateLimiter
specifier|private
name|RateLimiter
name|snapshotRateLimiter
decl_stmt|;
DECL|field|restoreRateLimiter
specifier|private
name|RateLimiter
name|restoreRateLimiter
decl_stmt|;
DECL|field|rateLimiterListener
specifier|private
name|RateLimiterListener
name|rateLimiterListener
decl_stmt|;
DECL|field|snapshotThrottleListener
specifier|private
name|RateLimitingInputStream
operator|.
name|Listener
name|snapshotThrottleListener
decl_stmt|;
DECL|field|SNAPSHOT_PREFIX
specifier|private
specifier|static
specifier|final
name|String
name|SNAPSHOT_PREFIX
init|=
literal|"snapshot-"
decl_stmt|;
annotation|@
name|Inject
DECL|method|BlobStoreIndexShardRepository
name|BlobStoreIndexShardRepository
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|RepositoryName
name|repositoryName
parameter_list|,
name|IndicesService
name|indicesService
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|this
operator|.
name|repositoryName
operator|=
name|repositoryName
operator|.
name|name
argument_list|()
expr_stmt|;
name|this
operator|.
name|indicesService
operator|=
name|indicesService
expr_stmt|;
block|}
comment|/**      * Called by {@link org.elasticsearch.repositories.blobstore.BlobStoreRepository} on repository startup      *      * @param blobStore blob store      * @param basePath  base path to blob store      * @param chunkSize chunk size      */
DECL|method|initialize
specifier|public
name|void
name|initialize
parameter_list|(
name|BlobStore
name|blobStore
parameter_list|,
name|BlobPath
name|basePath
parameter_list|,
name|ByteSizeValue
name|chunkSize
parameter_list|,
name|RateLimiter
name|snapshotRateLimiter
parameter_list|,
name|RateLimiter
name|restoreRateLimiter
parameter_list|,
specifier|final
name|RateLimiterListener
name|rateLimiterListener
parameter_list|)
block|{
name|this
operator|.
name|blobStore
operator|=
name|blobStore
expr_stmt|;
name|this
operator|.
name|basePath
operator|=
name|basePath
expr_stmt|;
name|this
operator|.
name|chunkSize
operator|=
name|chunkSize
expr_stmt|;
name|this
operator|.
name|snapshotRateLimiter
operator|=
name|snapshotRateLimiter
expr_stmt|;
name|this
operator|.
name|restoreRateLimiter
operator|=
name|restoreRateLimiter
expr_stmt|;
name|this
operator|.
name|rateLimiterListener
operator|=
name|rateLimiterListener
expr_stmt|;
name|this
operator|.
name|snapshotThrottleListener
operator|=
operator|new
name|RateLimitingInputStream
operator|.
name|Listener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onPause
parameter_list|(
name|long
name|nanos
parameter_list|)
block|{
name|rateLimiterListener
operator|.
name|onSnapshotPause
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|snapshot
specifier|public
name|void
name|snapshot
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|SnapshotIndexCommit
name|snapshotIndexCommit
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|SnapshotContext
name|snapshotContext
init|=
operator|new
name|SnapshotContext
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|snapshotStatus
argument_list|)
decl_stmt|;
name|snapshotStatus
operator|.
name|startTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|snapshotContext
operator|.
name|snapshot
argument_list|(
name|snapshotIndexCommit
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|snapshotStatus
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FAILURE
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|failure
argument_list|(
name|ExceptionsHelper
operator|.
name|detailedMessage
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|instanceof
name|IndexShardSnapshotFailedException
condition|)
block|{
throw|throw
operator|(
name|IndexShardSnapshotFailedException
operator|)
name|e
throw|;
block|}
else|else
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
name|e
operator|.
name|getMessage
argument_list|()
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|restore
specifier|public
name|void
name|restore
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryStatus
name|recoveryStatus
parameter_list|)
block|{
name|RestoreContext
name|snapshotContext
init|=
operator|new
name|RestoreContext
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|snapshotShardId
argument_list|,
name|recoveryStatus
argument_list|)
decl_stmt|;
try|try
block|{
name|recoveryStatus
operator|.
name|index
argument_list|()
operator|.
name|startTime
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
argument_list|)
expr_stmt|;
name|snapshotContext
operator|.
name|restore
argument_list|()
expr_stmt|;
name|recoveryStatus
operator|.
name|index
argument_list|()
operator|.
name|time
argument_list|(
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|recoveryStatus
operator|.
name|index
argument_list|()
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to restore snapshot ["
operator|+
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
operator|+
literal|"]"
argument_list|,
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * {@inheritDoc}      */
annotation|@
name|Override
DECL|method|snapshotStatus
specifier|public
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|context
operator|.
name|loadSnapshot
argument_list|()
decl_stmt|;
name|IndexShardSnapshotStatus
name|status
init|=
operator|new
name|IndexShardSnapshotStatus
argument_list|()
decl_stmt|;
name|status
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
name|status
operator|.
name|startTime
argument_list|(
name|snapshot
operator|.
name|startTime
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|files
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
comment|// The snapshot is done which means the number of processed files is the same as total
name|status
operator|.
name|processedFiles
argument_list|(
name|snapshot
operator|.
name|numberOfFiles
argument_list|()
argument_list|,
name|snapshot
operator|.
name|totalSize
argument_list|()
argument_list|)
expr_stmt|;
name|status
operator|.
name|time
argument_list|(
name|snapshot
operator|.
name|time
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/**      * Delete shard snapshot      *      * @param snapshotId snapshot id      * @param shardId    shard id      */
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|Context
name|context
init|=
operator|new
name|Context
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
decl_stmt|;
name|context
operator|.
name|delete
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"BlobStoreIndexShardRepository["
operator|+
literal|"["
operator|+
name|repositoryName
operator|+
literal|"], ["
operator|+
name|blobStore
operator|+
literal|']'
operator|+
literal|']'
return|;
block|}
comment|/**      * Returns shard snapshot metadata file name      *      * @param snapshotId snapshot id      * @return shard snapshot metadata file name      */
DECL|method|snapshotBlobName
specifier|private
name|String
name|snapshotBlobName
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|)
block|{
return|return
name|SNAPSHOT_PREFIX
operator|+
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
return|;
block|}
comment|/**      * Serializes snapshot to JSON      *      * @param snapshot snapshot      * @return JSON representation of the snapshot      * @throws IOException      */
DECL|method|writeSnapshot
specifier|public
specifier|static
name|byte
index|[]
name|writeSnapshot
parameter_list|(
name|BlobStoreIndexShardSnapshot
name|snapshot
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentBuilder
name|builder
init|=
name|XContentFactory
operator|.
name|contentBuilder
argument_list|(
name|XContentType
operator|.
name|JSON
argument_list|)
operator|.
name|prettyPrint
argument_list|()
decl_stmt|;
name|BlobStoreIndexShardSnapshot
operator|.
name|toXContent
argument_list|(
name|snapshot
argument_list|,
name|builder
argument_list|,
name|ToXContent
operator|.
name|EMPTY_PARAMS
argument_list|)
expr_stmt|;
return|return
name|builder
operator|.
name|bytes
argument_list|()
operator|.
name|toBytes
argument_list|()
return|;
block|}
comment|/**      * Parses JSON representation of a snapshot      *      * @param data JSON      * @return snapshot      * @throws IOException      */
DECL|method|readSnapshot
specifier|public
specifier|static
name|BlobStoreIndexShardSnapshot
name|readSnapshot
parameter_list|(
name|byte
index|[]
name|data
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
name|parser
init|=
name|XContentFactory
operator|.
name|xContent
argument_list|(
name|XContentType
operator|.
name|JSON
argument_list|)
operator|.
name|createParser
argument_list|(
name|data
argument_list|)
decl_stmt|;
try|try
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
return|return
name|BlobStoreIndexShardSnapshot
operator|.
name|fromXContent
argument_list|(
name|parser
argument_list|)
return|;
block|}
finally|finally
block|{
name|parser
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Context for snapshot/restore operations      */
DECL|class|Context
specifier|private
class|class
name|Context
block|{
DECL|field|snapshotId
specifier|protected
specifier|final
name|SnapshotId
name|snapshotId
decl_stmt|;
DECL|field|shardId
specifier|protected
specifier|final
name|ShardId
name|shardId
decl_stmt|;
DECL|field|blobContainer
specifier|protected
specifier|final
name|ImmutableBlobContainer
name|blobContainer
decl_stmt|;
DECL|method|Context
specifier|public
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|)
block|{
name|this
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
block|}
DECL|method|Context
specifier|public
name|Context
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|)
block|{
name|this
operator|.
name|snapshotId
operator|=
name|snapshotId
expr_stmt|;
name|this
operator|.
name|shardId
operator|=
name|shardId
expr_stmt|;
name|blobContainer
operator|=
name|blobStore
operator|.
name|immutableBlobContainer
argument_list|(
name|basePath
operator|.
name|add
argument_list|(
literal|"indices"
argument_list|)
operator|.
name|add
argument_list|(
name|snapshotShardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|snapshotShardId
operator|.
name|getId
argument_list|()
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**          * Delete shard snapshot          */
DECL|method|delete
specifier|public
name|void
name|delete
parameter_list|()
block|{
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to list content of gateway"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|String
name|commitPointName
init|=
name|snapshotBlobName
argument_list|(
name|snapshotId
argument_list|)
decl_stmt|;
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|commitPointName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] failed to delete shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
block|}
comment|// delete all files that are not referenced by any commit point
comment|// build a new BlobStoreIndexShardSnapshot, that includes this one and all the saved ones
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|newSnapshotsList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|BlobStoreIndexShardSnapshot
name|point
range|:
name|snapshots
control|)
block|{
if|if
condition|(
operator|!
name|point
operator|.
name|snapshot
argument_list|()
operator|.
name|equals
argument_list|(
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
argument_list|)
condition|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
name|cleanup
argument_list|(
name|newSnapshotsList
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
block|}
comment|/**          * Loads information about shard snapshot          */
DECL|method|loadSnapshot
specifier|public
name|BlobStoreIndexShardSnapshot
name|loadSnapshot
parameter_list|()
block|{
name|BlobStoreIndexShardSnapshot
name|snapshot
decl_stmt|;
try|try
block|{
name|snapshot
operator|=
name|readSnapshot
argument_list|(
name|blobContainer
operator|.
name|readBlobFully
argument_list|(
name|snapshotBlobName
argument_list|(
name|snapshotId
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to read shard snapshot file"
argument_list|,
name|ex
argument_list|)
throw|;
block|}
return|return
name|snapshot
return|;
block|}
comment|/**          * Removes all unreferenced files from the repository          *          * @param snapshots list of active snapshots in the container          * @param blobs     list of blobs in the container          */
DECL|method|cleanup
specifier|protected
name|void
name|cleanup
parameter_list|(
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|snapshots
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobStoreIndexShardSnapshots
name|newSnapshots
init|=
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
decl_stmt|;
comment|// now go over all the blobs, and if they don't exists in a snapshot, delete them
for|for
control|(
name|String
name|blobName
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|blobName
operator|.
name|startsWith
argument_list|(
literal|"__"
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|newSnapshots
operator|.
name|findNameFile
argument_list|(
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|blobName
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|blobContainer
operator|.
name|deleteBlob
argument_list|(
name|blobName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] error deleting blob [{}] during cleanup"
argument_list|,
name|e
argument_list|,
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|blobName
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**          * Generates blob name          *          * @param generation the blob number          * @return the blob name          */
DECL|method|fileNameFromGeneration
specifier|protected
name|String
name|fileNameFromGeneration
parameter_list|(
name|long
name|generation
parameter_list|)
block|{
return|return
literal|"__"
operator|+
name|Long
operator|.
name|toString
argument_list|(
name|generation
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
return|;
block|}
comment|/**          * Finds the next available blob number          *          * @param blobs list of blobs in the repository          * @return next available blob number          */
DECL|method|findLatestFileNameGeneration
specifier|protected
name|long
name|findLatestFileNameGeneration
parameter_list|(
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|long
name|generation
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|name
operator|.
name|startsWith
argument_list|(
literal|"__"
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|name
operator|=
name|FileInfo
operator|.
name|canonicalName
argument_list|(
name|name
argument_list|)
expr_stmt|;
try|try
block|{
name|long
name|currentGen
init|=
name|Long
operator|.
name|parseLong
argument_list|(
name|name
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
comment|/*__*/
argument_list|,
name|Character
operator|.
name|MAX_RADIX
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentGen
operator|>
name|generation
condition|)
block|{
name|generation
operator|=
name|currentGen
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"file [{}] does not conform to the '__' schema"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|generation
return|;
block|}
comment|/**          * Loads all available snapshots in the repository          *          * @param blobs list of blobs in repository          * @return BlobStoreIndexShardSnapshots          */
DECL|method|buildBlobStoreIndexShardSnapshots
specifier|protected
name|BlobStoreIndexShardSnapshots
name|buildBlobStoreIndexShardSnapshots
parameter_list|(
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|snapshots
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|name
range|:
name|blobs
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|name
operator|.
name|startsWith
argument_list|(
name|SNAPSHOT_PREFIX
argument_list|)
condition|)
block|{
try|try
block|{
name|snapshots
operator|.
name|add
argument_list|(
name|readSnapshot
argument_list|(
name|blobContainer
operator|.
name|readBlobFully
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|logger
operator|.
name|warn
argument_list|(
literal|"failed to read commit point [{}]"
argument_list|,
name|e
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|new
name|BlobStoreIndexShardSnapshots
argument_list|(
name|snapshots
argument_list|)
return|;
block|}
block|}
comment|/**      * Context for snapshot operations      */
DECL|class|SnapshotContext
specifier|private
class|class
name|SnapshotContext
extends|extends
name|Context
block|{
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|snapshotStatus
specifier|private
specifier|final
name|IndexShardSnapshotStatus
name|snapshotStatus
decl_stmt|;
comment|/**          * Constructs new context          *          * @param snapshotId     snapshot id          * @param shardId        shard to be snapshotted          * @param snapshotStatus snapshot status to report progress          */
DECL|method|SnapshotContext
specifier|public
name|SnapshotContext
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|IndexShardSnapshotStatus
name|snapshotStatus
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|store
operator|=
name|indicesService
operator|.
name|indexServiceSafe
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|shardInjectorSafe
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|getInstance
argument_list|(
name|Store
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|snapshotStatus
operator|=
name|snapshotStatus
expr_stmt|;
block|}
comment|/**          * Create snapshot from index commit point          *          * @param snapshotIndexCommit snapshot commit point          */
DECL|method|snapshot
specifier|public
name|void
name|snapshot
parameter_list|(
name|SnapshotIndexCommit
name|snapshotIndexCommit
parameter_list|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] snapshot to [{}] ..."
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|repositoryName
argument_list|)
expr_stmt|;
specifier|final
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
decl_stmt|;
try|try
block|{
name|blobs
operator|=
name|blobContainer
operator|.
name|listBlobs
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"failed to list blobs"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|long
name|generation
init|=
name|findLatestFileNameGeneration
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshots
name|snapshots
init|=
name|buildBlobStoreIndexShardSnapshots
argument_list|(
name|blobs
argument_list|)
decl_stmt|;
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|Throwable
argument_list|>
name|failures
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|()
decl_stmt|;
specifier|final
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|>
name|indexCommitPointFiles
init|=
name|newArrayList
argument_list|()
decl_stmt|;
name|int
name|indexNumberOfFiles
init|=
literal|0
decl_stmt|;
name|long
name|indexTotalFilesSize
init|=
literal|0
decl_stmt|;
name|ArrayList
argument_list|<
name|FileInfo
argument_list|>
name|filesToSnapshot
init|=
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|fileName
range|:
name|snapshotIndexCommit
operator|.
name|getFiles
argument_list|()
control|)
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] Processing [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
specifier|final
name|StoreFileMetaData
name|md
decl_stmt|;
try|try
block|{
name|md
operator|=
name|store
operator|.
name|metaData
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to get store file metadata"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|boolean
name|snapshotRequired
init|=
literal|false
decl_stmt|;
comment|// TODO: For now segment files are copied on each commit because segment files don't have checksum
comment|//            if (snapshot.indexChanged()&& fileName.equals(snapshotIndexCommit.getSegmentsFileName())) {
comment|//                snapshotRequired = true; // we want to always snapshot the segment file if the index changed
comment|//            }
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
init|=
name|snapshots
operator|.
name|findPhysicalIndexFile
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|fileInfo
operator|==
literal|null
operator|||
operator|!
name|fileInfo
operator|.
name|isSame
argument_list|(
name|md
argument_list|)
operator|||
operator|!
name|snapshotFileExistsInBlobs
argument_list|(
name|fileInfo
argument_list|,
name|blobs
argument_list|)
condition|)
block|{
comment|// commit point file does not exists in any commit point, or has different length, or does not fully exists in the listed blobs
name|snapshotRequired
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|snapshotRequired
condition|)
block|{
name|indexNumberOfFiles
operator|++
expr_stmt|;
name|indexTotalFilesSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
comment|// create a new FileInfo
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|snapshotFileInfo
init|=
operator|new
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
argument_list|(
name|fileNameFromGeneration
argument_list|(
operator|++
name|generation
argument_list|)
argument_list|,
name|fileName
argument_list|,
name|md
operator|.
name|length
argument_list|()
argument_list|,
name|chunkSize
argument_list|,
name|md
operator|.
name|checksum
argument_list|()
argument_list|)
decl_stmt|;
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
name|filesToSnapshot
operator|.
name|add
argument_list|(
name|snapshotFileInfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indexCommitPointFiles
operator|.
name|add
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
block|}
block|}
name|snapshotStatus
operator|.
name|files
argument_list|(
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|STARTED
argument_list|)
expr_stmt|;
specifier|final
name|CountDownLatch
name|indexLatch
init|=
operator|new
name|CountDownLatch
argument_list|(
name|filesToSnapshot
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|FileInfo
name|snapshotFileInfo
range|:
name|filesToSnapshot
control|)
block|{
try|try
block|{
name|snapshotFile
argument_list|(
name|snapshotFileInfo
argument_list|,
name|indexLatch
argument_list|,
name|failures
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|failures
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
name|snapshotStatus
operator|.
name|indexVersion
argument_list|(
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|)
expr_stmt|;
try|try
block|{
name|indexLatch
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|failures
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to perform snapshot (index files)"
argument_list|,
name|failures
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
comment|// now create and write the commit point
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|FINALIZE
argument_list|)
expr_stmt|;
name|String
name|commitPointName
init|=
name|snapshotBlobName
argument_list|(
name|snapshotId
argument_list|)
decl_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
operator|new
name|BlobStoreIndexShardSnapshot
argument_list|(
name|snapshotId
operator|.
name|getSnapshot
argument_list|()
argument_list|,
name|snapshotIndexCommit
operator|.
name|getGeneration
argument_list|()
argument_list|,
name|indexCommitPointFiles
argument_list|,
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
comment|// snapshotStatus.startTime() is assigned on the same machine, so it's safe to use with VLong
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|snapshotStatus
operator|.
name|startTime
argument_list|()
argument_list|,
name|indexNumberOfFiles
argument_list|,
name|indexTotalFilesSize
argument_list|)
decl_stmt|;
comment|//TODO: The time stored in snapshot doesn't include cleanup time.
try|try
block|{
name|byte
index|[]
name|snapshotData
init|=
name|writeSnapshot
argument_list|(
name|snapshot
argument_list|)
decl_stmt|;
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] writing shard snapshot file"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|)
expr_stmt|;
name|blobContainer
operator|.
name|writeBlob
argument_list|(
name|commitPointName
argument_list|,
operator|new
name|BytesStreamInput
argument_list|(
name|snapshotData
argument_list|,
literal|false
argument_list|)
argument_list|,
name|snapshotData
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to write commit point"
argument_list|,
name|e
argument_list|)
throw|;
block|}
comment|// delete all files that are not referenced by any commit point
comment|// build a new BlobStoreIndexShardSnapshot, that includes this one and all the saved ones
name|List
argument_list|<
name|BlobStoreIndexShardSnapshot
argument_list|>
name|newSnapshotsList
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
for|for
control|(
name|BlobStoreIndexShardSnapshot
name|point
range|:
name|snapshots
control|)
block|{
name|newSnapshotsList
operator|.
name|add
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
name|cleanup
argument_list|(
name|newSnapshotsList
argument_list|,
name|blobs
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|updateStage
argument_list|(
name|IndexShardSnapshotStatus
operator|.
name|Stage
operator|.
name|DONE
argument_list|)
expr_stmt|;
block|}
comment|/**          * Snapshot individual file          *<p/>          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be snapshotted          * @param latch    latch that should be counted down once file is snapshoted          * @param failures thread-safe list of failures          * @throws IOException          */
DECL|method|snapshotFile
specifier|private
name|void
name|snapshotFile
parameter_list|(
specifier|final
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
specifier|final
name|CountDownLatch
name|latch
parameter_list|,
specifier|final
name|List
argument_list|<
name|Throwable
argument_list|>
name|failures
parameter_list|)
throws|throws
name|IOException
block|{
specifier|final
name|AtomicLong
name|counter
init|=
operator|new
name|AtomicLong
argument_list|(
name|fileInfo
operator|.
name|numberOfParts
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|long
name|i
init|=
literal|0
init|;
name|i
operator|<
name|fileInfo
operator|.
name|numberOfParts
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|IndexInput
name|indexInput
init|=
literal|null
decl_stmt|;
try|try
block|{
name|indexInput
operator|=
name|store
operator|.
name|openInputRaw
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|IOContext
operator|.
name|READONCE
argument_list|)
expr_stmt|;
name|indexInput
operator|.
name|seek
argument_list|(
name|i
operator|*
name|fileInfo
operator|.
name|partBytes
argument_list|()
argument_list|)
expr_stmt|;
name|InputStreamIndexInput
name|inputStreamIndexInput
init|=
operator|new
name|ThreadSafeInputStreamIndexInput
argument_list|(
name|indexInput
argument_list|,
name|fileInfo
operator|.
name|partBytes
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|IndexInput
name|fIndexInput
init|=
name|indexInput
decl_stmt|;
name|long
name|size
init|=
name|inputStreamIndexInput
operator|.
name|actualSizeToRead
argument_list|()
decl_stmt|;
name|InputStream
name|inputStream
decl_stmt|;
if|if
condition|(
name|snapshotRateLimiter
operator|!=
literal|null
condition|)
block|{
name|inputStream
operator|=
operator|new
name|RateLimitingInputStream
argument_list|(
name|inputStreamIndexInput
argument_list|,
name|snapshotRateLimiter
argument_list|,
name|snapshotThrottleListener
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inputStream
operator|=
name|inputStreamIndexInput
expr_stmt|;
block|}
name|inputStream
operator|=
operator|new
name|AbortableInputStream
argument_list|(
name|inputStream
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
name|blobContainer
operator|.
name|writeBlob
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|i
argument_list|)
argument_list|,
name|inputStream
argument_list|,
name|size
argument_list|,
operator|new
name|ImmutableBlobContainer
operator|.
name|WriterListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|onCompleted
parameter_list|()
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|fIndexInput
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
name|fileInfo
operator|.
name|length
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|.
name|decrementAndGet
argument_list|()
operator|==
literal|0
condition|)
block|{
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|fIndexInput
argument_list|)
expr_stmt|;
name|snapshotStatus
operator|.
name|addProcessedFile
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|failures
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|.
name|decrementAndGet
argument_list|()
operator|==
literal|0
condition|)
block|{
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|IOUtils
operator|.
name|closeWhileHandlingException
argument_list|(
name|indexInput
argument_list|)
expr_stmt|;
name|failures
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Checks if snapshot file already exists in the list of blobs          *          * @param fileInfo file to check          * @param blobs    list of blobs          * @return true if file exists in the list of blobs          */
DECL|method|snapshotFileExistsInBlobs
specifier|private
name|boolean
name|snapshotFileExistsInBlobs
parameter_list|(
name|BlobStoreIndexShardSnapshot
operator|.
name|FileInfo
name|fileInfo
parameter_list|,
name|ImmutableMap
argument_list|<
name|String
argument_list|,
name|BlobMetaData
argument_list|>
name|blobs
parameter_list|)
block|{
name|BlobMetaData
name|blobMetaData
init|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|name
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|blobMetaData
operator|!=
literal|null
condition|)
block|{
return|return
name|blobMetaData
operator|.
name|length
argument_list|()
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|blobs
operator|.
name|containsKey
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|// multi part file sum up the size and check
name|int
name|part
init|=
literal|0
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
name|blobMetaData
operator|=
name|blobs
operator|.
name|get
argument_list|(
name|fileInfo
operator|.
name|partName
argument_list|(
name|part
operator|++
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blobMetaData
operator|==
literal|null
condition|)
block|{
break|break;
block|}
name|totalSize
operator|+=
name|blobMetaData
operator|.
name|length
argument_list|()
expr_stmt|;
block|}
return|return
name|totalSize
operator|==
name|fileInfo
operator|.
name|length
argument_list|()
return|;
block|}
comment|// no file, not exact and not multipart
return|return
literal|false
return|;
block|}
DECL|class|AbortableInputStream
specifier|private
class|class
name|AbortableInputStream
extends|extends
name|FilterInputStream
block|{
DECL|field|fileName
specifier|private
specifier|final
name|String
name|fileName
decl_stmt|;
DECL|method|AbortableInputStream
specifier|public
name|AbortableInputStream
parameter_list|(
name|InputStream
name|delegate
parameter_list|,
name|String
name|fileName
parameter_list|)
block|{
name|super
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
name|this
operator|.
name|fileName
operator|=
name|fileName
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|()
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|read
specifier|public
name|int
name|read
parameter_list|(
name|byte
index|[]
name|b
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|)
throws|throws
name|IOException
block|{
name|checkAborted
argument_list|()
expr_stmt|;
return|return
name|in
operator|.
name|read
argument_list|(
name|b
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
return|;
block|}
DECL|method|checkAborted
specifier|private
name|void
name|checkAborted
parameter_list|()
block|{
if|if
condition|(
name|snapshotStatus
operator|.
name|aborted
argument_list|()
condition|)
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] Aborted on the file [{}], exiting"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileName
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|IndexShardSnapshotFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Aborted"
argument_list|)
throw|;
block|}
block|}
block|}
block|}
comment|/**      * Context for restore operations      */
DECL|class|RestoreContext
specifier|private
class|class
name|RestoreContext
extends|extends
name|Context
block|{
DECL|field|store
specifier|private
specifier|final
name|Store
name|store
decl_stmt|;
DECL|field|recoveryStatus
specifier|private
specifier|final
name|RecoveryStatus
name|recoveryStatus
decl_stmt|;
comment|/**          * Constructs new restore context          *          * @param snapshotId      snapshot id          * @param shardId         shard to be restored          * @param snapshotShardId shard in the snapshot that data should be restored from          * @param recoveryStatus  recovery status to report progress          */
DECL|method|RestoreContext
specifier|public
name|RestoreContext
parameter_list|(
name|SnapshotId
name|snapshotId
parameter_list|,
name|ShardId
name|shardId
parameter_list|,
name|ShardId
name|snapshotShardId
parameter_list|,
name|RecoveryStatus
name|recoveryStatus
parameter_list|)
block|{
name|super
argument_list|(
name|snapshotId
argument_list|,
name|shardId
argument_list|,
name|snapshotShardId
argument_list|)
expr_stmt|;
name|store
operator|=
name|indicesService
operator|.
name|indexServiceSafe
argument_list|(
name|shardId
operator|.
name|getIndex
argument_list|()
argument_list|)
operator|.
name|shardInjectorSafe
argument_list|(
name|shardId
operator|.
name|id
argument_list|()
argument_list|)
operator|.
name|getInstance
argument_list|(
name|Store
operator|.
name|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|recoveryStatus
operator|=
name|recoveryStatus
expr_stmt|;
block|}
comment|/**          * Performs restore operation          */
DECL|method|restore
specifier|public
name|void
name|restore
parameter_list|()
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"[{}] [{}] restoring to [{}] ..."
argument_list|,
name|snapshotId
argument_list|,
name|repositoryName
argument_list|,
name|shardId
argument_list|)
expr_stmt|;
name|BlobStoreIndexShardSnapshot
name|snapshot
init|=
name|loadSnapshot
argument_list|()
decl_stmt|;
name|recoveryStatus
operator|.
name|updateStage
argument_list|(
name|RecoveryStatus
operator|.
name|Stage
operator|.
name|INDEX
argument_list|)
expr_stmt|;
name|int
name|numberOfFiles
init|=
literal|0
decl_stmt|;
name|long
name|totalSize
init|=
literal|0
decl_stmt|;
name|int
name|numberOfReusedFiles
init|=
literal|0
decl_stmt|;
name|long
name|reusedTotalSize
init|=
literal|0
decl_stmt|;
name|List
argument_list|<
name|FileInfo
argument_list|>
name|filesToRecover
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
for|for
control|(
name|FileInfo
name|fileInfo
range|:
name|snapshot
operator|.
name|indexFiles
argument_list|()
control|)
block|{
name|String
name|fileName
init|=
name|fileInfo
operator|.
name|physicalName
argument_list|()
decl_stmt|;
name|StoreFileMetaData
name|md
init|=
literal|null
decl_stmt|;
try|try
block|{
name|md
operator|=
name|store
operator|.
name|metaData
argument_list|(
name|fileName
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// no file
block|}
name|numberOfFiles
operator|++
expr_stmt|;
comment|// we don't compute checksum for segments, so always recover them
if|if
condition|(
operator|!
name|fileName
operator|.
name|startsWith
argument_list|(
literal|"segments"
argument_list|)
operator|&&
name|md
operator|!=
literal|null
operator|&&
name|fileInfo
operator|.
name|isSame
argument_list|(
name|md
argument_list|)
condition|)
block|{
name|totalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
name|numberOfReusedFiles
operator|++
expr_stmt|;
name|reusedTotalSize
operator|+=
name|md
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"not_recovering [{}], exists in local store and is same"
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|totalSize
operator|+=
name|fileInfo
operator|.
name|length
argument_list|()
expr_stmt|;
name|filesToRecover
operator|.
name|add
argument_list|(
name|fileInfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"recovering [{}], does not exists in local store"
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"recovering [{}], exists in local store but is different"
argument_list|,
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|recoveryStatus
operator|.
name|index
argument_list|()
operator|.
name|files
argument_list|(
name|numberOfFiles
argument_list|,
name|totalSize
argument_list|,
name|numberOfReusedFiles
argument_list|,
name|reusedTotalSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|filesToRecover
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"no files to recover, all exists within the local store"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] recovering_files [{}] with total_size [{}], reusing_files [{}] with reused_size [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|numberOfFiles
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|totalSize
argument_list|)
argument_list|,
name|numberOfReusedFiles
argument_list|,
operator|new
name|ByteSizeValue
argument_list|(
name|reusedTotalSize
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|final
name|CountDownLatch
name|latch
init|=
operator|new
name|CountDownLatch
argument_list|(
name|filesToRecover
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|CopyOnWriteArrayList
argument_list|<
name|Throwable
argument_list|>
name|failures
init|=
operator|new
name|CopyOnWriteArrayList
argument_list|<
name|Throwable
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
specifier|final
name|FileInfo
name|fileToRecover
range|:
name|filesToRecover
control|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"[{}] [{}] restoring file [{}]"
argument_list|,
name|shardId
argument_list|,
name|snapshotId
argument_list|,
name|fileToRecover
operator|.
name|name
argument_list|()
argument_list|)
expr_stmt|;
name|restoreFile
argument_list|(
name|fileToRecover
argument_list|,
name|latch
argument_list|,
name|failures
argument_list|)
expr_stmt|;
block|}
try|try
block|{
name|latch
operator|.
name|await
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|failures
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to recover index"
argument_list|,
name|failures
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
throw|;
block|}
comment|// read the snapshot data persisted
name|long
name|version
init|=
operator|-
literal|1
decl_stmt|;
try|try
block|{
if|if
condition|(
name|Lucene
operator|.
name|indexExists
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
condition|)
block|{
name|version
operator|=
name|Lucene
operator|.
name|readSegmentInfos
argument_list|(
name|store
operator|.
name|directory
argument_list|()
argument_list|)
operator|.
name|getVersion
argument_list|()
expr_stmt|;
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|IndexShardRestoreFailedException
argument_list|(
name|shardId
argument_list|,
literal|"Failed to fetch index version after copying it over"
argument_list|,
name|e
argument_list|)
throw|;
block|}
name|recoveryStatus
operator|.
name|index
argument_list|()
operator|.
name|updateVersion
argument_list|(
name|version
argument_list|)
expr_stmt|;
comment|/// now, go over and clean files that are in the store, but were not in the snapshot
try|try
block|{
for|for
control|(
name|String
name|storeFile
range|:
name|store
operator|.
name|directory
argument_list|()
operator|.
name|listAll
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|snapshot
operator|.
name|containPhysicalIndexFile
argument_list|(
name|storeFile
argument_list|)
condition|)
block|{
try|try
block|{
name|store
operator|.
name|directory
argument_list|()
operator|.
name|deleteFile
argument_list|(
name|storeFile
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
block|}
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
comment|// ignore
block|}
block|}
comment|/**          * Restores a file          * This is asynchronous method. Upon completion of the operation latch is getting counted down and any failures are          * added to the {@code failures} list          *          * @param fileInfo file to be restored          * @param latch    latch that should be counted down once file is snapshoted          * @param failures thread-safe list of failures          */
DECL|method|restoreFile
specifier|private
name|void
name|restoreFile
parameter_list|(
specifier|final
name|FileInfo
name|fileInfo
parameter_list|,
specifier|final
name|CountDownLatch
name|latch
parameter_list|,
specifier|final
name|List
argument_list|<
name|Throwable
argument_list|>
name|failures
parameter_list|)
block|{
specifier|final
name|IndexOutput
name|indexOutput
decl_stmt|;
try|try
block|{
comment|// we create an output with no checksum, this is because the pure binary data of the file is not
comment|// the checksum (because of seek). We will create the checksum file once copying is done
name|indexOutput
operator|=
name|store
operator|.
name|createOutputRaw
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|failures
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
return|return;
block|}
name|String
name|firstFileToRecover
init|=
name|fileInfo
operator|.
name|partName
argument_list|(
literal|0
argument_list|)
decl_stmt|;
specifier|final
name|AtomicInteger
name|partIndex
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
name|blobContainer
operator|.
name|readBlob
argument_list|(
name|firstFileToRecover
argument_list|,
operator|new
name|BlobContainer
operator|.
name|ReadBlobListener
argument_list|()
block|{
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|onPartial
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
throws|throws
name|IOException
block|{
name|recoveryStatus
operator|.
name|index
argument_list|()
operator|.
name|addCurrentFilesSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|indexOutput
operator|.
name|writeBytes
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|restoreRateLimiter
operator|!=
literal|null
condition|)
block|{
name|rateLimiterListener
operator|.
name|onRestorePause
argument_list|(
name|restoreRateLimiter
operator|.
name|pause
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
specifier|public
specifier|synchronized
name|void
name|onCompleted
parameter_list|()
block|{
name|int
name|part
init|=
name|partIndex
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
if|if
condition|(
name|part
operator|<
name|fileInfo
operator|.
name|numberOfParts
argument_list|()
condition|)
block|{
name|String
name|partName
init|=
name|fileInfo
operator|.
name|partName
argument_list|(
name|part
argument_list|)
decl_stmt|;
comment|// continue with the new part
name|blobContainer
operator|.
name|readBlob
argument_list|(
name|partName
argument_list|,
name|this
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// we are done...
try|try
block|{
name|indexOutput
operator|.
name|close
argument_list|()
expr_stmt|;
comment|// write the checksum
if|if
condition|(
name|fileInfo
operator|.
name|checksum
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|store
operator|.
name|writeChecksum
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|,
name|fileInfo
operator|.
name|checksum
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|store
operator|.
name|directory
argument_list|()
operator|.
name|sync
argument_list|(
name|Collections
operator|.
name|singleton
argument_list|(
name|fileInfo
operator|.
name|physicalName
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
name|onFailure
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|void
name|onFailure
parameter_list|(
name|Throwable
name|t
parameter_list|)
block|{
name|failures
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|latch
operator|.
name|countDown
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
expr_stmt|;
block|}
block|}
DECL|interface|RateLimiterListener
specifier|public
interface|interface
name|RateLimiterListener
block|{
DECL|method|onRestorePause
name|void
name|onRestorePause
parameter_list|(
name|long
name|nanos
parameter_list|)
function_decl|;
DECL|method|onSnapshotPause
name|void
name|onSnapshotPause
parameter_list|(
name|long
name|nanos
parameter_list|)
function_decl|;
block|}
block|}
end_class

end_unit

