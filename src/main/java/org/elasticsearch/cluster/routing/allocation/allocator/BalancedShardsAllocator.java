begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to ElasticSearch and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. ElasticSearch licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.cluster.routing.allocation.allocator
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|allocator
package|;
end_package

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|base
operator|.
name|Predicate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Iterables
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|SorterTemplate
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticSearchIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|metadata
operator|.
name|MetaData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|FailedRerouteAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|RoutingAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|StartedRerouteAllocation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|AllocationDeciders
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|allocation
operator|.
name|decider
operator|.
name|Decision
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|component
operator|.
name|AbstractComponent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|inject
operator|.
name|Inject
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|settings
operator|.
name|Settings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|node
operator|.
name|settings
operator|.
name|NodeSettingsService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
operator|.
name|INITIALIZING
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|cluster
operator|.
name|routing
operator|.
name|ShardRoutingState
operator|.
name|RELOCATING
import|;
end_import

begin_comment
comment|/**  * The {@link BalancedShardsAllocator} re-balances the nodes allocations  * within an cluster based on a {@link WeightFunction}. The clusters balance is defined by four parameters which can be set  * in the cluster update API that allows changes in real-time:  *<p/>  *<ul><li><code>cluster.routing.allocation.balance.shard</code> - The<b>shard balance</b> defines the weight factor  * for shards allocated on a {@link RoutingNode}</li>  *<li><code>cluster.routing.allocation.balance.index</code> - The<b>index balance</b> defines a factor to the number  * of {@link org.elasticsearch.cluster.routing.ShardRouting}s per index allocated on a specific node</li>  *<li><code>cluster.routing.allocation.balance.primary</code> - the<b>primary balance</b> defines a weight factor for  * the number of primaries of a specific index allocated on a node</li>  *<li><code>cluster.routing.allocation.balance.threshold</code> - A<b>threshold</b> to set the minimal optimization  * value of operations that should be performed</li>  *</ul>  *<p/>  * These parameters are combined in a {@link WeightFunction} that allows calculation of node weights which  * are used to re-balance shards based on global as well as per-index factors.  */
end_comment

begin_class
DECL|class|BalancedShardsAllocator
specifier|public
class|class
name|BalancedShardsAllocator
extends|extends
name|AbstractComponent
implements|implements
name|ShardsAllocator
block|{
DECL|field|SETTING_THRESHOLD
specifier|public
specifier|static
specifier|final
name|String
name|SETTING_THRESHOLD
init|=
literal|"cluster.routing.allocation.balance.threshold"
decl_stmt|;
DECL|field|SETTING_INDEX_BALANCE_FACTOR
specifier|public
specifier|static
specifier|final
name|String
name|SETTING_INDEX_BALANCE_FACTOR
init|=
literal|"cluster.routing.allocation.balance.index"
decl_stmt|;
DECL|field|SETTING_SHARD_BALANCE_FACTOR
specifier|public
specifier|static
specifier|final
name|String
name|SETTING_SHARD_BALANCE_FACTOR
init|=
literal|"cluster.routing.allocation.balance.shard"
decl_stmt|;
DECL|field|SETTING_PRIMARY_BALANCE_FACTOR
specifier|public
specifier|static
specifier|final
name|String
name|SETTING_PRIMARY_BALANCE_FACTOR
init|=
literal|"cluster.routing.allocation.balance.primary"
decl_stmt|;
DECL|field|DEFAULT_INDEX_BALANCE_FACTOR
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_INDEX_BALANCE_FACTOR
init|=
literal|0.5f
decl_stmt|;
DECL|field|DEFAULT_SHARD_BALANCE_FACTOR
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_SHARD_BALANCE_FACTOR
init|=
literal|0.45f
decl_stmt|;
DECL|field|DEFAULT_PRIMARY_BALANCE_FACTOR
specifier|private
specifier|static
specifier|final
name|float
name|DEFAULT_PRIMARY_BALANCE_FACTOR
init|=
literal|0.05f
decl_stmt|;
DECL|class|ApplySettings
class|class
name|ApplySettings
implements|implements
name|NodeSettingsService
operator|.
name|Listener
block|{
annotation|@
name|Override
DECL|method|onRefreshSettings
specifier|public
name|void
name|onRefreshSettings
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
specifier|final
name|float
name|indexBalance
init|=
name|settings
operator|.
name|getAsFloat
argument_list|(
name|SETTING_INDEX_BALANCE_FACTOR
argument_list|,
name|weightFunction
operator|.
name|indexBalance
argument_list|)
decl_stmt|;
specifier|final
name|float
name|shardBalance
init|=
name|settings
operator|.
name|getAsFloat
argument_list|(
name|SETTING_SHARD_BALANCE_FACTOR
argument_list|,
name|weightFunction
operator|.
name|shardBalance
argument_list|)
decl_stmt|;
specifier|final
name|float
name|primaryBalance
init|=
name|settings
operator|.
name|getAsFloat
argument_list|(
name|SETTING_PRIMARY_BALANCE_FACTOR
argument_list|,
name|weightFunction
operator|.
name|primaryBalance
argument_list|)
decl_stmt|;
name|float
name|threshold
init|=
name|settings
operator|.
name|getAsFloat
argument_list|(
name|SETTING_THRESHOLD
argument_list|,
name|BalancedShardsAllocator
operator|.
name|this
operator|.
name|threshold
argument_list|)
decl_stmt|;
if|if
condition|(
name|threshold
operator|<=
literal|0.0f
condition|)
block|{
throw|throw
operator|new
name|ElasticSearchIllegalArgumentException
argument_list|(
literal|"threshold must be greater than 0.0f but was: "
operator|+
name|threshold
argument_list|)
throw|;
block|}
name|BalancedShardsAllocator
operator|.
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
name|BalancedShardsAllocator
operator|.
name|this
operator|.
name|weightFunction
operator|=
operator|new
name|WeightFunction
argument_list|(
name|indexBalance
argument_list|,
name|shardBalance
argument_list|,
name|primaryBalance
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|weightFunction
specifier|private
specifier|volatile
name|WeightFunction
name|weightFunction
init|=
operator|new
name|WeightFunction
argument_list|(
name|DEFAULT_INDEX_BALANCE_FACTOR
argument_list|,
name|DEFAULT_SHARD_BALANCE_FACTOR
argument_list|,
name|DEFAULT_PRIMARY_BALANCE_FACTOR
argument_list|)
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|volatile
name|float
name|threshold
init|=
literal|1.0f
decl_stmt|;
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|)
block|{
name|this
argument_list|(
name|settings
argument_list|,
operator|new
name|NodeSettingsService
argument_list|(
name|settings
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Inject
DECL|method|BalancedShardsAllocator
specifier|public
name|BalancedShardsAllocator
parameter_list|(
name|Settings
name|settings
parameter_list|,
name|NodeSettingsService
name|nodeSettingsService
parameter_list|)
block|{
name|super
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|ApplySettings
name|applySettings
init|=
operator|new
name|ApplySettings
argument_list|()
decl_stmt|;
name|applySettings
operator|.
name|onRefreshSettings
argument_list|(
name|settings
argument_list|)
expr_stmt|;
name|nodeSettingsService
operator|.
name|addListener
argument_list|(
name|applySettings
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|applyStartedShards
specifier|public
name|void
name|applyStartedShards
parameter_list|(
name|StartedRerouteAllocation
name|allocation
parameter_list|)
block|{
comment|/* ONLY FOR GATEWAYS */
block|}
annotation|@
name|Override
DECL|method|applyFailedShards
specifier|public
name|void
name|applyFailedShards
parameter_list|(
name|FailedRerouteAllocation
name|allocation
parameter_list|)
block|{
comment|/* ONLY FOR GATEWAYS */
block|}
annotation|@
name|Override
DECL|method|allocateUnassigned
specifier|public
name|boolean
name|allocateUnassigned
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
return|return
name|rebalance
argument_list|(
name|allocation
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|rebalance
specifier|public
name|boolean
name|rebalance
parameter_list|(
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
return|return
name|balancer
operator|.
name|balance
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|move
specifier|public
name|boolean
name|move
parameter_list|(
name|MutableShardRouting
name|shardRouting
parameter_list|,
name|RoutingNode
name|node
parameter_list|,
name|RoutingAllocation
name|allocation
parameter_list|)
block|{
specifier|final
name|Balancer
name|balancer
init|=
operator|new
name|Balancer
argument_list|(
name|logger
argument_list|,
name|allocation
argument_list|,
name|weightFunction
argument_list|,
name|threshold
argument_list|)
decl_stmt|;
return|return
name|balancer
operator|.
name|move
argument_list|(
name|shardRouting
argument_list|,
name|node
argument_list|)
return|;
block|}
comment|/**      * Returns the currently configured delta threshold      */
DECL|method|getThreshold
specifier|public
name|float
name|getThreshold
parameter_list|()
block|{
return|return
name|threshold
return|;
block|}
comment|/**      * Returns the index related weight factor.      */
DECL|method|getIndexBalance
specifier|public
name|float
name|getIndexBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|indexBalance
return|;
block|}
comment|/**      * Returns the primary related weight factor.      */
DECL|method|getPrimaryBalance
specifier|public
name|float
name|getPrimaryBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|primaryBalance
return|;
block|}
comment|/**      * Returns the shard related weight factor.      */
DECL|method|getShardBalance
specifier|public
name|float
name|getShardBalance
parameter_list|()
block|{
return|return
name|weightFunction
operator|.
name|shardBalance
return|;
block|}
comment|/**      * This class is the primary weight function used to create balanced over nodes and shards in the cluster.      * Currently this function has 3 properties:      *<ul>      *<li><code>index balance</code> - balance property over shards per index</li>      *<li><code>shard balance</code> - balance property over shards per cluster</li>      *<li><code>primary balance</code> - balance property over primaries per cluster</li>      *</ul>      *<p>      * Each of these properties are expressed as factor such that the properties factor defines the relative importance of the property for the      * weight function. For example if the weight function should calculate the weights only based on a global (shard) balance the index and primary balance      * can be set to<tt>0.0</tt> and will in turn have no effect on the distribution.      *</p>      * The weight per index is calculated based on the following formula:      *<ul>      *<li>      *<code>weight<sub>index</sub>(node, index) = indexBalance * (node.numShards(index) - avgShardsPerNode(index))</code>      *</li>      *<li>      *<code>weight<sub>node</sub>(node, index) = shardBalance * (node.numShards() - avgShardsPerNode)</code>      *</li>      *<li>      *<code>weight<sub>primary</sub>(node, index) = primaryBalance * (node.numPrimaries() - avgPrimariesPerNode)</code>      *</li>      *</ul>      *<code>weight(node, index) = weight<sub>index</sub>(node, index) + weight<sub>node</sub>(node, index) + weight<sub>primary</sub>(node, index)</code>      */
DECL|class|WeightFunction
specifier|public
specifier|static
class|class
name|WeightFunction
block|{
DECL|field|indexBalance
specifier|private
specifier|final
name|float
name|indexBalance
decl_stmt|;
DECL|field|shardBalance
specifier|private
specifier|final
name|float
name|shardBalance
decl_stmt|;
DECL|field|primaryBalance
specifier|private
specifier|final
name|float
name|primaryBalance
decl_stmt|;
DECL|field|thetaMap
specifier|private
specifier|final
name|EnumMap
argument_list|<
name|Operation
argument_list|,
name|float
index|[]
argument_list|>
name|thetaMap
init|=
operator|new
name|EnumMap
argument_list|<
name|BalancedShardsAllocator
operator|.
name|Operation
argument_list|,
name|float
index|[]
argument_list|>
argument_list|(
name|Operation
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|method|WeightFunction
specifier|public
name|WeightFunction
parameter_list|(
name|float
name|indexBalance
parameter_list|,
name|float
name|shardBalance
parameter_list|,
name|float
name|primaryBalance
parameter_list|)
block|{
name|float
name|sum
init|=
name|indexBalance
operator|+
name|shardBalance
operator|+
name|primaryBalance
decl_stmt|;
if|if
condition|(
name|sum
operator|<=
literal|0.0f
condition|)
block|{
throw|throw
operator|new
name|ElasticSearchIllegalArgumentException
argument_list|(
literal|"Balance factors must sum to a value> 0 but was: "
operator|+
name|sum
argument_list|)
throw|;
block|}
specifier|final
name|float
index|[]
name|defaultTheta
init|=
operator|new
name|float
index|[]
block|{
name|shardBalance
operator|/
name|sum
block|,
name|indexBalance
operator|/
name|sum
block|,
name|primaryBalance
operator|/
name|sum
block|}
decl_stmt|;
for|for
control|(
name|Operation
name|operation
range|:
name|Operation
operator|.
name|values
argument_list|()
control|)
block|{
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|THRESHOLD_CHECK
case|:
name|sum
operator|=
name|indexBalance
operator|+
name|shardBalance
expr_stmt|;
if|if
condition|(
name|sum
operator|<=
literal|0.0f
condition|)
block|{
name|thetaMap
operator|.
name|put
argument_list|(
name|operation
argument_list|,
name|defaultTheta
argument_list|)
expr_stmt|;
block|}
name|thetaMap
operator|.
name|put
argument_list|(
name|operation
argument_list|,
operator|new
name|float
index|[]
block|{
name|shardBalance
operator|/
name|sum
block|,
name|indexBalance
operator|/
name|sum
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
break|break;
case|case
name|BALANCE
case|:
case|case
name|ALLOCATE
case|:
case|case
name|MOVE
case|:
name|thetaMap
operator|.
name|put
argument_list|(
name|operation
argument_list|,
name|defaultTheta
argument_list|)
expr_stmt|;
break|break;
default|default:
assert|assert
literal|false
assert|;
block|}
block|}
name|this
operator|.
name|indexBalance
operator|=
name|indexBalance
expr_stmt|;
name|this
operator|.
name|shardBalance
operator|=
name|shardBalance
expr_stmt|;
name|this
operator|.
name|primaryBalance
operator|=
name|primaryBalance
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|Balancer
name|balancer
parameter_list|,
name|ModelNode
name|node
parameter_list|,
name|String
name|index
parameter_list|)
block|{
specifier|final
name|float
name|weightShard
init|=
operator|(
name|node
operator|.
name|numShards
argument_list|()
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|()
operator|)
decl_stmt|;
specifier|final
name|float
name|weightIndex
init|=
operator|(
name|node
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|-
name|balancer
operator|.
name|avgShardsPerNode
argument_list|(
name|index
argument_list|)
operator|)
decl_stmt|;
specifier|final
name|float
name|weightPrimary
init|=
operator|(
name|node
operator|.
name|numPrimaries
argument_list|()
operator|-
name|balancer
operator|.
name|avgPrimariesPerNode
argument_list|()
operator|)
decl_stmt|;
specifier|final
name|float
index|[]
name|theta
init|=
name|thetaMap
operator|.
name|get
argument_list|(
name|operation
argument_list|)
decl_stmt|;
assert|assert
name|theta
operator|!=
literal|null
assert|;
return|return
name|theta
index|[
literal|0
index|]
operator|*
name|weightShard
operator|+
name|theta
index|[
literal|1
index|]
operator|*
name|weightIndex
operator|+
name|theta
index|[
literal|2
index|]
operator|*
name|weightPrimary
return|;
block|}
block|}
comment|/**      * An enum that donates the actual operation the {@link WeightFunction} is      * applied to.      */
DECL|enum|Operation
specifier|public
specifier|static
enum|enum
name|Operation
block|{
comment|/**          * Provided during balance operations.           */
DECL|enum constant|BALANCE
name|BALANCE
block|,
comment|/**          * Provided during initial allocation operation for unassigned shards.           */
DECL|enum constant|ALLOCATE
name|ALLOCATE
block|,
comment|/**          * Provided during move operation.          */
DECL|enum constant|MOVE
name|MOVE
block|,
comment|/**          * Provided when the weight delta is checked against the configured threshold.          * This can be used to ignore tie-breaking weight factors that should not           * solely trigger a relocation unless the delta is above the threshold.           */
DECL|enum constant|THRESHOLD_CHECK
name|THRESHOLD_CHECK
block|}
comment|/**      * A {@link Balancer}      */
DECL|class|Balancer
specifier|public
specifier|static
class|class
name|Balancer
block|{
DECL|field|logger
specifier|private
specifier|final
name|ESLogger
name|logger
decl_stmt|;
DECL|field|nodes
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelNode
argument_list|>
name|nodes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ModelNode
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|indices
specifier|private
specifier|final
name|HashSet
argument_list|<
name|String
argument_list|>
name|indices
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|allocation
specifier|private
specifier|final
name|RoutingAllocation
name|allocation
decl_stmt|;
DECL|field|weight
specifier|private
specifier|final
name|WeightFunction
name|weight
decl_stmt|;
DECL|field|threshold
specifier|private
specifier|final
name|float
name|threshold
decl_stmt|;
DECL|field|metaData
specifier|private
specifier|final
name|MetaData
name|metaData
decl_stmt|;
DECL|field|assignedFilter
specifier|private
specifier|final
name|Predicate
argument_list|<
name|MutableShardRouting
argument_list|>
name|assignedFilter
init|=
operator|new
name|Predicate
argument_list|<
name|MutableShardRouting
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|boolean
name|apply
parameter_list|(
name|MutableShardRouting
name|input
parameter_list|)
block|{
return|return
name|input
operator|.
name|assignedToNode
argument_list|()
return|;
block|}
block|}
decl_stmt|;
DECL|method|Balancer
specifier|public
name|Balancer
parameter_list|(
name|ESLogger
name|logger
parameter_list|,
name|RoutingAllocation
name|allocation
parameter_list|,
name|WeightFunction
name|weight
parameter_list|,
name|float
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|logger
operator|=
name|logger
expr_stmt|;
name|this
operator|.
name|allocation
operator|=
name|allocation
expr_stmt|;
name|this
operator|.
name|weight
operator|=
name|weight
expr_stmt|;
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
for|for
control|(
name|RoutingNode
name|node
range|:
name|allocation
operator|.
name|routingNodes
argument_list|()
control|)
block|{
name|nodes
operator|.
name|put
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|,
operator|new
name|ModelNode
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metaData
operator|=
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|metaData
argument_list|()
expr_stmt|;
block|}
comment|/**          * Returns an array view on the nodes in the balancer. Nodes should not be removed from this list.          */
DECL|method|nodesArray
specifier|private
name|ModelNode
index|[]
name|nodesArray
parameter_list|()
block|{
return|return
name|nodes
operator|.
name|values
argument_list|()
operator|.
name|toArray
argument_list|(
operator|new
name|ModelNode
index|[
name|nodes
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**          * Returns the average of shards per node for the given index          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|(
name|String
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|totalNumberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the global average of shards per node          */
DECL|method|avgShardsPerNode
specifier|public
name|float
name|avgShardsPerNode
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|totalNumberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the global average of primaries per node          */
DECL|method|avgPrimariesPerNode
specifier|public
name|float
name|avgPrimariesPerNode
parameter_list|()
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|numberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns the average of primaries per node for the given index          */
DECL|method|avgPrimariesPerNode
specifier|public
name|float
name|avgPrimariesPerNode
parameter_list|(
name|String
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|float
operator|)
name|metaData
operator|.
name|index
argument_list|(
name|index
argument_list|)
operator|.
name|numberOfShards
argument_list|()
operator|)
operator|/
name|nodes
operator|.
name|size
argument_list|()
return|;
block|}
comment|/**          * Returns a new {@link NodeSorter} that sorts the nodes based on their          * current weight with respect to the index passed to the sorter. The          * returned sorter is not sorted. Use {@link NodeSorter#reset(String)}          * to sort based on an index.          */
DECL|method|newNodeSorter
specifier|private
name|NodeSorter
name|newNodeSorter
parameter_list|()
block|{
specifier|final
name|NodeSorter
name|sorter
init|=
operator|new
name|NodeSorter
argument_list|(
name|nodesArray
argument_list|()
argument_list|,
name|weight
argument_list|,
name|this
argument_list|)
decl_stmt|;
return|return
name|sorter
return|;
block|}
DECL|method|initialize
specifier|private
name|boolean
name|initialize
parameter_list|(
name|RoutingNodes
name|routing
parameter_list|)
block|{
name|Collection
argument_list|<
name|MutableShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<
name|MutableShardRouting
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start distributing Shards"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|IndexRoutingTable
name|index
range|:
name|allocation
operator|.
name|routingTable
argument_list|()
operator|.
name|indicesRouting
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|indices
operator|.
name|add
argument_list|(
name|index
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|IndexShardRoutingTable
name|shard
range|:
name|index
operator|.
name|getShards
argument_list|()
operator|.
name|values
argument_list|()
control|)
block|{
name|shards
operator|.
name|addAll
argument_list|(
name|routing
operator|.
name|shardsRoutingFor
argument_list|(
name|index
operator|.
name|index
argument_list|()
argument_list|,
name|shard
operator|.
name|shardId
argument_list|()
operator|.
name|id
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|buildModelFromAssigned
argument_list|(
name|Iterables
operator|.
name|filter
argument_list|(
name|shards
argument_list|,
name|assignedFilter
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|allocateUnassigned
argument_list|(
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|unassigned
argument_list|()
argument_list|,
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|ignoredUnassigned
argument_list|()
argument_list|)
return|;
block|}
comment|/**          * Balances the nodes on the cluster model according to the weight          * function. The configured threshold is the minimum delta between the          * weight of the maximum node and the minimum node according to the          * {@link WeightFunction}. This weight is calculated per index to          * distribute shards evenly per index. The balancer tries to relocate          * shards only if the delta exceeds the threshold. If the default case          * the threshold is set to<tt>1.0</tt> to enforce gaining relocation          * only, or in other words relocations that move the weight delta closer          * to<tt>0.0</tt>          *          * @return<code>true</code> if the current configuration has been          *         changed, otherwise<code>false</code>          */
DECL|method|balance
specifier|public
name|boolean
name|balance
parameter_list|()
block|{
if|if
condition|(
name|this
operator|.
name|nodes
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|/* with no nodes this is pointless */
return|return
literal|false
return|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start balancing cluster"
argument_list|)
expr_stmt|;
block|}
name|boolean
name|changed
init|=
name|initialize
argument_list|(
name|allocation
operator|.
name|routingNodes
argument_list|()
argument_list|)
decl_stmt|;
name|NodeSorter
name|sorter
init|=
name|newNodeSorter
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodes
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
comment|/* skip if we only have one node */
for|for
control|(
name|String
name|index
range|:
name|buildWeightOrderedIndidces
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|sorter
argument_list|)
control|)
block|{
name|sorter
operator|.
name|reset
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|index
argument_list|)
expr_stmt|;
specifier|final
name|float
index|[]
name|weights
init|=
name|sorter
operator|.
name|weights
decl_stmt|;
specifier|final
name|ModelNode
index|[]
name|modelNodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
name|int
name|lowIdx
init|=
literal|0
decl_stmt|;
name|int
name|highIdx
init|=
name|weights
operator|.
name|length
operator|-
literal|1
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
specifier|final
name|ModelNode
name|minNode
init|=
name|modelNodes
index|[
name|lowIdx
index|]
decl_stmt|;
specifier|final
name|ModelNode
name|maxNode
init|=
name|modelNodes
index|[
name|highIdx
index|]
decl_stmt|;
if|if
condition|(
name|maxNode
operator|.
name|numShards
argument_list|(
name|index
argument_list|)
operator|>
literal|0
condition|)
block|{
name|float
name|delta
init|=
name|weights
index|[
name|highIdx
index|]
operator|-
name|weights
index|[
name|lowIdx
index|]
decl_stmt|;
name|delta
operator|=
name|delta
operator|<=
name|threshold
condition|?
name|delta
else|:
name|sorter
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|THRESHOLD_CHECK
argument_list|,
name|maxNode
argument_list|)
operator|-
name|sorter
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|THRESHOLD_CHECK
argument_list|,
name|minNode
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<=
name|threshold
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|index
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|highIdx
index|]
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|weights
index|[
name|lowIdx
index|]
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
comment|/* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.                              * a relocation must bring us closer to the balance if we only achive the same delta the relocation is useless */
if|if
condition|(
name|tryRelocateShard
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|minNode
argument_list|,
name|maxNode
argument_list|,
name|index
argument_list|,
name|delta
argument_list|)
condition|)
block|{
comment|/*                                  * TODO we could be a bit smarter here, we don't need to fully sort necessarily                                  * we could just find the place to insert linearly but the win might be minor                                  * compared to the added complexity                                  */
name|weights
index|[
name|lowIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|modelNodes
index|[
name|lowIdx
index|]
argument_list|)
expr_stmt|;
name|weights
index|[
name|highIdx
index|]
operator|=
name|sorter
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|BALANCE
argument_list|,
name|modelNodes
index|[
name|highIdx
index|]
argument_list|)
expr_stmt|;
name|sorter
operator|.
name|quickSort
argument_list|(
literal|0
argument_list|,
name|weights
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|=
name|weights
operator|.
name|length
operator|-
literal|1
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|lowIdx
operator|<
name|highIdx
operator|-
literal|1
condition|)
block|{
comment|/* we can't move from any shard from the min node lets move on to the next node                              * and see if the threshold still holds. We either don't have any shard of this                              * index on this node of allocation deciders prevent any relocation.*/
name|lowIdx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowIdx
operator|>
literal|0
condition|)
block|{
comment|/* now we go max to min since obviously we can't move anything to the max node                               * lets pick the next highest */
name|lowIdx
operator|=
literal|0
expr_stmt|;
name|highIdx
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* we are done here, we either can't relocate anymore or we are balanced */
break|break;
block|}
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
comment|/**          * This builds a initial index ordering where the indices are returned          * in most unbalanced first. We need this in order to prevent over          * allocations on added nodes from one index when the weight parameters          * for global balance overrule the index balance at an intermediate          * state. For example this can happen if we have 3 nodes and 3 indices          * with 3 shards and 1 shard. At the first stage all three nodes hold          * 2 shard for each index. now we add another node and the first index          * is balanced moving 3 two of the nodes over to the new node since it          * has no shards yet and global balance for the node is way below          * average. To re-balance we need to move shards back eventually likely          * to the nodes we relocated them from.          */
DECL|method|buildWeightOrderedIndidces
specifier|private
name|String
index|[]
name|buildWeightOrderedIndidces
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|NodeSorter
name|sorter
parameter_list|)
block|{
specifier|final
name|String
index|[]
name|indices
init|=
name|this
operator|.
name|indices
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|this
operator|.
name|indices
operator|.
name|size
argument_list|()
index|]
argument_list|)
decl_stmt|;
specifier|final
name|float
index|[]
name|deltas
init|=
operator|new
name|float
index|[
name|indices
operator|.
name|length
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|deltas
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|sorter
operator|.
name|reset
argument_list|(
name|operation
argument_list|,
name|indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|sorter
operator|.
name|delta
argument_list|()
expr_stmt|;
block|}
operator|new
name|SorterTemplate
argument_list|()
block|{
name|float
name|pivotWeight
decl_stmt|;
annotation|@
name|Override
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|String
name|tmpIdx
init|=
name|indices
index|[
name|i
index|]
decl_stmt|;
name|indices
index|[
name|i
index|]
operator|=
name|indices
index|[
name|j
index|]
expr_stmt|;
name|indices
index|[
name|j
index|]
operator|=
name|tmpIdx
expr_stmt|;
specifier|final
name|float
name|tmpDelta
init|=
name|deltas
index|[
name|i
index|]
decl_stmt|;
name|deltas
index|[
name|i
index|]
operator|=
name|deltas
index|[
name|j
index|]
expr_stmt|;
name|deltas
index|[
name|j
index|]
operator|=
name|tmpDelta
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|deltas
index|[
name|i
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|deltas
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|deltas
index|[
name|j
index|]
argument_list|,
name|pivotWeight
argument_list|)
return|;
block|}
block|}
operator|.
name|quickSort
argument_list|(
literal|0
argument_list|,
name|deltas
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|indices
return|;
block|}
comment|/**          * This function executes a move operation moving the given shard from          * the given node to the minimal eligible node with respect to the          * weight function. Iff the shard is moved the shard will be set to          * {@link ShardRoutingState#RELOCATING} and a shadow instance of this          * shard is created with an incremented version in the state          * {@link ShardRoutingState#INITIALIZING}.          *          * @return<code>true</code> iff the shard has successfully been moved.          */
DECL|method|move
specifier|public
name|boolean
name|move
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|,
name|RoutingNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|nodes
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|shard
operator|.
name|started
argument_list|()
condition|)
block|{
comment|/* with no nodes or a not started shard this is pointless */
return|return
literal|false
return|;
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Try moving shard [{}] from [{}]"
argument_list|,
name|shard
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|boolean
name|changed
init|=
name|initialize
argument_list|(
name|allocation
operator|.
name|routingNodes
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|ModelNode
name|sourceNode
init|=
name|nodes
operator|.
name|get
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|sourceNode
operator|!=
literal|null
assert|;
specifier|final
name|NodeSorter
name|sorter
init|=
name|newNodeSorter
argument_list|()
decl_stmt|;
name|sorter
operator|.
name|reset
argument_list|(
name|Operation
operator|.
name|MOVE
argument_list|,
name|shard
operator|.
name|getIndex
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|ModelNode
index|[]
name|nodes
init|=
name|sorter
operator|.
name|modelNodes
decl_stmt|;
assert|assert
name|sourceNode
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
assert|;
comment|/*              * the sorter holds the minimum weight node first for the shards index.              * We now walk through the nodes until we find a node to allocate the shard.              * This is not guaranteed to be balanced after this operation we still try best effort to               * allocate on the minimal eligable node.              */
for|for
control|(
name|ModelNode
name|currentNode
range|:
name|nodes
control|)
block|{
if|if
condition|(
name|currentNode
operator|.
name|getNodeId
argument_list|()
operator|.
name|equals
argument_list|(
name|node
operator|.
name|nodeId
argument_list|()
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|RoutingNode
name|target
init|=
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|currentNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|Decision
name|decision
init|=
name|allocation
operator|.
name|deciders
argument_list|()
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|target
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
comment|// TODO maybe we can respect throtteling here too?
name|sourceNode
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
specifier|final
name|MutableShardRouting
name|initializingShard
init|=
operator|new
name|MutableShardRouting
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|,
name|shard
operator|.
name|id
argument_list|()
argument_list|,
name|currentNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|,
name|shard
operator|.
name|primary
argument_list|()
argument_list|,
name|INITIALIZING
argument_list|,
name|shard
operator|.
name|version
argument_list|()
operator|+
literal|1
argument_list|)
decl_stmt|;
name|currentNode
operator|.
name|addShard
argument_list|(
name|initializingShard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
name|target
operator|.
name|add
argument_list|(
name|initializingShard
argument_list|)
expr_stmt|;
name|shard
operator|.
name|relocate
argument_list|(
name|target
operator|.
name|nodeId
argument_list|()
argument_list|)
expr_stmt|;
comment|// set the node to relocate after we added the initializing shard
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Moved shard [{}] to node [{}]"
argument_list|,
name|shard
argument_list|,
name|currentNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
return|return
name|changed
return|;
block|}
comment|/**          * Builds the internal model from all shards in the given          * {@link Iterable}. All shards in the {@link Iterable} must be assigned          * to a node. This method will skip shards in the state          * {@link ShardRoutingState#RELOCATING} since each relocating shard has          * a shadow shard in the state {@link ShardRoutingState#INITIALIZING}          * on the target node which we respect during the allocation / balancing          * process. In short, this method recreates the status-quo in the cluster.          */
DECL|method|buildModelFromAssigned
specifier|private
name|void
name|buildModelFromAssigned
parameter_list|(
name|Iterable
argument_list|<
name|MutableShardRouting
argument_list|>
name|shards
parameter_list|)
block|{
for|for
control|(
name|MutableShardRouting
name|shard
range|:
name|shards
control|)
block|{
assert|assert
name|shard
operator|.
name|assignedToNode
argument_list|()
assert|;
comment|/* we skip relocating shards here since we expect an initializing shard with the same id coming in */
if|if
condition|(
name|shard
operator|.
name|state
argument_list|()
operator|==
name|RELOCATING
condition|)
block|{
continue|continue;
block|}
name|ModelNode
name|node
init|=
name|nodes
operator|.
name|get
argument_list|(
name|shard
operator|.
name|currentNodeId
argument_list|()
argument_list|)
decl_stmt|;
assert|assert
name|node
operator|!=
literal|null
assert|;
name|node
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|Decision
operator|.
name|single
argument_list|(
name|Type
operator|.
name|YES
argument_list|,
literal|"Already allocated on node"
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to node [{}]"
argument_list|,
name|shard
argument_list|,
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Allocates all given shards on the minimal eligable node for the shards index          * with respect to the weight function. All given shards must be unassigned.          */
DECL|method|allocateUnassigned
specifier|private
name|boolean
name|allocateUnassigned
parameter_list|(
name|List
argument_list|<
name|MutableShardRouting
argument_list|>
name|unassigned
parameter_list|,
name|List
argument_list|<
name|MutableShardRouting
argument_list|>
name|ignoredUnassigned
parameter_list|)
block|{
assert|assert
operator|!
name|nodes
operator|.
name|isEmpty
argument_list|()
assert|;
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Start allocating unassigned shards"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unassigned
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
name|boolean
name|changed
init|=
literal|false
decl_stmt|;
comment|/*              * TODO: We could be smarter here and group the shards by index and then              * use the sorter to save some iterations.               */
specifier|final
name|RoutingNodes
name|routingNodes
init|=
name|allocation
operator|.
name|routingNodes
argument_list|()
decl_stmt|;
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
specifier|final
name|Set
argument_list|<
name|MutableShardRouting
argument_list|>
name|currentRound
init|=
operator|new
name|TreeSet
argument_list|<
name|MutableShardRouting
argument_list|>
argument_list|(
operator|new
name|Comparator
argument_list|<
name|MutableShardRouting
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|int
name|compare
parameter_list|(
name|MutableShardRouting
name|o1
parameter_list|,
name|MutableShardRouting
name|o2
parameter_list|)
block|{
specifier|final
name|int
name|indexCmp
decl_stmt|;
if|if
condition|(
operator|(
name|indexCmp
operator|=
name|o1
operator|.
name|index
argument_list|()
operator|.
name|compareTo
argument_list|(
name|o2
operator|.
name|index
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|o1
operator|.
name|getId
argument_list|()
operator|-
name|o2
operator|.
name|getId
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
name|o1
operator|.
name|primary
argument_list|()
condition|?
operator|-
literal|1
else|:
name|o2
operator|.
name|primary
argument_list|()
condition|?
literal|1
else|:
literal|0
return|;
block|}
return|return
name|o1
operator|.
name|getId
argument_list|()
operator|-
name|o2
operator|.
name|getId
argument_list|()
return|;
block|}
return|return
name|indexCmp
return|;
block|}
block|}
argument_list|)
decl_stmt|;
do|do
block|{
name|Iterator
argument_list|<
name|MutableShardRouting
argument_list|>
name|iterator
init|=
name|unassigned
operator|.
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
comment|/* we treat every index equally here once chunk a time such that we fill up                      * nodes with all indices at the same time. Only on shard of a shard a time.                 	 * Although there might be a primary and a shard of a shard in the set but                 	 * primaries will be started first.*/
if|if
condition|(
name|currentRound
operator|.
name|add
argument_list|(
name|iterator
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|iterator
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
name|boolean
name|iterationChanged
init|=
literal|false
decl_stmt|;
for|for
control|(
name|MutableShardRouting
name|shard
range|:
name|currentRound
control|)
block|{
assert|assert
operator|!
name|shard
operator|.
name|assignedToNode
argument_list|()
assert|;
comment|/* find an node with minimal weight we can allocate on*/
name|float
name|minWeight
init|=
name|Float
operator|.
name|POSITIVE_INFINITY
decl_stmt|;
name|ModelNode
name|minNode
init|=
literal|null
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
for|for
control|(
name|ModelNode
name|node
range|:
name|nodes
operator|.
name|values
argument_list|()
control|)
block|{
comment|/* 	                     * The shard we add is removed below to simulate the 	                     * addition for weight calculation we use Decision.ALWAYS to 	                     * not violate the not null condition. 	                     */
if|if
condition|(
operator|!
name|node
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
condition|)
block|{
name|node
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|Decision
operator|.
name|ALWAYS
argument_list|)
expr_stmt|;
name|float
name|currentWeight
init|=
name|weight
operator|.
name|weight
argument_list|(
name|Operation
operator|.
name|ALLOCATE
argument_list|,
name|this
argument_list|,
name|node
argument_list|,
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
comment|/* 	                         * Remove the shard from the node again this is only a 	                         * simulation 	                         */
name|Decision
name|removed
init|=
name|node
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
decl_stmt|;
assert|assert
name|removed
operator|!=
literal|null
assert|;
comment|/* 	                         * Unless the operation is not providing any gains we 	                         * don't check deciders 	                         */
if|if
condition|(
name|currentWeight
operator|<=
name|minWeight
condition|)
block|{
name|Decision
name|currentDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|routingNodes
operator|.
name|node
argument_list|(
name|node
operator|.
name|getNodeId
argument_list|()
argument_list|)
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|NOUPDATE
label|:
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|||
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
condition|)
block|{
if|if
condition|(
name|currentWeight
operator|==
name|minWeight
condition|)
block|{
comment|/*  we have an equal weight tie breaking: 	                                     *  1. if one decision is YES prefer it 	                                     *  2. prefer the node that holds the primary for this index with the next id in the ring ie. 	                                     *  for the 3 shards 2 replica case we try to build up: 	                                     *    1 2 0 	                                     *    2 0 1 	                                     *    0 1 2 	                                     *  such that if we need to tie-break we try to prefer the node holding a shard with the minimal id greater 	                                     *  than the id of the shard we need to assign. This works find when new indices are created since  	                                     *  primaries are added first and we only add one shard set a time in this algorithm. 	                                     */
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|==
name|decision
operator|.
name|type
argument_list|()
condition|)
block|{
specifier|final
name|int
name|repId
init|=
name|shard
operator|.
name|id
argument_list|()
decl_stmt|;
specifier|final
name|int
name|nodeHigh
init|=
name|node
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|int
name|minNodeHigh
init|=
name|minNode
operator|.
name|highestPrimary
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|>
name|repId
operator|)
operator|||
operator|(
name|nodeHigh
operator|<
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
operator|)
operator|&&
operator|(
name|nodeHigh
operator|<
name|minNodeHigh
operator|)
operator|)
operator|||
operator|(
name|nodeHigh
operator|>
name|minNodeHigh
operator|&&
name|nodeHigh
operator|>
name|repId
operator|&&
name|minNodeHigh
operator|<
name|repId
operator|)
condition|)
block|{
name|minNode
operator|=
name|node
expr_stmt|;
name|minWeight
operator|=
name|currentWeight
expr_stmt|;
name|decision
operator|=
name|currentDecision
expr_stmt|;
block|}
else|else
block|{
break|break
name|NOUPDATE
break|;
block|}
block|}
elseif|else
if|if
condition|(
name|currentDecision
operator|.
name|type
argument_list|()
operator|!=
name|Type
operator|.
name|YES
condition|)
block|{
break|break
name|NOUPDATE
break|;
block|}
block|}
name|minNode
operator|=
name|node
expr_stmt|;
name|minWeight
operator|=
name|currentWeight
expr_stmt|;
name|decision
operator|=
name|currentDecision
expr_stmt|;
block|}
block|}
block|}
block|}
assert|assert
name|decision
operator|!=
literal|null
operator|&&
name|minNode
operator|!=
literal|null
operator|||
name|decision
operator|==
literal|null
operator|&&
name|minNode
operator|==
literal|null
assert|;
if|if
condition|(
name|minNode
operator|!=
literal|null
condition|)
block|{
name|iterationChanged
operator|=
literal|true
expr_stmt|;
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Assigned shard [{}] to [{}]"
argument_list|,
name|shard
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|routingNodes
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|true
expr_stmt|;
continue|continue;
comment|// don't add to ignoreUnassigned
block|}
block|}
elseif|else
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"No Node found to assign shard [{}]"
argument_list|,
name|shard
argument_list|)
expr_stmt|;
block|}
name|ignoredUnassigned
operator|.
name|add
argument_list|(
name|shard
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iterationChanged
operator|&&
operator|!
name|unassigned
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|ignoredUnassigned
operator|.
name|addAll
argument_list|(
name|unassigned
argument_list|)
expr_stmt|;
name|unassigned
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
name|currentRound
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|unassigned
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
comment|// clear everything we have either added it or moved to ingoreUnassigned
return|return
name|changed
return|;
block|}
comment|/**          * Tries to find a relocation from the max node to the minimal node for an arbitrary shard of the given index on the          * balance model. Iff this method returns a<code>true</code> the relocation has already been executed on the          * simulation model as well as on the cluster.          */
DECL|method|tryRelocateShard
specifier|private
name|boolean
name|tryRelocateShard
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|ModelNode
name|minNode
parameter_list|,
name|ModelNode
name|maxNode
parameter_list|,
name|String
name|idx
parameter_list|,
name|float
name|minCost
parameter_list|)
block|{
specifier|final
name|ModelIndex
name|index
init|=
name|maxNode
operator|.
name|getIndex
argument_list|(
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Try relocating shard for index index [{}] from node [{}] to node [{}]"
argument_list|,
name|idx
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|final
name|RoutingNode
name|node
init|=
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|MutableShardRouting
name|candidate
init|=
literal|null
decl_stmt|;
name|Decision
name|decision
init|=
literal|null
decl_stmt|;
specifier|final
name|AllocationDeciders
name|deciders
init|=
name|allocation
operator|.
name|deciders
argument_list|()
decl_stmt|;
comment|/* make a copy since we modify this list in the loop */
specifier|final
name|ArrayList
argument_list|<
name|MutableShardRouting
argument_list|>
name|shards
init|=
operator|new
name|ArrayList
argument_list|<
name|MutableShardRouting
argument_list|>
argument_list|(
name|index
operator|.
name|getAllShards
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|MutableShardRouting
name|shard
range|:
name|shards
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|started
argument_list|()
condition|)
block|{
comment|// skip initializing, unassigned and relocating shards we can't relocate them anyway
name|Decision
name|allocationDecision
init|=
name|deciders
operator|.
name|canAllocate
argument_list|(
name|shard
argument_list|,
name|node
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
name|Decision
name|rebalanceDecission
init|=
name|deciders
operator|.
name|canRebalance
argument_list|(
name|shard
argument_list|,
name|allocation
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|allocationDecision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|rebalanceDecission
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
operator|)
operator|||
operator|(
name|rebalanceDecission
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|THROTTLE
operator|)
operator|)
condition|)
block|{
name|Decision
name|srcDecision
decl_stmt|;
if|if
condition|(
operator|(
name|srcDecision
operator|=
name|maxNode
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|minNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|srcDecision
argument_list|)
expr_stmt|;
specifier|final
name|float
name|delta
init|=
name|weight
operator|.
name|weight
argument_list|(
name|operation
argument_list|,
name|this
argument_list|,
name|minNode
argument_list|,
name|idx
argument_list|)
operator|-
name|weight
operator|.
name|weight
argument_list|(
name|operation
argument_list|,
name|this
argument_list|,
name|maxNode
argument_list|,
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|<
name|minCost
condition|)
block|{
name|minCost
operator|=
name|delta
expr_stmt|;
name|candidate
operator|=
name|shard
expr_stmt|;
name|decision
operator|=
operator|new
name|Decision
operator|.
name|Multi
argument_list|()
operator|.
name|add
argument_list|(
name|allocationDecision
argument_list|)
operator|.
name|add
argument_list|(
name|rebalanceDecission
argument_list|)
expr_stmt|;
block|}
name|minNode
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
name|maxNode
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|srcDecision
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|candidate
operator|!=
literal|null
condition|)
block|{
comment|/* allocate on the model even if not throttled */
name|maxNode
operator|.
name|removeShard
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
name|minNode
operator|.
name|addShard
argument_list|(
name|candidate
argument_list|,
name|decision
argument_list|)
expr_stmt|;
if|if
condition|(
name|decision
operator|.
name|type
argument_list|()
operator|==
name|Type
operator|.
name|YES
condition|)
block|{
comment|/* only allocate on the cluster if we are not throttled */
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Relocate shard [{}] from node [{}] to node [{}]"
argument_list|,
name|candidate
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* now allocate on the cluster - if we are started we need to relocate the shard */
if|if
condition|(
name|candidate
operator|.
name|started
argument_list|()
condition|)
block|{
name|RoutingNode
name|lowRoutingNode
init|=
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
decl_stmt|;
name|lowRoutingNode
operator|.
name|add
argument_list|(
operator|new
name|MutableShardRouting
argument_list|(
name|candidate
operator|.
name|index
argument_list|()
argument_list|,
name|candidate
operator|.
name|id
argument_list|()
argument_list|,
name|lowRoutingNode
operator|.
name|nodeId
argument_list|()
argument_list|,
name|candidate
operator|.
name|currentNodeId
argument_list|()
argument_list|,
name|candidate
operator|.
name|primary
argument_list|()
argument_list|,
name|INITIALIZING
argument_list|,
name|candidate
operator|.
name|version
argument_list|()
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|candidate
operator|.
name|relocate
argument_list|(
name|lowRoutingNode
operator|.
name|nodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
assert|assert
name|candidate
operator|.
name|unassigned
argument_list|()
assert|;
name|allocation
operator|.
name|routingNodes
argument_list|()
operator|.
name|node
argument_list|(
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
operator|.
name|add
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
block|}
block|}
if|if
condition|(
name|logger
operator|.
name|isTraceEnabled
argument_list|()
condition|)
block|{
name|logger
operator|.
name|trace
argument_list|(
literal|"Couldn't find shard to relocate from node [{}] to node [{}]"
argument_list|,
name|maxNode
operator|.
name|getNodeId
argument_list|()
argument_list|,
name|minNode
operator|.
name|getNodeId
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
DECL|class|ModelNode
specifier|static
class|class
name|ModelNode
implements|implements
name|Iterable
argument_list|<
name|ModelIndex
argument_list|>
block|{
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|field|indices
specifier|private
specifier|final
name|Map
argument_list|<
name|String
argument_list|,
name|ModelIndex
argument_list|>
name|indices
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|ModelIndex
argument_list|>
argument_list|()
decl_stmt|;
comment|/* cached stats - invalidated on add/remove and lazily calculated */
DECL|field|numShards
specifier|private
name|int
name|numShards
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|numPrimaries
specifier|private
name|int
name|numPrimaries
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|ModelNode
specifier|public
name|ModelNode
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|method|getIndex
specifier|public
name|ModelIndex
name|getIndex
parameter_list|(
name|String
name|indexId
parameter_list|)
block|{
return|return
name|indices
operator|.
name|get
argument_list|(
name|indexId
argument_list|)
return|;
block|}
DECL|method|getNodeId
specifier|public
name|String
name|getNodeId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
if|if
condition|(
name|numShards
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ModelIndex
name|index
range|:
name|indices
operator|.
name|values
argument_list|()
control|)
block|{
name|sum
operator|+=
name|index
operator|.
name|numShards
argument_list|()
expr_stmt|;
block|}
name|numShards
operator|=
name|sum
expr_stmt|;
block|}
return|return
name|numShards
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|(
name|String
name|idx
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|0
else|:
name|index
operator|.
name|numShards
argument_list|()
return|;
block|}
DECL|method|numPrimaries
specifier|public
name|int
name|numPrimaries
parameter_list|(
name|String
name|idx
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|idx
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|0
else|:
name|index
operator|.
name|numPrimaries
argument_list|()
return|;
block|}
DECL|method|numPrimaries
specifier|public
name|int
name|numPrimaries
parameter_list|()
block|{
if|if
condition|(
name|numPrimaries
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ModelIndex
name|index
range|:
name|indices
operator|.
name|values
argument_list|()
control|)
block|{
name|sum
operator|+=
name|index
operator|.
name|numPrimaries
argument_list|()
expr_stmt|;
block|}
name|numPrimaries
operator|=
name|sum
expr_stmt|;
block|}
return|return
name|numPrimaries
return|;
block|}
DECL|method|shards
specifier|public
name|Collection
argument_list|<
name|MutableShardRouting
argument_list|>
name|shards
parameter_list|()
block|{
name|Collection
argument_list|<
name|MutableShardRouting
argument_list|>
name|result
init|=
operator|new
name|ArrayList
argument_list|<
name|MutableShardRouting
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|ModelIndex
name|index
range|:
name|indices
operator|.
name|values
argument_list|()
control|)
block|{
name|result
operator|.
name|addAll
argument_list|(
name|index
operator|.
name|getAllShards
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|(
name|String
name|index
parameter_list|)
block|{
name|ModelIndex
name|idx
init|=
name|indices
operator|.
name|get
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|idx
operator|!=
literal|null
condition|)
block|{
return|return
name|idx
operator|.
name|highestPrimary
argument_list|()
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|,
name|Decision
name|decision
parameter_list|)
block|{
name|numPrimaries
operator|=
name|numShards
operator|=
operator|-
literal|1
expr_stmt|;
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|null
condition|)
block|{
name|index
operator|=
operator|new
name|ModelIndex
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
name|indices
operator|.
name|put
argument_list|(
name|index
operator|.
name|getIndexId
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|index
operator|.
name|addShard
argument_list|(
name|shard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
block|}
DECL|method|removeShard
specifier|public
name|Decision
name|removeShard
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|)
block|{
name|numPrimaries
operator|=
name|numShards
operator|=
operator|-
literal|1
expr_stmt|;
name|ModelIndex
name|index
init|=
name|indices
operator|.
name|get
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
decl_stmt|;
name|Decision
name|removed
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|index
operator|!=
literal|null
condition|)
block|{
name|removed
operator|=
name|index
operator|.
name|removeShard
argument_list|(
name|shard
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed
operator|!=
literal|null
operator|&&
name|index
operator|.
name|numShards
argument_list|()
operator|==
literal|0
condition|)
block|{
name|indices
operator|.
name|remove
argument_list|(
name|shard
operator|.
name|index
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|removed
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"Node("
argument_list|)
operator|.
name|append
argument_list|(
name|id
argument_list|)
operator|.
name|append
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
return|return
name|sb
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|ModelIndex
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
name|indices
operator|.
name|values
argument_list|()
operator|.
name|iterator
argument_list|()
return|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|)
block|{
name|ModelIndex
name|index
init|=
name|getIndex
argument_list|(
name|shard
operator|.
name|getIndex
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|index
operator|==
literal|null
condition|?
literal|false
else|:
name|index
operator|.
name|containsShard
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|ModelIndex
specifier|static
specifier|final
class|class
name|ModelIndex
block|{
DECL|field|id
specifier|private
specifier|final
name|String
name|id
decl_stmt|;
DECL|field|shards
specifier|private
specifier|final
name|Map
argument_list|<
name|MutableShardRouting
argument_list|,
name|Decision
argument_list|>
name|shards
init|=
operator|new
name|HashMap
argument_list|<
name|MutableShardRouting
argument_list|,
name|Decision
argument_list|>
argument_list|()
decl_stmt|;
DECL|field|numPrimaries
specifier|private
name|int
name|numPrimaries
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|highestPrimary
specifier|private
name|int
name|highestPrimary
init|=
operator|-
literal|1
decl_stmt|;
DECL|method|ModelIndex
specifier|public
name|ModelIndex
parameter_list|(
name|String
name|id
parameter_list|)
block|{
name|this
operator|.
name|id
operator|=
name|id
expr_stmt|;
block|}
DECL|method|highestPrimary
specifier|public
name|int
name|highestPrimary
parameter_list|()
block|{
if|if
condition|(
name|highestPrimary
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|maxId
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|MutableShardRouting
name|shard
range|:
name|shards
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|maxId
operator|=
name|Math
operator|.
name|max
argument_list|(
name|maxId
argument_list|,
name|shard
operator|.
name|id
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|highestPrimary
operator|=
name|maxId
return|;
block|}
return|return
name|highestPrimary
return|;
block|}
DECL|method|getIndexId
specifier|public
name|String
name|getIndexId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
DECL|method|getDecicion
specifier|public
name|Decision
name|getDecicion
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|)
block|{
return|return
name|shards
operator|.
name|get
argument_list|(
name|shard
argument_list|)
return|;
block|}
DECL|method|numShards
specifier|public
name|int
name|numShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|getAllShards
specifier|public
name|Collection
argument_list|<
name|MutableShardRouting
argument_list|>
name|getAllShards
parameter_list|()
block|{
return|return
name|shards
operator|.
name|keySet
argument_list|()
return|;
block|}
DECL|method|numPrimaries
specifier|public
name|int
name|numPrimaries
parameter_list|()
block|{
if|if
condition|(
name|numPrimaries
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|num
init|=
literal|0
decl_stmt|;
for|for
control|(
name|MutableShardRouting
name|shard
range|:
name|shards
operator|.
name|keySet
argument_list|()
control|)
block|{
if|if
condition|(
name|shard
operator|.
name|primary
argument_list|()
condition|)
block|{
name|num
operator|++
expr_stmt|;
block|}
block|}
return|return
name|numPrimaries
operator|=
name|num
return|;
block|}
return|return
name|numPrimaries
return|;
block|}
DECL|method|removeShard
specifier|public
name|Decision
name|removeShard
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|)
block|{
name|highestPrimary
operator|=
name|numPrimaries
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|shards
operator|.
name|remove
argument_list|(
name|shard
argument_list|)
return|;
block|}
DECL|method|addShard
specifier|public
name|void
name|addShard
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|,
name|Decision
name|decision
parameter_list|)
block|{
name|highestPrimary
operator|=
name|numPrimaries
operator|=
operator|-
literal|1
expr_stmt|;
assert|assert
name|decision
operator|!=
literal|null
assert|;
assert|assert
operator|!
name|shards
operator|.
name|containsKey
argument_list|(
name|shard
argument_list|)
operator|:
literal|"Shard already allocated on current node: "
operator|+
name|shards
operator|.
name|get
argument_list|(
name|shard
argument_list|)
operator|+
literal|" "
operator|+
name|shard
assert|;
name|shards
operator|.
name|put
argument_list|(
name|shard
argument_list|,
name|decision
argument_list|)
expr_stmt|;
block|}
DECL|method|containsShard
specifier|public
name|boolean
name|containsShard
parameter_list|(
name|MutableShardRouting
name|shard
parameter_list|)
block|{
return|return
name|shards
operator|.
name|containsKey
argument_list|(
name|shard
argument_list|)
return|;
block|}
block|}
DECL|class|NodeSorter
specifier|static
specifier|final
class|class
name|NodeSorter
extends|extends
name|SorterTemplate
block|{
DECL|field|modelNodes
specifier|final
name|ModelNode
index|[]
name|modelNodes
decl_stmt|;
comment|/* the nodes weights with respect to the current weight function / index */
DECL|field|weights
specifier|final
name|float
index|[]
name|weights
decl_stmt|;
DECL|field|function
specifier|private
specifier|final
name|WeightFunction
name|function
decl_stmt|;
DECL|field|index
specifier|private
name|String
name|index
decl_stmt|;
DECL|field|balancer
specifier|private
specifier|final
name|Balancer
name|balancer
decl_stmt|;
DECL|field|pivotWeight
specifier|private
name|float
name|pivotWeight
decl_stmt|;
DECL|method|NodeSorter
specifier|public
name|NodeSorter
parameter_list|(
name|ModelNode
index|[]
name|modelNodes
parameter_list|,
name|WeightFunction
name|function
parameter_list|,
name|Balancer
name|balancer
parameter_list|)
block|{
name|this
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|this
operator|.
name|balancer
operator|=
name|balancer
expr_stmt|;
name|this
operator|.
name|modelNodes
operator|=
name|modelNodes
expr_stmt|;
name|weights
operator|=
operator|new
name|float
index|[
name|modelNodes
operator|.
name|length
index|]
expr_stmt|;
block|}
comment|/**          * Resets the sorter, recalculates the weights per node and sorts the          * nodes by weight, with minimal weight first.          */
DECL|method|reset
specifier|public
name|void
name|reset
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|String
name|index
parameter_list|)
block|{
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|weights
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|weights
index|[
name|i
index|]
operator|=
name|weight
argument_list|(
name|operation
argument_list|,
name|modelNodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|quickSort
argument_list|(
literal|0
argument_list|,
name|modelNodes
operator|.
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|weight
specifier|public
name|float
name|weight
parameter_list|(
name|Operation
name|operation
parameter_list|,
name|ModelNode
name|node
parameter_list|)
block|{
return|return
name|function
operator|.
name|weight
argument_list|(
name|operation
argument_list|,
name|balancer
argument_list|,
name|node
argument_list|,
name|index
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|swap
specifier|protected
name|void
name|swap
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
specifier|final
name|ModelNode
name|tmpNode
init|=
name|modelNodes
index|[
name|i
index|]
decl_stmt|;
name|modelNodes
index|[
name|i
index|]
operator|=
name|modelNodes
index|[
name|j
index|]
expr_stmt|;
name|modelNodes
index|[
name|j
index|]
operator|=
name|tmpNode
expr_stmt|;
specifier|final
name|float
name|tmpWeight
init|=
name|weights
index|[
name|i
index|]
decl_stmt|;
name|weights
index|[
name|i
index|]
operator|=
name|weights
index|[
name|j
index|]
expr_stmt|;
name|weights
index|[
name|j
index|]
operator|=
name|tmpWeight
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|compare
specifier|protected
name|int
name|compare
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|weights
index|[
name|i
index|]
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|setPivot
specifier|protected
name|void
name|setPivot
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|pivotWeight
operator|=
name|weights
index|[
name|i
index|]
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|comparePivot
specifier|protected
name|int
name|comparePivot
parameter_list|(
name|int
name|j
parameter_list|)
block|{
return|return
name|Float
operator|.
name|compare
argument_list|(
name|pivotWeight
argument_list|,
name|weights
index|[
name|j
index|]
argument_list|)
return|;
block|}
DECL|method|delta
specifier|public
name|float
name|delta
parameter_list|()
block|{
return|return
name|weights
index|[
name|weights
operator|.
name|length
operator|-
literal|1
index|]
operator|-
name|weights
index|[
literal|0
index|]
return|;
block|}
block|}
block|}
end_class

end_unit

