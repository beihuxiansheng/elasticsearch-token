begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.elasticsearch.common.lucene.search
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|search
package|;
end_package

begin_comment
comment|/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */
end_comment

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|AtomicReaderContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|IndexReader
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|index
operator|.
name|Term
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|*
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|FilteredQuery
operator|.
name|FilterStrategy
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|util
operator|.
name|Bits
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|docset
operator|.
name|DocIdSets
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_comment
comment|/**  * A query that applies a filter to the results of another query.  *<p/>  *<p>Note: the bits are retrieved from the filter each time this  * query is used in a search - use a CachingWrapperFilter to avoid  * regenerating the bits every time.  *  * @see CachingWrapperFilter  * @since 1.4  */
end_comment

begin_comment
comment|// Changes are marked with //CHANGE:
end_comment

begin_comment
comment|// Delegate to FilteredQuery - this version fixes the bug in LUCENE-4705 and uses ApplyAcceptedDocsFilter internally
end_comment

begin_class
DECL|class|XFilteredQuery
specifier|public
class|class
name|XFilteredQuery
extends|extends
name|Query
block|{
DECL|field|rawFilter
specifier|private
specifier|final
name|Filter
name|rawFilter
decl_stmt|;
DECL|field|delegate
specifier|private
specifier|final
name|FilteredQuery
name|delegate
decl_stmt|;
DECL|field|strategy
specifier|private
specifier|final
name|FilterStrategy
name|strategy
decl_stmt|;
comment|/**      * Constructs a new query which applies a filter to the results of the original query.      * {@link Filter#getDocIdSet} will be called every time this query is used in a search.      *      * @param query  Query to be filtered, cannot be<code>null</code>.      * @param filter Filter to apply to query results, cannot be<code>null</code>.      */
DECL|method|XFilteredQuery
specifier|public
name|XFilteredQuery
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|)
block|{
name|this
argument_list|(
name|query
argument_list|,
name|filter
argument_list|,
name|FilteredQuery
operator|.
name|RANDOM_ACCESS_FILTER_STRATEGY
argument_list|)
expr_stmt|;
block|}
comment|/**      * Expert: Constructs a new query which applies a filter to the results of the original query.      * {@link Filter#getDocIdSet} will be called every time this query is used in a search.      *      * @param query    Query to be filtered, cannot be<code>null</code>.      * @param filter   Filter to apply to query results, cannot be<code>null</code>.      * @param strategy a filter strategy used to create a filtered scorer.      * @see FilterStrategy      */
DECL|method|XFilteredQuery
specifier|public
name|XFilteredQuery
parameter_list|(
name|Query
name|query
parameter_list|,
name|Filter
name|filter
parameter_list|,
name|FilterStrategy
name|strategy
parameter_list|)
block|{
name|delegate
operator|=
operator|new
name|FilteredQuery
argument_list|(
name|query
argument_list|,
operator|new
name|ApplyAcceptedDocsFilter
argument_list|(
name|filter
argument_list|)
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
comment|// CHANGE: we need to wrap it in post application of accepted docs
name|this
operator|.
name|rawFilter
operator|=
name|filter
expr_stmt|;
name|this
operator|.
name|strategy
operator|=
name|strategy
expr_stmt|;
block|}
comment|/**      * Returns a Weight that applies the filter to the enclosed query's Weight.      * This is accomplished by overriding the Scorer returned by the Weight.      */
annotation|@
name|Override
DECL|method|createWeight
specifier|public
name|Weight
name|createWeight
parameter_list|(
specifier|final
name|IndexSearcher
name|searcher
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|delegate
operator|.
name|createWeight
argument_list|(
name|searcher
argument_list|)
return|;
block|}
comment|/**      * Rewrites the query. If the wrapped is an instance of      * {@link MatchAllDocsQuery} it returns a {@link ConstantScoreQuery}. Otherwise      * it returns a new {@code FilteredQuery} wrapping the rewritten query.      */
annotation|@
name|Override
DECL|method|rewrite
specifier|public
name|Query
name|rewrite
parameter_list|(
name|IndexReader
name|reader
parameter_list|)
throws|throws
name|IOException
block|{
name|Query
name|query
init|=
name|delegate
operator|.
name|getQuery
argument_list|()
decl_stmt|;
specifier|final
name|Query
name|queryRewritten
init|=
name|query
operator|.
name|rewrite
argument_list|(
name|reader
argument_list|)
decl_stmt|;
comment|// CHANGE: if we push back to Lucene, would love to have an extension for "isMatchAllQuery"
if|if
condition|(
name|queryRewritten
operator|instanceof
name|MatchAllDocsQuery
operator|||
name|Queries
operator|.
name|isConstantMatchAllQuery
argument_list|(
name|queryRewritten
argument_list|)
condition|)
block|{
comment|// Special case: If the query is a MatchAllDocsQuery, we only
comment|// return a CSQ(filter).
specifier|final
name|Query
name|rewritten
init|=
operator|new
name|ConstantScoreQuery
argument_list|(
name|delegate
operator|.
name|getFilter
argument_list|()
argument_list|)
decl_stmt|;
comment|// Combine boost of MatchAllDocsQuery and the wrapped rewritten query:
name|rewritten
operator|.
name|setBoost
argument_list|(
name|delegate
operator|.
name|getBoost
argument_list|()
operator|*
name|queryRewritten
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rewritten
return|;
block|}
if|if
condition|(
name|queryRewritten
operator|!=
name|query
condition|)
block|{
comment|// rewrite to a new FilteredQuery wrapping the rewritten query
specifier|final
name|Query
name|rewritten
init|=
operator|new
name|XFilteredQuery
argument_list|(
name|queryRewritten
argument_list|,
name|rawFilter
argument_list|,
name|strategy
argument_list|)
decl_stmt|;
name|rewritten
operator|.
name|setBoost
argument_list|(
name|delegate
operator|.
name|getBoost
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|rewritten
return|;
block|}
else|else
block|{
comment|// nothing to rewrite, we are done!
return|return
name|this
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|setBoost
specifier|public
name|void
name|setBoost
parameter_list|(
name|float
name|b
parameter_list|)
block|{
name|delegate
operator|.
name|setBoost
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|getBoost
specifier|public
name|float
name|getBoost
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|getBoost
argument_list|()
return|;
block|}
comment|/**      * Returns this FilteredQuery's (unfiltered) Query      */
DECL|method|getQuery
specifier|public
specifier|final
name|Query
name|getQuery
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|getQuery
argument_list|()
return|;
block|}
comment|/**      * Returns this FilteredQuery's filter      */
DECL|method|getFilter
specifier|public
specifier|final
name|Filter
name|getFilter
parameter_list|()
block|{
comment|// CHANGE: unwrap the accepted docs filter
if|if
condition|(
name|rawFilter
operator|instanceof
name|ApplyAcceptedDocsFilter
condition|)
block|{
return|return
operator|(
operator|(
name|ApplyAcceptedDocsFilter
operator|)
name|rawFilter
operator|)
operator|.
name|filter
argument_list|()
return|;
block|}
return|return
name|rawFilter
return|;
block|}
comment|// inherit javadoc
annotation|@
name|Override
DECL|method|extractTerms
specifier|public
name|void
name|extractTerms
parameter_list|(
name|Set
argument_list|<
name|Term
argument_list|>
name|terms
parameter_list|)
block|{
name|delegate
operator|.
name|extractTerms
argument_list|(
name|terms
argument_list|)
expr_stmt|;
block|}
comment|/**      * Prints a user-readable version of this query.      */
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|(
name|String
name|s
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|toString
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|/**      * Returns true iff<code>o</code> is equal to this.      */
annotation|@
name|Override
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|delegate
operator|.
name|equals
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|/**      * Returns a hash code value for this object.      */
annotation|@
name|Override
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|delegate
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|// CHANGE: Add custom random access strategy, allowing to set the threshold
comment|// CHANGE: Add filter first filter strategy
DECL|field|ALWAYS_RANDOM_ACCESS_FILTER_STRATEGY
specifier|public
specifier|static
specifier|final
name|FilterStrategy
name|ALWAYS_RANDOM_ACCESS_FILTER_STRATEGY
init|=
operator|new
name|CustomRandomAccessFilterStrategy
argument_list|(
literal|0
argument_list|)
decl_stmt|;
DECL|field|CUSTOM_FILTER_STRATEGY
specifier|public
specifier|static
specifier|final
name|CustomRandomAccessFilterStrategy
name|CUSTOM_FILTER_STRATEGY
init|=
operator|new
name|CustomRandomAccessFilterStrategy
argument_list|()
decl_stmt|;
comment|/**      * Extends {@link org.apache.lucene.search.FilteredQuery.RandomAccessFilterStrategy}.      *<p/>      * Adds a threshold value, which defaults to -1. When set to -1, it will check if the filter docSet is      * *not*  a fast docSet, and if not, it will use {@link FilteredQuery#QUERY_FIRST_FILTER_STRATEGY} (since      * the assumption is that its a "slow" filter and better computed only on whatever matched the query).      *<p/>      * If the threshold value is 0, it always tries to pass "down" the filter as acceptDocs, and it the filter      * can't be represented as Bits (never really), then it uses {@link FilteredQuery#LEAP_FROG_QUERY_FIRST_STRATEGY}.      *<p/>      * If the above conditions are not met, then it reverts to the {@link FilteredQuery.RandomAccessFilterStrategy} logic,      * with the threshold used to control {@link #useRandomAccess(org.apache.lucene.util.Bits, int)}.      */
DECL|class|CustomRandomAccessFilterStrategy
specifier|public
specifier|static
class|class
name|CustomRandomAccessFilterStrategy
extends|extends
name|FilteredQuery
operator|.
name|RandomAccessFilterStrategy
block|{
DECL|field|threshold
specifier|private
specifier|final
name|int
name|threshold
decl_stmt|;
DECL|method|CustomRandomAccessFilterStrategy
specifier|public
name|CustomRandomAccessFilterStrategy
parameter_list|()
block|{
name|this
operator|.
name|threshold
operator|=
operator|-
literal|1
expr_stmt|;
block|}
DECL|method|CustomRandomAccessFilterStrategy
specifier|public
name|CustomRandomAccessFilterStrategy
parameter_list|(
name|int
name|threshold
parameter_list|)
block|{
name|this
operator|.
name|threshold
operator|=
name|threshold
expr_stmt|;
block|}
annotation|@
name|Override
DECL|method|filteredScorer
specifier|public
name|Scorer
name|filteredScorer
parameter_list|(
name|AtomicReaderContext
name|context
parameter_list|,
name|boolean
name|scoreDocsInOrder
parameter_list|,
name|boolean
name|topScorer
parameter_list|,
name|Weight
name|weight
parameter_list|,
name|DocIdSet
name|docIdSet
parameter_list|)
throws|throws
name|IOException
block|{
comment|// CHANGE: If threshold is 0, always pass down the accept docs, don't pay the price of calling nextDoc even...
if|if
condition|(
name|threshold
operator|==
literal|0
condition|)
block|{
specifier|final
name|Bits
name|filterAcceptDocs
init|=
name|docIdSet
operator|.
name|bits
argument_list|()
decl_stmt|;
if|if
condition|(
name|filterAcceptDocs
operator|!=
literal|null
condition|)
block|{
return|return
name|weight
operator|.
name|scorer
argument_list|(
name|context
argument_list|,
name|scoreDocsInOrder
argument_list|,
name|topScorer
argument_list|,
name|filterAcceptDocs
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|FilteredQuery
operator|.
name|LEAP_FROG_QUERY_FIRST_STRATEGY
operator|.
name|filteredScorer
argument_list|(
name|context
argument_list|,
name|scoreDocsInOrder
argument_list|,
name|topScorer
argument_list|,
name|weight
argument_list|,
name|docIdSet
argument_list|)
return|;
block|}
block|}
comment|// CHANGE: handle "default" value
if|if
condition|(
name|threshold
operator|==
operator|-
literal|1
condition|)
block|{
comment|// default  value, don't iterate on only apply filter after query if its not a "fast" docIdSet
if|if
condition|(
operator|!
name|DocIdSets
operator|.
name|isFastIterator
argument_list|(
name|docIdSet
argument_list|)
condition|)
block|{
return|return
name|FilteredQuery
operator|.
name|QUERY_FIRST_FILTER_STRATEGY
operator|.
name|filteredScorer
argument_list|(
name|context
argument_list|,
name|scoreDocsInOrder
argument_list|,
name|topScorer
argument_list|,
name|weight
argument_list|,
name|docIdSet
argument_list|)
return|;
block|}
block|}
return|return
name|super
operator|.
name|filteredScorer
argument_list|(
name|context
argument_list|,
name|scoreDocsInOrder
argument_list|,
name|topScorer
argument_list|,
name|weight
argument_list|,
name|docIdSet
argument_list|)
return|;
block|}
comment|/**          * Expert: decides if a filter should be executed as "random-access" or not.          * random-access means the filter "filters" in a similar way as deleted docs are filtered          * in Lucene. This is faster when the filter accepts many documents.          * However, when the filter is very sparse, it can be faster to execute the query+filter          * as a conjunction in some cases.          *<p/>          * The default implementation returns<code>true</code> if the first document accepted by the          * filter is< threshold, if threshold is -1 (the default), then it checks for< 100.          */
DECL|method|useRandomAccess
specifier|protected
name|boolean
name|useRandomAccess
parameter_list|(
name|Bits
name|bits
parameter_list|,
name|int
name|firstFilterDoc
parameter_list|)
block|{
comment|// "default"
if|if
condition|(
name|threshold
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|firstFilterDoc
operator|<
literal|100
return|;
block|}
comment|//TODO once we have a cost API on filters and scorers we should rethink this heuristic
return|return
name|firstFilterDoc
operator|<
name|threshold
return|;
block|}
block|}
block|}
end_class

end_unit

