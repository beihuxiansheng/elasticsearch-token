begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.elasticsearch.common.lucene.spatial
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|spatial
package|;
end_package

begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|SpatialContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Point
import|;
end_import

begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Rectangle
import|;
end_import

begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|document
operator|.
name|Field
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|lucene
operator|.
name|search
operator|.
name|Query
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|GeoShapeConstants
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|ShapeRelation
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|NodeTokenStream
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
operator|.
name|Node
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|lucene
operator|.
name|spatial
operator|.
name|prefix
operator|.
name|tree
operator|.
name|SpatialPrefixTree
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|FieldMapper
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_comment
comment|/**  * Abstraction of the logic used to index and filter Shapes.  */
end_comment

begin_class
DECL|class|SpatialStrategy
specifier|public
specifier|abstract
class|class
name|SpatialStrategy
block|{
DECL|field|fieldName
specifier|private
specifier|final
name|FieldMapper
operator|.
name|Names
name|fieldName
decl_stmt|;
DECL|field|distanceErrorPct
specifier|private
specifier|final
name|double
name|distanceErrorPct
decl_stmt|;
DECL|field|prefixTree
specifier|private
specifier|final
name|SpatialPrefixTree
name|prefixTree
decl_stmt|;
DECL|field|nodeTokenStream
specifier|private
name|ThreadLocal
argument_list|<
name|NodeTokenStream
argument_list|>
name|nodeTokenStream
init|=
operator|new
name|ThreadLocal
argument_list|<
name|NodeTokenStream
argument_list|>
argument_list|()
block|{
annotation|@
name|Override
specifier|protected
name|NodeTokenStream
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|NodeTokenStream
argument_list|()
return|;
block|}
block|}
decl_stmt|;
comment|/**      * Creates a new SpatialStrategy that will index and Filter using the      * given field      *      * @param fieldName Name of the field that the Strategy will index in and Filter      * @param prefixTree SpatialPrefixTree that will be used to represent Shapes      * @param distanceErrorPct Distance Error Percentage used to guide the      *        SpatialPrefixTree on how precise it should be      */
DECL|method|SpatialStrategy
specifier|protected
name|SpatialStrategy
parameter_list|(
name|FieldMapper
operator|.
name|Names
name|fieldName
parameter_list|,
name|SpatialPrefixTree
name|prefixTree
parameter_list|,
name|double
name|distanceErrorPct
parameter_list|)
block|{
name|this
operator|.
name|fieldName
operator|=
name|fieldName
expr_stmt|;
name|this
operator|.
name|prefixTree
operator|=
name|prefixTree
expr_stmt|;
name|this
operator|.
name|distanceErrorPct
operator|=
name|distanceErrorPct
expr_stmt|;
block|}
comment|/**      * Converts the given Shape into its indexable format.  Implementations      * should not store the Shape value as well.      *      * @param shape Shape to convert ints its indexable format      * @return Fieldable for indexing the Shape      */
DECL|method|createField
specifier|public
name|Field
name|createField
parameter_list|(
name|Shape
name|shape
parameter_list|)
block|{
name|int
name|detailLevel
init|=
name|prefixTree
operator|.
name|getLevelForDistance
argument_list|(
name|calcDistanceFromErrPct
argument_list|(
name|shape
argument_list|,
name|distanceErrorPct
argument_list|,
name|GeoShapeConstants
operator|.
name|SPATIAL_CONTEXT
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|Node
argument_list|>
name|nodes
init|=
name|prefixTree
operator|.
name|getNodes
argument_list|(
name|shape
argument_list|,
name|detailLevel
argument_list|,
literal|true
argument_list|)
decl_stmt|;
name|NodeTokenStream
name|tokenStream
init|=
name|nodeTokenStream
operator|.
name|get
argument_list|()
decl_stmt|;
name|tokenStream
operator|.
name|setNodes
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
comment|// LUCENE 4 Upgrade: We should pass in the FieldType and use it here
return|return
operator|new
name|Field
argument_list|(
name|fieldName
operator|.
name|indexName
argument_list|()
argument_list|,
name|tokenStream
argument_list|)
return|;
block|}
comment|/**      * Creates a Filter that will find all indexed Shapes that relate to the      * given Shape      *      * @param shape Shape the indexed shapes will relate to      * @param relation Nature of the relation      * @return Filter for finding the related shapes      */
DECL|method|createFilter
specifier|public
name|Filter
name|createFilter
parameter_list|(
name|Shape
name|shape
parameter_list|,
name|ShapeRelation
name|relation
parameter_list|)
block|{
switch|switch
condition|(
name|relation
condition|)
block|{
case|case
name|INTERSECTS
case|:
return|return
name|createIntersectsFilter
argument_list|(
name|shape
argument_list|)
return|;
case|case
name|WITHIN
case|:
return|return
name|createWithinFilter
argument_list|(
name|shape
argument_list|)
return|;
case|case
name|DISJOINT
case|:
return|return
name|createDisjointFilter
argument_list|(
name|shape
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Shape Relation ["
operator|+
name|relation
operator|.
name|getRelationName
argument_list|()
operator|+
literal|"] not currently supported"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a Query that will find all indexed Shapes that relate to the      * given Shape      *      * @param shape Shape the indexed shapes will relate to      * @param relation Nature of the relation      * @return Query for finding the related shapes      */
DECL|method|createQuery
specifier|public
name|Query
name|createQuery
parameter_list|(
name|Shape
name|shape
parameter_list|,
name|ShapeRelation
name|relation
parameter_list|)
block|{
switch|switch
condition|(
name|relation
condition|)
block|{
case|case
name|INTERSECTS
case|:
return|return
name|createIntersectsQuery
argument_list|(
name|shape
argument_list|)
return|;
case|case
name|WITHIN
case|:
return|return
name|createWithinQuery
argument_list|(
name|shape
argument_list|)
return|;
case|case
name|DISJOINT
case|:
return|return
name|createDisjointQuery
argument_list|(
name|shape
argument_list|)
return|;
default|default:
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"Shape Relation ["
operator|+
name|relation
operator|.
name|getRelationName
argument_list|()
operator|+
literal|"] not currently supported"
argument_list|)
throw|;
block|}
block|}
comment|/**      * Creates a Filter that will find all indexed Shapes that intersect with      * the given Shape      *      * @param shape Shape to find the intersection Shapes of      * @return Filter finding the intersecting indexed Shapes      */
DECL|method|createIntersectsFilter
specifier|public
specifier|abstract
name|Filter
name|createIntersectsFilter
parameter_list|(
name|Shape
name|shape
parameter_list|)
function_decl|;
comment|/**      * Creates a Query that will find all indexed Shapes that intersect with      * the given Shape      *      * @param shape Shape to find the intersection Shapes of      * @return Query finding the intersecting indexed Shapes      */
DECL|method|createIntersectsQuery
specifier|public
specifier|abstract
name|Query
name|createIntersectsQuery
parameter_list|(
name|Shape
name|shape
parameter_list|)
function_decl|;
comment|/**      * Creates a Filter that will find all indexed Shapes that are disjoint      * to the given Shape      *      * @param shape Shape to find the disjoint Shapes of      * @return Filter for finding the disjoint indexed Shapes      */
DECL|method|createDisjointFilter
specifier|public
specifier|abstract
name|Filter
name|createDisjointFilter
parameter_list|(
name|Shape
name|shape
parameter_list|)
function_decl|;
comment|/**      * Creates a Query that will find all indexed Shapes that are disjoint      * to the given Shape      *      * @param shape Shape to find the disjoint Shapes of      * @return Query for finding the disjoint indexed Shapes      */
DECL|method|createDisjointQuery
specifier|public
specifier|abstract
name|Query
name|createDisjointQuery
parameter_list|(
name|Shape
name|shape
parameter_list|)
function_decl|;
comment|/**      * Creates a Filter that will find all indexed Shapes that are properly      * contained within the given Shape (the indexed Shapes will not have      * any area outside of the given Shape).      *      * @param shape Shape to find the contained Shapes of      * @return Filter for finding the contained indexed Shapes      */
DECL|method|createWithinFilter
specifier|public
specifier|abstract
name|Filter
name|createWithinFilter
parameter_list|(
name|Shape
name|shape
parameter_list|)
function_decl|;
comment|/**      * Creates a Query that will find all indexed Shapes that are properly      * contained within the given Shape (the indexed Shapes will not have      * any area outside of the given Shape).      *      * @param shape Shape to find the contained Shapes of      * @return Query for finding the contained indexed Shapes      */
DECL|method|createWithinQuery
specifier|public
specifier|abstract
name|Query
name|createWithinQuery
parameter_list|(
name|Shape
name|shape
parameter_list|)
function_decl|;
comment|/**      * Returns the name of the field this Strategy applies to      *      * @return Name of the field the Strategy applies to      */
DECL|method|getFieldName
specifier|public
name|FieldMapper
operator|.
name|Names
name|getFieldName
parameter_list|()
block|{
return|return
name|fieldName
return|;
block|}
comment|/**      * Returns the distance error percentage for this Strategy      *      * @return Distance error percentage for the Strategy      */
DECL|method|getDistanceErrorPct
specifier|public
name|double
name|getDistanceErrorPct
parameter_list|()
block|{
return|return
name|distanceErrorPct
return|;
block|}
comment|/**      * Returns the {@link SpatialPrefixTree} used by this Strategy      *      * @return SpatialPrefixTree used by the Strategy      */
DECL|method|getPrefixTree
specifier|public
name|SpatialPrefixTree
name|getPrefixTree
parameter_list|()
block|{
return|return
name|prefixTree
return|;
block|}
comment|/**      * Computes the distance given a shape and the {@code distErrPct}.  The      * algorithm is the fraction of the distance from the center of the query      * shape to its furthest bounding box corner.      *      * @param shape Mandatory.      * @param distErrPct 0 to 0.5      * @param ctx Mandatory      * @return A distance (in degrees).      */
DECL|method|calcDistanceFromErrPct
specifier|protected
specifier|final
name|double
name|calcDistanceFromErrPct
parameter_list|(
name|Shape
name|shape
parameter_list|,
name|double
name|distErrPct
parameter_list|,
name|SpatialContext
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|distErrPct
argument_list|<
literal|0
operator|||
name|distErrPct
argument_list|>
literal|0.5
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"distErrPct "
operator|+
name|distErrPct
operator|+
literal|" must be between [0 to 0.5]"
argument_list|)
throw|;
block|}
if|if
condition|(
name|distErrPct
operator|==
literal|0
operator|||
name|shape
operator|instanceof
name|Point
condition|)
block|{
return|return
literal|0
return|;
block|}
name|Rectangle
name|bbox
init|=
name|shape
operator|.
name|getBoundingBox
argument_list|()
decl_stmt|;
comment|//The diagonal distance should be the same computed from any opposite corner,
comment|// and this is the longest distance that might be occurring within the shape.
name|double
name|diagonalDist
init|=
name|ctx
operator|.
name|getDistCalc
argument_list|()
operator|.
name|distance
argument_list|(
name|ctx
operator|.
name|makePoint
argument_list|(
name|bbox
operator|.
name|getMinX
argument_list|()
argument_list|,
name|bbox
operator|.
name|getMinY
argument_list|()
argument_list|)
argument_list|,
name|bbox
operator|.
name|getMaxX
argument_list|()
argument_list|,
name|bbox
operator|.
name|getMaxY
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|diagonalDist
operator|*
literal|0.5
operator|*
name|distErrPct
return|;
block|}
block|}
end_class

end_unit

