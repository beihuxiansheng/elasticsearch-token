begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elasticsearch under one or more contributor  * license agreements. See the NOTICE file distributed with  * this work for additional information regarding copyright  * ownership. Elasticsearch licenses this file to you under  * the Apache License, Version 2.0 (the "License"); you may  * not use this file except in compliance with the License.  * You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.common.geo.builders
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|geo
operator|.
name|builders
package|;
end_package

begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|context
operator|.
name|jts
operator|.
name|JtsSpatialContext
import|;
end_import

begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|Shape
import|;
end_import

begin_import
import|import
name|com
operator|.
name|spatial4j
operator|.
name|core
operator|.
name|shape
operator|.
name|jts
operator|.
name|JtsGeometry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|Coordinate
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|Geometry
import|;
end_import

begin_import
import|import
name|com
operator|.
name|vividsolutions
operator|.
name|jts
operator|.
name|geom
operator|.
name|GeometryFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|commons
operator|.
name|lang3
operator|.
name|tuple
operator|.
name|Pair
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchIllegalArgumentException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|ElasticsearchParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLoggerFactory
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|unit
operator|.
name|DistanceUnit
operator|.
name|Distance
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|ToXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentBuilder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|XContentParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|xcontent
operator|.
name|json
operator|.
name|JsonXContent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|index
operator|.
name|mapper
operator|.
name|geo
operator|.
name|GeoShapeFieldMapper
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * Basic class for building GeoJSON shapes like Polygons, Linestrings, etc   */
end_comment

begin_class
DECL|class|ShapeBuilder
specifier|public
specifier|abstract
class|class
name|ShapeBuilder
implements|implements
name|ToXContent
block|{
DECL|field|LOGGER
specifier|protected
specifier|static
specifier|final
name|ESLogger
name|LOGGER
init|=
name|ESLoggerFactory
operator|.
name|getLogger
argument_list|(
name|ShapeBuilder
operator|.
name|class
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
DECL|field|DEBUG
specifier|private
specifier|static
specifier|final
name|boolean
name|DEBUG
decl_stmt|;
static|static
block|{
comment|// if asserts are enabled we run the debug statements even if they are not logged
comment|// to prevent exceptions only present if debug enabled
name|boolean
name|debug
init|=
literal|false
decl_stmt|;
assert|assert
name|debug
operator|=
literal|true
assert|;
name|DEBUG
operator|=
name|debug
expr_stmt|;
block|}
DECL|field|DATELINE
specifier|public
specifier|static
specifier|final
name|double
name|DATELINE
init|=
literal|180
decl_stmt|;
comment|// TODO how might we use JtsSpatialContextFactory to configure the context (esp. for non-geo)?
DECL|field|SPATIAL_CONTEXT
specifier|public
specifier|static
specifier|final
name|JtsSpatialContext
name|SPATIAL_CONTEXT
init|=
name|JtsSpatialContext
operator|.
name|GEO
decl_stmt|;
DECL|field|FACTORY
specifier|public
specifier|static
specifier|final
name|GeometryFactory
name|FACTORY
init|=
name|SPATIAL_CONTEXT
operator|.
name|getGeometryFactory
argument_list|()
decl_stmt|;
comment|/** We're expecting some geometries might cross the dateline. */
DECL|field|wrapdateline
specifier|protected
specifier|final
name|boolean
name|wrapdateline
init|=
name|SPATIAL_CONTEXT
operator|.
name|isGeo
argument_list|()
decl_stmt|;
comment|/** It's possible that some geometries in a MULTI* shape might overlap. With the possible exception of GeometryCollection,      * this normally isn't allowed.      */
DECL|field|multiPolygonMayOverlap
specifier|protected
specifier|final
name|boolean
name|multiPolygonMayOverlap
init|=
literal|false
decl_stmt|;
comment|/** @see com.spatial4j.core.shape.jts.JtsGeometry#validate() */
DECL|field|autoValidateJtsGeometry
specifier|protected
specifier|final
name|boolean
name|autoValidateJtsGeometry
init|=
literal|true
decl_stmt|;
comment|/** @see com.spatial4j.core.shape.jts.JtsGeometry#index() */
DECL|field|autoIndexJtsGeometry
specifier|protected
specifier|final
name|boolean
name|autoIndexJtsGeometry
init|=
literal|true
decl_stmt|;
comment|//may want to turn off once SpatialStrategy impls do it.
DECL|field|orientation
specifier|protected
name|Orientation
name|orientation
init|=
name|Orientation
operator|.
name|RIGHT
decl_stmt|;
DECL|method|ShapeBuilder
specifier|protected
name|ShapeBuilder
parameter_list|()
block|{      }
DECL|method|ShapeBuilder
specifier|protected
name|ShapeBuilder
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
name|this
operator|.
name|orientation
operator|=
name|orientation
expr_stmt|;
block|}
DECL|method|coordinate
specifier|protected
specifier|static
name|Coordinate
name|coordinate
parameter_list|(
name|double
name|longitude
parameter_list|,
name|double
name|latitude
parameter_list|)
block|{
return|return
operator|new
name|Coordinate
argument_list|(
name|longitude
argument_list|,
name|latitude
argument_list|)
return|;
block|}
DECL|method|jtsGeometry
specifier|protected
name|JtsGeometry
name|jtsGeometry
parameter_list|(
name|Geometry
name|geom
parameter_list|)
block|{
comment|//dateline180Check is false because ElasticSearch does it's own dateline wrapping
name|JtsGeometry
name|jtsGeometry
init|=
operator|new
name|JtsGeometry
argument_list|(
name|geom
argument_list|,
name|SPATIAL_CONTEXT
argument_list|,
literal|false
argument_list|,
name|multiPolygonMayOverlap
argument_list|)
decl_stmt|;
if|if
condition|(
name|autoValidateJtsGeometry
condition|)
name|jtsGeometry
operator|.
name|validate
argument_list|()
expr_stmt|;
if|if
condition|(
name|autoIndexJtsGeometry
condition|)
name|jtsGeometry
operator|.
name|index
argument_list|()
expr_stmt|;
return|return
name|jtsGeometry
return|;
block|}
comment|/**      * Create a new point      *       * @param longitude longitude of the point      * @param latitude latitude of the point      * @return a new {@link PointBuilder}      */
DECL|method|newPoint
specifier|public
specifier|static
name|PointBuilder
name|newPoint
parameter_list|(
name|double
name|longitude
parameter_list|,
name|double
name|latitude
parameter_list|)
block|{
return|return
name|newPoint
argument_list|(
operator|new
name|Coordinate
argument_list|(
name|longitude
argument_list|,
name|latitude
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Create a new {@link PointBuilder} from a {@link Coordinate}      * @param coordinate coordinate defining the position of the point      * @return a new {@link PointBuilder}      */
DECL|method|newPoint
specifier|public
specifier|static
name|PointBuilder
name|newPoint
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|)
block|{
return|return
operator|new
name|PointBuilder
argument_list|()
operator|.
name|coordinate
argument_list|(
name|coordinate
argument_list|)
return|;
block|}
comment|/**      * Create a new set of points      * @return new {@link MultiPointBuilder}      */
DECL|method|newMultiPoint
specifier|public
specifier|static
name|MultiPointBuilder
name|newMultiPoint
parameter_list|()
block|{
return|return
operator|new
name|MultiPointBuilder
argument_list|()
return|;
block|}
comment|/**      * Create a new lineString      * @return a new {@link LineStringBuilder}      */
DECL|method|newLineString
specifier|public
specifier|static
name|LineStringBuilder
name|newLineString
parameter_list|()
block|{
return|return
operator|new
name|LineStringBuilder
argument_list|()
return|;
block|}
comment|/**      * Create a new Collection of lineStrings      * @return a new {@link MultiLineStringBuilder}      */
DECL|method|newMultiLinestring
specifier|public
specifier|static
name|MultiLineStringBuilder
name|newMultiLinestring
parameter_list|()
block|{
return|return
operator|new
name|MultiLineStringBuilder
argument_list|()
return|;
block|}
comment|/**      * Create a new Polygon      * @return a new {@link PointBuilder}      */
DECL|method|newPolygon
specifier|public
specifier|static
name|PolygonBuilder
name|newPolygon
parameter_list|()
block|{
return|return
operator|new
name|PolygonBuilder
argument_list|()
return|;
block|}
comment|/**      * Create a new Polygon      * @return a new {@link PointBuilder}      */
DECL|method|newPolygon
specifier|public
specifier|static
name|PolygonBuilder
name|newPolygon
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
return|return
operator|new
name|PolygonBuilder
argument_list|(
name|orientation
argument_list|)
return|;
block|}
comment|/**      * Create a new Collection of polygons      * @return a new {@link MultiPolygonBuilder}      */
DECL|method|newMultiPolygon
specifier|public
specifier|static
name|MultiPolygonBuilder
name|newMultiPolygon
parameter_list|()
block|{
return|return
operator|new
name|MultiPolygonBuilder
argument_list|()
return|;
block|}
comment|/**      * Create a new Collection of polygons      * @return a new {@link MultiPolygonBuilder}      */
DECL|method|newMultiPolygon
specifier|public
specifier|static
name|MultiPolygonBuilder
name|newMultiPolygon
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
return|return
operator|new
name|MultiPolygonBuilder
argument_list|(
name|orientation
argument_list|)
return|;
block|}
comment|/**      * Create a new GeometryCollection      * @return a new {@link GeometryCollectionBuilder}      */
DECL|method|newGeometryCollection
specifier|public
specifier|static
name|GeometryCollectionBuilder
name|newGeometryCollection
parameter_list|()
block|{
return|return
operator|new
name|GeometryCollectionBuilder
argument_list|()
return|;
block|}
comment|/**      * Create a new GeometryCollection      * @return a new {@link GeometryCollectionBuilder}      */
DECL|method|newGeometryCollection
specifier|public
specifier|static
name|GeometryCollectionBuilder
name|newGeometryCollection
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
return|return
operator|new
name|GeometryCollectionBuilder
argument_list|(
name|orientation
argument_list|)
return|;
block|}
comment|/**      * create a new Circle      * @return a new {@link CircleBuilder}      */
DECL|method|newCircleBuilder
specifier|public
specifier|static
name|CircleBuilder
name|newCircleBuilder
parameter_list|()
block|{
return|return
operator|new
name|CircleBuilder
argument_list|()
return|;
block|}
comment|/**      * create a new rectangle      * @return a new {@link EnvelopeBuilder}      */
DECL|method|newEnvelope
specifier|public
specifier|static
name|EnvelopeBuilder
name|newEnvelope
parameter_list|()
block|{
return|return
operator|new
name|EnvelopeBuilder
argument_list|()
return|;
block|}
comment|/**      * create a new rectangle      * @return a new {@link EnvelopeBuilder}      */
DECL|method|newEnvelope
specifier|public
specifier|static
name|EnvelopeBuilder
name|newEnvelope
parameter_list|(
name|Orientation
name|orientation
parameter_list|)
block|{
return|return
operator|new
name|EnvelopeBuilder
argument_list|(
name|orientation
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
try|try
block|{
name|XContentBuilder
name|xcontent
init|=
name|JsonXContent
operator|.
name|contentBuilder
argument_list|()
decl_stmt|;
return|return
name|toXContent
argument_list|(
name|xcontent
argument_list|,
name|EMPTY_PARAMS
argument_list|)
operator|.
name|prettyPrint
argument_list|()
operator|.
name|string
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|IOException
name|e
parameter_list|)
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
comment|/**      * Create a new Shape from this builder. Since calling this method could change the      * defined shape. (by inserting new coordinates or change the position of points)      * the builder looses its validity. So this method should only be called once on a builder        * @return new {@link Shape} defined by the builder      */
DECL|method|build
specifier|public
specifier|abstract
name|Shape
name|build
parameter_list|()
function_decl|;
comment|/**      * Recursive method which parses the arrays of coordinates used to define      * Shapes      *       * @param parser      *            Parser that will be read from      * @return CoordinateNode representing the start of the coordinate tree      * @throws IOException      *             Thrown if an error occurs while reading from the      *             XContentParser      */
DECL|method|parseCoordinates
specifier|private
specifier|static
name|CoordinateNode
name|parseCoordinates
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
comment|// Base cases
if|if
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
operator|&&
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
operator|&&
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
name|double
name|lon
init|=
name|parser
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|double
name|lat
init|=
name|parser
operator|.
name|doubleValue
argument_list|()
decl_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
return|return
operator|new
name|CoordinateNode
argument_list|(
operator|new
name|Coordinate
argument_list|(
name|lon
argument_list|,
name|lat
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchIllegalArgumentException
argument_list|(
literal|"coordinates cannot contain NULL values)"
argument_list|)
throw|;
block|}
name|List
argument_list|<
name|CoordinateNode
argument_list|>
name|nodes
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|()
decl_stmt|;
while|while
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
condition|)
block|{
name|nodes
operator|.
name|add
argument_list|(
name|parseCoordinates
argument_list|(
name|parser
argument_list|)
argument_list|)
expr_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
return|return
operator|new
name|CoordinateNode
argument_list|(
name|nodes
argument_list|)
return|;
block|}
comment|/**      * Create a new {@link ShapeBuilder} from {@link XContent}      * @param parser parser to read the GeoShape from      * @return {@link ShapeBuilder} read from the parser or null      *          if the parsers current token has been<code><null</code>      * @throws IOException if the input could not be read      */
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|GeoShapeType
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Create a new {@link ShapeBuilder} from {@link XContent}      * @param parser parser to read the GeoShape from      * @param geoDocMapper document field mapper reference required for spatial parameters relevant      *                     to the shape construction process (e.g., orientation)      *                     todo: refactor to place build specific parameters in the SpatialContext      * @return {@link ShapeBuilder} read from the parser or null      *          if the parsers current token has been<code><null</code>      * @throws IOException if the input could not be read      */
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|GeoShapeFieldMapper
name|geoDocMapper
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|GeoShapeType
operator|.
name|parse
argument_list|(
name|parser
argument_list|,
name|geoDocMapper
argument_list|)
return|;
block|}
DECL|method|toXContent
specifier|protected
specifier|static
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Coordinate
name|coordinate
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|builder
operator|.
name|startArray
argument_list|()
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|x
argument_list|)
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|y
argument_list|)
operator|.
name|endArray
argument_list|()
return|;
block|}
DECL|method|orientationFromString
specifier|public
specifier|static
name|Orientation
name|orientationFromString
parameter_list|(
name|String
name|orientation
parameter_list|)
block|{
name|orientation
operator|=
name|orientation
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|orientation
condition|)
block|{
case|case
literal|"right"
case|:
case|case
literal|"counterclockwise"
case|:
case|case
literal|"ccw"
case|:
return|return
name|Orientation
operator|.
name|RIGHT
return|;
case|case
literal|"left"
case|:
case|case
literal|"clockwise"
case|:
case|case
literal|"cw"
case|:
return|return
name|Orientation
operator|.
name|LEFT
return|;
default|default:
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Unknown orientation ["
operator|+
name|orientation
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
DECL|method|shift
specifier|protected
specifier|static
name|Coordinate
name|shift
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|,
name|double
name|dateline
parameter_list|)
block|{
if|if
condition|(
name|dateline
operator|==
literal|0
condition|)
block|{
return|return
name|coordinate
return|;
block|}
else|else
block|{
return|return
operator|new
name|Coordinate
argument_list|(
operator|-
literal|2
operator|*
name|dateline
operator|+
name|coordinate
operator|.
name|x
argument_list|,
name|coordinate
operator|.
name|y
argument_list|)
return|;
block|}
block|}
comment|/**      * get the shapes type      * @return type of the shape      */
DECL|method|type
specifier|public
specifier|abstract
name|GeoShapeType
name|type
parameter_list|()
function_decl|;
comment|/**      * Calculate the intersection of a line segment and a vertical dateline.      *       * @param p1      *            start-point of the line segment      * @param p2      *            end-point of the line segment      * @param dateline      *            x-coordinate of the vertical dateline      * @return position of the intersection in the open range (0..1] if the line      *         segment intersects with the line segment. Otherwise this method      *         returns {@link Double#NaN}      */
DECL|method|intersection
specifier|protected
specifier|static
specifier|final
name|double
name|intersection
parameter_list|(
name|Coordinate
name|p1
parameter_list|,
name|Coordinate
name|p2
parameter_list|,
name|double
name|dateline
parameter_list|)
block|{
if|if
condition|(
name|p1
operator|.
name|x
operator|==
name|p2
operator|.
name|x
operator|&&
name|p1
operator|.
name|x
operator|!=
name|dateline
condition|)
block|{
return|return
name|Double
operator|.
name|NaN
return|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|.
name|x
operator|==
name|p2
operator|.
name|x
operator|&&
name|p1
operator|.
name|x
operator|==
name|dateline
condition|)
block|{
return|return
literal|1.0
return|;
block|}
else|else
block|{
specifier|final
name|double
name|t
init|=
operator|(
name|dateline
operator|-
name|p1
operator|.
name|x
operator|)
operator|/
operator|(
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
operator|)
decl_stmt|;
if|if
condition|(
name|t
operator|>
literal|1
operator|||
name|t
operator|<=
literal|0
condition|)
block|{
return|return
name|Double
operator|.
name|NaN
return|;
block|}
else|else
block|{
return|return
name|t
return|;
block|}
block|}
block|}
comment|/**      * Calculate all intersections of line segments and a vertical line. The      * Array of edges will be ordered asc by the y-coordinate of the      * intersections of edges.      *       * @param dateline      *            x-coordinate of the dateline      * @param edges      *            set of edges that may intersect with the dateline      * @return number of intersecting edges      */
DECL|method|intersections
specifier|protected
specifier|static
name|int
name|intersections
parameter_list|(
name|double
name|dateline
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|)
block|{
name|int
name|numIntersections
init|=
literal|0
decl_stmt|;
assert|assert
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|dateline
argument_list|)
assert|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edges
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Coordinate
name|p1
init|=
name|edges
index|[
name|i
index|]
operator|.
name|coordinate
decl_stmt|;
name|Coordinate
name|p2
init|=
name|edges
index|[
name|i
index|]
operator|.
name|next
operator|.
name|coordinate
decl_stmt|;
assert|assert
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|p2
operator|.
name|x
argument_list|)
operator|&&
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|p1
operator|.
name|x
argument_list|)
assert|;
name|edges
index|[
name|i
index|]
operator|.
name|intersect
operator|=
name|Edge
operator|.
name|MAX_COORDINATE
expr_stmt|;
name|double
name|position
init|=
name|intersection
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|dateline
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Double
operator|.
name|isNaN
argument_list|(
name|position
argument_list|)
condition|)
block|{
name|edges
index|[
name|i
index|]
operator|.
name|intersection
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|numIntersections
operator|++
expr_stmt|;
block|}
block|}
name|Arrays
operator|.
name|sort
argument_list|(
name|edges
argument_list|,
name|INTERSECTION_ORDER
argument_list|)
expr_stmt|;
return|return
name|numIntersections
return|;
block|}
comment|/**      * Node used to represent a tree of coordinates.      *<p/>      * Can either be a leaf node consisting of a Coordinate, or a parent with      * children      */
DECL|class|CoordinateNode
specifier|protected
specifier|static
class|class
name|CoordinateNode
implements|implements
name|ToXContent
block|{
DECL|field|coordinate
specifier|protected
specifier|final
name|Coordinate
name|coordinate
decl_stmt|;
DECL|field|children
specifier|protected
specifier|final
name|List
argument_list|<
name|CoordinateNode
argument_list|>
name|children
decl_stmt|;
comment|/**          * Creates a new leaf CoordinateNode          *           * @param coordinate          *            Coordinate for the Node          */
DECL|method|CoordinateNode
specifier|protected
name|CoordinateNode
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|)
block|{
name|this
operator|.
name|coordinate
operator|=
name|coordinate
expr_stmt|;
name|this
operator|.
name|children
operator|=
literal|null
expr_stmt|;
block|}
comment|/**          * Creates a new parent CoordinateNode          *           * @param children          *            Children of the Node          */
DECL|method|CoordinateNode
specifier|protected
name|CoordinateNode
parameter_list|(
name|List
argument_list|<
name|CoordinateNode
argument_list|>
name|children
parameter_list|)
block|{
name|this
operator|.
name|children
operator|=
name|children
expr_stmt|;
name|this
operator|.
name|coordinate
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|isEmpty
specifier|protected
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
operator|(
name|coordinate
operator|==
literal|null
operator|&&
operator|(
name|children
operator|==
literal|null
operator|||
name|children
operator|.
name|isEmpty
argument_list|()
operator|)
operator|)
return|;
block|}
annotation|@
name|Override
DECL|method|toXContent
specifier|public
name|XContentBuilder
name|toXContent
parameter_list|(
name|XContentBuilder
name|builder
parameter_list|,
name|Params
name|params
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|children
operator|==
literal|null
condition|)
block|{
name|builder
operator|.
name|startArray
argument_list|()
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|x
argument_list|)
operator|.
name|value
argument_list|(
name|coordinate
operator|.
name|y
argument_list|)
operator|.
name|endArray
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|builder
operator|.
name|startArray
argument_list|()
expr_stmt|;
for|for
control|(
name|CoordinateNode
name|child
range|:
name|children
control|)
block|{
name|child
operator|.
name|toXContent
argument_list|(
name|builder
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
name|builder
operator|.
name|endArray
argument_list|()
expr_stmt|;
block|}
return|return
name|builder
return|;
block|}
block|}
comment|/**      * This helper class implements a linked list for {@link Coordinate}. It contains      * fields for a dateline intersection and component id       */
DECL|class|Edge
specifier|protected
specifier|static
specifier|final
class|class
name|Edge
block|{
DECL|field|coordinate
name|Coordinate
name|coordinate
decl_stmt|;
comment|// coordinate of the start point
DECL|field|next
name|Edge
name|next
decl_stmt|;
comment|// next segment
DECL|field|intersect
name|Coordinate
name|intersect
decl_stmt|;
comment|// potential intersection with dateline
DECL|field|component
name|int
name|component
init|=
operator|-
literal|1
decl_stmt|;
comment|// id of the component this edge belongs to
DECL|field|MAX_COORDINATE
specifier|public
specifier|static
specifier|final
name|Coordinate
name|MAX_COORDINATE
init|=
operator|new
name|Coordinate
argument_list|(
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|,
name|Double
operator|.
name|POSITIVE_INFINITY
argument_list|)
decl_stmt|;
DECL|method|Edge
specifier|protected
name|Edge
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|,
name|Edge
name|next
parameter_list|,
name|Coordinate
name|intersection
parameter_list|)
block|{
name|this
operator|.
name|coordinate
operator|=
name|coordinate
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|this
operator|.
name|intersect
operator|=
name|intersection
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
block|{
name|this
operator|.
name|component
operator|=
name|next
operator|.
name|component
expr_stmt|;
block|}
block|}
DECL|method|Edge
specifier|protected
name|Edge
parameter_list|(
name|Coordinate
name|coordinate
parameter_list|,
name|Edge
name|next
parameter_list|)
block|{
name|this
argument_list|(
name|coordinate
argument_list|,
name|next
argument_list|,
name|Edge
operator|.
name|MAX_COORDINATE
argument_list|)
expr_stmt|;
block|}
DECL|method|top
specifier|private
specifier|static
specifier|final
name|int
name|top
parameter_list|(
name|Coordinate
index|[]
name|points
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|top
init|=
literal|0
decl_stmt|;
comment|// we start at 1 here since top points to 0
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|<
name|points
index|[
name|offset
operator|+
name|top
index|]
operator|.
name|y
condition|)
block|{
name|top
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|==
name|points
index|[
name|offset
operator|+
name|top
index|]
operator|.
name|y
condition|)
block|{
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
operator|<
name|points
index|[
name|offset
operator|+
name|top
index|]
operator|.
name|x
condition|)
block|{
name|top
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
return|return
name|top
return|;
block|}
DECL|method|range
specifier|private
specifier|static
specifier|final
name|Pair
name|range
parameter_list|(
name|Coordinate
index|[]
name|points
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|double
name|minX
init|=
name|points
index|[
literal|0
index|]
operator|.
name|x
decl_stmt|;
name|double
name|maxX
init|=
name|points
index|[
literal|0
index|]
operator|.
name|x
decl_stmt|;
name|double
name|minY
init|=
name|points
index|[
literal|0
index|]
operator|.
name|y
decl_stmt|;
name|double
name|maxY
init|=
name|points
index|[
literal|0
index|]
operator|.
name|y
decl_stmt|;
comment|// compute the bounding coordinates (@todo: cleanup brute force)
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
operator|<
name|minX
condition|)
block|{
name|minX
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
operator|>
name|maxX
condition|)
block|{
name|maxX
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|x
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|<
name|minY
condition|)
block|{
name|minY
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
if|if
condition|(
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
operator|>
name|maxY
condition|)
block|{
name|maxY
operator|=
name|points
index|[
name|offset
operator|+
name|i
index|]
operator|.
name|y
expr_stmt|;
block|}
block|}
return|return
name|Pair
operator|.
name|of
argument_list|(
name|Pair
operator|.
name|of
argument_list|(
name|minX
argument_list|,
name|maxX
argument_list|)
argument_list|,
name|Pair
operator|.
name|of
argument_list|(
name|minY
argument_list|,
name|maxY
argument_list|)
argument_list|)
return|;
block|}
comment|/**          * Concatenate a set of points to a polygon          *           * @param component          *            component id of the polygon          * @param direction          *            direction of the ring          * @param points          *            list of points to concatenate          * @param pointOffset          *            index of the first point          * @param edges          *            Array of edges to write the result to          * @param edgeOffset          *            index of the first edge in the result          * @param length          *            number of points to use          * @return the edges creates          */
DECL|method|concat
specifier|private
specifier|static
name|Edge
index|[]
name|concat
parameter_list|(
name|int
name|component
parameter_list|,
name|boolean
name|direction
parameter_list|,
name|Coordinate
index|[]
name|points
parameter_list|,
specifier|final
name|int
name|pointOffset
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|,
specifier|final
name|int
name|edgeOffset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
assert|assert
name|edges
operator|.
name|length
operator|>=
name|length
operator|+
name|edgeOffset
assert|;
assert|assert
name|points
operator|.
name|length
operator|>=
name|length
operator|+
name|pointOffset
assert|;
name|edges
index|[
name|edgeOffset
index|]
operator|=
operator|new
name|Edge
argument_list|(
name|points
index|[
name|pointOffset
index|]
argument_list|,
literal|null
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|direction
condition|)
block|{
name|edges
index|[
name|edgeOffset
operator|+
name|i
index|]
operator|=
operator|new
name|Edge
argument_list|(
name|points
index|[
name|pointOffset
operator|+
name|i
index|]
argument_list|,
name|edges
index|[
name|edgeOffset
operator|+
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|edges
index|[
name|edgeOffset
operator|+
name|i
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
else|else
block|{
name|edges
index|[
name|edgeOffset
operator|+
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|edges
index|[
name|edgeOffset
operator|+
name|i
index|]
operator|=
operator|new
name|Edge
argument_list|(
name|points
index|[
name|pointOffset
operator|+
name|i
index|]
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|edges
index|[
name|edgeOffset
operator|+
name|i
operator|-
literal|1
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
block|}
if|if
condition|(
name|direction
condition|)
block|{
name|edges
index|[
name|edgeOffset
index|]
operator|.
name|next
operator|=
name|edges
index|[
name|edgeOffset
operator|+
name|length
operator|-
literal|1
index|]
expr_stmt|;
name|edges
index|[
name|edgeOffset
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
else|else
block|{
name|edges
index|[
name|edgeOffset
operator|+
name|length
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|edges
index|[
name|edgeOffset
index|]
expr_stmt|;
name|edges
index|[
name|edgeOffset
operator|+
name|length
operator|-
literal|1
index|]
operator|.
name|component
operator|=
name|component
expr_stmt|;
block|}
return|return
name|edges
return|;
block|}
comment|/**          * Create a connected list of a list of coordinates          *           * @param points          *            array of point          * @param offset          *            index of the first point          * @param length          *            number of points          * @return Array of edges          */
DECL|method|ring
specifier|protected
specifier|static
name|Edge
index|[]
name|ring
parameter_list|(
name|int
name|component
parameter_list|,
name|boolean
name|direction
parameter_list|,
name|boolean
name|handedness
parameter_list|,
name|BaseLineStringBuilder
argument_list|<
name|?
argument_list|>
name|shell
parameter_list|,
name|Coordinate
index|[]
name|points
parameter_list|,
name|int
name|offset
parameter_list|,
name|Edge
index|[]
name|edges
parameter_list|,
name|int
name|toffset
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|// calculate the direction of the points:
comment|// find the point a the top of the set and check its
comment|// neighbors orientation. So direction is equivalent
comment|// to clockwise/counterclockwise
specifier|final
name|int
name|top
init|=
name|top
argument_list|(
name|points
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
specifier|final
name|int
name|prev
init|=
operator|(
name|offset
operator|+
operator|(
operator|(
name|top
operator|+
name|length
operator|-
literal|1
operator|)
operator|%
name|length
operator|)
operator|)
decl_stmt|;
specifier|final
name|int
name|next
init|=
operator|(
name|offset
operator|+
operator|(
operator|(
name|top
operator|+
literal|1
operator|)
operator|%
name|length
operator|)
operator|)
decl_stmt|;
name|boolean
name|orientation
init|=
name|points
index|[
name|offset
operator|+
name|prev
index|]
operator|.
name|x
operator|>
name|points
index|[
name|offset
operator|+
name|next
index|]
operator|.
name|x
decl_stmt|;
comment|// OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness)
comment|// since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards
comment|// thus if orientation is computed as cw, the logic will translate points across dateline
comment|// and convert to a right handed system
comment|// compute the bounding box and calculate range
name|Pair
argument_list|<
name|Pair
argument_list|,
name|Pair
argument_list|>
name|range
init|=
name|range
argument_list|(
name|points
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
decl_stmt|;
specifier|final
name|double
name|rng
init|=
operator|(
name|Double
operator|)
name|range
operator|.
name|getLeft
argument_list|()
operator|.
name|getRight
argument_list|()
operator|-
operator|(
name|Double
operator|)
name|range
operator|.
name|getLeft
argument_list|()
operator|.
name|getLeft
argument_list|()
decl_stmt|;
comment|// translate the points if the following is true
comment|//   1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres
comment|//       (translation would result in a collapsed poly)
comment|//   2.  the shell of the candidate hole has been translated (to preserve the coordinate system)
name|boolean
name|incorrectOrientation
init|=
name|component
operator|==
literal|0
operator|&&
name|handedness
operator|!=
name|orientation
decl_stmt|;
if|if
condition|(
operator|(
name|incorrectOrientation
operator|&&
operator|(
name|rng
operator|>
name|DATELINE
operator|&&
name|rng
operator|!=
literal|2
operator|*
name|DATELINE
operator|)
operator|)
operator|||
operator|(
name|shell
operator|.
name|translated
operator|&&
name|component
operator|!=
literal|0
operator|)
condition|)
block|{
name|translate
argument_list|(
name|points
argument_list|)
expr_stmt|;
comment|// flip the translation bit if the shell is being translated
if|if
condition|(
name|component
operator|==
literal|0
condition|)
block|{
name|shell
operator|.
name|translated
operator|=
literal|true
expr_stmt|;
block|}
comment|// correct the orientation post translation (ccw for shell, cw for holes)
if|if
condition|(
name|component
operator|==
literal|0
operator|||
operator|(
name|component
operator|!=
literal|0
operator|&&
name|handedness
operator|==
name|orientation
operator|)
condition|)
block|{
name|orientation
operator|=
operator|!
name|orientation
expr_stmt|;
block|}
block|}
return|return
name|concat
argument_list|(
name|component
argument_list|,
name|direction
operator|^
name|orientation
argument_list|,
name|points
argument_list|,
name|offset
argument_list|,
name|edges
argument_list|,
name|toffset
argument_list|,
name|length
argument_list|)
return|;
block|}
comment|/**          * Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range           * @param points          */
DECL|method|translate
specifier|protected
specifier|static
name|void
name|translate
parameter_list|(
name|Coordinate
index|[]
name|points
parameter_list|)
block|{
for|for
control|(
name|Coordinate
name|c
range|:
name|points
control|)
block|{
if|if
condition|(
name|c
operator|.
name|x
operator|<
literal|0
condition|)
block|{
name|c
operator|.
name|x
operator|+=
literal|2
operator|*
name|DATELINE
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Set the intersection of this line segment to the given position          *           * @param position          *            position of the intersection [0..1]          * @return the {@link Coordinate} of the intersection          */
DECL|method|intersection
specifier|protected
name|Coordinate
name|intersection
parameter_list|(
name|double
name|position
parameter_list|)
block|{
return|return
name|intersect
operator|=
name|position
argument_list|(
name|coordinate
argument_list|,
name|next
operator|.
name|coordinate
argument_list|,
name|position
argument_list|)
return|;
block|}
DECL|method|position
specifier|public
specifier|static
name|Coordinate
name|position
parameter_list|(
name|Coordinate
name|p1
parameter_list|,
name|Coordinate
name|p2
parameter_list|,
name|double
name|position
parameter_list|)
block|{
if|if
condition|(
name|position
operator|==
literal|0
condition|)
block|{
return|return
name|p1
return|;
block|}
elseif|else
if|if
condition|(
name|position
operator|==
literal|1
condition|)
block|{
return|return
name|p2
return|;
block|}
else|else
block|{
specifier|final
name|double
name|x
init|=
name|p1
operator|.
name|x
operator|+
name|position
operator|*
operator|(
name|p2
operator|.
name|x
operator|-
name|p1
operator|.
name|x
operator|)
decl_stmt|;
specifier|final
name|double
name|y
init|=
name|p1
operator|.
name|y
operator|+
name|position
operator|*
operator|(
name|p2
operator|.
name|y
operator|-
name|p1
operator|.
name|y
operator|)
decl_stmt|;
return|return
operator|new
name|Coordinate
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
block|}
annotation|@
name|Override
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
literal|"Edge[Component="
operator|+
name|component
operator|+
literal|"; start="
operator|+
name|coordinate
operator|+
literal|" "
operator|+
literal|"; intersection="
operator|+
name|intersect
operator|+
literal|"]"
return|;
block|}
block|}
DECL|field|INTERSECTION_ORDER
specifier|protected
specifier|static
specifier|final
name|IntersectionOrder
name|INTERSECTION_ORDER
init|=
operator|new
name|IntersectionOrder
argument_list|()
decl_stmt|;
DECL|class|IntersectionOrder
specifier|private
specifier|static
specifier|final
class|class
name|IntersectionOrder
implements|implements
name|Comparator
argument_list|<
name|Edge
argument_list|>
block|{
annotation|@
name|Override
DECL|method|compare
specifier|public
name|int
name|compare
parameter_list|(
name|Edge
name|o1
parameter_list|,
name|Edge
name|o2
parameter_list|)
block|{
return|return
name|Double
operator|.
name|compare
argument_list|(
name|o1
operator|.
name|intersect
operator|.
name|y
argument_list|,
name|o2
operator|.
name|intersect
operator|.
name|y
argument_list|)
return|;
block|}
block|}
DECL|enum|Orientation
specifier|public
specifier|static
enum|enum
name|Orientation
block|{
DECL|enum constant|LEFT
name|LEFT
block|,
DECL|enum constant|RIGHT
name|RIGHT
block|;
DECL|field|CLOCKWISE
specifier|public
specifier|static
specifier|final
name|Orientation
name|CLOCKWISE
init|=
name|Orientation
operator|.
name|LEFT
decl_stmt|;
DECL|field|COUNTER_CLOCKWISE
specifier|public
specifier|static
specifier|final
name|Orientation
name|COUNTER_CLOCKWISE
init|=
name|Orientation
operator|.
name|RIGHT
decl_stmt|;
DECL|field|CW
specifier|public
specifier|static
specifier|final
name|Orientation
name|CW
init|=
name|Orientation
operator|.
name|LEFT
decl_stmt|;
DECL|field|CCW
specifier|public
specifier|static
specifier|final
name|Orientation
name|CCW
init|=
name|Orientation
operator|.
name|RIGHT
decl_stmt|;
block|}
DECL|field|FIELD_TYPE
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_TYPE
init|=
literal|"type"
decl_stmt|;
DECL|field|FIELD_COORDINATES
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_COORDINATES
init|=
literal|"coordinates"
decl_stmt|;
DECL|field|FIELD_GEOMETRIES
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_GEOMETRIES
init|=
literal|"geometries"
decl_stmt|;
DECL|field|FIELD_ORIENTATION
specifier|public
specifier|static
specifier|final
name|String
name|FIELD_ORIENTATION
init|=
literal|"orientation"
decl_stmt|;
DECL|method|debugEnabled
specifier|protected
specifier|static
specifier|final
name|boolean
name|debugEnabled
parameter_list|()
block|{
return|return
name|LOGGER
operator|.
name|isDebugEnabled
argument_list|()
operator|||
name|DEBUG
return|;
block|}
comment|/**      * Enumeration that lists all {@link GeoShapeType}s that can be handled      */
DECL|enum|GeoShapeType
specifier|public
specifier|static
enum|enum
name|GeoShapeType
block|{
DECL|enum constant|POINT
name|POINT
argument_list|(
literal|"point"
argument_list|)
block|,
DECL|enum constant|MULTIPOINT
name|MULTIPOINT
argument_list|(
literal|"multipoint"
argument_list|)
block|,
DECL|enum constant|LINESTRING
name|LINESTRING
argument_list|(
literal|"linestring"
argument_list|)
block|,
DECL|enum constant|MULTILINESTRING
name|MULTILINESTRING
argument_list|(
literal|"multilinestring"
argument_list|)
block|,
DECL|enum constant|POLYGON
name|POLYGON
argument_list|(
literal|"polygon"
argument_list|)
block|,
DECL|enum constant|MULTIPOLYGON
name|MULTIPOLYGON
argument_list|(
literal|"multipolygon"
argument_list|)
block|,
DECL|enum constant|GEOMETRYCOLLECTION
name|GEOMETRYCOLLECTION
argument_list|(
literal|"geometrycollection"
argument_list|)
block|,
DECL|enum constant|ENVELOPE
name|ENVELOPE
argument_list|(
literal|"envelope"
argument_list|)
block|,
DECL|enum constant|CIRCLE
name|CIRCLE
argument_list|(
literal|"circle"
argument_list|)
block|;
DECL|field|shapename
specifier|protected
specifier|final
name|String
name|shapename
decl_stmt|;
DECL|method|GeoShapeType
specifier|private
name|GeoShapeType
parameter_list|(
name|String
name|shapename
parameter_list|)
block|{
name|this
operator|.
name|shapename
operator|=
name|shapename
expr_stmt|;
block|}
DECL|method|forName
specifier|public
specifier|static
name|GeoShapeType
name|forName
parameter_list|(
name|String
name|geoshapename
parameter_list|)
block|{
name|String
name|typename
init|=
name|geoshapename
operator|.
name|toLowerCase
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|)
decl_stmt|;
for|for
control|(
name|GeoShapeType
name|type
range|:
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|type
operator|.
name|shapename
operator|.
name|equals
argument_list|(
name|typename
argument_list|)
condition|)
block|{
return|return
name|type
return|;
block|}
block|}
throw|throw
operator|new
name|ElasticsearchIllegalArgumentException
argument_list|(
literal|"unknown geo_shape ["
operator|+
name|geoshapename
operator|+
literal|"]"
argument_list|)
throw|;
block|}
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|)
throws|throws
name|IOException
block|{
return|return
name|parse
argument_list|(
name|parser
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**          * Parse the geometry specified by the source document and return a ShapeBuilder instance used to          * build the actual geometry          * @param parser - parse utility object including source document          * @param shapeMapper - field mapper needed for index specific parameters          * @return ShapeBuilder - a builder instance used to create the geometry          * @throws IOException          */
DECL|method|parse
specifier|public
specifier|static
name|ShapeBuilder
name|parse
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|GeoShapeFieldMapper
name|shapeMapper
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|parser
operator|.
name|currentToken
argument_list|()
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|VALUE_NULL
condition|)
block|{
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|parser
operator|.
name|currentToken
argument_list|()
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_OBJECT
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Shape must be an object consisting of type and coordinates"
argument_list|)
throw|;
block|}
name|GeoShapeType
name|shapeType
init|=
literal|null
decl_stmt|;
name|Distance
name|radius
init|=
literal|null
decl_stmt|;
name|CoordinateNode
name|node
init|=
literal|null
decl_stmt|;
name|GeometryCollectionBuilder
name|geometryCollections
init|=
literal|null
decl_stmt|;
name|Orientation
name|requestedOrientation
init|=
operator|(
name|shapeMapper
operator|==
literal|null
operator|)
condition|?
name|Orientation
operator|.
name|RIGHT
else|:
name|shapeMapper
operator|.
name|orientation
argument_list|()
decl_stmt|;
name|XContentParser
operator|.
name|Token
name|token
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
operator|)
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_OBJECT
condition|)
block|{
if|if
condition|(
name|token
operator|==
name|XContentParser
operator|.
name|Token
operator|.
name|FIELD_NAME
condition|)
block|{
name|String
name|fieldName
init|=
name|parser
operator|.
name|currentName
argument_list|()
decl_stmt|;
if|if
condition|(
name|FIELD_TYPE
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|shapeType
operator|=
name|GeoShapeType
operator|.
name|forName
argument_list|(
name|parser
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FIELD_COORDINATES
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|node
operator|=
name|parseCoordinates
argument_list|(
name|parser
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FIELD_GEOMETRIES
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|geometryCollections
operator|=
name|parseGeometries
argument_list|(
name|parser
argument_list|,
name|requestedOrientation
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CircleBuilder
operator|.
name|FIELD_RADIUS
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|radius
operator|=
name|Distance
operator|.
name|parseDistance
argument_list|(
name|parser
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FIELD_ORIENTATION
operator|.
name|equals
argument_list|(
name|fieldName
argument_list|)
condition|)
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|requestedOrientation
operator|=
name|orientationFromString
argument_list|(
name|parser
operator|.
name|text
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
name|parser
operator|.
name|skipChildren
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|shapeType
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Shape type not included"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
literal|null
operator|&&
name|GeoShapeType
operator|.
name|GEOMETRYCOLLECTION
operator|!=
name|shapeType
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Coordinates not included"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|geometryCollections
operator|==
literal|null
operator|&&
name|GeoShapeType
operator|.
name|GEOMETRYCOLLECTION
operator|==
name|shapeType
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"geometries not included"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|radius
operator|!=
literal|null
operator|&&
name|GeoShapeType
operator|.
name|CIRCLE
operator|!=
name|shapeType
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Field ["
operator|+
name|CircleBuilder
operator|.
name|FIELD_RADIUS
operator|+
literal|"] is supported for ["
operator|+
name|CircleBuilder
operator|.
name|TYPE
operator|+
literal|"] only"
argument_list|)
throw|;
block|}
switch|switch
condition|(
name|shapeType
condition|)
block|{
case|case
name|POINT
case|:
return|return
name|parsePoint
argument_list|(
name|node
argument_list|)
return|;
case|case
name|MULTIPOINT
case|:
return|return
name|parseMultiPoint
argument_list|(
name|node
argument_list|)
return|;
case|case
name|LINESTRING
case|:
return|return
name|parseLineString
argument_list|(
name|node
argument_list|)
return|;
case|case
name|MULTILINESTRING
case|:
return|return
name|parseMultiLine
argument_list|(
name|node
argument_list|)
return|;
case|case
name|POLYGON
case|:
return|return
name|parsePolygon
argument_list|(
name|node
argument_list|,
name|requestedOrientation
argument_list|)
return|;
case|case
name|MULTIPOLYGON
case|:
return|return
name|parseMultiPolygon
argument_list|(
name|node
argument_list|,
name|requestedOrientation
argument_list|)
return|;
case|case
name|CIRCLE
case|:
return|return
name|parseCircle
argument_list|(
name|node
argument_list|,
name|radius
argument_list|)
return|;
case|case
name|ENVELOPE
case|:
return|return
name|parseEnvelope
argument_list|(
name|node
argument_list|,
name|requestedOrientation
argument_list|)
return|;
case|case
name|GEOMETRYCOLLECTION
case|:
return|return
name|geometryCollections
return|;
default|default:
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Shape type ["
operator|+
name|shapeType
operator|+
literal|"] not included"
argument_list|)
throw|;
block|}
block|}
DECL|method|validatePointNode
specifier|protected
specifier|static
name|void
name|validatePointNode
parameter_list|(
name|CoordinateNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Invalid number of points (0) provided when expecting a single coordinate "
operator|+
literal|"([lat, lng])"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|coordinate
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
operator|==
literal|false
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"multipoint data provided when single point data expected."
argument_list|)
throw|;
block|}
block|}
block|}
DECL|method|parsePoint
specifier|protected
specifier|static
name|PointBuilder
name|parsePoint
parameter_list|(
name|CoordinateNode
name|node
parameter_list|)
block|{
name|validatePointNode
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|newPoint
argument_list|(
name|node
operator|.
name|coordinate
argument_list|)
return|;
block|}
DECL|method|parseCircle
specifier|protected
specifier|static
name|CircleBuilder
name|parseCircle
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
name|Distance
name|radius
parameter_list|)
block|{
return|return
name|newCircleBuilder
argument_list|()
operator|.
name|center
argument_list|(
name|coordinates
operator|.
name|coordinate
argument_list|)
operator|.
name|radius
argument_list|(
name|radius
argument_list|)
return|;
block|}
DECL|method|parseEnvelope
specifier|protected
specifier|static
name|EnvelopeBuilder
name|parseEnvelope
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
block|{
return|return
name|newEnvelope
argument_list|(
name|orientation
argument_list|)
operator|.
name|topLeft
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|coordinate
argument_list|)
operator|.
name|bottomRight
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|1
argument_list|)
operator|.
name|coordinate
argument_list|)
return|;
block|}
DECL|method|validateMultiPointNode
specifier|protected
specifier|static
name|void
name|validateMultiPointNode
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
if|if
condition|(
name|coordinates
operator|.
name|children
operator|==
literal|null
operator|||
name|coordinates
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|coordinates
operator|.
name|coordinate
operator|!=
literal|null
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"single coordinate found when expecting an array of "
operator|+
literal|"coordinates. change type to point or change data to an array of>0 coordinates"
argument_list|)
throw|;
block|}
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"No data provided for multipoint object when expecting "
operator|+
literal|">0 points (e.g., [[lat, lng]] or [[lat, lng], ...])"
argument_list|)
throw|;
block|}
else|else
block|{
for|for
control|(
name|CoordinateNode
name|point
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|validatePointNode
argument_list|(
name|point
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|parseMultiPoint
specifier|protected
specifier|static
name|MultiPointBuilder
name|parseMultiPoint
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
name|validateMultiPointNode
argument_list|(
name|coordinates
argument_list|)
expr_stmt|;
name|MultiPointBuilder
name|points
init|=
operator|new
name|MultiPointBuilder
argument_list|()
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|points
operator|.
name|point
argument_list|(
name|node
operator|.
name|coordinate
argument_list|)
expr_stmt|;
block|}
return|return
name|points
return|;
block|}
DECL|method|parseLineString
specifier|protected
specifier|static
name|LineStringBuilder
name|parseLineString
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
comment|/**              * Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)              * "coordinates" member must be an array of two or more positions              * LineStringBuilder should throw a graceful exception if< 2 coordinates/points are provided              */
if|if
condition|(
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Invalid number of points in LineString (found "
operator|+
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|+
literal|" - must be>= 2)"
argument_list|)
throw|;
block|}
name|LineStringBuilder
name|line
init|=
name|newLineString
argument_list|()
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|line
operator|.
name|point
argument_list|(
name|node
operator|.
name|coordinate
argument_list|)
expr_stmt|;
block|}
return|return
name|line
return|;
block|}
DECL|method|parseMultiLine
specifier|protected
specifier|static
name|MultiLineStringBuilder
name|parseMultiLine
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
name|MultiLineStringBuilder
name|multiline
init|=
name|newMultiLinestring
argument_list|()
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|multiline
operator|.
name|linestring
argument_list|(
name|parseLineString
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|multiline
return|;
block|}
DECL|method|parseLinearRing
specifier|protected
specifier|static
name|LineStringBuilder
name|parseLinearRing
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|)
block|{
comment|/**              * Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)              * A LinearRing is closed LineString with 4 or more positions. The first and last positions              * are equivalent (they represent equivalent points). Though a LinearRing is not explicitly              * represented as a GeoJSON geometry type, it is referred to in the Polygon geometry type definition.              */
if|if
condition|(
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|<
literal|4
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Invalid number of points in LinearRing (found "
operator|+
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|+
literal|" - must be>= 4)"
argument_list|)
throw|;
block|}
elseif|else
if|if
condition|(
operator|!
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
operator|.
name|coordinate
operator|.
name|equals
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
operator|.
name|coordinate
argument_list|)
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Invalid LinearRing found (coordinates are not closed)"
argument_list|)
throw|;
block|}
return|return
name|parseLineString
argument_list|(
name|coordinates
argument_list|)
return|;
block|}
DECL|method|parsePolygon
specifier|protected
specifier|static
name|PolygonBuilder
name|parsePolygon
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
block|{
if|if
condition|(
name|coordinates
operator|.
name|children
operator|==
literal|null
operator|||
name|coordinates
operator|.
name|children
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Invalid LinearRing provided for type polygon. Linear ring must be an array of "
operator|+
literal|"coordinates"
argument_list|)
throw|;
block|}
name|LineStringBuilder
name|shell
init|=
name|parseLinearRing
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|PolygonBuilder
name|polygon
init|=
operator|new
name|PolygonBuilder
argument_list|(
name|shell
operator|.
name|points
argument_list|,
name|orientation
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|coordinates
operator|.
name|children
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|polygon
operator|.
name|hole
argument_list|(
name|parseLinearRing
argument_list|(
name|coordinates
operator|.
name|children
operator|.
name|get
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|polygon
return|;
block|}
DECL|method|parseMultiPolygon
specifier|protected
specifier|static
name|MultiPolygonBuilder
name|parseMultiPolygon
parameter_list|(
name|CoordinateNode
name|coordinates
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
block|{
name|MultiPolygonBuilder
name|polygons
init|=
name|newMultiPolygon
argument_list|(
name|orientation
argument_list|)
decl_stmt|;
for|for
control|(
name|CoordinateNode
name|node
range|:
name|coordinates
operator|.
name|children
control|)
block|{
name|polygons
operator|.
name|polygon
argument_list|(
name|parsePolygon
argument_list|(
name|node
argument_list|,
name|orientation
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|polygons
return|;
block|}
comment|/**          * Parse the geometries array of a GeometryCollection          *          * @param parser Parser that will be read from          * @return Geometry[] geometries of the GeometryCollection          * @throws IOException Thrown if an error occurs while reading from the XContentParser          */
DECL|method|parseGeometries
specifier|protected
specifier|static
name|GeometryCollectionBuilder
name|parseGeometries
parameter_list|(
name|XContentParser
name|parser
parameter_list|,
name|Orientation
name|orientation
parameter_list|)
throws|throws
name|IOException
block|{
if|if
condition|(
name|parser
operator|.
name|currentToken
argument_list|()
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|START_ARRAY
condition|)
block|{
throw|throw
operator|new
name|ElasticsearchParseException
argument_list|(
literal|"Geometries must be an array of geojson objects"
argument_list|)
throw|;
block|}
name|XContentParser
operator|.
name|Token
name|token
init|=
name|parser
operator|.
name|nextToken
argument_list|()
decl_stmt|;
name|GeometryCollectionBuilder
name|geometryCollection
init|=
name|newGeometryCollection
argument_list|(
name|orientation
argument_list|)
decl_stmt|;
while|while
condition|(
name|token
operator|!=
name|XContentParser
operator|.
name|Token
operator|.
name|END_ARRAY
condition|)
block|{
name|ShapeBuilder
name|shapeBuilder
init|=
name|GeoShapeType
operator|.
name|parse
argument_list|(
name|parser
argument_list|)
decl_stmt|;
name|geometryCollection
operator|.
name|shape
argument_list|(
name|shapeBuilder
argument_list|)
expr_stmt|;
name|token
operator|=
name|parser
operator|.
name|nextToken
argument_list|()
expr_stmt|;
block|}
return|return
name|geometryCollection
return|;
block|}
block|}
block|}
end_class

end_unit

