begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_package
DECL|package|org.elasticsearch.common.compress.lzf.impl
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|lzf
operator|.
name|impl
package|;
end_package

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|lzf
operator|.
name|ChunkDecoder
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|compress
operator|.
name|lzf
operator|.
name|LZFChunk
import|;
end_import

begin_import
import|import
name|sun
operator|.
name|misc
operator|.
name|Unsafe
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|InputStream
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
import|;
end_import

begin_comment
comment|/**  * Highly optimized {@link ChunkDecoder} implementation that uses  * Sun JDK's Unsafe class (which may be included by other JDK's as well;  * IBM's apparently does).  *<p/>  * Credits for the idea go to Dain Sundstrom, who kindly suggested this use,  * and is all-around great source for optimization tips and tricks.  */
end_comment

begin_class
annotation|@
name|SuppressWarnings
argument_list|(
literal|"restriction"
argument_list|)
DECL|class|UnsafeChunkDecoder
specifier|public
class|class
name|UnsafeChunkDecoder
extends|extends
name|ChunkDecoder
block|{
DECL|field|unsafe
specifier|private
specifier|static
specifier|final
name|Unsafe
name|unsafe
decl_stmt|;
static|static
block|{
try|try
block|{
name|Field
name|theUnsafe
init|=
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|theUnsafe
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|unsafe
operator|=
operator|(
name|Unsafe
operator|)
name|theUnsafe
operator|.
name|get
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
DECL|field|BYTE_ARRAY_OFFSET
specifier|private
specifier|static
specifier|final
name|long
name|BYTE_ARRAY_OFFSET
init|=
name|unsafe
operator|.
name|arrayBaseOffset
argument_list|(
name|byte
index|[]
operator|.
expr|class
argument_list|)
decl_stmt|;
comment|//    private static final long SHORT_ARRAY_OFFSET = unsafe.arrayBaseOffset(short[].class);
comment|//    private static final long SHORT_ARRAY_STRIDE = unsafe.arrayIndexScale(short[].class);
DECL|method|UnsafeChunkDecoder
specifier|public
name|UnsafeChunkDecoder
parameter_list|()
block|{     }
annotation|@
name|Override
DECL|method|decodeChunk
specifier|public
specifier|final
name|int
name|decodeChunk
parameter_list|(
specifier|final
name|InputStream
name|is
parameter_list|,
specifier|final
name|byte
index|[]
name|inputBuffer
parameter_list|,
specifier|final
name|byte
index|[]
name|outputBuffer
parameter_list|)
throws|throws
name|IOException
block|{
name|int
name|bytesInOutput
decl_stmt|;
comment|/* note: we do NOT read more than 5 bytes because otherwise might need to shuffle bytes          * for output buffer (could perhaps optimize in future?)          */
name|int
name|bytesRead
init|=
name|readHeader
argument_list|(
name|is
argument_list|,
name|inputBuffer
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|bytesRead
operator|<
name|HEADER_BYTES
operator|)
operator|||
name|inputBuffer
index|[
literal|0
index|]
operator|!=
name|LZFChunk
operator|.
name|BYTE_Z
operator|||
name|inputBuffer
index|[
literal|1
index|]
operator|!=
name|LZFChunk
operator|.
name|BYTE_V
condition|)
block|{
if|if
condition|(
name|bytesRead
operator|==
literal|0
condition|)
block|{
comment|// probably fine, clean EOF
return|return
operator|-
literal|1
return|;
block|}
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupt input data, block did not start with 2 byte signature ('ZV') followed by type byte, 2-byte length)"
argument_list|)
throw|;
block|}
name|int
name|type
init|=
name|inputBuffer
index|[
literal|2
index|]
decl_stmt|;
name|int
name|compLen
init|=
name|uint16
argument_list|(
name|inputBuffer
argument_list|,
literal|3
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|LZFChunk
operator|.
name|BLOCK_TYPE_NON_COMPRESSED
condition|)
block|{
comment|// uncompressed
name|readFully
argument_list|(
name|is
argument_list|,
literal|false
argument_list|,
name|outputBuffer
argument_list|,
literal|0
argument_list|,
name|compLen
argument_list|)
expr_stmt|;
name|bytesInOutput
operator|=
name|compLen
expr_stmt|;
block|}
else|else
block|{
comment|// compressed
name|readFully
argument_list|(
name|is
argument_list|,
literal|true
argument_list|,
name|inputBuffer
argument_list|,
literal|0
argument_list|,
literal|2
operator|+
name|compLen
argument_list|)
expr_stmt|;
comment|// first 2 bytes are uncompressed length
name|int
name|uncompLen
init|=
name|uint16
argument_list|(
name|inputBuffer
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|decodeChunk
argument_list|(
name|inputBuffer
argument_list|,
literal|2
argument_list|,
name|outputBuffer
argument_list|,
literal|0
argument_list|,
name|uncompLen
argument_list|)
expr_stmt|;
name|bytesInOutput
operator|=
name|uncompLen
expr_stmt|;
block|}
return|return
name|bytesInOutput
return|;
block|}
annotation|@
name|Override
DECL|method|decodeChunk
specifier|public
specifier|final
name|void
name|decodeChunk
parameter_list|(
name|byte
index|[]
name|in
parameter_list|,
name|int
name|inPos
parameter_list|,
name|byte
index|[]
name|out
parameter_list|,
name|int
name|outPos
parameter_list|,
name|int
name|outEnd
parameter_list|)
throws|throws
name|IOException
block|{
name|main_loop
label|:
do|do
block|{
name|int
name|ctrl
init|=
name|in
index|[
name|inPos
operator|++
index|]
operator|&
literal|255
decl_stmt|;
while|while
condition|(
name|ctrl
operator|<
name|LZFChunk
operator|.
name|MAX_LITERAL
condition|)
block|{
comment|// literal run(s)
name|copyUpTo32
argument_list|(
name|in
argument_list|,
name|inPos
argument_list|,
name|out
argument_list|,
name|outPos
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
operator|++
name|ctrl
expr_stmt|;
name|inPos
operator|+=
name|ctrl
expr_stmt|;
name|outPos
operator|+=
name|ctrl
expr_stmt|;
if|if
condition|(
name|outPos
operator|>=
name|outEnd
condition|)
block|{
break|break
name|main_loop
break|;
block|}
name|ctrl
operator|=
name|in
index|[
name|inPos
operator|++
index|]
operator|&
literal|255
expr_stmt|;
block|}
comment|// back reference
name|int
name|len
init|=
name|ctrl
operator|>>
literal|5
decl_stmt|;
name|ctrl
operator|=
operator|-
operator|(
operator|(
name|ctrl
operator|&
literal|0x1f
operator|)
operator|<<
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
comment|// short back reference? 2 bytes; run lengths of 2 - 8 bytes
if|if
condition|(
name|len
operator|<
literal|7
condition|)
block|{
name|ctrl
operator|-=
name|in
index|[
name|inPos
operator|++
index|]
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|ctrl
operator|<
operator|-
literal|7
condition|)
block|{
comment|// non-overlapping? can use efficient bulk copy
name|moveLong
argument_list|(
name|out
argument_list|,
name|outPos
argument_list|,
name|outEnd
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|outPos
operator|+=
name|len
operator|+
literal|2
expr_stmt|;
continue|continue;
block|}
comment|// otherwise, byte-by-byte
name|outPos
operator|=
name|copyOverlappingShort
argument_list|(
name|out
argument_list|,
name|outPos
argument_list|,
name|ctrl
argument_list|,
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// long back reference: 3 bytes, length of up to 264 bytes
name|len
operator|=
name|in
index|[
name|inPos
operator|++
index|]
operator|&
literal|255
expr_stmt|;
name|ctrl
operator|-=
name|in
index|[
name|inPos
operator|++
index|]
operator|&
literal|255
expr_stmt|;
comment|// First: ovelapping case can't use default handling, off line:
if|if
condition|(
operator|(
name|ctrl
operator|+
name|len
operator|)
operator|>=
operator|-
literal|9
condition|)
block|{
name|outPos
operator|=
name|copyOverlappingLong
argument_list|(
name|out
argument_list|,
name|outPos
argument_list|,
name|ctrl
argument_list|,
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// but non-overlapping is simple
name|len
operator|+=
literal|9
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|32
condition|)
block|{
name|copyUpTo32
argument_list|(
name|out
argument_list|,
name|outPos
operator|+
name|ctrl
argument_list|,
name|out
argument_list|,
name|outPos
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|out
argument_list|,
name|outPos
operator|+
name|ctrl
argument_list|,
name|out
argument_list|,
name|outPos
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|outPos
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|outPos
operator|<
name|outEnd
condition|)
do|;
comment|// sanity check to guard against corrupt data:
if|if
condition|(
name|outPos
operator|!=
name|outEnd
condition|)
throw|throw
operator|new
name|IOException
argument_list|(
literal|"Corrupt data: overrun in decompress, input offset "
operator|+
name|inPos
operator|+
literal|", output offset "
operator|+
name|outPos
argument_list|)
throw|;
block|}
comment|/*    ///////////////////////////////////////////////////////////////////////    // Internal methods    ///////////////////////////////////////////////////////////////////////     */
DECL|method|copyOverlappingShort
specifier|private
specifier|final
name|int
name|copyOverlappingShort
parameter_list|(
specifier|final
name|byte
index|[]
name|out
parameter_list|,
name|int
name|outPos
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|6
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
case|case
literal|5
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
case|case
literal|4
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
case|case
literal|3
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
case|case
literal|2
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
case|case
literal|1
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
block|}
return|return
name|outPos
return|;
block|}
DECL|method|copyOverlappingLong
specifier|private
specifier|final
specifier|static
name|int
name|copyOverlappingLong
parameter_list|(
specifier|final
name|byte
index|[]
name|out
parameter_list|,
name|int
name|outPos
parameter_list|,
specifier|final
name|int
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|// otherwise manual copy: so first just copy 9 bytes we know are needed
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
comment|// then loop
comment|// Odd: after extensive profiling, looks like magic number
comment|// for unrolling is 4: with 8 performance is worse (even
comment|// bit less than with no unrolling).
name|len
operator|+=
name|outPos
expr_stmt|;
specifier|final
name|int
name|end
init|=
name|len
operator|-
literal|3
decl_stmt|;
while|while
condition|(
name|outPos
operator|<
name|end
condition|)
block|{
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
block|}
switch|switch
condition|(
name|len
operator|-
name|outPos
condition|)
block|{
case|case
literal|3
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
case|case
literal|2
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
case|case
literal|1
case|:
name|out
index|[
name|outPos
index|]
operator|=
name|out
index|[
name|outPos
operator|++
operator|+
name|offset
index|]
expr_stmt|;
block|}
return|return
name|outPos
return|;
block|}
comment|/* Note: 'delta' is negative (back ref); dataEnd is the first location AFTER      * end of expected uncompressed data (i.e. end marker)      */
DECL|method|moveLong
specifier|private
specifier|final
specifier|static
name|void
name|moveLong
parameter_list|(
name|byte
index|[]
name|data
parameter_list|,
name|int
name|resultOffset
parameter_list|,
name|int
name|dataEnd
parameter_list|,
name|int
name|delta
parameter_list|)
block|{
if|if
condition|(
operator|(
name|resultOffset
operator|+
literal|8
operator|)
operator|<
name|dataEnd
condition|)
block|{
specifier|final
name|long
name|rawOffset
init|=
name|BYTE_ARRAY_OFFSET
operator|+
name|resultOffset
decl_stmt|;
name|long
name|value
init|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|data
argument_list|,
name|rawOffset
operator|+
name|delta
argument_list|)
decl_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|data
argument_list|,
name|rawOffset
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|System
operator|.
name|arraycopy
argument_list|(
name|data
argument_list|,
name|resultOffset
operator|+
name|delta
argument_list|,
name|data
argument_list|,
name|resultOffset
argument_list|,
name|data
operator|.
name|length
operator|-
name|resultOffset
argument_list|)
expr_stmt|;
block|}
DECL|method|copyUpTo32
specifier|private
specifier|final
specifier|static
name|void
name|copyUpTo32
parameter_list|(
name|byte
index|[]
name|in
parameter_list|,
name|int
name|inputIndex
parameter_list|,
name|byte
index|[]
name|out
parameter_list|,
name|int
name|outputIndex
parameter_list|,
name|int
name|lengthMinusOne
parameter_list|)
block|{
if|if
condition|(
operator|(
name|outputIndex
operator|+
literal|32
operator|)
operator|>
name|out
operator|.
name|length
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|in
argument_list|,
name|inputIndex
argument_list|,
name|out
argument_list|,
name|outputIndex
argument_list|,
name|lengthMinusOne
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|long
name|inPtr
init|=
name|BYTE_ARRAY_OFFSET
operator|+
name|inputIndex
decl_stmt|;
name|long
name|outPtr
init|=
name|BYTE_ARRAY_OFFSET
operator|+
name|outputIndex
decl_stmt|;
switch|switch
condition|(
name|lengthMinusOne
operator|>>>
literal|3
condition|)
block|{
case|case
literal|3
case|:
block|{
name|long
name|value
init|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
decl_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|inPtr
operator|+=
literal|8
expr_stmt|;
name|outPtr
operator|+=
literal|8
expr_stmt|;
name|value
operator|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
expr_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|inPtr
operator|+=
literal|8
expr_stmt|;
name|outPtr
operator|+=
literal|8
expr_stmt|;
name|value
operator|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
expr_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|inPtr
operator|+=
literal|8
expr_stmt|;
name|outPtr
operator|+=
literal|8
expr_stmt|;
name|value
operator|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
expr_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|long
name|value
init|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
decl_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|inPtr
operator|+=
literal|8
expr_stmt|;
name|outPtr
operator|+=
literal|8
expr_stmt|;
name|value
operator|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
expr_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|inPtr
operator|+=
literal|8
expr_stmt|;
name|outPtr
operator|+=
literal|8
expr_stmt|;
name|value
operator|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
expr_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
block|{
name|long
name|value
init|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
decl_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|inPtr
operator|+=
literal|8
expr_stmt|;
name|outPtr
operator|+=
literal|8
expr_stmt|;
name|value
operator|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
expr_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
block|{
name|long
name|value
init|=
name|unsafe
operator|.
name|getLong
argument_list|(
name|in
argument_list|,
name|inPtr
argument_list|)
decl_stmt|;
name|unsafe
operator|.
name|putLong
argument_list|(
name|out
argument_list|,
name|outPtr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

