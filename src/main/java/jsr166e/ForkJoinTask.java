begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|// Rev 1.16 from http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/ForkJoinTask.java?view=co
end_comment

begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|RandomAccess
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|WeakReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|ref
operator|.
name|ReferenceQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RunnableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Constructor
import|;
end_import

begin_comment
comment|/**  * Abstract base class for tasks that run within a {@link ForkJoinPool}.  * A {@code ForkJoinTask} is a thread-like entity that is much  * lighter weight than a normal thread.  Huge numbers of tasks and  * subtasks may be hosted by a small number of actual threads in a  * ForkJoinPool, at the price of some usage limitations.  *  *<p>A "main" {@code ForkJoinTask} begins execution when it is  * explicitly submitted to a {@link ForkJoinPool}, or, if not already  * engaged in a ForkJoin computation, commenced in the {@link  * ForkJoinPool#commonPool()} via {@link #fork}, {@link #invoke}, or  * related methods.  Once started, it will usually in turn start other  * subtasks.  As indicated by the name of this class, many programs  * using {@code ForkJoinTask} employ only methods {@link #fork} and  * {@link #join}, or derivatives such as {@link  * #invokeAll(ForkJoinTask...) invokeAll}.  However, this class also  * provides a number of other methods that can come into play in  * advanced usages, as well as extension mechanics that allow support  * of new forms of fork/join processing.  *  *<p>A {@code ForkJoinTask} is a lightweight form of {@link Future}.  * The efficiency of {@code ForkJoinTask}s stems from a set of  * restrictions (that are only partially statically enforceable)  * reflecting their main use as computational tasks calculating pure  * functions or operating on purely isolated objects.  The primary  * coordination mechanisms are {@link #fork}, that arranges  * asynchronous execution, and {@link #join}, that doesn't proceed  * until the task's result has been computed.  Computations should  * ideally avoid {@code synchronized} methods or blocks, and should  * minimize other blocking synchronization apart from joining other  * tasks or using synchronizers such as Phasers that are advertised to  * cooperate with fork/join scheduling. Subdividable tasks should also  * not perform blocking I/O, and should ideally access variables that  * are completely independent of those accessed by other running  * tasks. These guidelines are loosely enforced by not permitting  * checked exceptions such as {@code IOExceptions} to be  * thrown. However, computations may still encounter unchecked  * exceptions, that are rethrown to callers attempting to join  * them. These exceptions may additionally include {@link  * RejectedExecutionException} stemming from internal resource  * exhaustion, such as failure to allocate internal task  * queues. Rethrown exceptions behave in the same way as regular  * exceptions, but, when possible, contain stack traces (as displayed  * for example using {@code ex.printStackTrace()}) of both the thread  * that initiated the computation as well as the thread actually  * encountering the exception; minimally only the latter.  *  *<p>It is possible to define and use ForkJoinTasks that may block,  * but doing do requires three further considerations: (1) Completion  * of few if any<em>other</em> tasks should be dependent on a task  * that blocks on external synchronization or I/O. Event-style async  * tasks that are never joined (for example, those subclassing {@link  * CountedCompleter}) often fall into this category.  (2) To minimize  * resource impact, tasks should be small; ideally performing only the  * (possibly) blocking action. (3) Unless the {@link  * ForkJoinPool.ManagedBlocker} API is used, or the number of possibly  * blocked tasks is known to be less than the pool's {@link  * ForkJoinPool#getParallelism} level, the pool cannot guarantee that  * enough threads will be available to ensure progress or good  * performance.  *  *<p>The primary method for awaiting completion and extracting  * results of a task is {@link #join}, but there are several variants:  * The {@link Future#get} methods support interruptible and/or timed  * waits for completion and report results using {@code Future}  * conventions. Method {@link #invoke} is semantically  * equivalent to {@code fork(); join()} but always attempts to begin  * execution in the current thread. The "<em>quiet</em>" forms of  * these methods do not extract results or report exceptions. These  * may be useful when a set of tasks are being executed, and you need  * to delay processing of results or exceptions until all complete.  * Method {@code invokeAll} (available in multiple versions)  * performs the most common form of parallel invocation: forking a set  * of tasks and joining them all.  *  *<p>In the most typical usages, a fork-join pair act like a call  * (fork) and return (join) from a parallel recursive function. As is  * the case with other forms of recursive calls, returns (joins)  * should be performed innermost-first. For example, {@code a.fork();  * b.fork(); b.join(); a.join();} is likely to be substantially more  * efficient than joining {@code a} before {@code b}.  *  *<p>The execution status of tasks may be queried at several levels  * of detail: {@link #isDone} is true if a task completed in any way  * (including the case where a task was cancelled without executing);  * {@link #isCompletedNormally} is true if a task completed without  * cancellation or encountering an exception; {@link #isCancelled} is  * true if the task was cancelled (in which case {@link #getException}  * returns a {@link java.util.concurrent.CancellationException}); and  * {@link #isCompletedAbnormally} is true if a task was either  * cancelled or encountered an exception, in which case {@link  * #getException} will return either the encountered exception or  * {@link java.util.concurrent.CancellationException}.  *  *<p>The ForkJoinTask class is not usually directly subclassed.  * Instead, you subclass one of the abstract classes that support a  * particular style of fork/join processing, typically {@link  * RecursiveAction} for most computations that do not return results,  * {@link RecursiveTask} for those that do, and {@link  * CountedCompleter} for those in which completed actions trigger  * other actions.  Normally, a concrete ForkJoinTask subclass declares  * fields comprising its parameters, established in a constructor, and  * then defines a {@code compute} method that somehow uses the control  * methods supplied by this base class.  *  *<p>Method {@link #join} and its variants are appropriate for use  * only when completion dependencies are acyclic; that is, the  * parallel computation can be described as a directed acyclic graph  * (DAG). Otherwise, executions may encounter a form of deadlock as  * tasks cyclically wait for each other.  However, this framework  * supports other methods and techniques (for example the use of  * {@link java.util.concurrent.Phaser Phaser}, {@link #helpQuiesce}, and {@link #complete}) that  * may be of use in constructing custom subclasses for problems that  * are not statically structured as DAGs. To support such usages, a  * ForkJoinTask may be atomically<em>tagged</em> with a {@code short}  * value using {@link #setForkJoinTaskTag} or {@link  * #compareAndSetForkJoinTaskTag} and checked using {@link  * #getForkJoinTaskTag}. The ForkJoinTask implementation does not use  * these {@code protected} methods or tags for any purpose, but they  * may be of use in the construction of specialized subclasses.  For  * example, parallel graph traversals can use the supplied methods to  * avoid revisiting nodes/tasks that have already been processed.  * (Method names for tagging are bulky in part to encourage definition  * of methods that reflect their usage patterns.)  *  *<p>Most base support methods are {@code final}, to prevent  * overriding of implementations that are intrinsically tied to the  * underlying lightweight task scheduling framework.  Developers  * creating new basic styles of fork/join processing should minimally  * implement {@code protected} methods {@link #exec}, {@link  * #setRawResult}, and {@link #getRawResult}, while also introducing  * an abstract computational method that can be implemented in its  * subclasses, possibly relying on other {@code protected} methods  * provided by this class.  *  *<p>ForkJoinTasks should perform relatively small amounts of  * computation. Large tasks should be split into smaller subtasks,  * usually via recursive decomposition. As a very rough rule of thumb,  * a task should perform more than 100 and less than 10000 basic  * computational steps, and should avoid indefinite looping. If tasks  * are too big, then parallelism cannot improve throughput. If too  * small, then memory and internal task maintenance overhead may  * overwhelm processing.  *  *<p>This class provides {@code adapt} methods for {@link Runnable}  * and {@link Callable}, that may be of use when mixing execution of  * {@code ForkJoinTasks} with other kinds of tasks. When all tasks are  * of this form, consider using a pool constructed in<em>asyncMode</em>.  *  *<p>ForkJoinTasks are {@code Serializable}, which enables them to be  * used in extensions such as remote execution frameworks. It is  * sensible to serialize tasks only before or after, but not during,  * execution. Serialization is not relied on during execution itself.  *  * @since 1.7  * @author Doug Lea  */
end_comment

begin_class
DECL|class|ForkJoinTask
specifier|public
specifier|abstract
class|class
name|ForkJoinTask
parameter_list|<
name|V
parameter_list|>
implements|implements
name|Future
argument_list|<
name|V
argument_list|>
implements|,
name|Serializable
block|{
comment|/*      * See the internal documentation of class ForkJoinPool for a      * general implementation overview.  ForkJoinTasks are mainly      * responsible for maintaining their "status" field amidst relays      * to methods in ForkJoinWorkerThread and ForkJoinPool.      *      * The methods of this class are more-or-less layered into      * (1) basic status maintenance      * (2) execution and awaiting completion      * (3) user-level methods that additionally report results.      * This is sometimes hard to see because this file orders exported      * methods in a way that flows well in javadocs.      */
comment|/*      * The status field holds run control status bits packed into a      * single int to minimize footprint and to ensure atomicity (via      * CAS).  Status is initially zero, and takes on nonnegative      * values until completed, upon which status (anded with      * DONE_MASK) holds value NORMAL, CANCELLED, or EXCEPTIONAL. Tasks      * undergoing blocking waits by other threads have the SIGNAL bit      * set.  Completion of a stolen task with SIGNAL set awakens any      * waiters via notifyAll. Even though suboptimal for some      * purposes, we use basic builtin wait/notify to take advantage of      * "monitor inflation" in JVMs that we would otherwise need to      * emulate to avoid adding further per-task bookkeeping overhead.      * We want these monitors to be "fat", i.e., not use biasing or      * thin-lock techniques, so use some odd coding idioms that tend      * to avoid them, mainly by arranging that every synchronized      * block performs a wait, notifyAll or both.      *      * These control bits occupy only (some of) the upper half (16      * bits) of status field. The lower bits are used for user-defined      * tags.      */
comment|/** The run status of this task */
DECL|field|status
specifier|volatile
name|int
name|status
decl_stmt|;
comment|// accessed directly by pool and workers
DECL|field|DONE_MASK
specifier|static
specifier|final
name|int
name|DONE_MASK
init|=
literal|0xf0000000
decl_stmt|;
comment|// mask out non-completion bits
DECL|field|NORMAL
specifier|static
specifier|final
name|int
name|NORMAL
init|=
literal|0xf0000000
decl_stmt|;
comment|// must be negative
DECL|field|CANCELLED
specifier|static
specifier|final
name|int
name|CANCELLED
init|=
literal|0xc0000000
decl_stmt|;
comment|// must be< NORMAL
DECL|field|EXCEPTIONAL
specifier|static
specifier|final
name|int
name|EXCEPTIONAL
init|=
literal|0x80000000
decl_stmt|;
comment|// must be< CANCELLED
DECL|field|SIGNAL
specifier|static
specifier|final
name|int
name|SIGNAL
init|=
literal|0x00010000
decl_stmt|;
comment|// must be>= 1<< 16
DECL|field|SMASK
specifier|static
specifier|final
name|int
name|SMASK
init|=
literal|0x0000ffff
decl_stmt|;
comment|// short bits for tags
comment|/**      * Marks completion and wakes up threads waiting to join this      * task.      *      * @param completion one of NORMAL, CANCELLED, EXCEPTIONAL      * @return completion status on exit      */
DECL|method|setCompletion
specifier|private
name|int
name|setCompletion
parameter_list|(
name|int
name|completion
parameter_list|)
block|{
for|for
control|(
name|int
name|s
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|<
literal|0
condition|)
return|return
name|s
return|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|STATUS
argument_list|,
name|s
argument_list|,
name|s
operator||
name|completion
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|>>>
literal|16
operator|)
operator|!=
literal|0
condition|)
synchronized|synchronized
init|(
name|this
init|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
return|return
name|completion
return|;
block|}
block|}
block|}
comment|/**      * Primary execution method for stolen tasks. Unless done, calls      * exec and records status if completed, but doesn't wait for      * completion otherwise.      *      * @return status on exit from this method      */
DECL|method|doExec
specifier|final
name|int
name|doExec
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|boolean
name|completed
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
try|try
block|{
name|completed
operator|=
name|exec
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
return|return
name|setExceptionalCompletion
argument_list|(
name|rex
argument_list|)
return|;
block|}
if|if
condition|(
name|completed
condition|)
name|s
operator|=
name|setCompletion
argument_list|(
name|NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Tries to set SIGNAL status unless already completed. Used by      * ForkJoinPool. Other variants are directly incorporated into      * externalAwaitDone etc.      *      * @return true if successful      */
DECL|method|trySetSignal
specifier|final
name|boolean
name|trySetSignal
parameter_list|()
block|{
name|int
name|s
init|=
name|status
decl_stmt|;
return|return
name|s
operator|>=
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|STATUS
argument_list|,
name|s
argument_list|,
name|s
operator||
name|SIGNAL
argument_list|)
return|;
block|}
comment|/**      * Blocks a non-worker-thread until completion.      * @return status upon completion      */
DECL|method|externalAwaitDone
specifier|private
name|int
name|externalAwaitDone
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|ForkJoinPool
name|cp
init|=
name|ForkJoinPool
operator|.
name|common
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|instanceof
name|CountedCompleter
condition|)
name|s
operator|=
name|cp
operator|.
name|externalHelpComplete
argument_list|(
operator|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
operator|)
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|.
name|tryExternalUnpush
argument_list|(
name|this
argument_list|)
condition|)
name|s
operator|=
name|doExec
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
do|do
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|STATUS
argument_list|,
name|s
argument_list|,
name|s
operator||
name|SIGNAL
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
name|interrupted
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**      * Blocks a non-worker-thread until completion or interruption.      */
DECL|method|externalInterruptibleAwaitDone
specifier|private
name|int
name|externalInterruptibleAwaitDone
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|int
name|s
decl_stmt|;
name|ForkJoinPool
name|cp
init|=
name|ForkJoinPool
operator|.
name|common
decl_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
operator|&&
name|cp
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|instanceof
name|CountedCompleter
condition|)
name|cp
operator|.
name|externalHelpComplete
argument_list|(
operator|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
operator|)
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|.
name|tryExternalUnpush
argument_list|(
name|this
argument_list|)
condition|)
name|doExec
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|STATUS
argument_list|,
name|s
argument_list|,
name|s
operator||
name|SIGNAL
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
name|wait
argument_list|()
expr_stmt|;
else|else
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**      * Implementation for join, get, quietlyJoin. Directly handles      * only cases of already-completed, external wait, and      * unfork+exec.  Others are relayed to ForkJoinPool.awaitJoin.      *      * @return status upon completion      */
DECL|method|doJoin
specifier|private
name|int
name|doJoin
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|Thread
name|t
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
decl_stmt|;
name|ForkJoinPool
operator|.
name|WorkQueue
name|w
decl_stmt|;
return|return
operator|(
name|s
operator|=
name|status
operator|)
operator|<
literal|0
condition|?
name|s
else|:
operator|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
name|w
operator|=
operator|(
name|wt
operator|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|workQueue
operator|)
operator|.
name|tryUnpush
argument_list|(
name|this
argument_list|)
operator|&&
operator|(
name|s
operator|=
name|doExec
argument_list|()
operator|)
operator|<
literal|0
condition|?
name|s
else|:
name|wt
operator|.
name|pool
operator|.
name|awaitJoin
argument_list|(
name|w
argument_list|,
name|this
argument_list|)
else|:
name|externalAwaitDone
argument_list|()
return|;
block|}
comment|/**      * Implementation for invoke, quietlyInvoke.      *      * @return status upon completion      */
DECL|method|doInvoke
specifier|private
name|int
name|doInvoke
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
name|Thread
name|t
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
decl_stmt|;
return|return
operator|(
name|s
operator|=
name|doExec
argument_list|()
operator|)
operator|<
literal|0
condition|?
name|s
else|:
operator|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
name|wt
operator|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
operator|.
name|awaitJoin
argument_list|(
name|wt
operator|.
name|workQueue
argument_list|,
name|this
argument_list|)
else|:
name|externalAwaitDone
argument_list|()
return|;
block|}
comment|// Exception table support
comment|/**      * Table of exceptions thrown by tasks, to enable reporting by      * callers. Because exceptions are rare, we don't directly keep      * them with task objects, but instead use a weak ref table.  Note      * that cancellation exceptions don't appear in the table, but are      * instead recorded as status values.      *      * Note: These statics are initialized below in static block.      */
DECL|field|exceptionTable
specifier|private
specifier|static
specifier|final
name|ExceptionNode
index|[]
name|exceptionTable
decl_stmt|;
DECL|field|exceptionTableLock
specifier|private
specifier|static
specifier|final
name|ReentrantLock
name|exceptionTableLock
decl_stmt|;
DECL|field|exceptionTableRefQueue
specifier|private
specifier|static
specifier|final
name|ReferenceQueue
argument_list|<
name|Object
argument_list|>
name|exceptionTableRefQueue
decl_stmt|;
comment|/**      * Fixed capacity for exceptionTable.      */
DECL|field|EXCEPTION_MAP_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|EXCEPTION_MAP_CAPACITY
init|=
literal|32
decl_stmt|;
comment|/**      * Key-value nodes for exception table.  The chained hash table      * uses identity comparisons, full locking, and weak references      * for keys. The table has a fixed capacity because it only      * maintains task exceptions long enough for joiners to access      * them, so should never become very large for sustained      * periods. However, since we do not know when the last joiner      * completes, we must use weak references and expunge them. We do      * so on each operation (hence full locking). Also, some thread in      * any ForkJoinPool will call helpExpungeStaleExceptions when its      * pool becomes isQuiescent.      */
DECL|class|ExceptionNode
specifier|static
specifier|final
class|class
name|ExceptionNode
extends|extends
name|WeakReference
argument_list|<
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
block|{
DECL|field|ex
specifier|final
name|Throwable
name|ex
decl_stmt|;
DECL|field|next
name|ExceptionNode
name|next
decl_stmt|;
DECL|field|thrower
specifier|final
name|long
name|thrower
decl_stmt|;
comment|// use id not ref to avoid weak cycles
DECL|field|hashCode
specifier|final
name|int
name|hashCode
decl_stmt|;
comment|// store task hashCode before weak ref disappears
DECL|method|ExceptionNode
name|ExceptionNode
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|,
name|Throwable
name|ex
parameter_list|,
name|ExceptionNode
name|next
parameter_list|)
block|{
name|super
argument_list|(
name|task
argument_list|,
name|exceptionTableRefQueue
argument_list|)
expr_stmt|;
name|this
operator|.
name|ex
operator|=
name|ex
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
name|this
operator|.
name|thrower
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getId
argument_list|()
expr_stmt|;
name|this
operator|.
name|hashCode
operator|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Records exception and sets status.      *      * @return status on exit      */
DECL|method|recordExceptionalCompletion
specifier|final
name|int
name|recordExceptionalCompletion
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|int
name|h
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|ReentrantLock
name|lock
init|=
name|exceptionTableLock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|expungeStaleExceptions
argument_list|()
expr_stmt|;
name|ExceptionNode
index|[]
name|t
init|=
name|exceptionTable
decl_stmt|;
name|int
name|i
init|=
name|h
operator|&
operator|(
name|t
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|ExceptionNode
name|e
init|=
name|t
index|[
name|i
index|]
init|;
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
name|e
operator|==
literal|null
condition|)
block|{
name|t
index|[
name|i
index|]
operator|=
operator|new
name|ExceptionNode
argument_list|(
name|this
argument_list|,
name|ex
argument_list|,
name|t
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|.
name|get
argument_list|()
operator|==
name|this
condition|)
comment|// already present
break|break;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|s
operator|=
name|setCompletion
argument_list|(
name|EXCEPTIONAL
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Records exception and possibly propagates.      *      * @return status on exit      */
DECL|method|setExceptionalCompletion
specifier|private
name|int
name|setExceptionalCompletion
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|int
name|s
init|=
name|recordExceptionalCompletion
argument_list|(
name|ex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|DONE_MASK
operator|)
operator|==
name|EXCEPTIONAL
condition|)
name|internalPropagateException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
comment|/**      * Hook for exception propagation support for tasks with completers.      */
DECL|method|internalPropagateException
name|void
name|internalPropagateException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{     }
comment|/**      * Cancels, ignoring any exceptions thrown by cancel. Used during      * worker and pool shutdown. Cancel is spec'ed not to throw any      * exceptions, but if it does anyway, we have no recourse during      * shutdown, so guard against this case.      */
DECL|method|cancelIgnoringExceptions
specifier|static
specifier|final
name|void
name|cancelIgnoringExceptions
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
name|t
operator|.
name|status
operator|>=
literal|0
condition|)
block|{
try|try
block|{
name|t
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignore
parameter_list|)
block|{             }
block|}
block|}
comment|/**      * Removes exception node and clears status.      */
DECL|method|clearExceptionalCompletion
specifier|private
name|void
name|clearExceptionalCompletion
parameter_list|()
block|{
name|int
name|h
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
decl_stmt|;
specifier|final
name|ReentrantLock
name|lock
init|=
name|exceptionTableLock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|ExceptionNode
index|[]
name|t
init|=
name|exceptionTable
decl_stmt|;
name|int
name|i
init|=
name|h
operator|&
operator|(
name|t
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|ExceptionNode
name|e
init|=
name|t
index|[
name|i
index|]
decl_stmt|;
name|ExceptionNode
name|pred
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|ExceptionNode
name|next
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|get
argument_list|()
operator|==
name|this
condition|)
block|{
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
name|t
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
else|else
name|pred
operator|.
name|next
operator|=
name|next
expr_stmt|;
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
name|expungeStaleExceptions
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Returns a rethrowable exception for the given task, if      * available. To provide accurate stack traces, if the exception      * was not thrown by the current thread, we try to create a new      * exception of the same type as the one thrown, but with the      * recorded exception as its cause. If there is no such      * constructor, we instead try to use a no-arg constructor,      * followed by initCause, to the same effect. If none of these      * apply, or any fail due to other exceptions, we return the      * recorded exception, which is still correct, although it may      * contain a misleading stack trace.      *      * @return the exception, or null if none      */
DECL|method|getThrowableException
specifier|private
name|Throwable
name|getThrowableException
parameter_list|()
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|DONE_MASK
operator|)
operator|!=
name|EXCEPTIONAL
condition|)
return|return
literal|null
return|;
name|int
name|h
init|=
name|System
operator|.
name|identityHashCode
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|ExceptionNode
name|e
decl_stmt|;
specifier|final
name|ReentrantLock
name|lock
init|=
name|exceptionTableLock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|expungeStaleExceptions
argument_list|()
expr_stmt|;
name|ExceptionNode
index|[]
name|t
init|=
name|exceptionTable
decl_stmt|;
name|e
operator|=
name|t
index|[
name|h
operator|&
operator|(
name|t
operator|.
name|length
operator|-
literal|1
operator|)
index|]
expr_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
operator|&&
name|e
operator|.
name|get
argument_list|()
operator|!=
name|this
condition|)
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
operator|||
operator|(
name|ex
operator|=
name|e
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
literal|false
operator|&&
name|e
operator|.
name|thrower
operator|!=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getId
argument_list|()
condition|)
block|{
name|Class
argument_list|<
name|?
extends|extends
name|Throwable
argument_list|>
name|ec
init|=
name|ex
operator|.
name|getClass
argument_list|()
decl_stmt|;
try|try
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|noArgCtor
init|=
literal|null
decl_stmt|;
name|Constructor
argument_list|<
name|?
argument_list|>
index|[]
name|cs
init|=
name|ec
operator|.
name|getConstructors
argument_list|()
decl_stmt|;
comment|// public ctors only
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cs
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|Constructor
argument_list|<
name|?
argument_list|>
name|c
init|=
name|cs
index|[
name|i
index|]
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
index|[]
name|ps
init|=
name|c
operator|.
name|getParameterTypes
argument_list|()
decl_stmt|;
if|if
condition|(
name|ps
operator|.
name|length
operator|==
literal|0
condition|)
name|noArgCtor
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|ps
operator|.
name|length
operator|==
literal|1
operator|&&
name|ps
index|[
literal|0
index|]
operator|==
name|Throwable
operator|.
name|class
condition|)
return|return
call|(
name|Throwable
call|)
argument_list|(
name|c
operator|.
name|newInstance
argument_list|(
name|ex
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|noArgCtor
operator|!=
literal|null
condition|)
block|{
name|Throwable
name|wx
init|=
call|(
name|Throwable
call|)
argument_list|(
name|noArgCtor
operator|.
name|newInstance
argument_list|()
argument_list|)
decl_stmt|;
name|wx
operator|.
name|initCause
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
name|wx
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Exception
name|ignore
parameter_list|)
block|{             }
block|}
return|return
name|ex
return|;
block|}
comment|/**      * Poll stale refs and remove them. Call only while holding lock.      */
comment|/**      * Poll stale refs and remove them. Call only while holding lock.      */
DECL|method|expungeStaleExceptions
specifier|private
specifier|static
name|void
name|expungeStaleExceptions
parameter_list|()
block|{
for|for
control|(
name|Object
name|x
init|;
operator|(
name|x
operator|=
name|exceptionTableRefQueue
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|instanceof
name|ExceptionNode
condition|)
block|{
name|int
name|hashCode
init|=
operator|(
operator|(
name|ExceptionNode
operator|)
name|x
operator|)
operator|.
name|hashCode
decl_stmt|;
name|ExceptionNode
index|[]
name|t
init|=
name|exceptionTable
decl_stmt|;
name|int
name|i
init|=
name|hashCode
operator|&
operator|(
name|t
operator|.
name|length
operator|-
literal|1
operator|)
decl_stmt|;
name|ExceptionNode
name|e
init|=
name|t
index|[
name|i
index|]
decl_stmt|;
name|ExceptionNode
name|pred
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
name|ExceptionNode
name|next
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|x
condition|)
block|{
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
name|t
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
else|else
name|pred
operator|.
name|next
operator|=
name|next
expr_stmt|;
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * If lock is available, poll stale refs and remove them.      * Called from ForkJoinPool when pools become quiescent.      */
DECL|method|helpExpungeStaleExceptions
specifier|static
specifier|final
name|void
name|helpExpungeStaleExceptions
parameter_list|()
block|{
specifier|final
name|ReentrantLock
name|lock
init|=
name|exceptionTableLock
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|tryLock
argument_list|()
condition|)
block|{
try|try
block|{
name|expungeStaleExceptions
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * A version of "sneaky throw" to relay exceptions      */
DECL|method|rethrow
specifier|static
name|void
name|rethrow
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|ForkJoinTask
operator|.
expr|<
name|RuntimeException
operator|>
name|uncheckedThrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/**      * The sneaky part of sneaky throw, relying on generics      * limitations to evade compiler complaints about rethrowing      * unchecked exceptions      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
parameter_list|<
name|T
extends|extends
name|Throwable
parameter_list|>
DECL|method|uncheckedThrow
name|void
name|uncheckedThrow
parameter_list|(
name|Throwable
name|t
parameter_list|)
throws|throws
name|T
block|{
throw|throw
operator|(
name|T
operator|)
name|t
throw|;
comment|// rely on vacuous cast
block|}
comment|/**      * Throws exception, if any, associated with the given status.      */
DECL|method|reportException
specifier|private
name|void
name|reportException
parameter_list|(
name|int
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|==
name|CANCELLED
condition|)
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
if|if
condition|(
name|s
operator|==
name|EXCEPTIONAL
condition|)
name|rethrow
argument_list|(
name|getThrowableException
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// public methods
comment|/**      * Arranges to asynchronously execute this task in the pool the      * current task is running in, if applicable, or using the {@link      * ForkJoinPool#commonPool()} if not {@link #inForkJoinPool}.  While      * it is not necessarily enforced, it is a usage error to fork a      * task more than once unless it has completed and been      * reinitialized.  Subsequent modifications to the state of this      * task or any data it operates on are not necessarily      * consistently observable by any thread other than the one      * executing it unless preceded by a call to {@link #join} or      * related methods, or a call to {@link #isDone} returning {@code      * true}.      *      * @return {@code this}, to simplify usage      */
DECL|method|fork
specifier|public
specifier|final
name|ForkJoinTask
argument_list|<
name|V
argument_list|>
name|fork
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
condition|)
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|workQueue
operator|.
name|push
argument_list|(
name|this
argument_list|)
expr_stmt|;
else|else
name|ForkJoinPool
operator|.
name|common
operator|.
name|externalPush
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
comment|/**      * Returns the result of the computation when it {@link #isDone is      * done}.  This method differs from {@link #get()} in that      * abnormal completion results in {@code RuntimeException} or      * {@code Error}, not {@code ExecutionException}, and that      * interrupts of the calling thread do<em>not</em> cause the      * method to abruptly return by throwing {@code      * InterruptedException}.      *      * @return the computed result      */
DECL|method|join
specifier|public
specifier|final
name|V
name|join
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|doJoin
argument_list|()
operator|&
name|DONE_MASK
operator|)
operator|!=
name|NORMAL
condition|)
name|reportException
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|getRawResult
argument_list|()
return|;
block|}
comment|/**      * Commences performing this task, awaits its completion if      * necessary, and returns its result, or throws an (unchecked)      * {@code RuntimeException} or {@code Error} if the underlying      * computation did so.      *      * @return the computed result      */
DECL|method|invoke
specifier|public
specifier|final
name|V
name|invoke
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|doInvoke
argument_list|()
operator|&
name|DONE_MASK
operator|)
operator|!=
name|NORMAL
condition|)
name|reportException
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|getRawResult
argument_list|()
return|;
block|}
comment|/**      * Forks the given tasks, returning when {@code isDone} holds for      * each task or an (unchecked) exception is encountered, in which      * case the exception is rethrown. If more than one task      * encounters an exception, then this method throws any one of      * these exceptions. If any task encounters an exception, the      * other may be cancelled. However, the execution status of      * individual tasks is not guaranteed upon exceptional return. The      * status of each task may be obtained using {@link      * #getException()} and related methods to check if they have been      * cancelled, completed normally or exceptionally, or left      * unprocessed.      *      * @param t1 the first task      * @param t2 the second task      * @throws NullPointerException if any task is null      */
DECL|method|invokeAll
specifier|public
specifier|static
name|void
name|invokeAll
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t1
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t2
parameter_list|)
block|{
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|t2
operator|.
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|s1
operator|=
name|t1
operator|.
name|doInvoke
argument_list|()
operator|&
name|DONE_MASK
operator|)
operator|!=
name|NORMAL
condition|)
name|t1
operator|.
name|reportException
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|=
name|t2
operator|.
name|doJoin
argument_list|()
operator|&
name|DONE_MASK
operator|)
operator|!=
name|NORMAL
condition|)
name|t2
operator|.
name|reportException
argument_list|(
name|s2
argument_list|)
expr_stmt|;
block|}
comment|/**      * Forks the given tasks, returning when {@code isDone} holds for      * each task or an (unchecked) exception is encountered, in which      * case the exception is rethrown. If more than one task      * encounters an exception, then this method throws any one of      * these exceptions. If any task encounters an exception, others      * may be cancelled. However, the execution status of individual      * tasks is not guaranteed upon exceptional return. The status of      * each task may be obtained using {@link #getException()} and      * related methods to check if they have been cancelled, completed      * normally or exceptionally, or left unprocessed.      *      * @param tasks the tasks      * @throws NullPointerException if any task is null      */
DECL|method|invokeAll
specifier|public
specifier|static
name|void
name|invokeAll
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
modifier|...
name|tasks
parameter_list|)
block|{
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|int
name|last
init|=
name|tasks
operator|.
name|length
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|last
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|tasks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|t
operator|.
name|fork
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|.
name|doInvoke
argument_list|()
operator|<
name|NORMAL
operator|&&
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|tasks
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|t
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|.
name|doJoin
argument_list|()
operator|<
name|NORMAL
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/**      * Forks all tasks in the specified collection, returning when      * {@code isDone} holds for each task or an (unchecked) exception      * is encountered, in which case the exception is rethrown. If      * more than one task encounters an exception, then this method      * throws any one of these exceptions. If any task encounters an      * exception, others may be cancelled. However, the execution      * status of individual tasks is not guaranteed upon exceptional      * return. The status of each task may be obtained using {@link      * #getException()} and related methods to check if they have been      * cancelled, completed normally or exceptionally, or left      * unprocessed.      *      * @param tasks the collection of tasks      * @param<T> the type of the values returned from the tasks      * @return the tasks argument, to simplify usage      * @throws NullPointerException if tasks or any element are null      */
DECL|method|invokeAll
specifier|public
specifier|static
parameter_list|<
name|T
extends|extends
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
parameter_list|>
name|Collection
argument_list|<
name|T
argument_list|>
name|invokeAll
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|tasks
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|tasks
operator|instanceof
name|RandomAccess
operator|)
operator|||
operator|!
operator|(
name|tasks
operator|instanceof
name|List
argument_list|<
name|?
argument_list|>
operator|)
condition|)
block|{
name|invokeAll
argument_list|(
name|tasks
operator|.
name|toArray
argument_list|(
operator|new
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[
name|tasks
operator|.
name|size
argument_list|()
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tasks
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|List
argument_list|<
name|?
extends|extends
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
name|ts
init|=
operator|(
name|List
argument_list|<
name|?
extends|extends
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
operator|)
name|tasks
decl_stmt|;
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|int
name|last
init|=
name|ts
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|last
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|ts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|t
operator|.
name|fork
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|.
name|doInvoke
argument_list|()
operator|<
name|NORMAL
operator|&&
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
name|ts
operator|.
name|get
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|t
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|.
name|doJoin
argument_list|()
operator|<
name|NORMAL
condition|)
name|ex
operator|=
name|t
operator|.
name|getException
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
return|return
name|tasks
return|;
block|}
comment|/**      * Attempts to cancel execution of this task. This attempt will      * fail if the task has already completed or could not be      * cancelled for some other reason. If successful, and this task      * has not started when {@code cancel} is called, execution of      * this task is suppressed. After this method returns      * successfully, unless there is an intervening call to {@link      * #reinitialize}, subsequent calls to {@link #isCancelled},      * {@link #isDone}, and {@code cancel} will return {@code true}      * and calls to {@link #join} and related methods will result in      * {@code CancellationException}.      *      *<p>This method may be overridden in subclasses, but if so, must      * still ensure that these properties hold. In particular, the      * {@code cancel} method itself must not throw exceptions.      *      *<p>This method is designed to be invoked by<em>other</em>      * tasks. To terminate the current task, you can just return or      * throw an unchecked exception from its computation method, or      * invoke {@link #completeExceptionally(Throwable)}.      *      * @param mayInterruptIfRunning this value has no effect in the      * default implementation because interrupts are not used to      * control cancellation.      *      * @return {@code true} if this task is now cancelled      */
DECL|method|cancel
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
return|return
operator|(
name|setCompletion
argument_list|(
name|CANCELLED
argument_list|)
operator|&
name|DONE_MASK
operator|)
operator|==
name|CANCELLED
return|;
block|}
DECL|method|isDone
specifier|public
specifier|final
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|status
operator|<
literal|0
return|;
block|}
DECL|method|isCancelled
specifier|public
specifier|final
name|boolean
name|isCancelled
parameter_list|()
block|{
return|return
operator|(
name|status
operator|&
name|DONE_MASK
operator|)
operator|==
name|CANCELLED
return|;
block|}
comment|/**      * Returns {@code true} if this task threw an exception or was cancelled.      *      * @return {@code true} if this task threw an exception or was cancelled      */
DECL|method|isCompletedAbnormally
specifier|public
specifier|final
name|boolean
name|isCompletedAbnormally
parameter_list|()
block|{
return|return
name|status
operator|<
name|NORMAL
return|;
block|}
comment|/**      * Returns {@code true} if this task completed without throwing an      * exception and was not cancelled.      *      * @return {@code true} if this task completed without throwing an      * exception and was not cancelled      */
DECL|method|isCompletedNormally
specifier|public
specifier|final
name|boolean
name|isCompletedNormally
parameter_list|()
block|{
return|return
operator|(
name|status
operator|&
name|DONE_MASK
operator|)
operator|==
name|NORMAL
return|;
block|}
comment|/**      * Returns the exception thrown by the base computation, or a      * {@code CancellationException} if cancelled, or {@code null} if      * none or if the method has not yet completed.      *      * @return the exception, or {@code null} if none      */
DECL|method|getException
specifier|public
specifier|final
name|Throwable
name|getException
parameter_list|()
block|{
name|int
name|s
init|=
name|status
operator|&
name|DONE_MASK
decl_stmt|;
return|return
operator|(
operator|(
name|s
operator|>=
name|NORMAL
operator|)
condition|?
literal|null
else|:
operator|(
name|s
operator|==
name|CANCELLED
operator|)
condition|?
operator|new
name|CancellationException
argument_list|()
else|:
name|getThrowableException
argument_list|()
operator|)
return|;
block|}
comment|/**      * Completes this task abnormally, and if not already aborted or      * cancelled, causes it to throw the given exception upon      * {@code join} and related operations. This method may be used      * to induce exceptions in asynchronous tasks, or to force      * completion of tasks that would not otherwise complete.  Its use      * in other situations is discouraged.  This method is      * overridable, but overridden versions must invoke {@code super}      * implementation to maintain guarantees.      *      * @param ex the exception to throw. If this exception is not a      * {@code RuntimeException} or {@code Error}, the actual exception      * thrown will be a {@code RuntimeException} with cause {@code ex}.      */
DECL|method|completeExceptionally
specifier|public
name|void
name|completeExceptionally
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|setExceptionalCompletion
argument_list|(
operator|(
name|ex
operator|instanceof
name|RuntimeException
operator|)
operator|||
operator|(
name|ex
operator|instanceof
name|Error
operator|)
condition|?
name|ex
else|:
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Completes this task, and if not already aborted or cancelled,      * returning the given value as the result of subsequent      * invocations of {@code join} and related operations. This method      * may be used to provide results for asynchronous tasks, or to      * provide alternative handling for tasks that would not otherwise      * complete normally. Its use in other situations is      * discouraged. This method is overridable, but overridden      * versions must invoke {@code super} implementation to maintain      * guarantees.      *      * @param value the result value for this task      */
DECL|method|complete
specifier|public
name|void
name|complete
parameter_list|(
name|V
name|value
parameter_list|)
block|{
try|try
block|{
name|setRawResult
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|setExceptionalCompletion
argument_list|(
name|rex
argument_list|)
expr_stmt|;
return|return;
block|}
name|setCompletion
argument_list|(
name|NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/**      * Completes this task normally without setting a value. The most      * recent value established by {@link #setRawResult} (or {@code      * null} by default) will be returned as the result of subsequent      * invocations of {@code join} and related operations.      *      * @since 1.8      */
DECL|method|quietlyComplete
specifier|public
specifier|final
name|void
name|quietlyComplete
parameter_list|()
block|{
name|setCompletion
argument_list|(
name|NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/**      * Waits if necessary for the computation to complete, and then      * retrieves its result.      *      * @return the computed result      * @throws CancellationException if the computation was cancelled      * @throws ExecutionException if the computation threw an      * exception      * @throws InterruptedException if the current thread is not a      * member of a ForkJoinPool and was interrupted while waiting      */
DECL|method|get
specifier|public
specifier|final
name|V
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
name|int
name|s
init|=
operator|(
name|Thread
operator|.
name|currentThread
argument_list|()
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
name|doJoin
argument_list|()
else|:
name|externalInterruptibleAwaitDone
argument_list|()
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|&=
name|DONE_MASK
operator|)
operator|==
name|CANCELLED
condition|)
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
if|if
condition|(
name|s
operator|==
name|EXCEPTIONAL
operator|&&
operator|(
name|ex
operator|=
name|getThrowableException
argument_list|()
operator|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
return|return
name|getRawResult
argument_list|()
return|;
block|}
comment|/**      * Waits if necessary for at most the given time for the computation      * to complete, and then retrieves its result, if available.      *      * @param timeout the maximum time to wait      * @param unit the time unit of the timeout argument      * @return the computed result      * @throws CancellationException if the computation was cancelled      * @throws ExecutionException if the computation threw an      * exception      * @throws InterruptedException if the current thread is not a      * member of a ForkJoinPool and was interrupted while waiting      * @throws TimeoutException if the wait timed out      */
DECL|method|get
specifier|public
specifier|final
name|V
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
comment|// Messy in part because we measure in nanosecs, but wait in millisecs
name|int
name|s
decl_stmt|;
name|long
name|ms
decl_stmt|;
name|long
name|ns
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|ForkJoinPool
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
operator|&&
name|ns
operator|>
literal|0L
condition|)
block|{
name|long
name|deadline
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|ns
decl_stmt|;
name|ForkJoinPool
name|p
init|=
literal|null
decl_stmt|;
name|ForkJoinPool
operator|.
name|WorkQueue
name|w
init|=
literal|null
decl_stmt|;
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
condition|)
block|{
name|ForkJoinWorkerThread
name|wt
init|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
decl_stmt|;
name|p
operator|=
name|wt
operator|.
name|pool
expr_stmt|;
name|w
operator|=
name|wt
operator|.
name|workQueue
expr_stmt|;
name|p
operator|.
name|helpJoinOnce
argument_list|(
name|w
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// no retries on failure
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|ForkJoinPool
operator|.
name|common
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|this
operator|instanceof
name|CountedCompleter
condition|)
name|cp
operator|.
name|externalHelpComplete
argument_list|(
operator|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
operator|)
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|.
name|tryExternalUnpush
argument_list|(
name|this
argument_list|)
condition|)
name|doExec
argument_list|()
expr_stmt|;
block|}
name|boolean
name|canBlock
init|=
literal|false
decl_stmt|;
name|boolean
name|interrupted
init|=
literal|false
decl_stmt|;
try|try
block|{
while|while
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|qlock
operator|<
literal|0
condition|)
name|cancelIgnoringExceptions
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|canBlock
condition|)
block|{
if|if
condition|(
name|p
operator|==
literal|null
operator|||
name|p
operator|.
name|tryCompensate
argument_list|(
name|p
operator|.
name|ctl
argument_list|)
condition|)
name|canBlock
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ms
operator|=
name|TimeUnit
operator|.
name|NANOSECONDS
operator|.
name|toMillis
argument_list|(
name|ns
argument_list|)
operator|)
operator|>
literal|0L
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|STATUS
argument_list|,
name|s
argument_list|,
name|s
operator||
name|SIGNAL
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
try|try
block|{
name|wait
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|interrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|status
operator|)
operator|<
literal|0
operator|||
name|interrupted
operator|||
operator|(
name|ns
operator|=
name|deadline
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|<=
literal|0L
condition|)
break|break;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|p
operator|!=
literal|null
operator|&&
name|canBlock
condition|)
name|p
operator|.
name|incrementActiveCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|interrupted
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
if|if
condition|(
operator|(
name|s
operator|&=
name|DONE_MASK
operator|)
operator|!=
name|NORMAL
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|CANCELLED
condition|)
throw|throw
operator|new
name|CancellationException
argument_list|()
throw|;
if|if
condition|(
name|s
operator|!=
name|EXCEPTIONAL
condition|)
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|ex
operator|=
name|getThrowableException
argument_list|()
operator|)
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
return|return
name|getRawResult
argument_list|()
return|;
block|}
comment|/**      * Joins this task, without returning its result or throwing its      * exception. This method may be useful when processing      * collections of tasks when some have been cancelled or otherwise      * known to have aborted.      */
DECL|method|quietlyJoin
specifier|public
specifier|final
name|void
name|quietlyJoin
parameter_list|()
block|{
name|doJoin
argument_list|()
expr_stmt|;
block|}
comment|/**      * Commences performing this task and awaits its completion if      * necessary, without returning its result or throwing its      * exception.      */
DECL|method|quietlyInvoke
specifier|public
specifier|final
name|void
name|quietlyInvoke
parameter_list|()
block|{
name|doInvoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Possibly executes tasks until the pool hosting the current task      * {@link ForkJoinPool#isQuiescent is quiescent}. This method may      * be of use in designs in which many tasks are forked, but none      * are explicitly joined, instead executing them until all are      * processed.      */
DECL|method|helpQuiesce
specifier|public
specifier|static
name|void
name|helpQuiesce
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
condition|)
block|{
name|ForkJoinWorkerThread
name|wt
init|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
decl_stmt|;
name|wt
operator|.
name|pool
operator|.
name|helpQuiescePool
argument_list|(
name|wt
operator|.
name|workQueue
argument_list|)
expr_stmt|;
block|}
else|else
name|ForkJoinPool
operator|.
name|quiesceCommonPool
argument_list|()
expr_stmt|;
block|}
comment|/**      * Resets the internal bookkeeping state of this task, allowing a      * subsequent {@code fork}. This method allows repeated reuse of      * this task, but only if reuse occurs when this task has either      * never been forked, or has been forked, then completed and all      * outstanding joins of this task have also completed. Effects      * under any other usage conditions are not guaranteed.      * This method may be useful when executing      * pre-constructed trees of subtasks in loops.      *      *<p>Upon completion of this method, {@code isDone()} reports      * {@code false}, and {@code getException()} reports {@code      * null}. However, the value returned by {@code getRawResult} is      * unaffected. To clear this value, you can invoke {@code      * setRawResult(null)}.      */
DECL|method|reinitialize
specifier|public
name|void
name|reinitialize
parameter_list|()
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|DONE_MASK
operator|)
operator|==
name|EXCEPTIONAL
condition|)
name|clearExceptionalCompletion
argument_list|()
expr_stmt|;
else|else
name|status
operator|=
literal|0
expr_stmt|;
block|}
comment|/**      * Returns the pool hosting the current task execution, or null      * if this task is executing outside of any ForkJoinPool.      *      * @see #inForkJoinPool      * @return the pool, or {@code null} if none      */
DECL|method|getPool
specifier|public
specifier|static
name|ForkJoinPool
name|getPool
parameter_list|()
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
return|return
operator|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
else|:
literal|null
return|;
block|}
comment|/**      * Returns {@code true} if the current thread is a {@link      * ForkJoinWorkerThread} executing as a ForkJoinPool computation.      *      * @return {@code true} if the current thread is a {@link      * ForkJoinWorkerThread} executing as a ForkJoinPool computation,      * or {@code false} otherwise      */
DECL|method|inForkJoinPool
specifier|public
specifier|static
name|boolean
name|inForkJoinPool
parameter_list|()
block|{
return|return
name|Thread
operator|.
name|currentThread
argument_list|()
operator|instanceof
name|ForkJoinWorkerThread
return|;
block|}
comment|/**      * Tries to unschedule this task for execution. This method will      * typically (but is not guaranteed to) succeed if this task is      * the most recently forked task by the current thread, and has      * not commenced executing in another thread.  This method may be      * useful when arranging alternative local processing of tasks      * that could have been, but were not, stolen.      *      * @return {@code true} if unforked      */
DECL|method|tryUnfork
specifier|public
name|boolean
name|tryUnfork
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|workQueue
operator|.
name|tryUnpush
argument_list|(
name|this
argument_list|)
else|:
name|ForkJoinPool
operator|.
name|common
operator|.
name|tryExternalUnpush
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns an estimate of the number of tasks that have been      * forked by the current worker thread but not yet executed. This      * value may be useful for heuristic decisions about whether to      * fork other tasks.      *      * @return the number of tasks      */
DECL|method|getQueuedTaskCount
specifier|public
specifier|static
name|int
name|getQueuedTaskCount
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
name|ForkJoinPool
operator|.
name|WorkQueue
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
condition|)
name|q
operator|=
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|workQueue
expr_stmt|;
else|else
name|q
operator|=
name|ForkJoinPool
operator|.
name|commonSubmitterQueue
argument_list|()
expr_stmt|;
return|return
operator|(
name|q
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|q
operator|.
name|queueSize
argument_list|()
return|;
block|}
comment|/**      * Returns an estimate of how many more locally queued tasks are      * held by the current worker thread than there are other worker      * threads that might steal them, or zero if this thread is not      * operating in a ForkJoinPool. This value may be useful for      * heuristic decisions about whether to fork other tasks. In many      * usages of ForkJoinTasks, at steady state, each worker should      * aim to maintain a small constant surplus (for example, 3) of      * tasks, and to process computations locally if this threshold is      * exceeded.      *      * @return the surplus number of tasks, which may be negative      */
DECL|method|getSurplusQueuedTaskCount
specifier|public
specifier|static
name|int
name|getSurplusQueuedTaskCount
parameter_list|()
block|{
return|return
name|ForkJoinPool
operator|.
name|getSurplusQueuedTaskCount
argument_list|()
return|;
block|}
comment|// Extension methods
comment|/**      * Returns the result that would be returned by {@link #join}, even      * if this task completed abnormally, or {@code null} if this task      * is not known to have been completed.  This method is designed      * to aid debugging, as well as to support extensions. Its use in      * any other context is discouraged.      *      * @return the result, or {@code null} if not completed      */
DECL|method|getRawResult
specifier|public
specifier|abstract
name|V
name|getRawResult
parameter_list|()
function_decl|;
comment|/**      * Forces the given value to be returned as a result.  This method      * is designed to support extensions, and should not in general be      * called otherwise.      *      * @param value the value      */
DECL|method|setRawResult
specifier|protected
specifier|abstract
name|void
name|setRawResult
parameter_list|(
name|V
name|value
parameter_list|)
function_decl|;
comment|/**      * Immediately performs the base action of this task and returns      * true if, upon return from this method, this task is guaranteed      * to have completed normally. This method may return false      * otherwise, to indicate that this task is not necessarily      * complete (or is not known to be complete), for example in      * asynchronous actions that require explicit invocations of      * completion methods. This method may also throw an (unchecked)      * exception to indicate abnormal exit. This method is designed to      * support extensions, and should not in general be called      * otherwise.      *      * @return {@code true} if this task is known to have completed normally      */
DECL|method|exec
specifier|protected
specifier|abstract
name|boolean
name|exec
parameter_list|()
function_decl|;
comment|/**      * Returns, but does not unschedule or execute, a task queued by      * the current thread but not yet executed, if one is immediately      * available. There is no guarantee that this task will actually      * be polled or executed next. Conversely, this method may return      * null even if a task exists but cannot be accessed without      * contention with other threads.  This method is designed      * primarily to support extensions, and is unlikely to be useful      * otherwise.      *      * @return the next task, or {@code null} if none are available      */
DECL|method|peekNextLocalTask
specifier|protected
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|peekNextLocalTask
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
name|ForkJoinPool
operator|.
name|WorkQueue
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
condition|)
name|q
operator|=
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|workQueue
expr_stmt|;
else|else
name|q
operator|=
name|ForkJoinPool
operator|.
name|commonSubmitterQueue
argument_list|()
expr_stmt|;
return|return
operator|(
name|q
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|q
operator|.
name|peek
argument_list|()
return|;
block|}
comment|/**      * Unschedules and returns, without executing, the next task      * queued by the current thread but not yet executed, if the      * current thread is operating in a ForkJoinPool.  This method is      * designed primarily to support extensions, and is unlikely to be      * useful otherwise.      *      * @return the next task, or {@code null} if none are available      */
DECL|method|pollNextLocalTask
specifier|protected
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollNextLocalTask
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
return|return
operator|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|workQueue
operator|.
name|nextLocalTask
argument_list|()
else|:
literal|null
return|;
block|}
comment|/**      * If the current thread is operating in a ForkJoinPool,      * unschedules and returns, without executing, the next task      * queued by the current thread but not yet executed, if one is      * available, or if not available, a task that was forked by some      * other thread, if available. Availability may be transient, so a      * {@code null} result does not necessarily imply quiescence of      * the pool this task is operating in.  This method is designed      * primarily to support extensions, and is unlikely to be useful      * otherwise.      *      * @return a task, or {@code null} if none are available      */
DECL|method|pollTask
specifier|protected
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollTask
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
decl_stmt|;
return|return
operator|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
name|wt
operator|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
operator|.
name|nextTaskFor
argument_list|(
name|wt
operator|.
name|workQueue
argument_list|)
else|:
literal|null
return|;
block|}
comment|// tag operations
comment|/**      * Returns the tag for this task.      *      * @return the tag for this task      * @since 1.8      */
DECL|method|getForkJoinTaskTag
specifier|public
specifier|final
name|short
name|getForkJoinTaskTag
parameter_list|()
block|{
return|return
operator|(
name|short
operator|)
name|status
return|;
block|}
comment|/**      * Atomically sets the tag value for this task.      *      * @param tag the tag value      * @return the previous value of the tag      * @since 1.8      */
DECL|method|setForkJoinTaskTag
specifier|public
specifier|final
name|short
name|setForkJoinTaskTag
parameter_list|(
name|short
name|tag
parameter_list|)
block|{
for|for
control|(
name|int
name|s
init|;
condition|;
control|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|STATUS
argument_list|,
name|s
operator|=
name|status
argument_list|,
operator|(
name|s
operator|&
operator|~
name|SMASK
operator|)
operator||
operator|(
name|tag
operator|&
name|SMASK
operator|)
argument_list|)
condition|)
return|return
operator|(
name|short
operator|)
name|s
return|;
block|}
block|}
comment|/**      * Atomically conditionally sets the tag value for this task.      * Among other applications, tags can be used as visit markers      * in tasks operating on graphs, as in methods that check: {@code      * if (task.compareAndSetForkJoinTaskTag((short)0, (short)1))}      * before processing, otherwise exiting because the node has      * already been visited.      *      * @param e the expected tag value      * @param tag the new tag value      * @return {@code true} if successful; i.e., the current value was      * equal to e and is now tag.      * @since 1.8      */
DECL|method|compareAndSetForkJoinTaskTag
specifier|public
specifier|final
name|boolean
name|compareAndSetForkJoinTaskTag
parameter_list|(
name|short
name|e
parameter_list|,
name|short
name|tag
parameter_list|)
block|{
for|for
control|(
name|int
name|s
init|;
condition|;
control|)
block|{
if|if
condition|(
call|(
name|short
call|)
argument_list|(
name|s
operator|=
name|status
argument_list|)
operator|!=
name|e
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|STATUS
argument_list|,
name|s
argument_list|,
operator|(
name|s
operator|&
operator|~
name|SMASK
operator|)
operator||
operator|(
name|tag
operator|&
name|SMASK
operator|)
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Adaptor for Runnables. This implements RunnableFuture      * to be compliant with AbstractExecutorService constraints      * when used in ForkJoinPool.      */
DECL|class|AdaptedRunnable
specifier|static
specifier|final
class|class
name|AdaptedRunnable
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
implements|implements
name|RunnableFuture
argument_list|<
name|T
argument_list|>
block|{
DECL|field|runnable
specifier|final
name|Runnable
name|runnable
decl_stmt|;
DECL|field|result
name|T
name|result
decl_stmt|;
DECL|method|AdaptedRunnable
name|AdaptedRunnable
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|T
name|result
parameter_list|)
block|{
if|if
condition|(
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|runnable
operator|=
name|runnable
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
comment|// OK to set this even before completion
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|T
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|T
name|v
parameter_list|)
block|{
name|result
operator|=
name|v
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|runnable
operator|.
name|run
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
name|invoke
argument_list|()
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|/**      * Adaptor for Runnables without results      */
DECL|class|AdaptedRunnableAction
specifier|static
specifier|final
class|class
name|AdaptedRunnableAction
extends|extends
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
implements|implements
name|RunnableFuture
argument_list|<
name|Void
argument_list|>
block|{
DECL|field|runnable
specifier|final
name|Runnable
name|runnable
decl_stmt|;
DECL|method|AdaptedRunnableAction
name|AdaptedRunnableAction
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
if|if
condition|(
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|runnable
operator|=
name|runnable
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Void
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|Void
name|v
parameter_list|)
block|{ }
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|runnable
operator|.
name|run
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
name|invoke
argument_list|()
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|/**      * Adaptor for Runnables in which failure forces worker exception      */
DECL|class|RunnableExecuteAction
specifier|static
specifier|final
class|class
name|RunnableExecuteAction
extends|extends
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
block|{
DECL|field|runnable
specifier|final
name|Runnable
name|runnable
decl_stmt|;
DECL|method|RunnableExecuteAction
name|RunnableExecuteAction
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
if|if
condition|(
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|runnable
operator|=
name|runnable
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Void
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|Void
name|v
parameter_list|)
block|{ }
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|runnable
operator|.
name|run
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|internalPropagateException
name|void
name|internalPropagateException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
comment|// rethrow outside exec() catches.
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|/**      * Adaptor for Callables      */
DECL|class|AdaptedCallable
specifier|static
specifier|final
class|class
name|AdaptedCallable
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
implements|implements
name|RunnableFuture
argument_list|<
name|T
argument_list|>
block|{
DECL|field|callable
specifier|final
name|Callable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|callable
decl_stmt|;
DECL|field|result
name|T
name|result
decl_stmt|;
DECL|method|AdaptedCallable
name|AdaptedCallable
parameter_list|(
name|Callable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|callable
parameter_list|)
block|{
if|if
condition|(
name|callable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|this
operator|.
name|callable
operator|=
name|callable
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|T
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|T
name|v
parameter_list|)
block|{
name|result
operator|=
name|v
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
try|try
block|{
name|result
operator|=
name|callable
operator|.
name|call
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
catch|catch
parameter_list|(
name|Error
name|err
parameter_list|)
block|{
throw|throw
name|err
throw|;
block|}
catch|catch
parameter_list|(
name|RuntimeException
name|rex
parameter_list|)
block|{
throw|throw
name|rex
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ex
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
name|invoke
argument_list|()
expr_stmt|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2838392045355241008L
decl_stmt|;
block|}
comment|/**      * Returns a new {@code ForkJoinTask} that performs the {@code run}      * method of the given {@code Runnable} as its action, and returns      * a null result upon {@link #join}.      *      * @param runnable the runnable action      * @return the task      */
DECL|method|adapt
specifier|public
specifier|static
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|adapt
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
return|return
operator|new
name|AdaptedRunnableAction
argument_list|(
name|runnable
argument_list|)
return|;
block|}
comment|/**      * Returns a new {@code ForkJoinTask} that performs the {@code run}      * method of the given {@code Runnable} as its action, and returns      * the given result upon {@link #join}.      *      * @param runnable the runnable action      * @param result the result upon completion      * @param<T> the type of the result      * @return the task      */
DECL|method|adapt
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|adapt
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|T
name|result
parameter_list|)
block|{
return|return
operator|new
name|AdaptedRunnable
argument_list|<
name|T
argument_list|>
argument_list|(
name|runnable
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/**      * Returns a new {@code ForkJoinTask} that performs the {@code call}      * method of the given {@code Callable} as its action, and returns      * its result upon {@link #join}, translating any checked exceptions      * encountered into {@code RuntimeException}.      *      * @param callable the callable action      * @param<T> the type of the callable's result      * @return the task      */
DECL|method|adapt
specifier|public
specifier|static
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|adapt
parameter_list|(
name|Callable
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|callable
parameter_list|)
block|{
return|return
operator|new
name|AdaptedCallable
argument_list|<
name|T
argument_list|>
argument_list|(
name|callable
argument_list|)
return|;
block|}
comment|// Serialization support
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|7721805057305804111L
decl_stmt|;
comment|/**      * Saves this task to a stream (that is, serializes it).      *      * @param s the stream      * @throws java.io.IOException if an I/O error occurs      * @serialData the current run status and the exception thrown      * during execution, or {@code null} if none      */
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
name|getException
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reconstitutes this task from a stream (that is, deserializes it).      * @param s the stream      * @throws ClassNotFoundException if the class of a serialized object      *         could not be found      * @throws java.io.IOException if an I/O error occurs      */
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|Object
name|ex
init|=
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|setExceptionalCompletion
argument_list|(
operator|(
name|Throwable
operator|)
name|ex
argument_list|)
expr_stmt|;
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|STATUS
specifier|private
specifier|static
specifier|final
name|long
name|STATUS
decl_stmt|;
static|static
block|{
name|exceptionTableLock
operator|=
operator|new
name|ReentrantLock
argument_list|()
expr_stmt|;
name|exceptionTableRefQueue
operator|=
operator|new
name|ReferenceQueue
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|exceptionTable
operator|=
operator|new
name|ExceptionNode
index|[
name|EXCEPTION_MAP_CAPACITY
index|]
expr_stmt|;
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|ForkJoinTask
operator|.
name|class
decl_stmt|;
name|STATUS
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"status"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

