begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_import
import|import
name|jsr166y
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_comment
comment|/**  * A {@link Future} that may be explicitly completed (setting its  * value and status), and may include dependent functions and actions  * that trigger upon its completion.  Methods are available for adding  * those based on Functions, Blocks, and Runnables, depending on  * whether they require arguments and/or produce results, as well as  * those triggered after either or both the current and another  * CompletableFuture complete.  Functions and actions supplied for  * dependent completions (mainly using methods with prefix {@code  * then}) may be performed by the thread that completes the current  * CompletableFuture, or by any other caller of these methods.  There  * are no guarantees about the order of processing completions unless  * constrained by these methods.  *  *<p>When two or more threads attempt to {@link #complete} or {@link  * #completeExceptionally} a CompletableFuture, only one of them  * succeeds.  *  *<p>Upon exceptional completion, or when a completion entails  * computation of a function or action, and it terminates abruptly  * with an (unchecked) exception or error, then further completions  * act as {@code completeExceptionally} with a {@link  * CompletionException} holding that exception as its cause.  If a  * CompletableFuture completes exceptionally, and is not followed by a  * {@link #exceptionally} or {@link #handle} completion, then all of  * its dependents (and their dependents) also complete exceptionally  * with CompletionExceptions holding the ultimate cause.  In case of a  * CompletionException, methods {@link #get()} and {@link #get(long,  * TimeUnit)} throw an {@link ExecutionException} with the same cause  * as would be held in the corresponding CompletionException. However,  * in these cases, methods {@link #join()} and {@link #getNow} throw  * the CompletionException, which simplifies usage especially within  * other completion functions.  *  *<p>CompletableFutures themselves do not execute asynchronously.  * However, the {@code async} methods provide commonly useful ways to  * commence asynchronous processing, using either a given {@link  * Executor} or by default the {@link ForkJoinPool#commonPool()}, of a  * function or action that will result in the completion of a new  * CompletableFuture. To simplify monitoring, debugging, and tracking,  * all generated asynchronous tasks are instances of the tagging  * interface {@link AsynchronousCompletionTask}.  *  *<p><em>jsr166e note: During transition, this class  * uses nested functional interfaces with different names but the  * same forms as those expected for JDK8.</em>  *  * @author Doug Lea  * @since 1.8  */
end_comment

begin_class
DECL|class|CompletableFuture
specifier|public
class|class
name|CompletableFuture
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Future
argument_list|<
name|T
argument_list|>
block|{
comment|// jsr166e nested interfaces
comment|/** Interface describing a void action of one argument */
DECL|interface|Action
DECL|method|accept
specifier|public
interface|interface
name|Action
parameter_list|<
name|A
parameter_list|>
block|{
name|void
name|accept
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a void action of two arguments */
DECL|interface|BiAction
DECL|method|accept
specifier|public
interface|interface
name|BiAction
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|void
name|accept
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of one argument */
DECL|interface|Fun
DECL|method|apply
specifier|public
interface|interface
name|Fun
parameter_list|<
name|A
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of two arguments */
DECL|interface|BiFun
DECL|method|apply
specifier|public
interface|interface
name|BiFun
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of no arguments */
DECL|interface|Generator
DECL|method|get
specifier|public
interface|interface
name|Generator
parameter_list|<
name|T
parameter_list|>
block|{
name|T
name|get
parameter_list|()
function_decl|;
block|}
comment|/*      * Overview:      *      * 1. Non-nullness of field result (set via CAS) indicates done.      * An AltResult is used to box null as a result, as well as to      * hold exceptions.  Using a single field makes completion fast      * and simple to detect and trigger, at the expense of a lot of      * encoding and decoding that infiltrates many methods. One minor      * simplification relies on the (static) NIL (to box null results)      * being the only AltResult with a null exception field, so we      * don't usually need explicit comparisons with NIL. The CF      * exception propagation mechanics surrounding decoding rely on      * unchecked casts of decoded results really being unchecked,      * where user type errors are caught at point of use, as is      * currently the case in Java. These are highlighted by using      * SuppressWarnings-annotated temporaries.      *      * 2. Waiters are held in a Treiber stack similar to the one used      * in FutureTask, Phaser, and SynchronousQueue. See their      * internal documentation for algorithmic details.      *      * 3. Completions are also kept in a list/stack, and pulled off      * and run when completion is triggered. (We could even use the      * same stack as for waiters, but would give up the potential      * parallelism obtained because woken waiters help release/run      * others -- see method postComplete).  Because post-processing      * may race with direct calls, class Completion opportunistically      * extends AtomicInteger so callers can claim the action via      * compareAndSet(0, 1).  The Completion.run methods are all      * written a boringly similar uniform way (that sometimes includes      * unnecessary-looking checks, kept to maintain uniformity). There      * are enough dimensions upon which they differ that factoring to      * use common code isn't worthwhile.      *      * 4. The exported then/and/or methods do support a bit of      * factoring (see doThenApply etc). They must cope with the      * intrinsic races surrounding addition of a dependent action      * versus performing the action directly because the task is      * already complete.  For example, a CF may not be complete upon      * entry, so a dependent completion is added, but by the time it      * is added, the target CF is complete, so must be directly      * executed. This is all done while avoiding unnecessary object      * construction in safe-bypass cases.      */
comment|// preliminaries
DECL|class|AltResult
specifier|static
specifier|final
class|class
name|AltResult
block|{
DECL|field|ex
specifier|final
name|Throwable
name|ex
decl_stmt|;
comment|// null only for NIL
DECL|method|AltResult
name|AltResult
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ex
operator|=
name|ex
expr_stmt|;
block|}
block|}
DECL|field|NIL
specifier|static
specifier|final
name|AltResult
name|NIL
init|=
operator|new
name|AltResult
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// Fields
DECL|field|result
specifier|volatile
name|Object
name|result
decl_stmt|;
comment|// Either the result or boxed AltResult
DECL|field|waiters
specifier|volatile
name|WaitNode
name|waiters
decl_stmt|;
comment|// Treiber stack of threads blocked on get()
DECL|field|completions
specifier|volatile
name|CompletionNode
name|completions
decl_stmt|;
comment|// list (Treiber stack) of completions
comment|// Basic utilities for triggering and processing completions
comment|/**      * Removes and signals all waiting threads and runs all completions.      */
DECL|method|postComplete
specifier|final
name|void
name|postComplete
parameter_list|()
block|{
name|WaitNode
name|q
decl_stmt|;
name|Thread
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|waiters
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
argument_list|,
name|q
operator|.
name|next
argument_list|)
operator|&&
operator|(
name|t
operator|=
name|q
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|CompletionNode
name|h
decl_stmt|;
name|Completion
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|h
operator|=
name|completions
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|h
argument_list|,
name|h
operator|.
name|next
argument_list|)
operator|&&
operator|(
name|c
operator|=
name|h
operator|.
name|completion
operator|)
operator|!=
literal|null
condition|)
name|c
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Triggers completion with the encoding of the given arguments:      * if the exception is non-null, encodes it as a wrapped      * CompletionException unless it is one already.  Otherwise uses      * the given result, boxed as NIL if null.      */
DECL|method|internalComplete
specifier|final
name|void
name|internalComplete
parameter_list|(
name|Object
name|v
parameter_list|,
name|Throwable
name|ex
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
operator|(
name|ex
operator|==
literal|null
operator|)
condition|?
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
name|NIL
else|:
name|v
else|:
operator|new
name|AltResult
argument_list|(
operator|(
name|ex
operator|instanceof
name|CompletionException
operator|)
condition|?
name|ex
else|:
operator|new
name|CompletionException
argument_list|(
name|ex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
comment|// help out even if not triggered
block|}
comment|/**      * If triggered, helps release and/or process completions.      */
DECL|method|helpPostComplete
specifier|final
name|void
name|helpPostComplete
parameter_list|()
block|{
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
name|postComplete
argument_list|()
expr_stmt|;
block|}
comment|/* ------------- waiting for completions -------------- */
comment|/**      * Heuristic spin value for waitingGet() before blocking on      * multiprocessors      */
DECL|field|WAITING_GET_SPINS
specifier|static
specifier|final
name|int
name|WAITING_GET_SPINS
init|=
literal|256
decl_stmt|;
comment|/**      * Linked nodes to record waiting threads in a Treiber stack.  See      * other classes such as Phaser and SynchronousQueue for more      * detailed explanation. This class implements ManagedBlocker to      * avoid starvation when blocking actions pile up in      * ForkJoinPools.      */
DECL|class|WaitNode
specifier|static
specifier|final
class|class
name|WaitNode
implements|implements
name|ForkJoinPool
operator|.
name|ManagedBlocker
block|{
DECL|field|nanos
name|long
name|nanos
decl_stmt|;
comment|// wait time if timed
DECL|field|deadline
specifier|final
name|long
name|deadline
decl_stmt|;
comment|// non-zero if timed
DECL|field|interruptControl
specifier|volatile
name|int
name|interruptControl
decl_stmt|;
comment|//> 0: interruptible,< 0: interrupted
DECL|field|thread
specifier|volatile
name|Thread
name|thread
decl_stmt|;
DECL|field|next
specifier|volatile
name|WaitNode
name|next
decl_stmt|;
DECL|method|WaitNode
name|WaitNode
parameter_list|(
name|boolean
name|interruptible
parameter_list|,
name|long
name|nanos
parameter_list|,
name|long
name|deadline
parameter_list|)
block|{
name|this
operator|.
name|thread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
name|this
operator|.
name|interruptControl
operator|=
name|interruptible
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|this
operator|.
name|nanos
operator|=
name|nanos
expr_stmt|;
name|this
operator|.
name|deadline
operator|=
name|deadline
expr_stmt|;
block|}
DECL|method|isReleasable
specifier|public
name|boolean
name|isReleasable
parameter_list|()
block|{
if|if
condition|(
name|thread
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|interruptControl
decl_stmt|;
name|interruptControl
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
name|deadline
operator|!=
literal|0L
operator|&&
operator|(
name|nanos
operator|<=
literal|0L
operator|||
operator|(
name|nanos
operator|=
name|deadline
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|<=
literal|0L
operator|)
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|block
specifier|public
name|boolean
name|block
parameter_list|()
block|{
if|if
condition|(
name|isReleasable
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|deadline
operator|==
literal|0L
condition|)
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nanos
operator|>
literal|0L
condition|)
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
return|return
name|isReleasable
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns raw result after waiting, or null if interruptible and      * interrupted.      */
DECL|method|waitingGet
specifier|private
name|Object
name|waitingGet
parameter_list|(
name|boolean
name|interruptible
parameter_list|)
block|{
name|WaitNode
name|q
init|=
literal|null
decl_stmt|;
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
name|int
name|h
init|=
literal|0
decl_stmt|,
name|spins
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Object
name|r
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
comment|// suppress unpark
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interruptible
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|postComplete
argument_list|()
expr_stmt|;
comment|// help release others
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|h
operator|==
literal|0
condition|)
block|{
name|h
operator|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
expr_stmt|;
if|if
condition|(
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|>
literal|1
condition|)
name|spins
operator|=
name|WAITING_GET_SPINS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|>
literal|0
condition|)
block|{
name|h
operator|^=
name|h
operator|<<
literal|1
expr_stmt|;
comment|// xorshift
name|h
operator|^=
name|h
operator|>>>
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|^=
name|h
operator|<<
literal|10
operator|)
operator|>=
literal|0
condition|)
operator|--
name|spins
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|==
literal|null
condition|)
name|q
operator|=
operator|new
name|WaitNode
argument_list|(
name|interruptible
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
name|queued
operator|=
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
operator|.
name|next
operator|=
name|waiters
argument_list|,
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|interruptible
operator|&&
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|thread
operator|!=
literal|null
operator|&&
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|ForkJoinPool
operator|.
name|managedBlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|q
operator|.
name|interruptControl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Awaits completion or aborts on interrupt or timeout.      *      * @param nanos time to wait      * @return raw result      */
DECL|method|timedAwaitDone
specifier|private
name|Object
name|timedAwaitDone
parameter_list|(
name|long
name|nanos
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
name|WaitNode
name|q
init|=
literal|null
decl_stmt|;
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Object
name|r
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
block|}
name|postComplete
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|nanos
operator|<=
literal|0L
condition|)
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
name|long
name|d
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|nanos
decl_stmt|;
name|q
operator|=
operator|new
name|WaitNode
argument_list|(
literal|true
argument_list|,
name|nanos
argument_list|,
name|d
operator|==
literal|0L
condition|?
literal|1L
else|:
name|d
argument_list|)
expr_stmt|;
comment|// avoid 0
block|}
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
name|queued
operator|=
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
operator|.
name|next
operator|=
name|waiters
argument_list|,
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|nanos
operator|<=
literal|0L
condition|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|thread
operator|!=
literal|null
operator|&&
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|ForkJoinPool
operator|.
name|managedBlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|q
operator|.
name|interruptControl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Tries to unlink a timed-out or interrupted wait node to avoid      * accumulating garbage.  Internal nodes are simply unspliced      * without CAS since it is harmless if they are traversed anyway      * by releasers.  To avoid effects of unsplicing from already      * removed nodes, the list is retraversed in case of an apparent      * race.  This is slow when there are a lot of nodes, but we don't      * expect lists to be long enough to outweigh higher-overhead      * schemes.      */
DECL|method|removeWaiter
specifier|private
name|void
name|removeWaiter
parameter_list|(
name|WaitNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|retry
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// restart on removeWaiter race
for|for
control|(
name|WaitNode
name|pred
init|=
literal|null
init|,
name|q
init|=
name|waiters
init|,
name|s
init|;
name|q
operator|!=
literal|null
condition|;
name|q
operator|=
name|s
control|)
block|{
name|s
operator|=
name|q
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|thread
operator|!=
literal|null
condition|)
name|pred
operator|=
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
block|{
name|pred
operator|.
name|next
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|pred
operator|.
name|thread
operator|==
literal|null
condition|)
comment|// check for race
continue|continue
name|retry
continue|;
block|}
elseif|else
if|if
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
argument_list|,
name|s
argument_list|)
condition|)
continue|continue
name|retry
continue|;
block|}
break|break;
block|}
block|}
block|}
comment|/* ------------- Async tasks -------------- */
comment|/**      * A tagging interface identifying asynchronous tasks produced by      * {@code async} methods. This may be useful for monitoring,      * debugging, and tracking asynchronous activities.      */
DECL|interface|AsynchronousCompletionTask
specifier|public
specifier|static
interface|interface
name|AsynchronousCompletionTask
block|{     }
comment|/** Base class can act as either FJ or plain Runnable */
DECL|class|Async
specifier|abstract
specifier|static
class|class
name|Async
extends|extends
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
implements|implements
name|Runnable
implements|,
name|AsynchronousCompletionTask
block|{
DECL|method|getRawResult
specifier|public
specifier|final
name|Void
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|Void
name|v
parameter_list|)
block|{ }
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
name|exec
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|AsyncRun
specifier|static
specifier|final
class|class
name|AsyncRun
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncRun
name|AsyncRun
parameter_list|(
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|d
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncSupply
specifier|static
specifier|final
class|class
name|AsyncSupply
parameter_list|<
name|U
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|Generator
argument_list|<
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncSupply
name|AsyncSupply
parameter_list|(
name|Generator
argument_list|<
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|d
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|get
argument_list|()
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncApply
specifier|static
specifier|final
class|class
name|AsyncApply
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|arg
specifier|final
name|T
name|arg
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncApply
name|AsyncApply
parameter_list|(
name|T
name|arg
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|d
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncBiApply
specifier|static
specifier|final
class|class
name|AsyncBiApply
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
decl_stmt|;
DECL|field|arg1
specifier|final
name|T
name|arg1
decl_stmt|;
DECL|field|arg2
specifier|final
name|U
name|arg2
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncBiApply
name|AsyncBiApply
parameter_list|(
name|T
name|arg1
parameter_list|,
name|U
name|arg2
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg1
operator|=
name|arg1
expr_stmt|;
name|this
operator|.
name|arg2
operator|=
name|arg2
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|d
decl_stmt|;
name|V
name|v
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|v
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
name|v
operator|=
literal|null
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
name|v
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncAccept
specifier|static
specifier|final
class|class
name|AsyncAccept
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|arg
specifier|final
name|T
name|arg
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncAccept
name|AsyncAccept
parameter_list|(
name|T
name|arg
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|d
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|fn
operator|.
name|accept
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncBiAccept
specifier|static
specifier|final
class|class
name|AsyncBiAccept
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|arg1
specifier|final
name|T
name|arg1
decl_stmt|;
DECL|field|arg2
specifier|final
name|U
name|arg2
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncBiAccept
name|AsyncBiAccept
parameter_list|(
name|T
name|arg1
parameter_list|,
name|U
name|arg2
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg1
operator|=
name|arg1
expr_stmt|;
name|this
operator|.
name|arg2
operator|=
name|arg2
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|d
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|fn
operator|.
name|accept
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|/* ------------- Completions -------------- */
comment|/**      * Simple linked list nodes to record completions, used in      * basically the same way as WaitNodes. (We separate nodes from      * the Completions themselves mainly because for the And and Or      * methods, the same Completion object resides in two lists.)      */
DECL|class|CompletionNode
specifier|static
specifier|final
class|class
name|CompletionNode
block|{
DECL|field|completion
specifier|final
name|Completion
name|completion
decl_stmt|;
DECL|field|next
specifier|volatile
name|CompletionNode
name|next
decl_stmt|;
DECL|method|CompletionNode
name|CompletionNode
parameter_list|(
name|Completion
name|completion
parameter_list|)
block|{
name|this
operator|.
name|completion
operator|=
name|completion
expr_stmt|;
block|}
block|}
comment|// Opportunistically subclass AtomicInteger to use compareAndSet to claim.
DECL|class|Completion
specifier|abstract
specifier|static
class|class
name|Completion
extends|extends
name|AtomicInteger
implements|implements
name|Runnable
block|{     }
DECL|class|ApplyCompletion
specifier|static
specifier|final
class|class
name|ApplyCompletion
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ApplyCompletion
name|ApplyCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AcceptCompletion
specifier|static
specifier|final
class|class
name|AcceptCompletion
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|AcceptCompletion
name|AcceptCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|RunCompletion
specifier|static
specifier|final
class|class
name|RunCompletion
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|RunCompletion
name|RunCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Runnable
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|BiApplyCompletion
specifier|static
specifier|final
class|class
name|BiApplyCompletion
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|BiApplyCompletion
name|BiApplyCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|b
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
decl_stmt|;
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
name|V
name|v
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncBiApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|v
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|BiAcceptCompletion
specifier|static
specifier|final
class|class
name|BiAcceptCompletion
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|BiAcceptCompletion
name|BiAcceptCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|b
decl_stmt|;
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
decl_stmt|;
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncBiAccept
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|BiRunCompletion
specifier|static
specifier|final
class|class
name|BiRunCompletion
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|BiRunCompletion
name|BiRunCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
parameter_list|,
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Runnable
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
operator|&&
operator|(
name|s
operator|instanceof
name|AltResult
operator|)
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|OrApplyCompletion
specifier|static
specifier|final
class|class
name|OrApplyCompletion
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|OrApplyCompletion
name|OrApplyCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|OrAcceptCompletion
specifier|static
specifier|final
class|class
name|OrAcceptCompletion
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|OrAcceptCompletion
name|OrAcceptCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|OrRunCompletion
specifier|static
specifier|final
class|class
name|OrRunCompletion
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|OrRunCompletion
name|OrRunCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
parameter_list|,
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Runnable
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ExceptionCompletion
specifier|static
specifier|final
class|class
name|ExceptionCompletion
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
DECL|method|ExceptionCompletion
name|ExceptionCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
init|=
literal|null
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|dx
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
operator|&&
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|t
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
block|}
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ThenCopy
specifier|static
specifier|final
class|class
name|ThenCopy
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
DECL|method|ThenCopy
name|ThenCopy
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|Object
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
name|t
operator|=
name|r
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|HandleCompletion
specifier|static
specifier|final
class|class
name|HandleCompletion
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|HandleCompletion
name|HandleCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
init|=
literal|null
decl_stmt|;
name|Throwable
name|dx
init|=
literal|null
decl_stmt|;
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ComposeCompletion
specifier|static
specifier|final
class|class
name|ComposeCompletion
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|ComposeCompletion
name|ComposeCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|,
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|c
init|=
literal|null
decl_stmt|;
name|U
name|u
init|=
literal|null
decl_stmt|;
name|boolean
name|complete
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|c
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
operator|||
name|c
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ThenCopy
argument_list|<
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|c
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ThenCopy
argument_list|<
name|U
argument_list|>
argument_list|(
name|c
argument_list|,
name|dst
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|c
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|c
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|c
operator|.
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|complete
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
comment|// no rewrap
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|complete
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
name|c
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|// public methods
comment|/**      * Creates a new incomplete CompletableFuture.      */
DECL|method|CompletableFuture
specifier|public
name|CompletableFuture
parameter_list|()
block|{     }
comment|/**      * Asynchronously executes in the {@link      * ForkJoinPool#commonPool()}, a task that completes the returned      * CompletableFuture with the result of the given Supplier.      *      * @param supplier a function returning the value to be used      * to complete the returned CompletableFuture      * @return the CompletableFuture      */
DECL|method|supplyAsync
specifier|public
specifier|static
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|supplyAsync
parameter_list|(
name|Generator
argument_list|<
name|U
argument_list|>
name|supplier
parameter_list|)
block|{
if|if
condition|(
name|supplier
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
operator|.
name|execute
argument_list|(
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
operator|new
name|AsyncSupply
argument_list|<
name|U
argument_list|>
argument_list|(
name|supplier
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Asynchronously executes using the given executor, a task that      * completes the returned CompletableFuture with the result of the      * given Supplier.      *      * @param supplier a function returning the value to be used      * to complete the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the CompletableFuture      */
DECL|method|supplyAsync
specifier|public
specifier|static
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|supplyAsync
parameter_list|(
name|Generator
argument_list|<
name|U
argument_list|>
name|supplier
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
operator|||
name|supplier
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|AsyncSupply
argument_list|<
name|U
argument_list|>
argument_list|(
name|supplier
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Asynchronously executes in the {@link      * ForkJoinPool#commonPool()} a task that runs the given action,      * and then completes the returned CompletableFuture.      *      * @param runnable the action to run before completing the      * returned CompletableFuture      * @return the CompletableFuture      */
DECL|method|runAsync
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAsync
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
if|if
condition|(
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
operator|.
name|execute
argument_list|(
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
operator|new
name|AsyncRun
argument_list|(
name|runnable
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Asynchronously executes using the given executor, a task that      * runs the given action, and then completes the returned      * CompletableFuture.      *      * @param runnable the action to run before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the CompletableFuture      */
DECL|method|runAsync
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAsync
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
operator|||
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|runnable
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Returns {@code true} if completed in any fashion: normally,      * exceptionally, or via cancellation.      *      * @return {@code true} if completed      */
DECL|method|isDone
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|result
operator|!=
literal|null
return|;
block|}
comment|/**      * Waits if necessary for the computation to complete, and then      * retrieves its result.      *      * @return the computed result      * @throws CancellationException if the computation was cancelled      * @throws ExecutionException if the computation threw an      * exception      * @throws InterruptedException if the current thread was interrupted      * while waiting      */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|cause
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|waitingGet
argument_list|(
literal|true
argument_list|)
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
operator|(
name|ex
operator|instanceof
name|CompletionException
operator|)
operator|&&
operator|(
name|cause
operator|=
name|ex
operator|.
name|getCause
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|ex
operator|=
name|cause
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * Waits if necessary for at most the given time for completion,      * and then retrieves its result, if available.      *      * @param timeout the maximum time to wait      * @param unit the time unit of the timeout argument      * @return the computed result      * @throws CancellationException if the computation was cancelled      * @throws ExecutionException if the computation threw an      * exception      * @throws InterruptedException if the current thread was interrupted      * while waiting      * @throws TimeoutException if the wait timed out      */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|cause
decl_stmt|;
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
name|r
operator|=
name|timedAwaitDone
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
operator|(
name|ex
operator|instanceof
name|CompletionException
operator|)
operator|&&
operator|(
name|cause
operator|=
name|ex
operator|.
name|getCause
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|ex
operator|=
name|cause
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * Returns the result value when complete, or throws an      * (unchecked) exception if completed exceptionally. To better      * conform with the use of common functional forms, if a      * computation involved in the completion of this      * CompletableFuture threw an exception, this method throws an      * (unchecked) {@link CompletionException} with the underlying      * exception as its cause.      *      * @return the result value      * @throws CancellationException if the computation was cancelled      * @throws CompletionException if a completion computation threw      * an exception      */
DECL|method|join
specifier|public
name|T
name|join
parameter_list|()
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
name|r
operator|=
name|waitingGet
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
name|ex
operator|instanceof
name|CompletionException
condition|)
throw|throw
operator|(
name|CompletionException
operator|)
name|ex
throw|;
throw|throw
operator|new
name|CompletionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * Returns the result value (or throws any encountered exception)      * if completed, else returns the given valueIfAbsent.      *      * @param valueIfAbsent the value to return if not completed      * @return the result value, if completed, else the given valueIfAbsent      * @throws CancellationException if the computation was cancelled      * @throws CompletionException if a completion computation threw      * an exception      */
DECL|method|getNow
specifier|public
name|T
name|getNow
parameter_list|(
name|T
name|valueIfAbsent
parameter_list|)
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
return|return
name|valueIfAbsent
return|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
name|ex
operator|instanceof
name|CompletionException
condition|)
throw|throw
operator|(
name|CompletionException
operator|)
name|ex
throw|;
throw|throw
operator|new
name|CompletionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * If not already completed, sets the value returned by {@link      * #get()} and related methods to the given value.      *      * @param value the result value      * @return {@code true} if this invocation caused this CompletableFuture      * to transition to a completed state, else {@code false}      */
DECL|method|complete
specifier|public
name|boolean
name|complete
parameter_list|(
name|T
name|value
parameter_list|)
block|{
name|boolean
name|triggered
init|=
name|result
operator|==
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
name|value
operator|==
literal|null
condition|?
name|NIL
else|:
name|value
argument_list|)
decl_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
return|return
name|triggered
return|;
block|}
comment|/**      * If not already completed, causes invocations of {@link #get()}      * and related methods to throw the given exception.      *      * @param ex the exception      * @return {@code true} if this invocation caused this CompletableFuture      * to transition to a completed state, else {@code false}      */
DECL|method|completeExceptionally
specifier|public
name|boolean
name|completeExceptionally
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|boolean
name|triggered
init|=
name|result
operator|==
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
operator|new
name|AltResult
argument_list|(
name|ex
argument_list|)
argument_list|)
decl_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
return|return
name|triggered
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed with      * the result of the given function of this CompletableFuture.      * If this CompletableFuture completes exceptionally,      * then the returned CompletableFuture also does so,      * with a CompletionException holding this exception as      * its cause.      *      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenApply
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenApply
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenApply
argument_list|(
name|fn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is asynchronously      * completed using the {@link ForkJoinPool#commonPool()} with the      * result of the given function of this CompletableFuture.  If      * this CompletableFuture completes exceptionally, then the      * returned CompletableFuture also does so, with a      * CompletionException holding this exception as its cause.      *      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenApplyAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenApplyAsync
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenApply
argument_list|(
name|fn
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is asynchronously      * completed using the given executor with the result of the given      * function of this CompletableFuture.  If this CompletableFuture      * completes exceptionally, then the returned CompletableFuture      * also does so, with a CompletionException holding this exception as      * its cause.      *      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenApplyAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenApplyAsync
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenApply
argument_list|(
name|fn
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenApply
specifier|private
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|doThenApply
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|ApplyCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ApplyCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed after      * performing the given action with this CompletableFuture's      * result when it completes.  If this CompletableFuture      * completes exceptionally, then the returned CompletableFuture      * also does so, with a CompletionException holding this exception as      * its cause.      *      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAccept
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAccept
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenAccept
argument_list|(
name|block
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is asynchronously      * completed using the {@link ForkJoinPool#commonPool()} with this      * CompletableFuture's result when it completes.  If this      * CompletableFuture completes exceptionally, then the returned      * CompletableFuture also does so, with a CompletionException holding      * this exception as its cause.      *      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAcceptAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptAsync
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenAccept
argument_list|(
name|block
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is asynchronously      * completed using the given executor with this      * CompletableFuture's result when it completes.  If this      * CompletableFuture completes exceptionally, then the returned      * CompletableFuture also does so, with a CompletionException holding      * this exception as its cause.      *      * @param block the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenAcceptAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptAsync
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenAccept
argument_list|(
name|block
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenAccept
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doThenAccept
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|AcceptCompletion
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|AcceptCompletion
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed after      * performing the given action when this CompletableFuture      * completes.  If this CompletableFuture completes exceptionally,      * then the returned CompletableFuture also does so, with a      * CompletionException holding this exception as its cause.      *      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenRun
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenRun
parameter_list|(
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doThenRun
argument_list|(
name|action
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is asynchronously      * completed using the {@link ForkJoinPool#commonPool()} after      * performing the given action when this CompletableFuture      * completes.  If this CompletableFuture completes exceptionally,      * then the returned CompletableFuture also does so, with a      * CompletionException holding this exception as its cause.      *      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenRunAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenRunAsync
parameter_list|(
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doThenRun
argument_list|(
name|action
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is asynchronously      * completed using the given executor after performing the given      * action when this CompletableFuture completes.  If this      * CompletableFuture completes exceptionally, then the returned      * CompletableFuture also does so, with a CompletionException holding      * this exception as its cause.      *      * @param action the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenRunAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenRunAsync
parameter_list|(
name|Runnable
name|action
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenRun
argument_list|(
name|action
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenRun
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doThenRun
parameter_list|(
name|Runnable
name|action
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|RunCompletion
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|RunCompletion
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|action
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|action
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed with      * the result of the given function of this and the other given      * CompletableFuture's results when both complete.  If this or      * the other CompletableFuture complete exceptionally, then the      * returned CompletableFuture also does so, with a      * CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenCombine
specifier|public
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|thenCombine
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenBiApply
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is asynchronously      * completed using the {@link ForkJoinPool#commonPool()} with      * the result of the given function of this and the other given      * CompletableFuture's results when both complete.  If this or      * the other CompletableFuture complete exceptionally, then the      * returned CompletableFuture also does so, with a      * CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenCombineAsync
specifier|public
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|thenCombineAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenBiApply
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is      * asynchronously completed using the given executor with the      * result of the given function of this and the other given      * CompletableFuture's results when both complete.  If this or      * the other CompletableFuture complete exceptionally, then the      * returned CompletableFuture also does so, with a      * CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenCombineAsync
specifier|public
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|thenCombineAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenBiApply
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenBiApply
specifier|private
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|doThenBiApply
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
name|BiApplyCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|||
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|BiApplyCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|s
operator|==
literal|null
operator|&&
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
break|break;
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
name|V
name|v
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncBiApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|v
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed with      * the results of this and the other given CompletableFuture if      * both complete.  If this and/or the other CompletableFuture      * complete exceptionally, then the returned CompletableFuture      * also does so, with a CompletionException holding one of these      * exceptions as its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAcceptBoth
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenBiAccept
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the {@link ForkJoinPool#commonPool()} with      * the results of this and the other given CompletableFuture when      * both complete.  If this and/or the other CompletableFuture      * complete exceptionally, then the returned CompletableFuture      * also does so, with a CompletionException holding one of these      * exceptions as its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAcceptBothAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenBiAccept
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the given executor with the results of      * this and the other given CompletableFuture when both complete.      * If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture also does      * so, with a CompletionException holding one of these exceptions as      * its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenAcceptBothAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|block
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenBiAccept
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenBiAccept
specifier|private
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doThenBiAccept
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|BiAcceptCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|||
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|BiAcceptCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|s
operator|==
literal|null
operator|&&
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
break|break;
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncBiAccept
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * when this and the other given CompletableFuture both      * complete.  If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture also does      * so, with a CompletionException holding one of these exceptions as      * its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterBoth
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doThenBiRun
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the {@link ForkJoinPool#commonPool()}      * when this and the other given CompletableFuture both      * complete.  If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture also does      * so, with a CompletionException holding one of these exceptions as      * its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterBothAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doThenBiRun
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the given executor      * when this and the other given CompletableFuture both      * complete.  If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture also does      * so, with a CompletionException holding one of these exceptions as      * its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|runAfterBothAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenBiRun
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenBiRun
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doThenBiRun
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|BiRunCompletion
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|||
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|BiRunCompletion
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|action
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|s
operator|==
literal|null
operator|&&
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
break|break;
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
operator|&&
operator|(
name|s
operator|instanceof
name|AltResult
operator|)
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|action
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed with      * the result of the given function of either this or the other      * given CompletableFuture's results when either complete.  If      * this and/or the other CompletableFuture complete exceptionally,      * then the returned CompletableFuture may also do so, with a      * CompletionException holding one of these exceptions as its cause.      * No guarantees are made about which result or exception is used      * in the returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|applyToEither
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|applyToEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doOrApply
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the {@link ForkJoinPool#commonPool()} with      * the result of the given function of either this or the other      * given CompletableFuture's results when either complete.  If      * this and/or the other CompletableFuture complete exceptionally,      * then the returned CompletableFuture may also do so, with a      * CompletionException holding one of these exceptions as its cause.      * No guarantees are made about which result or exception is used      * in the returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|applyToEitherAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|applyToEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doOrApply
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the given executor with the result of the      * given function of either this or the other given      * CompletableFuture's results when either complete.  If this      * and/or the other CompletableFuture complete exceptionally, then      * the returned CompletableFuture may also do so, with a      * CompletionException holding one of these exceptions as its cause.      * No guarantees are made about which result or exception is used      * in the returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|applyToEitherAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|applyToEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doOrApply
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doOrApply
specifier|private
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|doOrApply
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|OrApplyCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|OrApplyCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed after      * performing the given action with the result of either this or the      * other given CompletableFuture's result, when either complete.      * If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do      * so, with a CompletionException holding one of these exceptions as      * its cause.  No guarantees are made about which exception is      * used in the returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|acceptEither
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|acceptEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doOrAccept
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the {@link ForkJoinPool#commonPool()},      * performing the given action with the result of either this or      * the other given CompletableFuture's result, when either      * complete.  If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do      * so, with a CompletionException holding one of these exceptions as      * its cause.  No guarantees are made about which exception is      * used in the returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|acceptEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|acceptEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doOrAccept
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the given executor,      * performing the given action with the result of either this or      * the other given CompletableFuture's result, when either      * complete.  If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do      * so, with a CompletionException holding one of these exceptions as      * its cause.  No guarantees are made about which exception is      * used in the returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|acceptEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|acceptEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doOrAccept
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doOrAccept
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doOrAccept
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|OrAcceptCompletion
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|OrAcceptCompletion
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * after this or the other given CompletableFuture complete.  If      * this and/or the other CompletableFuture complete exceptionally,      * then the returned CompletableFuture may also do so, with a      * CompletionException holding one of these exceptions as its cause.      * No guarantees are made about which exception is used in the      * returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterEither
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doOrRun
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the {@link ForkJoinPool#commonPool()}      * after this or the other given CompletableFuture complete.  If      * this and/or the other CompletableFuture complete exceptionally,      * then the returned CompletableFuture may also do so, with a      * CompletionException holding one of these exceptions as its cause.      * No guarantees are made about which exception is used in the      * returned CompletableFuture.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doOrRun
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed      * asynchronously using the given executor after this or the other      * given CompletableFuture complete.  If this and/or the other      * CompletableFuture complete exceptionally, then the returned      * CompletableFuture may also do so, with a CompletionException      * holding one of these exceptions as its cause.  No guarantees are      * made about which exception is used in the returned      * CompletableFuture.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|runAfterEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doOrRun
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doOrRun
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doOrRun
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|OrRunCompletion
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|OrRunCompletion
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|action
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|action
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a CompletableFuture (or an equivalent one) produced by      * the given function of the result of this CompletableFuture when      * completed.  If this CompletableFuture completes exceptionally,      * then the returned CompletableFuture also does so, with a      * CompletionException holding this exception as its cause.      *      * @param fn the function returning a new CompletableFuture      * @return the CompletableFuture, that {@code isDone()} upon      * return if completed by the given function, or an exception      * occurs      */
DECL|method|thenCompose
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenCompose
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
literal|null
decl_stmt|;
name|ComposeCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|dst
operator|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
expr_stmt|;
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ComposeCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|dst
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dst
operator|==
literal|null
condition|)
block|{
name|dst
operator|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|dst
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed with      * the result of the given function of the exception triggering      * this CompletableFuture's completion when it completes      * exceptionally; Otherwise, if this CompletableFuture completes      * normally, then the returned CompletableFuture also completes      * normally with the same value.      *      * @param fn the function to use to compute the value of the      * returned CompletableFuture if this CompletableFuture completed      * exceptionally      * @return the new CompletableFuture      */
DECL|method|exceptionally
specifier|public
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|exceptionally
parameter_list|(
name|Fun
argument_list|<
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|ExceptionCompletion
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ExceptionCompletion
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
init|=
literal|null
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|dx
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|t
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Creates and returns a CompletableFuture that is completed with      * the result of the given function of the result and exception of      * this CompletableFuture's completion when it completes.  The      * given function is invoked with the result (or {@code null} if      * none) and the exception (or {@code null} if none) of this      * CompletableFuture when complete.      *      * @param fn the function to use to compute the value of the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|handle
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|handle
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|HandleCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|HandleCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
decl_stmt|;
name|Throwable
name|dx
decl_stmt|;
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|dx
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Attempts to complete this CompletableFuture with      * a {@link CancellationException}.      *      * @param mayInterruptIfRunning this value has no effect in this      * implementation because interrupts are not used to control      * processing.      *      * @return {@code true} if this task is now cancelled      */
DECL|method|cancel
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|Object
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|r
operator|=
operator|new
name|AltResult
argument_list|(
operator|new
name|CancellationException
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|postComplete
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
operator|(
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
operator|&&
operator|(
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|instanceof
name|CancellationException
operator|)
operator|)
return|;
block|}
comment|/**      * Returns {@code true} if this CompletableFuture was cancelled      * before it completed normally.      *      * @return {@code true} if this CompletableFuture was cancelled      * before it completed normally      */
DECL|method|isCancelled
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
name|Object
name|r
decl_stmt|;
return|return
operator|(
operator|(
name|r
operator|=
name|result
operator|)
operator|instanceof
name|AltResult
operator|)
operator|&&
operator|(
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|instanceof
name|CancellationException
operator|)
return|;
block|}
comment|/**      * Forcibly sets or resets the value subsequently returned by      * method {@link #get()} and related methods, whether or not      * already completed. This method is designed for use only in      * error recovery actions, and even in such situations may result      * in ongoing dependent completions using established versus      * overwritten outcomes.      *      * @param value the completion value      */
DECL|method|obtrudeValue
specifier|public
name|void
name|obtrudeValue
parameter_list|(
name|T
name|value
parameter_list|)
block|{
name|result
operator|=
operator|(
name|value
operator|==
literal|null
operator|)
condition|?
name|NIL
else|:
name|value
expr_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
block|}
comment|/**      * Forcibly causes subsequent invocations of method {@link #get()}      * and related methods to throw the given exception, whether or      * not already completed. This method is designed for use only in      * recovery actions, and even in such situations may result in      * ongoing dependent completions using established versus      * overwritten outcomes.      *      * @param ex the exception      */
DECL|method|obtrudeException
specifier|public
name|void
name|obtrudeException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|result
operator|=
operator|new
name|AltResult
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|RESULT
specifier|private
specifier|static
specifier|final
name|long
name|RESULT
decl_stmt|;
DECL|field|WAITERS
specifier|private
specifier|static
specifier|final
name|long
name|WAITERS
decl_stmt|;
DECL|field|COMPLETIONS
specifier|private
specifier|static
specifier|final
name|long
name|COMPLETIONS
decl_stmt|;
static|static
block|{
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|CompletableFuture
operator|.
name|class
decl_stmt|;
name|RESULT
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"result"
argument_list|)
argument_list|)
expr_stmt|;
name|WAITERS
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"waiters"
argument_list|)
argument_list|)
expr_stmt|;
name|COMPLETIONS
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"completions"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

