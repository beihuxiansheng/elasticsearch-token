begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_import
import|import
name|jsr166y
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|FutureTask
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Executor
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|CancellationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_comment
comment|/**  * A {@link Future} that may be explicitly completed (setting its  * value and status), and may include dependent functions and actions  * that trigger upon its completion.  *  *<p>When two or more threads attempt to  * {@link #complete complete},  * {@link #completeExceptionally completeExceptionally}, or  * {@link #cancel cancel}  * a CompletableFuture, only one of them succeeds.  *  *<p>Methods are available for adding dependents based on  * user-provided Functions, Actions, or Runnables. The appropriate  * form to use depends on whether actions require arguments and/or  * produce results.  Completion of a dependent action will trigger the  * completion of another CompletableFuture.  Actions may also be  * triggered after either or both the current and another  * CompletableFuture complete.  Multiple CompletableFutures may also  * be grouped as one using {@link #anyOf(CompletableFuture...)} and  * {@link #allOf(CompletableFuture...)}.  *  *<p>CompletableFutures themselves do not execute asynchronously.  * However, actions supplied for dependent completions of another  * CompletableFuture may do so, depending on whether they are provided  * via one of the<em>async</em> methods (that is, methods with names  * of the form<tt><var>xxx</var>Async</tt>).  The<em>async</em>  * methods provide a way to commence asynchronous processing of an  * action using either a given {@link Executor} or by default the  * {@link ForkJoinPool#commonPool()}. To simplify monitoring,  * debugging, and tracking, all generated asynchronous tasks are  * instances of the marker interface {@link AsynchronousCompletionTask}.  *  *<p>Actions supplied for dependent completions of<em>non-async</em>  * methods may be performed by the thread that completes the current  * CompletableFuture, or by any other caller of these methods.  There  * are no guarantees about the order of processing completions unless  * constrained by these methods.  *  *<p>Since (unlike {@link FutureTask}) this class has no direct  * control over the computation that causes it to be completed,  * cancellation is treated as just another form of exceptional completion.  * Method {@link #cancel cancel} has the same effect as  * {@code completeExceptionally(new CancellationException())}.  *  *<p>Upon exceptional completion (including cancellation), or when a  * completion entails an additional computation which terminates  * abruptly with an (unchecked) exception or error, then all of their  * dependent completions (and their dependents in turn) generally act  * as {@code completeExceptionally} with a {@link CompletionException}  * holding that exception as its cause.  However, the {@link  * #exceptionally exceptionally} and {@link #handle handle}  * completions<em>are</em> able to handle exceptional completions of  * the CompletableFutures they depend on.  *  *<p>In case of exceptional completion with a CompletionException,  * methods {@link #get()} and {@link #get(long, TimeUnit)} throw an  * {@link ExecutionException} with the same cause as held in the  * corresponding CompletionException.  However, in these cases,  * methods {@link #join()} and {@link #getNow} throw the  * CompletionException, which simplifies usage.  *  *<p>Arguments used to pass a completion result (that is, for parameters  * of type {@code T}) may be null, but passing a null value for any other  * parameter will result in a {@link NullPointerException} being thrown.  *  * @author Doug Lea  */
end_comment

begin_class
DECL|class|CompletableFuture
specifier|public
class|class
name|CompletableFuture
parameter_list|<
name|T
parameter_list|>
implements|implements
name|Future
argument_list|<
name|T
argument_list|>
block|{
comment|// jsr166e nested interfaces
comment|/** Interface describing a void action of one argument */
DECL|interface|Action
DECL|method|accept
specifier|public
interface|interface
name|Action
parameter_list|<
name|A
parameter_list|>
block|{
name|void
name|accept
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a void action of two arguments */
DECL|interface|BiAction
DECL|method|accept
specifier|public
interface|interface
name|BiAction
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|void
name|accept
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of one argument */
DECL|interface|Fun
DECL|method|apply
specifier|public
interface|interface
name|Fun
parameter_list|<
name|A
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of two arguments */
DECL|interface|BiFun
DECL|method|apply
specifier|public
interface|interface
name|BiFun
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of no arguments */
DECL|interface|Generator
DECL|method|get
specifier|public
interface|interface
name|Generator
parameter_list|<
name|T
parameter_list|>
block|{
name|T
name|get
parameter_list|()
function_decl|;
block|}
comment|/*      * Overview:      *      * 1. Non-nullness of field result (set via CAS) indicates done.      * An AltResult is used to box null as a result, as well as to      * hold exceptions.  Using a single field makes completion fast      * and simple to detect and trigger, at the expense of a lot of      * encoding and decoding that infiltrates many methods. One minor      * simplification relies on the (static) NIL (to box null results)      * being the only AltResult with a null exception field, so we      * don't usually need explicit comparisons with NIL. The CF      * exception propagation mechanics surrounding decoding rely on      * unchecked casts of decoded results really being unchecked,      * where user type errors are caught at point of use, as is      * currently the case in Java. These are highlighted by using      * SuppressWarnings-annotated temporaries.      *      * 2. Waiters are held in a Treiber stack similar to the one used      * in FutureTask, Phaser, and SynchronousQueue. See their      * internal documentation for algorithmic details.      *      * 3. Completions are also kept in a list/stack, and pulled off      * and run when completion is triggered. (We could even use the      * same stack as for waiters, but would give up the potential      * parallelism obtained because woken waiters help release/run      * others -- see method postComplete).  Because post-processing      * may race with direct calls, class Completion opportunistically      * extends AtomicInteger so callers can claim the action via      * compareAndSet(0, 1).  The Completion.run methods are all      * written a boringly similar uniform way (that sometimes includes      * unnecessary-looking checks, kept to maintain uniformity).      * There are enough dimensions upon which they differ that      * attempts to factor commonalities while maintaining efficiency      * require more lines of code than they would save.      *      * 4. The exported then/and/or methods do support a bit of      * factoring (see doThenApply etc). They must cope with the      * intrinsic races surrounding addition of a dependent action      * versus performing the action directly because the task is      * already complete.  For example, a CF may not be complete upon      * entry, so a dependent completion is added, but by the time it      * is added, the target CF is complete, so must be directly      * executed. This is all done while avoiding unnecessary object      * construction in safe-bypass cases.      */
comment|// preliminaries
DECL|class|AltResult
specifier|static
specifier|final
class|class
name|AltResult
block|{
DECL|field|ex
specifier|final
name|Throwable
name|ex
decl_stmt|;
comment|// null only for NIL
DECL|method|AltResult
name|AltResult
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|this
operator|.
name|ex
operator|=
name|ex
expr_stmt|;
block|}
block|}
DECL|field|NIL
specifier|static
specifier|final
name|AltResult
name|NIL
init|=
operator|new
name|AltResult
argument_list|(
literal|null
argument_list|)
decl_stmt|;
comment|// Fields
DECL|field|result
specifier|volatile
name|Object
name|result
decl_stmt|;
comment|// Either the result or boxed AltResult
DECL|field|waiters
specifier|volatile
name|WaitNode
name|waiters
decl_stmt|;
comment|// Treiber stack of threads blocked on get()
DECL|field|completions
specifier|volatile
name|CompletionNode
name|completions
decl_stmt|;
comment|// list (Treiber stack) of completions
comment|// Basic utilities for triggering and processing completions
comment|/**      * Removes and signals all waiting threads and runs all completions.      */
DECL|method|postComplete
specifier|final
name|void
name|postComplete
parameter_list|()
block|{
name|WaitNode
name|q
decl_stmt|;
name|Thread
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|waiters
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
argument_list|,
name|q
operator|.
name|next
argument_list|)
operator|&&
operator|(
name|t
operator|=
name|q
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
name|CompletionNode
name|h
decl_stmt|;
name|Completion
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|h
operator|=
name|completions
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|h
argument_list|,
name|h
operator|.
name|next
argument_list|)
operator|&&
operator|(
name|c
operator|=
name|h
operator|.
name|completion
operator|)
operator|!=
literal|null
condition|)
name|c
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Triggers completion with the encoding of the given arguments:      * if the exception is non-null, encodes it as a wrapped      * CompletionException unless it is one already.  Otherwise uses      * the given result, boxed as NIL if null.      */
DECL|method|internalComplete
specifier|final
name|void
name|internalComplete
parameter_list|(
name|T
name|v
parameter_list|,
name|Throwable
name|ex
parameter_list|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
operator|(
name|ex
operator|==
literal|null
operator|)
condition|?
operator|(
name|v
operator|==
literal|null
operator|)
condition|?
name|NIL
else|:
name|v
else|:
operator|new
name|AltResult
argument_list|(
operator|(
name|ex
operator|instanceof
name|CompletionException
operator|)
condition|?
name|ex
else|:
operator|new
name|CompletionException
argument_list|(
name|ex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
comment|// help out even if not triggered
block|}
comment|/**      * If triggered, helps release and/or process completions.      */
DECL|method|helpPostComplete
specifier|final
name|void
name|helpPostComplete
parameter_list|()
block|{
if|if
condition|(
name|result
operator|!=
literal|null
condition|)
name|postComplete
argument_list|()
expr_stmt|;
block|}
comment|/* ------------- waiting for completions -------------- */
comment|/** Number of processors, for spin control */
DECL|field|NCPU
specifier|static
specifier|final
name|int
name|NCPU
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
decl_stmt|;
comment|/**      * Heuristic spin value for waitingGet() before blocking on      * multiprocessors      */
DECL|field|SPINS
specifier|static
specifier|final
name|int
name|SPINS
init|=
operator|(
name|NCPU
operator|>
literal|1
operator|)
condition|?
literal|1
operator|<<
literal|8
else|:
literal|0
decl_stmt|;
comment|/**      * Linked nodes to record waiting threads in a Treiber stack.  See      * other classes such as Phaser and SynchronousQueue for more      * detailed explanation. This class implements ManagedBlocker to      * avoid starvation when blocking actions pile up in      * ForkJoinPools.      */
DECL|class|WaitNode
specifier|static
specifier|final
class|class
name|WaitNode
implements|implements
name|ForkJoinPool
operator|.
name|ManagedBlocker
block|{
DECL|field|nanos
name|long
name|nanos
decl_stmt|;
comment|// wait time if timed
DECL|field|deadline
specifier|final
name|long
name|deadline
decl_stmt|;
comment|// non-zero if timed
DECL|field|interruptControl
specifier|volatile
name|int
name|interruptControl
decl_stmt|;
comment|//> 0: interruptible,< 0: interrupted
DECL|field|thread
specifier|volatile
name|Thread
name|thread
decl_stmt|;
DECL|field|next
specifier|volatile
name|WaitNode
name|next
decl_stmt|;
DECL|method|WaitNode
name|WaitNode
parameter_list|(
name|boolean
name|interruptible
parameter_list|,
name|long
name|nanos
parameter_list|,
name|long
name|deadline
parameter_list|)
block|{
name|this
operator|.
name|thread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
name|this
operator|.
name|interruptControl
operator|=
name|interruptible
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|this
operator|.
name|nanos
operator|=
name|nanos
expr_stmt|;
name|this
operator|.
name|deadline
operator|=
name|deadline
expr_stmt|;
block|}
DECL|method|isReleasable
specifier|public
name|boolean
name|isReleasable
parameter_list|()
block|{
if|if
condition|(
name|thread
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|int
name|i
init|=
name|interruptControl
decl_stmt|;
name|interruptControl
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
name|deadline
operator|!=
literal|0L
operator|&&
operator|(
name|nanos
operator|<=
literal|0L
operator|||
operator|(
name|nanos
operator|=
name|deadline
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|<=
literal|0L
operator|)
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|block
specifier|public
name|boolean
name|block
parameter_list|()
block|{
if|if
condition|(
name|isReleasable
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
name|deadline
operator|==
literal|0L
condition|)
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nanos
operator|>
literal|0L
condition|)
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
return|return
name|isReleasable
argument_list|()
return|;
block|}
block|}
comment|/**      * Returns raw result after waiting, or null if interruptible and      * interrupted.      */
DECL|method|waitingGet
specifier|private
name|Object
name|waitingGet
parameter_list|(
name|boolean
name|interruptible
parameter_list|)
block|{
name|WaitNode
name|q
init|=
literal|null
decl_stmt|;
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
name|int
name|spins
init|=
name|SPINS
decl_stmt|;
for|for
control|(
name|Object
name|r
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
comment|// suppress unpark
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|interruptible
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
name|postComplete
argument_list|()
expr_stmt|;
comment|// help release others
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|>
literal|0
condition|)
block|{
name|int
name|rnd
init|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|rnd
operator|>=
literal|0
condition|)
operator|--
name|spins
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|==
literal|null
condition|)
name|q
operator|=
operator|new
name|WaitNode
argument_list|(
name|interruptible
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
name|queued
operator|=
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
operator|.
name|next
operator|=
name|waiters
argument_list|,
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|interruptible
operator|&&
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|thread
operator|!=
literal|null
operator|&&
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|ForkJoinPool
operator|.
name|managedBlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|q
operator|.
name|interruptControl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Awaits completion or aborts on interrupt or timeout.      *      * @param nanos time to wait      * @return raw result      */
DECL|method|timedAwaitDone
specifier|private
name|Object
name|timedAwaitDone
parameter_list|(
name|long
name|nanos
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
name|WaitNode
name|q
init|=
literal|null
decl_stmt|;
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Object
name|r
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
block|}
name|postComplete
argument_list|()
expr_stmt|;
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|nanos
operator|<=
literal|0L
condition|)
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
name|long
name|d
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|nanos
decl_stmt|;
name|q
operator|=
operator|new
name|WaitNode
argument_list|(
literal|true
argument_list|,
name|nanos
argument_list|,
name|d
operator|==
literal|0L
condition|?
literal|1L
else|:
name|d
argument_list|)
expr_stmt|;
comment|// avoid 0
block|}
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
name|queued
operator|=
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
operator|.
name|next
operator|=
name|waiters
argument_list|,
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|.
name|interruptControl
operator|<
literal|0
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|nanos
operator|<=
literal|0L
condition|)
block|{
if|if
condition|(
name|result
operator|==
literal|null
condition|)
block|{
name|removeWaiter
argument_list|(
name|q
argument_list|)
expr_stmt|;
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|thread
operator|!=
literal|null
operator|&&
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|ForkJoinPool
operator|.
name|managedBlock
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ex
parameter_list|)
block|{
name|q
operator|.
name|interruptControl
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Tries to unlink a timed-out or interrupted wait node to avoid      * accumulating garbage.  Internal nodes are simply unspliced      * without CAS since it is harmless if they are traversed anyway      * by releasers.  To avoid effects of unsplicing from already      * removed nodes, the list is retraversed in case of an apparent      * race.  This is slow when there are a lot of nodes, but we don't      * expect lists to be long enough to outweigh higher-overhead      * schemes.      */
DECL|method|removeWaiter
specifier|private
name|void
name|removeWaiter
parameter_list|(
name|WaitNode
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|retry
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// restart on removeWaiter race
for|for
control|(
name|WaitNode
name|pred
init|=
literal|null
init|,
name|q
init|=
name|waiters
init|,
name|s
init|;
name|q
operator|!=
literal|null
condition|;
name|q
operator|=
name|s
control|)
block|{
name|s
operator|=
name|q
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|thread
operator|!=
literal|null
condition|)
name|pred
operator|=
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
block|{
name|pred
operator|.
name|next
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|pred
operator|.
name|thread
operator|==
literal|null
condition|)
comment|// check for race
continue|continue
name|retry
continue|;
block|}
elseif|else
if|if
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WAITERS
argument_list|,
name|q
argument_list|,
name|s
argument_list|)
condition|)
continue|continue
name|retry
continue|;
block|}
break|break;
block|}
block|}
block|}
comment|/* ------------- Async tasks -------------- */
comment|/**      * A marker interface identifying asynchronous tasks produced by      * {@code async} methods. This may be useful for monitoring,      * debugging, and tracking asynchronous activities.      *      * @since 1.8      */
DECL|interface|AsynchronousCompletionTask
specifier|public
specifier|static
interface|interface
name|AsynchronousCompletionTask
block|{     }
comment|/** Base class can act as either FJ or plain Runnable */
DECL|class|Async
specifier|abstract
specifier|static
class|class
name|Async
extends|extends
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
implements|implements
name|Runnable
implements|,
name|AsynchronousCompletionTask
block|{
DECL|method|getRawResult
specifier|public
specifier|final
name|Void
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|Void
name|v
parameter_list|)
block|{ }
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
name|exec
argument_list|()
expr_stmt|;
block|}
block|}
DECL|class|AsyncRun
specifier|static
specifier|final
class|class
name|AsyncRun
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncRun
name|AsyncRun
parameter_list|(
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|d
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncSupply
specifier|static
specifier|final
class|class
name|AsyncSupply
parameter_list|<
name|U
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|fn
specifier|final
name|Generator
argument_list|<
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncSupply
name|AsyncSupply
parameter_list|(
name|Generator
argument_list|<
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|d
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|get
argument_list|()
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncApply
specifier|static
specifier|final
class|class
name|AsyncApply
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|arg
specifier|final
name|T
name|arg
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncApply
name|AsyncApply
parameter_list|(
name|T
name|arg
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|d
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncCombine
specifier|static
specifier|final
class|class
name|AsyncCombine
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|arg1
specifier|final
name|T
name|arg1
decl_stmt|;
DECL|field|arg2
specifier|final
name|U
name|arg2
decl_stmt|;
DECL|field|fn
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncCombine
name|AsyncCombine
parameter_list|(
name|T
name|arg1
parameter_list|,
name|U
name|arg2
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg1
operator|=
name|arg1
expr_stmt|;
name|this
operator|.
name|arg2
operator|=
name|arg2
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|d
decl_stmt|;
name|V
name|v
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|v
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
name|v
operator|=
literal|null
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
name|v
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncAccept
specifier|static
specifier|final
class|class
name|AsyncAccept
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|arg
specifier|final
name|T
name|arg
decl_stmt|;
DECL|field|fn
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncAccept
name|AsyncAccept
parameter_list|(
name|T
name|arg
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|d
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|fn
operator|.
name|accept
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncAcceptBoth
specifier|static
specifier|final
class|class
name|AsyncAcceptBoth
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|arg1
specifier|final
name|T
name|arg1
decl_stmt|;
DECL|field|arg2
specifier|final
name|U
name|arg2
decl_stmt|;
DECL|field|fn
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncAcceptBoth
name|AsyncAcceptBoth
parameter_list|(
name|T
name|arg1
parameter_list|,
name|U
name|arg2
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg1
operator|=
name|arg1
expr_stmt|;
name|this
operator|.
name|arg2
operator|=
name|arg2
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|d
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|fn
operator|.
name|accept
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|ex
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
name|d
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AsyncCompose
specifier|static
specifier|final
class|class
name|AsyncCompose
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Async
block|{
DECL|field|arg
specifier|final
name|T
name|arg
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|AsyncCompose
name|AsyncCompose
parameter_list|(
name|T
name|arg
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|d
decl_stmt|,
name|fr
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
name|d
operator|.
name|result
operator|==
literal|null
condition|)
block|{
try|try
block|{
name|fr
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ex
operator|=
operator|(
name|fr
operator|==
literal|null
operator|)
condition|?
operator|new
name|NullPointerException
argument_list|()
else|:
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
name|fr
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
else|else
block|{
name|Object
name|r
init|=
name|fr
operator|.
name|result
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
name|r
operator|=
name|fr
operator|.
name|waitingGet
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|ur
init|=
operator|(
name|U
operator|)
name|r
decl_stmt|;
name|u
operator|=
name|ur
expr_stmt|;
block|}
block|}
name|d
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|/* ------------- Completions -------------- */
comment|/**      * Simple linked list nodes to record completions, used in      * basically the same way as WaitNodes. (We separate nodes from      * the Completions themselves mainly because for the And and Or      * methods, the same Completion object resides in two lists.)      */
DECL|class|CompletionNode
specifier|static
specifier|final
class|class
name|CompletionNode
block|{
DECL|field|completion
specifier|final
name|Completion
name|completion
decl_stmt|;
DECL|field|next
specifier|volatile
name|CompletionNode
name|next
decl_stmt|;
DECL|method|CompletionNode
name|CompletionNode
parameter_list|(
name|Completion
name|completion
parameter_list|)
block|{
name|this
operator|.
name|completion
operator|=
name|completion
expr_stmt|;
block|}
block|}
comment|// Opportunistically subclass AtomicInteger to use compareAndSet to claim.
DECL|class|Completion
specifier|abstract
specifier|static
class|class
name|Completion
extends|extends
name|AtomicInteger
implements|implements
name|Runnable
block|{     }
DECL|class|ThenApply
specifier|static
specifier|final
class|class
name|ThenApply
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ThenApply
name|ThenApply
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ThenAccept
specifier|static
specifier|final
class|class
name|ThenAccept
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ThenAccept
name|ThenAccept
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ThenRun
specifier|static
specifier|final
class|class
name|ThenRun
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ThenRun
name|ThenRun
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
parameter_list|,
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Runnable
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ThenCombine
specifier|static
specifier|final
class|class
name|ThenCombine
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ThenCombine
name|ThenCombine
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|b
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
decl_stmt|;
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
name|V
name|v
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncCombine
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|v
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ThenAcceptBoth
specifier|static
specifier|final
class|class
name|ThenAcceptBoth
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ThenAcceptBoth
name|ThenAcceptBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|snd
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|b
decl_stmt|;
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
decl_stmt|;
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAcceptBoth
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|RunAfterBoth
specifier|static
specifier|final
class|class
name|RunAfterBoth
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|RunAfterBoth
name|RunAfterBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
parameter_list|,
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Runnable
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
operator|&&
operator|(
name|s
operator|instanceof
name|AltResult
operator|)
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AndCompletion
specifier|static
specifier|final
class|class
name|AndCompletion
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|AndCompletion
name|AndCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|b
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
operator|&&
operator|(
name|s
operator|instanceof
name|AltResult
operator|)
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ApplyToEither
specifier|static
specifier|final
class|class
name|ApplyToEither
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ApplyToEither
name|ApplyToEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|AcceptEither
specifier|static
specifier|final
class|class
name|AcceptEither
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|AcceptEither
name|AcceptEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|snd
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|RunAfterEither
specifier|static
specifier|final
class|class
name|RunAfterEither
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
decl_stmt|;
DECL|field|fn
specifier|final
name|Runnable
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|RunAfterEither
name|RunAfterEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
parameter_list|,
name|Runnable
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|b
decl_stmt|;
specifier|final
name|Runnable
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
name|Executor
name|e
init|=
name|executor
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|OrCompletion
specifier|static
specifier|final
class|class
name|OrCompletion
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
decl_stmt|;
DECL|field|snd
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
name|dst
decl_stmt|;
DECL|method|OrCompletion
name|OrCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|snd
parameter_list|,
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|snd
operator|=
name|snd
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|b
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|b
operator|=
name|this
operator|.
name|snd
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|b
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|)
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
name|t
operator|=
name|r
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ExceptionCompletion
specifier|static
specifier|final
class|class
name|ExceptionCompletion
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
DECL|method|ExceptionCompletion
name|ExceptionCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
init|=
literal|null
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|dx
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
operator|&&
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|t
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
block|}
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ThenCopy
specifier|static
specifier|final
class|class
name|ThenCopy
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
DECL|method|ThenCopy
name|ThenCopy
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|// version of ThenCopy for CompletableFuture<Void> dst
DECL|class|ThenPropagate
specifier|static
specifier|final
class|class
name|ThenPropagate
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
DECL|method|ThenPropagate
name|ThenPropagate
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|src
parameter_list|,
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|a
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|HandleCompletion
specifier|static
specifier|final
class|class
name|HandleCompletion
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|method|HandleCompletion
name|HandleCompletion
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
init|=
literal|null
decl_stmt|;
name|Throwable
name|dx
init|=
literal|null
decl_stmt|;
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
DECL|class|ThenCompose
specifier|static
specifier|final
class|class
name|ThenCompose
parameter_list|<
name|T
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Completion
block|{
DECL|field|src
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
decl_stmt|;
DECL|field|fn
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
decl_stmt|;
DECL|field|dst
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
DECL|field|executor
specifier|final
name|Executor
name|executor
decl_stmt|;
DECL|method|ThenCompose
name|ThenCompose
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|src
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
name|this
operator|.
name|src
operator|=
name|src
expr_stmt|;
name|this
operator|.
name|fn
operator|=
name|fn
expr_stmt|;
name|this
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
name|this
operator|.
name|executor
operator|=
name|executor
expr_stmt|;
block|}
DECL|method|run
specifier|public
specifier|final
name|void
name|run
parameter_list|()
block|{
specifier|final
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|a
decl_stmt|;
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
decl_stmt|;
specifier|final
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
decl_stmt|;
name|Object
name|r
decl_stmt|;
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
name|Executor
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|this
operator|.
name|dst
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|fn
operator|=
name|this
operator|.
name|fn
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|this
operator|.
name|src
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|a
operator|.
name|result
operator|)
operator|!=
literal|null
operator|&&
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|c
init|=
literal|null
decl_stmt|;
name|U
name|u
init|=
literal|null
decl_stmt|;
name|boolean
name|complete
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|executor
operator|)
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncCompose
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
try|try
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
name|ThenCopy
argument_list|<
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|c
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ThenCopy
argument_list|<
name|U
argument_list|>
argument_list|(
name|c
argument_list|,
name|dst
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|c
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|c
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|c
operator|.
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|complete
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
comment|// no rewrap
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|complete
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
name|c
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
block|}
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453952276885070L
decl_stmt|;
block|}
comment|// public methods
comment|/**      * Creates a new incomplete CompletableFuture.      */
DECL|method|CompletableFuture
specifier|public
name|CompletableFuture
parameter_list|()
block|{     }
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * by a task running in the {@link ForkJoinPool#commonPool()} with      * the value obtained by calling the given Generator.      *      * @param supplier a function returning the value to be used      * to complete the returned CompletableFuture      * @param<U> the function's return type      * @return the new CompletableFuture      */
DECL|method|supplyAsync
specifier|public
specifier|static
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|supplyAsync
parameter_list|(
name|Generator
argument_list|<
name|U
argument_list|>
name|supplier
parameter_list|)
block|{
if|if
condition|(
name|supplier
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
operator|.
name|execute
argument_list|(
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
operator|new
name|AsyncSupply
argument_list|<
name|U
argument_list|>
argument_list|(
name|supplier
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * by a task running in the given executor with the value obtained      * by calling the given Generator.      *      * @param supplier a function returning the value to be used      * to complete the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @param<U> the function's return type      * @return the new CompletableFuture      */
DECL|method|supplyAsync
specifier|public
specifier|static
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|supplyAsync
parameter_list|(
name|Generator
argument_list|<
name|U
argument_list|>
name|supplier
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
operator|||
name|supplier
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|AsyncSupply
argument_list|<
name|U
argument_list|>
argument_list|(
name|supplier
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * by a task running in the {@link ForkJoinPool#commonPool()} after      * it runs the given action.      *      * @param runnable the action to run before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAsync
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAsync
parameter_list|(
name|Runnable
name|runnable
parameter_list|)
block|{
if|if
condition|(
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
operator|.
name|execute
argument_list|(
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
operator|new
name|AsyncRun
argument_list|(
name|runnable
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * by a task running in the given executor after it runs the given      * action.      *      * @param runnable the action to run before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|runAsync
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAsync
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
operator|||
name|runnable
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|executor
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|runnable
argument_list|,
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is already completed with      * the given value.      *      * @param value the value      * @param<U> the type of the value      * @return the completed CompletableFuture      */
DECL|method|completedFuture
specifier|public
specifier|static
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|completedFuture
parameter_list|(
name|U
name|value
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|f
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|f
operator|.
name|result
operator|=
operator|(
name|value
operator|==
literal|null
operator|)
condition|?
name|NIL
else|:
name|value
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/**      * Returns {@code true} if completed in any fashion: normally,      * exceptionally, or via cancellation.      *      * @return {@code true} if completed      */
DECL|method|isDone
specifier|public
name|boolean
name|isDone
parameter_list|()
block|{
return|return
name|result
operator|!=
literal|null
return|;
block|}
comment|/**      * Waits if necessary for this future to complete, and then      * returns its result.      *      * @return the result value      * @throws CancellationException if this future was cancelled      * @throws ExecutionException if this future completed exceptionally      * @throws InterruptedException if the current thread was interrupted      * while waiting      */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|()
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|cause
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|waitingGet
argument_list|(
literal|true
argument_list|)
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
operator|(
name|ex
operator|instanceof
name|CompletionException
operator|)
operator|&&
operator|(
name|cause
operator|=
name|ex
operator|.
name|getCause
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|ex
operator|=
name|cause
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * Waits if necessary for at most the given time for this future      * to complete, and then returns its result, if available.      *      * @param timeout the maximum time to wait      * @param unit the time unit of the timeout argument      * @return the result value      * @throws CancellationException if this future was cancelled      * @throws ExecutionException if this future completed exceptionally      * @throws InterruptedException if the current thread was interrupted      * while waiting      * @throws TimeoutException if the wait timed out      */
DECL|method|get
specifier|public
name|T
name|get
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|ExecutionException
throws|,
name|TimeoutException
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|cause
decl_stmt|;
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
name|r
operator|=
name|timedAwaitDone
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
operator|(
name|ex
operator|instanceof
name|CompletionException
operator|)
operator|&&
operator|(
name|cause
operator|=
name|ex
operator|.
name|getCause
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|ex
operator|=
name|cause
expr_stmt|;
throw|throw
operator|new
name|ExecutionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * Returns the result value when complete, or throws an      * (unchecked) exception if completed exceptionally. To better      * conform with the use of common functional forms, if a      * computation involved in the completion of this      * CompletableFuture threw an exception, this method throws an      * (unchecked) {@link CompletionException} with the underlying      * exception as its cause.      *      * @return the result value      * @throws CancellationException if the computation was cancelled      * @throws CompletionException if this future completed      * exceptionally or a completion computation threw an exception      */
DECL|method|join
specifier|public
name|T
name|join
parameter_list|()
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
name|r
operator|=
name|waitingGet
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
name|ex
operator|instanceof
name|CompletionException
condition|)
throw|throw
operator|(
name|CompletionException
operator|)
name|ex
throw|;
throw|throw
operator|new
name|CompletionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * Returns the result value (or throws any encountered exception)      * if completed, else returns the given valueIfAbsent.      *      * @param valueIfAbsent the value to return if not completed      * @return the result value, if completed, else the given valueIfAbsent      * @throws CancellationException if the computation was cancelled      * @throws CompletionException if this future completed      * exceptionally or a completion computation threw an exception      */
DECL|method|getNow
specifier|public
name|T
name|getNow
parameter_list|(
name|T
name|valueIfAbsent
parameter_list|)
block|{
name|Object
name|r
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
return|return
name|valueIfAbsent
return|;
if|if
condition|(
operator|!
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
return|return
name|tr
return|;
block|}
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
name|ex
operator|instanceof
name|CancellationException
condition|)
throw|throw
operator|(
name|CancellationException
operator|)
name|ex
throw|;
if|if
condition|(
name|ex
operator|instanceof
name|CompletionException
condition|)
throw|throw
operator|(
name|CompletionException
operator|)
name|ex
throw|;
throw|throw
operator|new
name|CompletionException
argument_list|(
name|ex
argument_list|)
throw|;
block|}
comment|/**      * If not already completed, sets the value returned by {@link      * #get()} and related methods to the given value.      *      * @param value the result value      * @return {@code true} if this invocation caused this CompletableFuture      * to transition to a completed state, else {@code false}      */
DECL|method|complete
specifier|public
name|boolean
name|complete
parameter_list|(
name|T
name|value
parameter_list|)
block|{
name|boolean
name|triggered
init|=
name|result
operator|==
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
name|value
operator|==
literal|null
condition|?
name|NIL
else|:
name|value
argument_list|)
decl_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
return|return
name|triggered
return|;
block|}
comment|/**      * If not already completed, causes invocations of {@link #get()}      * and related methods to throw the given exception.      *      * @param ex the exception      * @return {@code true} if this invocation caused this CompletableFuture      * to transition to a completed state, else {@code false}      */
DECL|method|completeExceptionally
specifier|public
name|boolean
name|completeExceptionally
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|boolean
name|triggered
init|=
name|result
operator|==
literal|null
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
operator|new
name|AltResult
argument_list|(
name|ex
argument_list|)
argument_list|)
decl_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
return|return
name|triggered
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when this CompletableFuture completes, with the result of the      * given function of this CompletableFuture's result.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied function throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenApply
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenApply
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenApply
argument_list|(
name|fn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when this CompletableFuture completes, with the result of the      * given function of this CompletableFuture's result from a      * task running in the {@link ForkJoinPool#commonPool()}.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied function throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenApplyAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenApplyAsync
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenApply
argument_list|(
name|fn
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when this CompletableFuture completes, with the result of the      * given function of this CompletableFuture's result from a      * task running in the given executor.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied function throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenApplyAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenApplyAsync
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenApply
argument_list|(
name|fn
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenApply
specifier|private
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|doThenApply
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|ThenApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ThenApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when this CompletableFuture completes, after performing the given      * action with this CompletableFuture's result.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied action throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAccept
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAccept
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenAccept
argument_list|(
name|block
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when this CompletableFuture completes, after performing the given      * action with this CompletableFuture's result from a task running      * in the {@link ForkJoinPool#commonPool()}.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied action throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAcceptAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptAsync
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenAccept
argument_list|(
name|block
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when this CompletableFuture completes, after performing the given      * action with this CompletableFuture's result from a task running      * in the given executor.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied action throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param block the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenAcceptAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptAsync
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenAccept
argument_list|(
name|block
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenAccept
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doThenAccept
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|ThenAccept
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ThenAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when this CompletableFuture completes, after performing the given      * action.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied action throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenRun
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenRun
parameter_list|(
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doThenRun
argument_list|(
name|action
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when this CompletableFuture completes, after performing the given      * action from a task running in the {@link ForkJoinPool#commonPool()}.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied action throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenRunAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenRunAsync
parameter_list|(
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doThenRun
argument_list|(
name|action
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when this CompletableFuture completes, after performing the given      * action from a task running in the given executor.      *      *<p>If this CompletableFuture completes exceptionally, or the      * supplied action throws an exception, then the returned      * CompletableFuture completes exceptionally with a      * CompletionException holding the exception as its cause.      *      * @param action the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenRunAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenRunAsync
parameter_list|(
name|Runnable
name|action
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenRun
argument_list|(
name|action
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenRun
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doThenRun
parameter_list|(
name|Runnable
name|action
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|ThenRun
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ThenRun
argument_list|(
name|this
argument_list|,
name|action
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|action
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when both this and the other given CompletableFuture complete,      * with the result of the given function of the results of the two      * CompletableFutures.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied function throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenCombine
specifier|public
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|thenCombine
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenCombine
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when both this and the other given CompletableFuture complete,      * with the result of the given function of the results of the two      * CompletableFutures from a task running in the      * {@link ForkJoinPool#commonPool()}.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied function throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenCombineAsync
specifier|public
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|thenCombineAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenCombine
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when both this and the other given CompletableFuture complete,      * with the result of the given function of the results of the two      * CompletableFutures from a task running in the given executor.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied function throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenCombineAsync
specifier|public
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|thenCombineAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenCombine
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenCombine
specifier|private
parameter_list|<
name|U
parameter_list|,
name|V
parameter_list|>
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|doThenCombine
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|V
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
name|ThenCombine
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|||
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|ThenCombine
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|s
operator|==
literal|null
operator|&&
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
break|break;
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
name|V
name|v
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncCombine
argument_list|<
name|T
argument_list|,
name|U
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|v
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when both this and the other given CompletableFuture complete,      * after performing the given action with the results of the two      * CompletableFutures.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied action throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAcceptBoth
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenAcceptBoth
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when both this and the other given CompletableFuture complete,      * after performing the given action with the results of the two      * CompletableFutures from a task running in the {@link      * ForkJoinPool#commonPool()}.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied action throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|thenAcceptBothAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doThenAcceptBoth
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when both this and the other given CompletableFuture complete,      * after performing the given action with the results of the two      * CompletableFutures from a task running in the given executor.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied action throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|thenAcceptBothAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|thenAcceptBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|block
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenAcceptBoth
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenAcceptBoth
specifier|private
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doThenAcceptBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|U
argument_list|>
name|other
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|T
argument_list|,
name|?
super|super
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|ThenAcceptBoth
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|||
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|ThenAcceptBoth
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|s
operator|==
literal|null
operator|&&
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
break|break;
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|U
name|u
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|u
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|U
name|us
init|=
operator|(
name|U
operator|)
name|s
decl_stmt|;
name|u
operator|=
name|us
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAcceptBoth
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|u
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when both this and the other given CompletableFuture complete,      * after performing the given action.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied action throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterBoth
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doRunAfterBoth
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when both this and the other given CompletableFuture complete,      * after performing the given action from a task running in the      * {@link ForkJoinPool#commonPool()}.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied action throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterBothAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doRunAfterBoth
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when both this and the other given CompletableFuture complete,      * after performing the given action from a task running in the      * given executor.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, or the supplied action throws an exception,      * then the returned CompletableFuture completes exceptionally      * with a CompletionException holding the exception as its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|runAfterBothAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterBothAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doRunAfterBoth
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doRunAfterBoth
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doRunAfterBoth
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|RunAfterBoth
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|,
name|s
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|||
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|RunAfterBoth
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|action
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|s
operator|==
literal|null
operator|&&
operator|(
name|s
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|!=
literal|null
operator|||
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
break|break;
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|s
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
operator|&&
operator|(
name|s
operator|instanceof
name|AltResult
operator|)
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|action
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when either this or the other given CompletableFuture completes,      * with the result of the given function of either this or the other      * CompletableFuture's result.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied function      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|applyToEither
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|applyToEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doApplyToEither
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when either this or the other given CompletableFuture completes,      * with the result of the given function of either this or the other      * CompletableFuture's result from a task running in the      * {@link ForkJoinPool#commonPool()}.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied function      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|applyToEitherAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|applyToEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doApplyToEither
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when either this or the other given CompletableFuture completes,      * with the result of the given function of either this or the other      * CompletableFuture's result from a task running in the      * given executor.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied function      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param fn the function to use to compute the value of      * the returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|applyToEitherAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|applyToEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doApplyToEither
argument_list|(
name|other
argument_list|,
name|fn
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doApplyToEither
specifier|private
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|doApplyToEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|U
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|ApplyToEither
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|ApplyToEither
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncApply
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when either this or the other given CompletableFuture completes,      * after performing the given action with the result of either this      * or the other CompletableFuture's result.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied action      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|acceptEither
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|acceptEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doAcceptEither
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when either this or the other given CompletableFuture completes,      * after performing the given action with the result of either this      * or the other CompletableFuture's result from a task running in      * the {@link ForkJoinPool#commonPool()}.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied action      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|acceptEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|acceptEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|)
block|{
return|return
name|doAcceptEither
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when either this or the other given CompletableFuture completes,      * after performing the given action with the result of either this      * or the other CompletableFuture's result from a task running in      * the given executor.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied action      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param block the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|acceptEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|acceptEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|block
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doAcceptEither
argument_list|(
name|other
argument_list|,
name|block
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doAcceptEither
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doAcceptEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
extends|extends
name|T
argument_list|>
name|other
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|AcceptEither
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|AcceptEither
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncAccept
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fn
operator|.
name|accept
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed      * when either this or the other given CompletableFuture completes,      * after performing the given action.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied action      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterEither
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doRunAfterEither
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when either this or the other given CompletableFuture completes,      * after performing the given action from a task running in the      * {@link ForkJoinPool#commonPool()}.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied action      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|runAfterEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|)
block|{
return|return
name|doRunAfterEither
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is asynchronously completed      * when either this or the other given CompletableFuture completes,      * after performing the given action from a task running in the      * given executor.      *      *<p>If this and/or the other CompletableFuture complete      * exceptionally, then the returned CompletableFuture may also do so,      * with a CompletionException holding one of these exceptions as its      * cause.  No guarantees are made about which result or exception is      * used in the returned CompletableFuture.  If the supplied action      * throws an exception, then the returned CompletableFuture completes      * exceptionally with a CompletionException holding the exception as      * its cause.      *      * @param other the other CompletableFuture      * @param action the action to perform before completing the      * returned CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the new CompletableFuture      */
DECL|method|runAfterEitherAsync
specifier|public
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|runAfterEitherAsync
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doRunAfterEither
argument_list|(
name|other
argument_list|,
name|action
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doRunAfterEither
specifier|private
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|doRunAfterEither
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|other
parameter_list|,
name|Runnable
name|action
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|other
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|RunAfterEither
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|d
operator|=
operator|new
name|RunAfterEither
argument_list|(
name|this
argument_list|,
name|other
argument_list|,
name|action
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|CompletionNode
name|q
init|=
literal|null
decl_stmt|,
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|other
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|other
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|other
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
try|try
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncRun
argument_list|(
name|action
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|action
operator|.
name|run
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
if|if
condition|(
name|e
operator|==
literal|null
operator|||
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|other
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a CompletableFuture that upon completion, has the same      * value as produced by the given function of the result of this      * CompletableFuture.      *      *<p>If this CompletableFuture completes exceptionally, then the      * returned CompletableFuture also does so, with a      * CompletionException holding this exception as its cause.      * Similarly, if the computed CompletableFuture completes      * exceptionally, then so does the returned CompletableFuture.      *      * @param fn the function returning a new CompletableFuture      * @return the CompletableFuture      */
DECL|method|thenCompose
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenCompose
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenCompose
argument_list|(
name|fn
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Returns a CompletableFuture that upon completion, has the same      * value as that produced asynchronously using the {@link      * ForkJoinPool#commonPool()} by the given function of the result      * of this CompletableFuture.      *      *<p>If this CompletableFuture completes exceptionally, then the      * returned CompletableFuture also does so, with a      * CompletionException holding this exception as its cause.      * Similarly, if the computed CompletableFuture completes      * exceptionally, then so does the returned CompletableFuture.      *      * @param fn the function returning a new CompletableFuture      * @return the CompletableFuture      */
DECL|method|thenComposeAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenComposeAsync
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|)
block|{
return|return
name|doThenCompose
argument_list|(
name|fn
argument_list|,
name|ForkJoinPool
operator|.
name|commonPool
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns a CompletableFuture that upon completion, has the same      * value as that produced asynchronously using the given executor      * by the given function of this CompletableFuture.      *      *<p>If this CompletableFuture completes exceptionally, then the      * returned CompletableFuture also does so, with a      * CompletionException holding this exception as its cause.      * Similarly, if the computed CompletableFuture completes      * exceptionally, then so does the returned CompletableFuture.      *      * @param fn the function returning a new CompletableFuture      * @param executor the executor to use for asynchronous execution      * @return the CompletableFuture      */
DECL|method|thenComposeAsync
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|thenComposeAsync
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|,
name|Executor
name|executor
parameter_list|)
block|{
if|if
condition|(
name|executor
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|doThenCompose
argument_list|(
name|fn
argument_list|,
name|executor
argument_list|)
return|;
block|}
DECL|method|doThenCompose
specifier|private
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|doThenCompose
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|>
name|fn
parameter_list|,
name|Executor
name|e
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
literal|null
decl_stmt|;
name|ThenCompose
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|dst
operator|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
expr_stmt|;
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ThenCompose
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|,
name|e
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dst
operator|==
literal|null
condition|)
name|dst
operator|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
expr_stmt|;
name|e
operator|.
name|execute
argument_list|(
operator|new
name|AsyncCompose
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|t
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
if|if
condition|(
operator|(
name|dst
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|ex
operator|=
operator|new
name|NullPointerException
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dst
operator|==
literal|null
condition|)
name|dst
operator|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
expr_stmt|;
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
name|dst
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed when this      * CompletableFuture completes, with the result of the given      * function of the exception triggering this CompletableFuture's      * completion when it completes exceptionally; otherwise, if this      * CompletableFuture completes normally, then the returned      * CompletableFuture also completes normally with the same value.      *      * @param fn the function to use to compute the value of the      * returned CompletableFuture if this CompletableFuture completed      * exceptionally      * @return the new CompletableFuture      */
DECL|method|exceptionally
specifier|public
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|exceptionally
parameter_list|(
name|Fun
argument_list|<
name|Throwable
argument_list|,
name|?
extends|extends
name|T
argument_list|>
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|T
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|T
argument_list|>
argument_list|()
decl_stmt|;
name|ExceptionCompletion
argument_list|<
name|T
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|ExceptionCompletion
argument_list|<
name|T
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
init|=
literal|null
decl_stmt|;
name|Throwable
name|ex
decl_stmt|,
name|dx
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
if|if
condition|(
operator|(
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|)
operator|!=
literal|null
condition|)
block|{
try|try
block|{
name|t
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed when this      * CompletableFuture completes, with the result of the given      * function of the result and exception of this CompletableFuture's      * completion.  The given function is invoked with the result (or      * {@code null} if none) and the exception (or {@code null} if none)      * of this CompletableFuture when complete.      *      * @param fn the function to use to compute the value of the      * returned CompletableFuture      * @return the new CompletableFuture      */
DECL|method|handle
specifier|public
parameter_list|<
name|U
parameter_list|>
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|handle
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|T
argument_list|,
name|Throwable
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|fn
parameter_list|)
block|{
if|if
condition|(
name|fn
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|U
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|U
argument_list|>
argument_list|()
decl_stmt|;
name|HandleCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
name|CompletionNode
name|p
init|=
operator|new
name|CompletionNode
argument_list|(
name|d
operator|=
operator|new
name|HandleCompletion
argument_list|<
name|T
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|fn
argument_list|,
name|dst
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|T
name|t
decl_stmt|;
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|T
name|tr
init|=
operator|(
name|T
operator|)
name|r
decl_stmt|;
name|t
operator|=
name|tr
expr_stmt|;
block|}
name|U
name|u
decl_stmt|;
name|Throwable
name|dx
decl_stmt|;
try|try
block|{
name|u
operator|=
name|fn
operator|.
name|apply
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|dx
operator|=
literal|null
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|dx
operator|=
name|rex
expr_stmt|;
name|u
operator|=
literal|null
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|u
argument_list|,
name|dx
argument_list|)
expr_stmt|;
block|}
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/* ------------- Arbitrary-arity constructions -------------- */
comment|/*      * The basic plan of attack is to recursively form binary      * completion trees of elements. This can be overkill for small      * sets, but scales nicely. The And/All vs Or/Any forms use the      * same idea, but details differ.      */
comment|/**      * Returns a new CompletableFuture that is completed when all of      * the given CompletableFutures complete.  If any of the given      * CompletableFutures complete exceptionally, then the returned      * CompletableFuture also does so, with a CompletionException      * holding this exception as its cause.  Otherwise, the results,      * if any, of the given CompletableFutures are not reflected in      * the returned CompletableFuture, but may be obtained by      * inspecting them individually. If no CompletableFutures are      * provided, returns a CompletableFuture completed with the value      * {@code null}.      *      *<p>Among the applications of this method is to await completion      * of a set of independent CompletableFutures before continuing a      * program, as in: {@code CompletableFuture.allOf(c1, c2,      * c3).join();}.      *      * @param cfs the CompletableFutures      * @return a new CompletableFuture that is completed when all of the      * given CompletableFutures complete      * @throws NullPointerException if the array or any of its elements are      * {@code null}      */
DECL|method|allOf
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|allOf
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
modifier|...
name|cfs
parameter_list|)
block|{
name|int
name|len
init|=
name|cfs
operator|.
name|length
decl_stmt|;
comment|// Directly handle empty and singleton cases
if|if
condition|(
name|len
operator|>
literal|1
condition|)
return|return
name|allTree
argument_list|(
name|cfs
argument_list|,
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
return|;
else|else
block|{
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|f
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|dst
operator|.
name|result
operator|=
name|NIL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|cfs
index|[
literal|0
index|]
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
else|else
block|{
name|ThenPropagate
name|d
init|=
literal|null
decl_stmt|;
name|CompletionNode
name|p
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|f
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|null
condition|)
name|d
operator|=
operator|new
name|ThenPropagate
argument_list|(
name|f
argument_list|,
name|dst
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|p
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|f
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|f
operator|.
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
condition|?
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
else|:
literal|null
argument_list|)
expr_stmt|;
name|f
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
block|}
comment|/**      * Recursively constructs an And'ed tree of CompletableFutures.      * Called only when array known to have at least two elements.      */
DECL|method|allTree
specifier|private
specifier|static
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|allTree
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
index|[]
name|cfs
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|fst
decl_stmt|,
name|snd
decl_stmt|;
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fst
operator|=
operator|(
name|lo
operator|==
name|mid
condition|?
name|cfs
index|[
name|lo
index|]
else|:
name|allTree
argument_list|(
name|cfs
argument_list|,
name|lo
argument_list|,
name|mid
argument_list|)
operator|)
operator|)
operator|==
literal|null
operator|||
operator|(
name|snd
operator|=
operator|(
name|hi
operator|==
name|mid
operator|+
literal|1
condition|?
name|cfs
index|[
name|hi
index|]
else|:
name|allTree
argument_list|(
name|cfs
argument_list|,
name|mid
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
operator|)
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Void
argument_list|>
argument_list|()
decl_stmt|;
name|AndCompletion
name|d
init|=
literal|null
decl_stmt|;
name|CompletionNode
name|p
init|=
literal|null
decl_stmt|,
name|q
init|=
literal|null
decl_stmt|;
name|Object
name|r
init|=
literal|null
decl_stmt|,
name|s
init|=
literal|null
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|fst
operator|.
name|result
operator|)
operator|==
literal|null
operator|||
operator|(
name|s
operator|=
name|snd
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|null
condition|)
name|d
operator|=
operator|new
name|AndCompletion
argument_list|(
name|fst
argument_list|,
name|snd
argument_list|,
name|dst
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|p
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|fst
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|fst
operator|.
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|snd
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|snd
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|r
operator|!=
literal|null
operator|||
operator|(
name|r
operator|=
name|fst
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|s
operator|!=
literal|null
operator|||
operator|(
name|s
operator|=
name|snd
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
else|else
name|ex
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|ex
operator|==
literal|null
operator|&&
operator|(
name|s
operator|instanceof
name|AltResult
operator|)
condition|)
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|s
operator|)
operator|.
name|ex
expr_stmt|;
name|dst
operator|.
name|internalComplete
argument_list|(
literal|null
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|fst
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
name|snd
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/**      * Returns a new CompletableFuture that is completed when any of      * the given CompletableFutures complete, with the same result.      * Otherwise, if it completed exceptionally, the returned      * CompletableFuture also does so, with a CompletionException      * holding this exception as its cause.  If no CompletableFutures      * are provided, returns an incomplete CompletableFuture.      *      * @param cfs the CompletableFutures      * @return a new CompletableFuture that is completed with the      * result or exception of any of the given CompletableFutures when      * one completes      * @throws NullPointerException if the array or any of its elements are      * {@code null}      */
DECL|method|anyOf
specifier|public
specifier|static
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
name|anyOf
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
modifier|...
name|cfs
parameter_list|)
block|{
name|int
name|len
init|=
name|cfs
operator|.
name|length
decl_stmt|;
comment|// Same idea as allOf
if|if
condition|(
name|len
operator|>
literal|1
condition|)
return|return
name|anyTree
argument_list|(
name|cfs
argument_list|,
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
return|;
else|else
block|{
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|f
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
empty_stmt|;
comment|// skip
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|cfs
index|[
literal|0
index|]
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
else|else
block|{
name|ThenCopy
argument_list|<
name|Object
argument_list|>
name|d
init|=
literal|null
decl_stmt|;
name|CompletionNode
name|p
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|f
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|null
condition|)
name|d
operator|=
operator|new
name|ThenCopy
argument_list|<
name|Object
argument_list|>
argument_list|(
name|f
argument_list|,
name|dst
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|p
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|f
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|f
operator|.
name|completions
argument_list|,
name|p
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
name|Object
name|t
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
name|t
operator|=
name|r
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|f
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
block|}
return|return
name|dst
return|;
block|}
block|}
comment|/**      * Recursively constructs an Or'ed tree of CompletableFutures.      */
DECL|method|anyTree
specifier|private
specifier|static
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
name|anyTree
parameter_list|(
name|CompletableFuture
argument_list|<
name|?
argument_list|>
index|[]
name|cfs
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
name|CompletableFuture
argument_list|<
name|?
argument_list|>
name|fst
decl_stmt|,
name|snd
decl_stmt|;
name|int
name|mid
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|>>>
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fst
operator|=
operator|(
name|lo
operator|==
name|mid
condition|?
name|cfs
index|[
name|lo
index|]
else|:
name|anyTree
argument_list|(
name|cfs
argument_list|,
name|lo
argument_list|,
name|mid
argument_list|)
operator|)
operator|)
operator|==
literal|null
operator|||
operator|(
name|snd
operator|=
operator|(
name|hi
operator|==
name|mid
operator|+
literal|1
condition|?
name|cfs
index|[
name|hi
index|]
else|:
name|anyTree
argument_list|(
name|cfs
argument_list|,
name|mid
operator|+
literal|1
argument_list|,
name|hi
argument_list|)
operator|)
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
name|dst
init|=
operator|new
name|CompletableFuture
argument_list|<
name|Object
argument_list|>
argument_list|()
decl_stmt|;
name|OrCompletion
name|d
init|=
literal|null
decl_stmt|;
name|CompletionNode
name|p
init|=
literal|null
decl_stmt|,
name|q
init|=
literal|null
decl_stmt|;
name|Object
name|r
decl_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|fst
operator|.
name|result
operator|)
operator|==
literal|null
operator|&&
operator|(
name|r
operator|=
name|snd
operator|.
name|result
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|null
condition|)
name|d
operator|=
operator|new
name|OrCompletion
argument_list|(
name|fst
argument_list|,
name|snd
argument_list|,
name|dst
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|p
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|fst
argument_list|,
name|COMPLETIONS
argument_list|,
name|p
operator|.
name|next
operator|=
name|fst
operator|.
name|completions
argument_list|,
name|p
argument_list|)
condition|)
name|q
operator|=
operator|new
name|CompletionNode
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|snd
argument_list|,
name|COMPLETIONS
argument_list|,
name|q
operator|.
name|next
operator|=
name|snd
operator|.
name|completions
argument_list|,
name|q
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|r
operator|!=
literal|null
operator|||
operator|(
name|r
operator|=
name|fst
operator|.
name|result
operator|)
operator|!=
literal|null
operator|||
operator|(
name|r
operator|=
name|snd
operator|.
name|result
operator|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|d
operator|==
literal|null
operator|||
name|d
operator|.
name|compareAndSet
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|Throwable
name|ex
decl_stmt|;
name|Object
name|t
decl_stmt|;
if|if
condition|(
name|r
operator|instanceof
name|AltResult
condition|)
block|{
name|ex
operator|=
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
expr_stmt|;
name|t
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|ex
operator|=
literal|null
expr_stmt|;
name|t
operator|=
name|r
expr_stmt|;
block|}
name|dst
operator|.
name|internalComplete
argument_list|(
name|t
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
name|fst
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
name|snd
operator|.
name|helpPostComplete
argument_list|()
expr_stmt|;
return|return
name|dst
return|;
block|}
comment|/* ------------- Control and status methods -------------- */
comment|/**      * If not already completed, completes this CompletableFuture with      * a {@link CancellationException}. Dependent CompletableFutures      * that have not already completed will also complete      * exceptionally, with a {@link CompletionException} caused by      * this {@code CancellationException}.      *      * @param mayInterruptIfRunning this value has no effect in this      * implementation because interrupts are not used to control      * processing.      *      * @return {@code true} if this task is now cancelled      */
DECL|method|cancel
specifier|public
name|boolean
name|cancel
parameter_list|(
name|boolean
name|mayInterruptIfRunning
parameter_list|)
block|{
name|boolean
name|cancelled
init|=
operator|(
name|result
operator|==
literal|null
operator|)
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|RESULT
argument_list|,
literal|null
argument_list|,
operator|new
name|AltResult
argument_list|(
operator|new
name|CancellationException
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
return|return
name|cancelled
operator|||
name|isCancelled
argument_list|()
return|;
block|}
comment|/**      * Returns {@code true} if this CompletableFuture was cancelled      * before it completed normally.      *      * @return {@code true} if this CompletableFuture was cancelled      * before it completed normally      */
DECL|method|isCancelled
specifier|public
name|boolean
name|isCancelled
parameter_list|()
block|{
name|Object
name|r
decl_stmt|;
return|return
operator|(
operator|(
name|r
operator|=
name|result
operator|)
operator|instanceof
name|AltResult
operator|)
operator|&&
operator|(
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|instanceof
name|CancellationException
operator|)
return|;
block|}
comment|/**      * Forcibly sets or resets the value subsequently returned by      * method {@link #get()} and related methods, whether or not      * already completed. This method is designed for use only in      * error recovery actions, and even in such situations may result      * in ongoing dependent completions using established versus      * overwritten outcomes.      *      * @param value the completion value      */
DECL|method|obtrudeValue
specifier|public
name|void
name|obtrudeValue
parameter_list|(
name|T
name|value
parameter_list|)
block|{
name|result
operator|=
operator|(
name|value
operator|==
literal|null
operator|)
condition|?
name|NIL
else|:
name|value
expr_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
block|}
comment|/**      * Forcibly causes subsequent invocations of method {@link #get()}      * and related methods to throw the given exception, whether or      * not already completed. This method is designed for use only in      * recovery actions, and even in such situations may result in      * ongoing dependent completions using established versus      * overwritten outcomes.      *      * @param ex the exception      */
DECL|method|obtrudeException
specifier|public
name|void
name|obtrudeException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|result
operator|=
operator|new
name|AltResult
argument_list|(
name|ex
argument_list|)
expr_stmt|;
name|postComplete
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns the estimated number of CompletableFutures whose      * completions are awaiting completion of this CompletableFuture.      * This method is designed for use in monitoring system state, not      * for synchronization control.      *      * @return the number of dependent CompletableFutures      */
DECL|method|getNumberOfDependents
specifier|public
name|int
name|getNumberOfDependents
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|CompletionNode
name|p
init|=
name|completions
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
comment|/**      * Returns a string identifying this CompletableFuture, as well as      * its completion state.  The state, in brackets, contains the      * String {@code "Completed Normally"} or the String {@code      * "Completed Exceptionally"}, or the String {@code "Not      * completed"} followed by the number of CompletableFutures      * dependent upon its completion, if any.      *      * @return a string identifying this CompletableFuture, as well as its state      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Object
name|r
init|=
name|result
decl_stmt|;
name|int
name|count
decl_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
operator|(
operator|(
operator|(
name|count
operator|=
name|getNumberOfDependents
argument_list|()
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"[Not completed]"
else|:
literal|"[Not completed, "
operator|+
name|count
operator|+
literal|" dependents]"
operator|)
else|:
operator|(
operator|(
operator|(
name|r
operator|instanceof
name|AltResult
operator|)
operator|&&
operator|(
operator|(
name|AltResult
operator|)
name|r
operator|)
operator|.
name|ex
operator|!=
literal|null
operator|)
condition|?
literal|"[Completed exceptionally]"
else|:
literal|"[Completed normally]"
operator|)
operator|)
return|;
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|RESULT
specifier|private
specifier|static
specifier|final
name|long
name|RESULT
decl_stmt|;
DECL|field|WAITERS
specifier|private
specifier|static
specifier|final
name|long
name|WAITERS
decl_stmt|;
DECL|field|COMPLETIONS
specifier|private
specifier|static
specifier|final
name|long
name|COMPLETIONS
decl_stmt|;
static|static
block|{
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|CompletableFuture
operator|.
name|class
decl_stmt|;
name|RESULT
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"result"
argument_list|)
argument_list|)
expr_stmt|;
name|WAITERS
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"waiters"
argument_list|)
argument_list|)
expr_stmt|;
name|COMPLETIONS
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"completions"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

