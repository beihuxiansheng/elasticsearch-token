begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_import
import|import
name|jsr166e
operator|.
name|ForkJoinPool
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|ObjectStreamField
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|ParameterizedType
import|;
end_import

begin_import
import|import
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Type
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReentrantLock
import|;
end_import

begin_comment
comment|/**  * A hash table supporting full concurrency of retrievals and  * high expected concurrency for updates. This class obeys the  * same functional specification as {@link java.util.Hashtable}, and  * includes versions of methods corresponding to each method of  * {@code Hashtable}. However, even though all operations are  * thread-safe, retrieval operations do<em>not</em> entail locking,  * and there is<em>not</em> any support for locking the entire table  * in a way that prevents all access.  This class is fully  * interoperable with {@code Hashtable} in programs that rely on its  * thread safety but not on its synchronization details.  *  *<p>Retrieval operations (including {@code get}) generally do not  * block, so may overlap with update operations (including {@code put}  * and {@code remove}). Retrievals reflect the results of the most  * recently<em>completed</em> update operations holding upon their  * onset. (More formally, an update operation for a given key bears a  *<em>happens-before</em> relation with any (non-null) retrieval for  * that key reporting the updated value.)  For aggregate operations  * such as {@code putAll} and {@code clear}, concurrent retrievals may  * reflect insertion or removal of only some entries.  Similarly,  * Iterators and Enumerations return elements reflecting the state of  * the hash table at some point at or since the creation of the  * iterator/enumeration.  They do<em>not</em> throw {@link  * ConcurrentModificationException}.  However, iterators are designed  * to be used by only one thread at a time.  Bear in mind that the  * results of aggregate status methods including {@code size}, {@code  * isEmpty}, and {@code containsValue} are typically useful only when  * a map is not undergoing concurrent updates in other threads.  * Otherwise the results of these methods reflect transient states  * that may be adequate for monitoring or estimation purposes, but not  * for program control.  *  *<p>The table is dynamically expanded when there are too many  * collisions (i.e., keys that have distinct hash codes but fall into  * the same slot modulo the table size), with the expected average  * effect of maintaining roughly two bins per mapping (corresponding  * to a 0.75 load factor threshold for resizing). There may be much  * variance around this average as mappings are added and removed, but  * overall, this maintains a commonly accepted time/space tradeoff for  * hash tables.  However, resizing this or any other kind of hash  * table may be a relatively slow operation. When possible, it is a  * good idea to provide a size estimate as an optional {@code  * initialCapacity} constructor argument. An additional optional  * {@code loadFactor} constructor argument provides a further means of  * customizing initial table capacity by specifying the table density  * to be used in calculating the amount of space to allocate for the  * given number of elements.  Also, for compatibility with previous  * versions of this class, constructors may optionally specify an  * expected {@code concurrencyLevel} as an additional hint for  * internal sizing.  Note that using many keys with exactly the same  * {@code hashCode()} is a sure way to slow down performance of any  * hash table. To ameliorate impact, when keys are {@link Comparable},  * this class may use comparison order among keys to help break ties.  *  *<p>A {@link Set} projection of a ConcurrentHashMapV8 may be created  * (using {@link #newKeySet()} or {@link #newKeySet(int)}), or viewed  * (using {@link #keySet(Object)} when only keys are of interest, and the  * mapped values are (perhaps transiently) not used or all take the  * same mapping value.  *  *<p>This class and its views and iterators implement all of the  *<em>optional</em> methods of the {@link Map} and {@link Iterator}  * interfaces.  *  *<p>Like {@link Hashtable} but unlike {@link HashMap}, this class  * does<em>not</em> allow {@code null} to be used as a key or value.  *  *<p>ConcurrentHashMapV8s support a set of sequential and parallel bulk  * operations that are designed  * to be safely, and often sensibly, applied even with maps that are  * being concurrently updated by other threads; for example, when  * computing a snapshot summary of the values in a shared registry.  * There are three kinds of operation, each with four forms, accepting  * functions with Keys, Values, Entries, and (Key, Value) arguments  * and/or return values. Because the elements of a ConcurrentHashMapV8  * are not ordered in any particular way, and may be processed in  * different orders in different parallel executions, the correctness  * of supplied functions should not depend on any ordering, or on any  * other objects or values that may transiently change while  * computation is in progress; and except for forEach actions, should  * ideally be side-effect-free. Bulk operations on {@link java.util.Map.Entry}  * objects do not support method {@code setValue}.  *  *<ul>  *<li> forEach: Perform a given action on each element.  * A variant form applies a given transformation on each element  * before performing the action.</li>  *  *<li> search: Return the first available non-null result of  * applying a given function on each element; skipping further  * search when a result is found.</li>  *  *<li> reduce: Accumulate each element.  The supplied reduction  * function cannot rely on ordering (more formally, it should be  * both associative and commutative).  There are five variants:  *  *<ul>  *  *<li> Plain reductions. (There is not a form of this method for  * (key, value) function arguments since there is no corresponding  * return type.)</li>  *  *<li> Mapped reductions that accumulate the results of a given  * function applied to each element.</li>  *  *<li> Reductions to scalar doubles, longs, and ints, using a  * given basis value.</li>  *  *</ul>  *</li>  *</ul>  *  *<p>These bulk operations accept a {@code parallelismThreshold}  * argument. Methods proceed sequentially if the current map size is  * estimated to be less than the given threshold. Using a value of  * {@code Long.MAX_VALUE} suppresses all parallelism.  Using a value  * of {@code 1} results in maximal parallelism by partitioning into  * enough subtasks to fully utilize the {@link  * ForkJoinPool#commonPool()} that is used for all parallel  * computations. Normally, you would initially choose one of these  * extreme values, and then measure performance of using in-between  * values that trade off overhead versus throughput.  *  *<p>The concurrency properties of bulk operations follow  * from those of ConcurrentHashMapV8: Any non-null result returned  * from {@code get(key)} and related access methods bears a  * happens-before relation with the associated insertion or  * update.  The result of any bulk operation reflects the  * composition of these per-element relations (but is not  * necessarily atomic with respect to the map as a whole unless it  * is somehow known to be quiescent).  Conversely, because keys  * and values in the map are never null, null serves as a reliable  * atomic indicator of the current lack of any result.  To  * maintain this property, null serves as an implicit basis for  * all non-scalar reduction operations. For the double, long, and  * int versions, the basis should be one that, when combined with  * any other value, returns that other value (more formally, it  * should be the identity element for the reduction). Most common  * reductions have these properties; for example, computing a sum  * with basis 0 or a minimum with basis MAX_VALUE.  *  *<p>Search and transformation functions provided as arguments  * should similarly return null to indicate the lack of any result  * (in which case it is not used). In the case of mapped  * reductions, this also enables transformations to serve as  * filters, returning null (or, in the case of primitive  * specializations, the identity basis) if the element should not  * be combined. You can create compound transformations and  * filterings by composing them yourself under this "null means  * there is nothing there now" rule before using them in search or  * reduce operations.  *  *<p>Methods accepting and/or returning Entry arguments maintain  * key-value associations. They may be useful for example when  * finding the key for the greatest value. Note that "plain" Entry  * arguments can be supplied using {@code new  * AbstractMap.SimpleEntry(k,v)}.  *  *<p>Bulk operations may complete abruptly, throwing an  * exception encountered in the application of a supplied  * function. Bear in mind when handling such exceptions that other  * concurrently executing functions could also have thrown  * exceptions, or would have done so if the first exception had  * not occurred.  *  *<p>Speedups for parallel compared to sequential forms are common  * but not guaranteed.  Parallel operations involving brief functions  * on small maps may execute more slowly than sequential forms if the  * underlying work to parallelize the computation is more expensive  * than the computation itself.  Similarly, parallelization may not  * lead to much actual parallelism if all processors are busy  * performing unrelated tasks.  *  *<p>All arguments to all task methods must be non-null.  *  *<p><em>jsr166e note: During transition, this class  * uses nested functional interfaces with different names but the  * same forms as those expected for JDK8.</em>  *  *<p>This class is a member of the  *<a href="{@docRoot}/../technotes/guides/collections/index.html">  * Java Collections Framework</a>.  *  * @since 1.5  * @author Doug Lea  * @param<K> the type of keys maintained by this map  * @param<V> the type of mapped values  */
end_comment

begin_class
DECL|class|ConcurrentHashMapV8
specifier|public
class|class
name|ConcurrentHashMapV8
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|AbstractMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7249069246763182397L
decl_stmt|;
comment|/**      * An object for traversing and partitioning elements of a source.      * This interface provides a subset of the functionality of JDK8      * java.util.Spliterator.      */
DECL|interface|ConcurrentHashMapSpliterator
specifier|public
specifier|static
interface|interface
name|ConcurrentHashMapSpliterator
parameter_list|<
name|T
parameter_list|>
block|{
comment|/**          * If possible, returns a new spliterator covering          * approximately one half of the elements, which will not be          * covered by this spliterator. Returns null if cannot be          * split.          */
DECL|method|trySplit
name|ConcurrentHashMapSpliterator
argument_list|<
name|T
argument_list|>
name|trySplit
parameter_list|()
function_decl|;
comment|/**          * Returns an estimate of the number of elements covered by          * this Spliterator.          */
DECL|method|estimateSize
name|long
name|estimateSize
parameter_list|()
function_decl|;
comment|/** Applies the action to each untraversed element */
DECL|method|forEachRemaining
name|void
name|forEachRemaining
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|action
parameter_list|)
function_decl|;
comment|/** If an element remains, applies the action and returns true. */
DECL|method|tryAdvance
name|boolean
name|tryAdvance
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|T
argument_list|>
name|action
parameter_list|)
function_decl|;
block|}
comment|// Sams
comment|/** Interface describing a void action of one argument */
DECL|interface|Action
DECL|method|apply
specifier|public
interface|interface
name|Action
parameter_list|<
name|A
parameter_list|>
block|{
name|void
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a void action of two arguments */
DECL|interface|BiAction
DECL|method|apply
specifier|public
interface|interface
name|BiAction
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|void
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of one argument */
DECL|interface|Fun
DECL|method|apply
specifier|public
interface|interface
name|Fun
parameter_list|<
name|A
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of two arguments */
DECL|interface|BiFun
DECL|method|apply
specifier|public
interface|interface
name|BiFun
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping its argument to a double */
DECL|interface|ObjectToDouble
DECL|method|apply
specifier|public
interface|interface
name|ObjectToDouble
parameter_list|<
name|A
parameter_list|>
block|{
name|double
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping its argument to a long */
DECL|interface|ObjectToLong
DECL|method|apply
specifier|public
interface|interface
name|ObjectToLong
parameter_list|<
name|A
parameter_list|>
block|{
name|long
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping its argument to an int */
DECL|interface|ObjectToInt
DECL|method|apply
specifier|public
interface|interface
name|ObjectToInt
parameter_list|<
name|A
parameter_list|>
block|{
name|int
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two arguments to a double */
DECL|interface|ObjectByObjectToDouble
DECL|method|apply
specifier|public
interface|interface
name|ObjectByObjectToDouble
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|double
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two arguments to a long */
DECL|interface|ObjectByObjectToLong
DECL|method|apply
specifier|public
interface|interface
name|ObjectByObjectToLong
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|long
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two arguments to an int */
DECL|interface|ObjectByObjectToInt
DECL|method|apply
specifier|public
interface|interface
name|ObjectByObjectToInt
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|int
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two doubles to a double */
DECL|interface|DoubleByDoubleToDouble
DECL|method|apply
specifier|public
interface|interface
name|DoubleByDoubleToDouble
block|{
name|double
name|apply
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two longs to a long */
DECL|interface|LongByLongToLong
DECL|method|apply
specifier|public
interface|interface
name|LongByLongToLong
block|{
name|long
name|apply
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two ints to an int */
DECL|interface|IntByIntToInt
DECL|method|apply
specifier|public
interface|interface
name|IntByIntToInt
block|{
name|int
name|apply
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
block|}
comment|/*      * Overview:      *      * The primary design goal of this hash table is to maintain      * concurrent readability (typically method get(), but also      * iterators and related methods) while minimizing update      * contention. Secondary goals are to keep space consumption about      * the same or better than java.util.HashMap, and to support high      * initial insertion rates on an empty table by many threads.      *      * This map usually acts as a binned (bucketed) hash table.  Each      * key-value mapping is held in a Node.  Most nodes are instances      * of the basic Node class with hash, key, value, and next      * fields. However, various subclasses exist: TreeNodes are      * arranged in balanced trees, not lists.  TreeBins hold the roots      * of sets of TreeNodes. ForwardingNodes are placed at the heads      * of bins during resizing. ReservationNodes are used as      * placeholders while establishing values in computeIfAbsent and      * related methods.  The types TreeBin, ForwardingNode, and      * ReservationNode do not hold normal user keys, values, or      * hashes, and are readily distinguishable during search etc      * because they have negative hash fields and null key and value      * fields. (These special nodes are either uncommon or transient,      * so the impact of carrying around some unused fields is      * insignificant.)      *      * The table is lazily initialized to a power-of-two size upon the      * first insertion.  Each bin in the table normally contains a      * list of Nodes (most often, the list has only zero or one Node).      * Table accesses require volatile/atomic reads, writes, and      * CASes.  Because there is no other way to arrange this without      * adding further indirections, we use intrinsics      * (sun.misc.Unsafe) operations.      *      * We use the top (sign) bit of Node hash fields for control      * purposes -- it is available anyway because of addressing      * constraints.  Nodes with negative hash fields are specially      * handled or ignored in map methods.      *      * Insertion (via put or its variants) of the first node in an      * empty bin is performed by just CASing it to the bin.  This is      * by far the most common case for put operations under most      * key/hash distributions.  Other update operations (insert,      * delete, and replace) require locks.  We do not want to waste      * the space required to associate a distinct lock object with      * each bin, so instead use the first node of a bin list itself as      * a lock. Locking support for these locks relies on builtin      * "synchronized" monitors.      *      * Using the first node of a list as a lock does not by itself      * suffice though: When a node is locked, any update must first      * validate that it is still the first node after locking it, and      * retry if not. Because new nodes are always appended to lists,      * once a node is first in a bin, it remains first until deleted      * or the bin becomes invalidated (upon resizing).      *      * The main disadvantage of per-bin locks is that other update      * operations on other nodes in a bin list protected by the same      * lock can stall, for example when user equals() or mapping      * functions take a long time.  However, statistically, under      * random hash codes, this is not a common problem.  Ideally, the      * frequency of nodes in bins follows a Poisson distribution      * (http://en.wikipedia.org/wiki/Poisson_distribution) with a      * parameter of about 0.5 on average, given the resizing threshold      * of 0.75, although with a large variance because of resizing      * granularity. Ignoring variance, the expected occurrences of      * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The      * first values are:      *      * 0:    0.60653066      * 1:    0.30326533      * 2:    0.07581633      * 3:    0.01263606      * 4:    0.00157952      * 5:    0.00015795      * 6:    0.00001316      * 7:    0.00000094      * 8:    0.00000006      * more: less than 1 in ten million      *      * Lock contention probability for two threads accessing distinct      * elements is roughly 1 / (8 * #elements) under random hashes.      *      * Actual hash code distributions encountered in practice      * sometimes deviate significantly from uniform randomness.  This      * includes the case when N> (1<<30), so some keys MUST collide.      * Similarly for dumb or hostile usages in which multiple keys are      * designed to have identical hash codes or ones that differs only      * in masked-out high bits. So we use a secondary strategy that      * applies when the number of nodes in a bin exceeds a      * threshold. These TreeBins use a balanced tree to hold nodes (a      * specialized form of red-black trees), bounding search time to      * O(log N).  Each search step in a TreeBin is at least twice as      * slow as in a regular list, but given that N cannot exceed      * (1<<64) (before running out of addresses) this bounds search      * steps, lock hold times, etc, to reasonable constants (roughly      * 100 nodes inspected per operation worst case) so long as keys      * are Comparable (which is very common -- String, Long, etc).      * TreeBin nodes (TreeNodes) also maintain the same "next"      * traversal pointers as regular nodes, so can be traversed in      * iterators in the same way.      *      * The table is resized when occupancy exceeds a percentage      * threshold (nominally, 0.75, but see below).  Any thread      * noticing an overfull bin may assist in resizing after the      * initiating thread allocates and sets up the replacement array.      * However, rather than stalling, these other threads may proceed      * with insertions etc.  The use of TreeBins shields us from the      * worst case effects of overfilling while resizes are in      * progress.  Resizing proceeds by transferring bins, one by one,      * from the table to the next table. However, threads claim small      * blocks of indices to transfer (via field transferIndex) before      * doing so, reducing contention.  A generation stamp in field      * sizeCtl ensures that resizings do not overlap. Because we are      * using power-of-two expansion, the elements from each bin must      * either stay at same index, or move with a power of two      * offset. We eliminate unnecessary node creation by catching      * cases where old nodes can be reused because their next fields      * won't change.  On average, only about one-sixth of them need      * cloning when a table doubles. The nodes they replace will be      * garbage collectable as soon as they are no longer referenced by      * any reader thread that may be in the midst of concurrently      * traversing table.  Upon transfer, the old table bin contains      * only a special forwarding node (with hash field "MOVED") that      * contains the next table as its key. On encountering a      * forwarding node, access and update operations restart, using      * the new table.      *      * Each bin transfer requires its bin lock, which can stall      * waiting for locks while resizing. However, because other      * threads can join in and help resize rather than contend for      * locks, average aggregate waits become shorter as resizing      * progresses.  The transfer operation must also ensure that all      * accessible bins in both the old and new table are usable by any      * traversal.  This is arranged in part by proceeding from the      * last bin (table.length - 1) up towards the first.  Upon seeing      * a forwarding node, traversals (see class Traverser) arrange to      * move to the new table without revisiting nodes.  To ensure that      * no intervening nodes are skipped even when moved out of order,      * a stack (see class TableStack) is created on first encounter of      * a forwarding node during a traversal, to maintain its place if      * later processing the current table. The need for these      * save/restore mechanics is relatively rare, but when one      * forwarding node is encountered, typically many more will be.      * So Traversers use a simple caching scheme to avoid creating so      * many new TableStack nodes. (Thanks to Peter Levart for      * suggesting use of a stack here.)      *      * The traversal scheme also applies to partial traversals of      * ranges of bins (via an alternate Traverser constructor)      * to support partitioned aggregate operations.  Also, read-only      * operations give up if ever forwarded to a null table, which      * provides support for shutdown-style clearing, which is also not      * currently implemented.      *      * Lazy table initialization minimizes footprint until first use,      * and also avoids resizings when the first operation is from a      * putAll, constructor with map argument, or deserialization.      * These cases attempt to override the initial capacity settings,      * but harmlessly fail to take effect in cases of races.      *      * The element count is maintained using a specialization of      * LongAdder. We need to incorporate a specialization rather than      * just use a LongAdder in order to access implicit      * contention-sensing that leads to creation of multiple      * CounterCells.  The counter mechanics avoid contention on      * updates but can encounter cache thrashing if read too      * frequently during concurrent access. To avoid reading so often,      * resizing under contention is attempted only upon adding to a      * bin already holding two or more nodes. Under uniform hash      * distributions, the probability of this occurring at threshold      * is around 13%, meaning that only about 1 in 8 puts check      * threshold (and after resizing, many fewer do so).      *      * TreeBins use a special form of comparison for search and      * related operations (which is the main reason we cannot use      * existing collections such as TreeMaps). TreeBins contain      * Comparable elements, but may contain others, as well as      * elements that are Comparable but not necessarily Comparable for      * the same T, so we cannot invoke compareTo among them. To handle      * this, the tree is ordered primarily by hash value, then by      * Comparable.compareTo order if applicable.  On lookup at a node,      * if elements are not comparable or compare as 0 then both left      * and right children may need to be searched in the case of tied      * hash values. (This corresponds to the full list search that      * would be necessary if all elements were non-Comparable and had      * tied hashes.) On insertion, to keep a total ordering (or as      * close as is required here) across rebalancings, we compare      * classes and identityHashCodes as tie-breakers. The red-black      * balancing code is updated from pre-jdk-collections      * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)      * based in turn on Cormen, Leiserson, and Rivest "Introduction to      * Algorithms" (CLR).      *      * TreeBins also require an additional locking mechanism.  While      * list traversal is always possible by readers even during      * updates, tree traversal is not, mainly because of tree-rotations      * that may change the root node and/or its linkages.  TreeBins      * include a simple read-write lock mechanism parasitic on the      * main bin-synchronization strategy: Structural adjustments      * associated with an insertion or removal are already bin-locked      * (and so cannot conflict with other writers) but must wait for      * ongoing readers to finish. Since there can be only one such      * waiter, we use a simple scheme using a single "waiter" field to      * block writers.  However, readers need never block.  If the root      * lock is held, they proceed along the slow traversal path (via      * next-pointers) until the lock becomes available or the list is      * exhausted, whichever comes first. These cases are not fast, but      * maximize aggregate expected throughput.      *      * Maintaining API and serialization compatibility with previous      * versions of this class introduces several oddities. Mainly: We      * leave untouched but unused constructor arguments refering to      * concurrencyLevel. We accept a loadFactor constructor argument,      * but apply it only to initial table capacity (which is the only      * time that we can guarantee to honor it.) We also declare an      * unused "Segment" class that is instantiated in minimal form      * only when serializing.      *      * Also, solely for compatibility with previous versions of this      * class, it extends AbstractMap, even though all of its methods      * are overridden, so it is just useless baggage.      *      * This file is organized to make things a little easier to follow      * while reading than they might otherwise: First the main static      * declarations and utilities, then fields, then main public      * methods (with a few factorings of multiple public methods into      * internal ones), then sizing methods, trees, traversers, and      * bulk operations.      */
comment|/* ---------------- Constants -------------- */
comment|/**      * The largest possible table capacity.  This value must be      * exactly 1<<30 to stay within Java array allocation and indexing      * bounds for power of two table sizes, and is further required      * because the top two bits of 32bit hash fields are used for      * control purposes.      */
DECL|field|MAXIMUM_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/**      * The default initial table capacity.  Must be a power of 2      * (i.e., at least 1) and at most MAXIMUM_CAPACITY.      */
DECL|field|DEFAULT_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CAPACITY
init|=
literal|16
decl_stmt|;
comment|/**      * The largest possible (non-power of two) array size.      * Needed by toArray and related methods.      */
DECL|field|MAX_ARRAY_SIZE
specifier|static
specifier|final
name|int
name|MAX_ARRAY_SIZE
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|8
decl_stmt|;
comment|/**      * The default concurrency level for this table. Unused but      * defined for compatibility with previous versions of this class.      */
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
comment|/**      * The load factor for this table. Overrides of this value in      * constructors affect only the initial table capacity.  The      * actual floating point value isn't normally used -- it is      * simpler to use expressions such as {@code n - (n>>> 2)} for      * the associated resizing threshold.      */
DECL|field|LOAD_FACTOR
specifier|private
specifier|static
specifier|final
name|float
name|LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
comment|/**      * The bin count threshold for using a tree rather than list for a      * bin.  Bins are converted to trees when adding an element to a      * bin with at least this many nodes. The value must be greater      * than 2, and should be at least 8 to mesh with assumptions in      * tree removal about conversion back to plain bins upon      * shrinkage.      */
DECL|field|TREEIFY_THRESHOLD
specifier|static
specifier|final
name|int
name|TREEIFY_THRESHOLD
init|=
literal|8
decl_stmt|;
comment|/**      * The bin count threshold for untreeifying a (split) bin during a      * resize operation. Should be less than TREEIFY_THRESHOLD, and at      * most 6 to mesh with shrinkage detection under removal.      */
DECL|field|UNTREEIFY_THRESHOLD
specifier|static
specifier|final
name|int
name|UNTREEIFY_THRESHOLD
init|=
literal|6
decl_stmt|;
comment|/**      * The smallest table capacity for which bins may be treeified.      * (Otherwise the table is resized if too many nodes in a bin.)      * The value should be at least 4 * TREEIFY_THRESHOLD to avoid      * conflicts between resizing and treeification thresholds.      */
DECL|field|MIN_TREEIFY_CAPACITY
specifier|static
specifier|final
name|int
name|MIN_TREEIFY_CAPACITY
init|=
literal|64
decl_stmt|;
comment|/**      * Minimum number of rebinnings per transfer step. Ranges are      * subdivided to allow multiple resizer threads.  This value      * serves as a lower bound to avoid resizers encountering      * excessive memory contention.  The value should be at least      * DEFAULT_CAPACITY.      */
DECL|field|MIN_TRANSFER_STRIDE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_TRANSFER_STRIDE
init|=
literal|16
decl_stmt|;
comment|/**      * The number of bits used for generation stamp in sizeCtl.      * Must be at least 6 for 32bit arrays.      */
DECL|field|RESIZE_STAMP_BITS
specifier|private
specifier|static
name|int
name|RESIZE_STAMP_BITS
init|=
literal|16
decl_stmt|;
comment|/**      * The maximum number of threads that can help resize.      * Must fit in 32 - RESIZE_STAMP_BITS bits.      */
DECL|field|MAX_RESIZERS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_RESIZERS
init|=
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|RESIZE_STAMP_BITS
operator|)
operator|)
operator|-
literal|1
decl_stmt|;
comment|/**      * The bit shift for recording size stamp in sizeCtl.      */
DECL|field|RESIZE_STAMP_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|RESIZE_STAMP_SHIFT
init|=
literal|32
operator|-
name|RESIZE_STAMP_BITS
decl_stmt|;
comment|/*      * Encodings for Node hash fields. See above for explanation.      */
DECL|field|MOVED
specifier|static
specifier|final
name|int
name|MOVED
init|=
operator|-
literal|1
decl_stmt|;
comment|// hash for forwarding nodes
DECL|field|TREEBIN
specifier|static
specifier|final
name|int
name|TREEBIN
init|=
operator|-
literal|2
decl_stmt|;
comment|// hash for roots of trees
DECL|field|RESERVED
specifier|static
specifier|final
name|int
name|RESERVED
init|=
operator|-
literal|3
decl_stmt|;
comment|// hash for transient reservations
DECL|field|HASH_BITS
specifier|static
specifier|final
name|int
name|HASH_BITS
init|=
literal|0x7fffffff
decl_stmt|;
comment|// usable bits of normal node hash
comment|/** Number of CPUS, to place bounds on some sizings */
DECL|field|NCPU
specifier|static
specifier|final
name|int
name|NCPU
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
decl_stmt|;
comment|/** For serialization compatibility. */
DECL|field|serialPersistentFields
specifier|private
specifier|static
specifier|final
name|ObjectStreamField
index|[]
name|serialPersistentFields
init|=
block|{
operator|new
name|ObjectStreamField
argument_list|(
literal|"segments"
argument_list|,
name|Segment
index|[]
operator|.
expr|class
argument_list|)
block|,
operator|new
name|ObjectStreamField
argument_list|(
literal|"segmentMask"
argument_list|,
name|Integer
operator|.
name|TYPE
argument_list|)
block|,
operator|new
name|ObjectStreamField
argument_list|(
literal|"segmentShift"
argument_list|,
name|Integer
operator|.
name|TYPE
argument_list|)
block|}
decl_stmt|;
comment|/* ---------------- Nodes -------------- */
comment|/**      * Key-value entry.  This class is never exported out as a      * user-mutable Map.Entry (i.e., one supporting setValue; see      * MapEntry below), but can be used for read-only traversals used      * in bulk tasks.  Subclasses of Node with a negative hash field      * are special, and contain null keys and values (but are never      * exported).  Otherwise, keys and vals are never null.      */
DECL|class|Node
specifier|static
class|class
name|Node
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
DECL|field|val
specifier|volatile
name|V
name|val
decl_stmt|;
DECL|field|next
specifier|volatile
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|method|Node
name|Node
parameter_list|(
name|int
name|hash
parameter_list|,
name|K
name|key
parameter_list|,
name|V
name|val
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
DECL|method|getKey
specifier|public
specifier|final
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue
specifier|public
specifier|final
name|V
name|getValue
parameter_list|()
block|{
return|return
name|val
return|;
block|}
DECL|method|hashCode
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|val
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
return|return
name|key
operator|+
literal|"="
operator|+
name|val
return|;
block|}
DECL|method|setValue
specifier|public
specifier|final
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|equals
specifier|public
specifier|final
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|,
name|u
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|k
operator|==
name|key
operator|||
name|k
operator|.
name|equals
argument_list|(
name|key
argument_list|)
operator|)
operator|&&
operator|(
name|v
operator|==
operator|(
name|u
operator|=
name|val
operator|)
operator|||
name|v
operator|.
name|equals
argument_list|(
name|u
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/**          * Virtualized support for map.get(); overridden in subclasses.          */
DECL|method|find
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|this
decl_stmt|;
if|if
condition|(
name|k
operator|!=
literal|null
condition|)
block|{
do|do
block|{
name|K
name|ek
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
return|return
name|e
return|;
block|}
do|while
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
do|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/* ---------------- Static utilities -------------- */
comment|/**      * Spreads (XORs) higher bits of hash to lower and also forces top      * bit to 0. Because the table uses power-of-two masking, sets of      * hashes that vary only in bits above the current mask will      * always collide. (Among known examples are sets of Float keys      * holding consecutive whole numbers in small tables.)  So we      * apply a transform that spreads the impact of higher bits      * downward. There is a tradeoff between speed, utility, and      * quality of bit-spreading. Because many common sets of hashes      * are already reasonably distributed (so don't benefit from      * spreading), and because we use trees to handle large sets of      * collisions in bins, we just XOR some shifted bits in the      * cheapest possible way to reduce systematic lossage, as well as      * to incorporate impact of the highest bits that would otherwise      * never be used in index calculations because of table bounds.      */
DECL|method|spread
specifier|static
specifier|final
name|int
name|spread
parameter_list|(
name|int
name|h
parameter_list|)
block|{
return|return
operator|(
name|h
operator|^
operator|(
name|h
operator|>>>
literal|16
operator|)
operator|)
operator|&
name|HASH_BITS
return|;
block|}
comment|/**      * Returns a power of two table size for the given desired capacity.      * See Hackers Delight, sec 3.2      */
DECL|method|tableSizeFor
specifier|private
specifier|static
specifier|final
name|int
name|tableSizeFor
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|int
name|n
init|=
name|c
operator|-
literal|1
decl_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|1
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|2
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|4
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|8
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|16
expr_stmt|;
return|return
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
literal|1
else|:
operator|(
name|n
operator|>=
name|MAXIMUM_CAPACITY
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|n
operator|+
literal|1
return|;
block|}
comment|/**      * Returns x's Class if it is of the form "class C implements      * Comparable<C>", else null.      */
DECL|method|comparableClassFor
specifier|static
name|Class
argument_list|<
name|?
argument_list|>
name|comparableClassFor
parameter_list|(
name|Object
name|x
parameter_list|)
block|{
if|if
condition|(
name|x
operator|instanceof
name|Comparable
condition|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
name|Type
index|[]
name|ts
decl_stmt|,
name|as
decl_stmt|;
name|Type
name|t
decl_stmt|;
name|ParameterizedType
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|x
operator|.
name|getClass
argument_list|()
operator|)
operator|==
name|String
operator|.
name|class
condition|)
comment|// bypass checks
return|return
name|c
return|;
if|if
condition|(
operator|(
name|ts
operator|=
name|c
operator|.
name|getGenericInterfaces
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ts
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|t
operator|=
name|ts
index|[
name|i
index|]
operator|)
operator|instanceof
name|ParameterizedType
operator|)
operator|&&
operator|(
operator|(
name|p
operator|=
operator|(
name|ParameterizedType
operator|)
name|t
operator|)
operator|.
name|getRawType
argument_list|()
operator|==
name|Comparable
operator|.
name|class
operator|)
operator|&&
operator|(
name|as
operator|=
name|p
operator|.
name|getActualTypeArguments
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|as
operator|.
name|length
operator|==
literal|1
operator|&&
name|as
index|[
literal|0
index|]
operator|==
name|c
condition|)
comment|// type arg is c
return|return
name|c
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns k.compareTo(x) if x matches kc (k's screened comparable      * class), else 0.      */
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"rawtypes"
block|,
literal|"unchecked"
block|}
argument_list|)
comment|// for cast to Comparable
DECL|method|compareComparables
specifier|static
name|int
name|compareComparables
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|kc
parameter_list|,
name|Object
name|k
parameter_list|,
name|Object
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|==
literal|null
operator|||
name|x
operator|.
name|getClass
argument_list|()
operator|!=
name|kc
condition|?
literal|0
else|:
operator|(
operator|(
name|Comparable
operator|)
name|k
operator|)
operator|.
name|compareTo
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
comment|/* ---------------- Table element access -------------- */
comment|/*      * Volatile access methods are used for table elements as well as      * elements of in-progress next table while resizing.  All uses of      * the tab arguments must be null checked by callers.  All callers      * also paranoically precheck that tab's length is not zero (or an      * equivalent check), thus ensuring that any index argument taking      * the form of a hash value anded with (length - 1) is a valid      * index.  Note that, to be correct wrt arbitrary concurrency      * errors by users, these checks must operate on local variables,      * which accounts for some odd-looking inline assignments below.      * Note that calls to setTabAt always occur within locked regions,      * and so in principle require only release ordering, not      * full volatile semantics, but are currently coded as volatile      * writes to be conservative.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|tabAt
specifier|static
specifier|final
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tabAt
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|)
return|;
block|}
DECL|method|casTabAt
specifier|static
specifier|final
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|casTabAt
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|c
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
parameter_list|)
block|{
return|return
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|c
argument_list|,
name|v
argument_list|)
return|;
block|}
DECL|method|setTabAt
specifier|static
specifier|final
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|void
name|setTabAt
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|v
parameter_list|)
block|{
name|U
operator|.
name|putObjectVolatile
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* ---------------- Fields -------------- */
comment|/**      * The array of bins. Lazily initialized upon first insertion.      * Size is always a power of two. Accessed directly by iterators.      */
DECL|field|table
specifier|transient
specifier|volatile
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|table
decl_stmt|;
comment|/**      * The next table to use; non-null only while resizing.      */
DECL|field|nextTable
specifier|private
specifier|transient
specifier|volatile
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nextTable
decl_stmt|;
comment|/**      * Base counter value, used mainly when there is no contention,      * but also as a fallback during table initialization      * races. Updated via CAS.      */
DECL|field|baseCount
specifier|private
specifier|transient
specifier|volatile
name|long
name|baseCount
decl_stmt|;
comment|/**      * Table initialization and resizing control.  When negative, the      * table is being initialized or resized: -1 for initialization,      * else -(1 + the number of active resizing threads).  Otherwise,      * when table is null, holds the initial table size to use upon      * creation, or 0 for default. After initialization, holds the      * next element count value upon which to resize the table.      */
DECL|field|sizeCtl
specifier|private
specifier|transient
specifier|volatile
name|int
name|sizeCtl
decl_stmt|;
comment|/**      * The next table index (plus one) to split while resizing.      */
DECL|field|transferIndex
specifier|private
specifier|transient
specifier|volatile
name|int
name|transferIndex
decl_stmt|;
comment|/**      * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.      */
DECL|field|cellsBusy
specifier|private
specifier|transient
specifier|volatile
name|int
name|cellsBusy
decl_stmt|;
comment|/**      * Table of counter cells. When non-null, size is a power of 2.      */
DECL|field|counterCells
specifier|private
specifier|transient
specifier|volatile
name|CounterCell
index|[]
name|counterCells
decl_stmt|;
comment|// views
DECL|field|keySet
specifier|private
specifier|transient
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keySet
decl_stmt|;
DECL|field|values
specifier|private
specifier|transient
name|ValuesView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|values
decl_stmt|;
DECL|field|entrySet
specifier|private
specifier|transient
name|EntrySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entrySet
decl_stmt|;
comment|/* ---------------- Public operations -------------- */
comment|/**      * Creates a new, empty map with the default initial table size (16).      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|()
block|{     }
comment|/**      * Creates a new, empty map with an initial table size      * accommodating the specified number of elements without the need      * to dynamically resize.      *      * @param initialCapacity The implementation performs internal      * sizing to accommodate this many elements.      * @throws IllegalArgumentException if the initial capacity of      * elements is negative      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
if|if
condition|(
name|initialCapacity
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|int
name|cap
init|=
operator|(
operator|(
name|initialCapacity
operator|>=
operator|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
operator|)
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
name|initialCapacity
operator|+
operator|(
name|initialCapacity
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
operator|)
decl_stmt|;
name|this
operator|.
name|sizeCtl
operator|=
name|cap
expr_stmt|;
block|}
comment|/**      * Creates a new map with the same mappings as the given map.      *      * @param m the map      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|this
operator|.
name|sizeCtl
operator|=
name|DEFAULT_CAPACITY
expr_stmt|;
name|putAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with an initial table size based on      * the given number of elements ({@code initialCapacity}) and      * initial table density ({@code loadFactor}).      *      * @param initialCapacity the initial capacity. The implementation      * performs internal sizing to accommodate this many elements,      * given the specified load factor.      * @param loadFactor the load factor (table density) for      * establishing the initial table size      * @throws IllegalArgumentException if the initial capacity of      * elements is negative or the load factor is nonpositive      *      * @since 1.6      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|loadFactor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with an initial table size based on      * the given number of elements ({@code initialCapacity}), table      * density ({@code loadFactor}), and number of concurrently      * updating threads ({@code concurrencyLevel}).      *      * @param initialCapacity the initial capacity. The implementation      * performs internal sizing to accommodate this many elements,      * given the specified load factor.      * @param loadFactor the load factor (table density) for      * establishing the initial table size      * @param concurrencyLevel the estimated number of concurrently      * updating threads. The implementation may use this value as      * a sizing hint.      * @throws IllegalArgumentException if the initial capacity is      * negative or the load factor or concurrencyLevel are      * nonpositive      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|loadFactor
operator|>
literal|0.0f
operator|)
operator|||
name|initialCapacity
operator|<
literal|0
operator|||
name|concurrencyLevel
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
if|if
condition|(
name|initialCapacity
operator|<
name|concurrencyLevel
condition|)
comment|// Use at least as many bins
name|initialCapacity
operator|=
name|concurrencyLevel
expr_stmt|;
comment|// as estimated threads
name|long
name|size
init|=
call|(
name|long
call|)
argument_list|(
literal|1.0
operator|+
operator|(
name|long
operator|)
name|initialCapacity
operator|/
name|loadFactor
argument_list|)
decl_stmt|;
name|int
name|cap
init|=
operator|(
name|size
operator|>=
operator|(
name|long
operator|)
name|MAXIMUM_CAPACITY
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|)
decl_stmt|;
name|this
operator|.
name|sizeCtl
operator|=
name|cap
expr_stmt|;
block|}
comment|// Original (since JDK1.2) Map methods
comment|/**      * {@inheritDoc}      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
name|long
name|n
init|=
name|sumCount
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|n
operator|<
literal|0L
operator|)
condition|?
literal|0
else|:
operator|(
name|n
operator|>
operator|(
name|long
operator|)
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|?
name|Integer
operator|.
name|MAX_VALUE
else|:
operator|(
name|int
operator|)
name|n
operator|)
return|;
block|}
comment|/**      * {@inheritDoc}      */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|sumCount
argument_list|()
operator|<=
literal|0L
return|;
comment|// ignore transient negative values
block|}
comment|/**      * Returns the value to which the specified key is mapped,      * or {@code null} if this map contains no mapping for the key.      *      *<p>More formally, if this map contains a mapping from a key      * {@code k} to a value {@code v} such that {@code key.equals(k)},      * then this method returns {@code v}; otherwise it returns      * {@code null}.  (There can be at most one such mapping.)      *      * @throws NullPointerException if the specified key is null      */
DECL|method|get
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|,
name|p
decl_stmt|;
name|int
name|n
decl_stmt|,
name|eh
decl_stmt|;
name|K
name|ek
decl_stmt|;
name|int
name|h
init|=
name|spread
argument_list|(
name|key
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|>
literal|0
operator|&&
operator|(
name|e
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|eh
operator|=
name|e
operator|.
name|hash
operator|)
operator|==
name|h
condition|)
block|{
if|if
condition|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
return|return
name|e
operator|.
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|eh
operator|<
literal|0
condition|)
return|return
operator|(
name|p
operator|=
name|e
operator|.
name|find
argument_list|(
name|h
argument_list|,
name|key
argument_list|)
operator|)
operator|!=
literal|null
condition|?
name|p
operator|.
name|val
else|:
literal|null
return|;
while|while
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
return|return
name|e
operator|.
name|val
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Tests if the specified object is a key in this table.      *      * @param  key possible key      * @return {@code true} if and only if the specified object      *         is a key in this table, as determined by the      *         {@code equals} method; {@code false} otherwise      * @throws NullPointerException if the specified key is null      */
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns {@code true} if this map maps one or more keys to the      * specified value. Note: This method may require a full traversal      * of the map, and is much slower than method {@code containsKey}.      *      * @param value value whose presence in this map is to be tested      * @return {@code true} if this map maps one or more keys to the      *         specified value      * @throws NullPointerException if the specified value is null      */
DECL|method|containsValue
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|p
operator|.
name|val
operator|)
operator|==
name|value
operator|||
operator|(
name|v
operator|!=
literal|null
operator|&&
name|value
operator|.
name|equals
argument_list|(
name|v
argument_list|)
operator|)
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Maps the specified key to the specified value in this table.      * Neither the key nor the value can be null.      *      *<p>The value can be retrieved by calling the {@code get} method      * with a key that is equal to the original key.      *      * @param key key with which the specified value is to be associated      * @param value value to be associated with the specified key      * @return the previous value associated with {@code key}, or      *         {@code null} if there was no mapping for {@code key}      * @throws NullPointerException if the specified key or value is null      */
DECL|method|put
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|putVal
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/** Implementation for put and putIfAbsent */
DECL|method|putVal
specifier|final
name|V
name|putVal
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|hash
init|=
name|spread
argument_list|(
name|key
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|binCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|fh
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|hash
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
break|break;
comment|// no lock when adding to empty bin
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
name|tab
operator|=
name|helpTransfer
argument_list|(
name|tab
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|V
name|oldVal
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|f
init|;
condition|;
operator|++
name|binCount
control|)
block|{
name|K
name|ek
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
block|{
name|oldVal
operator|=
name|e
operator|.
name|val
expr_stmt|;
if|if
condition|(
operator|!
name|onlyIfAbsent
condition|)
name|e
operator|.
name|val
operator|=
name|value
expr_stmt|;
break|break;
block|}
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pred
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|pred
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|instanceof
name|TreeBin
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
name|binCount
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
operator|)
operator|.
name|putTreeVal
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|oldVal
operator|=
name|p
operator|.
name|val
expr_stmt|;
if|if
condition|(
operator|!
name|onlyIfAbsent
condition|)
name|p
operator|.
name|val
operator|=
name|value
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|binCount
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|binCount
operator|>=
name|TREEIFY_THRESHOLD
condition|)
name|treeifyBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
return|return
name|oldVal
return|;
break|break;
block|}
block|}
block|}
name|addCount
argument_list|(
literal|1L
argument_list|,
name|binCount
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/**      * Copies all of the mappings from the specified map to this one.      * These mappings replace any mappings that this map had for any of the      * keys currently in the specified map.      *      * @param m mappings to be stored in this map      */
DECL|method|putAll
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|tryPresize
argument_list|(
name|m
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
name|putVal
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Removes the key (and its corresponding value) from this map.      * This method does nothing if the key is not in the map.      *      * @param  key the key that needs to be removed      * @return the previous value associated with {@code key}, or      *         {@code null} if there was no mapping for {@code key}      * @throws NullPointerException if the specified key is null      */
DECL|method|remove
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|replaceNode
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Implementation for the four public remove/replace methods:      * Replaces node value with v, conditional upon match of cv if      * non-null.  If resulting value is null, delete.      */
DECL|method|replaceNode
specifier|final
name|V
name|replaceNode
parameter_list|(
name|Object
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|Object
name|cv
parameter_list|)
block|{
name|int
name|hash
init|=
name|spread
argument_list|(
name|key
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|fh
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
operator|||
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|hash
argument_list|)
operator|)
operator|==
literal|null
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
name|tab
operator|=
name|helpTransfer
argument_list|(
name|tab
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|V
name|oldVal
init|=
literal|null
decl_stmt|;
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
control|)
block|{
name|K
name|ek
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|hash
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
block|{
name|V
name|ev
init|=
name|e
operator|.
name|val
decl_stmt|;
if|if
condition|(
name|cv
operator|==
literal|null
operator|||
name|cv
operator|==
name|ev
operator|||
operator|(
name|ev
operator|!=
literal|null
operator|&&
name|cv
operator|.
name|equals
argument_list|(
name|ev
argument_list|)
operator|)
condition|)
block|{
name|oldVal
operator|=
name|ev
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
name|e
operator|.
name|val
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|e
operator|.
name|next
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|e
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|instanceof
name|TreeBin
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
decl_stmt|,
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|t
operator|.
name|root
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|p
operator|=
name|r
operator|.
name|findTreeNode
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|V
name|pv
init|=
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
name|cv
operator|==
literal|null
operator|||
name|cv
operator|==
name|pv
operator|||
operator|(
name|pv
operator|!=
literal|null
operator|&&
name|cv
operator|.
name|equals
argument_list|(
name|pv
argument_list|)
operator|)
condition|)
block|{
name|oldVal
operator|=
name|pv
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|.
name|removeTreeNode
argument_list|(
name|p
argument_list|)
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|untreeify
argument_list|(
name|t
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|validated
condition|)
block|{
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
name|addCount
argument_list|(
operator|-
literal|1L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|oldVal
return|;
block|}
break|break;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Removes all of the mappings from this map.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|long
name|delta
init|=
literal|0L
decl_stmt|;
comment|// negative number of deletions
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
while|while
condition|(
name|tab
operator|!=
literal|null
operator|&&
name|i
operator|<
name|tab
operator|.
name|length
condition|)
block|{
name|int
name|fh
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
init|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
operator|++
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
name|tab
operator|=
name|helpTransfer
argument_list|(
name|tab
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|// restart
block|}
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
operator|(
name|fh
operator|>=
literal|0
condition|?
name|f
else|:
operator|(
name|f
operator|instanceof
name|TreeBin
operator|)
condition|?
operator|(
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
operator|)
operator|.
name|first
else|:
literal|null
operator|)
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
operator|--
name|delta
expr_stmt|;
name|p
operator|=
name|p
operator|.
name|next
expr_stmt|;
block|}
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|++
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0L
condition|)
name|addCount
argument_list|(
name|delta
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a {@link Set} view of the keys contained in this map.      * The set is backed by the map, so changes to the map are      * reflected in the set, and vice-versa. The set supports element      * removal, which removes the corresponding mapping from this map,      * via the {@code Iterator.remove}, {@code Set.remove},      * {@code removeAll}, {@code retainAll}, and {@code clear}      * operations.  It does not support the {@code add} or      * {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      *      * @return the set view      */
DECL|method|keySet
specifier|public
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keySet
parameter_list|()
block|{
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ks
decl_stmt|;
return|return
operator|(
name|ks
operator|=
name|keySet
operator|)
operator|!=
literal|null
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns a {@link Collection} view of the values contained in this map.      * The collection is backed by the map, so changes to the map are      * reflected in the collection, and vice-versa.  The collection      * supports element removal, which removes the corresponding      * mapping from this map, via the {@code Iterator.remove},      * {@code Collection.remove}, {@code removeAll},      * {@code retainAll}, and {@code clear} operations.  It does not      * support the {@code add} or {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      *      * @return the collection view      */
DECL|method|values
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|ValuesView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|vs
decl_stmt|;
return|return
operator|(
name|vs
operator|=
name|values
operator|)
operator|!=
literal|null
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|ValuesView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns a {@link Set} view of the mappings contained in this map.      * The set is backed by the map, so changes to the map are      * reflected in the set, and vice-versa.  The set supports element      * removal, which removes the corresponding mapping from the map,      * via the {@code Iterator.remove}, {@code Set.remove},      * {@code removeAll}, {@code retainAll}, and {@code clear}      * operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      *      * @return the set view      */
DECL|method|entrySet
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|EntrySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|es
decl_stmt|;
return|return
operator|(
name|es
operator|=
name|entrySet
operator|)
operator|!=
literal|null
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns the hash code value for this {@link Map}, i.e.,      * the sum of, for each key-value pair in the map,      * {@code key.hashCode() ^ value.hashCode()}.      *      * @return the hash code value for this map      */
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|h
operator|+=
name|p
operator|.
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|p
operator|.
name|val
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/**      * Returns a string representation of this map.  The string      * representation consists of a list of key-value mappings (in no      * particular order) enclosed in braces ("{@code {}}").  Adjacent      * mappings are separated by the characters {@code ", "} (comma      * and space).  Each key-value mapping is rendered as the key      * followed by an equals sign ("{@code =}") followed by the      * associated value.      *      * @return a string representation of this map      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|K
name|k
init|=
name|p
operator|.
name|key
decl_stmt|;
name|V
name|v
init|=
name|p
operator|.
name|val
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|k
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|k
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|v
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
break|break;
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Compares the specified object with this map for equality.      * Returns {@code true} if the given object is a map with the same      * mappings as this map.  This operation may return misleading      * results if either map is concurrently modified during execution      * of this method.      *      * @param o object to be compared for equality with this map      * @return {@code true} if the specified object is equal to this map      */
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|!=
name|this
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|)
condition|)
return|return
literal|false
return|;
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|m
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|V
name|val
init|=
name|p
operator|.
name|val
decl_stmt|;
name|Object
name|v
init|=
name|m
operator|.
name|get
argument_list|(
name|p
operator|.
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
operator|||
operator|(
name|v
operator|!=
name|val
operator|&&
operator|!
name|v
operator|.
name|equals
argument_list|(
name|val
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|mk
decl_stmt|,
name|mv
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|mk
operator|=
name|e
operator|.
name|getKey
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|mv
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|v
operator|=
name|get
argument_list|(
name|mk
argument_list|)
operator|)
operator|==
literal|null
operator|||
operator|(
name|mv
operator|!=
name|v
operator|&&
operator|!
name|mv
operator|.
name|equals
argument_list|(
name|v
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Stripped-down version of helper class used in previous version,      * declared for the sake of serialization compatibility      */
DECL|class|Segment
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ReentrantLock
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2249069246763182397L
decl_stmt|;
DECL|field|loadFactor
specifier|final
name|float
name|loadFactor
decl_stmt|;
DECL|method|Segment
name|Segment
parameter_list|(
name|float
name|lf
parameter_list|)
block|{
name|this
operator|.
name|loadFactor
operator|=
name|lf
expr_stmt|;
block|}
block|}
comment|/**      * Saves the state of the {@code ConcurrentHashMapV8} instance to a      * stream (i.e., serializes it).      * @param s the stream      * @throws java.io.IOException if an I/O error occurs      * @serialData      * the key (Object) and value (Object)      * for each key-value mapping, followed by a null pair.      * The key-value mappings are emitted in no particular order.      */
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
comment|// For serialization compatibility
comment|// Emulate segment calculation from previous version of this class
name|int
name|sshift
init|=
literal|0
decl_stmt|;
name|int
name|ssize
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|ssize
operator|<
name|DEFAULT_CONCURRENCY_LEVEL
condition|)
block|{
operator|++
name|sshift
expr_stmt|;
name|ssize
operator|<<=
literal|1
expr_stmt|;
block|}
name|int
name|segmentShift
init|=
literal|32
operator|-
name|sshift
decl_stmt|;
name|int
name|segmentMask
init|=
name|ssize
operator|-
literal|1
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
init|=
operator|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
operator|)
operator|new
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|DEFAULT_CONCURRENCY_LEVEL
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|LOAD_FACTOR
argument_list|)
expr_stmt|;
name|s
operator|.
name|putFields
argument_list|()
operator|.
name|put
argument_list|(
literal|"segments"
argument_list|,
name|segments
argument_list|)
expr_stmt|;
name|s
operator|.
name|putFields
argument_list|()
operator|.
name|put
argument_list|(
literal|"segmentShift"
argument_list|,
name|segmentShift
argument_list|)
expr_stmt|;
name|s
operator|.
name|putFields
argument_list|()
operator|.
name|put
argument_list|(
literal|"segmentMask"
argument_list|,
name|segmentMask
argument_list|)
expr_stmt|;
name|s
operator|.
name|writeFields
argument_list|()
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|s
operator|.
name|writeObject
argument_list|(
name|p
operator|.
name|key
argument_list|)
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|segments
operator|=
literal|null
expr_stmt|;
comment|// throw away
block|}
comment|/**      * Reconstitutes the instance from a stream (that is, deserializes it).      * @param s the stream      * @throws ClassNotFoundException if the class of a serialized object      *         could not be found      * @throws java.io.IOException if an I/O error occurs      */
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
comment|/*          * To improve performance in typical cases, we create nodes          * while reading, then place in table once size is known.          * However, we must also validate uniqueness and deal with          * overpopulated bins while doing so, which requires          * specialized versions of putVal mechanics.          */
name|sizeCtl
operator|=
operator|-
literal|1
expr_stmt|;
comment|// force exclusion for table construction
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|long
name|size
init|=
literal|0L
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
literal|null
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|K
name|k
init|=
operator|(
name|K
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|V
name|v
init|=
operator|(
name|V
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|!=
literal|null
operator|&&
name|v
operator|!=
literal|null
condition|)
block|{
name|p
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|++
name|size
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|size
operator|==
literal|0L
condition|)
name|sizeCtl
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|size
operator|>=
call|(
name|long
call|)
argument_list|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
argument_list|)
condition|)
name|n
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
else|else
block|{
name|int
name|sz
init|=
operator|(
name|int
operator|)
name|size
decl_stmt|;
name|n
operator|=
name|tableSizeFor
argument_list|(
name|sz
operator|+
operator|(
name|sz
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
operator|)
operator|new
name|Node
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|n
index|]
decl_stmt|;
name|int
name|mask
init|=
name|n
operator|-
literal|1
decl_stmt|;
name|long
name|added
init|=
literal|0L
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|boolean
name|insertAtFront
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|p
operator|.
name|next
decl_stmt|,
name|first
decl_stmt|;
name|int
name|h
init|=
name|p
operator|.
name|hash
decl_stmt|,
name|j
init|=
name|h
operator|&
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|first
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|j
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|insertAtFront
operator|=
literal|true
expr_stmt|;
else|else
block|{
name|K
name|k
init|=
name|p
operator|.
name|key
decl_stmt|;
if|if
condition|(
name|first
operator|.
name|hash
operator|<
literal|0
condition|)
block|{
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|first
decl_stmt|;
if|if
condition|(
name|t
operator|.
name|putTreeVal
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|p
operator|.
name|val
argument_list|)
operator|==
literal|null
condition|)
operator|++
name|added
expr_stmt|;
name|insertAtFront
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
name|int
name|binCount
init|=
literal|0
decl_stmt|;
name|insertAtFront
operator|=
literal|true
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|q
decl_stmt|;
name|K
name|qk
decl_stmt|;
for|for
control|(
name|q
operator|=
name|first
init|;
name|q
operator|!=
literal|null
condition|;
name|q
operator|=
name|q
operator|.
name|next
control|)
block|{
if|if
condition|(
name|q
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|qk
operator|=
name|q
operator|.
name|key
operator|)
operator|==
name|k
operator|||
operator|(
name|qk
operator|!=
literal|null
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|qk
argument_list|)
operator|)
operator|)
condition|)
block|{
name|insertAtFront
operator|=
literal|false
expr_stmt|;
break|break;
block|}
operator|++
name|binCount
expr_stmt|;
block|}
if|if
condition|(
name|insertAtFront
operator|&&
name|binCount
operator|>=
name|TREEIFY_THRESHOLD
condition|)
block|{
name|insertAtFront
operator|=
literal|false
expr_stmt|;
operator|++
name|added
expr_stmt|;
name|p
operator|.
name|next
operator|=
name|first
expr_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|hd
init|=
literal|null
decl_stmt|,
name|tl
init|=
literal|null
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
operator|!=
literal|null
condition|;
name|q
operator|=
name|q
operator|.
name|next
control|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|new
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|q
operator|.
name|hash
argument_list|,
name|q
operator|.
name|key
argument_list|,
name|q
operator|.
name|val
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|.
name|prev
operator|=
name|tl
operator|)
operator|==
literal|null
condition|)
name|hd
operator|=
name|t
expr_stmt|;
else|else
name|tl
operator|.
name|next
operator|=
name|t
expr_stmt|;
name|tl
operator|=
name|t
expr_stmt|;
block|}
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|j
argument_list|,
operator|new
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|hd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|insertAtFront
condition|)
block|{
operator|++
name|added
expr_stmt|;
name|p
operator|.
name|next
operator|=
name|first
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
name|table
operator|=
name|tab
expr_stmt|;
name|sizeCtl
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
name|baseCount
operator|=
name|added
expr_stmt|;
block|}
block|}
comment|// ConcurrentMap methods
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key,      *         or {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|putIfAbsent
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|putVal
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if the specified key is null      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|value
operator|!=
literal|null
operator|&&
name|replaceNode
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if any of the arguments are null      */
DECL|method|replace
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|oldValue
operator|==
literal|null
operator|||
name|newValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|replaceNode
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|,
name|oldValue
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key,      *         or {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|replace
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|replaceNode
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|// Overrides of JDK8+ Map extension method defaults
comment|/**      * Returns the value to which the specified key is mapped, or the      * given default value if this map contains no mapping for the      * key.      *      * @param key the key whose associated value is to be returned      * @param defaultValue the value to return if this map contains      * no mapping for the given key      * @return the mapping for the key, if present; else the default value      * @throws NullPointerException if the specified key is null      */
DECL|method|getOrDefault
specifier|public
name|V
name|getOrDefault
parameter_list|(
name|Object
name|key
parameter_list|,
name|V
name|defaultValue
parameter_list|)
block|{
name|V
name|v
decl_stmt|;
return|return
operator|(
name|v
operator|=
name|get
argument_list|(
name|key
argument_list|)
operator|)
operator|==
literal|null
condition|?
name|defaultValue
else|:
name|v
return|;
block|}
DECL|method|forEach
specifier|public
name|void
name|forEach
parameter_list|(
name|BiAction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|replaceAll
specifier|public
name|void
name|replaceAll
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|function
parameter_list|)
block|{
if|if
condition|(
name|function
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|V
name|oldValue
init|=
name|p
operator|.
name|val
decl_stmt|;
for|for
control|(
name|K
name|key
init|=
name|p
operator|.
name|key
init|;
condition|;
control|)
block|{
name|V
name|newValue
init|=
name|function
operator|.
name|apply
argument_list|(
name|key
argument_list|,
name|oldValue
argument_list|)
decl_stmt|;
if|if
condition|(
name|newValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|replaceNode
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|,
name|oldValue
argument_list|)
operator|!=
literal|null
operator|||
operator|(
name|oldValue
operator|=
name|get
argument_list|(
name|key
argument_list|)
operator|)
operator|==
literal|null
condition|)
break|break;
block|}
block|}
block|}
block|}
comment|/**      * If the specified key is not already associated with a value,      * attempts to compute its value using the given mapping function      * and enters it into this map unless {@code null}.  The entire      * method invocation is performed atomically, so the function is      * applied at most once per key.  Some attempted update operations      * on this map by other threads may be blocked while computation      * is in progress, so the computation should be short and simple,      * and must not attempt to update any other mappings of this map.      *      * @param key key with which the specified value is to be associated      * @param mappingFunction the function to compute a value      * @return the current (existing or computed) value associated with      *         the specified key, or null if the computed value is null      * @throws NullPointerException if the specified key or mappingFunction      *         is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the mappingFunction does so,      *         in which case the mapping is left unestablished      */
DECL|method|computeIfAbsent
specifier|public
name|V
name|computeIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|mappingFunction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|mappingFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|key
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|val
init|=
literal|null
decl_stmt|;
name|int
name|binCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|fh
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
init|=
operator|new
name|ReservationNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|r
init|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|node
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|mappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|node
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|binCount
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
name|tab
operator|=
name|helpTransfer
argument_list|(
name|tab
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|f
init|;
condition|;
operator|++
name|binCount
control|)
block|{
name|K
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
block|{
name|val
operator|=
name|e
operator|.
name|val
expr_stmt|;
break|break;
block|}
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pred
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|mappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|added
operator|=
literal|true
expr_stmt|;
name|pred
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|instanceof
name|TreeBin
condition|)
block|{
name|binCount
operator|=
literal|2
expr_stmt|;
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
decl_stmt|,
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|t
operator|.
name|root
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|p
operator|=
name|r
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|val
operator|=
name|p
operator|.
name|val
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|mappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|added
operator|=
literal|true
expr_stmt|;
name|t
operator|.
name|putTreeVal
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|binCount
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|binCount
operator|>=
name|TREEIFY_THRESHOLD
condition|)
name|treeifyBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|added
condition|)
return|return
name|val
return|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|addCount
argument_list|(
literal|1L
argument_list|,
name|binCount
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/**      * If the value for the specified key is present, attempts to      * compute a new mapping given the key and its current mapped      * value.  The entire method invocation is performed atomically.      * Some attempted update operations on this map by other threads      * may be blocked while computation is in progress, so the      * computation should be short and simple, and must not attempt to      * update any other mappings of this map.      *      * @param key key with which a value may be associated      * @param remappingFunction the function to compute a value      * @return the new value associated with the specified key, or null if none      * @throws NullPointerException if the specified key or remappingFunction      *         is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the remappingFunction does so,      *         in which case the mapping is unchanged      */
DECL|method|computeIfPresent
specifier|public
name|V
name|computeIfPresent
parameter_list|(
name|K
name|key
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|remappingFunction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|remappingFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|key
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|val
init|=
literal|null
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|binCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|fh
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
name|tab
operator|=
name|helpTransfer
argument_list|(
name|tab
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
operator|++
name|binCount
control|)
block|{
name|K
name|ek
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
block|{
name|val
operator|=
name|remappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|e
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|en
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|en
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|instanceof
name|TreeBin
condition|)
block|{
name|binCount
operator|=
literal|2
expr_stmt|;
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
decl_stmt|,
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|t
operator|.
name|root
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|p
operator|=
name|r
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|val
operator|=
name|remappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|removeTreeNode
argument_list|(
name|p
argument_list|)
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|untreeify
argument_list|(
name|t
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|binCount
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
name|addCount
argument_list|(
operator|(
name|long
operator|)
name|delta
argument_list|,
name|binCount
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/**      * Attempts to compute a mapping for the specified key and its      * current mapped value (or {@code null} if there is no current      * mapping). The entire method invocation is performed atomically.      * Some attempted update operations on this map by other threads      * may be blocked while computation is in progress, so the      * computation should be short and simple, and must not attempt to      * update any other mappings of this Map.      *      * @param key key with which the specified value is to be associated      * @param remappingFunction the function to compute a value      * @return the new value associated with the specified key, or null if none      * @throws NullPointerException if the specified key or remappingFunction      *         is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the remappingFunction does so,      *         in which case the mapping is unchanged      */
DECL|method|compute
specifier|public
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|remappingFunction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|remappingFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|key
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|val
init|=
literal|null
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|binCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|fh
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
init|=
operator|new
name|ReservationNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
decl_stmt|;
synchronized|synchronized
init|(
name|r
init|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|node
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|remappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|node
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|binCount
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
name|tab
operator|=
name|helpTransfer
argument_list|(
name|tab
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
operator|++
name|binCount
control|)
block|{
name|K
name|ek
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
block|{
name|val
operator|=
name|remappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|,
name|e
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|e
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|en
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|en
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|val
operator|=
name|remappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|pred
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|instanceof
name|TreeBin
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
decl_stmt|,
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|t
operator|.
name|root
operator|)
operator|!=
literal|null
condition|)
name|p
operator|=
name|r
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
literal|null
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
literal|null
expr_stmt|;
name|V
name|pv
init|=
operator|(
name|p
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|p
operator|.
name|val
decl_stmt|;
name|val
operator|=
name|remappingFunction
operator|.
name|apply
argument_list|(
name|key
argument_list|,
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|putTreeVal
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|removeTreeNode
argument_list|(
name|p
argument_list|)
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|untreeify
argument_list|(
name|t
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|binCount
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|binCount
operator|>=
name|TREEIFY_THRESHOLD
condition|)
name|treeifyBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
name|addCount
argument_list|(
operator|(
name|long
operator|)
name|delta
argument_list|,
name|binCount
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/**      * If the specified key is not already associated with a      * (non-null) value, associates it with the given value.      * Otherwise, replaces the value with the results of the given      * remapping function, or removes if {@code null}. The entire      * method invocation is performed atomically.  Some attempted      * update operations on this map by other threads may be blocked      * while computation is in progress, so the computation should be      * short and simple, and must not attempt to update any other      * mappings of this Map.      *      * @param key key with which the specified value is to be associated      * @param value the value to use if absent      * @param remappingFunction the function to recompute a value if present      * @return the new value associated with the specified key, or null if none      * @throws NullPointerException if the specified key or the      *         remappingFunction is null      * @throws RuntimeException or Error if the remappingFunction does so,      *         in which case the mapping is unchanged      */
DECL|method|merge
specifier|public
name|V
name|merge
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|remappingFunction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
operator|||
name|remappingFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|key
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|val
init|=
literal|null
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|binCount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|fh
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
name|tab
operator|=
name|helpTransfer
argument_list|(
name|tab
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
block|{
name|binCount
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
operator|++
name|binCount
control|)
block|{
name|K
name|ek
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|key
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|key
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
block|{
name|val
operator|=
name|remappingFunction
operator|.
name|apply
argument_list|(
name|e
operator|.
name|val
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|e
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|en
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|en
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|value
expr_stmt|;
name|pred
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|instanceof
name|TreeBin
condition|)
block|{
name|binCount
operator|=
literal|2
expr_stmt|;
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
init|=
name|t
operator|.
name|root
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|r
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|val
operator|=
operator|(
name|p
operator|==
literal|null
operator|)
condition|?
name|value
else|:
name|remappingFunction
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|putTreeVal
argument_list|(
name|h
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|removeTreeNode
argument_list|(
name|p
argument_list|)
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|untreeify
argument_list|(
name|t
operator|.
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|binCount
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|binCount
operator|>=
name|TREEIFY_THRESHOLD
condition|)
name|treeifyBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
name|addCount
argument_list|(
operator|(
name|long
operator|)
name|delta
argument_list|,
name|binCount
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|// Hashtable legacy methods
comment|/**      * Legacy method testing if some key maps into the specified value      * in this table.  This method is identical in functionality to      * {@link #containsValue(Object)}, and exists solely to ensure      * full compatibility with class {@link java.util.Hashtable},      * which supported this method prior to introduction of the      * Java Collections framework.      *      * @param  value a value to search for      * @return {@code true} if and only if some key maps to the      *         {@code value} argument in this table as      *         determined by the {@code equals} method;      *         {@code false} otherwise      * @throws NullPointerException if the specified value is null      */
DECL|method|contains
annotation|@
name|Deprecated
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Returns an enumeration of the keys in this table.      *      * @return an enumeration of the keys in this table      * @see #keySet()      */
DECL|method|keys
specifier|public
name|Enumeration
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns an enumeration of the values in this table.      *      * @return an enumeration of the values in this table      * @see #values()      */
DECL|method|elements
specifier|public
name|Enumeration
argument_list|<
name|V
argument_list|>
name|elements
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|this
argument_list|)
return|;
block|}
comment|// ConcurrentHashMapV8-only methods
comment|/**      * Returns the number of mappings. This method should be used      * instead of {@link #size} because a ConcurrentHashMapV8 may      * contain more mappings than can be represented as an int. The      * value returned is an estimate; the actual count may differ if      * there are concurrent insertions or removals.      *      * @return the number of mappings      * @since 1.8      */
DECL|method|mappingCount
specifier|public
name|long
name|mappingCount
parameter_list|()
block|{
name|long
name|n
init|=
name|sumCount
argument_list|()
decl_stmt|;
return|return
operator|(
name|n
operator|<
literal|0L
operator|)
condition|?
literal|0L
else|:
name|n
return|;
comment|// ignore transient negative values
block|}
comment|/**      * Creates a new {@link Set} backed by a ConcurrentHashMapV8      * from the given type to {@code Boolean.TRUE}.      *      * @return the new set      * @since 1.8      */
DECL|method|newKeySet
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|>
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
name|newKeySet
parameter_list|()
block|{
return|return
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|(
operator|new
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
return|;
block|}
comment|/**      * Creates a new {@link Set} backed by a ConcurrentHashMapV8      * from the given type to {@code Boolean.TRUE}.      *      * @param initialCapacity The implementation performs internal      * sizing to accommodate this many elements.      * @return the new set      * @throws IllegalArgumentException if the initial capacity of      * elements is negative      * @since 1.8      */
DECL|method|newKeySet
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|>
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
name|newKeySet
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
return|return
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|(
operator|new
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|initialCapacity
argument_list|)
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
return|;
block|}
comment|/**      * Returns a {@link Set} view of the keys in this map, using the      * given common mapped value for any additions (i.e., {@link      * Collection#add} and {@link Collection#addAll(Collection)}).      * This is of course only appropriate if it is acceptable to use      * the same value for all additions from this view.      *      * @param mappedValue the mapped value to use for any additions      * @return the set view      * @throws NullPointerException if the mappedValue is null      */
DECL|method|keySet
specifier|public
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keySet
parameter_list|(
name|V
name|mappedValue
parameter_list|)
block|{
if|if
condition|(
name|mappedValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|mappedValue
argument_list|)
return|;
block|}
comment|/* ---------------- Special Nodes -------------- */
comment|/**      * A node inserted at head of bins during transfer operations.      */
DECL|class|ForwardingNode
specifier|static
specifier|final
class|class
name|ForwardingNode
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|nextTable
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nextTable
decl_stmt|;
DECL|method|ForwardingNode
name|ForwardingNode
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|)
block|{
name|super
argument_list|(
name|MOVED
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextTable
operator|=
name|tab
expr_stmt|;
block|}
DECL|method|find
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|)
block|{
comment|// loop to avoid arbitrarily deep recursion on forwarding nodes
name|outer
label|:
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|nextTable
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|null
operator|||
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
operator|||
operator|(
name|e
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|eh
decl_stmt|;
name|K
name|ek
decl_stmt|;
if|if
condition|(
operator|(
name|eh
operator|=
name|e
operator|.
name|hash
operator|)
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
return|return
name|e
return|;
if|if
condition|(
name|eh
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|ForwardingNode
condition|)
block|{
name|tab
operator|=
operator|(
operator|(
name|ForwardingNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|e
operator|)
operator|.
name|nextTable
expr_stmt|;
continue|continue
name|outer
continue|;
block|}
else|else
return|return
name|e
operator|.
name|find
argument_list|(
name|h
argument_list|,
name|k
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
block|}
block|}
block|}
block|}
comment|/**      * A place-holder node used in computeIfAbsent and compute      */
DECL|class|ReservationNode
specifier|static
specifier|final
class|class
name|ReservationNode
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|ReservationNode
name|ReservationNode
parameter_list|()
block|{
name|super
argument_list|(
name|RESERVED
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|find
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|)
block|{
return|return
literal|null
return|;
block|}
block|}
comment|/* ---------------- Table Initialization and Resizing -------------- */
comment|/**      * Returns the stamp bits for resizing a table of size n.      * Must be negative when shifted left by RESIZE_STAMP_SHIFT.      */
DECL|method|resizeStamp
specifier|static
specifier|final
name|int
name|resizeStamp
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|n
argument_list|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|RESIZE_STAMP_BITS
operator|-
literal|1
operator|)
operator|)
return|;
block|}
comment|/**      * Initializes table, using the size recorded in sizeCtl.      */
DECL|method|initTable
specifier|private
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|initTable
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
decl_stmt|;
name|int
name|sc
decl_stmt|;
while|while
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|==
literal|null
operator|||
name|tab
operator|.
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|<
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// lost initialization race; just spin
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|==
literal|null
operator|||
name|tab
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|int
name|n
init|=
operator|(
name|sc
operator|>
literal|0
operator|)
condition|?
name|sc
else|:
name|DEFAULT_CAPACITY
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nt
init|=
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
operator|)
operator|new
name|Node
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|n
index|]
decl_stmt|;
name|table
operator|=
name|tab
operator|=
name|nt
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|tab
return|;
block|}
comment|/**      * Adds to count, and if table is too small and not already      * resizing, initiates transfer. If already resizing, helps      * perform transfer if work is available.  Rechecks occupancy      * after a transfer to see if another resize is already needed      * because resizings are lagging additions.      *      * @param x the count to add      * @param check if<0, don't check resize, if<= 1 only check if uncontended      */
DECL|method|addCount
specifier|private
specifier|final
name|void
name|addCount
parameter_list|(
name|long
name|x
parameter_list|,
name|int
name|check
parameter_list|)
block|{
name|CounterCell
index|[]
name|as
decl_stmt|;
name|long
name|b
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|as
operator|=
name|counterCells
operator|)
operator|!=
literal|null
operator|||
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|BASECOUNT
argument_list|,
name|b
operator|=
name|baseCount
argument_list|,
name|s
operator|=
name|b
operator|+
name|x
argument_list|)
condition|)
block|{
name|CounterHashCode
name|hc
decl_stmt|;
name|CounterCell
name|a
decl_stmt|;
name|long
name|v
decl_stmt|;
name|int
name|m
decl_stmt|;
name|boolean
name|uncontended
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|(
name|hc
operator|=
name|threadCounterHashCode
operator|.
name|get
argument_list|()
operator|)
operator|==
literal|null
operator|||
name|as
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|as
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|0
operator|||
operator|(
name|a
operator|=
name|as
index|[
name|m
operator|&
name|hc
operator|.
name|code
index|]
operator|)
operator|==
literal|null
operator|||
operator|!
operator|(
name|uncontended
operator|=
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|a
argument_list|,
name|CELLVALUE
argument_list|,
name|v
operator|=
name|a
operator|.
name|value
argument_list|,
name|v
operator|+
name|x
argument_list|)
operator|)
condition|)
block|{
name|fullAddCount
argument_list|(
name|x
argument_list|,
name|hc
argument_list|,
name|uncontended
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|check
operator|<=
literal|1
condition|)
return|return;
name|s
operator|=
name|sumCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|>=
literal|0
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
decl_stmt|,
name|nt
decl_stmt|;
name|int
name|n
decl_stmt|,
name|sc
decl_stmt|;
while|while
condition|(
name|s
operator|>=
call|(
name|long
call|)
argument_list|(
name|sc
operator|=
name|sizeCtl
argument_list|)
operator|&&
operator|(
name|tab
operator|=
name|table
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|<
name|MAXIMUM_CAPACITY
condition|)
block|{
name|int
name|rs
init|=
name|resizeStamp
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|>>>
name|RESIZE_STAMP_SHIFT
operator|)
operator|!=
name|rs
operator|||
name|sc
operator|==
name|rs
operator|+
literal|1
operator|||
name|sc
operator|==
name|rs
operator|+
name|MAX_RESIZERS
operator|||
operator|(
name|nt
operator|=
name|nextTable
operator|)
operator|==
literal|null
operator|||
name|transferIndex
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
name|sc
operator|+
literal|1
argument_list|)
condition|)
name|transfer
argument_list|(
name|tab
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|(
name|rs
operator|<<
name|RESIZE_STAMP_SHIFT
operator|)
operator|+
literal|2
argument_list|)
condition|)
name|transfer
argument_list|(
name|tab
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|s
operator|=
name|sumCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Helps transfer if a resize is in progress.      */
DECL|method|helpTransfer
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|helpTransfer
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
parameter_list|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nextTab
decl_stmt|;
name|int
name|sc
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
operator|&&
operator|(
name|f
operator|instanceof
name|ForwardingNode
operator|)
operator|&&
operator|(
name|nextTab
operator|=
operator|(
operator|(
name|ForwardingNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
operator|)
operator|.
name|nextTable
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|rs
init|=
name|resizeStamp
argument_list|(
name|tab
operator|.
name|length
argument_list|)
decl_stmt|;
while|while
condition|(
name|nextTab
operator|==
name|nextTable
operator|&&
name|table
operator|==
name|tab
operator|&&
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|>>>
name|RESIZE_STAMP_SHIFT
operator|)
operator|!=
name|rs
operator|||
name|sc
operator|==
name|rs
operator|+
literal|1
operator|||
name|sc
operator|==
name|rs
operator|+
name|MAX_RESIZERS
operator|||
name|transferIndex
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
name|sc
operator|+
literal|1
argument_list|)
condition|)
block|{
name|transfer
argument_list|(
name|tab
argument_list|,
name|nextTab
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|nextTab
return|;
block|}
return|return
name|table
return|;
block|}
comment|/**      * Tries to presize table to accommodate the given number of elements.      *      * @param size number of elements (doesn't need to be perfectly accurate)      */
DECL|method|tryPresize
specifier|private
specifier|final
name|void
name|tryPresize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|c
init|=
operator|(
name|size
operator|>=
operator|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
operator|)
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
name|size
operator|+
operator|(
name|size
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|sc
decl_stmt|;
while|while
condition|(
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|>=
literal|0
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|(
name|sc
operator|>
name|c
operator|)
condition|?
name|sc
else|:
name|c
expr_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|table
operator|==
name|tab
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nt
init|=
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
operator|)
operator|new
name|Node
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|n
index|]
decl_stmt|;
name|table
operator|=
name|nt
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
name|sc
operator|||
name|n
operator|>=
name|MAXIMUM_CAPACITY
condition|)
break|break;
elseif|else
if|if
condition|(
name|tab
operator|==
name|table
condition|)
block|{
name|int
name|rs
init|=
name|resizeStamp
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nt
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|>>>
name|RESIZE_STAMP_SHIFT
operator|)
operator|!=
name|rs
operator|||
name|sc
operator|==
name|rs
operator|+
literal|1
operator|||
name|sc
operator|==
name|rs
operator|+
name|MAX_RESIZERS
operator|||
operator|(
name|nt
operator|=
name|nextTable
operator|)
operator|==
literal|null
operator|||
name|transferIndex
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
name|sc
operator|+
literal|1
argument_list|)
condition|)
name|transfer
argument_list|(
name|tab
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|(
name|rs
operator|<<
name|RESIZE_STAMP_SHIFT
operator|)
operator|+
literal|2
argument_list|)
condition|)
name|transfer
argument_list|(
name|tab
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Moves and/or copies the nodes in each bin to new table. See      * above for explanation.      */
DECL|method|transfer
specifier|private
specifier|final
name|void
name|transfer
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nextTab
parameter_list|)
block|{
name|int
name|n
init|=
name|tab
operator|.
name|length
decl_stmt|,
name|stride
decl_stmt|;
if|if
condition|(
operator|(
name|stride
operator|=
operator|(
name|NCPU
operator|>
literal|1
operator|)
condition|?
operator|(
name|n
operator|>>>
literal|3
operator|)
operator|/
name|NCPU
else|:
name|n
operator|)
operator|<
name|MIN_TRANSFER_STRIDE
condition|)
name|stride
operator|=
name|MIN_TRANSFER_STRIDE
expr_stmt|;
comment|// subdivide range
if|if
condition|(
name|nextTab
operator|==
literal|null
condition|)
block|{
comment|// initiating
try|try
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|nt
init|=
operator|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
operator|)
operator|new
name|Node
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|n
operator|<<
literal|1
index|]
decl_stmt|;
name|nextTab
operator|=
name|nt
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// try to cope with OOME
name|sizeCtl
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
return|return;
block|}
name|nextTable
operator|=
name|nextTab
expr_stmt|;
name|transferIndex
operator|=
name|n
expr_stmt|;
block|}
name|int
name|nextn
init|=
name|nextTab
operator|.
name|length
decl_stmt|;
name|ForwardingNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|fwd
init|=
operator|new
name|ForwardingNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|nextTab
argument_list|)
decl_stmt|;
name|boolean
name|advance
init|=
literal|true
decl_stmt|;
name|boolean
name|finishing
init|=
literal|false
decl_stmt|;
comment|// to ensure sweep before committing nextTab
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|bound
init|=
literal|0
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|fh
decl_stmt|;
while|while
condition|(
name|advance
condition|)
block|{
name|int
name|nextIndex
decl_stmt|,
name|nextBound
decl_stmt|;
if|if
condition|(
operator|--
name|i
operator|>=
name|bound
operator|||
name|finishing
condition|)
name|advance
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|nextIndex
operator|=
name|transferIndex
operator|)
operator|<=
literal|0
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|TRANSFERINDEX
argument_list|,
name|nextIndex
argument_list|,
name|nextBound
operator|=
operator|(
name|nextIndex
operator|>
name|stride
condition|?
name|nextIndex
operator|-
name|stride
else|:
literal|0
operator|)
argument_list|)
condition|)
block|{
name|bound
operator|=
name|nextBound
expr_stmt|;
name|i
operator|=
name|nextIndex
operator|-
literal|1
expr_stmt|;
name|advance
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|n
operator|||
name|i
operator|+
name|n
operator|>=
name|nextn
condition|)
block|{
name|int
name|sc
decl_stmt|;
if|if
condition|(
name|finishing
condition|)
block|{
name|nextTable
operator|=
literal|null
expr_stmt|;
name|table
operator|=
name|nextTab
expr_stmt|;
name|sizeCtl
operator|=
operator|(
name|n
operator|<<
literal|1
operator|)
operator|-
operator|(
name|n
operator|>>>
literal|1
operator|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
operator|=
name|sizeCtl
argument_list|,
name|sc
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|-
literal|2
operator|)
operator|!=
name|resizeStamp
argument_list|(
name|n
argument_list|)
operator|<<
name|RESIZE_STAMP_SHIFT
condition|)
return|return;
name|finishing
operator|=
name|advance
operator|=
literal|true
expr_stmt|;
name|i
operator|=
name|n
expr_stmt|;
comment|// recheck before commit
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
name|advance
operator|=
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
name|advance
operator|=
literal|true
expr_stmt|;
comment|// already processed
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ln
decl_stmt|,
name|hn
decl_stmt|;
if|if
condition|(
name|fh
operator|>=
literal|0
condition|)
block|{
name|int
name|runBit
init|=
name|fh
operator|&
name|n
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastRun
init|=
name|f
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|f
operator|.
name|next
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|int
name|b
init|=
name|p
operator|.
name|hash
operator|&
name|n
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|runBit
condition|)
block|{
name|runBit
operator|=
name|b
expr_stmt|;
name|lastRun
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|runBit
operator|==
literal|0
condition|)
block|{
name|ln
operator|=
name|lastRun
expr_stmt|;
name|hn
operator|=
literal|null
expr_stmt|;
block|}
else|else
block|{
name|hn
operator|=
name|lastRun
expr_stmt|;
name|ln
operator|=
literal|null
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|f
init|;
name|p
operator|!=
name|lastRun
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|int
name|ph
init|=
name|p
operator|.
name|hash
decl_stmt|;
name|K
name|pk
init|=
name|p
operator|.
name|key
decl_stmt|;
name|V
name|pv
init|=
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|ph
operator|&
name|n
operator|)
operator|==
literal|0
condition|)
name|ln
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|ph
argument_list|,
name|pk
argument_list|,
name|pv
argument_list|,
name|ln
argument_list|)
expr_stmt|;
else|else
name|hn
operator|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|ph
argument_list|,
name|pk
argument_list|,
name|pv
argument_list|,
name|hn
argument_list|)
expr_stmt|;
block|}
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|n
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|advance
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|f
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lo
init|=
literal|null
decl_stmt|,
name|loTail
init|=
literal|null
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|hi
init|=
literal|null
decl_stmt|,
name|hiTail
init|=
literal|null
decl_stmt|;
name|int
name|lc
init|=
literal|0
decl_stmt|,
name|hc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|t
operator|.
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
name|int
name|h
init|=
name|e
operator|.
name|hash
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
operator|new
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|e
operator|.
name|key
argument_list|,
name|e
operator|.
name|val
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|&
name|n
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|.
name|prev
operator|=
name|loTail
operator|)
operator|==
literal|null
condition|)
name|lo
operator|=
name|p
expr_stmt|;
else|else
name|loTail
operator|.
name|next
operator|=
name|p
expr_stmt|;
name|loTail
operator|=
name|p
expr_stmt|;
operator|++
name|lc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|p
operator|.
name|prev
operator|=
name|hiTail
operator|)
operator|==
literal|null
condition|)
name|hi
operator|=
name|p
expr_stmt|;
else|else
name|hiTail
operator|.
name|next
operator|=
name|p
expr_stmt|;
name|hiTail
operator|=
name|p
expr_stmt|;
operator|++
name|hc
expr_stmt|;
block|}
block|}
name|ln
operator|=
operator|(
name|lc
operator|<=
name|UNTREEIFY_THRESHOLD
operator|)
condition|?
name|untreeify
argument_list|(
name|lo
argument_list|)
else|:
operator|(
name|hc
operator|!=
literal|0
operator|)
condition|?
operator|new
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|lo
argument_list|)
else|:
name|t
expr_stmt|;
name|hn
operator|=
operator|(
name|hc
operator|<=
name|UNTREEIFY_THRESHOLD
operator|)
condition|?
name|untreeify
argument_list|(
name|hi
argument_list|)
else|:
operator|(
name|lc
operator|!=
literal|0
operator|)
condition|?
operator|new
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|hi
argument_list|)
else|:
name|t
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|n
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|advance
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* ---------------- Conversion from/to TreeBins -------------- */
comment|/**      * Replaces all linked nodes in bin at given index unless table is      * too small, in which case resizes instead.      */
DECL|method|treeifyBin
specifier|private
specifier|final
name|void
name|treeifyBin
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|b
decl_stmt|;
name|int
name|n
decl_stmt|,
name|sc
decl_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|<
name|MIN_TREEIFY_CAPACITY
condition|)
name|tryPresize
argument_list|(
name|n
operator|<<
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|b
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
name|b
operator|.
name|hash
operator|>=
literal|0
condition|)
block|{
synchronized|synchronized
init|(
name|b
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|index
argument_list|)
operator|==
name|b
condition|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|hd
init|=
literal|null
decl_stmt|,
name|tl
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|b
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
operator|new
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|e
operator|.
name|hash
argument_list|,
name|e
operator|.
name|key
argument_list|,
name|e
operator|.
name|val
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|prev
operator|=
name|tl
operator|)
operator|==
literal|null
condition|)
name|hd
operator|=
name|p
expr_stmt|;
else|else
name|tl
operator|.
name|next
operator|=
name|p
expr_stmt|;
name|tl
operator|=
name|p
expr_stmt|;
block|}
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|index
argument_list|,
operator|new
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|hd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Returns a list on non-TreeNodes replacing those in given list.      */
DECL|method|untreeify
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|untreeify
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|b
parameter_list|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|hd
init|=
literal|null
decl_stmt|,
name|tl
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|q
init|=
name|b
init|;
name|q
operator|!=
literal|null
condition|;
name|q
operator|=
name|q
operator|.
name|next
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
operator|new
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|q
operator|.
name|hash
argument_list|,
name|q
operator|.
name|key
argument_list|,
name|q
operator|.
name|val
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|tl
operator|==
literal|null
condition|)
name|hd
operator|=
name|p
expr_stmt|;
else|else
name|tl
operator|.
name|next
operator|=
name|p
expr_stmt|;
name|tl
operator|=
name|p
expr_stmt|;
block|}
return|return
name|hd
return|;
block|}
comment|/* ---------------- TreeNodes -------------- */
comment|/**      * Nodes for use in TreeBins      */
DECL|class|TreeNode
specifier|static
specifier|final
class|class
name|TreeNode
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|parent
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|parent
decl_stmt|;
comment|// red-black tree links
DECL|field|left
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|left
decl_stmt|;
DECL|field|right
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|right
decl_stmt|;
DECL|field|prev
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|prev
decl_stmt|;
comment|// needed to unlink next upon deletion
DECL|field|red
name|boolean
name|red
decl_stmt|;
DECL|method|TreeNode
name|TreeNode
parameter_list|(
name|int
name|hash
parameter_list|,
name|K
name|key
parameter_list|,
name|V
name|val
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|,
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
DECL|method|find
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|)
block|{
return|return
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**          * Returns the TreeNode (or null if not found) for the given key          * starting at given root.          */
DECL|method|findTreeNode
specifier|final
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|findTreeNode
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|,
name|Class
argument_list|<
name|?
argument_list|>
name|kc
parameter_list|)
block|{
if|if
condition|(
name|k
operator|!=
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|this
decl_stmt|;
do|do
block|{
name|int
name|ph
decl_stmt|,
name|dir
decl_stmt|;
name|K
name|pk
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|q
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pl
init|=
name|p
operator|.
name|left
decl_stmt|,
name|pr
init|=
name|p
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|p
operator|.
name|hash
operator|)
operator|>
name|h
condition|)
name|p
operator|=
name|pl
expr_stmt|;
elseif|else
if|if
condition|(
name|ph
operator|<
name|h
condition|)
name|p
operator|=
name|pr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pk
operator|=
name|p
operator|.
name|key
operator|)
operator|==
name|k
operator|||
operator|(
name|pk
operator|!=
literal|null
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|pk
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|pl
operator|==
literal|null
condition|)
name|p
operator|=
name|pr
expr_stmt|;
elseif|else
if|if
condition|(
name|pr
operator|==
literal|null
condition|)
name|p
operator|=
name|pl
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|kc
operator|!=
literal|null
operator|||
operator|(
name|kc
operator|=
name|comparableClassFor
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|dir
operator|=
name|compareComparables
argument_list|(
name|kc
argument_list|,
name|k
argument_list|,
name|pk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|p
operator|=
operator|(
name|dir
operator|<
literal|0
operator|)
condition|?
name|pl
else|:
name|pr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|q
operator|=
name|pr
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|kc
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|q
return|;
else|else
name|p
operator|=
name|pl
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
literal|null
condition|)
do|;
block|}
return|return
literal|null
return|;
block|}
block|}
comment|/* ---------------- TreeBins -------------- */
comment|/**      * TreeNodes used at the heads of bins. TreeBins do not hold user      * keys or values, but instead point to list of TreeNodes and      * their root. They also maintain a parasitic read-write lock      * forcing writers (who hold bin lock) to wait for readers (who do      * not) to complete before tree restructuring operations.      */
DECL|class|TreeBin
specifier|static
specifier|final
class|class
name|TreeBin
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|root
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|root
decl_stmt|;
DECL|field|first
specifier|volatile
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|first
decl_stmt|;
DECL|field|waiter
specifier|volatile
name|Thread
name|waiter
decl_stmt|;
DECL|field|lockState
specifier|volatile
name|int
name|lockState
decl_stmt|;
comment|// values for lockState
DECL|field|WRITER
specifier|static
specifier|final
name|int
name|WRITER
init|=
literal|1
decl_stmt|;
comment|// set while holding write lock
DECL|field|WAITER
specifier|static
specifier|final
name|int
name|WAITER
init|=
literal|2
decl_stmt|;
comment|// set when waiting for write lock
DECL|field|READER
specifier|static
specifier|final
name|int
name|READER
init|=
literal|4
decl_stmt|;
comment|// increment value for setting read lock
comment|/**          * Tie-breaking utility for ordering insertions when equal          * hashCodes and non-comparable. We don't require a total          * order, just a consistent insertion rule to maintain          * equivalence across rebalancings. Tie-breaking further than          * necessary simplifies testing a bit.          */
DECL|method|tieBreakOrder
specifier|static
name|int
name|tieBreakOrder
parameter_list|(
name|Object
name|a
parameter_list|,
name|Object
name|b
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|null
operator|||
name|b
operator|==
literal|null
operator|||
operator|(
name|d
operator|=
name|a
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|b
operator|.
name|getClass
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|d
operator|=
operator|(
name|System
operator|.
name|identityHashCode
argument_list|(
name|a
argument_list|)
operator|<=
name|System
operator|.
name|identityHashCode
argument_list|(
name|b
argument_list|)
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
expr_stmt|;
return|return
name|d
return|;
block|}
comment|/**          * Creates bin with initial set of nodes headed by b.          */
DECL|method|TreeBin
name|TreeBin
parameter_list|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|b
parameter_list|)
block|{
name|super
argument_list|(
name|TREEBIN
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|this
operator|.
name|first
operator|=
name|b
expr_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|x
init|=
name|b
init|,
name|next
init|;
name|x
operator|!=
literal|null
condition|;
name|x
operator|=
name|next
control|)
block|{
name|next
operator|=
operator|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|x
operator|.
name|next
expr_stmt|;
name|x
operator|.
name|left
operator|=
name|x
operator|.
name|right
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|null
condition|)
block|{
name|x
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
name|x
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|r
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
name|K
name|k
init|=
name|x
operator|.
name|key
decl_stmt|;
name|int
name|h
init|=
name|x
operator|.
name|hash
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|kc
init|=
literal|null
decl_stmt|;
for|for
control|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|r
init|;
condition|;
control|)
block|{
name|int
name|dir
decl_stmt|,
name|ph
decl_stmt|;
name|K
name|pk
init|=
name|p
operator|.
name|key
decl_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|p
operator|.
name|hash
operator|)
operator|>
name|h
condition|)
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ph
operator|<
name|h
condition|)
name|dir
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|kc
operator|==
literal|null
operator|&&
operator|(
name|kc
operator|=
name|comparableClassFor
argument_list|(
name|k
argument_list|)
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|dir
operator|=
name|compareComparables
argument_list|(
name|kc
argument_list|,
name|k
argument_list|,
name|pk
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|dir
operator|=
name|tieBreakOrder
argument_list|(
name|k
argument_list|,
name|pk
argument_list|)
expr_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|xp
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|dir
operator|<=
literal|0
operator|)
condition|?
name|p
operator|.
name|left
else|:
name|p
operator|.
name|right
operator|)
operator|==
literal|null
condition|)
block|{
name|x
operator|.
name|parent
operator|=
name|xp
expr_stmt|;
if|if
condition|(
name|dir
operator|<=
literal|0
condition|)
name|xp
operator|.
name|left
operator|=
name|x
expr_stmt|;
else|else
name|xp
operator|.
name|right
operator|=
name|x
expr_stmt|;
name|r
operator|=
name|balanceInsertion
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|this
operator|.
name|root
operator|=
name|r
expr_stmt|;
assert|assert
name|checkInvariants
argument_list|(
name|root
argument_list|)
assert|;
block|}
comment|/**          * Acquires write lock for tree restructuring.          */
DECL|method|lockRoot
specifier|private
specifier|final
name|void
name|lockRoot
parameter_list|()
block|{
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|LOCKSTATE
argument_list|,
literal|0
argument_list|,
name|WRITER
argument_list|)
condition|)
name|contendedLock
argument_list|()
expr_stmt|;
comment|// offload to separate method
block|}
comment|/**          * Releases write lock for tree restructuring.          */
DECL|method|unlockRoot
specifier|private
specifier|final
name|void
name|unlockRoot
parameter_list|()
block|{
name|lockState
operator|=
literal|0
expr_stmt|;
block|}
comment|/**          * Possibly blocks awaiting root lock.          */
DECL|method|contendedLock
specifier|private
specifier|final
name|void
name|contendedLock
parameter_list|()
block|{
name|boolean
name|waiting
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|s
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|lockState
operator|)
operator|&
operator|~
name|WAITER
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|LOCKSTATE
argument_list|,
name|s
argument_list|,
name|WRITER
argument_list|)
condition|)
block|{
if|if
condition|(
name|waiting
condition|)
name|waiter
operator|=
literal|null
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|&
name|WAITER
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|LOCKSTATE
argument_list|,
name|s
argument_list|,
name|s
operator||
name|WAITER
argument_list|)
condition|)
block|{
name|waiting
operator|=
literal|true
expr_stmt|;
name|waiter
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|waiting
condition|)
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Returns matching node or null if none. Tries to search          * using tree comparisons from root, but continues linear          * search when lock not available.          */
DECL|method|find
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|find
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|)
block|{
if|if
condition|(
name|k
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
control|)
block|{
name|int
name|s
decl_stmt|;
name|K
name|ek
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|lockState
operator|)
operator|&
operator|(
name|WAITER
operator||
name|WRITER
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
operator|(
name|ek
operator|!=
literal|null
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
operator|)
condition|)
return|return
name|e
return|;
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|LOCKSTATE
argument_list|,
name|s
argument_list|,
name|s
operator|+
name|READER
argument_list|)
condition|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
decl_stmt|,
name|p
decl_stmt|;
try|try
block|{
name|p
operator|=
operator|(
operator|(
name|r
operator|=
name|root
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|r
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
literal|null
argument_list|)
operator|)
expr_stmt|;
block|}
finally|finally
block|{
name|Thread
name|w
decl_stmt|;
name|int
name|ls
decl_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|LOCKSTATE
argument_list|,
name|ls
operator|=
name|lockState
argument_list|,
name|ls
operator|-
name|READER
argument_list|)
condition|)
do|;
if|if
condition|(
name|ls
operator|==
operator|(
name|READER
operator||
name|WAITER
operator|)
operator|&&
operator|(
name|w
operator|=
name|waiter
operator|)
operator|!=
literal|null
condition|)
name|LockSupport
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Finds or adds a node.          * @return null if added          */
DECL|method|putTreeVal
specifier|final
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|putTreeVal
parameter_list|(
name|int
name|h
parameter_list|,
name|K
name|k
parameter_list|,
name|V
name|v
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|kc
init|=
literal|null
decl_stmt|;
name|boolean
name|searched
init|=
literal|false
decl_stmt|;
for|for
control|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|=
name|root
init|;
condition|;
control|)
block|{
name|int
name|dir
decl_stmt|,
name|ph
decl_stmt|;
name|K
name|pk
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
name|first
operator|=
name|root
operator|=
operator|new
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|ph
operator|=
name|p
operator|.
name|hash
operator|)
operator|>
name|h
condition|)
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ph
operator|<
name|h
condition|)
name|dir
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pk
operator|=
name|p
operator|.
name|key
operator|)
operator|==
name|k
operator|||
operator|(
name|pk
operator|!=
literal|null
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|pk
argument_list|)
operator|)
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
operator|(
name|kc
operator|==
literal|null
operator|&&
operator|(
name|kc
operator|=
name|comparableClassFor
argument_list|(
name|k
argument_list|)
operator|)
operator|==
literal|null
operator|)
operator|||
operator|(
name|dir
operator|=
name|compareComparables
argument_list|(
name|kc
argument_list|,
name|k
argument_list|,
name|pk
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|searched
condition|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|q
decl_stmt|,
name|ch
decl_stmt|;
name|searched
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ch
operator|=
name|p
operator|.
name|left
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
name|ch
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|kc
argument_list|)
operator|)
operator|!=
literal|null
operator|)
operator|||
operator|(
operator|(
name|ch
operator|=
name|p
operator|.
name|right
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
name|ch
operator|.
name|findTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|kc
argument_list|)
operator|)
operator|!=
literal|null
operator|)
condition|)
return|return
name|q
return|;
block|}
name|dir
operator|=
name|tieBreakOrder
argument_list|(
name|k
argument_list|,
name|pk
argument_list|)
expr_stmt|;
block|}
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|xp
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|dir
operator|<=
literal|0
operator|)
condition|?
name|p
operator|.
name|left
else|:
name|p
operator|.
name|right
operator|)
operator|==
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|x
decl_stmt|,
name|f
init|=
name|first
decl_stmt|;
name|first
operator|=
name|x
operator|=
operator|new
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
name|f
argument_list|,
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
name|f
operator|.
name|prev
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|dir
operator|<=
literal|0
condition|)
name|xp
operator|.
name|left
operator|=
name|x
expr_stmt|;
else|else
name|xp
operator|.
name|right
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|xp
operator|.
name|red
condition|)
name|x
operator|.
name|red
operator|=
literal|true
expr_stmt|;
else|else
block|{
name|lockRoot
argument_list|()
expr_stmt|;
try|try
block|{
name|root
operator|=
name|balanceInsertion
argument_list|(
name|root
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|unlockRoot
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
assert|assert
name|checkInvariants
argument_list|(
name|root
argument_list|)
assert|;
return|return
literal|null
return|;
block|}
comment|/**          * Removes the given node, that must be present before this          * call.  This is messier than typical red-black deletion code          * because we cannot swap the contents of an interior node          * with a leaf successor that is pinned by "next" pointers          * that are accessible independently of lock. So instead we          * swap the tree linkages.          *          * @return true if now too small, so should be untreeified          */
DECL|method|removeTreeNode
specifier|final
name|boolean
name|removeTreeNode
parameter_list|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
parameter_list|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
operator|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|p
operator|.
name|next
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pred
init|=
name|p
operator|.
name|prev
decl_stmt|;
comment|// unlink traversal pointers
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
decl_stmt|,
name|rl
decl_stmt|;
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
name|first
operator|=
name|next
expr_stmt|;
else|else
name|pred
operator|.
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
name|next
operator|.
name|prev
operator|=
name|pred
expr_stmt|;
if|if
condition|(
name|first
operator|==
literal|null
condition|)
block|{
name|root
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|root
operator|)
operator|==
literal|null
operator|||
name|r
operator|.
name|right
operator|==
literal|null
operator|||
comment|// too small
operator|(
name|rl
operator|=
name|r
operator|.
name|left
operator|)
operator|==
literal|null
operator|||
name|rl
operator|.
name|left
operator|==
literal|null
condition|)
return|return
literal|true
return|;
name|lockRoot
argument_list|()
expr_stmt|;
try|try
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|replacement
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pl
init|=
name|p
operator|.
name|left
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pr
init|=
name|p
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|pl
operator|!=
literal|null
operator|&&
name|pr
operator|!=
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
name|pr
decl_stmt|,
name|sl
decl_stmt|;
while|while
condition|(
operator|(
name|sl
operator|=
name|s
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
comment|// find successor
name|s
operator|=
name|sl
expr_stmt|;
name|boolean
name|c
init|=
name|s
operator|.
name|red
decl_stmt|;
name|s
operator|.
name|red
operator|=
name|p
operator|.
name|red
expr_stmt|;
name|p
operator|.
name|red
operator|=
name|c
expr_stmt|;
comment|// swap colors
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sr
init|=
name|s
operator|.
name|right
decl_stmt|;
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pp
init|=
name|p
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|pr
condition|)
block|{
comment|// p was s's direct parent
name|p
operator|.
name|parent
operator|=
name|s
expr_stmt|;
name|s
operator|.
name|right
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sp
init|=
name|s
operator|.
name|parent
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|parent
operator|=
name|sp
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|sp
operator|.
name|left
condition|)
name|sp
operator|.
name|left
operator|=
name|p
expr_stmt|;
else|else
name|sp
operator|.
name|right
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|.
name|right
operator|=
name|pr
operator|)
operator|!=
literal|null
condition|)
name|pr
operator|.
name|parent
operator|=
name|s
expr_stmt|;
block|}
name|p
operator|.
name|left
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|right
operator|=
name|sr
operator|)
operator|!=
literal|null
condition|)
name|sr
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|left
operator|=
name|pl
operator|)
operator|!=
literal|null
condition|)
name|pl
operator|.
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|parent
operator|=
name|pp
operator|)
operator|==
literal|null
condition|)
name|r
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
name|pp
operator|.
name|left
operator|=
name|s
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
name|replacement
operator|=
name|sr
expr_stmt|;
else|else
name|replacement
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pl
operator|!=
literal|null
condition|)
name|replacement
operator|=
name|pl
expr_stmt|;
elseif|else
if|if
condition|(
name|pr
operator|!=
literal|null
condition|)
name|replacement
operator|=
name|pr
expr_stmt|;
else|else
name|replacement
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|replacement
operator|!=
name|p
condition|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pp
init|=
name|replacement
operator|.
name|parent
operator|=
name|p
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|pp
operator|==
literal|null
condition|)
name|r
operator|=
name|replacement
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
name|pp
operator|.
name|left
operator|=
name|replacement
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|replacement
expr_stmt|;
name|p
operator|.
name|left
operator|=
name|p
operator|.
name|right
operator|=
name|p
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
block|}
name|root
operator|=
operator|(
name|p
operator|.
name|red
operator|)
condition|?
name|r
else|:
name|balanceDeletion
argument_list|(
name|r
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|replacement
condition|)
block|{
comment|// detach pointers
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|pp
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|p
operator|.
name|parent
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
name|pp
operator|.
name|left
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|right
condition|)
name|pp
operator|.
name|right
operator|=
literal|null
expr_stmt|;
name|p
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|unlockRoot
argument_list|()
expr_stmt|;
block|}
assert|assert
name|checkInvariants
argument_list|(
name|root
argument_list|)
assert|;
return|return
literal|false
return|;
block|}
comment|/* ------------------------------------------------------------ */
comment|// Red-black tree methods, all adapted from CLR
DECL|method|rotateLeft
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rotateLeft
parameter_list|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|root
parameter_list|,
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
parameter_list|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
decl_stmt|,
name|pp
decl_stmt|,
name|rl
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|p
operator|.
name|right
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|rl
operator|=
name|p
operator|.
name|right
operator|=
name|r
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
name|rl
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|r
operator|.
name|parent
operator|=
name|p
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
operator|(
name|root
operator|=
name|r
operator|)
operator|.
name|red
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|.
name|left
operator|==
name|p
condition|)
name|pp
operator|.
name|left
operator|=
name|r
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|r
expr_stmt|;
name|r
operator|.
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|parent
operator|=
name|r
expr_stmt|;
block|}
return|return
name|root
return|;
block|}
DECL|method|rotateRight
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rotateRight
parameter_list|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|root
parameter_list|,
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
parameter_list|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|l
decl_stmt|,
name|pp
decl_stmt|,
name|lr
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
operator|&&
operator|(
name|l
operator|=
name|p
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|lr
operator|=
name|p
operator|.
name|left
operator|=
name|l
operator|.
name|right
operator|)
operator|!=
literal|null
condition|)
name|lr
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|l
operator|.
name|parent
operator|=
name|p
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
operator|(
name|root
operator|=
name|l
operator|)
operator|.
name|red
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|.
name|right
operator|==
name|p
condition|)
name|pp
operator|.
name|right
operator|=
name|l
expr_stmt|;
else|else
name|pp
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|l
operator|.
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|parent
operator|=
name|l
expr_stmt|;
block|}
return|return
name|root
return|;
block|}
DECL|method|balanceInsertion
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|balanceInsertion
parameter_list|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|root
parameter_list|,
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|x
parameter_list|)
block|{
name|x
operator|.
name|red
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|xp
init|,
name|xpp
init|,
name|xppl
init|,
name|xppr
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
block|{
name|x
operator|.
name|red
operator|=
literal|false
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|xp
operator|.
name|red
operator|||
operator|(
name|xpp
operator|=
name|xp
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
return|return
name|root
return|;
if|if
condition|(
name|xp
operator|==
operator|(
name|xppl
operator|=
name|xpp
operator|.
name|left
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|xppr
operator|=
name|xpp
operator|.
name|right
operator|)
operator|!=
literal|null
operator|&&
name|xppr
operator|.
name|red
condition|)
block|{
name|xppr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xpp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|xp
operator|.
name|right
condition|)
block|{
name|root
operator|=
name|rotateLeft
argument_list|(
name|root
argument_list|,
name|x
operator|=
name|xp
argument_list|)
expr_stmt|;
name|xpp
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|xpp
operator|!=
literal|null
condition|)
block|{
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|root
operator|=
name|rotateRight
argument_list|(
name|root
argument_list|,
name|xpp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|xppl
operator|!=
literal|null
operator|&&
name|xppl
operator|.
name|red
condition|)
block|{
name|xppl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xpp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|xp
operator|.
name|left
condition|)
block|{
name|root
operator|=
name|rotateRight
argument_list|(
name|root
argument_list|,
name|x
operator|=
name|xp
argument_list|)
expr_stmt|;
name|xpp
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|xpp
operator|!=
literal|null
condition|)
block|{
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|root
operator|=
name|rotateLeft
argument_list|(
name|root
argument_list|,
name|xpp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
DECL|method|balanceDeletion
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|balanceDeletion
parameter_list|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|root
parameter_list|,
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|x
parameter_list|)
block|{
for|for
control|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|xp
init|,
name|xpl
init|,
name|xpr
init|;
condition|;
control|)
block|{
if|if
condition|(
name|x
operator|==
literal|null
operator|||
name|x
operator|==
name|root
condition|)
return|return
name|root
return|;
elseif|else
if|if
condition|(
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
block|{
name|x
operator|.
name|red
operator|=
literal|false
expr_stmt|;
return|return
name|x
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|.
name|red
condition|)
block|{
name|x
operator|.
name|red
operator|=
literal|false
expr_stmt|;
return|return
name|root
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xpl
operator|=
name|xp
operator|.
name|left
operator|)
operator|==
name|x
condition|)
block|{
if|if
condition|(
operator|(
name|xpr
operator|=
name|xp
operator|.
name|right
operator|)
operator|!=
literal|null
operator|&&
name|xpr
operator|.
name|red
condition|)
block|{
name|xpr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|root
operator|=
name|rotateLeft
argument_list|(
name|root
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|xpr
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|xpr
operator|==
literal|null
condition|)
name|x
operator|=
name|xp
expr_stmt|;
else|else
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sl
init|=
name|xpr
operator|.
name|left
decl_stmt|,
name|sr
init|=
name|xpr
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
operator|)
operator|&&
operator|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
operator|)
condition|)
block|{
name|xpr
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
condition|)
block|{
if|if
condition|(
name|sl
operator|!=
literal|null
condition|)
name|sl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpr
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|root
operator|=
name|rotateRight
argument_list|(
name|root
argument_list|,
name|xpr
argument_list|)
expr_stmt|;
name|xpr
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|xpr
operator|!=
literal|null
condition|)
block|{
name|xpr
operator|.
name|red
operator|=
operator|(
name|xp
operator|==
literal|null
operator|)
condition|?
literal|false
else|:
name|xp
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|xpr
operator|.
name|right
operator|)
operator|!=
literal|null
condition|)
name|sr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|root
operator|=
name|rotateLeft
argument_list|(
name|root
argument_list|,
name|xp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|root
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// symmetric
if|if
condition|(
name|xpl
operator|!=
literal|null
operator|&&
name|xpl
operator|.
name|red
condition|)
block|{
name|xpl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|root
operator|=
name|rotateRight
argument_list|(
name|root
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|xpl
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|xpl
operator|==
literal|null
condition|)
name|x
operator|=
name|xp
expr_stmt|;
else|else
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|sl
init|=
name|xpl
operator|.
name|left
decl_stmt|,
name|sr
init|=
name|xpl
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
operator|)
operator|&&
operator|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
operator|)
condition|)
block|{
name|xpl
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
condition|)
block|{
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
name|sr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpl
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|root
operator|=
name|rotateLeft
argument_list|(
name|root
argument_list|,
name|xpl
argument_list|)
expr_stmt|;
name|xpl
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|xpl
operator|!=
literal|null
condition|)
block|{
name|xpl
operator|.
name|red
operator|=
operator|(
name|xp
operator|==
literal|null
operator|)
condition|?
literal|false
else|:
name|xp
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|(
name|sl
operator|=
name|xpl
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
name|sl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|root
operator|=
name|rotateRight
argument_list|(
name|root
argument_list|,
name|xp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|root
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/**          * Recursive invariant check          */
DECL|method|checkInvariants
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|boolean
name|checkInvariants
parameter_list|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
parameter_list|)
block|{
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tp
init|=
name|t
operator|.
name|parent
decl_stmt|,
name|tl
init|=
name|t
operator|.
name|left
decl_stmt|,
name|tr
init|=
name|t
operator|.
name|right
decl_stmt|,
name|tb
init|=
name|t
operator|.
name|prev
decl_stmt|,
name|tn
init|=
operator|(
name|TreeNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|t
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|tb
operator|!=
literal|null
operator|&&
name|tb
operator|.
name|next
operator|!=
name|t
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|tn
operator|!=
literal|null
operator|&&
name|tn
operator|.
name|prev
operator|!=
name|t
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|tp
operator|!=
literal|null
operator|&&
name|t
operator|!=
name|tp
operator|.
name|left
operator|&&
name|t
operator|!=
name|tp
operator|.
name|right
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|tl
operator|!=
literal|null
operator|&&
operator|(
name|tl
operator|.
name|parent
operator|!=
name|t
operator|||
name|tl
operator|.
name|hash
operator|>
name|t
operator|.
name|hash
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|tr
operator|!=
literal|null
operator|&&
operator|(
name|tr
operator|.
name|parent
operator|!=
name|t
operator|||
name|tr
operator|.
name|hash
operator|<
name|t
operator|.
name|hash
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|t
operator|.
name|red
operator|&&
name|tl
operator|!=
literal|null
operator|&&
name|tl
operator|.
name|red
operator|&&
name|tr
operator|!=
literal|null
operator|&&
name|tr
operator|.
name|red
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|tl
operator|!=
literal|null
operator|&&
operator|!
name|checkInvariants
argument_list|(
name|tl
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|tr
operator|!=
literal|null
operator|&&
operator|!
name|checkInvariants
argument_list|(
name|tr
argument_list|)
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|LOCKSTATE
specifier|private
specifier|static
specifier|final
name|long
name|LOCKSTATE
decl_stmt|;
static|static
block|{
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|TreeBin
operator|.
name|class
decl_stmt|;
name|LOCKSTATE
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"lockState"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/* ----------------Table Traversal -------------- */
comment|/**      * Records the table, its length, and current traversal index for a      * traverser that must process a region of a forwarded table before      * proceeding with current table.      */
DECL|class|TableStack
specifier|static
specifier|final
class|class
name|TableStack
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|length
name|int
name|length
decl_stmt|;
DECL|field|index
name|int
name|index
decl_stmt|;
DECL|field|tab
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
decl_stmt|;
DECL|field|next
name|TableStack
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
block|}
comment|/**      * Encapsulates traversal for methods such as containsValue; also      * serves as a base class for other iterators and spliterators.      *      * Method advance visits once each still-valid node that was      * reachable upon iterator construction. It might miss some that      * were added to a bin after the bin was visited, which is OK wrt      * consistency guarantees. Maintaining this property in the face      * of possible ongoing resizes requires a fair amount of      * bookkeeping state that is difficult to optimize away amidst      * volatile accesses.  Even so, traversal maintains reasonable      * throughput.      *      * Normally, iteration proceeds bin-by-bin traversing lists.      * However, if the table has been resized, then all future steps      * must traverse both the bin at the current index as well as at      * (index + baseSize); and so on for further resizings. To      * paranoically cope with potential sharing by users of iterators      * across threads, iteration terminates if a bounds checks fails      * for a table read.      */
DECL|class|Traverser
specifier|static
class|class
name|Traverser
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|tab
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
decl_stmt|;
comment|// current table; updated if resized
DECL|field|next
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
comment|// the next entry to use
DECL|field|stack
DECL|field|spare
name|TableStack
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|stack
decl_stmt|,
name|spare
decl_stmt|;
comment|// to save/restore on ForwardingNodes
DECL|field|index
name|int
name|index
decl_stmt|;
comment|// index of bin to use next
DECL|field|baseIndex
name|int
name|baseIndex
decl_stmt|;
comment|// current index of initial table
DECL|field|baseLimit
name|int
name|baseLimit
decl_stmt|;
comment|// index bound for initial table
DECL|field|baseSize
specifier|final
name|int
name|baseSize
decl_stmt|;
comment|// initial table size
DECL|method|Traverser
name|Traverser
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|this
operator|.
name|tab
operator|=
name|tab
expr_stmt|;
name|this
operator|.
name|baseSize
operator|=
name|size
expr_stmt|;
name|this
operator|.
name|baseIndex
operator|=
name|this
operator|.
name|index
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|baseLimit
operator|=
name|limit
expr_stmt|;
name|this
operator|.
name|next
operator|=
literal|null
expr_stmt|;
block|}
comment|/**          * Advances if possible, returning next valid node, or null if none.          */
DECL|method|advance
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|advance
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|next
operator|)
operator|!=
literal|null
condition|)
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|// must use locals in checks
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
return|return
name|next
operator|=
name|e
return|;
if|if
condition|(
name|baseIndex
operator|>=
name|baseLimit
operator|||
operator|(
name|t
operator|=
name|tab
operator|)
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|t
operator|.
name|length
operator|)
operator|<=
operator|(
name|i
operator|=
name|index
operator|)
operator|||
name|i
operator|<
literal|0
condition|)
return|return
name|next
operator|=
literal|null
return|;
if|if
condition|(
operator|(
name|e
operator|=
name|tabAt
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
name|e
operator|.
name|hash
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|ForwardingNode
condition|)
block|{
name|tab
operator|=
operator|(
operator|(
name|ForwardingNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|e
operator|)
operator|.
name|nextTable
expr_stmt|;
name|e
operator|=
literal|null
expr_stmt|;
name|pushState
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|TreeBin
condition|)
name|e
operator|=
operator|(
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|e
operator|)
operator|.
name|first
expr_stmt|;
else|else
name|e
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
name|stack
operator|!=
literal|null
condition|)
name|recoverState
argument_list|(
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|index
operator|=
name|i
operator|+
name|baseSize
operator|)
operator|>=
name|n
condition|)
name|index
operator|=
operator|++
name|baseIndex
expr_stmt|;
comment|// visit upper slots if present
block|}
block|}
comment|/**          * Saves traversal state upon encountering a forwarding node.          */
DECL|method|pushState
specifier|private
name|void
name|pushState
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|TableStack
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
init|=
name|spare
decl_stmt|;
comment|// reuse if possible
if|if
condition|(
name|s
operator|!=
literal|null
condition|)
name|spare
operator|=
name|s
operator|.
name|next
expr_stmt|;
else|else
name|s
operator|=
operator|new
name|TableStack
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|()
expr_stmt|;
name|s
operator|.
name|tab
operator|=
name|t
expr_stmt|;
name|s
operator|.
name|length
operator|=
name|n
expr_stmt|;
name|s
operator|.
name|index
operator|=
name|i
expr_stmt|;
name|s
operator|.
name|next
operator|=
name|stack
expr_stmt|;
name|stack
operator|=
name|s
expr_stmt|;
block|}
comment|/**          * Possibly pops traversal state.          *          * @param n length of current table          */
DECL|method|recoverState
specifier|private
name|void
name|recoverState
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|TableStack
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|stack
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|index
operator|+=
operator|(
name|len
operator|=
name|s
operator|.
name|length
operator|)
operator|)
operator|>=
name|n
condition|)
block|{
name|n
operator|=
name|len
expr_stmt|;
name|index
operator|=
name|s
operator|.
name|index
expr_stmt|;
name|tab
operator|=
name|s
operator|.
name|tab
expr_stmt|;
name|s
operator|.
name|tab
operator|=
literal|null
expr_stmt|;
name|TableStack
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
init|=
name|s
operator|.
name|next
decl_stmt|;
name|s
operator|.
name|next
operator|=
name|spare
expr_stmt|;
comment|// save for reuse
name|stack
operator|=
name|next
expr_stmt|;
name|spare
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
literal|null
operator|&&
operator|(
name|index
operator|+=
name|baseSize
operator|)
operator|>=
name|n
condition|)
name|index
operator|=
operator|++
name|baseIndex
expr_stmt|;
block|}
block|}
comment|/**      * Base of key, value, and entry Iterators. Adds fields to      * Traverser to support iterator.remove.      */
DECL|class|BaseIterator
specifier|static
class|class
name|BaseIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|lastReturned
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|lastReturned
decl_stmt|;
DECL|method|BaseIterator
name|BaseIterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|tab
argument_list|,
name|size
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
specifier|final
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|next
operator|!=
literal|null
return|;
block|}
DECL|method|hasMoreElements
specifier|public
specifier|final
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|next
operator|!=
literal|null
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|void
name|remove
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|lastReturned
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|lastReturned
operator|=
literal|null
expr_stmt|;
name|map
operator|.
name|replaceNode
argument_list|(
name|p
operator|.
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|KeyIterator
specifier|static
specifier|final
class|class
name|KeyIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BaseIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Iterator
argument_list|<
name|K
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|K
argument_list|>
block|{
DECL|method|KeyIterator
name|KeyIterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|limit
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|tab
argument_list|,
name|index
argument_list|,
name|size
argument_list|,
name|limit
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|next
specifier|public
specifier|final
name|K
name|next
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|next
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|K
name|k
init|=
name|p
operator|.
name|key
decl_stmt|;
name|lastReturned
operator|=
name|p
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|k
return|;
block|}
DECL|method|nextElement
specifier|public
specifier|final
name|K
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|static
specifier|final
class|class
name|ValueIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BaseIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|V
argument_list|>
block|{
DECL|method|ValueIterator
name|ValueIterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|limit
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|tab
argument_list|,
name|index
argument_list|,
name|size
argument_list|,
name|limit
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|next
specifier|public
specifier|final
name|V
name|next
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|next
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|V
name|v
init|=
name|p
operator|.
name|val
decl_stmt|;
name|lastReturned
operator|=
name|p
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|v
return|;
block|}
DECL|method|nextElement
specifier|public
specifier|final
name|V
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|static
specifier|final
class|class
name|EntryIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BaseIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|EntryIterator
name|EntryIterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|limit
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|tab
argument_list|,
name|index
argument_list|,
name|size
argument_list|,
name|limit
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|next
specifier|public
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|next
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|K
name|k
init|=
name|p
operator|.
name|key
decl_stmt|;
name|V
name|v
init|=
name|p
operator|.
name|val
decl_stmt|;
name|lastReturned
operator|=
name|p
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|MapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|k
argument_list|,
name|v
argument_list|,
name|map
argument_list|)
return|;
block|}
block|}
comment|/**      * Exported Entry for EntryIterator      */
DECL|class|MapEntry
specifier|static
specifier|final
class|class
name|MapEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|val
name|V
name|val
decl_stmt|;
comment|// non-null
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|MapEntry
name|MapEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|val
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
DECL|method|getKey
specifier|public
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue
specifier|public
name|V
name|getValue
parameter_list|()
block|{
return|return
name|val
return|;
block|}
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|val
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|key
operator|+
literal|"="
operator|+
name|val
return|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|k
operator|==
name|key
operator|||
name|k
operator|.
name|equals
argument_list|(
name|key
argument_list|)
operator|)
operator|&&
operator|(
name|v
operator|==
name|val
operator|||
name|v
operator|.
name|equals
argument_list|(
name|val
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/**          * Sets our entry's value and writes through to the map. The          * value to return is somewhat arbitrary here. Since we do not          * necessarily track asynchronous changes, the most recent          * "previous" value could be different from what we return (or          * could even have been removed, in which case the put will          * re-establish). We do not and cannot guarantee more.          */
DECL|method|setValue
specifier|public
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|V
name|v
init|=
name|val
decl_stmt|;
name|val
operator|=
name|value
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
DECL|class|KeySpliterator
specifier|static
specifier|final
class|class
name|KeySpliterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentHashMapSpliterator
argument_list|<
name|K
argument_list|>
block|{
DECL|field|est
name|long
name|est
decl_stmt|;
comment|// size estimate
DECL|method|KeySpliterator
name|KeySpliterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|,
name|long
name|est
parameter_list|)
block|{
name|super
argument_list|(
name|tab
argument_list|,
name|size
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|this
operator|.
name|est
operator|=
name|est
expr_stmt|;
block|}
DECL|method|trySplit
specifier|public
name|ConcurrentHashMapSpliterator
argument_list|<
name|K
argument_list|>
name|trySplit
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|f
decl_stmt|,
name|h
decl_stmt|;
return|return
operator|(
name|h
operator|=
operator|(
operator|(
name|i
operator|=
name|baseIndex
operator|)
operator|+
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|)
operator|>>>
literal|1
operator|)
operator|<=
name|i
condition|?
literal|null
else|:
operator|new
name|KeySpliterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|tab
argument_list|,
name|baseSize
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|est
operator|>>>=
literal|1
argument_list|)
return|;
block|}
DECL|method|forEachRemaining
specifier|public
name|void
name|forEachRemaining
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
DECL|method|tryAdvance
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|estimateSize
specifier|public
name|long
name|estimateSize
parameter_list|()
block|{
return|return
name|est
return|;
block|}
block|}
DECL|class|ValueSpliterator
specifier|static
specifier|final
class|class
name|ValueSpliterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentHashMapSpliterator
argument_list|<
name|V
argument_list|>
block|{
DECL|field|est
name|long
name|est
decl_stmt|;
comment|// size estimate
DECL|method|ValueSpliterator
name|ValueSpliterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|,
name|long
name|est
parameter_list|)
block|{
name|super
argument_list|(
name|tab
argument_list|,
name|size
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|this
operator|.
name|est
operator|=
name|est
expr_stmt|;
block|}
DECL|method|trySplit
specifier|public
name|ConcurrentHashMapSpliterator
argument_list|<
name|V
argument_list|>
name|trySplit
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|f
decl_stmt|,
name|h
decl_stmt|;
return|return
operator|(
name|h
operator|=
operator|(
operator|(
name|i
operator|=
name|baseIndex
operator|)
operator|+
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|)
operator|>>>
literal|1
operator|)
operator|<=
name|i
condition|?
literal|null
else|:
operator|new
name|ValueSpliterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|tab
argument_list|,
name|baseSize
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|est
operator|>>>=
literal|1
argument_list|)
return|;
block|}
DECL|method|forEachRemaining
specifier|public
name|void
name|forEachRemaining
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|tryAdvance
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|estimateSize
specifier|public
name|long
name|estimateSize
parameter_list|()
block|{
return|return
name|est
return|;
block|}
block|}
DECL|class|EntrySpliterator
specifier|static
specifier|final
class|class
name|EntrySpliterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|ConcurrentHashMapSpliterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
comment|// To export MapEntry
DECL|field|est
name|long
name|est
decl_stmt|;
comment|// size estimate
DECL|method|EntrySpliterator
name|EntrySpliterator
parameter_list|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|limit
parameter_list|,
name|long
name|est
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|tab
argument_list|,
name|size
argument_list|,
name|index
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
name|this
operator|.
name|est
operator|=
name|est
expr_stmt|;
block|}
DECL|method|trySplit
specifier|public
name|ConcurrentHashMapSpliterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|trySplit
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|f
decl_stmt|,
name|h
decl_stmt|;
return|return
operator|(
name|h
operator|=
operator|(
operator|(
name|i
operator|=
name|baseIndex
operator|)
operator|+
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|)
operator|>>>
literal|1
operator|)
operator|<=
name|i
condition|?
literal|null
else|:
operator|new
name|EntrySpliterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|tab
argument_list|,
name|baseSize
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|est
operator|>>>=
literal|1
argument_list|,
name|map
argument_list|)
return|;
block|}
DECL|method|forEachRemaining
specifier|public
name|void
name|forEachRemaining
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
operator|new
name|MapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|method|tryAdvance
specifier|public
name|boolean
name|tryAdvance
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
return|return
literal|false
return|;
name|action
operator|.
name|apply
argument_list|(
operator|new
name|MapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|estimateSize
specifier|public
name|long
name|estimateSize
parameter_list|()
block|{
return|return
name|est
return|;
block|}
block|}
comment|// Parallel bulk operations
comment|/**      * Computes initial batch value for bulk tasks. The returned value      * is approximately exp2 of the number of times (minus one) to      * split task by two before executing leaf action. This value is      * faster to compute and more convenient to use as a guide to      * splitting than is the depth, since it is used while dividing by      * two anyway.      */
DECL|method|batchFor
specifier|final
name|int
name|batchFor
parameter_list|(
name|long
name|b
parameter_list|)
block|{
name|long
name|n
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|Long
operator|.
name|MAX_VALUE
operator|||
operator|(
name|n
operator|=
name|sumCount
argument_list|()
operator|)
operator|<=
literal|1L
operator|||
name|n
operator|<
name|b
condition|)
return|return
literal|0
return|;
name|int
name|sp
init|=
name|ForkJoinPool
operator|.
name|getCommonPoolParallelism
argument_list|()
operator|<<
literal|2
decl_stmt|;
comment|// slack of 4
return|return
operator|(
name|b
operator|<=
literal|0L
operator|||
operator|(
name|n
operator|/=
name|b
operator|)
operator|>=
name|sp
operator|)
condition|?
name|sp
else|:
operator|(
name|int
operator|)
name|n
return|;
block|}
comment|/**      * Performs the given action for each (key, value).      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param action the action      * @since 1.8      */
DECL|method|forEach
specifier|public
name|void
name|forEach
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each (key, value).      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      * @since 1.8      */
DECL|method|forEach
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEach
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachTransformedMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each (key, value), or null if none.  Upon      * success, further element processing is suppressed and the      * results of any other parallel invocations of the search      * function are ignored.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each (key, value), or null if none      * @since 1.8      */
DECL|method|search
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|search
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, or null if none.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      * @since 1.8      */
DECL|method|reduce
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduce
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      * @since 1.8      */
DECL|method|reduceToDouble
specifier|public
name|double
name|reduceToDouble
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      * @since 1.8      */
DECL|method|reduceToLong
specifier|public
name|long
name|reduceToLong
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      * @since 1.8      */
DECL|method|reduceToInt
specifier|public
name|int
name|reduceToInt
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Performs the given action for each key.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param action the action      * @since 1.8      */
DECL|method|forEachKey
specifier|public
name|void
name|forEachKey
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each key.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      * @since 1.8      */
DECL|method|forEachKey
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachKey
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachTransformedKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each key, or null if none. Upon success,      * further element processing is suppressed and the results of      * any other parallel invocations of the search function are      * ignored.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each key, or null if none      * @since 1.8      */
DECL|method|searchKeys
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchKeys
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating all keys using the given      * reducer to combine values, or null if none.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param reducer a commutative associative combining function      * @return the result of accumulating all keys using the given      * reducer to combine values, or null if none      * @since 1.8      */
DECL|method|reduceKeys
specifier|public
name|K
name|reduceKeys
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, or      * null if none.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      * @since 1.8      */
DECL|method|reduceKeys
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceKeys
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      * @since 1.8      */
DECL|method|reduceKeysToDouble
specifier|public
name|double
name|reduceKeysToDouble
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      * @since 1.8      */
DECL|method|reduceKeysToLong
specifier|public
name|long
name|reduceKeysToLong
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      * @since 1.8      */
DECL|method|reduceKeysToInt
specifier|public
name|int
name|reduceKeysToInt
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Performs the given action for each value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param action the action      * @since 1.8      */
DECL|method|forEachValue
specifier|public
name|void
name|forEachValue
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      * @since 1.8      */
DECL|method|forEachValue
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachValue
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachTransformedValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each value, or null if none.  Upon success,      * further element processing is suppressed and the results of      * any other parallel invocations of the search function are      * ignored.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each value, or null if none      * @since 1.8      */
DECL|method|searchValues
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchValues
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating all values using the      * given reducer to combine values, or null if none.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param reducer a commutative associative combining function      * @return the result of accumulating all values      * @since 1.8      */
DECL|method|reduceValues
specifier|public
name|V
name|reduceValues
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values, or      * null if none.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      * @since 1.8      */
DECL|method|reduceValues
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceValues
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      * @since 1.8      */
DECL|method|reduceValuesToDouble
specifier|public
name|double
name|reduceValuesToDouble
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      * @since 1.8      */
DECL|method|reduceValuesToLong
specifier|public
name|long
name|reduceValuesToLong
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      * @since 1.8      */
DECL|method|reduceValuesToInt
specifier|public
name|int
name|reduceValuesToInt
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Performs the given action for each entry.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param action the action      * @since 1.8      */
DECL|method|forEachEntry
specifier|public
name|void
name|forEachEntry
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each entry.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      * @since 1.8      */
DECL|method|forEachEntry
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachEntry
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
operator|new
name|ForEachTransformedEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each entry, or null if none.  Upon success,      * further element processing is suppressed and the results of      * any other parallel invocations of the search function are      * ignored.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each entry, or null if none      * @since 1.8      */
DECL|method|searchEntries
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchEntries
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating all entries using the      * given reducer to combine values, or null if none.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param reducer a commutative associative combining function      * @return the result of accumulating all entries      * @since 1.8      */
DECL|method|reduceEntries
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|reduceEntries
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * or null if none.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      * @since 1.8      */
DECL|method|reduceEntries
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceEntries
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      * @since 1.8      */
DECL|method|reduceEntriesToDouble
specifier|public
name|double
name|reduceEntriesToDouble
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      * @since 1.8      */
DECL|method|reduceEntriesToLong
specifier|public
name|long
name|reduceEntriesToLong
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param parallelismThreshold the (estimated) number of elements      * needed for this operation to be executed in parallel      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      * @since 1.8      */
DECL|method|reduceEntriesToInt
specifier|public
name|int
name|reduceEntriesToInt
parameter_list|(
name|long
name|parallelismThreshold
parameter_list|,
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
literal|null
argument_list|,
name|batchFor
argument_list|(
name|parallelismThreshold
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|table
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/* ----------------Views -------------- */
comment|/**      * Base class for views.      */
DECL|class|CollectionView
specifier|abstract
specifier|static
class|class
name|CollectionView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|E
parameter_list|>
implements|implements
name|Collection
argument_list|<
name|E
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7249069246763182397L
decl_stmt|;
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|CollectionView
name|CollectionView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
comment|/**          * Returns the map backing this view.          *          * @return the map backing this view          */
DECL|method|getMap
specifier|public
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getMap
parameter_list|()
block|{
return|return
name|map
return|;
block|}
comment|/**          * Removes all of the elements from this view, by removing all          * the mappings from the map backing this view.          */
DECL|method|clear
specifier|public
specifier|final
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|size
specifier|public
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty
specifier|public
specifier|final
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
comment|// implementations below rely on concrete classes supplying these
comment|// abstract methods
comment|/**          * Returns a "weakly consistent" iterator that will never          * throw {@link ConcurrentModificationException}, and          * guarantees to traverse elements as they existed upon          * construction of the iterator, and may (but is not          * guaranteed to) reflect any modifications subsequent to          * construction.          */
DECL|method|iterator
specifier|public
specifier|abstract
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
function_decl|;
DECL|method|contains
specifier|public
specifier|abstract
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
DECL|method|remove
specifier|public
specifier|abstract
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
DECL|field|oomeMsg
specifier|private
specifier|static
specifier|final
name|String
name|oomeMsg
init|=
literal|"Required array size too large"
decl_stmt|;
DECL|method|toArray
specifier|public
specifier|final
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|long
name|sz
init|=
name|map
operator|.
name|mappingCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|>
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
name|int
name|n
init|=
operator|(
name|int
operator|)
name|sz
decl_stmt|;
name|Object
index|[]
name|r
init|=
operator|new
name|Object
index|[
name|n
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|this
control|)
block|{
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
operator|-
operator|(
name|MAX_ARRAY_SIZE
operator|>>>
literal|1
operator|)
operator|-
literal|1
condition|)
name|n
operator|=
name|MAX_ARRAY_SIZE
expr_stmt|;
else|else
name|n
operator|+=
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|r
index|[
name|i
operator|++
index|]
operator|=
name|e
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|==
name|n
operator|)
condition|?
name|r
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|toArray
specifier|public
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
name|long
name|sz
init|=
name|map
operator|.
name|mappingCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|>
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
name|int
name|m
init|=
operator|(
name|int
operator|)
name|sz
decl_stmt|;
name|T
index|[]
name|r
init|=
operator|(
name|a
operator|.
name|length
operator|>=
name|m
operator|)
condition|?
name|a
else|:
operator|(
name|T
index|[]
operator|)
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
operator|.
name|newInstance
argument_list|(
name|a
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|r
operator|.
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|this
control|)
block|{
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
operator|-
operator|(
name|MAX_ARRAY_SIZE
operator|>>>
literal|1
operator|)
operator|-
literal|1
condition|)
name|n
operator|=
name|MAX_ARRAY_SIZE
expr_stmt|;
else|else
name|n
operator|+=
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|r
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|T
operator|)
name|e
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|r
operator|&&
name|i
operator|<
name|n
condition|)
block|{
name|r
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
comment|// null-terminate
return|return
name|r
return|;
block|}
return|return
operator|(
name|i
operator|==
name|n
operator|)
condition|?
name|r
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
return|;
block|}
comment|/**          * Returns a string representation of this collection.          * The string representation consists of the string representations          * of the collection's elements in the order they are returned by          * its iterator, enclosed in square brackets ({@code "[]"}).          * Adjacent elements are separated by the characters {@code ", "}          * (comma and space).  Elements are converted to strings as by          * {@link String#valueOf(Object)}.          *          * @return a string representation of this collection          */
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
operator|==
name|this
condition|?
literal|"(this Collection)"
else|:
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
break|break;
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|containsAll
specifier|public
specifier|final
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
name|this
condition|)
block|{
for|for
control|(
name|Object
name|e
range|:
name|c
control|)
block|{
if|if
condition|(
name|e
operator|==
literal|null
operator|||
operator|!
name|contains
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|removeAll
specifier|public
specifier|final
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
DECL|method|retainAll
specifier|public
specifier|final
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|E
argument_list|>
name|it
init|=
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|c
operator|.
name|contains
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
block|}
comment|/**      * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in      * which additions may optionally be enabled by mapping to a      * common value.  This class cannot be directly instantiated.      * See {@link #keySet() keySet()},      * {@link #keySet(Object) keySet(V)},      * {@link #newKeySet() newKeySet()},      * {@link #newKeySet(int) newKeySet(int)}.      *      * @since 1.8      */
DECL|class|KeySetView
specifier|public
specifier|static
class|class
name|KeySetView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|CollectionView
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|K
argument_list|>
implements|implements
name|Set
argument_list|<
name|K
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7249069246763182397L
decl_stmt|;
DECL|field|value
specifier|private
specifier|final
name|V
name|value
decl_stmt|;
DECL|method|KeySetView
name|KeySetView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|V
name|value
parameter_list|)
block|{
comment|// non-public
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
comment|/**          * Returns the default mapped value for additions,          * or {@code null} if additions are not supported.          *          * @return the default mapped value for additions, or {@code null}          * if not supported          */
DECL|method|getMappedValue
specifier|public
name|V
name|getMappedValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
comment|/**          * {@inheritDoc}          * @throws NullPointerException if the specified key is null          */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|/**          * Removes the key from this map view, by removing the key (and its          * corresponding value) from the backing map.  This method does          * nothing if the key is not in the map.          *          * @param  o the key to be removed from the backing map          * @return {@code true} if the backing map contained the specified key          * @throws NullPointerException if the specified key is null          */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**          * @return an iterator over the keys of the backing map          */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
init|=
name|map
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|m
operator|.
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|m
argument_list|)
return|;
block|}
comment|/**          * Adds the specified key to this set view by mapping the key to          * the default mapped value in the backing map, if defined.          *          * @param e key to be added          * @return {@code true} if this set changed as a result of the call          * @throws NullPointerException if the specified key is null          * @throws UnsupportedOperationException if no default mapped value          * for additions was provided          */
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|K
name|e
parameter_list|)
block|{
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|value
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
return|return
name|map
operator|.
name|putVal
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
return|;
block|}
comment|/**          * Adds all of the elements in the specified collection to this set,          * as if by calling {@link #add} on each one.          *          * @param c the elements to be inserted into this set          * @return {@code true} if this set changed as a result of the call          * @throws NullPointerException if the collection or any of its          * elements are {@code null}          * @throws UnsupportedOperationException if no default mapped value          * for additions was provided          */
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|value
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
for|for
control|(
name|K
name|e
range|:
name|c
control|)
block|{
if|if
condition|(
name|map
operator|.
name|putVal
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
condition|)
name|added
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
for|for
control|(
name|K
name|e
range|:
name|this
control|)
name|h
operator|+=
name|e
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|h
return|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Set
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|o
operator|)
operator|==
name|this
operator|||
operator|(
name|containsAll
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|.
name|containsAll
argument_list|(
name|this
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
DECL|method|spliteratorJSR166
specifier|public
name|ConcurrentHashMapSpliterator
argument_list|<
name|K
argument_list|>
name|spliteratorJSR166
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
init|=
name|map
decl_stmt|;
name|long
name|n
init|=
name|m
operator|.
name|sumCount
argument_list|()
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|m
operator|.
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|KeySpliterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|n
operator|<
literal|0L
condition|?
literal|0L
else|:
name|n
argument_list|)
return|;
block|}
DECL|method|forEach
specifier|public
name|void
name|forEach
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|map
operator|.
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * A view of a ConcurrentHashMapV8 as a {@link Collection} of      * values, in which additions are disabled. This class cannot be      * directly instantiated. See {@link #values()}.      */
DECL|class|ValuesView
specifier|static
specifier|final
class|class
name|ValuesView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|CollectionView
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|V
argument_list|>
implements|implements
name|Collection
argument_list|<
name|V
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2249069246763182397L
decl_stmt|;
DECL|method|ValuesView
name|ValuesView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|contains
specifier|public
specifier|final
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|V
argument_list|>
name|it
init|=
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|iterator
specifier|public
specifier|final
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
init|=
name|map
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|m
operator|.
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|m
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
specifier|final
name|boolean
name|add
parameter_list|(
name|V
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|addAll
specifier|public
specifier|final
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|c
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|spliteratorJSR166
specifier|public
name|ConcurrentHashMapSpliterator
argument_list|<
name|V
argument_list|>
name|spliteratorJSR166
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
init|=
name|map
decl_stmt|;
name|long
name|n
init|=
name|m
operator|.
name|sumCount
argument_list|()
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|m
operator|.
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|ValueSpliterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|n
operator|<
literal|0L
condition|?
literal|0L
else|:
name|n
argument_list|)
return|;
block|}
DECL|method|forEach
specifier|public
name|void
name|forEach
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|map
operator|.
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)      * entries.  This class cannot be directly instantiated. See      * {@link #entrySet()}.      */
DECL|class|EntrySetView
specifier|static
specifier|final
class|class
name|EntrySetView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|CollectionView
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
implements|implements
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2249069246763182397L
decl_stmt|;
DECL|method|EntrySetView
name|EntrySetView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|map
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|==
name|r
operator|||
name|v
operator|.
name|equals
argument_list|(
name|r
argument_list|)
operator|)
operator|)
return|;
block|}
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|map
operator|.
name|remove
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
comment|/**          * @return an iterator over the entries of the backing map          */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
init|=
name|map
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|m
operator|.
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|EntryIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|m
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
return|return
name|map
operator|.
name|putVal
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
return|;
block|}
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
range|:
name|c
control|)
block|{
if|if
condition|(
name|add
argument_list|(
name|e
argument_list|)
condition|)
name|added
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|hashCode
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|map
operator|.
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|h
operator|+=
name|p
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|h
return|;
block|}
DECL|method|equals
specifier|public
specifier|final
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Set
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|o
operator|)
operator|==
name|this
operator|||
operator|(
name|containsAll
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|.
name|containsAll
argument_list|(
name|this
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
DECL|method|spliteratorJSR166
specifier|public
name|ConcurrentHashMapSpliterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|spliteratorJSR166
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
init|=
name|map
decl_stmt|;
name|long
name|n
init|=
name|m
operator|.
name|sumCount
argument_list|()
decl_stmt|;
name|int
name|f
init|=
operator|(
name|t
operator|=
name|m
operator|.
name|table
operator|)
operator|==
literal|null
condition|?
literal|0
else|:
name|t
operator|.
name|length
decl_stmt|;
return|return
operator|new
name|EntrySpliterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
literal|0
argument_list|,
name|f
argument_list|,
name|n
operator|<
literal|0L
condition|?
literal|0L
else|:
name|n
argument_list|,
name|m
argument_list|)
return|;
block|}
DECL|method|forEach
specifier|public
name|void
name|forEach
parameter_list|(
name|Action
argument_list|<
name|?
super|super
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|map
operator|.
name|table
operator|)
operator|!=
literal|null
condition|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|t
argument_list|,
name|t
operator|.
name|length
argument_list|,
literal|0
argument_list|,
name|t
operator|.
name|length
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
operator|new
name|MapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
name|map
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// -------------------------------------------------------
comment|/**      * Base class for bulk tasks. Repeats some fields and code from      * class Traverser, because we need to subclass CountedCompleter.      */
DECL|class|BulkTask
specifier|abstract
specifier|static
class|class
name|BulkTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|R
parameter_list|>
extends|extends
name|CountedCompleter
argument_list|<
name|R
argument_list|>
block|{
DECL|field|tab
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|tab
decl_stmt|;
comment|// same as Traverser
DECL|field|next
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
decl_stmt|;
DECL|field|index
name|int
name|index
decl_stmt|;
DECL|field|baseIndex
name|int
name|baseIndex
decl_stmt|;
DECL|field|baseLimit
name|int
name|baseLimit
decl_stmt|;
DECL|field|baseSize
specifier|final
name|int
name|baseSize
decl_stmt|;
DECL|field|batch
name|int
name|batch
decl_stmt|;
comment|// split control
DECL|method|BulkTask
name|BulkTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|par
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|)
block|{
name|super
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|this
operator|.
name|batch
operator|=
name|b
expr_stmt|;
name|this
operator|.
name|index
operator|=
name|this
operator|.
name|baseIndex
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|tab
operator|=
name|t
operator|)
operator|==
literal|null
condition|)
name|this
operator|.
name|baseSize
operator|=
name|this
operator|.
name|baseLimit
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|par
operator|==
literal|null
condition|)
name|this
operator|.
name|baseSize
operator|=
name|this
operator|.
name|baseLimit
operator|=
name|t
operator|.
name|length
expr_stmt|;
else|else
block|{
name|this
operator|.
name|baseLimit
operator|=
name|f
expr_stmt|;
name|this
operator|.
name|baseSize
operator|=
name|par
operator|.
name|baseSize
expr_stmt|;
block|}
block|}
comment|/**          * Same as Traverser version          */
DECL|method|advance
specifier|final
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|advance
parameter_list|()
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|next
operator|)
operator|!=
literal|null
condition|)
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|K
name|ek
decl_stmt|;
comment|// must use locals in checks
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
return|return
name|next
operator|=
name|e
return|;
if|if
condition|(
name|baseIndex
operator|>=
name|baseLimit
operator|||
operator|(
name|t
operator|=
name|tab
operator|)
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|t
operator|.
name|length
operator|)
operator|<=
operator|(
name|i
operator|=
name|index
operator|)
operator|||
name|i
operator|<
literal|0
condition|)
return|return
name|next
operator|=
literal|null
return|;
if|if
condition|(
operator|(
name|e
operator|=
name|tabAt
argument_list|(
name|t
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
name|e
operator|.
name|hash
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|instanceof
name|ForwardingNode
condition|)
block|{
name|tab
operator|=
operator|(
operator|(
name|ForwardingNode
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|e
operator|)
operator|.
name|nextTable
expr_stmt|;
name|e
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|e
operator|instanceof
name|TreeBin
condition|)
name|e
operator|=
operator|(
operator|(
name|TreeBin
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|e
operator|)
operator|.
name|first
expr_stmt|;
else|else
name|e
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|index
operator|+=
name|baseSize
operator|)
operator|>=
name|n
condition|)
name|index
operator|=
operator|++
name|baseIndex
expr_stmt|;
comment|// visit upper slots if present
block|}
block|}
block|}
comment|/*      * Task classes. Coded in a regular but ugly format/style to      * simplify checks that each variant differs in the right way from      * others. The null screenings exist because compilers cannot tell      * that we've already null-checked task arguments, so we force      * simplest hoisted bypass to help avoid convoluted traps.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachKeyTask
specifier|static
specifier|final
class|class
name|ForEachKeyTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|Action
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachKeyTask
name|ForEachKeyTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Action
argument_list|<
name|?
super|super
name|K
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachValueTask
specifier|static
specifier|final
class|class
name|ForEachValueTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|Action
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachValueTask
name|ForEachValueTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Action
argument_list|<
name|?
super|super
name|V
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachEntryTask
specifier|static
specifier|final
class|class
name|ForEachEntryTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|Action
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachEntryTask
name|ForEachEntryTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Action
argument_list|<
name|?
super|super
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachMappingTask
specifier|static
specifier|final
class|class
name|ForEachMappingTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachMappingTask
name|ForEachMappingTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|BiAction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiAction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|action
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachTransformedKeyTask
specifier|static
specifier|final
class|class
name|ForEachTransformedKeyTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedKeyTask
name|ForEachTransformedKeyTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachTransformedKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachTransformedValueTask
specifier|static
specifier|final
class|class
name|ForEachTransformedValueTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedValueTask
name|ForEachTransformedValueTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachTransformedValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachTransformedEntryTask
specifier|static
specifier|final
class|class
name|ForEachTransformedEntryTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedEntryTask
name|ForEachTransformedEntryTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachTransformedEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ForEachTransformedMappingTask
specifier|static
specifier|final
class|class
name|ForEachTransformedMappingTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedMappingTask
name|ForEachTransformedMappingTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|?
super|super
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|ForEachTransformedMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|SearchKeysTask
specifier|static
specifier|final
class|class
name|SearchKeysTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchKeysTask
name|SearchKeysTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|SearchKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|U
name|u
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|SearchValuesTask
specifier|static
specifier|final
class|class
name|SearchValuesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchValuesTask
name|SearchValuesTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|SearchValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|U
name|u
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|SearchEntriesTask
specifier|static
specifier|final
class|class
name|SearchEntriesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|Fun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchEntriesTask
name|SearchEntriesTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|Fun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|SearchEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|U
name|u
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|SearchMappingsTask
specifier|static
specifier|final
class|class
name|SearchMappingsTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchMappingsTask
name|SearchMappingsTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|new
name|SearchMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|U
name|u
decl_stmt|;
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ReduceKeysTask
specifier|static
specifier|final
class|class
name|ReduceKeysTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|K
argument_list|>
block|{
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|K
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|ReduceKeysTask
name|ReduceKeysTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|K
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
name|K
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|K
name|u
init|=
name|p
operator|.
name|key
decl_stmt|;
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|u
operator|==
literal|null
condition|?
name|r
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|K
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ReduceValuesTask
specifier|static
specifier|final
class|class
name|ReduceValuesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|V
argument_list|>
block|{
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|V
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|ReduceValuesTask
name|ReduceValuesTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|V
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
name|V
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|V
name|v
init|=
name|p
operator|.
name|val
decl_stmt|;
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|v
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|V
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|ReduceEntriesTask
specifier|static
specifier|final
class|class
name|ReduceEntriesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|ReduceEntriesTask
name|ReduceEntriesTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|p
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceKeysTask
specifier|static
specifier|final
class|class
name|MapReduceKeysTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysTask
name|MapReduceKeysTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
name|U
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceValuesTask
specifier|static
specifier|final
class|class
name|MapReduceValuesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesTask
name|MapReduceValuesTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
name|U
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceEntriesTask
specifier|static
specifier|final
class|class
name|MapReduceEntriesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesTask
name|MapReduceEntriesTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
name|U
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceMappingsTask
specifier|static
specifier|final
class|class
name|MapReduceMappingsTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsTask
name|MapReduceMappingsTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
name|U
name|r
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceKeysToDoubleTask
specifier|static
specifier|final
class|class
name|MapReduceKeysToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysToDoubleTask
name|MapReduceKeysToDoubleTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceValuesToDoubleTask
specifier|static
specifier|final
class|class
name|MapReduceValuesToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesToDoubleTask
name|MapReduceValuesToDoubleTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceEntriesToDoubleTask
specifier|static
specifier|final
class|class
name|MapReduceEntriesToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesToDoubleTask
name|MapReduceEntriesToDoubleTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceMappingsToDoubleTask
specifier|static
specifier|final
class|class
name|MapReduceMappingsToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsToDoubleTask
name|MapReduceMappingsToDoubleTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceKeysToLongTask
specifier|static
specifier|final
class|class
name|MapReduceKeysToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysToLongTask
name|MapReduceKeysToLongTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceValuesToLongTask
specifier|static
specifier|final
class|class
name|MapReduceValuesToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesToLongTask
name|MapReduceValuesToLongTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceEntriesToLongTask
specifier|static
specifier|final
class|class
name|MapReduceEntriesToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesToLongTask
name|MapReduceEntriesToLongTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceMappingsToLongTask
specifier|static
specifier|final
class|class
name|MapReduceMappingsToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsToLongTask
name|MapReduceMappingsToLongTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceKeysToIntTask
specifier|static
specifier|final
class|class
name|MapReduceKeysToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysToIntTask
name|MapReduceKeysToIntTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceValuesToIntTask
specifier|static
specifier|final
class|class
name|MapReduceValuesToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesToIntTask
name|MapReduceValuesToIntTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceEntriesToIntTask
specifier|static
specifier|final
class|class
name|MapReduceEntriesToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesToIntTask
name|MapReduceEntriesToIntTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
DECL|class|MapReduceMappingsToIntTask
specifier|static
specifier|final
class|class
name|MapReduceMappingsToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsToIntTask
name|MapReduceMappingsToIntTask
parameter_list|(
name|BulkTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|t
parameter_list|,
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|baseIndex
init|,
name|f
init|,
name|h
init|;
name|batch
operator|>
literal|0
operator|&&
operator|(
name|h
operator|=
operator|(
operator|(
name|f
operator|=
name|baseLimit
operator|)
operator|+
name|i
operator|)
operator|>>>
literal|1
operator|)
operator|>
name|i
condition|;
control|)
block|{
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|batch
operator|>>>=
literal|1
argument_list|,
name|baseLimit
operator|=
name|h
argument_list|,
name|f
argument_list|,
name|tab
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Node
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|p
init|;
operator|(
name|p
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* ---------------- Counters -------------- */
comment|// Adapted from LongAdder and Striped64.
comment|// See their internal docs for explanation.
comment|// A padded cell for distributing counts
DECL|class|CounterCell
specifier|static
specifier|final
class|class
name|CounterCell
block|{
DECL|field|p0
DECL|field|p1
DECL|field|p2
DECL|field|p3
DECL|field|p4
DECL|field|p5
DECL|field|p6
specifier|volatile
name|long
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|p4
decl_stmt|,
name|p5
decl_stmt|,
name|p6
decl_stmt|;
DECL|field|value
specifier|volatile
name|long
name|value
decl_stmt|;
DECL|field|q0
DECL|field|q1
DECL|field|q2
DECL|field|q3
DECL|field|q4
DECL|field|q5
DECL|field|q6
specifier|volatile
name|long
name|q0
decl_stmt|,
name|q1
decl_stmt|,
name|q2
decl_stmt|,
name|q3
decl_stmt|,
name|q4
decl_stmt|,
name|q5
decl_stmt|,
name|q6
decl_stmt|;
DECL|method|CounterCell
name|CounterCell
parameter_list|(
name|long
name|x
parameter_list|)
block|{
name|value
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/**      * Holder for the thread-local hash code determining which      * CounterCell to use. The code is initialized via the      * counterHashCodeGenerator, but may be moved upon collisions.      */
DECL|class|CounterHashCode
specifier|static
specifier|final
class|class
name|CounterHashCode
block|{
DECL|field|code
name|int
name|code
decl_stmt|;
block|}
comment|/**      * Generates initial value for per-thread CounterHashCodes.      */
DECL|field|counterHashCodeGenerator
specifier|static
specifier|final
name|AtomicInteger
name|counterHashCodeGenerator
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**      * Increment for counterHashCodeGenerator. See class ThreadLocal      * for explanation.      */
DECL|field|SEED_INCREMENT
specifier|static
specifier|final
name|int
name|SEED_INCREMENT
init|=
literal|0x61c88647
decl_stmt|;
comment|/**      * Per-thread counter hash codes. Shared across all instances.      */
DECL|field|threadCounterHashCode
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|CounterHashCode
argument_list|>
name|threadCounterHashCode
init|=
operator|new
name|ThreadLocal
argument_list|<
name|CounterHashCode
argument_list|>
argument_list|()
decl_stmt|;
DECL|method|sumCount
specifier|final
name|long
name|sumCount
parameter_list|()
block|{
name|CounterCell
index|[]
name|as
init|=
name|counterCells
decl_stmt|;
name|CounterCell
name|a
decl_stmt|;
name|long
name|sum
init|=
name|baseCount
decl_stmt|;
if|if
condition|(
name|as
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|as
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|a
operator|=
name|as
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|sum
operator|+=
name|a
operator|.
name|value
expr_stmt|;
block|}
block|}
return|return
name|sum
return|;
block|}
comment|// See LongAdder version for explanation
DECL|method|fullAddCount
specifier|private
specifier|final
name|void
name|fullAddCount
parameter_list|(
name|long
name|x
parameter_list|,
name|CounterHashCode
name|hc
parameter_list|,
name|boolean
name|wasUncontended
parameter_list|)
block|{
name|int
name|h
decl_stmt|;
if|if
condition|(
name|hc
operator|==
literal|null
condition|)
block|{
name|hc
operator|=
operator|new
name|CounterHashCode
argument_list|()
expr_stmt|;
name|int
name|s
init|=
name|counterHashCodeGenerator
operator|.
name|addAndGet
argument_list|(
name|SEED_INCREMENT
argument_list|)
decl_stmt|;
name|h
operator|=
name|hc
operator|.
name|code
operator|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|s
expr_stmt|;
comment|// Avoid zero
name|threadCounterHashCode
operator|.
name|set
argument_list|(
name|hc
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|=
name|hc
operator|.
name|code
expr_stmt|;
name|boolean
name|collide
init|=
literal|false
decl_stmt|;
comment|// True if last slot nonempty
for|for
control|(
init|;
condition|;
control|)
block|{
name|CounterCell
index|[]
name|as
decl_stmt|;
name|CounterCell
name|a
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|as
operator|=
name|counterCells
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|n
operator|=
name|as
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|=
name|as
index|[
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
index|]
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|cellsBusy
operator|==
literal|0
condition|)
block|{
comment|// Try to attach new Cell
name|CounterCell
name|r
init|=
operator|new
name|CounterCell
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|// Optimistic create
if|if
condition|(
name|cellsBusy
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|CELLSBUSY
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|boolean
name|created
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Recheck under lock
name|CounterCell
index|[]
name|rs
decl_stmt|;
name|int
name|m
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|=
name|counterCells
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|rs
operator|.
name|length
operator|)
operator|>
literal|0
operator|&&
name|rs
index|[
name|j
operator|=
operator|(
name|m
operator|-
literal|1
operator|)
operator|&
name|h
index|]
operator|==
literal|null
condition|)
block|{
name|rs
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
name|created
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cellsBusy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|created
condition|)
break|break;
continue|continue;
comment|// Slot is now non-empty
block|}
block|}
name|collide
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wasUncontended
condition|)
comment|// CAS already known to fail
name|wasUncontended
operator|=
literal|true
expr_stmt|;
comment|// Continue after rehash
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|a
argument_list|,
name|CELLVALUE
argument_list|,
name|v
operator|=
name|a
operator|.
name|value
argument_list|,
name|v
operator|+
name|x
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|counterCells
operator|!=
name|as
operator|||
name|n
operator|>=
name|NCPU
condition|)
name|collide
operator|=
literal|false
expr_stmt|;
comment|// At max size or stale
elseif|else
if|if
condition|(
operator|!
name|collide
condition|)
name|collide
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|cellsBusy
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|CELLSBUSY
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|counterCells
operator|==
name|as
condition|)
block|{
comment|// Expand table unless stale
name|CounterCell
index|[]
name|rs
init|=
operator|new
name|CounterCell
index|[
name|n
operator|<<
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|rs
index|[
name|i
index|]
operator|=
name|as
index|[
name|i
index|]
expr_stmt|;
name|counterCells
operator|=
name|rs
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cellsBusy
operator|=
literal|0
expr_stmt|;
block|}
name|collide
operator|=
literal|false
expr_stmt|;
continue|continue;
comment|// Retry with expanded table
block|}
name|h
operator|^=
name|h
operator|<<
literal|13
expr_stmt|;
comment|// Rehash
name|h
operator|^=
name|h
operator|>>>
literal|17
expr_stmt|;
name|h
operator|^=
name|h
operator|<<
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cellsBusy
operator|==
literal|0
operator|&&
name|counterCells
operator|==
name|as
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|CELLSBUSY
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|boolean
name|init
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Initialize table
if|if
condition|(
name|counterCells
operator|==
name|as
condition|)
block|{
name|CounterCell
index|[]
name|rs
init|=
operator|new
name|CounterCell
index|[
literal|2
index|]
decl_stmt|;
name|rs
index|[
name|h
operator|&
literal|1
index|]
operator|=
operator|new
name|CounterCell
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|counterCells
operator|=
name|rs
expr_stmt|;
name|init
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|cellsBusy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|BASECOUNT
argument_list|,
name|v
operator|=
name|baseCount
argument_list|,
name|v
operator|+
name|x
argument_list|)
condition|)
break|break;
comment|// Fall back on using base
block|}
name|hc
operator|.
name|code
operator|=
name|h
expr_stmt|;
comment|// Record index for next time
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|SIZECTL
specifier|private
specifier|static
specifier|final
name|long
name|SIZECTL
decl_stmt|;
DECL|field|TRANSFERINDEX
specifier|private
specifier|static
specifier|final
name|long
name|TRANSFERINDEX
decl_stmt|;
DECL|field|BASECOUNT
specifier|private
specifier|static
specifier|final
name|long
name|BASECOUNT
decl_stmt|;
DECL|field|CELLSBUSY
specifier|private
specifier|static
specifier|final
name|long
name|CELLSBUSY
decl_stmt|;
DECL|field|CELLVALUE
specifier|private
specifier|static
specifier|final
name|long
name|CELLVALUE
decl_stmt|;
DECL|field|ABASE
specifier|private
specifier|static
specifier|final
name|long
name|ABASE
decl_stmt|;
DECL|field|ASHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ASHIFT
decl_stmt|;
static|static
block|{
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|ConcurrentHashMapV8
operator|.
name|class
decl_stmt|;
name|SIZECTL
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"sizeCtl"
argument_list|)
argument_list|)
expr_stmt|;
name|TRANSFERINDEX
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"transferIndex"
argument_list|)
argument_list|)
expr_stmt|;
name|BASECOUNT
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"baseCount"
argument_list|)
argument_list|)
expr_stmt|;
name|CELLSBUSY
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"cellsBusy"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|ck
init|=
name|CounterCell
operator|.
name|class
decl_stmt|;
name|CELLVALUE
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|ck
operator|.
name|getDeclaredField
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|ak
init|=
name|Node
index|[]
operator|.
name|class
decl_stmt|;
name|ABASE
operator|=
name|U
operator|.
name|arrayBaseOffset
argument_list|(
name|ak
argument_list|)
expr_stmt|;
name|int
name|scale
init|=
name|U
operator|.
name|arrayIndexScale
argument_list|(
name|ak
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|scale
operator|&
operator|(
name|scale
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|ASHIFT
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

