begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_comment
comment|// Snapshot Tue Jun  5 14:56:09 2012  Doug Lea  (dl at altair)
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_import
import|import
name|jsr166e
operator|.
name|LongAdder
import|;
end_import

begin_import
import|import
name|jsr166y
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|AbstractQueuedSynchronizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_comment
comment|/**  * A hash table supporting full concurrency of retrievals and  * high expected concurrency for updates. This class obeys the  * same functional specification as {@link java.util.Hashtable}, and  * includes versions of methods corresponding to each method of  * {@code Hashtable}. However, even though all operations are  * thread-safe, retrieval operations do<em>not</em> entail locking,  * and there is<em>not</em> any support for locking the entire table  * in a way that prevents all access.  This class is fully  * interoperable with {@code Hashtable} in programs that rely on its  * thread safety but not on its synchronization details.  *  *<p> Retrieval operations (including {@code get}) generally do not  * block, so may overlap with update operations (including {@code put}  * and {@code remove}). Retrievals reflect the results of the most  * recently<em>completed</em> update operations holding upon their  * onset.  For aggregate operations such as {@code putAll} and {@code  * clear}, concurrent retrievals may reflect insertion or removal of  * only some entries.  Similarly, Iterators and Enumerations return  * elements reflecting the state of the hash table at some point at or  * since the creation of the iterator/enumeration.  They do  *<em>not</em> throw {@link ConcurrentModificationException}.  * However, iterators are designed to be used by only one thread at a  * time.  Bear in mind that the results of aggregate status methods  * including {@code size}, {@code isEmpty}, and {@code containsValue}  * are typically useful only when a map is not undergoing concurrent  * updates in other threads.  Otherwise the results of these methods  * reflect transient states that may be adequate for monitoring  * or estimation purposes, but not for program control.  *  *<p> The table is dynamically expanded when there are too many  * collisions (i.e., keys that have distinct hash codes but fall into  * the same slot modulo the table size), with the expected average  * effect of maintaining roughly two bins per mapping (corresponding  * to a 0.75 load factor threshold for resizing). There may be much  * variance around this average as mappings are added and removed, but  * overall, this maintains a commonly accepted time/space tradeoff for  * hash tables.  However, resizing this or any other kind of hash  * table may be a relatively slow operation. When possible, it is a  * good idea to provide a size estimate as an optional {@code  * initialCapacity} constructor argument. An additional optional  * {@code loadFactor} constructor argument provides a further means of  * customizing initial table capacity by specifying the table density  * to be used in calculating the amount of space to allocate for the  * given number of elements.  Also, for compatibility with previous  * versions of this class, constructors may optionally specify an  * expected {@code concurrencyLevel} as an additional hint for  * internal sizing.  Note that using many keys with exactly the same  * {@code hashCode()} is a sure way to slow down performance of any  * hash table.  *  *<p>This class and its views and iterators implement all of the  *<em>optional</em> methods of the {@link Map} and {@link Iterator}  * interfaces.  *  *<p> Like {@link Hashtable} but unlike {@link HashMap}, this class  * does<em>not</em> allow {@code null} to be used as a key or value.  *  *<p>This class is a member of the  *<a href="{@docRoot}/../technotes/guides/collections/index.html">  * Java Collections Framework</a>.  *  *<p><em>jsr166e note: This class is a candidate replacement for  * java.util.concurrent.ConcurrentHashMap.<em>  *  * @since 1.5  * @author Doug Lea  * @param<K> the type of keys maintained by this map  * @param<V> the type of mapped values  */
end_comment

begin_class
DECL|class|ConcurrentHashMapV8
specifier|public
class|class
name|ConcurrentHashMapV8
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7249069246763182397L
decl_stmt|;
comment|/**      * A function computing a mapping from the given key to a value.      * This is a place-holder for an upcoming JDK8 interface.      */
DECL|interface|MappingFunction
specifier|public
specifier|static
interface|interface
name|MappingFunction
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * Returns a non-null value for the given key.          *          * @param key the (non-null) key          * @return a non-null value          */
DECL|method|map
name|V
name|map
parameter_list|(
name|K
name|key
parameter_list|)
function_decl|;
block|}
comment|/**      * A function computing a new mapping given a key and its current      * mapped value (or {@code null} if there is no current      * mapping). This is a place-holder for an upcoming JDK8      * interface.      */
DECL|interface|RemappingFunction
specifier|public
specifier|static
interface|interface
name|RemappingFunction
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
comment|/**          * Returns a new value given a key and its current value.          *          * @param key the (non-null) key          * @param value the current value, or null if there is no mapping          * @return a non-null value          */
DECL|method|remap
name|V
name|remap
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
function_decl|;
block|}
comment|/*      * Overview:      *      * The primary design goal of this hash table is to maintain      * concurrent readability (typically method get(), but also      * iterators and related methods) while minimizing update      * contention. Secondary goals are to keep space consumption about      * the same or better than java.util.HashMap, and to support high      * initial insertion rates on an empty table by many threads.      *      * Each key-value mapping is held in a Node.  Because Node fields      * can contain special values, they are defined using plain Object      * types. Similarly in turn, all internal methods that use them      * work off Object types. And similarly, so do the internal      * methods of auxiliary iterator and view classes.  All public      * generic typed methods relay in/out of these internal methods,      * supplying null-checks and casts as needed. This also allows      * many of the public methods to be factored into a smaller number      * of internal methods (although sadly not so for the five      * variants of put-related operations). The validation-based      * approach explained below leads to a lot of code sprawl because      * retry-control precludes factoring into smaller methods.      *      * The table is lazily initialized to a power-of-two size upon the      * first insertion.  Each bin in the table normally contains a      * list of Nodes (most often, the list has only zero or one Node).      * Table accesses require volatile/atomic reads, writes, and      * CASes.  Because there is no other way to arrange this without      * adding further indirections, we use intrinsics      * (sun.misc.Unsafe) operations.  The lists of nodes within bins      * are always accurately traversable under volatile reads, so long      * as lookups check hash code and non-nullness of value before      * checking key equality.      *      * We use the top two bits of Node hash fields for control      * purposes -- they are available anyway because of addressing      * constraints.  As explained further below, these top bits are      * used as follows:      *  00 - Normal      *  01 - Locked      *  11 - Locked and may have a thread waiting for lock      *  10 - Node is a forwarding node      *      * The lower 30 bits of each Node's hash field contain a      * transformation of the key's hash code, except for forwarding      * nodes, for which the lower bits are zero (and so always have      * hash field == MOVED).      *      * Insertion (via put or its variants) of the first node in an      * empty bin is performed by just CASing it to the bin.  This is      * by far the most common case for put operations under most      * key/hash distributions.  Other update operations (insert,      * delete, and replace) require locks.  We do not want to waste      * the space required to associate a distinct lock object with      * each bin, so instead use the first node of a bin list itself as      * a lock. Blocking support for these locks relies on the builtin      * "synchronized" monitors.  However, we also need a tryLock      * construction, so we overlay these by using bits of the Node      * hash field for lock control (see above), and so normally use      * builtin monitors only for blocking and signalling using      * wait/notifyAll constructions. See Node.tryAwaitLock.      *      * Using the first node of a list as a lock does not by itself      * suffice though: When a node is locked, any update must first      * validate that it is still the first node after locking it, and      * retry if not. Because new nodes are always appended to lists,      * once a node is first in a bin, it remains first until deleted      * or the bin becomes invalidated (upon resizing).  However,      * operations that only conditionally update may inspect nodes      * until the point of update. This is a converse of sorts to the      * lazy locking technique described by Herlihy& Shavit.      *      * The main disadvantage of per-bin locks is that other update      * operations on other nodes in a bin list protected by the same      * lock can stall, for example when user equals() or mapping      * functions take a long time.  However, statistically, under      * random hash codes, this is not a common problem.  Ideally, the      * frequency of nodes in bins follows a Poisson distribution      * (http://en.wikipedia.org/wiki/Poisson_distribution) with a      * parameter of about 0.5 on average, given the resizing threshold      * of 0.75, although with a large variance because of resizing      * granularity. Ignoring variance, the expected occurrences of      * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The      * first values are:      *      * 0:    0.60653066      * 1:    0.30326533      * 2:    0.07581633      * 3:    0.01263606      * 4:    0.00157952      * 5:    0.00015795      * 6:    0.00001316      * 7:    0.00000094      * 8:    0.00000006      * more: less than 1 in ten million      *      * Lock contention probability for two threads accessing distinct      * elements is roughly 1 / (8 * #elements) under random hashes.      *      * Actual hash code distributions encountered in practice      * sometimes deviate significantly from uniform randomness.  This      * includes the case when N> (1<<30), so some keys MUST collide.      * Similarly for dumb or hostile usages in which multiple keys are      * designed to have identical hash codes. Also, although we guard      * against the worst effects of this (see method spread), sets of      * hashes may differ only in bits that do not impact their bin      * index for a given power-of-two mask.  So we use a secondary      * strategy that applies when the number of nodes in a bin exceeds      * a threshold, and at least one of the keys implements      * Comparable.  These TreeBins use a balanced tree to hold nodes      * (a specialized form of red-black trees), bounding search time      * to O(log N).  Each search step in a TreeBin is around twice as      * slow as in a regular list, but given that N cannot exceed      * (1<<64) (before running out of addresses) this bounds search      * steps, lock hold times, etc, to reasonable constants (roughly      * 100 nodes inspected per operation worst case) so long as keys      * are Comparable (which is very common -- String, Long, etc).      * TreeBin nodes (TreeNodes) also maintain the same "next"      * traversal pointers as regular nodes, so can be traversed in      * iterators in the same way.      *      * The table is resized when occupancy exceeds a percentage      * threshold (nominally, 0.75, but see below).  Only a single      * thread performs the resize (using field "sizeCtl", to arrange      * exclusion), but the table otherwise remains usable for reads      * and updates. Resizing proceeds by transferring bins, one by      * one, from the table to the next table.  Because we are using      * power-of-two expansion, the elements from each bin must either      * stay at same index, or move with a power of two offset. We      * eliminate unnecessary node creation by catching cases where old      * nodes can be reused because their next fields won't change.  On      * average, only about one-sixth of them need cloning when a table      * doubles. The nodes they replace will be garbage collectable as      * soon as they are no longer referenced by any reader thread that      * may be in the midst of concurrently traversing table.  Upon      * transfer, the old table bin contains only a special forwarding      * node (with hash field "MOVED") that contains the next table as      * its key. On encountering a forwarding node, access and update      * operations restart, using the new table.      *      * Each bin transfer requires its bin lock. However, unlike other      * cases, a transfer can skip a bin if it fails to acquire its      * lock, and revisit it later (unless it is a TreeBin). Method      * rebuild maintains a buffer of TRANSFER_BUFFER_SIZE bins that      * have been skipped because of failure to acquire a lock, and      * blocks only if none are available (i.e., only very rarely).      * The transfer operation must also ensure that all accessible      * bins in both the old and new table are usable by any traversal.      * When there are no lock acquisition failures, this is arranged      * simply by proceeding from the last bin (table.length - 1) up      * towards the first.  Upon seeing a forwarding node, traversals      * (see class InternalIterator) arrange to move to the new table      * without revisiting nodes.  However, when any node is skipped      * during a transfer, all earlier table bins may have become      * visible, so are initialized with a reverse-forwarding node back      * to the old table until the new ones are established. (This      * sometimes requires transiently locking a forwarding node, which      * is possible under the above encoding.) These more expensive      * mechanics trigger only when necessary.      *      * The traversal scheme also applies to partial traversals of      * ranges of bins (via an alternate InternalIterator constructor)      * to support partitioned aggregate operations (that are not      * otherwise implemented yet).  Also, read-only operations give up      * if ever forwarded to a null table, which provides support for      * shutdown-style clearing, which is also not currently      * implemented.      *      * Lazy table initialization minimizes footprint until first use,      * and also avoids resizings when the first operation is from a      * putAll, constructor with map argument, or deserialization.      * These cases attempt to override the initial capacity settings,      * but harmlessly fail to take effect in cases of races.      *      * The element count is maintained using a LongAdder, which avoids      * contention on updates but can encounter cache thrashing if read      * too frequently during concurrent access. To avoid reading so      * often, resizing is attempted either when a bin lock is      * contended, or upon adding to a bin already holding two or more      * nodes (checked before adding in the xIfAbsent methods, after      * adding in others). Under uniform hash distributions, the      * probability of this occurring at threshold is around 13%,      * meaning that only about 1 in 8 puts check threshold (and after      * resizing, many fewer do so). But this approximation has high      * variance for small table sizes, so we check on any collision      * for sizes<= 64. The bulk putAll operation further reduces      * contention by only committing count updates upon these size      * checks.      *      * Maintaining API and serialization compatibility with previous      * versions of this class introduces several oddities. Mainly: We      * leave untouched but unused constructor arguments refering to      * concurrencyLevel. We accept a loadFactor constructor argument,      * but apply it only to initial table capacity (which is the only      * time that we can guarantee to honor it.) We also declare an      * unused "Segment" class that is instantiated in minimal form      * only when serializing.      */
comment|/* ---------------- Constants -------------- */
comment|/**      * The largest possible table capacity.  This value must be      * exactly 1<<30 to stay within Java array allocation and indexing      * bounds for power of two table sizes, and is further required      * because the top two bits of 32bit hash fields are used for      * control purposes.      */
DECL|field|MAXIMUM_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/**      * The default initial table capacity.  Must be a power of 2      * (i.e., at least 1) and at most MAXIMUM_CAPACITY.      */
DECL|field|DEFAULT_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CAPACITY
init|=
literal|16
decl_stmt|;
comment|/**      * The largest possible (non-power of two) array size.      * Needed by toArray and related methods.      */
DECL|field|MAX_ARRAY_SIZE
specifier|static
specifier|final
name|int
name|MAX_ARRAY_SIZE
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|8
decl_stmt|;
comment|/**      * The default concurrency level for this table. Unused but      * defined for compatibility with previous versions of this class.      */
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
comment|/**      * The load factor for this table. Overrides of this value in      * constructors affect only the initial table capacity.  The      * actual floating point value isn't normally used -- it is      * simpler to use expressions such as {@code n - (n>>> 2)} for      * the associated resizing threshold.      */
DECL|field|LOAD_FACTOR
specifier|private
specifier|static
specifier|final
name|float
name|LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
comment|/**      * The buffer size for skipped bins during transfers. The      * value is arbitrary but should be large enough to avoid      * most locking stalls during resizes.      */
DECL|field|TRANSFER_BUFFER_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|TRANSFER_BUFFER_SIZE
init|=
literal|32
decl_stmt|;
comment|/**      * The bin count threshold for using a tree rather than list for a      * bin.  The value reflects the approximate break-even point for      * using tree-based operations.      */
DECL|field|TREE_THRESHOLD
specifier|private
specifier|static
specifier|final
name|int
name|TREE_THRESHOLD
init|=
literal|8
decl_stmt|;
comment|/*      * Encodings for special uses of Node hash fields. See above for      * explanation.      */
DECL|field|MOVED
specifier|static
specifier|final
name|int
name|MOVED
init|=
literal|0x80000000
decl_stmt|;
comment|// hash field for forwarding nodes
DECL|field|LOCKED
specifier|static
specifier|final
name|int
name|LOCKED
init|=
literal|0x40000000
decl_stmt|;
comment|// set/tested only as a bit
DECL|field|WAITING
specifier|static
specifier|final
name|int
name|WAITING
init|=
literal|0xc0000000
decl_stmt|;
comment|// both bits set/tested together
DECL|field|HASH_BITS
specifier|static
specifier|final
name|int
name|HASH_BITS
init|=
literal|0x3fffffff
decl_stmt|;
comment|// usable bits of normal node hash
comment|/* ---------------- Fields -------------- */
comment|/**      * The array of bins. Lazily initialized upon first insertion.      * Size is always a power of two. Accessed directly by iterators.      */
DECL|field|table
specifier|transient
specifier|volatile
name|Node
index|[]
name|table
decl_stmt|;
comment|/**      * The counter maintaining number of elements.      */
DECL|field|counter
specifier|private
specifier|transient
specifier|final
name|LongAdder
name|counter
decl_stmt|;
comment|/**      * Table initialization and resizing control.  When negative, the      * table is being initialized or resized. Otherwise, when table is      * null, holds the initial table size to use upon creation, or 0      * for default. After initialization, holds the next element count      * value upon which to resize the table.      */
DECL|field|sizeCtl
specifier|private
specifier|transient
specifier|volatile
name|int
name|sizeCtl
decl_stmt|;
comment|// views
DECL|field|keySet
specifier|private
specifier|transient
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keySet
decl_stmt|;
DECL|field|values
specifier|private
specifier|transient
name|Values
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|values
decl_stmt|;
DECL|field|entrySet
specifier|private
specifier|transient
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entrySet
decl_stmt|;
comment|/** For serialization compatibility. Null unless serialized; see below */
DECL|field|segments
specifier|private
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
comment|/* ---------------- Table element access -------------- */
comment|/*      * Volatile access methods are used for table elements as well as      * elements of in-progress next table while resizing.  Uses are      * null checked by callers, and implicitly bounds-checked, relying      * on the invariants that tab arrays have non-zero size, and all      * indices are masked with (tab.length - 1) which is never      * negative and always less than length. Note that, to be correct      * wrt arbitrary concurrency errors by users, bounds checks must      * operate on local variables, which accounts for some odd-looking      * inline assignments below.      */
DECL|method|tabAt
specifier|static
specifier|final
name|Node
name|tabAt
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|)
block|{
comment|// used by InternalIterator
return|return
operator|(
name|Node
operator|)
name|UNSAFE
operator|.
name|getObjectVolatile
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|)
return|;
block|}
DECL|method|casTabAt
specifier|private
specifier|static
specifier|final
name|boolean
name|casTabAt
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|,
name|Node
name|c
parameter_list|,
name|Node
name|v
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|c
argument_list|,
name|v
argument_list|)
return|;
block|}
DECL|method|setTabAt
specifier|private
specifier|static
specifier|final
name|void
name|setTabAt
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|,
name|Node
name|v
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObjectVolatile
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* ---------------- Nodes -------------- */
comment|/**      * Key-value entry. Note that this is never exported out as a      * user-visible Map.Entry (see WriteThroughEntry and SnapshotEntry      * below). Nodes with a hash field of MOVED are special, and do      * not contain user keys or values.  Otherwise, keys are never      * null, and null val fields indicate that a node is in the      * process of being deleted or created. For purposes of read-only      * access, a key may be read before a val, but can only be used      * after checking val to be non-null.      */
DECL|class|Node
specifier|static
class|class
name|Node
block|{
DECL|field|hash
specifier|volatile
name|int
name|hash
decl_stmt|;
DECL|field|key
specifier|final
name|Object
name|key
decl_stmt|;
DECL|field|val
specifier|volatile
name|Object
name|val
decl_stmt|;
DECL|field|next
specifier|volatile
name|Node
name|next
decl_stmt|;
DECL|method|Node
name|Node
parameter_list|(
name|int
name|hash
parameter_list|,
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|,
name|Node
name|next
parameter_list|)
block|{
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
comment|/** CompareAndSet the hash field */
DECL|method|casHash
specifier|final
name|boolean
name|casHash
parameter_list|(
name|int
name|cmp
parameter_list|,
name|int
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|hashOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/** The number of spins before blocking for a lock */
DECL|field|MAX_SPINS
specifier|static
specifier|final
name|int
name|MAX_SPINS
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|>
literal|1
condition|?
literal|64
else|:
literal|1
decl_stmt|;
comment|/**          * Spins a while if LOCKED bit set and this node is the first          * of its bin, and then sets WAITING bits on hash field and          * blocks (once) if they are still set.  It is OK for this          * method to return even if lock is not available upon exit,          * which enables these simple single-wait mechanics.          *          * The corresponding signalling operation is performed within          * callers: Upon detecting that WAITING has been set when          * unlocking lock (via a failed CAS from non-waiting LOCKED          * state), unlockers acquire the sync lock and perform a          * notifyAll.          */
DECL|method|tryAwaitLock
specifier|final
name|void
name|tryAwaitLock
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|tab
operator|!=
literal|null
operator|&&
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|tab
operator|.
name|length
condition|)
block|{
comment|// bounds check
name|int
name|r
init|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
decl_stmt|;
comment|// randomize spins
name|int
name|spins
init|=
name|MAX_SPINS
decl_stmt|,
name|h
decl_stmt|;
while|while
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|this
operator|&&
operator|(
operator|(
name|h
operator|=
name|hash
operator|)
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spins
operator|>=
literal|0
condition|)
block|{
name|r
operator|^=
name|r
operator|<<
literal|1
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|3
expr_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|10
expr_stmt|;
comment|// xorshift
if|if
condition|(
name|r
operator|>=
literal|0
operator|&&
operator|--
name|spins
operator|==
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// yield before block
block|}
elseif|else
if|if
condition|(
name|casHash
argument_list|(
name|h
argument_list|,
name|h
operator||
name|WAITING
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|this
operator|&&
operator|(
name|hash
operator|&
name|WAITING
operator|)
operator|==
name|WAITING
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|notifyAll
argument_list|()
expr_stmt|;
comment|// possibly won race vs signaller
block|}
break|break;
block|}
block|}
block|}
block|}
comment|// Unsafe mechanics for casHash
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|hashOffset
specifier|private
specifier|static
specifier|final
name|long
name|hashOffset
decl_stmt|;
static|static
block|{
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|Node
operator|.
name|class
decl_stmt|;
name|hashOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"hash"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/* ---------------- TreeBins -------------- */
comment|/**      * Nodes for use in TreeBins      */
DECL|class|TreeNode
specifier|static
specifier|final
class|class
name|TreeNode
extends|extends
name|Node
block|{
DECL|field|parent
name|TreeNode
name|parent
decl_stmt|;
comment|// red-black tree links
DECL|field|left
name|TreeNode
name|left
decl_stmt|;
DECL|field|right
name|TreeNode
name|right
decl_stmt|;
DECL|field|prev
name|TreeNode
name|prev
decl_stmt|;
comment|// needed to unlink next upon deletion
DECL|field|red
name|boolean
name|red
decl_stmt|;
DECL|method|TreeNode
name|TreeNode
parameter_list|(
name|int
name|hash
parameter_list|,
name|Object
name|key
parameter_list|,
name|Object
name|val
parameter_list|,
name|Node
name|next
parameter_list|,
name|TreeNode
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
block|}
comment|/**      * A specialized form of red-black tree for use in bins      * whose size exceeds a threshold.      *      * TreeBins use a special form of comparison for search and      * related operations (which is the main reason we cannot use      * existing collections such as TreeMaps). TreeBins contain      * Comparable elements, but may contain others, as well as      * elements that are Comparable but not necessarily Comparable<T>      * for the same T, so we cannot invoke compareTo among them. To      * handle this, the tree is ordered primarily by hash value, then      * by getClass().getName() order, and then by Comparator order      * among elements of the same class.  On lookup at a node, if      * non-Comparable, both left and right children may need to be      * searched in the case of tied hash values. (This corresponds to      * the full list search that would be necessary if all elements      * were non-Comparable and had tied hashes.)      *      * TreeBins also maintain a separate locking discipline than      * regular bins. Because they are forwarded via special MOVED      * nodes at bin heads (which can never change once established),      * we cannot use use those nodes as locks. Instead, TreeBin      * extends AbstractQueuedSynchronizer to support a simple form of      * read-write lock. For update operations and table validation,      * the exclusive form of lock behaves in the same way as bin-head      * locks. However, lookups use shared read-lock mechanics to allow      * multiple readers in the absence of writers.  Additionally,      * these lookups do not ever block: While the lock is not      * available, they proceed along the slow traversal path (via      * next-pointers) until the lock becomes available or the list is      * exhausted, whichever comes first. (These cases are not fast,      * but maximize aggregate expected throughput.)  The AQS mechanics      * for doing this are straightforward.  The lock state is held as      * AQS getState().  Read counts are negative; the write count (1)      * is positive.  There are no signalling preferences among readers      * and writers. Since we don't need to export full Lock API, we      * just override the minimal AQS methods and use them directly.      */
DECL|class|TreeBin
specifier|static
specifier|final
class|class
name|TreeBin
extends|extends
name|AbstractQueuedSynchronizer
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2249069246763182397L
decl_stmt|;
DECL|field|root
name|TreeNode
name|root
decl_stmt|;
comment|// root of tree
DECL|field|first
name|TreeNode
name|first
decl_stmt|;
comment|// head of next-pointer list
comment|/* AQS overrides */
DECL|method|isHeldExclusively
specifier|public
specifier|final
name|boolean
name|isHeldExclusively
parameter_list|()
block|{
return|return
name|getState
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|method|tryAcquire
specifier|public
specifier|final
name|boolean
name|tryAcquire
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
if|if
condition|(
name|compareAndSetState
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|setExclusiveOwnerThread
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|tryRelease
specifier|public
specifier|final
name|boolean
name|tryRelease
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|setExclusiveOwnerThread
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setState
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|tryAcquireShared
specifier|public
specifier|final
name|int
name|tryAcquireShared
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getState
argument_list|()
operator|)
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|compareAndSetState
argument_list|(
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
DECL|method|tryReleaseShared
specifier|public
specifier|final
name|boolean
name|tryReleaseShared
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|compareAndSetState
argument_list|(
name|c
operator|=
name|getState
argument_list|()
argument_list|,
name|c
operator|+
literal|1
argument_list|)
condition|)
do|;
return|return
name|c
operator|==
operator|-
literal|1
return|;
block|}
comment|/**          * Return the TreeNode (or null if not found) for the given key          * starting at given root.          */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// suppress Comparable cast warning
DECL|method|getTreeNode
specifier|final
name|TreeNode
name|getTreeNode
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|,
name|TreeNode
name|p
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|k
operator|.
name|getClass
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|int
name|dir
decl_stmt|,
name|ph
decl_stmt|;
name|Object
name|pk
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|pc
decl_stmt|;
name|TreeNode
name|r
decl_stmt|;
if|if
condition|(
name|h
operator|<
operator|(
name|ph
operator|=
name|p
operator|.
name|hash
operator|)
condition|)
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|>
name|ph
condition|)
name|dir
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pk
operator|=
name|p
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|pk
argument_list|)
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|c
operator|!=
operator|(
name|pc
operator|=
name|pk
operator|.
name|getClass
argument_list|()
operator|)
condition|)
name|dir
operator|=
name|c
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|pc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|instanceof
name|Comparable
condition|)
name|dir
operator|=
operator|(
operator|(
name|Comparable
operator|)
name|k
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Comparable
operator|)
name|pk
argument_list|)
expr_stmt|;
else|else
name|dir
operator|=
literal|0
expr_stmt|;
name|TreeNode
name|pr
init|=
name|p
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
name|p
operator|=
name|pr
expr_stmt|;
elseif|else
if|if
condition|(
name|dir
operator|==
literal|0
operator|&&
name|pr
operator|!=
literal|null
operator|&&
name|h
operator|>=
name|pr
operator|.
name|hash
operator|&&
operator|(
name|r
operator|=
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|pr
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|r
return|;
else|else
name|p
operator|=
name|p
operator|.
name|left
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Wrapper for getTreeNode used by CHM.get. Tries to obtain          * read-lock to call getTreeNode, but during failure to get          * lock, searches along next links.          */
DECL|method|getValue
specifier|final
name|Object
name|getValue
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|)
block|{
name|Node
name|r
init|=
literal|null
decl_stmt|;
name|int
name|c
init|=
name|getState
argument_list|()
decl_stmt|;
comment|// Must read lock state first
for|for
control|(
name|Node
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
name|c
operator|<=
literal|0
operator|&&
name|compareAndSetState
argument_list|(
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
name|r
operator|=
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|releaseShared
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|e
operator|.
name|key
argument_list|)
condition|)
block|{
name|r
operator|=
name|e
expr_stmt|;
break|break;
block|}
else|else
name|c
operator|=
name|getState
argument_list|()
expr_stmt|;
block|}
return|return
name|r
operator|==
literal|null
condition|?
literal|null
else|:
name|r
operator|.
name|val
return|;
block|}
comment|/**          * Find or add a node          * @return null if added          */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
comment|// suppress Comparable cast warning
DECL|method|putTreeNode
specifier|final
name|TreeNode
name|putTreeNode
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|,
name|Object
name|v
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|k
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|TreeNode
name|p
init|=
name|root
decl_stmt|;
name|int
name|dir
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ph
decl_stmt|;
name|Object
name|pk
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|pc
decl_stmt|;
name|TreeNode
name|r
decl_stmt|;
if|if
condition|(
name|h
operator|<
operator|(
name|ph
operator|=
name|p
operator|.
name|hash
operator|)
condition|)
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|>
name|ph
condition|)
name|dir
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pk
operator|=
name|p
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|pk
argument_list|)
condition|)
return|return
name|p
return|;
elseif|else
if|if
condition|(
name|c
operator|!=
operator|(
name|pc
operator|=
operator|(
name|pk
operator|=
name|p
operator|.
name|key
operator|)
operator|.
name|getClass
argument_list|()
operator|)
condition|)
name|dir
operator|=
name|c
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|pc
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|instanceof
name|Comparable
condition|)
name|dir
operator|=
operator|(
operator|(
name|Comparable
operator|)
name|k
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Comparable
operator|)
name|pk
argument_list|)
expr_stmt|;
else|else
name|dir
operator|=
literal|0
expr_stmt|;
name|TreeNode
name|pr
init|=
name|p
operator|.
name|right
decl_stmt|,
name|pl
decl_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pr
operator|==
literal|null
condition|)
break|break;
name|p
operator|=
name|pr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|==
literal|0
operator|&&
name|pr
operator|!=
literal|null
operator|&&
name|h
operator|>=
name|pr
operator|.
name|hash
operator|&&
operator|(
name|r
operator|=
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|pr
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|r
return|;
elseif|else
if|if
condition|(
operator|(
name|pl
operator|=
name|p
operator|.
name|left
operator|)
operator|==
literal|null
condition|)
break|break;
else|else
name|p
operator|=
name|pl
expr_stmt|;
block|}
block|}
name|TreeNode
name|f
init|=
name|first
decl_stmt|;
name|TreeNode
name|r
init|=
name|first
operator|=
operator|new
name|TreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
name|f
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|root
operator|=
name|r
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dir
operator|<=
literal|0
condition|)
name|p
operator|.
name|left
operator|=
name|r
expr_stmt|;
else|else
name|p
operator|.
name|right
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
name|f
operator|.
name|prev
operator|=
name|r
expr_stmt|;
name|fixAfterInsertion
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Removes the given node, that must be present before this          * call.  This is messier than typical red-black deletion code          * because we cannot swap the contents of an interior node          * with a leaf successor that is pinned by "next" pointers          * that are accessible independently of lock. So instead we          * swap the tree linkages.          */
DECL|method|deleteTreeNode
specifier|final
name|void
name|deleteTreeNode
parameter_list|(
name|TreeNode
name|p
parameter_list|)
block|{
name|TreeNode
name|next
init|=
operator|(
name|TreeNode
operator|)
name|p
operator|.
name|next
decl_stmt|;
comment|// unlink traversal pointers
name|TreeNode
name|pred
init|=
name|p
operator|.
name|prev
decl_stmt|;
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
name|first
operator|=
name|next
expr_stmt|;
else|else
name|pred
operator|.
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
name|next
operator|.
name|prev
operator|=
name|pred
expr_stmt|;
name|TreeNode
name|replacement
decl_stmt|;
name|TreeNode
name|pl
init|=
name|p
operator|.
name|left
decl_stmt|;
name|TreeNode
name|pr
init|=
name|p
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|pl
operator|!=
literal|null
operator|&&
name|pr
operator|!=
literal|null
condition|)
block|{
name|TreeNode
name|s
init|=
name|pr
decl_stmt|;
while|while
condition|(
name|s
operator|.
name|left
operator|!=
literal|null
condition|)
comment|// find successor
name|s
operator|=
name|s
operator|.
name|left
expr_stmt|;
name|boolean
name|c
init|=
name|s
operator|.
name|red
decl_stmt|;
name|s
operator|.
name|red
operator|=
name|p
operator|.
name|red
expr_stmt|;
name|p
operator|.
name|red
operator|=
name|c
expr_stmt|;
comment|// swap colors
name|TreeNode
name|sr
init|=
name|s
operator|.
name|right
decl_stmt|;
name|TreeNode
name|pp
init|=
name|p
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|pr
condition|)
block|{
comment|// p was s's direct parent
name|p
operator|.
name|parent
operator|=
name|s
expr_stmt|;
name|s
operator|.
name|right
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|TreeNode
name|sp
init|=
name|s
operator|.
name|parent
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|parent
operator|=
name|sp
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|sp
operator|.
name|left
condition|)
name|sp
operator|.
name|left
operator|=
name|p
expr_stmt|;
else|else
name|sp
operator|.
name|right
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|.
name|right
operator|=
name|pr
operator|)
operator|!=
literal|null
condition|)
name|pr
operator|.
name|parent
operator|=
name|s
expr_stmt|;
block|}
name|p
operator|.
name|left
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|right
operator|=
name|sr
operator|)
operator|!=
literal|null
condition|)
name|sr
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|left
operator|=
name|pl
operator|)
operator|!=
literal|null
condition|)
name|pl
operator|.
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|parent
operator|=
name|pp
operator|)
operator|==
literal|null
condition|)
name|root
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
name|pp
operator|.
name|left
operator|=
name|s
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|s
expr_stmt|;
name|replacement
operator|=
name|sr
expr_stmt|;
block|}
else|else
name|replacement
operator|=
operator|(
name|pl
operator|!=
literal|null
operator|)
condition|?
name|pl
else|:
name|pr
expr_stmt|;
name|TreeNode
name|pp
init|=
name|p
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|replacement
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|pp
operator|==
literal|null
condition|)
block|{
name|root
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|replacement
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|replacement
operator|.
name|parent
operator|=
name|pp
expr_stmt|;
if|if
condition|(
name|pp
operator|==
literal|null
condition|)
name|root
operator|=
name|replacement
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
name|pp
operator|.
name|left
operator|=
name|replacement
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|replacement
expr_stmt|;
name|p
operator|.
name|left
operator|=
name|p
operator|.
name|right
operator|=
name|p
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|.
name|red
condition|)
name|fixAfterDeletion
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|replacement
operator|&&
operator|(
name|pp
operator|=
name|p
operator|.
name|parent
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
comment|// detach pointers
name|pp
operator|.
name|left
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|right
condition|)
name|pp
operator|.
name|right
operator|=
literal|null
expr_stmt|;
name|p
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|// CLR code updated from pre-jdk-collections version at
comment|// http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java
comment|/** From CLR */
DECL|method|rotateLeft
specifier|private
name|void
name|rotateLeft
parameter_list|(
name|TreeNode
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|TreeNode
name|r
init|=
name|p
operator|.
name|right
decl_stmt|,
name|pp
decl_stmt|,
name|rl
decl_stmt|;
if|if
condition|(
operator|(
name|rl
operator|=
name|p
operator|.
name|right
operator|=
name|r
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
name|rl
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|r
operator|.
name|parent
operator|=
name|p
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
name|root
operator|=
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|.
name|left
operator|==
name|p
condition|)
name|pp
operator|.
name|left
operator|=
name|r
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|r
expr_stmt|;
name|r
operator|.
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|parent
operator|=
name|r
expr_stmt|;
block|}
block|}
comment|/** From CLR */
DECL|method|rotateRight
specifier|private
name|void
name|rotateRight
parameter_list|(
name|TreeNode
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|TreeNode
name|l
init|=
name|p
operator|.
name|left
decl_stmt|,
name|pp
decl_stmt|,
name|lr
decl_stmt|;
if|if
condition|(
operator|(
name|lr
operator|=
name|p
operator|.
name|left
operator|=
name|l
operator|.
name|right
operator|)
operator|!=
literal|null
condition|)
name|lr
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|l
operator|.
name|parent
operator|=
name|p
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
name|root
operator|=
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|.
name|right
operator|==
name|p
condition|)
name|pp
operator|.
name|right
operator|=
name|l
expr_stmt|;
else|else
name|pp
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|l
operator|.
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|parent
operator|=
name|l
expr_stmt|;
block|}
block|}
comment|/** From CLR */
DECL|method|fixAfterInsertion
specifier|private
name|void
name|fixAfterInsertion
parameter_list|(
name|TreeNode
name|x
parameter_list|)
block|{
name|x
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|TreeNode
name|xp
decl_stmt|,
name|xpp
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|null
operator|&&
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|!=
literal|null
operator|&&
name|xp
operator|.
name|red
operator|&&
operator|(
name|xpp
operator|=
name|xp
operator|.
name|parent
operator|)
operator|!=
literal|null
condition|)
block|{
name|TreeNode
name|xppl
init|=
name|xpp
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|xp
operator|==
name|xppl
condition|)
block|{
name|TreeNode
name|y
init|=
name|xpp
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|null
operator|&&
name|y
operator|.
name|red
condition|)
block|{
name|y
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xpp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|xp
operator|.
name|right
condition|)
block|{
name|x
operator|=
name|xp
expr_stmt|;
name|rotateLeft
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|xpp
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|xpp
operator|!=
literal|null
condition|)
block|{
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateRight
argument_list|(
name|xpp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|TreeNode
name|y
init|=
name|xppl
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|null
operator|&&
name|y
operator|.
name|red
condition|)
block|{
name|y
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xpp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|xp
operator|.
name|left
condition|)
block|{
name|x
operator|=
name|xp
expr_stmt|;
name|rotateRight
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|xpp
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|xpp
operator|!=
literal|null
condition|)
block|{
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateLeft
argument_list|(
name|xpp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|TreeNode
name|r
init|=
name|root
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|r
operator|.
name|red
condition|)
name|r
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
comment|/** From CLR */
DECL|method|fixAfterDeletion
specifier|private
name|void
name|fixAfterDeletion
parameter_list|(
name|TreeNode
name|x
parameter_list|)
block|{
while|while
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
name|TreeNode
name|xp
decl_stmt|,
name|xpl
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|red
operator|||
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
block|{
name|x
operator|.
name|red
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|x
operator|==
operator|(
name|xpl
operator|=
name|xp
operator|.
name|left
operator|)
condition|)
block|{
name|TreeNode
name|sib
init|=
name|xp
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|sib
operator|!=
literal|null
operator|&&
name|sib
operator|.
name|red
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateLeft
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|==
literal|null
condition|)
name|x
operator|=
name|xp
expr_stmt|;
else|else
block|{
name|TreeNode
name|sl
init|=
name|sib
operator|.
name|left
decl_stmt|,
name|sr
init|=
name|sib
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
operator|)
operator|&&
operator|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
operator|)
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
condition|)
block|{
if|if
condition|(
name|sl
operator|!=
literal|null
condition|)
name|sl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateRight
argument_list|(
name|sib
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|!=
literal|null
condition|)
block|{
name|sib
operator|.
name|red
operator|=
operator|(
name|xp
operator|==
literal|null
operator|)
condition|?
literal|false
else|:
name|xp
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|sib
operator|.
name|right
operator|)
operator|!=
literal|null
condition|)
name|sr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|rotateLeft
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|root
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// symmetric
name|TreeNode
name|sib
init|=
name|xpl
decl_stmt|;
if|if
condition|(
name|sib
operator|!=
literal|null
operator|&&
name|sib
operator|.
name|red
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateRight
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|==
literal|null
condition|)
name|x
operator|=
name|xp
expr_stmt|;
else|else
block|{
name|TreeNode
name|sl
init|=
name|sib
operator|.
name|left
decl_stmt|,
name|sr
init|=
name|sib
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
operator|)
operator|&&
operator|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
operator|)
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
condition|)
block|{
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
name|sr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateLeft
argument_list|(
name|sib
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|!=
literal|null
condition|)
block|{
name|sib
operator|.
name|red
operator|=
operator|(
name|xp
operator|==
literal|null
operator|)
condition|?
literal|false
else|:
name|xp
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|(
name|sl
operator|=
name|sib
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
name|sl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|rotateRight
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|root
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* ---------------- Collision reduction methods -------------- */
comment|/**      * Spreads higher bits to lower, and also forces top 2 bits to 0.      * Because the table uses power-of-two masking, sets of hashes      * that vary only in bits above the current mask will always      * collide. (Among known examples are sets of Float keys holding      * consecutive whole numbers in small tables.)  To counter this,      * we apply a transform that spreads the impact of higher bits      * downward. There is a tradeoff between speed, utility, and      * quality of bit-spreading. Because many common sets of hashes      * are already reasonably distributed across bits (so don't benefit      * from spreading), and because we use trees to handle large sets      * of collisions in bins, we don't need excessively high quality.      */
DECL|method|spread
specifier|private
specifier|static
specifier|final
name|int
name|spread
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|18
operator|)
operator|^
operator|(
name|h
operator|>>>
literal|12
operator|)
expr_stmt|;
return|return
operator|(
name|h
operator|^
operator|(
name|h
operator|>>>
literal|10
operator|)
operator|)
operator|&
name|HASH_BITS
return|;
block|}
comment|/**      * Replaces a list bin with a tree bin. Call only when locked.      * Fails to replace if the given key is non-comparable or table      * is, or needs, resizing.      */
DECL|method|replaceWithTreeBin
specifier|private
specifier|final
name|void
name|replaceWithTreeBin
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|,
name|int
name|index
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
operator|(
name|key
operator|instanceof
name|Comparable
operator|)
operator|&&
operator|(
name|tab
operator|.
name|length
operator|>=
name|MAXIMUM_CAPACITY
operator|||
name|counter
operator|.
name|sum
argument_list|()
operator|<
operator|(
name|long
operator|)
name|sizeCtl
operator|)
condition|)
block|{
name|TreeBin
name|t
init|=
operator|new
name|TreeBin
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|index
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
name|t
operator|.
name|putTreeNode
argument_list|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
argument_list|,
name|e
operator|.
name|key
argument_list|,
name|e
operator|.
name|val
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|index
argument_list|,
operator|new
name|Node
argument_list|(
name|MOVED
argument_list|,
name|t
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ---------------- Internal access and update methods -------------- */
comment|/** Implementation for get and containsKey */
DECL|method|internalGet
specifier|private
specifier|final
name|Object
name|internalGet
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|retry
label|:
for|for
control|(
name|Node
index|[]
name|tab
init|=
name|table
init|;
name|tab
operator|!=
literal|null
condition|;
control|)
block|{
name|Node
name|e
decl_stmt|,
name|p
decl_stmt|;
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
name|int
name|eh
decl_stmt|;
comment|// locals to read fields once
for|for
control|(
name|e
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
operator|(
name|eh
operator|=
name|e
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
comment|// search TreeBin
return|return
operator|(
operator|(
name|TreeBin
operator|)
name|ek
operator|)
operator|.
name|getValue
argument_list|(
name|h
argument_list|,
name|k
argument_list|)
return|;
else|else
block|{
comment|// restart with new table
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|ek
expr_stmt|;
continue|continue
name|retry
continue|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|eh
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
return|return
name|ev
return|;
block|}
break|break;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Implementation for the four public remove/replace methods:      * Replaces node value with v, conditional upon match of cv if      * non-null.  If resulting value is null, delete.      */
DECL|method|internalReplace
specifier|private
specifier|final
name|Object
name|internalReplace
parameter_list|(
name|Object
name|k
parameter_list|,
name|Object
name|v
parameter_list|,
name|Object
name|cv
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|Object
name|oldVal
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
name|TreeNode
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|Object
name|pv
init|=
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
name|cv
operator|==
literal|null
operator|||
name|cv
operator|==
name|pv
operator|||
name|cv
operator|.
name|equals
argument_list|(
name|pv
argument_list|)
condition|)
block|{
name|oldVal
operator|=
name|pv
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|val
operator|=
name|v
operator|)
operator|==
literal|null
condition|)
block|{
name|deleted
operator|=
literal|true
expr_stmt|;
name|t
operator|.
name|deleteTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|validated
condition|)
block|{
if|if
condition|(
name|deleted
condition|)
name|counter
operator|.
name|add
argument_list|(
operator|-
literal|1L
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|HASH_BITS
operator|)
operator|!=
name|h
operator|&&
name|f
operator|.
name|next
operator|==
literal|null
condition|)
comment|// precheck
break|break;
comment|// rules out possible existence
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|checkForResize
argument_list|()
expr_stmt|;
comment|// try resizing if can't get lock
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cv
operator|==
literal|null
operator|||
name|cv
operator|==
name|ev
operator|||
name|cv
operator|.
name|equals
argument_list|(
name|ev
argument_list|)
condition|)
block|{
name|oldVal
operator|=
name|ev
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|val
operator|=
name|v
operator|)
operator|==
literal|null
condition|)
block|{
name|deleted
operator|=
literal|true
expr_stmt|;
name|Node
name|en
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|en
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
break|break;
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|validated
condition|)
block|{
if|if
condition|(
name|deleted
condition|)
name|counter
operator|.
name|add
argument_list|(
operator|-
literal|1L
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|oldVal
return|;
block|}
comment|/*      * Internal versions of the five insertion methods, each a      * little more complicated than the last. All have      * the same basic structure as the first (internalPut):      *  1. If table uninitialized, create      *  2. If bin empty, try to CAS new node      *  3. If bin stale, use new table      *  4. if bin converted to TreeBin, validate and relay to TreeBin methods      *  5. Lock and validate; if valid, scan and add or update      *      * The others interweave other checks and/or alternative actions:      *  * Plain put checks for and performs resize after insertion.      *  * putIfAbsent prescans for mapping without lock (and fails to add      *    if present), which also makes pre-emptive resize checks worthwhile.      *  * computeIfAbsent extends form used in putIfAbsent with additional      *    mechanics to deal with, calls, potential exceptions and null      *    returns from function call.      *  * compute uses the same function-call mechanics, but without      *    the prescans      *  * putAll attempts to pre-allocate enough table space      *    and more lazily performs count updates and checks.      *      * Someday when details settle down a bit more, it might be worth      * some factoring to reduce sprawl.      */
comment|/** Implementation for put */
DECL|method|internalPut
specifier|private
specifier|final
name|Object
name|internalPut
parameter_list|(
name|Object
name|k
parameter_list|,
name|Object
name|v
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|Node
name|f
decl_stmt|;
name|int
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
break|break;
comment|// no lock when adding to empty bin
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|Object
name|oldVal
init|=
literal|null
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|TreeNode
name|p
init|=
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|oldVal
operator|=
name|p
operator|.
name|val
expr_stmt|;
name|p
operator|.
name|val
operator|=
name|v
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
return|return
name|oldVal
return|;
break|break;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|checkForResize
argument_list|()
expr_stmt|;
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
name|Object
name|oldVal
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// needed in case equals() throws
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|f
init|;
condition|;
operator|++
name|count
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|oldVal
operator|=
name|ev
expr_stmt|;
name|e
operator|.
name|val
operator|=
name|v
expr_stmt|;
break|break;
block|}
name|Node
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
finally|finally
block|{
comment|// unlock and signal if needed
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
return|return
name|oldVal
return|;
if|if
condition|(
name|tab
operator|.
name|length
operator|<=
literal|64
condition|)
name|count
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
name|counter
operator|.
name|add
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|checkForResize
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/** Implementation for putIfAbsent */
DECL|method|internalPutIfAbsent
specifier|private
specifier|final
name|Object
name|internalPutIfAbsent
parameter_list|(
name|Object
name|k
parameter_list|,
name|Object
name|v
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|Node
name|f
decl_stmt|;
name|int
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|,
name|fv
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|Object
name|oldVal
init|=
literal|null
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|TreeNode
name|p
init|=
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|oldVal
operator|=
name|p
operator|.
name|val
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
return|return
name|oldVal
return|;
break|break;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|fv
operator|=
name|f
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|fk
argument_list|)
operator|)
condition|)
return|return
name|fv
return|;
else|else
block|{
name|Node
name|g
init|=
name|f
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|null
condition|)
block|{
comment|// at least 2 nodes -- search and maybe resize
for|for
control|(
name|Node
name|e
init|=
name|g
init|;
condition|;
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
return|return
name|ev
return|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|checkForResize
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|checkForResize
argument_list|()
expr_stmt|;
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
operator|&&
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
name|Object
name|oldVal
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|f
init|;
condition|;
operator|++
name|count
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|oldVal
operator|=
name|ev
expr_stmt|;
break|break;
block|}
name|Node
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
return|return
name|oldVal
return|;
if|if
condition|(
name|tab
operator|.
name|length
operator|<=
literal|64
condition|)
name|count
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|counter
operator|.
name|add
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|checkForResize
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/** Implementation for computeIfAbsent */
DECL|method|internalComputeIfAbsent
specifier|private
specifier|final
name|Object
name|internalComputeIfAbsent
parameter_list|(
name|K
name|k
parameter_list|,
name|MappingFunction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
argument_list|>
name|mf
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
literal|null
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|,
name|fv
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|Node
name|node
init|=
operator|new
name|Node
argument_list|(
name|fh
operator|=
name|h
operator||
name|LOCKED
argument_list|,
name|k
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|map
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|node
operator|.
name|val
operator|=
name|val
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|node
operator|.
name|hash
operator|=
name|h
expr_stmt|;
synchronized|synchronized
init|(
name|node
init|)
block|{
name|node
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|TreeNode
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|val
operator|=
name|p
operator|.
name|val
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|map
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|added
operator|=
literal|true
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|added
condition|)
return|return
name|val
return|;
break|break;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|fv
operator|=
name|f
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|fk
argument_list|)
operator|)
condition|)
return|return
name|fv
return|;
else|else
block|{
name|Node
name|g
init|=
name|f
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|g
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Node
name|e
init|=
name|g
init|;
condition|;
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
return|return
name|ev
return|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|checkForResize
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|checkForResize
argument_list|()
expr_stmt|;
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
operator|&&
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|f
init|;
condition|;
operator|++
name|count
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|ev
expr_stmt|;
break|break;
block|}
name|Node
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|map
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|added
operator|=
literal|true
expr_stmt|;
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|added
condition|)
return|return
name|val
return|;
if|if
condition|(
name|tab
operator|.
name|length
operator|<=
literal|64
condition|)
name|count
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|counter
operator|.
name|add
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|checkForResize
argument_list|()
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/** Implementation for compute */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|internalCompute
specifier|private
specifier|final
name|Object
name|internalCompute
parameter_list|(
name|K
name|k
parameter_list|,
name|RemappingFunction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|mf
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|Object
name|val
init|=
literal|null
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|Node
name|node
init|=
operator|new
name|Node
argument_list|(
name|fh
operator|=
name|h
operator||
name|LOCKED
argument_list|,
name|k
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|node
argument_list|)
condition|)
block|{
try|try
block|{
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|remap
argument_list|(
name|k
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|added
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|node
operator|.
name|hash
operator|=
name|h
expr_stmt|;
synchronized|synchronized
init|(
name|node
init|)
block|{
name|node
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|TreeNode
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
name|Object
name|pv
init|=
operator|(
name|p
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|remap
argument_list|(
name|k
argument_list|,
operator|(
name|V
operator|)
name|pv
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|count
operator|=
literal|2
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|checkForResize
argument_list|()
expr_stmt|;
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|f
init|;
condition|;
operator|++
name|count
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|mf
operator|.
name|remap
argument_list|(
name|k
argument_list|,
operator|(
name|V
operator|)
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|e
operator|.
name|val
operator|=
name|val
expr_stmt|;
break|break;
block|}
name|Node
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|remap
argument_list|(
name|k
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|added
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tab
operator|.
name|length
operator|<=
literal|64
condition|)
name|count
operator|=
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|val
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|added
condition|)
block|{
name|counter
operator|.
name|add
argument_list|(
literal|1L
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|checkForResize
argument_list|()
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
comment|/** Implementation for putAll */
DECL|method|internalPutAll
specifier|private
specifier|final
name|void
name|internalPutAll
parameter_list|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|m
parameter_list|)
block|{
name|tryPresize
argument_list|(
name|m
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|delta
init|=
literal|0L
decl_stmt|;
comment|// number of uncommitted additions
name|boolean
name|npe
init|=
literal|false
decl_stmt|;
comment|// to throw exception on exit for nulls
try|try
block|{
comment|// to clean up counts on other exceptions
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|entry
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
operator|||
operator|(
name|k
operator|=
name|entry
operator|.
name|getKey
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|v
operator|=
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|Node
name|f
decl_stmt|;
name|int
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|delta
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
name|TreeNode
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|v
expr_stmt|;
else|else
block|{
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
operator|++
name|delta
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|validated
condition|)
break|break;
block|}
else|else
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|counter
operator|.
name|add
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|0L
expr_stmt|;
name|checkForResize
argument_list|()
expr_stmt|;
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|f
init|;
condition|;
operator|++
name|count
control|)
block|{
name|Object
name|ek
decl_stmt|,
name|ev
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
operator|)
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|e
operator|.
name|val
operator|=
name|v
expr_stmt|;
break|break;
block|}
name|Node
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
operator|++
name|delta
expr_stmt|;
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|counter
operator|.
name|add
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|0L
expr_stmt|;
name|checkForResize
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
name|counter
operator|.
name|add
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
comment|/* ---------------- Table Initialization and Resizing -------------- */
comment|/**      * Returns a power of two table size for the given desired capacity.      * See Hackers Delight, sec 3.2      */
DECL|method|tableSizeFor
specifier|private
specifier|static
specifier|final
name|int
name|tableSizeFor
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|int
name|n
init|=
name|c
operator|-
literal|1
decl_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|1
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|2
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|4
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|8
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|16
expr_stmt|;
return|return
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
literal|1
else|:
operator|(
name|n
operator|>=
name|MAXIMUM_CAPACITY
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|n
operator|+
literal|1
return|;
block|}
comment|/**      * Initializes table, using the size recorded in sizeCtl.      */
DECL|method|initTable
specifier|private
specifier|final
name|Node
index|[]
name|initTable
parameter_list|()
block|{
name|Node
index|[]
name|tab
decl_stmt|;
name|int
name|sc
decl_stmt|;
while|while
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|<
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// lost initialization race; just spin
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|sizeCtlOffset
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|==
literal|null
condition|)
block|{
name|int
name|n
init|=
operator|(
name|sc
operator|>
literal|0
operator|)
condition|?
name|sc
else|:
name|DEFAULT_CAPACITY
decl_stmt|;
name|tab
operator|=
name|table
operator|=
operator|new
name|Node
index|[
name|n
index|]
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|tab
return|;
block|}
comment|/**      * If table is too small and not already resizing, creates next      * table and transfers bins.  Rechecks occupancy after a transfer      * to see if another resize is already needed because resizings      * are lagging additions.      */
DECL|method|checkForResize
specifier|private
specifier|final
name|void
name|checkForResize
parameter_list|()
block|{
name|Node
index|[]
name|tab
decl_stmt|;
name|int
name|n
decl_stmt|,
name|sc
decl_stmt|;
while|while
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|<
name|MAXIMUM_CAPACITY
operator|&&
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|>=
literal|0
operator|&&
name|counter
operator|.
name|sum
argument_list|()
operator|>=
operator|(
name|long
operator|)
name|sc
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|sizeCtlOffset
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|tab
operator|==
name|table
condition|)
block|{
name|table
operator|=
name|rebuild
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
name|n
operator|<<
literal|1
operator|)
operator|-
operator|(
name|n
operator|>>>
literal|1
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Tries to presize table to accommodate the given number of elements.      *      * @param size number of elements (doesn't need to be perfectly accurate)      */
DECL|method|tryPresize
specifier|private
specifier|final
name|void
name|tryPresize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|c
init|=
operator|(
name|size
operator|>=
operator|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
operator|)
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
name|size
operator|+
operator|(
name|size
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|sc
decl_stmt|;
while|while
condition|(
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|>=
literal|0
condition|)
block|{
name|Node
index|[]
name|tab
init|=
name|table
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|(
name|sc
operator|>
name|c
operator|)
condition|?
name|sc
else|:
name|c
expr_stmt|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|sizeCtlOffset
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|table
operator|==
name|tab
condition|)
block|{
name|table
operator|=
operator|new
name|Node
index|[
name|n
index|]
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
name|sc
operator|||
name|n
operator|>=
name|MAXIMUM_CAPACITY
condition|)
break|break;
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|sizeCtlOffset
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|table
operator|==
name|tab
condition|)
block|{
name|table
operator|=
name|rebuild
argument_list|(
name|tab
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
name|n
operator|<<
literal|1
operator|)
operator|-
operator|(
name|n
operator|>>>
literal|1
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*      * Moves and/or copies the nodes in each bin to new table. See      * above for explanation.      *      * @return the new table      */
DECL|method|rebuild
specifier|private
specifier|static
specifier|final
name|Node
index|[]
name|rebuild
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|)
block|{
name|int
name|n
init|=
name|tab
operator|.
name|length
decl_stmt|;
name|Node
index|[]
name|nextTab
init|=
operator|new
name|Node
index|[
name|n
operator|<<
literal|1
index|]
decl_stmt|;
name|Node
name|fwd
init|=
operator|new
name|Node
argument_list|(
name|MOVED
argument_list|,
name|nextTab
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|int
index|[]
name|buffer
init|=
literal|null
decl_stmt|;
comment|// holds bins to revisit; null until needed
name|Node
name|rev
init|=
literal|null
decl_stmt|;
comment|// reverse forwarder; null until needed
name|int
name|nbuffered
init|=
literal|0
decl_stmt|;
comment|// the number of bins in buffer list
name|int
name|bufferIndex
init|=
literal|0
decl_stmt|;
comment|// buffer index of current buffered bin
name|int
name|bin
init|=
name|n
operator|-
literal|1
decl_stmt|;
comment|// current non-buffered bin or -1 if none
for|for
control|(
name|int
name|i
init|=
name|bin
init|;
condition|;
control|)
block|{
comment|// start upwards sweep
name|int
name|fh
decl_stmt|;
name|Node
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|bin
operator|>=
literal|0
condition|)
block|{
comment|// no lock needed (or available)
if|if
condition|(
operator|!
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|fwd
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
comment|// transiently use a locked forwarding node
name|Node
name|g
init|=
operator|new
name|Node
argument_list|(
name|MOVED
operator||
name|LOCKED
argument_list|,
name|nextTab
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
condition|)
continue|continue;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|n
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g
operator|.
name|casHash
argument_list|(
name|MOVED
operator||
name|LOCKED
argument_list|,
name|MOVED
argument_list|)
condition|)
block|{
name|g
operator|.
name|hash
operator|=
name|MOVED
expr_stmt|;
synchronized|synchronized
init|(
name|g
init|)
block|{
name|g
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
name|Object
name|fk
init|=
name|f
operator|.
name|key
decl_stmt|;
if|if
condition|(
name|fk
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
name|splitTreeBin
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|validated
condition|)
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|LOCKED
operator|)
operator|==
literal|0
operator|&&
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// split to lo and hi lists; copying as needed
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
name|splitBin
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|validated
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|buffer
operator|==
literal|null
condition|)
comment|// initialize buffer for revisits
name|buffer
operator|=
operator|new
name|int
index|[
name|TRANSFER_BUFFER_SIZE
index|]
expr_stmt|;
if|if
condition|(
name|bin
argument_list|<
literal|0
operator|&&
name|bufferIndex
argument_list|>
literal|0
condition|)
block|{
name|int
name|j
init|=
name|buffer
index|[
operator|--
name|bufferIndex
index|]
decl_stmt|;
name|buffer
index|[
name|bufferIndex
index|]
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
comment|// swap with another bin
continue|continue;
block|}
if|if
condition|(
name|bin
operator|<
literal|0
operator|||
name|nbuffered
operator|>=
name|TRANSFER_BUFFER_SIZE
condition|)
block|{
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
comment|// no other options -- block
block|}
if|if
condition|(
name|rev
operator|==
literal|null
condition|)
comment|// initialize reverse-forwarder
name|rev
operator|=
operator|new
name|Node
argument_list|(
name|MOVED
argument_list|,
name|tab
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|!=
name|f
operator|||
operator|(
name|f
operator|.
name|hash
operator|&
name|LOCKED
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|// recheck before adding to list
name|buffer
index|[
name|nbuffered
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|// install place-holders
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|n
argument_list|,
name|rev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bin
operator|>
literal|0
condition|)
name|i
operator|=
operator|--
name|bin
expr_stmt|;
elseif|else
if|if
condition|(
name|buffer
operator|!=
literal|null
operator|&&
name|nbuffered
operator|>
literal|0
condition|)
block|{
name|bin
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
name|buffer
index|[
name|bufferIndex
operator|=
operator|--
name|nbuffered
index|]
expr_stmt|;
block|}
else|else
return|return
name|nextTab
return|;
block|}
block|}
comment|/**      * Split a normal bin with list headed by e into lo and hi parts;      * install in given table      */
DECL|method|splitBin
specifier|private
specifier|static
name|void
name|splitBin
parameter_list|(
name|Node
index|[]
name|nextTab
parameter_list|,
name|int
name|i
parameter_list|,
name|Node
name|e
parameter_list|)
block|{
name|int
name|bit
init|=
name|nextTab
operator|.
name|length
operator|>>>
literal|1
decl_stmt|;
comment|// bit to split on
name|int
name|runBit
init|=
name|e
operator|.
name|hash
operator|&
name|bit
decl_stmt|;
name|Node
name|lastRun
init|=
name|e
decl_stmt|,
name|lo
init|=
literal|null
decl_stmt|,
name|hi
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
name|p
init|=
name|e
operator|.
name|next
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|int
name|b
init|=
name|p
operator|.
name|hash
operator|&
name|bit
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|runBit
condition|)
block|{
name|runBit
operator|=
name|b
expr_stmt|;
name|lastRun
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|runBit
operator|==
literal|0
condition|)
name|lo
operator|=
name|lastRun
expr_stmt|;
else|else
name|hi
operator|=
name|lastRun
expr_stmt|;
for|for
control|(
name|Node
name|p
init|=
name|e
init|;
name|p
operator|!=
name|lastRun
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|int
name|ph
init|=
name|p
operator|.
name|hash
operator|&
name|HASH_BITS
decl_stmt|;
name|Object
name|pk
init|=
name|p
operator|.
name|key
decl_stmt|,
name|pv
init|=
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|ph
operator|&
name|bit
operator|)
operator|==
literal|0
condition|)
name|lo
operator|=
operator|new
name|Node
argument_list|(
name|ph
argument_list|,
name|pk
argument_list|,
name|pv
argument_list|,
name|lo
argument_list|)
expr_stmt|;
else|else
name|hi
operator|=
operator|new
name|Node
argument_list|(
name|ph
argument_list|,
name|pk
argument_list|,
name|pv
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|lo
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|bit
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
comment|/**      * Split a tree bin into lo and hi parts; install in given table      */
DECL|method|splitTreeBin
specifier|private
specifier|static
name|void
name|splitTreeBin
parameter_list|(
name|Node
index|[]
name|nextTab
parameter_list|,
name|int
name|i
parameter_list|,
name|TreeBin
name|t
parameter_list|)
block|{
name|int
name|bit
init|=
name|nextTab
operator|.
name|length
operator|>>>
literal|1
decl_stmt|;
name|TreeBin
name|lt
init|=
operator|new
name|TreeBin
argument_list|()
decl_stmt|;
name|TreeBin
name|ht
init|=
operator|new
name|TreeBin
argument_list|()
decl_stmt|;
name|int
name|lc
init|=
literal|0
decl_stmt|,
name|hc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|t
operator|.
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
name|int
name|h
init|=
name|e
operator|.
name|hash
operator|&
name|HASH_BITS
decl_stmt|;
name|Object
name|k
init|=
name|e
operator|.
name|key
decl_stmt|,
name|v
init|=
name|e
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|&
name|bit
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|lc
expr_stmt|;
name|lt
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|hc
expr_stmt|;
name|ht
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|Node
name|ln
decl_stmt|,
name|hn
decl_stmt|;
comment|// throw away trees if too small
if|if
condition|(
name|lc
operator|<=
operator|(
name|TREE_THRESHOLD
operator|>>>
literal|1
operator|)
condition|)
block|{
name|ln
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|Node
name|p
init|=
name|lt
operator|.
name|first
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
name|ln
operator|=
operator|new
name|Node
argument_list|(
name|p
operator|.
name|hash
argument_list|,
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
name|ln
operator|=
operator|new
name|Node
argument_list|(
name|MOVED
argument_list|,
name|lt
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|hc
operator|<=
operator|(
name|TREE_THRESHOLD
operator|>>>
literal|1
operator|)
condition|)
block|{
name|hn
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|Node
name|p
init|=
name|ht
operator|.
name|first
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
name|hn
operator|=
operator|new
name|Node
argument_list|(
name|p
operator|.
name|hash
argument_list|,
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
name|hn
argument_list|)
expr_stmt|;
block|}
else|else
name|hn
operator|=
operator|new
name|Node
argument_list|(
name|MOVED
argument_list|,
name|ht
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|bit
argument_list|,
name|hn
argument_list|)
expr_stmt|;
block|}
comment|/**      * Implementation for clear. Steps through each bin, removing all      * nodes.      */
DECL|method|internalClear
specifier|private
specifier|final
name|void
name|internalClear
parameter_list|()
block|{
name|long
name|delta
init|=
literal|0L
decl_stmt|;
comment|// negative number of deletions
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Node
index|[]
name|tab
init|=
name|table
decl_stmt|;
while|while
condition|(
name|tab
operator|!=
literal|null
operator|&&
name|i
operator|<
name|tab
operator|.
name|length
condition|)
block|{
name|int
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
name|Node
name|f
init|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
operator|++
name|i
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
name|t
init|=
operator|(
name|TreeBin
operator|)
name|fk
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
for|for
control|(
name|Node
name|p
init|=
name|t
operator|.
name|first
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|p
operator|.
name|val
operator|=
literal|null
expr_stmt|;
operator|--
name|delta
expr_stmt|;
block|}
name|t
operator|.
name|first
operator|=
literal|null
expr_stmt|;
name|t
operator|.
name|root
operator|=
literal|null
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|&
name|LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|counter
operator|.
name|add
argument_list|(
name|delta
argument_list|)
expr_stmt|;
comment|// opportunistically update count
name|delta
operator|=
literal|0L
expr_stmt|;
name|f
operator|.
name|tryAwaitLock
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|casHash
argument_list|(
name|fh
argument_list|,
name|fh
operator||
name|LOCKED
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
for|for
control|(
name|Node
name|e
init|=
name|f
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
name|e
operator|.
name|val
operator|=
literal|null
expr_stmt|;
operator|--
name|delta
expr_stmt|;
block|}
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|f
operator|.
name|casHash
argument_list|(
name|fh
operator||
name|LOCKED
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|f
operator|.
name|hash
operator|=
name|fh
expr_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
name|f
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
name|counter
operator|.
name|add
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
comment|/* ----------------Table Traversal -------------- */
comment|/**      * Encapsulates traversal for methods such as containsValue; also      * serves as a base class for other iterators.      *      * At each step, the iterator snapshots the key ("nextKey") and      * value ("nextVal") of a valid node (i.e., one that, at point of      * snapshot, has a non-null user value). Because val fields can      * change (including to null, indicating deletion), field nextVal      * might not be accurate at point of use, but still maintains the      * weak consistency property of holding a value that was once      * valid.      *      * Internal traversals directly access these fields, as in:      * {@code while (it.next != null) { process(it.nextKey); it.advance(); }}      *      * Exported iterators (subclasses of ViewIterator) extract key,      * value, or key-value pairs as return values of Iterator.next(),      * and encapsulate the it.next check as hasNext();      *      * The iterator visits once each still-valid node that was      * reachable upon iterator construction. It might miss some that      * were added to a bin after the bin was visited, which is OK wrt      * consistency guarantees. Maintaining this property in the face      * of possible ongoing resizes requires a fair amount of      * bookkeeping state that is difficult to optimize away amidst      * volatile accesses.  Even so, traversal maintains reasonable      * throughput.      *      * Normally, iteration proceeds bin-by-bin traversing lists.      * However, if the table has been resized, then all future steps      * must traverse both the bin at the current index as well as at      * (index + baseSize); and so on for further resizings. To      * paranoically cope with potential sharing by users of iterators      * across threads, iteration terminates if a bounds checks fails      * for a table read.      *      * The range-based constructor enables creation of parallel      * range-splitting traversals. (Not yet implemented.)      */
DECL|class|InternalIterator
specifier|static
class|class
name|InternalIterator
block|{
DECL|field|next
name|Node
name|next
decl_stmt|;
comment|// the next entry to use
DECL|field|last
name|Node
name|last
decl_stmt|;
comment|// the last entry used
DECL|field|nextKey
name|Object
name|nextKey
decl_stmt|;
comment|// cached key field of next
DECL|field|nextVal
name|Object
name|nextVal
decl_stmt|;
comment|// cached val field of next
DECL|field|tab
name|Node
index|[]
name|tab
decl_stmt|;
comment|// current table; updated if resized
DECL|field|index
name|int
name|index
decl_stmt|;
comment|// index of bin to use next
DECL|field|baseIndex
name|int
name|baseIndex
decl_stmt|;
comment|// current index of initial table
DECL|field|baseLimit
specifier|final
name|int
name|baseLimit
decl_stmt|;
comment|// index bound for initial table
DECL|field|baseSize
specifier|final
name|int
name|baseSize
decl_stmt|;
comment|// initial table size
comment|/** Creates iterator for all entries in the table. */
DECL|method|InternalIterator
name|InternalIterator
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|)
block|{
name|this
operator|.
name|tab
operator|=
name|tab
expr_stmt|;
name|baseLimit
operator|=
name|baseSize
operator|=
operator|(
name|tab
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|tab
operator|.
name|length
expr_stmt|;
name|index
operator|=
name|baseIndex
operator|=
literal|0
expr_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
comment|/** Creates iterator for the given range of the table */
DECL|method|InternalIterator
name|InternalIterator
parameter_list|(
name|Node
index|[]
name|tab
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
name|this
operator|.
name|tab
operator|=
name|tab
expr_stmt|;
name|baseSize
operator|=
operator|(
name|tab
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|tab
operator|.
name|length
expr_stmt|;
name|baseLimit
operator|=
operator|(
name|hi
operator|<=
name|baseSize
operator|)
condition|?
name|hi
else|:
name|baseSize
expr_stmt|;
name|index
operator|=
name|baseIndex
operator|=
operator|(
name|lo
operator|>=
literal|0
operator|)
condition|?
name|lo
else|:
literal|0
expr_stmt|;
name|next
operator|=
literal|null
expr_stmt|;
name|advance
argument_list|()
expr_stmt|;
block|}
comment|/** Advances next. See above for explanation. */
DECL|method|advance
specifier|final
name|void
name|advance
parameter_list|()
block|{
name|Node
name|e
init|=
name|last
operator|=
name|next
decl_stmt|;
name|outer
label|:
do|do
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
comment|// advance past used/skipped node
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|e
operator|==
literal|null
condition|)
block|{
comment|// get to next non-null bin
name|Node
index|[]
name|t
decl_stmt|;
name|int
name|b
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|Object
name|ek
decl_stmt|;
comment|// checks must use locals
if|if
condition|(
operator|(
name|b
operator|=
name|baseIndex
operator|)
operator|>=
name|baseLimit
operator|||
operator|(
name|i
operator|=
name|index
operator|)
operator|<
literal|0
operator|||
operator|(
name|t
operator|=
name|tab
operator|)
operator|==
literal|null
operator|||
name|i
operator|>=
operator|(
name|n
operator|=
name|t
operator|.
name|length
operator|)
condition|)
break|break
name|outer
break|;
elseif|else
if|if
condition|(
operator|(
name|e
operator|=
name|tabAt
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
name|e
operator|.
name|hash
operator|==
name|MOVED
condition|)
block|{
if|if
condition|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
name|e
operator|=
operator|(
operator|(
name|TreeBin
operator|)
name|ek
operator|)
operator|.
name|first
expr_stmt|;
else|else
block|{
name|tab
operator|=
operator|(
name|Node
index|[]
operator|)
name|ek
expr_stmt|;
continue|continue;
comment|// restarts due to null val
block|}
block|}
comment|// visit upper slots if present
name|index
operator|=
operator|(
name|i
operator|+=
name|baseSize
operator|)
operator|<
name|n
condition|?
name|i
else|:
operator|(
name|baseIndex
operator|=
name|b
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|nextKey
operator|=
name|e
operator|.
name|key
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|nextVal
operator|=
name|e
operator|.
name|val
operator|)
operator|==
literal|null
condition|)
do|;
comment|// skip deleted or special nodes
name|next
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|/* ---------------- Public operations -------------- */
comment|/**      * Creates a new, empty map with the default initial table size (16),      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|()
block|{
name|this
operator|.
name|counter
operator|=
operator|new
name|LongAdder
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with an initial table size      * accommodating the specified number of elements without the need      * to dynamically resize.      *      * @param initialCapacity The implementation performs internal      * sizing to accommodate this many elements.      * @throws IllegalArgumentException if the initial capacity of      * elements is negative      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
if|if
condition|(
name|initialCapacity
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|int
name|cap
init|=
operator|(
operator|(
name|initialCapacity
operator|>=
operator|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
operator|)
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
name|initialCapacity
operator|+
operator|(
name|initialCapacity
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
operator|)
decl_stmt|;
name|this
operator|.
name|counter
operator|=
operator|new
name|LongAdder
argument_list|()
expr_stmt|;
name|this
operator|.
name|sizeCtl
operator|=
name|cap
expr_stmt|;
block|}
comment|/**      * Creates a new map with the same mappings as the given map.      *      * @param m the map      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|this
operator|.
name|counter
operator|=
operator|new
name|LongAdder
argument_list|()
expr_stmt|;
name|this
operator|.
name|sizeCtl
operator|=
name|DEFAULT_CAPACITY
expr_stmt|;
name|internalPutAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with an initial table size based on      * the given number of elements ({@code initialCapacity}) and      * initial table density ({@code loadFactor}).      *      * @param initialCapacity the initial capacity. The implementation      * performs internal sizing to accommodate this many elements,      * given the specified load factor.      * @param loadFactor the load factor (table density) for      * establishing the initial table size      * @throws IllegalArgumentException if the initial capacity of      * elements is negative or the load factor is nonpositive      *      * @since 1.6      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|loadFactor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with an initial table size based on      * the given number of elements ({@code initialCapacity}), table      * density ({@code loadFactor}), and number of concurrently      * updating threads ({@code concurrencyLevel}).      *      * @param initialCapacity the initial capacity. The implementation      * performs internal sizing to accommodate this many elements,      * given the specified load factor.      * @param loadFactor the load factor (table density) for      * establishing the initial table size      * @param concurrencyLevel the estimated number of concurrently      * updating threads. The implementation may use this value as      * a sizing hint.      * @throws IllegalArgumentException if the initial capacity is      * negative or the load factor or concurrencyLevel are      * nonpositive      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|loadFactor
operator|>
literal|0.0f
operator|)
operator|||
name|initialCapacity
operator|<
literal|0
operator|||
name|concurrencyLevel
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
if|if
condition|(
name|initialCapacity
operator|<
name|concurrencyLevel
condition|)
comment|// Use at least as many bins
name|initialCapacity
operator|=
name|concurrencyLevel
expr_stmt|;
comment|// as estimated threads
name|long
name|size
init|=
call|(
name|long
call|)
argument_list|(
literal|1.0
operator|+
operator|(
name|long
operator|)
name|initialCapacity
operator|/
name|loadFactor
argument_list|)
decl_stmt|;
name|int
name|cap
init|=
operator|(
operator|(
name|size
operator|>=
operator|(
name|long
operator|)
name|MAXIMUM_CAPACITY
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|)
operator|)
decl_stmt|;
name|this
operator|.
name|counter
operator|=
operator|new
name|LongAdder
argument_list|()
expr_stmt|;
name|this
operator|.
name|sizeCtl
operator|=
name|cap
expr_stmt|;
block|}
comment|/**      * {@inheritDoc}      */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|counter
operator|.
name|sum
argument_list|()
operator|<=
literal|0L
return|;
comment|// ignore transient negative values
block|}
comment|/**      * {@inheritDoc}      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
name|long
name|n
init|=
name|counter
operator|.
name|sum
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|n
operator|<
literal|0L
operator|)
condition|?
literal|0
else|:
operator|(
name|n
operator|>
operator|(
name|long
operator|)
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|?
name|Integer
operator|.
name|MAX_VALUE
else|:
operator|(
name|int
operator|)
name|n
operator|)
return|;
block|}
DECL|method|longSize
specifier|final
name|long
name|longSize
parameter_list|()
block|{
comment|// accurate version of size needed for views
name|long
name|n
init|=
name|counter
operator|.
name|sum
argument_list|()
decl_stmt|;
return|return
operator|(
name|n
operator|<
literal|0L
operator|)
condition|?
literal|0L
else|:
name|n
return|;
block|}
comment|/**      * Returns the value to which the specified key is mapped,      * or {@code null} if this map contains no mapping for the key.      *      *<p>More formally, if this map contains a mapping from a key      * {@code k} to a value {@code v} such that {@code key.equals(k)},      * then this method returns {@code v}; otherwise it returns      * {@code null}.  (There can be at most one such mapping.)      *      * @throws NullPointerException if the specified key is null      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|get
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|(
name|V
operator|)
name|internalGet
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * Tests if the specified object is a key in this table.      *      * @param  key   possible key      * @return {@code true} if and only if the specified object      *         is a key in this table, as determined by the      *         {@code equals} method; {@code false} otherwise      * @throws NullPointerException if the specified key is null      */
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|internalGet
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns {@code true} if this map maps one or more keys to the      * specified value. Note: This method may require a full traversal      * of the map, and is much slower than method {@code containsKey}.      *      * @param value value whose presence in this map is to be tested      * @return {@code true} if this map maps one or more keys to the      *         specified value      * @throws NullPointerException if the specified value is null      */
DECL|method|containsValue
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Object
name|v
decl_stmt|;
name|InternalIterator
name|it
init|=
operator|new
name|InternalIterator
argument_list|(
name|table
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|nextVal
operator|)
operator|==
name|value
operator|||
name|value
operator|.
name|equals
argument_list|(
name|v
argument_list|)
condition|)
return|return
literal|true
return|;
name|it
operator|.
name|advance
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Legacy method testing if some key maps into the specified value      * in this table.  This method is identical in functionality to      * {@link #containsValue}, and exists solely to ensure      * full compatibility with class {@link java.util.Hashtable},      * which supported this method prior to introduction of the      * Java Collections framework.      *      * @param  value a value to search for      * @return {@code true} if and only if some key maps to the      *         {@code value} argument in this table as      *         determined by the {@code equals} method;      *         {@code false} otherwise      * @throws NullPointerException if the specified value is null      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Maps the specified key to the specified value in this table.      * Neither the key nor the value can be null.      *      *<p> The value can be retrieved by calling the {@code get} method      * with a key that is equal to the original key.      *      * @param key key with which the specified value is to be associated      * @param value value to be associated with the specified key      * @return the previous value associated with {@code key}, or      *         {@code null} if there was no mapping for {@code key}      * @throws NullPointerException if the specified key or value is null      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|put
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|(
name|V
operator|)
name|internalPut
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key,      *         or {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|putIfAbsent
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|(
name|V
operator|)
name|internalPutIfAbsent
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
return|;
block|}
comment|/**      * Copies all of the mappings from the specified map to this one.      * These mappings replace any mappings that this map had for any of the      * keys currently in the specified map.      *      * @param m mappings to be stored in this map      */
DECL|method|putAll
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|internalPutAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**      * If the specified key is not already associated with a value,      * computes its value using the given mappingFunction and      * enters it into the map.  This is equivalent to      *<pre> {@code      * if (map.containsKey(key))      *   return map.get(key);      * value = mappingFunction.map(key);      * map.put(key, value);      * return value;}</pre>      *      * except that the action is performed atomically.  If the      * function returns {@code null} (in which case a {@code      * NullPointerException} is thrown), or the function itself throws      * an (unchecked) exception, the exception is rethrown to its      * caller, and no mapping is recorded.  Some attempted update      * operations on this map by other threads may be blocked while      * computation is in progress, so the computation should be short      * and simple, and must not attempt to update any other mappings      * of this Map. The most appropriate usage is to construct a new      * object serving as an initial mapped value, or memoized result,      * as in:      *      *<pre> {@code      * map.computeIfAbsent(key, new MappingFunction<K, V>() {      *   public V map(K k) { return new Value(f(k)); }});}</pre>      *      * @param key key with which the specified value is to be associated      * @param mappingFunction the function to compute a value      * @return the current (existing or computed) value associated with      *         the specified key.      * @throws NullPointerException if the specified key, mappingFunction,      *         or computed value is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the mappingFunction does so,      *         in which case the mapping is left unestablished      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|computeIfAbsent
specifier|public
name|V
name|computeIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|MappingFunction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|mappingFunction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|mappingFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|(
name|V
operator|)
name|internalComputeIfAbsent
argument_list|(
name|key
argument_list|,
name|mappingFunction
argument_list|)
return|;
block|}
comment|/**      * Computes and enters a new mapping value given a key and      * its current mapped value (or {@code null} if there is no current      * mapping). This is equivalent to      *<pre> {@code      *  map.put(key, remappingFunction.remap(key, map.get(key));      * }</pre>      *      * except that the action is performed atomically.  If the      * function returns {@code null} (in which case a {@code      * NullPointerException} is thrown), or the function itself throws      * an (unchecked) exception, the exception is rethrown to its      * caller, and current mapping is left unchanged.  Some attempted      * update operations on this map by other threads may be blocked      * while computation is in progress, so the computation should be      * short and simple, and must not attempt to update any other      * mappings of this Map. For example, to either create or      * append new messages to a value mapping:      *      *<pre> {@code      * Map<Key, String> map = ...;      * final String msg = ...;      * map.compute(key, new RemappingFunction<Key, String>() {      *   public String remap(Key k, String v) {      *    return (v == null) ? msg : v + msg;});}}</pre>      *      * @param key key with which the specified value is to be associated      * @param remappingFunction the function to compute a value      * @return the new value associated with      *         the specified key.      * @throws NullPointerException if the specified key or remappingFunction      *         or computed value is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the remappingFunction does so,      *         in which case the mapping is unchanged      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|compute
specifier|public
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|,
name|RemappingFunction
argument_list|<
name|?
super|super
name|K
argument_list|,
name|V
argument_list|>
name|remappingFunction
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|remappingFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|(
name|V
operator|)
name|internalCompute
argument_list|(
name|key
argument_list|,
name|remappingFunction
argument_list|)
return|;
block|}
comment|/**      * Removes the key (and its corresponding value) from this map.      * This method does nothing if the key is not in the map.      *      * @param  key the key that needs to be removed      * @return the previous value associated with {@code key}, or      *         {@code null} if there was no mapping for {@code key}      * @throws NullPointerException if the specified key is null      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|remove
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|(
name|V
operator|)
name|internalReplace
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if the specified key is null      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|value
operator|==
literal|null
condition|)
return|return
literal|false
return|;
return|return
name|internalReplace
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if any of the arguments are null      */
DECL|method|replace
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|oldValue
operator|==
literal|null
operator|||
name|newValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|internalReplace
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|,
name|oldValue
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key,      *         or {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|replace
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|(
name|V
operator|)
name|internalReplace
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Removes all of the mappings from this map.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|internalClear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a {@link Set} view of the keys contained in this map.      * The set is backed by the map, so changes to the map are      * reflected in the set, and vice-versa.  The set supports element      * removal, which removes the corresponding mapping from this map,      * via the {@code Iterator.remove}, {@code Set.remove},      * {@code removeAll}, {@code retainAll}, and {@code clear}      * operations.  It does not support the {@code add} or      * {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      */
DECL|method|keySet
specifier|public
name|Set
argument_list|<
name|K
argument_list|>
name|keySet
parameter_list|()
block|{
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns a {@link Collection} view of the values contained in this map.      * The collection is backed by the map, so changes to the map are      * reflected in the collection, and vice-versa.  The collection      * supports element removal, which removes the corresponding      * mapping from this map, via the {@code Iterator.remove},      * {@code Collection.remove}, {@code removeAll},      * {@code retainAll}, and {@code clear} operations.  It does not      * support the {@code add} or {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      */
DECL|method|values
specifier|public
name|Collection
argument_list|<
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|Values
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|Values
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns a {@link Set} view of the mappings contained in this map.      * The set is backed by the map, so changes to the map are      * reflected in the set, and vice-versa.  The set supports element      * removal, which removes the corresponding mapping from the map,      * via the {@code Iterator.remove}, {@code Set.remove},      * {@code removeAll}, {@code retainAll}, and {@code clear}      * operations.  It does not support the {@code add} or      * {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      */
DECL|method|entrySet
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySet
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns an enumeration of the keys in this table.      *      * @return an enumeration of the keys in this table      * @see #keySet()      */
DECL|method|keys
specifier|public
name|Enumeration
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns an enumeration of the values in this table.      *      * @return an enumeration of the values in this table      * @see #values()      */
DECL|method|elements
specifier|public
name|Enumeration
argument_list|<
name|V
argument_list|>
name|elements
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns the hash code value for this {@link Map}, i.e.,      * the sum of, for each key-value pair in the map,      * {@code key.hashCode() ^ value.hashCode()}.      *      * @return the hash code value for this map      */
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
name|InternalIterator
name|it
init|=
operator|new
name|InternalIterator
argument_list|(
name|table
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|h
operator|+=
name|it
operator|.
name|nextKey
operator|.
name|hashCode
argument_list|()
operator|^
name|it
operator|.
name|nextVal
operator|.
name|hashCode
argument_list|()
expr_stmt|;
name|it
operator|.
name|advance
argument_list|()
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/**      * Returns a string representation of this map.  The string      * representation consists of a list of key-value mappings (in no      * particular order) enclosed in braces ("{@code {}}").  Adjacent      * mappings are separated by the characters {@code ", "} (comma      * and space).  Each key-value mapping is rendered as the key      * followed by an equals sign ("{@code =}") followed by the      * associated value.      *      * @return a string representation of this map      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|InternalIterator
name|it
init|=
operator|new
name|InternalIterator
argument_list|(
name|table
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|k
init|=
name|it
operator|.
name|nextKey
decl_stmt|,
name|v
init|=
name|it
operator|.
name|nextVal
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|k
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|k
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|v
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|v
argument_list|)
expr_stmt|;
name|it
operator|.
name|advance
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|next
operator|==
literal|null
condition|)
break|break;
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Compares the specified object with this map for equality.      * Returns {@code true} if the given object is a map with the same      * mappings as this map.  This operation may return misleading      * results if either map is concurrently modified during execution      * of this method.      *      * @param o object to be compared for equality with this map      * @return {@code true} if the specified object is equal to this map      */
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|!=
name|this
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|)
condition|)
return|return
literal|false
return|;
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|m
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|InternalIterator
name|it
init|=
operator|new
name|InternalIterator
argument_list|(
name|table
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|Object
name|val
init|=
name|it
operator|.
name|nextVal
decl_stmt|;
name|Object
name|v
init|=
name|m
operator|.
name|get
argument_list|(
name|it
operator|.
name|nextKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
operator|||
operator|(
name|v
operator|!=
name|val
operator|&&
operator|!
name|v
operator|.
name|equals
argument_list|(
name|val
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
name|it
operator|.
name|advance
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|mk
decl_stmt|,
name|mv
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|mk
operator|=
name|e
operator|.
name|getKey
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|mv
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|v
operator|=
name|internalGet
argument_list|(
name|mk
argument_list|)
operator|)
operator|==
literal|null
operator|||
operator|(
name|mv
operator|!=
name|v
operator|&&
operator|!
name|mv
operator|.
name|equals
argument_list|(
name|v
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/* ----------------Iterators -------------- */
comment|/**      * Base class for key, value, and entry iterators.  Adds a map      * reference to InternalIterator to support Iterator.remove.      */
DECL|class|ViewIterator
specifier|static
specifier|abstract
class|class
name|ViewIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|InternalIterator
block|{
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|ViewIterator
name|ViewIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
operator|.
name|table
argument_list|)
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|void
name|remove
parameter_list|()
block|{
if|if
condition|(
name|last
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|map
operator|.
name|remove
argument_list|(
name|last
operator|.
name|key
argument_list|)
expr_stmt|;
name|last
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
specifier|final
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|next
operator|!=
literal|null
return|;
block|}
DECL|method|hasMoreElements
specifier|public
specifier|final
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|next
operator|!=
literal|null
return|;
block|}
block|}
DECL|class|KeyIterator
specifier|static
specifier|final
class|class
name|KeyIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Iterator
argument_list|<
name|K
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|K
argument_list|>
block|{
DECL|method|KeyIterator
name|KeyIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|next
specifier|public
specifier|final
name|K
name|next
parameter_list|()
block|{
if|if
condition|(
name|next
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|Object
name|k
init|=
name|nextKey
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|K
operator|)
name|k
return|;
block|}
DECL|method|nextElement
specifier|public
specifier|final
name|K
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
specifier|static
specifier|final
class|class
name|ValueIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Iterator
argument_list|<
name|V
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|V
argument_list|>
block|{
DECL|method|ValueIterator
name|ValueIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|next
specifier|public
specifier|final
name|V
name|next
parameter_list|()
block|{
if|if
condition|(
name|next
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|Object
name|v
init|=
name|nextVal
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
operator|(
name|V
operator|)
name|v
return|;
block|}
DECL|method|nextElement
specifier|public
specifier|final
name|V
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
block|}
DECL|class|EntryIterator
specifier|static
specifier|final
class|class
name|EntryIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|EntryIterator
name|EntryIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|next
specifier|public
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
name|next
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|Object
name|k
init|=
name|nextKey
decl_stmt|;
name|Object
name|v
init|=
name|nextVal
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|WriteThroughEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
operator|(
name|K
operator|)
name|k
argument_list|,
operator|(
name|V
operator|)
name|v
argument_list|,
name|map
argument_list|)
return|;
block|}
block|}
DECL|class|SnapshotEntryIterator
specifier|static
specifier|final
class|class
name|SnapshotEntryIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|ViewIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|SnapshotEntryIterator
name|SnapshotEntryIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|next
specifier|public
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
if|if
condition|(
name|next
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|Object
name|k
init|=
name|nextKey
decl_stmt|;
name|Object
name|v
init|=
name|nextVal
decl_stmt|;
name|advance
argument_list|()
expr_stmt|;
return|return
operator|new
name|SnapshotEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
operator|(
name|K
operator|)
name|k
argument_list|,
operator|(
name|V
operator|)
name|v
argument_list|)
return|;
block|}
block|}
comment|/**      * Base of writeThrough and Snapshot entry classes      */
DECL|class|MapEntry
specifier|static
specifier|abstract
class|class
name|MapEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|val
name|V
name|val
decl_stmt|;
comment|// non-null
DECL|method|MapEntry
name|MapEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|val
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
block|}
DECL|method|getKey
specifier|public
specifier|final
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue
specifier|public
specifier|final
name|V
name|getValue
parameter_list|()
block|{
return|return
name|val
return|;
block|}
DECL|method|hashCode
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|val
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
return|return
name|key
operator|+
literal|"="
operator|+
name|val
return|;
block|}
DECL|method|equals
specifier|public
specifier|final
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|k
operator|==
name|key
operator|||
name|k
operator|.
name|equals
argument_list|(
name|key
argument_list|)
operator|)
operator|&&
operator|(
name|v
operator|==
name|val
operator|||
name|v
operator|.
name|equals
argument_list|(
name|val
argument_list|)
operator|)
operator|)
return|;
block|}
DECL|method|setValue
specifier|public
specifier|abstract
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
function_decl|;
block|}
comment|/**      * Entry used by EntryIterator.next(), that relays setValue      * changes to the underlying map.      */
DECL|class|WriteThroughEntry
specifier|static
specifier|final
class|class
name|WriteThroughEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|MapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|WriteThroughEntry
name|WriteThroughEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|val
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
comment|/**          * Sets our entry's value and writes through to the map. The          * value to return is somewhat arbitrary here. Since a          * WriteThroughEntry does not necessarily track asynchronous          * changes, the most recent "previous" value could be          * different from what we return (or could even have been          * removed in which case the put will re-establish). We do not          * and cannot guarantee more.          */
DECL|method|setValue
specifier|public
specifier|final
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|V
name|v
init|=
name|val
decl_stmt|;
name|val
operator|=
name|value
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
comment|/**      * Internal version of entry, that doesn't write though changes      */
DECL|class|SnapshotEntry
specifier|static
specifier|final
class|class
name|SnapshotEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|MapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|method|SnapshotEntry
name|SnapshotEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|val
parameter_list|)
block|{
name|super
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|setValue
specifier|public
specifier|final
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
comment|// only locally update
if|if
condition|(
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|V
name|v
init|=
name|val
decl_stmt|;
name|val
operator|=
name|value
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
comment|/* ----------------Views -------------- */
comment|/**      * Base class for views. This is done mainly to allow adding      * customized parallel traversals (not yet implemented.)      */
DECL|class|MapView
specifier|static
specifier|abstract
class|class
name|MapView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|MapView
name|MapView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
DECL|method|size
specifier|public
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty
specifier|public
specifier|final
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|clear
specifier|public
specifier|final
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// implementations below rely on concrete classes supplying these
DECL|method|iter
specifier|abstract
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|()
function_decl|;
DECL|method|contains
specifier|abstract
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
DECL|method|remove
specifier|abstract
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
DECL|field|oomeMsg
specifier|private
specifier|static
specifier|final
name|String
name|oomeMsg
init|=
literal|"Required array size too large"
decl_stmt|;
DECL|method|toArray
specifier|public
specifier|final
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|long
name|sz
init|=
name|map
operator|.
name|longSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|>
call|(
name|long
call|)
argument_list|(
name|MAX_ARRAY_SIZE
argument_list|)
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
name|int
name|n
init|=
operator|(
name|int
operator|)
name|sz
decl_stmt|;
name|Object
index|[]
name|r
init|=
operator|new
name|Object
index|[
name|n
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iter
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
operator|-
operator|(
name|MAX_ARRAY_SIZE
operator|>>>
literal|1
operator|)
operator|-
literal|1
condition|)
name|n
operator|=
name|MAX_ARRAY_SIZE
expr_stmt|;
else|else
name|n
operator|+=
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|r
index|[
name|i
operator|++
index|]
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|==
name|n
operator|)
condition|?
name|r
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|toArray
specifier|public
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
name|long
name|sz
init|=
name|map
operator|.
name|longSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|>
call|(
name|long
call|)
argument_list|(
name|MAX_ARRAY_SIZE
argument_list|)
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
name|int
name|m
init|=
operator|(
name|int
operator|)
name|sz
decl_stmt|;
name|T
index|[]
name|r
init|=
operator|(
name|a
operator|.
name|length
operator|>=
name|m
operator|)
condition|?
name|a
else|:
operator|(
name|T
index|[]
operator|)
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
operator|.
name|newInstance
argument_list|(
name|a
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|r
operator|.
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iter
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
operator|-
operator|(
name|MAX_ARRAY_SIZE
operator|>>>
literal|1
operator|)
operator|-
literal|1
condition|)
name|n
operator|=
name|MAX_ARRAY_SIZE
expr_stmt|;
else|else
name|n
operator|+=
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|r
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|T
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|r
operator|&&
name|i
operator|<
name|n
condition|)
block|{
name|r
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
comment|// null-terminate
return|return
name|r
return|;
block|}
return|return
operator|(
name|i
operator|==
name|n
operator|)
condition|?
name|r
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|hashCode
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iter
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|h
operator|+=
name|it
operator|.
name|next
argument_list|()
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|h
return|;
block|}
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iter
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
operator|==
name|this
condition|?
literal|"(this Collection)"
else|:
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
break|break;
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|containsAll
specifier|public
specifier|final
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
name|this
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|c
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
operator|||
operator|!
name|contains
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|removeAll
specifier|public
specifier|final
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iter
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
DECL|method|retainAll
specifier|public
specifier|final
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iter
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|c
operator|.
name|contains
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
block|}
DECL|class|KeySet
specifier|static
specifier|final
class|class
name|KeySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|MapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|K
argument_list|>
block|{
DECL|method|KeySet
name|KeySet
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|contains
specifier|public
specifier|final
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
DECL|method|iterator
specifier|public
specifier|final
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|iter
specifier|final
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
specifier|final
name|boolean
name|add
parameter_list|(
name|K
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|addAll
specifier|public
specifier|final
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|c
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Set
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|o
operator|)
operator|==
name|this
operator|||
operator|(
name|containsAll
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|.
name|containsAll
argument_list|(
name|this
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
block|}
DECL|class|Values
specifier|static
specifier|final
class|class
name|Values
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|MapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Collection
argument_list|<
name|V
argument_list|>
block|{
DECL|method|Values
name|Values
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|contains
specifier|public
specifier|final
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|V
argument_list|>
name|it
init|=
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|iterator
specifier|public
specifier|final
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|iter
specifier|final
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
specifier|final
name|boolean
name|add
parameter_list|(
name|V
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|addAll
specifier|public
specifier|final
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|c
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
DECL|class|EntrySet
specifier|static
specifier|final
class|class
name|EntrySet
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|MapView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|EntrySet
name|EntrySet
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|contains
specifier|public
specifier|final
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|map
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|==
name|r
operator|||
name|v
operator|.
name|equals
argument_list|(
name|r
argument_list|)
operator|)
operator|)
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|map
operator|.
name|remove
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
DECL|method|iterator
specifier|public
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|iter
specifier|final
name|Iterator
argument_list|<
name|?
argument_list|>
name|iter
parameter_list|()
block|{
return|return
operator|new
name|SnapshotEntryIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
specifier|final
name|boolean
name|add
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|addAll
specifier|public
specifier|final
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Set
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|o
operator|)
operator|==
name|this
operator|||
operator|(
name|containsAll
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|.
name|containsAll
argument_list|(
name|this
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
block|}
comment|/* ---------------- Serialization Support -------------- */
comment|/**      * Stripped-down version of helper class used in previous version,      * declared for the sake of serialization compatibility      */
DECL|class|Segment
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2249069246763182397L
decl_stmt|;
DECL|field|loadFactor
specifier|final
name|float
name|loadFactor
decl_stmt|;
DECL|method|Segment
name|Segment
parameter_list|(
name|float
name|lf
parameter_list|)
block|{
name|this
operator|.
name|loadFactor
operator|=
name|lf
expr_stmt|;
block|}
block|}
comment|/**      * Saves the state of the {@code ConcurrentHashMapV8} instance to a      * stream (i.e., serializes it).      * @param s the stream      * @serialData      * the key (Object) and value (Object)      * for each key-value mapping, followed by a null pair.      * The key-value mappings are emitted in no particular order.      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|segments
operator|==
literal|null
condition|)
block|{
comment|// for serialization compatibility
name|segments
operator|=
operator|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
operator|)
operator|new
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|DEFAULT_CONCURRENCY_LEVEL
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|LOAD_FACTOR
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|InternalIterator
name|it
init|=
operator|new
name|InternalIterator
argument_list|(
name|table
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|next
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|writeObject
argument_list|(
name|it
operator|.
name|nextKey
argument_list|)
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
name|it
operator|.
name|nextVal
argument_list|)
expr_stmt|;
name|it
operator|.
name|advance
argument_list|()
expr_stmt|;
block|}
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|segments
operator|=
literal|null
expr_stmt|;
comment|// throw away
block|}
comment|/**      * Reconstitutes the instance from a stream (that is, deserializes it).      * @param s the stream      */
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|this
operator|.
name|segments
operator|=
literal|null
expr_stmt|;
comment|// unneeded
comment|// initialize transient final field
name|UNSAFE
operator|.
name|putObjectVolatile
argument_list|(
name|this
argument_list|,
name|counterOffset
argument_list|,
operator|new
name|LongAdder
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create all nodes, then place in table once size is known
name|long
name|size
init|=
literal|0L
decl_stmt|;
name|Node
name|p
init|=
literal|null
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|K
name|k
init|=
operator|(
name|K
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|V
name|v
init|=
operator|(
name|V
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|!=
literal|null
operator|&&
name|v
operator|!=
literal|null
condition|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|=
operator|new
name|Node
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|++
name|size
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|boolean
name|init
init|=
literal|false
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|size
operator|>=
call|(
name|long
call|)
argument_list|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
argument_list|)
condition|)
name|n
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
else|else
block|{
name|int
name|sz
init|=
operator|(
name|int
operator|)
name|size
decl_stmt|;
name|n
operator|=
name|tableSizeFor
argument_list|(
name|sz
operator|+
operator|(
name|sz
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|sc
init|=
name|sizeCtl
decl_stmt|;
name|boolean
name|collide
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|sc
operator|&&
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|sizeCtlOffset
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|table
operator|==
literal|null
condition|)
block|{
name|init
operator|=
literal|true
expr_stmt|;
name|Node
index|[]
name|tab
init|=
operator|new
name|Node
index|[
name|n
index|]
decl_stmt|;
name|int
name|mask
init|=
name|n
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|int
name|j
init|=
name|p
operator|.
name|hash
operator|&
name|mask
decl_stmt|;
name|Node
name|next
init|=
name|p
operator|.
name|next
decl_stmt|;
name|Node
name|q
init|=
name|p
operator|.
name|next
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|collide
operator|&&
name|q
operator|!=
literal|null
operator|&&
name|q
operator|.
name|hash
operator|==
name|p
operator|.
name|hash
condition|)
name|collide
operator|=
literal|true
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|table
operator|=
name|tab
expr_stmt|;
name|counter
operator|.
name|add
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
if|if
condition|(
name|collide
condition|)
block|{
comment|// rescan and convert to TreeBins
name|Node
index|[]
name|tab
init|=
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tab
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
name|e
init|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
operator|++
name|c
operator|>
name|TREE_THRESHOLD
operator|&&
operator|(
name|e
operator|.
name|key
operator|instanceof
name|Comparable
operator|)
condition|)
block|{
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|init
condition|)
block|{
comment|// Can only happen if unsafely published.
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|internalPut
argument_list|(
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|.
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|counterOffset
specifier|private
specifier|static
specifier|final
name|long
name|counterOffset
decl_stmt|;
DECL|field|sizeCtlOffset
specifier|private
specifier|static
specifier|final
name|long
name|sizeCtlOffset
decl_stmt|;
DECL|field|ABASE
specifier|private
specifier|static
specifier|final
name|long
name|ABASE
decl_stmt|;
DECL|field|ASHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ASHIFT
decl_stmt|;
static|static
block|{
name|int
name|ss
decl_stmt|;
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|ConcurrentHashMapV8
operator|.
name|class
decl_stmt|;
name|counterOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"counter"
argument_list|)
argument_list|)
expr_stmt|;
name|sizeCtlOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"sizeCtl"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|sc
init|=
name|Node
index|[]
operator|.
name|class
decl_stmt|;
name|ABASE
operator|=
name|UNSAFE
operator|.
name|arrayBaseOffset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ss
operator|=
name|UNSAFE
operator|.
name|arrayIndexScale
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|ss
operator|&
operator|(
name|ss
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|ASHIFT
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|ss
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

