begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Comparator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Hashtable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Enumeration
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ConcurrentModificationException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ConcurrentMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|AbstractQueuedSynchronizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|Serializable
import|;
end_import

begin_comment
comment|/**  * A hash table supporting full concurrency of retrievals and  * high expected concurrency for updates. This class obeys the  * same functional specification as {@link java.util.Hashtable}, and  * includes versions of methods corresponding to each method of  * {@code Hashtable}. However, even though all operations are  * thread-safe, retrieval operations do<em>not</em> entail locking,  * and there is<em>not</em> any support for locking the entire table  * in a way that prevents all access.  This class is fully  * interoperable with {@code Hashtable} in programs that rely on its  * thread safety but not on its synchronization details.  *  *<p>Retrieval operations (including {@code get}) generally do not  * block, so may overlap with update operations (including {@code put}  * and {@code remove}). Retrievals reflect the results of the most  * recently<em>completed</em> update operations holding upon their  * onset. (More formally, an update operation for a given key bears a  *<em>happens-before</em> relation with any (non-null) retrieval for  * that key reporting the updated value.)  For aggregate operations  * such as {@code putAll} and {@code clear}, concurrent retrievals may  * reflect insertion or removal of only some entries.  Similarly,  * Iterators and Enumerations return elements reflecting the state of  * the hash table at some point at or since the creation of the  * iterator/enumeration.  They do<em>not</em> throw {@link  * ConcurrentModificationException}.  However, iterators are designed  * to be used by only one thread at a time.  Bear in mind that the  * results of aggregate status methods including {@code size}, {@code  * isEmpty}, and {@code containsValue} are typically useful only when  * a map is not undergoing concurrent updates in other threads.  * Otherwise the results of these methods reflect transient states  * that may be adequate for monitoring or estimation purposes, but not  * for program control.  *  *<p>The table is dynamically expanded when there are too many  * collisions (i.e., keys that have distinct hash codes but fall into  * the same slot modulo the table size), with the expected average  * effect of maintaining roughly two bins per mapping (corresponding  * to a 0.75 load factor threshold for resizing). There may be much  * variance around this average as mappings are added and removed, but  * overall, this maintains a commonly accepted time/space tradeoff for  * hash tables.  However, resizing this or any other kind of hash  * table may be a relatively slow operation. When possible, it is a  * good idea to provide a size estimate as an optional {@code  * initialCapacity} constructor argument. An additional optional  * {@code loadFactor} constructor argument provides a further means of  * customizing initial table capacity by specifying the table density  * to be used in calculating the amount of space to allocate for the  * given number of elements.  Also, for compatibility with previous  * versions of this class, constructors may optionally specify an  * expected {@code concurrencyLevel} as an additional hint for  * internal sizing.  Note that using many keys with exactly the same  * {@code hashCode()} is a sure way to slow down performance of any  * hash table.  *  *<p>A {@link Set} projection of a ConcurrentHashMapV8 may be created  * (using {@link #newKeySet()} or {@link #newKeySet(int)}), or viewed  * (using {@link #keySet(Object)} when only keys are of interest, and the  * mapped values are (perhaps transiently) not used or all take the  * same mapping value.  *  *<p>A ConcurrentHashMapV8 can be used as scalable frequency map (a  * form of histogram or multiset) by using {@link LongAdder} values  * and initializing via {@link #computeIfAbsent}. For example, to add  * a count to a {@code ConcurrentHashMapV8<String,LongAdder> freqs}, you  * can use {@code freqs.computeIfAbsent(k -> new  * LongAdder()).increment();}  *  *<p>This class and its views and iterators implement all of the  *<em>optional</em> methods of the {@link Map} and {@link Iterator}  * interfaces.  *  *<p>Like {@link Hashtable} but unlike {@link HashMap}, this class  * does<em>not</em> allow {@code null} to be used as a key or value.  *  *<p>ConcurrentHashMapV8s support sequential and parallel operations  * bulk operations. (Parallel forms use the {@link  * ForkJoinPool#commonPool()}). Tasks that may be used in other  * contexts are available in class {@link ForkJoinTasks}. These  * operations are designed to be safely, and often sensibly, applied  * even with maps that are being concurrently updated by other  * threads; for example, when computing a snapshot summary of the  * values in a shared registry.  There are three kinds of operation,  * each with four forms, accepting functions with Keys, Values,  * Entries, and (Key, Value) arguments and/or return values. Because  * the elements of a ConcurrentHashMapV8 are not ordered in any  * particular way, and may be processed in different orders in  * different parallel executions, the correctness of supplied  * functions should not depend on any ordering, or on any other  * objects or values that may transiently change while computation is  * in progress; and except for forEach actions, should ideally be  * side-effect-free.  *  *<ul>  *<li> forEach: Perform a given action on each element.  * A variant form applies a given transformation on each element  * before performing the action.</li>  *  *<li> search: Return the first available non-null result of  * applying a given function on each element; skipping further  * search when a result is found.</li>  *  *<li> reduce: Accumulate each element.  The supplied reduction  * function cannot rely on ordering (more formally, it should be  * both associative and commutative).  There are five variants:  *  *<ul>  *  *<li> Plain reductions. (There is not a form of this method for  * (key, value) function arguments since there is no corresponding  * return type.)</li>  *  *<li> Mapped reductions that accumulate the results of a given  * function applied to each element.</li>  *  *<li> Reductions to scalar doubles, longs, and ints, using a  * given basis value.</li>  *  *</li>  *</ul>  *</ul>  *  *<p>The concurrency properties of bulk operations follow  * from those of ConcurrentHashMapV8: Any non-null result returned  * from {@code get(key)} and related access methods bears a  * happens-before relation with the associated insertion or  * update.  The result of any bulk operation reflects the  * composition of these per-element relations (but is not  * necessarily atomic with respect to the map as a whole unless it  * is somehow known to be quiescent).  Conversely, because keys  * and values in the map are never null, null serves as a reliable  * atomic indicator of the current lack of any result.  To  * maintain this property, null serves as an implicit basis for  * all non-scalar reduction operations. For the double, long, and  * int versions, the basis should be one that, when combined with  * any other value, returns that other value (more formally, it  * should be the identity element for the reduction). Most common  * reductions have these properties; for example, computing a sum  * with basis 0 or a minimum with basis MAX_VALUE.  *  *<p>Search and transformation functions provided as arguments  * should similarly return null to indicate the lack of any result  * (in which case it is not used). In the case of mapped  * reductions, this also enables transformations to serve as  * filters, returning null (or, in the case of primitive  * specializations, the identity basis) if the element should not  * be combined. You can create compound transformations and  * filterings by composing them yourself under this "null means  * there is nothing there now" rule before using them in search or  * reduce operations.  *  *<p>Methods accepting and/or returning Entry arguments maintain  * key-value associations. They may be useful for example when  * finding the key for the greatest value. Note that "plain" Entry  * arguments can be supplied using {@code new  * AbstractMap.SimpleEntry(k,v)}.  *  *<p>Bulk operations may complete abruptly, throwing an  * exception encountered in the application of a supplied  * function. Bear in mind when handling such exceptions that other  * concurrently executing functions could also have thrown  * exceptions, or would have done so if the first exception had  * not occurred.  *  *<p>Speedups for parallel compared to sequential forms are common  * but not guaranteed.  Parallel operations involving brief functions  * on small maps may execute more slowly than sequential forms if the  * underlying work to parallelize the computation is more expensive  * than the computation itself.  Similarly, parallelization may not  * lead to much actual parallelism if all processors are busy  * performing unrelated tasks.  *  *<p>All arguments to all task methods must be non-null.  *  *<p><em>jsr166e note: During transition, this class  * uses nested functional interfaces with different names but the  * same forms as those expected for JDK8.</em>  *  *<p>This class is a member of the  *<a href="{@docRoot}/../technotes/guides/collections/index.html">  * Java Collections Framework</a>.  *  * @since 1.5  * @author Doug Lea  * @param<K> the type of keys maintained by this map  * @param<V> the type of mapped values  */
end_comment

begin_class
DECL|class|ConcurrentHashMapV8
specifier|public
class|class
name|ConcurrentHashMapV8
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|ConcurrentMap
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|,
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7249069246763182397L
decl_stmt|;
comment|/**      * A partitionable iterator. A Spliterator can be traversed      * directly, but can also be partitioned (before traversal) by      * creating another Spliterator that covers a non-overlapping      * portion of the elements, and so may be amenable to parallel      * execution.      *      *<p>This interface exports a subset of expected JDK8      * functionality.      *      *<p>Sample usage: Here is one (of the several) ways to compute      * the sum of the values held in a map using the ForkJoin      * framework. As illustrated here, Spliterators are well suited to      * designs in which a task repeatedly splits off half its work      * into forked subtasks until small enough to process directly,      * and then joins these subtasks. Variants of this style can also      * be used in completion-based designs.      *      *<pre>      * {@code ConcurrentHashMapV8<String, Long> m = ...      * // split as if have 8 * parallelism, for load balance      * int n = m.size();      * int p = aForkJoinPool.getParallelism() * 8;      * int split = (n< p)? n : p;      * long sum = aForkJoinPool.invoke(new SumValues(m.valueSpliterator(), split, null));      * // ...      * static class SumValues extends RecursiveTask<Long> {      *   final Spliterator<Long> s;      *   final int split;             // split while> 1      *   final SumValues nextJoin;    // records forked subtasks to join      *   SumValues(Spliterator<Long> s, int depth, SumValues nextJoin) {      *     this.s = s; this.depth = depth; this.nextJoin = nextJoin;      *   }      *   public Long compute() {      *     long sum = 0;      *     SumValues subtasks = null; // fork subtasks      *     for (int s = split>>> 1; s> 0; s>>>= 1)      *       (subtasks = new SumValues(s.split(), s, subtasks)).fork();      *     while (s.hasNext())        // directly process remaining elements      *       sum += s.next();      *     for (SumValues t = subtasks; t != null; t = t.nextJoin)      *       sum += t.join();         // collect subtask results      *     return sum;      *   }      * }      * }</pre>      */
DECL|interface|Spliterator
specifier|public
specifier|static
interface|interface
name|Spliterator
parameter_list|<
name|T
parameter_list|>
extends|extends
name|Iterator
argument_list|<
name|T
argument_list|>
block|{
comment|/**          * Returns a Spliterator covering approximately half of the          * elements, guaranteed not to overlap with those subsequently          * returned by this Spliterator.  After invoking this method,          * the current Spliterator will<em>not</em> produce any of          * the elements of the returned Spliterator, but the two          * Spliterators together will produce all of the elements that          * would have been produced by this Spliterator had this          * method not been called. The exact number of elements          * produced by the returned Spliterator is not guaranteed, and          * may be zero (i.e., with {@code hasNext()} reporting {@code          * false}) if this Spliterator cannot be further split.          *          * @return a Spliterator covering approximately half of the          * elements          * @throws IllegalStateException if this Spliterator has          * already commenced traversing elements          */
DECL|method|split
name|Spliterator
argument_list|<
name|T
argument_list|>
name|split
parameter_list|()
function_decl|;
block|}
comment|/*      * Overview:      *      * The primary design goal of this hash table is to maintain      * concurrent readability (typically method get(), but also      * iterators and related methods) while minimizing update      * contention. Secondary goals are to keep space consumption about      * the same or better than java.util.HashMap, and to support high      * initial insertion rates on an empty table by many threads.      *      * Each key-value mapping is held in a Node.  Because Node key      * fields can contain special values, they are defined using plain      * Object types (not type "K"). This leads to a lot of explicit      * casting (and many explicit warning suppressions to tell      * compilers not to complain about it). It also allows some of the      * public methods to be factored into a smaller number of internal      * methods (although sadly not so for the five variants of      * put-related operations). The validation-based approach      * explained below leads to a lot of code sprawl because      * retry-control precludes factoring into smaller methods.      *      * The table is lazily initialized to a power-of-two size upon the      * first insertion.  Each bin in the table normally contains a      * list of Nodes (most often, the list has only zero or one Node).      * Table accesses require volatile/atomic reads, writes, and      * CASes.  Because there is no other way to arrange this without      * adding further indirections, we use intrinsics      * (sun.misc.Unsafe) operations.  The lists of nodes within bins      * are always accurately traversable under volatile reads, so long      * as lookups check hash code and non-nullness of value before      * checking key equality.      *      * We use the top (sign) bit of Node hash fields for control      * purposes -- it is available anyway because of addressing      * constraints.  Nodes with negative hash fields are forwarding      * nodes to either TreeBins or resized tables.  The lower 31 bits      * of each normal Node's hash field contain a transformation of      * the key's hash code.      *      * Insertion (via put or its variants) of the first node in an      * empty bin is performed by just CASing it to the bin.  This is      * by far the most common case for put operations under most      * key/hash distributions.  Other update operations (insert,      * delete, and replace) require locks.  We do not want to waste      * the space required to associate a distinct lock object with      * each bin, so instead use the first node of a bin list itself as      * a lock. Locking support for these locks relies on builtin      * "synchronized" monitors.      *      * Using the first node of a list as a lock does not by itself      * suffice though: When a node is locked, any update must first      * validate that it is still the first node after locking it, and      * retry if not. Because new nodes are always appended to lists,      * once a node is first in a bin, it remains first until deleted      * or the bin becomes invalidated (upon resizing).  However,      * operations that only conditionally update may inspect nodes      * until the point of update. This is a converse of sorts to the      * lazy locking technique described by Herlihy& Shavit.      *      * The main disadvantage of per-bin locks is that other update      * operations on other nodes in a bin list protected by the same      * lock can stall, for example when user equals() or mapping      * functions take a long time.  However, statistically, under      * random hash codes, this is not a common problem.  Ideally, the      * frequency of nodes in bins follows a Poisson distribution      * (http://en.wikipedia.org/wiki/Poisson_distribution) with a      * parameter of about 0.5 on average, given the resizing threshold      * of 0.75, although with a large variance because of resizing      * granularity. Ignoring variance, the expected occurrences of      * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The      * first values are:      *      * 0:    0.60653066      * 1:    0.30326533      * 2:    0.07581633      * 3:    0.01263606      * 4:    0.00157952      * 5:    0.00015795      * 6:    0.00001316      * 7:    0.00000094      * 8:    0.00000006      * more: less than 1 in ten million      *      * Lock contention probability for two threads accessing distinct      * elements is roughly 1 / (8 * #elements) under random hashes.      *      * Actual hash code distributions encountered in practice      * sometimes deviate significantly from uniform randomness.  This      * includes the case when N> (1<<30), so some keys MUST collide.      * Similarly for dumb or hostile usages in which multiple keys are      * designed to have identical hash codes. Also, although we guard      * against the worst effects of this (see method spread), sets of      * hashes may differ only in bits that do not impact their bin      * index for a given power-of-two mask.  So we use a secondary      * strategy that applies when the number of nodes in a bin exceeds      * a threshold, and at least one of the keys implements      * Comparable.  These TreeBins use a balanced tree to hold nodes      * (a specialized form of red-black trees), bounding search time      * to O(log N).  Each search step in a TreeBin is around twice as      * slow as in a regular list, but given that N cannot exceed      * (1<<64) (before running out of addresses) this bounds search      * steps, lock hold times, etc, to reasonable constants (roughly      * 100 nodes inspected per operation worst case) so long as keys      * are Comparable (which is very common -- String, Long, etc).      * TreeBin nodes (TreeNodes) also maintain the same "next"      * traversal pointers as regular nodes, so can be traversed in      * iterators in the same way.      *      * The table is resized when occupancy exceeds a percentage      * threshold (nominally, 0.75, but see below).  Any thread      * noticing an overfull bin may assist in resizing after the      * initiating thread allocates and sets up the replacement      * array. However, rather than stalling, these other threads may      * proceed with insertions etc.  The use of TreeBins shields us      * from the worst case effects of overfilling while resizes are in      * progress.  Resizing proceeds by transferring bins, one by one,      * from the table to the next table. To enable concurrency, the      * next table must be (incrementally) prefilled with place-holders      * serving as reverse forwarders to the old table.  Because we are      * using power-of-two expansion, the elements from each bin must      * either stay at same index, or move with a power of two      * offset. We eliminate unnecessary node creation by catching      * cases where old nodes can be reused because their next fields      * won't change.  On average, only about one-sixth of them need      * cloning when a table doubles. The nodes they replace will be      * garbage collectable as soon as they are no longer referenced by      * any reader thread that may be in the midst of concurrently      * traversing table.  Upon transfer, the old table bin contains      * only a special forwarding node (with hash field "MOVED") that      * contains the next table as its key. On encountering a      * forwarding node, access and update operations restart, using      * the new table.      *      * Each bin transfer requires its bin lock, which can stall      * waiting for locks while resizing. However, because other      * threads can join in and help resize rather than contend for      * locks, average aggregate waits become shorter as resizing      * progresses.  The transfer operation must also ensure that all      * accessible bins in both the old and new table are usable by any      * traversal.  This is arranged by proceeding from the last bin      * (table.length - 1) up towards the first.  Upon seeing a      * forwarding node, traversals (see class Traverser) arrange to      * move to the new table without revisiting nodes.  However, to      * ensure that no intervening nodes are skipped, bin splitting can      * only begin after the associated reverse-forwarders are in      * place.      *      * The traversal scheme also applies to partial traversals of      * ranges of bins (via an alternate Traverser constructor)      * to support partitioned aggregate operations.  Also, read-only      * operations give up if ever forwarded to a null table, which      * provides support for shutdown-style clearing, which is also not      * currently implemented.      *      * Lazy table initialization minimizes footprint until first use,      * and also avoids resizings when the first operation is from a      * putAll, constructor with map argument, or deserialization.      * These cases attempt to override the initial capacity settings,      * but harmlessly fail to take effect in cases of races.      *      * The element count is maintained using a specialization of      * LongAdder. We need to incorporate a specialization rather than      * just use a LongAdder in order to access implicit      * contention-sensing that leads to creation of multiple      * CounterCells.  The counter mechanics avoid contention on      * updates but can encounter cache thrashing if read too      * frequently during concurrent access. To avoid reading so often,      * resizing under contention is attempted only upon adding to a      * bin already holding two or more nodes. Under uniform hash      * distributions, the probability of this occurring at threshold      * is around 13%, meaning that only about 1 in 8 puts check      * threshold (and after resizing, many fewer do so). The bulk      * putAll operation further reduces contention by only committing      * count updates upon these size checks.      *      * Maintaining API and serialization compatibility with previous      * versions of this class introduces several oddities. Mainly: We      * leave untouched but unused constructor arguments refering to      * concurrencyLevel. We accept a loadFactor constructor argument,      * but apply it only to initial table capacity (which is the only      * time that we can guarantee to honor it.) We also declare an      * unused "Segment" class that is instantiated in minimal form      * only when serializing.      */
comment|/* ---------------- Constants -------------- */
comment|/**      * The largest possible table capacity.  This value must be      * exactly 1<<30 to stay within Java array allocation and indexing      * bounds for power of two table sizes, and is further required      * because the top two bits of 32bit hash fields are used for      * control purposes.      */
DECL|field|MAXIMUM_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|MAXIMUM_CAPACITY
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|/**      * The default initial table capacity.  Must be a power of 2      * (i.e., at least 1) and at most MAXIMUM_CAPACITY.      */
DECL|field|DEFAULT_CAPACITY
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CAPACITY
init|=
literal|16
decl_stmt|;
comment|/**      * The largest possible (non-power of two) array size.      * Needed by toArray and related methods.      */
DECL|field|MAX_ARRAY_SIZE
specifier|static
specifier|final
name|int
name|MAX_ARRAY_SIZE
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|8
decl_stmt|;
comment|/**      * The default concurrency level for this table. Unused but      * defined for compatibility with previous versions of this class.      */
DECL|field|DEFAULT_CONCURRENCY_LEVEL
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_CONCURRENCY_LEVEL
init|=
literal|16
decl_stmt|;
comment|/**      * The load factor for this table. Overrides of this value in      * constructors affect only the initial table capacity.  The      * actual floating point value isn't normally used -- it is      * simpler to use expressions such as {@code n - (n>>> 2)} for      * the associated resizing threshold.      */
DECL|field|LOAD_FACTOR
specifier|private
specifier|static
specifier|final
name|float
name|LOAD_FACTOR
init|=
literal|0.75f
decl_stmt|;
comment|/**      * The bin count threshold for using a tree rather than list for a      * bin.  The value reflects the approximate break-even point for      * using tree-based operations.      */
DECL|field|TREE_THRESHOLD
specifier|private
specifier|static
specifier|final
name|int
name|TREE_THRESHOLD
init|=
literal|8
decl_stmt|;
comment|/**      * Minimum number of rebinnings per transfer step. Ranges are      * subdivided to allow multiple resizer threads.  This value      * serves as a lower bound to avoid resizers encountering      * excessive memory contention.  The value should be at least      * DEFAULT_CAPACITY.      */
DECL|field|MIN_TRANSFER_STRIDE
specifier|private
specifier|static
specifier|final
name|int
name|MIN_TRANSFER_STRIDE
init|=
literal|16
decl_stmt|;
comment|/*      * Encodings for Node hash fields. See above for explanation.      */
DECL|field|MOVED
specifier|static
specifier|final
name|int
name|MOVED
init|=
literal|0x80000000
decl_stmt|;
comment|// hash field for forwarding nodes
DECL|field|HASH_BITS
specifier|static
specifier|final
name|int
name|HASH_BITS
init|=
literal|0x7fffffff
decl_stmt|;
comment|// usable bits of normal node hash
comment|/** Number of CPUS, to place bounds on some sizings */
DECL|field|NCPU
specifier|static
specifier|final
name|int
name|NCPU
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
decl_stmt|;
comment|/* ---------------- Counters -------------- */
comment|// Adapted from LongAdder and Striped64.
comment|// See their internal docs for explanation.
comment|// A padded cell for distributing counts
DECL|class|CounterCell
specifier|static
specifier|final
class|class
name|CounterCell
block|{
DECL|field|p0
DECL|field|p1
DECL|field|p2
DECL|field|p3
DECL|field|p4
DECL|field|p5
DECL|field|p6
specifier|volatile
name|long
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|p4
decl_stmt|,
name|p5
decl_stmt|,
name|p6
decl_stmt|;
DECL|field|value
specifier|volatile
name|long
name|value
decl_stmt|;
DECL|field|q0
DECL|field|q1
DECL|field|q2
DECL|field|q3
DECL|field|q4
DECL|field|q5
DECL|field|q6
specifier|volatile
name|long
name|q0
decl_stmt|,
name|q1
decl_stmt|,
name|q2
decl_stmt|,
name|q3
decl_stmt|,
name|q4
decl_stmt|,
name|q5
decl_stmt|,
name|q6
decl_stmt|;
DECL|method|CounterCell
name|CounterCell
parameter_list|(
name|long
name|x
parameter_list|)
block|{
name|value
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/**      * Holder for the thread-local hash code determining which      * CounterCell to use. The code is initialized via the      * counterHashCodeGenerator, but may be moved upon collisions.      */
DECL|class|CounterHashCode
specifier|static
specifier|final
class|class
name|CounterHashCode
block|{
DECL|field|code
name|int
name|code
decl_stmt|;
block|}
comment|/**      * Generates initial value for per-thread CounterHashCodes      */
DECL|field|counterHashCodeGenerator
specifier|static
specifier|final
name|AtomicInteger
name|counterHashCodeGenerator
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/**      * Increment for counterHashCodeGenerator. See class ThreadLocal      * for explanation.      */
DECL|field|SEED_INCREMENT
specifier|static
specifier|final
name|int
name|SEED_INCREMENT
init|=
literal|0x61c88647
decl_stmt|;
comment|/**      * Per-thread counter hash codes. Shared across all instances.      */
DECL|field|threadCounterHashCode
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|CounterHashCode
argument_list|>
name|threadCounterHashCode
init|=
operator|new
name|ThreadLocal
argument_list|<
name|CounterHashCode
argument_list|>
argument_list|()
decl_stmt|;
comment|/* ---------------- Fields -------------- */
comment|/**      * The array of bins. Lazily initialized upon first insertion.      * Size is always a power of two. Accessed directly by iterators.      */
DECL|field|table
specifier|transient
specifier|volatile
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|table
decl_stmt|;
comment|/**      * The next table to use; non-null only while resizing.      */
DECL|field|nextTable
specifier|private
specifier|transient
specifier|volatile
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|nextTable
decl_stmt|;
comment|/**      * Base counter value, used mainly when there is no contention,      * but also as a fallback during table initialization      * races. Updated via CAS.      */
DECL|field|baseCount
specifier|private
specifier|transient
specifier|volatile
name|long
name|baseCount
decl_stmt|;
comment|/**      * Table initialization and resizing control.  When negative, the      * table is being initialized or resized: -1 for initialization,      * else -(1 + the number of active resizing threads).  Otherwise,      * when table is null, holds the initial table size to use upon      * creation, or 0 for default. After initialization, holds the      * next element count value upon which to resize the table.      */
DECL|field|sizeCtl
specifier|private
specifier|transient
specifier|volatile
name|int
name|sizeCtl
decl_stmt|;
comment|/**      * The next table index (plus one) to split while resizing.      */
DECL|field|transferIndex
specifier|private
specifier|transient
specifier|volatile
name|int
name|transferIndex
decl_stmt|;
comment|/**      * The least available table index to split while resizing.      */
DECL|field|transferOrigin
specifier|private
specifier|transient
specifier|volatile
name|int
name|transferOrigin
decl_stmt|;
comment|/**      * Spinlock (locked via CAS) used when resizing and/or creating Cells.      */
DECL|field|counterBusy
specifier|private
specifier|transient
specifier|volatile
name|int
name|counterBusy
decl_stmt|;
comment|/**      * Table of counter cells. When non-null, size is a power of 2.      */
DECL|field|counterCells
specifier|private
specifier|transient
specifier|volatile
name|CounterCell
index|[]
name|counterCells
decl_stmt|;
comment|// views
DECL|field|keySet
specifier|private
specifier|transient
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keySet
decl_stmt|;
DECL|field|values
specifier|private
specifier|transient
name|ValuesView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|values
decl_stmt|;
DECL|field|entrySet
specifier|private
specifier|transient
name|EntrySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entrySet
decl_stmt|;
comment|/** For serialization compatibility. Null unless serialized; see below */
DECL|field|segments
specifier|private
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
name|segments
decl_stmt|;
comment|/* ---------------- Table element access -------------- */
comment|/*      * Volatile access methods are used for table elements as well as      * elements of in-progress next table while resizing.  Uses are      * null checked by callers, and implicitly bounds-checked, relying      * on the invariants that tab arrays have non-zero size, and all      * indices are masked with (tab.length - 1) which is never      * negative and always less than length. Note that, to be correct      * wrt arbitrary concurrency errors by users, bounds checks must      * operate on local variables, which accounts for some odd-looking      * inline assignments below.      */
DECL|method|tabAt
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|static
specifier|final
parameter_list|<
name|V
parameter_list|>
name|Node
argument_list|<
name|V
argument_list|>
name|tabAt
parameter_list|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|)
block|{
comment|// used by Traverser
return|return
operator|(
name|Node
argument_list|<
name|V
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|)
return|;
block|}
DECL|method|casTabAt
specifier|private
specifier|static
specifier|final
parameter_list|<
name|V
parameter_list|>
name|boolean
name|casTabAt
parameter_list|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|,
name|Node
argument_list|<
name|V
argument_list|>
name|c
parameter_list|,
name|Node
argument_list|<
name|V
argument_list|>
name|v
parameter_list|)
block|{
return|return
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|c
argument_list|,
name|v
argument_list|)
return|;
block|}
DECL|method|setTabAt
specifier|private
specifier|static
specifier|final
parameter_list|<
name|V
parameter_list|>
name|void
name|setTabAt
parameter_list|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|i
parameter_list|,
name|Node
argument_list|<
name|V
argument_list|>
name|v
parameter_list|)
block|{
name|U
operator|.
name|putObjectVolatile
argument_list|(
name|tab
argument_list|,
operator|(
operator|(
name|long
operator|)
name|i
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* ---------------- Nodes -------------- */
comment|/**      * Key-value entry. Note that this is never exported out as a      * user-visible Map.Entry (see MapEntry below). Nodes with a hash      * field of MOVED are special, and do not contain user keys or      * values.  Otherwise, keys are never null, and null val fields      * indicate that a node is in the process of being deleted or      * created. For purposes of read-only access, a key may be read      * before a val, but can only be used after checking val to be      * non-null.      */
DECL|class|Node
specifier|static
class|class
name|Node
parameter_list|<
name|V
parameter_list|>
block|{
DECL|field|hash
specifier|final
name|int
name|hash
decl_stmt|;
DECL|field|key
specifier|final
name|Object
name|key
decl_stmt|;
DECL|field|val
specifier|volatile
name|V
name|val
decl_stmt|;
DECL|field|next
specifier|volatile
name|Node
argument_list|<
name|V
argument_list|>
name|next
decl_stmt|;
DECL|method|Node
name|Node
parameter_list|(
name|int
name|hash
parameter_list|,
name|Object
name|key
parameter_list|,
name|V
name|val
parameter_list|,
name|Node
argument_list|<
name|V
argument_list|>
name|next
parameter_list|)
block|{
name|this
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|next
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* ---------------- TreeBins -------------- */
comment|/**      * Nodes for use in TreeBins      */
DECL|class|TreeNode
specifier|static
specifier|final
class|class
name|TreeNode
parameter_list|<
name|V
parameter_list|>
extends|extends
name|Node
argument_list|<
name|V
argument_list|>
block|{
DECL|field|parent
name|TreeNode
argument_list|<
name|V
argument_list|>
name|parent
decl_stmt|;
comment|// red-black tree links
DECL|field|left
name|TreeNode
argument_list|<
name|V
argument_list|>
name|left
decl_stmt|;
DECL|field|right
name|TreeNode
argument_list|<
name|V
argument_list|>
name|right
decl_stmt|;
DECL|field|prev
name|TreeNode
argument_list|<
name|V
argument_list|>
name|prev
decl_stmt|;
comment|// needed to unlink next upon deletion
DECL|field|red
name|boolean
name|red
decl_stmt|;
DECL|method|TreeNode
name|TreeNode
parameter_list|(
name|int
name|hash
parameter_list|,
name|Object
name|key
parameter_list|,
name|V
name|val
parameter_list|,
name|Node
argument_list|<
name|V
argument_list|>
name|next
parameter_list|,
name|TreeNode
argument_list|<
name|V
argument_list|>
name|parent
parameter_list|)
block|{
name|super
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
block|}
block|}
comment|/**      * A specialized form of red-black tree for use in bins      * whose size exceeds a threshold.      *      * TreeBins use a special form of comparison for search and      * related operations (which is the main reason we cannot use      * existing collections such as TreeMaps). TreeBins contain      * Comparable elements, but may contain others, as well as      * elements that are Comparable but not necessarily Comparable<T>      * for the same T, so we cannot invoke compareTo among them. To      * handle this, the tree is ordered primarily by hash value, then      * by getClass().getName() order, and then by Comparator order      * among elements of the same class.  On lookup at a node, if      * elements are not comparable or compare as 0, both left and      * right children may need to be searched in the case of tied hash      * values. (This corresponds to the full list search that would be      * necessary if all elements were non-Comparable and had tied      * hashes.)  The red-black balancing code is updated from      * pre-jdk-collections      * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)      * based in turn on Cormen, Leiserson, and Rivest "Introduction to      * Algorithms" (CLR).      *      * TreeBins also maintain a separate locking discipline than      * regular bins. Because they are forwarded via special MOVED      * nodes at bin heads (which can never change once established),      * we cannot use those nodes as locks. Instead, TreeBin      * extends AbstractQueuedSynchronizer to support a simple form of      * read-write lock. For update operations and table validation,      * the exclusive form of lock behaves in the same way as bin-head      * locks. However, lookups use shared read-lock mechanics to allow      * multiple readers in the absence of writers.  Additionally,      * these lookups do not ever block: While the lock is not      * available, they proceed along the slow traversal path (via      * next-pointers) until the lock becomes available or the list is      * exhausted, whichever comes first. (These cases are not fast,      * but maximize aggregate expected throughput.)  The AQS mechanics      * for doing this are straightforward.  The lock state is held as      * AQS getState().  Read counts are negative; the write count (1)      * is positive.  There are no signalling preferences among readers      * and writers. Since we don't need to export full Lock API, we      * just override the minimal AQS methods and use them directly.      */
DECL|class|TreeBin
specifier|static
specifier|final
class|class
name|TreeBin
parameter_list|<
name|V
parameter_list|>
extends|extends
name|AbstractQueuedSynchronizer
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2249069246763182397L
decl_stmt|;
DECL|field|root
specifier|transient
name|TreeNode
argument_list|<
name|V
argument_list|>
name|root
decl_stmt|;
comment|// root of tree
DECL|field|first
specifier|transient
name|TreeNode
argument_list|<
name|V
argument_list|>
name|first
decl_stmt|;
comment|// head of next-pointer list
comment|/* AQS overrides */
DECL|method|isHeldExclusively
specifier|public
specifier|final
name|boolean
name|isHeldExclusively
parameter_list|()
block|{
return|return
name|getState
argument_list|()
operator|>
literal|0
return|;
block|}
DECL|method|tryAcquire
specifier|public
specifier|final
name|boolean
name|tryAcquire
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
if|if
condition|(
name|compareAndSetState
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|setExclusiveOwnerThread
argument_list|(
name|Thread
operator|.
name|currentThread
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|method|tryRelease
specifier|public
specifier|final
name|boolean
name|tryRelease
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|setExclusiveOwnerThread
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|setState
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|tryAcquireShared
specifier|public
specifier|final
name|int
name|tryAcquireShared
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getState
argument_list|()
operator|)
operator|>
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|compareAndSetState
argument_list|(
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
DECL|method|tryReleaseShared
specifier|public
specifier|final
name|boolean
name|tryReleaseShared
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|compareAndSetState
argument_list|(
name|c
operator|=
name|getState
argument_list|()
argument_list|,
name|c
operator|+
literal|1
argument_list|)
condition|)
do|;
return|return
name|c
operator|==
operator|-
literal|1
return|;
block|}
comment|/** From CLR */
DECL|method|rotateLeft
specifier|private
name|void
name|rotateLeft
parameter_list|(
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|r
init|=
name|p
operator|.
name|right
decl_stmt|,
name|pp
decl_stmt|,
name|rl
decl_stmt|;
if|if
condition|(
operator|(
name|rl
operator|=
name|p
operator|.
name|right
operator|=
name|r
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
name|rl
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|r
operator|.
name|parent
operator|=
name|p
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
name|root
operator|=
name|r
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|.
name|left
operator|==
name|p
condition|)
name|pp
operator|.
name|left
operator|=
name|r
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|r
expr_stmt|;
name|r
operator|.
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|parent
operator|=
name|r
expr_stmt|;
block|}
block|}
comment|/** From CLR */
DECL|method|rotateRight
specifier|private
name|void
name|rotateRight
parameter_list|(
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|l
init|=
name|p
operator|.
name|left
decl_stmt|,
name|pp
decl_stmt|,
name|lr
decl_stmt|;
if|if
condition|(
operator|(
name|lr
operator|=
name|p
operator|.
name|left
operator|=
name|l
operator|.
name|right
operator|)
operator|!=
literal|null
condition|)
name|lr
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|l
operator|.
name|parent
operator|=
name|p
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
name|root
operator|=
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|pp
operator|.
name|right
operator|==
name|p
condition|)
name|pp
operator|.
name|right
operator|=
name|l
expr_stmt|;
else|else
name|pp
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|l
operator|.
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|.
name|parent
operator|=
name|l
expr_stmt|;
block|}
block|}
comment|/**          * Returns the TreeNode (or null if not found) for the given key          * starting at given root.          */
DECL|method|getTreeNode
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|TreeNode
argument_list|<
name|V
argument_list|>
name|getTreeNode
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|,
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|k
operator|.
name|getClass
argument_list|()
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|int
name|dir
decl_stmt|,
name|ph
decl_stmt|;
name|Object
name|pk
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|pc
decl_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|p
operator|.
name|hash
operator|)
operator|==
name|h
condition|)
block|{
if|if
condition|(
operator|(
name|pk
operator|=
name|p
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|pk
argument_list|)
condition|)
return|return
name|p
return|;
if|if
condition|(
name|c
operator|!=
operator|(
name|pc
operator|=
name|pk
operator|.
name|getClass
argument_list|()
operator|)
operator|||
operator|!
operator|(
name|k
operator|instanceof
name|Comparable
operator|)
operator|||
operator|(
name|dir
operator|=
operator|(
operator|(
name|Comparable
operator|)
name|k
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Comparable
operator|)
name|pk
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|dir
operator|=
operator|(
name|c
operator|==
name|pc
operator|)
condition|?
literal|0
else|:
name|c
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|pc
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|r
init|=
literal|null
decl_stmt|,
name|pl
decl_stmt|,
name|pr
decl_stmt|;
comment|// check both sides
if|if
condition|(
operator|(
name|pr
operator|=
name|p
operator|.
name|right
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|>=
name|pr
operator|.
name|hash
operator|&&
operator|(
name|r
operator|=
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|pr
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|r
return|;
elseif|else
if|if
condition|(
operator|(
name|pl
operator|=
name|p
operator|.
name|left
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|<=
name|pl
operator|.
name|hash
condition|)
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
else|else
comment|// nothing there
return|return
literal|null
return|;
block|}
block|}
block|}
else|else
name|dir
operator|=
operator|(
name|h
operator|<
name|ph
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|dir
operator|>
literal|0
operator|)
condition|?
name|p
operator|.
name|right
else|:
name|p
operator|.
name|left
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Wrapper for getTreeNode used by CHM.get. Tries to obtain          * read-lock to call getTreeNode, but during failure to get          * lock, searches along next links.          */
DECL|method|getValue
specifier|final
name|V
name|getValue
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|r
init|=
literal|null
decl_stmt|;
name|int
name|c
init|=
name|getState
argument_list|()
decl_stmt|;
comment|// Must read lock state first
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
name|c
operator|<=
literal|0
operator|&&
name|compareAndSetState
argument_list|(
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
name|r
operator|=
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|root
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|releaseShared
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
name|k
operator|.
name|equals
argument_list|(
name|e
operator|.
name|key
argument_list|)
condition|)
block|{
name|r
operator|=
name|e
expr_stmt|;
break|break;
block|}
else|else
name|c
operator|=
name|getState
argument_list|()
expr_stmt|;
block|}
return|return
name|r
operator|==
literal|null
condition|?
literal|null
else|:
name|r
operator|.
name|val
return|;
block|}
comment|/**          * Finds or adds a node.          * @return null if added          */
DECL|method|putTreeNode
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|TreeNode
argument_list|<
name|V
argument_list|>
name|putTreeNode
parameter_list|(
name|int
name|h
parameter_list|,
name|Object
name|k
parameter_list|,
name|V
name|v
parameter_list|)
block|{
name|Class
argument_list|<
name|?
argument_list|>
name|c
init|=
name|k
operator|.
name|getClass
argument_list|()
decl_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|pp
init|=
name|root
decl_stmt|,
name|p
init|=
literal|null
decl_stmt|;
name|int
name|dir
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|pp
operator|!=
literal|null
condition|)
block|{
comment|// find existing node or leaf to insert at
name|int
name|ph
decl_stmt|;
name|Object
name|pk
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|pc
decl_stmt|;
name|p
operator|=
name|pp
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|=
name|p
operator|.
name|hash
operator|)
operator|==
name|h
condition|)
block|{
if|if
condition|(
operator|(
name|pk
operator|=
name|p
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|pk
argument_list|)
condition|)
return|return
name|p
return|;
if|if
condition|(
name|c
operator|!=
operator|(
name|pc
operator|=
name|pk
operator|.
name|getClass
argument_list|()
operator|)
operator|||
operator|!
operator|(
name|k
operator|instanceof
name|Comparable
operator|)
operator|||
operator|(
name|dir
operator|=
operator|(
operator|(
name|Comparable
operator|)
name|k
operator|)
operator|.
name|compareTo
argument_list|(
operator|(
name|Comparable
operator|)
name|pk
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|s
init|=
literal|null
decl_stmt|,
name|r
init|=
literal|null
decl_stmt|,
name|pr
decl_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
operator|(
name|c
operator|==
name|pc
operator|)
condition|?
literal|0
else|:
name|c
operator|.
name|getName
argument_list|()
operator|.
name|compareTo
argument_list|(
name|pc
operator|.
name|getName
argument_list|()
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pr
operator|=
name|p
operator|.
name|right
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|>=
name|pr
operator|.
name|hash
operator|&&
operator|(
name|r
operator|=
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|pr
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|r
return|;
else|else
comment|// continue left
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pr
operator|=
name|p
operator|.
name|right
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|>=
name|pr
operator|.
name|hash
condition|)
name|s
operator|=
name|pr
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|s
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|r
return|;
block|}
block|}
else|else
name|dir
operator|=
operator|(
name|h
operator|<
name|ph
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|pp
operator|=
operator|(
name|dir
operator|>
literal|0
operator|)
condition|?
name|p
operator|.
name|right
else|:
name|p
operator|.
name|left
expr_stmt|;
block|}
name|TreeNode
argument_list|<
name|V
argument_list|>
name|f
init|=
name|first
decl_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|x
init|=
name|first
operator|=
operator|new
name|TreeNode
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
name|f
argument_list|,
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|root
operator|=
name|x
expr_stmt|;
else|else
block|{
comment|// attach and rebalance; adapted from CLR
name|TreeNode
argument_list|<
name|V
argument_list|>
name|xp
decl_stmt|,
name|xpp
decl_stmt|;
if|if
condition|(
name|f
operator|!=
literal|null
condition|)
name|f
operator|.
name|prev
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|dir
operator|<=
literal|0
condition|)
name|p
operator|.
name|left
operator|=
name|x
expr_stmt|;
else|else
name|p
operator|.
name|right
operator|=
name|x
expr_stmt|;
name|x
operator|.
name|red
operator|=
literal|true
expr_stmt|;
while|while
condition|(
name|x
operator|!=
literal|null
operator|&&
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|!=
literal|null
operator|&&
name|xp
operator|.
name|red
operator|&&
operator|(
name|xpp
operator|=
name|xp
operator|.
name|parent
operator|)
operator|!=
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|xppl
init|=
name|xpp
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|xp
operator|==
name|xppl
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|y
init|=
name|xpp
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|null
operator|&&
name|y
operator|.
name|red
condition|)
block|{
name|y
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xpp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|xp
operator|.
name|right
condition|)
block|{
name|rotateLeft
argument_list|(
name|x
operator|=
name|xp
argument_list|)
expr_stmt|;
name|xpp
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|xpp
operator|!=
literal|null
condition|)
block|{
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateRight
argument_list|(
name|xpp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|y
init|=
name|xppl
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|null
operator|&&
name|y
operator|.
name|red
condition|)
block|{
name|y
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xpp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|x
operator|==
name|xp
operator|.
name|left
condition|)
block|{
name|rotateRight
argument_list|(
name|x
operator|=
name|xp
argument_list|)
expr_stmt|;
name|xpp
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|xpp
operator|!=
literal|null
condition|)
block|{
name|xpp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateLeft
argument_list|(
name|xpp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|TreeNode
argument_list|<
name|V
argument_list|>
name|r
init|=
name|root
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|null
operator|&&
name|r
operator|.
name|red
condition|)
name|r
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Removes the given node, that must be present before this          * call.  This is messier than typical red-black deletion code          * because we cannot swap the contents of an interior node          * with a leaf successor that is pinned by "next" pointers          * that are accessible independently of lock. So instead we          * swap the tree linkages.          */
DECL|method|deleteTreeNode
specifier|final
name|void
name|deleteTreeNode
parameter_list|(
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
parameter_list|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|next
init|=
operator|(
name|TreeNode
argument_list|<
name|V
argument_list|>
operator|)
name|p
operator|.
name|next
decl_stmt|;
comment|// unlink traversal pointers
name|TreeNode
argument_list|<
name|V
argument_list|>
name|pred
init|=
name|p
operator|.
name|prev
decl_stmt|;
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
name|first
operator|=
name|next
expr_stmt|;
else|else
name|pred
operator|.
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
operator|!=
literal|null
condition|)
name|next
operator|.
name|prev
operator|=
name|pred
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|replacement
decl_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|pl
init|=
name|p
operator|.
name|left
decl_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|pr
init|=
name|p
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|pl
operator|!=
literal|null
operator|&&
name|pr
operator|!=
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|s
init|=
name|pr
decl_stmt|,
name|sl
decl_stmt|;
while|while
condition|(
operator|(
name|sl
operator|=
name|s
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
comment|// find successor
name|s
operator|=
name|sl
expr_stmt|;
name|boolean
name|c
init|=
name|s
operator|.
name|red
decl_stmt|;
name|s
operator|.
name|red
operator|=
name|p
operator|.
name|red
expr_stmt|;
name|p
operator|.
name|red
operator|=
name|c
expr_stmt|;
comment|// swap colors
name|TreeNode
argument_list|<
name|V
argument_list|>
name|sr
init|=
name|s
operator|.
name|right
decl_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|pp
init|=
name|p
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|pr
condition|)
block|{
comment|// p was s's direct parent
name|p
operator|.
name|parent
operator|=
name|s
expr_stmt|;
name|s
operator|.
name|right
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|sp
init|=
name|s
operator|.
name|parent
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|parent
operator|=
name|sp
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|sp
operator|.
name|left
condition|)
name|sp
operator|.
name|left
operator|=
name|p
expr_stmt|;
else|else
name|sp
operator|.
name|right
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|.
name|right
operator|=
name|pr
operator|)
operator|!=
literal|null
condition|)
name|pr
operator|.
name|parent
operator|=
name|s
expr_stmt|;
block|}
name|p
operator|.
name|left
operator|=
literal|null
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|right
operator|=
name|sr
operator|)
operator|!=
literal|null
condition|)
name|sr
operator|.
name|parent
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|left
operator|=
name|pl
operator|)
operator|!=
literal|null
condition|)
name|pl
operator|.
name|parent
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|.
name|parent
operator|=
name|pp
operator|)
operator|==
literal|null
condition|)
name|root
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
name|pp
operator|.
name|left
operator|=
name|s
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|s
expr_stmt|;
name|replacement
operator|=
name|sr
expr_stmt|;
block|}
else|else
name|replacement
operator|=
operator|(
name|pl
operator|!=
literal|null
operator|)
condition|?
name|pl
else|:
name|pr
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|pp
init|=
name|p
operator|.
name|parent
decl_stmt|;
if|if
condition|(
name|replacement
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|pp
operator|==
literal|null
condition|)
block|{
name|root
operator|=
literal|null
expr_stmt|;
return|return;
block|}
name|replacement
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|replacement
operator|.
name|parent
operator|=
name|pp
expr_stmt|;
if|if
condition|(
name|pp
operator|==
literal|null
condition|)
name|root
operator|=
name|replacement
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
name|pp
operator|.
name|left
operator|=
name|replacement
expr_stmt|;
else|else
name|pp
operator|.
name|right
operator|=
name|replacement
expr_stmt|;
name|p
operator|.
name|left
operator|=
name|p
operator|.
name|right
operator|=
name|p
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p
operator|.
name|red
condition|)
block|{
comment|// rebalance, from CLR
name|TreeNode
argument_list|<
name|V
argument_list|>
name|x
init|=
name|replacement
decl_stmt|;
while|while
condition|(
name|x
operator|!=
literal|null
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|xp
decl_stmt|,
name|xpl
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|red
operator|||
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|)
block|{
name|x
operator|.
name|red
operator|=
literal|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|x
operator|==
operator|(
name|xpl
operator|=
name|xp
operator|.
name|left
operator|)
condition|)
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|sib
init|=
name|xp
operator|.
name|right
decl_stmt|;
if|if
condition|(
name|sib
operator|!=
literal|null
operator|&&
name|sib
operator|.
name|red
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateLeft
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|==
literal|null
condition|)
name|x
operator|=
name|xp
expr_stmt|;
else|else
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|sl
init|=
name|sib
operator|.
name|left
decl_stmt|,
name|sr
init|=
name|sib
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
operator|)
operator|&&
operator|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
operator|)
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
condition|)
block|{
if|if
condition|(
name|sl
operator|!=
literal|null
condition|)
name|sl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateRight
argument_list|(
name|sib
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|right
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|!=
literal|null
condition|)
block|{
name|sib
operator|.
name|red
operator|=
operator|(
name|xp
operator|==
literal|null
operator|)
condition|?
literal|false
else|:
name|xp
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|sib
operator|.
name|right
operator|)
operator|!=
literal|null
condition|)
name|sr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|rotateLeft
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|root
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// symmetric
name|TreeNode
argument_list|<
name|V
argument_list|>
name|sib
init|=
name|xpl
decl_stmt|;
if|if
condition|(
name|sib
operator|!=
literal|null
operator|&&
name|sib
operator|.
name|red
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|xp
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateRight
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|==
literal|null
condition|)
name|x
operator|=
name|xp
expr_stmt|;
else|else
block|{
name|TreeNode
argument_list|<
name|V
argument_list|>
name|sl
init|=
name|sib
operator|.
name|left
decl_stmt|,
name|sr
init|=
name|sib
operator|.
name|right
decl_stmt|;
if|if
condition|(
operator|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
operator|)
operator|&&
operator|(
name|sr
operator|==
literal|null
operator|||
operator|!
name|sr
operator|.
name|red
operator|)
condition|)
block|{
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|x
operator|=
name|xp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sl
operator|==
literal|null
operator|||
operator|!
name|sl
operator|.
name|red
condition|)
block|{
if|if
condition|(
name|sr
operator|!=
literal|null
condition|)
name|sr
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|sib
operator|.
name|red
operator|=
literal|true
expr_stmt|;
name|rotateLeft
argument_list|(
name|sib
argument_list|)
expr_stmt|;
name|sib
operator|=
operator|(
name|xp
operator|=
name|x
operator|.
name|parent
operator|)
operator|==
literal|null
condition|?
literal|null
else|:
name|xp
operator|.
name|left
expr_stmt|;
block|}
if|if
condition|(
name|sib
operator|!=
literal|null
condition|)
block|{
name|sib
operator|.
name|red
operator|=
operator|(
name|xp
operator|==
literal|null
operator|)
condition|?
literal|false
else|:
name|xp
operator|.
name|red
expr_stmt|;
if|if
condition|(
operator|(
name|sl
operator|=
name|sib
operator|.
name|left
operator|)
operator|!=
literal|null
condition|)
name|sl
operator|.
name|red
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
literal|null
condition|)
block|{
name|xp
operator|.
name|red
operator|=
literal|false
expr_stmt|;
name|rotateRight
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|root
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|p
operator|==
name|replacement
operator|&&
operator|(
name|pp
operator|=
name|p
operator|.
name|parent
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|left
condition|)
comment|// detach pointers
name|pp
operator|.
name|left
operator|=
literal|null
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|pp
operator|.
name|right
condition|)
name|pp
operator|.
name|right
operator|=
literal|null
expr_stmt|;
name|p
operator|.
name|parent
operator|=
literal|null
expr_stmt|;
block|}
block|}
block|}
comment|/* ---------------- Collision reduction methods -------------- */
comment|/**      * Spreads higher bits to lower, and also forces top bit to 0.      * Because the table uses power-of-two masking, sets of hashes      * that vary only in bits above the current mask will always      * collide. (Among known examples are sets of Float keys holding      * consecutive whole numbers in small tables.)  To counter this,      * we apply a transform that spreads the impact of higher bits      * downward. There is a tradeoff between speed, utility, and      * quality of bit-spreading. Because many common sets of hashes      * are already reasonably distributed across bits (so don't benefit      * from spreading), and because we use trees to handle large sets      * of collisions in bins, we don't need excessively high quality.      */
DECL|method|spread
specifier|private
specifier|static
specifier|final
name|int
name|spread
parameter_list|(
name|int
name|h
parameter_list|)
block|{
name|h
operator|^=
operator|(
name|h
operator|>>>
literal|18
operator|)
operator|^
operator|(
name|h
operator|>>>
literal|12
operator|)
expr_stmt|;
return|return
operator|(
name|h
operator|^
operator|(
name|h
operator|>>>
literal|10
operator|)
operator|)
operator|&
name|HASH_BITS
return|;
block|}
comment|/**      * Replaces a list bin with a tree bin if key is comparable.  Call      * only when locked.      */
DECL|method|replaceWithTreeBin
specifier|private
specifier|final
name|void
name|replaceWithTreeBin
parameter_list|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|int
name|index
parameter_list|,
name|Object
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|instanceof
name|Comparable
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|new
name|TreeBin
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|index
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
name|t
operator|.
name|putTreeNode
argument_list|(
name|e
operator|.
name|hash
argument_list|,
name|e
operator|.
name|key
argument_list|,
name|e
operator|.
name|val
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|index
argument_list|,
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|MOVED
argument_list|,
name|t
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ---------------- Internal access and update methods -------------- */
comment|/** Implementation for get and containsKey */
DECL|method|internalGet
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|V
name|internalGet
parameter_list|(
name|Object
name|k
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|retry
label|:
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
name|tab
operator|!=
literal|null
condition|;
control|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|e
decl_stmt|;
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
name|int
name|eh
decl_stmt|;
comment|// locals to read fields once
for|for
control|(
name|e
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
operator|(
name|eh
operator|=
name|e
operator|.
name|hash
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
comment|// search TreeBin
return|return
operator|(
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|ek
operator|)
operator|.
name|getValue
argument_list|(
name|h
argument_list|,
name|k
argument_list|)
return|;
else|else
block|{
comment|// restart with new table
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|ek
expr_stmt|;
continue|continue
name|retry
continue|;
block|}
block|}
elseif|else
if|if
condition|(
name|eh
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
return|return
name|ev
return|;
block|}
break|break;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Implementation for the four public remove/replace methods:      * Replaces node value with v, conditional upon match of cv if      * non-null.  If resulting value is null, delete.      */
DECL|method|internalReplace
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|V
name|internalReplace
parameter_list|(
name|Object
name|k
parameter_list|,
name|V
name|v
parameter_list|,
name|Object
name|cv
parameter_list|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|oldVal
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
break|break;
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|V
name|pv
init|=
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
name|cv
operator|==
literal|null
operator|||
name|cv
operator|==
name|pv
operator|||
name|cv
operator|.
name|equals
argument_list|(
name|pv
argument_list|)
condition|)
block|{
name|oldVal
operator|=
name|pv
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|.
name|val
operator|=
name|v
operator|)
operator|==
literal|null
condition|)
block|{
name|deleted
operator|=
literal|true
expr_stmt|;
name|t
operator|.
name|deleteTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|validated
condition|)
block|{
if|if
condition|(
name|deleted
condition|)
name|addCount
argument_list|(
operator|-
literal|1L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fh
operator|!=
name|h
operator|&&
name|f
operator|.
name|next
operator|==
literal|null
condition|)
comment|// precheck
break|break;
comment|// rules out possible existence
else|else
block|{
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
name|boolean
name|deleted
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
control|)
block|{
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|)
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cv
operator|==
literal|null
operator|||
name|cv
operator|==
name|ev
operator|||
name|cv
operator|.
name|equals
argument_list|(
name|ev
argument_list|)
condition|)
block|{
name|oldVal
operator|=
name|ev
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|.
name|val
operator|=
name|v
operator|)
operator|==
literal|null
condition|)
block|{
name|deleted
operator|=
literal|true
expr_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|en
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|en
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|validated
condition|)
block|{
if|if
condition|(
name|deleted
condition|)
name|addCount
argument_list|(
operator|-
literal|1L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|oldVal
return|;
block|}
comment|/*      * Internal versions of insertion methods      * All have the same basic structure as the first (internalPut):      *  1. If table uninitialized, create      *  2. If bin empty, try to CAS new node      *  3. If bin stale, use new table      *  4. if bin converted to TreeBin, validate and relay to TreeBin methods      *  5. Lock and validate; if valid, scan and add or update      *      * The putAll method differs mainly in attempting to pre-allocate      * enough table space, and also more lazily performs count updates      * and checks.      *      * Most of the function-accepting methods can't be factored nicely      * because they require different functional forms, so instead      * sprawl out similar mechanics.      */
comment|/** Implementation for put and putIfAbsent */
DECL|method|internalPut
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|V
name|internalPut
parameter_list|(
name|K
name|k
parameter_list|,
name|V
name|v
parameter_list|,
name|boolean
name|onlyIfAbsent
parameter_list|)
block|{
if|if
condition|(
name|k
operator|==
literal|null
operator|||
name|v
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|,
name|fh
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|f
decl_stmt|;
name|Object
name|fk
decl_stmt|;
name|V
name|fv
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
break|break;
comment|// no lock when adding to empty bin
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|V
name|oldVal
init|=
literal|null
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
init|=
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|oldVal
operator|=
name|p
operator|.
name|val
expr_stmt|;
if|if
condition|(
operator|!
name|onlyIfAbsent
condition|)
name|p
operator|.
name|val
operator|=
name|v
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
return|return
name|oldVal
return|;
break|break;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|fk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|onlyIfAbsent
operator|&&
name|fh
operator|==
name|h
operator|&&
operator|(
name|fv
operator|=
name|f
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|fk
argument_list|)
operator|)
condition|)
comment|// peek while nearby
return|return
name|fv
return|;
else|else
block|{
name|V
name|oldVal
init|=
literal|null
decl_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|;
condition|;
operator|++
name|len
control|)
block|{
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|oldVal
operator|=
name|ev
expr_stmt|;
if|if
condition|(
operator|!
name|onlyIfAbsent
condition|)
name|e
operator|.
name|val
operator|=
name|v
expr_stmt|;
break|break;
block|}
name|Node
argument_list|<
name|V
argument_list|>
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|oldVal
operator|!=
literal|null
condition|)
return|return
name|oldVal
return|;
break|break;
block|}
block|}
block|}
name|addCount
argument_list|(
literal|1L
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|null
return|;
block|}
comment|/** Implementation for computeIfAbsent */
DECL|method|internalComputeIfAbsent
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|V
name|internalComputeIfAbsent
parameter_list|(
name|K
name|k
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|mf
parameter_list|)
block|{
if|if
condition|(
name|k
operator|==
literal|null
operator|||
name|mf
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|val
init|=
literal|null
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|node
init|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|node
init|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|node
operator|.
name|val
operator|=
name|val
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
name|val
operator|==
literal|null
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|hash
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|val
operator|=
name|p
operator|.
name|val
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|added
operator|=
literal|true
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|added
condition|)
return|return
name|val
return|;
break|break;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|fk
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
comment|// prescan
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
return|return
name|ev
return|;
block|}
name|boolean
name|added
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|;
condition|;
operator|++
name|len
control|)
block|{
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|ev
expr_stmt|;
break|break;
block|}
name|Node
argument_list|<
name|V
argument_list|>
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|added
operator|=
literal|true
expr_stmt|;
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|added
condition|)
return|return
name|val
return|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|addCount
argument_list|(
literal|1L
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/** Implementation for compute */
DECL|method|internalCompute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|V
name|internalCompute
parameter_list|(
name|K
name|k
parameter_list|,
name|boolean
name|onlyIfPresent
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|mf
parameter_list|)
block|{
if|if
condition|(
name|k
operator|==
literal|null
operator|||
name|mf
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|val
init|=
literal|null
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|onlyIfPresent
condition|)
break|break;
name|Node
argument_list|<
name|V
argument_list|>
name|node
init|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
synchronized|synchronized
init|(
name|node
init|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|node
argument_list|)
condition|)
block|{
try|try
block|{
name|len
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|k
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
operator|&&
name|onlyIfPresent
condition|)
break|break;
name|V
name|pv
init|=
operator|(
name|p
operator|==
literal|null
operator|)
condition|?
literal|null
else|:
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|k
argument_list|,
name|pv
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|.
name|deleteTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|fk
expr_stmt|;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
operator|++
name|len
control|)
block|{
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|k
argument_list|,
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|e
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|en
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|en
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|onlyIfPresent
operator|&&
operator|(
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|k
argument_list|,
literal|null
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|pred
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
name|addCount
argument_list|(
operator|(
name|long
operator|)
name|delta
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/** Implementation for merge */
DECL|method|internalMerge
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|V
name|internalMerge
parameter_list|(
name|K
name|k
parameter_list|,
name|V
name|v
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|mf
parameter_list|)
block|{
if|if
condition|(
name|k
operator|==
literal|null
operator|||
name|v
operator|==
literal|null
operator|||
name|mf
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|V
name|val
init|=
literal|null
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|f
decl_stmt|;
name|Object
name|fk
decl_stmt|;
name|V
name|fv
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
name|delta
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|v
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|hash
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
name|val
operator|=
operator|(
name|p
operator|==
literal|null
operator|)
condition|?
name|v
else|:
name|mf
operator|.
name|apply
argument_list|(
name|p
operator|.
name|val
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|len
operator|=
literal|2
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|t
operator|.
name|deleteTreeNode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|fk
expr_stmt|;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|,
name|pred
init|=
literal|null
init|;
condition|;
operator|++
name|len
control|)
block|{
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|val
operator|=
name|mf
operator|.
name|apply
argument_list|(
name|ev
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|null
condition|)
name|e
operator|.
name|val
operator|=
name|val
expr_stmt|;
else|else
block|{
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|en
init|=
name|e
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|pred
operator|!=
literal|null
condition|)
name|pred
operator|.
name|next
operator|=
name|en
expr_stmt|;
else|else
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|en
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pred
operator|=
name|e
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
name|val
operator|=
name|v
expr_stmt|;
name|pred
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|val
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0
condition|)
name|addCount
argument_list|(
operator|(
name|long
operator|)
name|delta
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/** Implementation for putAll */
DECL|method|internalPutAll
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|void
name|internalPutAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|tryPresize
argument_list|(
name|m
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|long
name|delta
init|=
literal|0L
decl_stmt|;
comment|// number of uncommitted additions
name|boolean
name|npe
init|=
literal|false
decl_stmt|;
comment|// to throw exception on exit for nulls
try|try
block|{
comment|// to clean up counts on other exceptions
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|entry
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|k
decl_stmt|;
name|V
name|v
decl_stmt|;
if|if
condition|(
name|entry
operator|==
literal|null
operator|||
operator|(
name|k
operator|=
name|entry
operator|.
name|getKey
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|v
operator|=
name|entry
operator|.
name|getValue
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|npe
operator|=
literal|true
expr_stmt|;
break|break;
block|}
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
init|;
condition|;
control|)
block|{
name|int
name|i
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|f
decl_stmt|;
name|int
name|fh
decl_stmt|;
name|Object
name|fk
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
condition|)
name|tab
operator|=
name|initTable
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
operator|=
operator|(
name|tab
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|h
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|delta
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fh
operator|=
name|f
operator|.
name|hash
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|boolean
name|validated
init|=
literal|false
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|validated
operator|=
literal|true
expr_stmt|;
name|TreeNode
argument_list|<
name|V
argument_list|>
name|p
init|=
name|t
operator|.
name|getTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|t
operator|.
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|val
operator|=
name|v
expr_stmt|;
else|else
block|{
name|t
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
operator|++
name|delta
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|validated
condition|)
break|break;
block|}
else|else
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|fk
expr_stmt|;
block|}
else|else
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|;
condition|;
operator|++
name|len
control|)
block|{
name|Object
name|ek
decl_stmt|;
name|V
name|ev
decl_stmt|;
if|if
condition|(
name|e
operator|.
name|hash
operator|==
name|h
operator|&&
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|!=
literal|null
operator|&&
operator|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|==
name|k
operator|||
name|k
operator|.
name|equals
argument_list|(
name|ek
argument_list|)
operator|)
condition|)
block|{
name|e
operator|.
name|val
operator|=
name|v
expr_stmt|;
break|break;
block|}
name|Node
argument_list|<
name|V
argument_list|>
name|last
init|=
name|e
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|e
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
operator|++
name|delta
expr_stmt|;
name|last
operator|.
name|next
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|TREE_THRESHOLD
condition|)
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|addCount
argument_list|(
name|delta
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|delta
operator|=
literal|0L
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
block|}
finally|finally
block|{
if|if
condition|(
name|delta
operator|!=
literal|0L
condition|)
name|addCount
argument_list|(
name|delta
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npe
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
comment|/**      * Implementation for clear. Steps through each bin, removing all      * nodes.      */
DECL|method|internalClear
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|void
name|internalClear
parameter_list|()
block|{
name|long
name|delta
init|=
literal|0L
decl_stmt|;
comment|// negative number of deletions
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
while|while
condition|(
name|tab
operator|!=
literal|null
operator|&&
name|i
operator|<
name|tab
operator|.
name|length
condition|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|f
init|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
literal|null
condition|)
operator|++
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|.
name|hash
operator|<
literal|0
condition|)
block|{
name|Object
name|fk
decl_stmt|;
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|p
init|=
name|t
operator|.
name|first
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
if|if
condition|(
name|p
operator|.
name|val
operator|!=
literal|null
condition|)
block|{
comment|// (currently always true)
name|p
operator|.
name|val
operator|=
literal|null
expr_stmt|;
operator|--
name|delta
expr_stmt|;
block|}
block|}
name|t
operator|.
name|first
operator|=
literal|null
expr_stmt|;
name|t
operator|.
name|root
operator|=
literal|null
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|fk
expr_stmt|;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|f
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
name|e
operator|.
name|val
operator|!=
literal|null
condition|)
block|{
comment|// (currently always true)
name|e
operator|.
name|val
operator|=
literal|null
expr_stmt|;
operator|--
name|delta
expr_stmt|;
block|}
block|}
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|delta
operator|!=
literal|0L
condition|)
name|addCount
argument_list|(
name|delta
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* ---------------- Table Initialization and Resizing -------------- */
comment|/**      * Returns a power of two table size for the given desired capacity.      * See Hackers Delight, sec 3.2      */
DECL|method|tableSizeFor
specifier|private
specifier|static
specifier|final
name|int
name|tableSizeFor
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|int
name|n
init|=
name|c
operator|-
literal|1
decl_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|1
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|2
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|4
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|8
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|16
expr_stmt|;
return|return
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
literal|1
else|:
operator|(
name|n
operator|>=
name|MAXIMUM_CAPACITY
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|n
operator|+
literal|1
return|;
block|}
comment|/**      * Initializes table, using the size recorded in sizeCtl.      */
DECL|method|initTable
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|initTable
parameter_list|()
block|{
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
decl_stmt|;
name|int
name|sc
decl_stmt|;
while|while
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|<
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// lost initialization race; just spin
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
operator|(
name|tab
operator|=
name|table
operator|)
operator|==
literal|null
condition|)
block|{
name|int
name|n
init|=
operator|(
name|sc
operator|>
literal|0
operator|)
condition|?
name|sc
else|:
name|DEFAULT_CAPACITY
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|Node
index|[]
name|tb
init|=
operator|new
name|Node
index|[
name|n
index|]
decl_stmt|;
name|table
operator|=
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|tb
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|tab
return|;
block|}
comment|/**      * Adds to count, and if table is too small and not already      * resizing, initiates transfer. If already resizing, helps      * perform transfer if work is available.  Rechecks occupancy      * after a transfer to see if another resize is already needed      * because resizings are lagging additions.      *      * @param x the count to add      * @param check if<0, don't check resize, if<= 1 only check if uncontended      */
DECL|method|addCount
specifier|private
specifier|final
name|void
name|addCount
parameter_list|(
name|long
name|x
parameter_list|,
name|int
name|check
parameter_list|)
block|{
name|CounterCell
index|[]
name|as
decl_stmt|;
name|long
name|b
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|as
operator|=
name|counterCells
operator|)
operator|!=
literal|null
operator|||
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|BASECOUNT
argument_list|,
name|b
operator|=
name|baseCount
argument_list|,
name|s
operator|=
name|b
operator|+
name|x
argument_list|)
condition|)
block|{
name|CounterHashCode
name|hc
decl_stmt|;
name|CounterCell
name|a
decl_stmt|;
name|long
name|v
decl_stmt|;
name|int
name|m
decl_stmt|;
name|boolean
name|uncontended
init|=
literal|true
decl_stmt|;
if|if
condition|(
operator|(
name|hc
operator|=
name|threadCounterHashCode
operator|.
name|get
argument_list|()
operator|)
operator|==
literal|null
operator|||
name|as
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|as
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|0
operator|||
operator|(
name|a
operator|=
name|as
index|[
name|m
operator|&
name|hc
operator|.
name|code
index|]
operator|)
operator|==
literal|null
operator|||
operator|!
operator|(
name|uncontended
operator|=
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|a
argument_list|,
name|CELLVALUE
argument_list|,
name|v
operator|=
name|a
operator|.
name|value
argument_list|,
name|v
operator|+
name|x
argument_list|)
operator|)
condition|)
block|{
name|fullAddCount
argument_list|(
name|x
argument_list|,
name|hc
argument_list|,
name|uncontended
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|check
operator|<=
literal|1
condition|)
return|return;
name|s
operator|=
name|sumCount
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|check
operator|>=
literal|0
condition|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
decl_stmt|,
name|nt
decl_stmt|;
name|int
name|sc
decl_stmt|;
while|while
condition|(
name|s
operator|>=
call|(
name|long
call|)
argument_list|(
name|sc
operator|=
name|sizeCtl
argument_list|)
operator|&&
operator|(
name|tab
operator|=
name|table
operator|)
operator|!=
literal|null
operator|&&
name|tab
operator|.
name|length
operator|<
name|MAXIMUM_CAPACITY
condition|)
block|{
if|if
condition|(
name|sc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|==
operator|-
literal|1
operator|||
name|transferIndex
operator|<=
name|transferOrigin
operator|||
operator|(
name|nt
operator|=
name|nextTable
operator|)
operator|==
literal|null
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
name|sc
operator|-
literal|1
argument_list|)
condition|)
name|transfer
argument_list|(
name|tab
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
name|transfer
argument_list|(
name|tab
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|s
operator|=
name|sumCount
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Tries to presize table to accommodate the given number of elements.      *      * @param size number of elements (doesn't need to be perfectly accurate)      */
DECL|method|tryPresize
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|void
name|tryPresize
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|c
init|=
operator|(
name|size
operator|>=
operator|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
operator|)
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
name|size
operator|+
operator|(
name|size
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|sc
decl_stmt|;
while|while
condition|(
operator|(
name|sc
operator|=
name|sizeCtl
operator|)
operator|>=
literal|0
condition|)
block|{
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|tab
operator|==
literal|null
operator|||
operator|(
name|n
operator|=
name|tab
operator|.
name|length
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|(
name|sc
operator|>
name|c
operator|)
condition|?
name|sc
else|:
name|c
expr_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|table
operator|==
name|tab
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|Node
index|[]
name|tb
init|=
operator|new
name|Node
index|[
name|n
index|]
decl_stmt|;
name|table
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|tb
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
name|sc
operator|||
name|n
operator|>=
name|MAXIMUM_CAPACITY
condition|)
break|break;
elseif|else
if|if
condition|(
name|tab
operator|==
name|table
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
name|transfer
argument_list|(
name|tab
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Moves and/or copies the nodes in each bin to new table. See      * above for explanation.      */
DECL|method|transfer
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
specifier|final
name|void
name|transfer
parameter_list|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
parameter_list|,
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|nextTab
parameter_list|)
block|{
name|int
name|n
init|=
name|tab
operator|.
name|length
decl_stmt|,
name|stride
decl_stmt|;
if|if
condition|(
operator|(
name|stride
operator|=
operator|(
name|NCPU
operator|>
literal|1
operator|)
condition|?
operator|(
name|n
operator|>>>
literal|3
operator|)
operator|/
name|NCPU
else|:
name|n
operator|)
operator|<
name|MIN_TRANSFER_STRIDE
condition|)
name|stride
operator|=
name|MIN_TRANSFER_STRIDE
expr_stmt|;
comment|// subdivide range
if|if
condition|(
name|nextTab
operator|==
literal|null
condition|)
block|{
comment|// initiating
try|try
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|Node
index|[]
name|tb
init|=
operator|new
name|Node
index|[
name|n
operator|<<
literal|1
index|]
decl_stmt|;
name|nextTab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|tb
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
comment|// try to cope with OOME
name|sizeCtl
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
return|return;
block|}
name|nextTable
operator|=
name|nextTab
expr_stmt|;
name|transferOrigin
operator|=
name|n
expr_stmt|;
name|transferIndex
operator|=
name|n
expr_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|rev
init|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|MOVED
argument_list|,
name|tab
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
name|n
init|;
name|k
operator|>
literal|0
condition|;
control|)
block|{
comment|// progressively reveal ready slots
name|int
name|nextk
init|=
operator|(
name|k
operator|>
name|stride
operator|)
condition|?
name|k
operator|-
name|stride
else|:
literal|0
decl_stmt|;
for|for
control|(
name|int
name|m
init|=
name|nextk
init|;
name|m
operator|<
name|k
condition|;
operator|++
name|m
control|)
name|nextTab
index|[
name|m
index|]
operator|=
name|rev
expr_stmt|;
for|for
control|(
name|int
name|m
init|=
name|n
operator|+
name|nextk
init|;
name|m
operator|<
name|n
operator|+
name|k
condition|;
operator|++
name|m
control|)
name|nextTab
index|[
name|m
index|]
operator|=
name|rev
expr_stmt|;
name|U
operator|.
name|putOrderedInt
argument_list|(
name|this
argument_list|,
name|TRANSFERORIGIN
argument_list|,
name|k
operator|=
name|nextk
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|nextn
init|=
name|nextTab
operator|.
name|length
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|fwd
init|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|MOVED
argument_list|,
name|nextTab
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|boolean
name|advance
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|bound
init|=
literal|0
init|;
condition|;
control|)
block|{
name|int
name|nextIndex
decl_stmt|,
name|nextBound
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|f
decl_stmt|;
name|Object
name|fk
decl_stmt|;
while|while
condition|(
name|advance
condition|)
block|{
if|if
condition|(
operator|--
name|i
operator|>=
name|bound
condition|)
name|advance
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|nextIndex
operator|=
name|transferIndex
operator|)
operator|<=
name|transferOrigin
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|advance
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|TRANSFERINDEX
argument_list|,
name|nextIndex
argument_list|,
name|nextBound
operator|=
operator|(
name|nextIndex
operator|>
name|stride
condition|?
name|nextIndex
operator|-
name|stride
else|:
literal|0
operator|)
argument_list|)
condition|)
block|{
name|bound
operator|=
name|nextBound
expr_stmt|;
name|i
operator|=
name|nextIndex
operator|-
literal|1
expr_stmt|;
name|advance
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|n
operator|||
name|i
operator|+
name|n
operator|>=
name|nextn
condition|)
block|{
for|for
control|(
name|int
name|sc
init|;
condition|;
control|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
operator|=
name|sizeCtl
argument_list|,
operator|++
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|==
operator|-
literal|1
condition|)
block|{
name|nextTable
operator|=
literal|null
expr_stmt|;
name|table
operator|=
name|nextTab
expr_stmt|;
name|sizeCtl
operator|=
operator|(
name|n
operator|<<
literal|1
operator|)
operator|-
operator|(
name|n
operator|>>>
literal|1
operator|)
expr_stmt|;
block|}
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|,
name|fwd
argument_list|)
condition|)
block|{
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|n
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|advance
operator|=
literal|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|.
name|hash
operator|>=
literal|0
condition|)
block|{
synchronized|synchronized
init|(
name|f
init|)
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|int
name|runBit
init|=
name|f
operator|.
name|hash
operator|&
name|n
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|lastRun
init|=
name|f
decl_stmt|,
name|lo
init|=
literal|null
decl_stmt|,
name|hi
init|=
literal|null
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|p
init|=
name|f
operator|.
name|next
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|int
name|b
init|=
name|p
operator|.
name|hash
operator|&
name|n
decl_stmt|;
if|if
condition|(
name|b
operator|!=
name|runBit
condition|)
block|{
name|runBit
operator|=
name|b
expr_stmt|;
name|lastRun
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|runBit
operator|==
literal|0
condition|)
name|lo
operator|=
name|lastRun
expr_stmt|;
else|else
name|hi
operator|=
name|lastRun
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|p
init|=
name|f
init|;
name|p
operator|!=
name|lastRun
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
block|{
name|int
name|ph
init|=
name|p
operator|.
name|hash
decl_stmt|;
name|Object
name|pk
init|=
name|p
operator|.
name|key
decl_stmt|;
name|V
name|pv
init|=
name|p
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|ph
operator|&
name|n
operator|)
operator|==
literal|0
condition|)
name|lo
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|ph
argument_list|,
name|pk
argument_list|,
name|pv
argument_list|,
name|lo
argument_list|)
expr_stmt|;
else|else
name|hi
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|ph
argument_list|,
name|pk
argument_list|,
name|pv
argument_list|,
name|hi
argument_list|)
expr_stmt|;
block|}
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|lo
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|n
argument_list|,
name|hi
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|advance
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|fk
operator|=
name|f
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|t
init|=
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|fk
decl_stmt|;
name|t
operator|.
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
try|try
block|{
if|if
condition|(
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
operator|==
name|f
condition|)
block|{
name|TreeBin
argument_list|<
name|V
argument_list|>
name|lt
init|=
operator|new
name|TreeBin
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
name|TreeBin
argument_list|<
name|V
argument_list|>
name|ht
init|=
operator|new
name|TreeBin
argument_list|<
name|V
argument_list|>
argument_list|()
decl_stmt|;
name|int
name|lc
init|=
literal|0
decl_stmt|,
name|hc
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|t
operator|.
name|first
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
name|int
name|h
init|=
name|e
operator|.
name|hash
decl_stmt|;
name|Object
name|k
init|=
name|e
operator|.
name|key
decl_stmt|;
name|V
name|v
init|=
name|e
operator|.
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|&
name|n
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|lc
expr_stmt|;
name|lt
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|hc
expr_stmt|;
name|ht
operator|.
name|putTreeNode
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
name|Node
argument_list|<
name|V
argument_list|>
name|ln
decl_stmt|,
name|hn
decl_stmt|;
comment|// throw away trees if too small
if|if
condition|(
name|lc
operator|<
name|TREE_THRESHOLD
condition|)
block|{
name|ln
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|p
init|=
name|lt
operator|.
name|first
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
name|ln
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|p
operator|.
name|hash
argument_list|,
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
name|ln
argument_list|)
expr_stmt|;
block|}
else|else
name|ln
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|MOVED
argument_list|,
name|lt
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
name|hc
operator|<
name|TREE_THRESHOLD
condition|)
block|{
name|hn
operator|=
literal|null
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|p
init|=
name|ht
operator|.
name|first
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|p
operator|.
name|next
control|)
name|hn
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|p
operator|.
name|hash
argument_list|,
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
name|hn
argument_list|)
expr_stmt|;
block|}
else|else
name|hn
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|MOVED
argument_list|,
name|ht
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|nextTab
argument_list|,
name|i
operator|+
name|n
argument_list|,
name|hn
argument_list|)
expr_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|fwd
argument_list|)
expr_stmt|;
name|advance
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|t
operator|.
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|advance
operator|=
literal|true
expr_stmt|;
comment|// already processed
block|}
block|}
comment|/* ---------------- Counter support -------------- */
DECL|method|sumCount
specifier|final
name|long
name|sumCount
parameter_list|()
block|{
name|CounterCell
index|[]
name|as
init|=
name|counterCells
decl_stmt|;
name|CounterCell
name|a
decl_stmt|;
name|long
name|sum
init|=
name|baseCount
decl_stmt|;
if|if
condition|(
name|as
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|as
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|a
operator|=
name|as
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|sum
operator|+=
name|a
operator|.
name|value
expr_stmt|;
block|}
block|}
return|return
name|sum
return|;
block|}
comment|// See LongAdder version for explanation
DECL|method|fullAddCount
specifier|private
specifier|final
name|void
name|fullAddCount
parameter_list|(
name|long
name|x
parameter_list|,
name|CounterHashCode
name|hc
parameter_list|,
name|boolean
name|wasUncontended
parameter_list|)
block|{
name|int
name|h
decl_stmt|;
if|if
condition|(
name|hc
operator|==
literal|null
condition|)
block|{
name|hc
operator|=
operator|new
name|CounterHashCode
argument_list|()
expr_stmt|;
name|int
name|s
init|=
name|counterHashCodeGenerator
operator|.
name|addAndGet
argument_list|(
name|SEED_INCREMENT
argument_list|)
decl_stmt|;
name|h
operator|=
name|hc
operator|.
name|code
operator|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|s
expr_stmt|;
comment|// Avoid zero
name|threadCounterHashCode
operator|.
name|set
argument_list|(
name|hc
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|=
name|hc
operator|.
name|code
expr_stmt|;
name|boolean
name|collide
init|=
literal|false
decl_stmt|;
comment|// True if last slot nonempty
for|for
control|(
init|;
condition|;
control|)
block|{
name|CounterCell
index|[]
name|as
decl_stmt|;
name|CounterCell
name|a
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|as
operator|=
name|counterCells
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|n
operator|=
name|as
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|=
name|as
index|[
operator|(
name|n
operator|-
literal|1
operator|)
operator|&
name|h
index|]
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|counterBusy
operator|==
literal|0
condition|)
block|{
comment|// Try to attach new Cell
name|CounterCell
name|r
init|=
operator|new
name|CounterCell
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|// Optimistic create
if|if
condition|(
name|counterBusy
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|COUNTERBUSY
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|boolean
name|created
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Recheck under lock
name|CounterCell
index|[]
name|rs
decl_stmt|;
name|int
name|m
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|=
name|counterCells
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|rs
operator|.
name|length
operator|)
operator|>
literal|0
operator|&&
name|rs
index|[
name|j
operator|=
operator|(
name|m
operator|-
literal|1
operator|)
operator|&
name|h
index|]
operator|==
literal|null
condition|)
block|{
name|rs
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
name|created
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|counterBusy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|created
condition|)
break|break;
continue|continue;
comment|// Slot is now non-empty
block|}
block|}
name|collide
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wasUncontended
condition|)
comment|// CAS already known to fail
name|wasUncontended
operator|=
literal|true
expr_stmt|;
comment|// Continue after rehash
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|a
argument_list|,
name|CELLVALUE
argument_list|,
name|v
operator|=
name|a
operator|.
name|value
argument_list|,
name|v
operator|+
name|x
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|counterCells
operator|!=
name|as
operator|||
name|n
operator|>=
name|NCPU
condition|)
name|collide
operator|=
literal|false
expr_stmt|;
comment|// At max size or stale
elseif|else
if|if
condition|(
operator|!
name|collide
condition|)
name|collide
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
name|counterBusy
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|COUNTERBUSY
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|counterCells
operator|==
name|as
condition|)
block|{
comment|// Expand table unless stale
name|CounterCell
index|[]
name|rs
init|=
operator|new
name|CounterCell
index|[
name|n
operator|<<
literal|1
index|]
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|rs
index|[
name|i
index|]
operator|=
name|as
index|[
name|i
index|]
expr_stmt|;
name|counterCells
operator|=
name|rs
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|counterBusy
operator|=
literal|0
expr_stmt|;
block|}
name|collide
operator|=
literal|false
expr_stmt|;
continue|continue;
comment|// Retry with expanded table
block|}
name|h
operator|^=
name|h
operator|<<
literal|13
expr_stmt|;
comment|// Rehash
name|h
operator|^=
name|h
operator|>>>
literal|17
expr_stmt|;
name|h
operator|^=
name|h
operator|<<
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|counterBusy
operator|==
literal|0
operator|&&
name|counterCells
operator|==
name|as
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|COUNTERBUSY
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|boolean
name|init
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// Initialize table
if|if
condition|(
name|counterCells
operator|==
name|as
condition|)
block|{
name|CounterCell
index|[]
name|rs
init|=
operator|new
name|CounterCell
index|[
literal|2
index|]
decl_stmt|;
name|rs
index|[
name|h
operator|&
literal|1
index|]
operator|=
operator|new
name|CounterCell
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|counterCells
operator|=
name|rs
expr_stmt|;
name|init
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|counterBusy
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|BASECOUNT
argument_list|,
name|v
operator|=
name|baseCount
argument_list|,
name|v
operator|+
name|x
argument_list|)
condition|)
break|break;
comment|// Fall back on using base
block|}
name|hc
operator|.
name|code
operator|=
name|h
expr_stmt|;
comment|// Record index for next time
block|}
comment|/* ----------------Table Traversal -------------- */
comment|/**      * Encapsulates traversal for methods such as containsValue; also      * serves as a base class for other iterators and bulk tasks.      *      * At each step, the iterator snapshots the key ("nextKey") and      * value ("nextVal") of a valid node (i.e., one that, at point of      * snapshot, has a non-null user value). Because val fields can      * change (including to null, indicating deletion), field nextVal      * might not be accurate at point of use, but still maintains the      * weak consistency property of holding a value that was once      * valid. To support iterator.remove, the nextKey field is not      * updated (nulled out) when the iterator cannot advance.      *      * Internal traversals directly access these fields, as in:      * {@code while (it.advance() != null) { process(it.nextKey); }}      *      * Exported iterators must track whether the iterator has advanced      * (in hasNext vs next) (by setting/checking/nulling field      * nextVal), and then extract key, value, or key-value pairs as      * return values of next().      *      * The iterator visits once each still-valid node that was      * reachable upon iterator construction. It might miss some that      * were added to a bin after the bin was visited, which is OK wrt      * consistency guarantees. Maintaining this property in the face      * of possible ongoing resizes requires a fair amount of      * bookkeeping state that is difficult to optimize away amidst      * volatile accesses.  Even so, traversal maintains reasonable      * throughput.      *      * Normally, iteration proceeds bin-by-bin traversing lists.      * However, if the table has been resized, then all future steps      * must traverse both the bin at the current index as well as at      * (index + baseSize); and so on for further resizings. To      * paranoically cope with potential sharing by users of iterators      * across threads, iteration terminates if a bounds checks fails      * for a table read.      *      * This class extends CountedCompleter to streamline parallel      * iteration in bulk operations. This adds only a few fields of      * space overhead, which is small enough in cases where it is not      * needed to not worry about it.  Because CountedCompleter is      * Serializable, but iterators need not be, we need to add warning      * suppressions.      */
DECL|class|Traverser
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
class|class
name|Traverser
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|R
parameter_list|>
extends|extends
name|CountedCompleter
argument_list|<
name|R
argument_list|>
block|{
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|field|next
name|Node
argument_list|<
name|V
argument_list|>
name|next
decl_stmt|;
comment|// the next entry to use
DECL|field|nextKey
name|Object
name|nextKey
decl_stmt|;
comment|// cached key field of next
DECL|field|nextVal
name|V
name|nextVal
decl_stmt|;
comment|// cached val field of next
DECL|field|tab
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
decl_stmt|;
comment|// current table; updated if resized
DECL|field|index
name|int
name|index
decl_stmt|;
comment|// index of bin to use next
DECL|field|baseIndex
name|int
name|baseIndex
decl_stmt|;
comment|// current index of initial table
DECL|field|baseLimit
name|int
name|baseLimit
decl_stmt|;
comment|// index bound for initial table
DECL|field|baseSize
name|int
name|baseSize
decl_stmt|;
comment|// initial table size
DECL|field|batch
name|int
name|batch
decl_stmt|;
comment|// split control
comment|/** Creates iterator for all entries in the table. */
DECL|method|Traverser
name|Traverser
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
comment|/** Creates iterator for split() methods and task constructors */
DECL|method|Traverser
name|Traverser
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|it
parameter_list|,
name|int
name|batch
parameter_list|)
block|{
name|super
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|this
operator|.
name|batch
operator|=
name|batch
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|.
name|map
operator|=
name|map
operator|)
operator|!=
literal|null
operator|&&
name|it
operator|!=
literal|null
condition|)
block|{
comment|// split parent
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|it
operator|.
name|tab
operator|)
operator|==
literal|null
operator|&&
operator|(
name|t
operator|=
name|it
operator|.
name|tab
operator|=
name|map
operator|.
name|table
operator|)
operator|!=
literal|null
condition|)
name|it
operator|.
name|baseLimit
operator|=
name|it
operator|.
name|baseSize
operator|=
name|t
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|tab
operator|=
name|t
expr_stmt|;
name|this
operator|.
name|baseSize
operator|=
name|it
operator|.
name|baseSize
expr_stmt|;
name|int
name|hi
init|=
name|this
operator|.
name|baseLimit
operator|=
name|it
operator|.
name|baseLimit
decl_stmt|;
name|it
operator|.
name|baseLimit
operator|=
name|this
operator|.
name|index
operator|=
name|this
operator|.
name|baseIndex
operator|=
operator|(
name|hi
operator|+
name|it
operator|.
name|baseIndex
operator|+
literal|1
operator|)
operator|>>>
literal|1
expr_stmt|;
block|}
block|}
comment|/**          * Advances next; returns nextVal or null if terminated.          * See above for explanation.          */
DECL|method|advance
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|final
name|V
name|advance
parameter_list|()
block|{
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|next
decl_stmt|;
name|V
name|ev
init|=
literal|null
decl_stmt|;
name|outer
label|:
do|do
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
comment|// advance past used/skipped node
name|e
operator|=
name|e
operator|.
name|next
expr_stmt|;
while|while
condition|(
name|e
operator|==
literal|null
condition|)
block|{
comment|// get to next non-null bin
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|int
name|b
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|Object
name|ek
decl_stmt|;
comment|//  must use locals
if|if
condition|(
operator|(
name|t
operator|=
name|tab
operator|)
operator|!=
literal|null
condition|)
name|n
operator|=
name|t
operator|.
name|length
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|m
operator|=
name|map
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|t
operator|=
name|tab
operator|=
name|m
operator|.
name|table
operator|)
operator|!=
literal|null
condition|)
name|n
operator|=
name|baseLimit
operator|=
name|baseSize
operator|=
name|t
operator|.
name|length
expr_stmt|;
else|else
break|break
name|outer
break|;
if|if
condition|(
operator|(
name|b
operator|=
name|baseIndex
operator|)
operator|>=
name|baseLimit
operator|||
operator|(
name|i
operator|=
name|index
operator|)
operator|<
literal|0
operator|||
name|i
operator|>=
name|n
condition|)
break|break
name|outer
break|;
if|if
condition|(
operator|(
name|e
operator|=
name|tabAt
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
name|e
operator|.
name|hash
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ek
operator|=
name|e
operator|.
name|key
operator|)
operator|instanceof
name|TreeBin
condition|)
name|e
operator|=
operator|(
operator|(
name|TreeBin
argument_list|<
name|V
argument_list|>
operator|)
name|ek
operator|)
operator|.
name|first
expr_stmt|;
else|else
block|{
name|tab
operator|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|ek
expr_stmt|;
continue|continue;
comment|// restarts due to null val
block|}
block|}
comment|// visit upper slots if present
name|index
operator|=
operator|(
name|i
operator|+=
name|baseSize
operator|)
operator|<
name|n
condition|?
name|i
else|:
operator|(
name|baseIndex
operator|=
name|b
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|nextKey
operator|=
name|e
operator|.
name|key
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ev
operator|=
name|e
operator|.
name|val
operator|)
operator|==
literal|null
condition|)
do|;
comment|// skip deleted or special nodes
name|next
operator|=
name|e
expr_stmt|;
return|return
name|nextVal
operator|=
name|ev
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|void
name|remove
parameter_list|()
block|{
name|Object
name|k
init|=
name|nextKey
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|null
operator|&&
operator|(
name|advance
argument_list|()
operator|==
literal|null
operator|||
operator|(
name|k
operator|=
name|nextKey
operator|)
operator|==
literal|null
operator|)
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|map
operator|.
name|internalReplace
argument_list|(
name|k
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
specifier|final
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextVal
operator|!=
literal|null
operator|||
name|advance
argument_list|()
operator|!=
literal|null
return|;
block|}
DECL|method|hasMoreElements
specifier|public
specifier|final
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
DECL|method|compute
specifier|public
name|void
name|compute
parameter_list|()
block|{ }
comment|// default no-op CountedCompleter body
comment|/**          * Returns a batch value> 0 if this task should (and must) be          * split, if so, adding to pending count, and in any case          * updating batch value. The initial batch value is approx          * exp2 of the number of times (minus one) to split task by          * two before executing leaf action. This value is faster to          * compute and more convenient to use as a guide to splitting          * than is the depth, since it is used while dividing by two          * anyway.          */
DECL|method|preSplit
specifier|final
name|int
name|preSplit
parameter_list|()
block|{
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
decl_stmt|;
name|int
name|b
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|t
decl_stmt|;
name|ForkJoinPool
name|pool
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|batch
operator|)
operator|<
literal|0
operator|&&
operator|(
name|m
operator|=
name|map
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// force initialization
if|if
condition|(
operator|(
name|t
operator|=
name|tab
operator|)
operator|==
literal|null
operator|&&
operator|(
name|t
operator|=
name|tab
operator|=
name|m
operator|.
name|table
operator|)
operator|!=
literal|null
condition|)
name|baseLimit
operator|=
name|baseSize
operator|=
name|t
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|long
name|n
init|=
name|m
operator|.
name|sumCount
argument_list|()
decl_stmt|;
name|int
name|par
init|=
operator|(
operator|(
name|pool
operator|=
name|getPool
argument_list|()
operator|)
operator|==
literal|null
operator|)
condition|?
name|ForkJoinPool
operator|.
name|getCommonPoolParallelism
argument_list|()
else|:
name|pool
operator|.
name|getParallelism
argument_list|()
decl_stmt|;
name|int
name|sp
init|=
name|par
operator|<<
literal|3
decl_stmt|;
comment|// slack of 8
name|b
operator|=
operator|(
name|n
operator|<=
literal|0L
operator|)
condition|?
literal|0
else|:
operator|(
name|n
operator|<
operator|(
name|long
operator|)
name|sp
operator|)
condition|?
operator|(
name|int
operator|)
name|n
else|:
name|sp
expr_stmt|;
block|}
block|}
name|b
operator|=
operator|(
name|b
operator|<=
literal|1
operator|||
name|baseIndex
operator|==
name|baseLimit
operator|)
condition|?
literal|0
else|:
operator|(
name|b
operator|>>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|batch
operator|=
name|b
operator|)
operator|>
literal|0
condition|)
name|addToPendingCount
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
block|}
comment|/* ---------------- Public operations -------------- */
comment|/**      * Creates a new, empty map with the default initial table size (16).      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|()
block|{     }
comment|/**      * Creates a new, empty map with an initial table size      * accommodating the specified number of elements without the need      * to dynamically resize.      *      * @param initialCapacity The implementation performs internal      * sizing to accommodate this many elements.      * @throws IllegalArgumentException if the initial capacity of      * elements is negative      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
if|if
condition|(
name|initialCapacity
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|int
name|cap
init|=
operator|(
operator|(
name|initialCapacity
operator|>=
operator|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
operator|)
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
name|initialCapacity
operator|+
operator|(
name|initialCapacity
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
operator|)
decl_stmt|;
name|this
operator|.
name|sizeCtl
operator|=
name|cap
expr_stmt|;
block|}
comment|/**      * Creates a new map with the same mappings as the given map.      *      * @param m the map      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|this
operator|.
name|sizeCtl
operator|=
name|DEFAULT_CAPACITY
expr_stmt|;
name|internalPutAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with an initial table size based on      * the given number of elements ({@code initialCapacity}) and      * initial table density ({@code loadFactor}).      *      * @param initialCapacity the initial capacity. The implementation      * performs internal sizing to accommodate this many elements,      * given the specified load factor.      * @param loadFactor the load factor (table density) for      * establishing the initial table size      * @throws IllegalArgumentException if the initial capacity of      * elements is negative or the load factor is nonpositive      *      * @since 1.6      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
name|loadFactor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new, empty map with an initial table size based on      * the given number of elements ({@code initialCapacity}), table      * density ({@code loadFactor}), and number of concurrently      * updating threads ({@code concurrencyLevel}).      *      * @param initialCapacity the initial capacity. The implementation      * performs internal sizing to accommodate this many elements,      * given the specified load factor.      * @param loadFactor the load factor (table density) for      * establishing the initial table size      * @param concurrencyLevel the estimated number of concurrently      * updating threads. The implementation may use this value as      * a sizing hint.      * @throws IllegalArgumentException if the initial capacity is      * negative or the load factor or concurrencyLevel are      * nonpositive      */
DECL|method|ConcurrentHashMapV8
specifier|public
name|ConcurrentHashMapV8
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|float
name|loadFactor
parameter_list|,
name|int
name|concurrencyLevel
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|loadFactor
operator|>
literal|0.0f
operator|)
operator|||
name|initialCapacity
operator|<
literal|0
operator|||
name|concurrencyLevel
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
if|if
condition|(
name|initialCapacity
operator|<
name|concurrencyLevel
condition|)
comment|// Use at least as many bins
name|initialCapacity
operator|=
name|concurrencyLevel
expr_stmt|;
comment|// as estimated threads
name|long
name|size
init|=
call|(
name|long
call|)
argument_list|(
literal|1.0
operator|+
operator|(
name|long
operator|)
name|initialCapacity
operator|/
name|loadFactor
argument_list|)
decl_stmt|;
name|int
name|cap
init|=
operator|(
name|size
operator|>=
operator|(
name|long
operator|)
name|MAXIMUM_CAPACITY
operator|)
condition|?
name|MAXIMUM_CAPACITY
else|:
name|tableSizeFor
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|)
decl_stmt|;
name|this
operator|.
name|sizeCtl
operator|=
name|cap
expr_stmt|;
block|}
comment|/**      * Creates a new {@link Set} backed by a ConcurrentHashMapV8      * from the given type to {@code Boolean.TRUE}.      *      * @return the new set      */
DECL|method|newKeySet
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|>
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
name|newKeySet
parameter_list|()
block|{
return|return
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|(
operator|new
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|()
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
return|;
block|}
comment|/**      * Creates a new {@link Set} backed by a ConcurrentHashMapV8      * from the given type to {@code Boolean.TRUE}.      *      * @param initialCapacity The implementation performs internal      * sizing to accommodate this many elements.      * @throws IllegalArgumentException if the initial capacity of      * elements is negative      * @return the new set      */
DECL|method|newKeySet
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|>
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
name|newKeySet
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
return|return
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|(
operator|new
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|Boolean
argument_list|>
argument_list|(
name|initialCapacity
argument_list|)
argument_list|,
name|Boolean
operator|.
name|TRUE
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|sumCount
argument_list|()
operator|<=
literal|0L
return|;
comment|// ignore transient negative values
block|}
comment|/**      * {@inheritDoc}      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
name|long
name|n
init|=
name|sumCount
argument_list|()
decl_stmt|;
return|return
operator|(
operator|(
name|n
operator|<
literal|0L
operator|)
condition|?
literal|0
else|:
operator|(
name|n
operator|>
operator|(
name|long
operator|)
name|Integer
operator|.
name|MAX_VALUE
operator|)
condition|?
name|Integer
operator|.
name|MAX_VALUE
else|:
operator|(
name|int
operator|)
name|n
operator|)
return|;
block|}
comment|/**      * Returns the number of mappings. This method should be used      * instead of {@link #size} because a ConcurrentHashMapV8 may      * contain more mappings than can be represented as an int. The      * value returned is an estimate; the actual count may differ if      * there are concurrent insertions or removals.      *      * @return the number of mappings      */
DECL|method|mappingCount
specifier|public
name|long
name|mappingCount
parameter_list|()
block|{
name|long
name|n
init|=
name|sumCount
argument_list|()
decl_stmt|;
return|return
operator|(
name|n
operator|<
literal|0L
operator|)
condition|?
literal|0L
else|:
name|n
return|;
comment|// ignore transient negative values
block|}
comment|/**      * Returns the value to which the specified key is mapped,      * or {@code null} if this map contains no mapping for the key.      *      *<p>More formally, if this map contains a mapping from a key      * {@code k} to a value {@code v} such that {@code key.equals(k)},      * then this method returns {@code v}; otherwise it returns      * {@code null}.  (There can be at most one such mapping.)      *      * @throws NullPointerException if the specified key is null      */
DECL|method|get
specifier|public
name|V
name|get
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|internalGet
argument_list|(
name|key
argument_list|)
return|;
block|}
comment|/**      * Returns the value to which the specified key is mapped,      * or the given defaultValue if this map contains no mapping for the key.      *      * @param key the key      * @param defaultValue the value to return if this map contains      * no mapping for the given key      * @return the mapping for the key, if present; else the defaultValue      * @throws NullPointerException if the specified key is null      */
DECL|method|getValueOrDefault
specifier|public
name|V
name|getValueOrDefault
parameter_list|(
name|Object
name|key
parameter_list|,
name|V
name|defaultValue
parameter_list|)
block|{
name|V
name|v
decl_stmt|;
return|return
operator|(
name|v
operator|=
name|internalGet
argument_list|(
name|key
argument_list|)
operator|)
operator|==
literal|null
condition|?
name|defaultValue
else|:
name|v
return|;
block|}
comment|/**      * Tests if the specified object is a key in this table.      *      * @param  key possible key      * @return {@code true} if and only if the specified object      *         is a key in this table, as determined by the      *         {@code equals} method; {@code false} otherwise      * @throws NullPointerException if the specified key is null      */
DECL|method|containsKey
specifier|public
name|boolean
name|containsKey
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|internalGet
argument_list|(
name|key
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns {@code true} if this map maps one or more keys to the      * specified value. Note: This method may require a full traversal      * of the map, and is much slower than method {@code containsKey}.      *      * @param value value whose presence in this map is to be tested      * @return {@code true} if this map maps one or more keys to the      *         specified value      * @throws NullPointerException if the specified value is null      */
DECL|method|containsValue
specifier|public
name|boolean
name|containsValue
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|V
name|v
decl_stmt|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|v
operator|==
name|value
operator|||
name|value
operator|.
name|equals
argument_list|(
name|v
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Legacy method testing if some key maps into the specified value      * in this table.  This method is identical in functionality to      * {@link #containsValue}, and exists solely to ensure      * full compatibility with class {@link java.util.Hashtable},      * which supported this method prior to introduction of the      * Java Collections framework.      *      * @param  value a value to search for      * @return {@code true} if and only if some key maps to the      *         {@code value} argument in this table as      *         determined by the {@code equals} method;      *         {@code false} otherwise      * @throws NullPointerException if the specified value is null      */
DECL|method|contains
annotation|@
name|Deprecated
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|value
parameter_list|)
block|{
return|return
name|containsValue
argument_list|(
name|value
argument_list|)
return|;
block|}
comment|/**      * Maps the specified key to the specified value in this table.      * Neither the key nor the value can be null.      *      *<p>The value can be retrieved by calling the {@code get} method      * with a key that is equal to the original key.      *      * @param key key with which the specified value is to be associated      * @param value value to be associated with the specified key      * @return the previous value associated with {@code key}, or      *         {@code null} if there was no mapping for {@code key}      * @throws NullPointerException if the specified key or value is null      */
DECL|method|put
specifier|public
name|V
name|put
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|internalPut
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|false
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key,      *         or {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|putIfAbsent
specifier|public
name|V
name|putIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
return|return
name|internalPut
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|true
argument_list|)
return|;
block|}
comment|/**      * Copies all of the mappings from the specified map to this one.      * These mappings replace any mappings that this map had for any of the      * keys currently in the specified map.      *      * @param m mappings to be stored in this map      */
DECL|method|putAll
specifier|public
name|void
name|putAll
parameter_list|(
name|Map
argument_list|<
name|?
extends|extends
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|m
parameter_list|)
block|{
name|internalPutAll
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/**      * If the specified key is not already associated with a value,      * computes its value using the given mappingFunction and enters      * it into the map unless null.  This is equivalent to      *<pre> {@code      * if (map.containsKey(key))      *   return map.get(key);      * value = mappingFunction.apply(key);      * if (value != null)      *   map.put(key, value);      * return value;}</pre>      *      * except that the action is performed atomically.  If the      * function returns {@code null} no mapping is recorded. If the      * function itself throws an (unchecked) exception, the exception      * is rethrown to its caller, and no mapping is recorded.  Some      * attempted update operations on this map by other threads may be      * blocked while computation is in progress, so the computation      * should be short and simple, and must not attempt to update any      * other mappings of this Map. The most appropriate usage is to      * construct a new object serving as an initial mapped value, or      * memoized result, as in:      *      *<pre> {@code      * map.computeIfAbsent(key, new Fun<K,V>() {      *   public V map(K k) { return new Value(f(k)); }});}</pre>      *      * @param key key with which the specified value is to be associated      * @param mappingFunction the function to compute a value      * @return the current (existing or computed) value associated with      *         the specified key, or null if the computed value is null      * @throws NullPointerException if the specified key or mappingFunction      *         is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the mappingFunction does so,      *         in which case the mapping is left unestablished      */
DECL|method|computeIfAbsent
specifier|public
name|V
name|computeIfAbsent
parameter_list|(
name|K
name|key
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|mappingFunction
parameter_list|)
block|{
return|return
name|internalComputeIfAbsent
argument_list|(
name|key
argument_list|,
name|mappingFunction
argument_list|)
return|;
block|}
comment|/**      * If the given key is present, computes a new mapping value given a key and      * its current mapped value. This is equivalent to      *<pre> {@code      *   if (map.containsKey(key)) {      *     value = remappingFunction.apply(key, map.get(key));      *     if (value != null)      *       map.put(key, value);      *     else      *       map.remove(key);      *   }      * }</pre>      *      * except that the action is performed atomically.  If the      * function returns {@code null}, the mapping is removed.  If the      * function itself throws an (unchecked) exception, the exception      * is rethrown to its caller, and the current mapping is left      * unchanged.  Some attempted update operations on this map by      * other threads may be blocked while computation is in progress,      * so the computation should be short and simple, and must not      * attempt to update any other mappings of this Map. For example,      * to either create or append new messages to a value mapping:      *      * @param key key with which the specified value is to be associated      * @param remappingFunction the function to compute a value      * @return the new value associated with the specified key, or null if none      * @throws NullPointerException if the specified key or remappingFunction      *         is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the remappingFunction does so,      *         in which case the mapping is unchanged      */
DECL|method|computeIfPresent
specifier|public
name|V
name|computeIfPresent
parameter_list|(
name|K
name|key
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|remappingFunction
parameter_list|)
block|{
return|return
name|internalCompute
argument_list|(
name|key
argument_list|,
literal|true
argument_list|,
name|remappingFunction
argument_list|)
return|;
block|}
comment|/**      * Computes a new mapping value given a key and      * its current mapped value (or {@code null} if there is no current      * mapping). This is equivalent to      *<pre> {@code      *   value = remappingFunction.apply(key, map.get(key));      *   if (value != null)      *     map.put(key, value);      *   else      *     map.remove(key);      * }</pre>      *      * except that the action is performed atomically.  If the      * function returns {@code null}, the mapping is removed.  If the      * function itself throws an (unchecked) exception, the exception      * is rethrown to its caller, and the current mapping is left      * unchanged.  Some attempted update operations on this map by      * other threads may be blocked while computation is in progress,      * so the computation should be short and simple, and must not      * attempt to update any other mappings of this Map. For example,      * to either create or append new messages to a value mapping:      *      *<pre> {@code      * Map<Key, String> map = ...;      * final String msg = ...;      * map.compute(key, new BiFun<Key, String, String>() {      *   public String apply(Key k, String v) {      *    return (v == null) ? msg : v + msg;});}}</pre>      *      * @param key key with which the specified value is to be associated      * @param remappingFunction the function to compute a value      * @return the new value associated with the specified key, or null if none      * @throws NullPointerException if the specified key or remappingFunction      *         is null      * @throws IllegalStateException if the computation detectably      *         attempts a recursive update to this map that would      *         otherwise never complete      * @throws RuntimeException or Error if the remappingFunction does so,      *         in which case the mapping is unchanged      */
DECL|method|compute
specifier|public
name|V
name|compute
parameter_list|(
name|K
name|key
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|remappingFunction
parameter_list|)
block|{
return|return
name|internalCompute
argument_list|(
name|key
argument_list|,
literal|false
argument_list|,
name|remappingFunction
argument_list|)
return|;
block|}
comment|/**      * If the specified key is not already associated      * with a value, associate it with the given value.      * Otherwise, replace the value with the results of      * the given remapping function. This is equivalent to:      *<pre> {@code      *   if (!map.containsKey(key))      *     map.put(value);      *   else {      *     newValue = remappingFunction.apply(map.get(key), value);      *     if (value != null)      *       map.put(key, value);      *     else      *       map.remove(key);      *   }      * }</pre>      * except that the action is performed atomically.  If the      * function returns {@code null}, the mapping is removed.  If the      * function itself throws an (unchecked) exception, the exception      * is rethrown to its caller, and the current mapping is left      * unchanged.  Some attempted update operations on this map by      * other threads may be blocked while computation is in progress,      * so the computation should be short and simple, and must not      * attempt to update any other mappings of this Map.      */
DECL|method|merge
specifier|public
name|V
name|merge
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|remappingFunction
parameter_list|)
block|{
return|return
name|internalMerge
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
name|remappingFunction
argument_list|)
return|;
block|}
comment|/**      * Removes the key (and its corresponding value) from this map.      * This method does nothing if the key is not in the map.      *      * @param  key the key that needs to be removed      * @return the previous value associated with {@code key}, or      *         {@code null} if there was no mapping for {@code key}      * @throws NullPointerException if the specified key is null      */
DECL|method|remove
specifier|public
name|V
name|remove
parameter_list|(
name|Object
name|key
parameter_list|)
block|{
return|return
name|internalReplace
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if the specified key is null      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|key
parameter_list|,
name|Object
name|value
parameter_list|)
block|{
return|return
name|value
operator|!=
literal|null
operator|&&
name|internalReplace
argument_list|(
name|key
argument_list|,
literal|null
argument_list|,
name|value
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @throws NullPointerException if any of the arguments are null      */
DECL|method|replace
specifier|public
name|boolean
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|oldValue
parameter_list|,
name|V
name|newValue
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|oldValue
operator|==
literal|null
operator|||
name|newValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|internalReplace
argument_list|(
name|key
argument_list|,
name|newValue
argument_list|,
name|oldValue
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * {@inheritDoc}      *      * @return the previous value associated with the specified key,      *         or {@code null} if there was no mapping for the key      * @throws NullPointerException if the specified key or value is null      */
DECL|method|replace
specifier|public
name|V
name|replace
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|null
operator|||
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
name|internalReplace
argument_list|(
name|key
argument_list|,
name|value
argument_list|,
literal|null
argument_list|)
return|;
block|}
comment|/**      * Removes all of the mappings from this map.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
name|internalClear
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a {@link Set} view of the keys contained in this map.      * The set is backed by the map, so changes to the map are      * reflected in the set, and vice-versa.      *      * @return the set view      */
DECL|method|keySet
specifier|public
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keySet
parameter_list|()
block|{
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|ks
init|=
name|keySet
decl_stmt|;
return|return
operator|(
name|ks
operator|!=
literal|null
operator|)
condition|?
name|ks
else|:
operator|(
name|keySet
operator|=
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
literal|null
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns a {@link Set} view of the keys in this map, using the      * given common mapped value for any additions (i.e., {@link      * Collection#add} and {@link Collection#addAll}). This is of      * course only appropriate if it is acceptable to use the same      * value for all additions from this view.      *      * @param mappedValue the mapped value to use for any additions      * @return the set view      * @throws NullPointerException if the mappedValue is null      */
DECL|method|keySet
specifier|public
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|keySet
parameter_list|(
name|V
name|mappedValue
parameter_list|)
block|{
if|if
condition|(
name|mappedValue
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|KeySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|,
name|mappedValue
argument_list|)
return|;
block|}
comment|/**      * Returns a {@link Collection} view of the values contained in this map.      * The collection is backed by the map, so changes to the map are      * reflected in the collection, and vice-versa.      */
DECL|method|values
specifier|public
name|ValuesView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|values
parameter_list|()
block|{
name|ValuesView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|vs
init|=
name|values
decl_stmt|;
return|return
operator|(
name|vs
operator|!=
literal|null
operator|)
condition|?
name|vs
else|:
operator|(
name|values
operator|=
operator|new
name|ValuesView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns a {@link Set} view of the mappings contained in this map.      * The set is backed by the map, so changes to the map are      * reflected in the set, and vice-versa.  The set supports element      * removal, which removes the corresponding mapping from the map,      * via the {@code Iterator.remove}, {@code Set.remove},      * {@code removeAll}, {@code retainAll}, and {@code clear}      * operations.  It does not support the {@code add} or      * {@code addAll} operations.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      */
DECL|method|entrySet
specifier|public
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySet
parameter_list|()
block|{
name|EntrySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|es
init|=
name|entrySet
decl_stmt|;
return|return
operator|(
name|es
operator|!=
literal|null
operator|)
condition|?
name|es
else|:
operator|(
name|entrySet
operator|=
operator|new
name|EntrySetView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
operator|)
return|;
block|}
comment|/**      * Returns an enumeration of the keys in this table.      *      * @return an enumeration of the keys in this table      * @see #keySet()      */
DECL|method|keys
specifier|public
name|Enumeration
argument_list|<
name|K
argument_list|>
name|keys
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns an enumeration of the values in this table.      *      * @return an enumeration of the values in this table      * @see #values()      */
DECL|method|elements
specifier|public
name|Enumeration
argument_list|<
name|V
argument_list|>
name|elements
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns a partitionable iterator of the keys in this map.      *      * @return a partitionable iterator of the keys in this map      */
DECL|method|keySpliterator
specifier|public
name|Spliterator
argument_list|<
name|K
argument_list|>
name|keySpliterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns a partitionable iterator of the values in this map.      *      * @return a partitionable iterator of the values in this map      */
DECL|method|valueSpliterator
specifier|public
name|Spliterator
argument_list|<
name|V
argument_list|>
name|valueSpliterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns a partitionable iterator of the entries in this map.      *      * @return a partitionable iterator of the entries in this map      */
DECL|method|entrySpliterator
specifier|public
name|Spliterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|entrySpliterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|this
argument_list|)
return|;
block|}
comment|/**      * Returns the hash code value for this {@link Map}, i.e.,      * the sum of, for each key-value pair in the map,      * {@code key.hashCode() ^ value.hashCode()}.      *      * @return the hash code value for this map      */
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|h
operator|+=
name|it
operator|.
name|nextKey
operator|.
name|hashCode
argument_list|()
operator|^
name|v
operator|.
name|hashCode
argument_list|()
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
comment|/**      * Returns a string representation of this map.  The string      * representation consists of a list of key-value mappings (in no      * particular order) enclosed in braces ("{@code {}}").  Adjacent      * mappings are separated by the characters {@code ", "} (comma      * and space).  Each key-value mapping is rendered as the key      * followed by an equals sign ("{@code =}") followed by the      * associated value.      *      * @return a string representation of this map      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'{'
argument_list|)
expr_stmt|;
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|k
init|=
name|it
operator|.
name|nextKey
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|k
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|k
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|v
operator|==
name|this
condition|?
literal|"(this Map)"
else|:
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
break|break;
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|'}'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
comment|/**      * Compares the specified object with this map for equality.      * Returns {@code true} if the given object is a map with the same      * mappings as this map.  This operation may return misleading      * results if either map is concurrently modified during execution      * of this method.      *      * @param o object to be compared for equality with this map      * @return {@code true} if the specified object is equal to this map      */
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|!=
name|this
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|Map
operator|)
condition|)
return|return
literal|false
return|;
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|m
init|=
operator|(
name|Map
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
decl_stmt|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|val
decl_stmt|;
while|while
condition|(
operator|(
name|val
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|Object
name|v
init|=
name|m
operator|.
name|get
argument_list|(
name|it
operator|.
name|nextKey
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
literal|null
operator|||
operator|(
name|v
operator|!=
name|val
operator|&&
operator|!
name|v
operator|.
name|equals
argument_list|(
name|val
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
for|for
control|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
range|:
name|m
operator|.
name|entrySet
argument_list|()
control|)
block|{
name|Object
name|mk
decl_stmt|,
name|mv
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|mk
operator|=
name|e
operator|.
name|getKey
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|mv
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|==
literal|null
operator|||
operator|(
name|v
operator|=
name|internalGet
argument_list|(
name|mk
argument_list|)
operator|)
operator|==
literal|null
operator|||
operator|(
name|mv
operator|!=
name|v
operator|&&
operator|!
name|mv
operator|.
name|equals
argument_list|(
name|v
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/* ----------------Iterators -------------- */
DECL|class|KeyIterator
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|KeyIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
implements|implements
name|Spliterator
argument_list|<
name|K
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|K
argument_list|>
block|{
DECL|method|KeyIterator
name|KeyIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|KeyIterator
name|KeyIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|it
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|split
specifier|public
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|split
parameter_list|()
block|{
if|if
condition|(
name|nextKey
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|next
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|K
name|next
parameter_list|()
block|{
if|if
condition|(
name|nextVal
operator|==
literal|null
operator|&&
name|advance
argument_list|()
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|Object
name|k
init|=
name|nextKey
decl_stmt|;
name|nextVal
operator|=
literal|null
expr_stmt|;
return|return
operator|(
name|K
operator|)
name|k
return|;
block|}
DECL|method|nextElement
specifier|public
specifier|final
name|K
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
block|}
DECL|class|ValueIterator
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ValueIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
implements|implements
name|Spliterator
argument_list|<
name|V
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|V
argument_list|>
block|{
DECL|method|ValueIterator
name|ValueIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|ValueIterator
name|ValueIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|it
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|split
specifier|public
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|split
parameter_list|()
block|{
if|if
condition|(
name|nextKey
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|next
specifier|public
specifier|final
name|V
name|next
parameter_list|()
block|{
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|nextVal
operator|)
operator|==
literal|null
operator|&&
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|nextVal
operator|=
literal|null
expr_stmt|;
return|return
name|v
return|;
block|}
DECL|method|nextElement
specifier|public
specifier|final
name|V
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
block|}
DECL|class|EntryIterator
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|EntryIterator
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
implements|implements
name|Spliterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|EntryIterator
name|EntryIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|EntryIterator
name|EntryIterator
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|,
name|it
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|method|split
specifier|public
name|EntryIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|split
parameter_list|()
block|{
if|if
condition|(
name|nextKey
operator|!=
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
return|return
operator|new
name|EntryIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|)
return|;
block|}
DECL|method|next
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|next
parameter_list|()
block|{
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|nextVal
operator|)
operator|==
literal|null
operator|&&
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|Object
name|k
init|=
name|nextKey
decl_stmt|;
name|nextVal
operator|=
literal|null
expr_stmt|;
return|return
operator|new
name|MapEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
operator|(
name|K
operator|)
name|k
argument_list|,
name|v
argument_list|,
name|map
argument_list|)
return|;
block|}
block|}
comment|/**      * Exported Entry for iterators      */
DECL|class|MapEntry
specifier|static
specifier|final
class|class
name|MapEntry
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
block|{
DECL|field|key
specifier|final
name|K
name|key
decl_stmt|;
comment|// non-null
DECL|field|val
name|V
name|val
decl_stmt|;
comment|// non-null
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|MapEntry
name|MapEntry
parameter_list|(
name|K
name|key
parameter_list|,
name|V
name|val
parameter_list|,
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|this
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
DECL|method|getKey
specifier|public
specifier|final
name|K
name|getKey
parameter_list|()
block|{
return|return
name|key
return|;
block|}
DECL|method|getValue
specifier|public
specifier|final
name|V
name|getValue
parameter_list|()
block|{
return|return
name|val
return|;
block|}
DECL|method|hashCode
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|key
operator|.
name|hashCode
argument_list|()
operator|^
name|val
operator|.
name|hashCode
argument_list|()
return|;
block|}
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
return|return
name|key
operator|+
literal|"="
operator|+
name|val
return|;
block|}
DECL|method|equals
specifier|public
specifier|final
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|k
operator|==
name|key
operator|||
name|k
operator|.
name|equals
argument_list|(
name|key
argument_list|)
operator|)
operator|&&
operator|(
name|v
operator|==
name|val
operator|||
name|v
operator|.
name|equals
argument_list|(
name|val
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/**          * Sets our entry's value and writes through to the map. The          * value to return is somewhat arbitrary here. Since we do not          * necessarily track asynchronous changes, the most recent          * "previous" value could be different from what we return (or          * could even have been removed in which case the put will          * re-establish). We do not and cannot guarantee more.          */
DECL|method|setValue
specifier|public
specifier|final
name|V
name|setValue
parameter_list|(
name|V
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|V
name|v
init|=
name|val
decl_stmt|;
name|val
operator|=
name|value
expr_stmt|;
name|map
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
comment|/**      * Returns exportable snapshot entry for the given key and value      * when write-through can't or shouldn't be used.      */
DECL|method|entryFor
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|AbstractMap
operator|.
name|SimpleEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|entryFor
parameter_list|(
name|K
name|k
parameter_list|,
name|V
name|v
parameter_list|)
block|{
return|return
operator|new
name|AbstractMap
operator|.
name|SimpleEntry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
return|;
block|}
comment|/* ---------------- Serialization Support -------------- */
comment|/**      * Stripped-down version of helper class used in previous version,      * declared for the sake of serialization compatibility      */
DECL|class|Segment
specifier|static
class|class
name|Segment
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
implements|implements
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|2249069246763182397L
decl_stmt|;
DECL|field|loadFactor
specifier|final
name|float
name|loadFactor
decl_stmt|;
DECL|method|Segment
name|Segment
parameter_list|(
name|float
name|lf
parameter_list|)
block|{
name|this
operator|.
name|loadFactor
operator|=
name|lf
expr_stmt|;
block|}
block|}
comment|/**      * Saves the state of the {@code ConcurrentHashMapV8} instance to a      * stream (i.e., serializes it).      * @param s the stream      * @serialData      * the key (Object) and value (Object)      * for each key-value mapping, followed by a null pair.      * The key-value mappings are emitted in no particular order.      */
DECL|method|writeObject
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
if|if
condition|(
name|segments
operator|==
literal|null
condition|)
block|{
comment|// for serialization compatibility
name|segments
operator|=
operator|(
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
index|[]
operator|)
operator|new
name|Segment
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
index|[
name|DEFAULT_CONCURRENCY_LEVEL
index|]
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|segments
operator|.
name|length
condition|;
operator|++
name|i
control|)
name|segments
index|[
name|i
index|]
operator|=
operator|new
name|Segment
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|LOAD_FACTOR
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|s
operator|.
name|writeObject
argument_list|(
name|it
operator|.
name|nextKey
argument_list|)
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
name|segments
operator|=
literal|null
expr_stmt|;
comment|// throw away
block|}
comment|/**      * Reconstitutes the instance from a stream (that is, deserializes it).      * @param s the stream      */
DECL|method|readObject
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|this
operator|.
name|segments
operator|=
literal|null
expr_stmt|;
comment|// unneeded
comment|// Create all nodes, then place in table once size is known
name|long
name|size
init|=
literal|0L
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|p
init|=
literal|null
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|K
name|k
init|=
operator|(
name|K
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
name|V
name|v
init|=
operator|(
name|V
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|!=
literal|null
operator|&&
name|v
operator|!=
literal|null
condition|)
block|{
name|int
name|h
init|=
name|spread
argument_list|(
name|k
operator|.
name|hashCode
argument_list|()
argument_list|)
decl_stmt|;
name|p
operator|=
operator|new
name|Node
argument_list|<
name|V
argument_list|>
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|v
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|++
name|size
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|boolean
name|init
init|=
literal|false
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|size
operator|>=
call|(
name|long
call|)
argument_list|(
name|MAXIMUM_CAPACITY
operator|>>>
literal|1
argument_list|)
condition|)
name|n
operator|=
name|MAXIMUM_CAPACITY
expr_stmt|;
else|else
block|{
name|int
name|sz
init|=
operator|(
name|int
operator|)
name|size
decl_stmt|;
name|n
operator|=
name|tableSizeFor
argument_list|(
name|sz
operator|+
operator|(
name|sz
operator|>>>
literal|1
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|int
name|sc
init|=
name|sizeCtl
decl_stmt|;
name|boolean
name|collide
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|sc
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|SIZECTL
argument_list|,
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
try|try
block|{
if|if
condition|(
name|table
operator|==
literal|null
condition|)
block|{
name|init
operator|=
literal|true
expr_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"rawtypes"
argument_list|)
name|Node
index|[]
name|rt
init|=
operator|new
name|Node
index|[
name|n
index|]
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
operator|(
name|Node
argument_list|<
name|V
argument_list|>
index|[]
operator|)
name|rt
decl_stmt|;
name|int
name|mask
init|=
name|n
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|int
name|j
init|=
name|p
operator|.
name|hash
operator|&
name|mask
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|next
init|=
name|p
operator|.
name|next
decl_stmt|;
name|Node
argument_list|<
name|V
argument_list|>
name|q
init|=
name|p
operator|.
name|next
operator|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|setTabAt
argument_list|(
name|tab
argument_list|,
name|j
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|collide
operator|&&
name|q
operator|!=
literal|null
operator|&&
name|q
operator|.
name|hash
operator|==
name|p
operator|.
name|hash
condition|)
name|collide
operator|=
literal|true
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|table
operator|=
name|tab
expr_stmt|;
name|addCount
argument_list|(
name|size
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
name|n
operator|-
operator|(
name|n
operator|>>>
literal|2
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|sizeCtl
operator|=
name|sc
expr_stmt|;
block|}
if|if
condition|(
name|collide
condition|)
block|{
comment|// rescan and convert to TreeBins
name|Node
argument_list|<
name|V
argument_list|>
index|[]
name|tab
init|=
name|table
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tab
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|int
name|c
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|V
argument_list|>
name|e
init|=
name|tabAt
argument_list|(
name|tab
argument_list|,
name|i
argument_list|)
init|;
name|e
operator|!=
literal|null
condition|;
name|e
operator|=
name|e
operator|.
name|next
control|)
block|{
if|if
condition|(
operator|++
name|c
operator|>
name|TREE_THRESHOLD
operator|&&
operator|(
name|e
operator|.
name|key
operator|instanceof
name|Comparable
operator|)
condition|)
block|{
name|replaceWithTreeBin
argument_list|(
name|tab
argument_list|,
name|i
argument_list|,
name|e
operator|.
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|init
condition|)
block|{
comment|// Can only happen if unsafely published.
while|while
condition|(
name|p
operator|!=
literal|null
condition|)
block|{
name|internalPut
argument_list|(
operator|(
name|K
operator|)
name|p
operator|.
name|key
argument_list|,
name|p
operator|.
name|val
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|.
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// -------------------------------------------------------
comment|// Sams
comment|/** Interface describing a void action of one argument */
DECL|interface|Action
DECL|method|apply
specifier|public
interface|interface
name|Action
parameter_list|<
name|A
parameter_list|>
block|{
name|void
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a void action of two arguments */
DECL|interface|BiAction
DECL|method|apply
specifier|public
interface|interface
name|BiAction
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|void
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of one argument */
DECL|interface|Fun
DECL|method|apply
specifier|public
interface|interface
name|Fun
parameter_list|<
name|A
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of two arguments */
DECL|interface|BiFun
DECL|method|apply
specifier|public
interface|interface
name|BiFun
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|,
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function of no arguments */
DECL|interface|Generator
DECL|method|apply
specifier|public
interface|interface
name|Generator
parameter_list|<
name|T
parameter_list|>
block|{
name|T
name|apply
parameter_list|()
function_decl|;
block|}
comment|/** Interface describing a function mapping its argument to a double */
DECL|interface|ObjectToDouble
DECL|method|apply
specifier|public
interface|interface
name|ObjectToDouble
parameter_list|<
name|A
parameter_list|>
block|{
name|double
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping its argument to a long */
DECL|interface|ObjectToLong
DECL|method|apply
specifier|public
interface|interface
name|ObjectToLong
parameter_list|<
name|A
parameter_list|>
block|{
name|long
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping its argument to an int */
DECL|interface|ObjectToInt
DECL|method|apply
specifier|public
interface|interface
name|ObjectToInt
parameter_list|<
name|A
parameter_list|>
block|{
name|int
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two arguments to a double */
DECL|interface|ObjectByObjectToDouble
DECL|method|apply
specifier|public
interface|interface
name|ObjectByObjectToDouble
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|double
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two arguments to a long */
DECL|interface|ObjectByObjectToLong
DECL|method|apply
specifier|public
interface|interface
name|ObjectByObjectToLong
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|long
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two arguments to an int */
DECL|interface|ObjectByObjectToInt
DECL|method|apply
specifier|public
interface|interface
name|ObjectByObjectToInt
parameter_list|<
name|A
parameter_list|,
name|B
parameter_list|>
block|{
name|int
name|apply
parameter_list|(
name|A
name|a
parameter_list|,
name|B
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping a double to a double */
DECL|interface|DoubleToDouble
DECL|method|apply
specifier|public
interface|interface
name|DoubleToDouble
block|{
name|double
name|apply
parameter_list|(
name|double
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping a long to a long */
DECL|interface|LongToLong
DECL|method|apply
specifier|public
interface|interface
name|LongToLong
block|{
name|long
name|apply
parameter_list|(
name|long
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping an int to an int */
DECL|interface|IntToInt
DECL|method|apply
specifier|public
interface|interface
name|IntToInt
block|{
name|int
name|apply
parameter_list|(
name|int
name|a
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two doubles to a double */
DECL|interface|DoubleByDoubleToDouble
DECL|method|apply
specifier|public
interface|interface
name|DoubleByDoubleToDouble
block|{
name|double
name|apply
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two longs to a long */
DECL|interface|LongByLongToLong
DECL|method|apply
specifier|public
interface|interface
name|LongByLongToLong
block|{
name|long
name|apply
parameter_list|(
name|long
name|a
parameter_list|,
name|long
name|b
parameter_list|)
function_decl|;
block|}
comment|/** Interface describing a function mapping two ints to an int */
DECL|interface|IntByIntToInt
DECL|method|apply
specifier|public
interface|interface
name|IntByIntToInt
block|{
name|int
name|apply
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
block|}
comment|// -------------------------------------------------------
comment|// Sequential bulk operations
comment|/**      * Performs the given action for each (key, value).      *      * @param action the action      */
DECL|method|forEachSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|forEachSequentially
parameter_list|(
name|BiAction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each (key, value).      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      */
DECL|method|forEachSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachSequentially
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each (key, value), or null if none.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each (key, value), or null if none      */
DECL|method|searchSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchSequentially
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|u
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, or null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceSequentially
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceToDoubleSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|double
name|reduceToDoubleSequentially
parameter_list|(
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|double
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceToLongSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|long
name|reduceToLongSequentially
parameter_list|(
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|long
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceToIntSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|int
name|reduceToIntSequentially
parameter_list|(
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Performs the given action for each key.      *      * @param action the action      */
DECL|method|forEachKeySequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|forEachKeySequentially
parameter_list|(
name|Action
argument_list|<
name|K
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|)
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each key.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      */
DECL|method|forEachKeySequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachKeySequentially
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|ForkJoinTasks
operator|.
name|forEachKey
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each key, or null if none.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each key, or null if none      */
DECL|method|searchKeysSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchKeysSequentially
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|u
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns the result of accumulating all keys using the given      * reducer to combine values, or null if none.      *      * @param reducer a commutative associative combining function      * @return the result of accumulating all keys using the given      * reducer to combine values, or null if none      */
DECL|method|reduceKeysSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|K
name|reduceKeysSequentially
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|K
name|r
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|K
name|u
init|=
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
decl_stmt|;
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, or      * null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceKeysSequentially
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return  the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysToDoubleSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|double
name|reduceKeysToDoubleSequentially
parameter_list|(
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|double
name|r
init|=
name|basis
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysToLongSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|long
name|reduceKeysToLongSequentially
parameter_list|(
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|long
name|r
init|=
name|basis
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysToIntSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|int
name|reduceKeysToIntSequentially
parameter_list|(
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|basis
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Performs the given action for each value.      *      * @param action the action      */
DECL|method|forEachValueSequentially
specifier|public
name|void
name|forEachValueSequentially
parameter_list|(
name|Action
argument_list|<
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each value.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      */
DECL|method|forEachValueSequentially
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachValueSequentially
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each value, or null if none.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each value, or null if none      */
DECL|method|searchValuesSequentially
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchValuesSequentially
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|u
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns the result of accumulating all values using the      * given reducer to combine values, or null if none.      *      * @param reducer a commutative associative combining function      * @return  the result of accumulating all values      */
DECL|method|reduceValuesSequentially
specifier|public
name|V
name|reduceValuesSequentially
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|r
init|=
literal|null
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|v
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values, or      * null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesSequentially
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceValuesSequentially
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesToDoubleSequentially
specifier|public
name|double
name|reduceValuesToDoubleSequentially
parameter_list|(
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|double
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesToLongSequentially
specifier|public
name|long
name|reduceValuesToLongSequentially
parameter_list|(
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|long
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesToIntSequentially
specifier|public
name|int
name|reduceValuesToIntSequentially
parameter_list|(
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Performs the given action for each entry.      *      * @param action the action      */
DECL|method|forEachEntrySequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|void
name|forEachEntrySequentially
parameter_list|(
name|Action
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each entry.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      */
DECL|method|forEachEntrySequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachEntrySequentially
parameter_list|(
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each entry, or null if none.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each entry, or null if none      */
DECL|method|searchEntriesSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchEntriesSequentially
parameter_list|(
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|u
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns the result of accumulating all entries using the      * given reducer to combine values, or null if none.      *      * @param reducer a commutative associative combining function      * @return the result of accumulating all entries      */
DECL|method|reduceEntriesSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|reduceEntriesSequentially
parameter_list|(
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
init|=
literal|null
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|u
init|=
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * or null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceEntriesSequentially
parameter_list|(
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesToDoubleSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|double
name|reduceEntriesToDoubleSequentially
parameter_list|(
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|double
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return  the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesToLongSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|long
name|reduceEntriesToLongSequentially
parameter_list|(
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|long
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesToIntSequentially
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|int
name|reduceEntriesToIntSequentially
parameter_list|(
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
name|it
init|=
operator|new
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Object
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|basis
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|it
operator|.
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|it
operator|.
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
comment|// Parallel bulk operations
comment|/**      * Performs the given action for each (key, value).      *      * @param action the action      */
DECL|method|forEachInParallel
specifier|public
name|void
name|forEachInParallel
parameter_list|(
name|BiAction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEach
argument_list|(
name|this
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each (key, value).      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      */
DECL|method|forEachInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachInParallel
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEach
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each (key, value), or null if none.  Upon      * success, further element processing is suppressed and the      * results of any other parallel invocations of the search      * function are ignored.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each (key, value), or null if none      */
DECL|method|searchInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchInParallel
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|search
argument_list|(
name|this
argument_list|,
name|searchFunction
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, or null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceInParallel
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduce
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceToDoubleInParallel
specifier|public
name|double
name|reduceToDoubleInParallel
parameter_list|(
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceToDouble
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceToLongInParallel
specifier|public
name|long
name|reduceToLongInParallel
parameter_list|(
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceToLong
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all (key, value) pairs using the given reducer to      * combine values, and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all (key, value) pairs      */
DECL|method|reduceToIntInParallel
specifier|public
name|int
name|reduceToIntInParallel
parameter_list|(
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceToInt
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Performs the given action for each key.      *      * @param action the action      */
DECL|method|forEachKeyInParallel
specifier|public
name|void
name|forEachKeyInParallel
parameter_list|(
name|Action
argument_list|<
name|K
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEachKey
argument_list|(
name|this
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each key.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      */
DECL|method|forEachKeyInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachKeyInParallel
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEachKey
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each key, or null if none. Upon success,      * further element processing is suppressed and the results of      * any other parallel invocations of the search function are      * ignored.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each key, or null if none      */
DECL|method|searchKeysInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchKeysInParallel
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|searchKeys
argument_list|(
name|this
argument_list|,
name|searchFunction
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating all keys using the given      * reducer to combine values, or null if none.      *      * @param reducer a commutative associative combining function      * @return the result of accumulating all keys using the given      * reducer to combine values, or null if none      */
DECL|method|reduceKeysInParallel
specifier|public
name|K
name|reduceKeysInParallel
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceKeys
argument_list|(
name|this
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, or      * null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceKeysInParallel
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceKeys
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return  the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysToDoubleInParallel
specifier|public
name|double
name|reduceKeysToDoubleInParallel
parameter_list|(
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceKeysToDouble
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysToLongInParallel
specifier|public
name|long
name|reduceKeysToLongInParallel
parameter_list|(
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceKeysToLong
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all keys using the given reducer to combine values, and      * the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all keys      */
DECL|method|reduceKeysToIntInParallel
specifier|public
name|int
name|reduceKeysToIntInParallel
parameter_list|(
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceKeysToInt
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Performs the given action for each value.      *      * @param action the action      */
DECL|method|forEachValueInParallel
specifier|public
name|void
name|forEachValueInParallel
parameter_list|(
name|Action
argument_list|<
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEachValue
argument_list|(
name|this
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each value.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      */
DECL|method|forEachValueInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachValueInParallel
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEachValue
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each value, or null if none.  Upon success,      * further element processing is suppressed and the results of      * any other parallel invocations of the search function are      * ignored.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each value, or null if none      */
DECL|method|searchValuesInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchValuesInParallel
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|searchValues
argument_list|(
name|this
argument_list|,
name|searchFunction
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating all values using the      * given reducer to combine values, or null if none.      *      * @param reducer a commutative associative combining function      * @return  the result of accumulating all values      */
DECL|method|reduceValuesInParallel
specifier|public
name|V
name|reduceValuesInParallel
parameter_list|(
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceValues
argument_list|(
name|this
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values, or      * null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceValuesInParallel
parameter_list|(
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceValues
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesToDoubleInParallel
specifier|public
name|double
name|reduceValuesToDoubleInParallel
parameter_list|(
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceValuesToDouble
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesToLongInParallel
specifier|public
name|long
name|reduceValuesToLongInParallel
parameter_list|(
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceValuesToLong
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all values using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all values      */
DECL|method|reduceValuesToIntInParallel
specifier|public
name|int
name|reduceValuesToIntInParallel
parameter_list|(
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceValuesToInt
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Performs the given action for each entry.      *      * @param action the action      */
DECL|method|forEachEntryInParallel
specifier|public
name|void
name|forEachEntryInParallel
parameter_list|(
name|Action
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEachEntry
argument_list|(
name|this
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Performs the given action for each non-null transformation      * of each entry.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case the action is not applied)      * @param action the action      */
DECL|method|forEachEntryInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|void
name|forEachEntryInParallel
parameter_list|(
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|ForkJoinTasks
operator|.
name|forEachEntry
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|invoke
argument_list|()
expr_stmt|;
block|}
comment|/**      * Returns a non-null result from applying the given search      * function on each entry, or null if none.  Upon success,      * further element processing is suppressed and the results of      * any other parallel invocations of the search function are      * ignored.      *      * @param searchFunction a function returning a non-null      * result on success, else null      * @return a non-null result from applying the given search      * function on each entry, or null if none      */
DECL|method|searchEntriesInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|searchEntriesInParallel
parameter_list|(
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|searchEntries
argument_list|(
name|this
argument_list|,
name|searchFunction
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating all entries using the      * given reducer to combine values, or null if none.      *      * @param reducer a commutative associative combining function      * @return the result of accumulating all entries      */
DECL|method|reduceEntriesInParallel
specifier|public
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|reduceEntriesInParallel
parameter_list|(
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceEntries
argument_list|(
name|this
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * or null if none.      *      * @param transformer a function returning the transformation      * for an element, or null if there is no transformation (in      * which case it is not combined)      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesInParallel
specifier|public
parameter_list|<
name|U
parameter_list|>
name|U
name|reduceEntriesInParallel
parameter_list|(
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceEntries
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesToDoubleInParallel
specifier|public
name|double
name|reduceEntriesToDoubleInParallel
parameter_list|(
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceEntriesToDouble
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return  the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesToLongInParallel
specifier|public
name|long
name|reduceEntriesToLongInParallel
parameter_list|(
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceEntriesToLong
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/**      * Returns the result of accumulating the given transformation      * of all entries using the given reducer to combine values,      * and the given basis as an identity value.      *      * @param transformer a function returning the transformation      * for an element      * @param basis the identity (initial default value) for the reduction      * @param reducer a commutative associative combining function      * @return the result of accumulating the given transformation      * of all entries      */
DECL|method|reduceEntriesToIntInParallel
specifier|public
name|int
name|reduceEntriesToIntInParallel
parameter_list|(
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
return|return
name|ForkJoinTasks
operator|.
name|reduceEntriesToInt
argument_list|(
name|this
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
operator|.
name|invoke
argument_list|()
return|;
block|}
comment|/* ----------------Views -------------- */
comment|/**      * Base class for views.      */
DECL|class|CHMView
specifier|abstract
specifier|static
class|class
name|CHMView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
block|{
DECL|field|map
specifier|final
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
decl_stmt|;
DECL|method|CHMView
name|CHMView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|this
operator|.
name|map
operator|=
name|map
expr_stmt|;
block|}
comment|/**          * Returns the map backing this view.          *          * @return the map backing this view          */
DECL|method|getMap
specifier|public
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getMap
parameter_list|()
block|{
return|return
name|map
return|;
block|}
DECL|method|size
specifier|public
specifier|final
name|int
name|size
parameter_list|()
block|{
return|return
name|map
operator|.
name|size
argument_list|()
return|;
block|}
DECL|method|isEmpty
specifier|public
specifier|final
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|map
operator|.
name|isEmpty
argument_list|()
return|;
block|}
DECL|method|clear
specifier|public
specifier|final
name|void
name|clear
parameter_list|()
block|{
name|map
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// implementations below rely on concrete classes supplying these
DECL|method|iterator
specifier|public
specifier|abstract
name|Iterator
argument_list|<
name|?
argument_list|>
name|iterator
parameter_list|()
function_decl|;
DECL|method|contains
specifier|public
specifier|abstract
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
DECL|method|remove
specifier|public
specifier|abstract
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
function_decl|;
DECL|field|oomeMsg
specifier|private
specifier|static
specifier|final
name|String
name|oomeMsg
init|=
literal|"Required array size too large"
decl_stmt|;
DECL|method|toArray
specifier|public
specifier|final
name|Object
index|[]
name|toArray
parameter_list|()
block|{
name|long
name|sz
init|=
name|map
operator|.
name|mappingCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|>
call|(
name|long
call|)
argument_list|(
name|MAX_ARRAY_SIZE
argument_list|)
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
name|int
name|n
init|=
operator|(
name|int
operator|)
name|sz
decl_stmt|;
name|Object
index|[]
name|r
init|=
operator|new
name|Object
index|[
name|n
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
operator|-
operator|(
name|MAX_ARRAY_SIZE
operator|>>>
literal|1
operator|)
operator|-
literal|1
condition|)
name|n
operator|=
name|MAX_ARRAY_SIZE
expr_stmt|;
else|else
name|n
operator|+=
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|r
index|[
name|i
operator|++
index|]
operator|=
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|==
name|n
operator|)
condition|?
name|r
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|toArray
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
name|long
name|sz
init|=
name|map
operator|.
name|mappingCount
argument_list|()
decl_stmt|;
if|if
condition|(
name|sz
operator|>
call|(
name|long
call|)
argument_list|(
name|MAX_ARRAY_SIZE
argument_list|)
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
name|int
name|m
init|=
operator|(
name|int
operator|)
name|sz
decl_stmt|;
name|T
index|[]
name|r
init|=
operator|(
name|a
operator|.
name|length
operator|>=
name|m
operator|)
condition|?
name|a
else|:
operator|(
name|T
index|[]
operator|)
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Array
operator|.
name|newInstance
argument_list|(
name|a
operator|.
name|getClass
argument_list|()
operator|.
name|getComponentType
argument_list|()
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|r
operator|.
name|length
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iterator
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
condition|)
throw|throw
operator|new
name|OutOfMemoryError
argument_list|(
name|oomeMsg
argument_list|)
throw|;
if|if
condition|(
name|n
operator|>=
name|MAX_ARRAY_SIZE
operator|-
operator|(
name|MAX_ARRAY_SIZE
operator|>>>
literal|1
operator|)
operator|-
literal|1
condition|)
name|n
operator|=
name|MAX_ARRAY_SIZE
expr_stmt|;
else|else
name|n
operator|+=
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|r
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|T
operator|)
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
name|r
operator|&&
name|i
operator|<
name|n
condition|)
block|{
name|r
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
comment|// null-terminate
return|return
name|r
return|;
block|}
return|return
operator|(
name|i
operator|==
name|n
operator|)
condition|?
name|r
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|r
argument_list|,
name|i
argument_list|)
return|;
block|}
DECL|method|hashCode
specifier|public
specifier|final
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
name|h
operator|+=
name|it
operator|.
name|next
argument_list|()
operator|.
name|hashCode
argument_list|()
expr_stmt|;
return|return
name|h
return|;
block|}
DECL|method|toString
specifier|public
specifier|final
name|String
name|toString
parameter_list|()
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iterator
argument_list|()
decl_stmt|;
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|e
operator|==
name|this
condition|?
literal|"(this Collection)"
else|:
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
break|break;
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
DECL|method|containsAll
specifier|public
specifier|final
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|!=
name|this
condition|)
block|{
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|c
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Object
name|e
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|null
operator|||
operator|!
name|contains
argument_list|(
name|e
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
DECL|method|removeAll
specifier|public
specifier|final
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
DECL|method|retainAll
specifier|public
specifier|final
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|modified
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|c
operator|.
name|contains
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
name|modified
operator|=
literal|true
expr_stmt|;
block|}
block|}
return|return
name|modified
return|;
block|}
block|}
comment|/**      * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in      * which additions may optionally be enabled by mapping to a      * common value.  This class cannot be directly instantiated. See      * {@link #keySet()}, {@link #keySet(Object)}, {@link #newKeySet()},      * {@link #newKeySet(int)}.      */
DECL|class|KeySetView
specifier|public
specifier|static
class|class
name|KeySetView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|CHMView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|K
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|7249069246763182397L
decl_stmt|;
DECL|field|value
specifier|private
specifier|final
name|V
name|value
decl_stmt|;
DECL|method|KeySetView
name|KeySetView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|V
name|value
parameter_list|)
block|{
comment|// non-public
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|this
operator|.
name|value
operator|=
name|value
expr_stmt|;
block|}
comment|/**          * Returns the default mapped value for additions,          * or {@code null} if additions are not supported.          *          * @return the default mapped value for additions, or {@code null}          * if not supported          */
DECL|method|getMappedValue
specifier|public
name|V
name|getMappedValue
parameter_list|()
block|{
return|return
name|value
return|;
block|}
comment|// implement Set API
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsKey
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|remove
argument_list|(
name|o
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**          * Returns a "weakly consistent" iterator that will never          * throw {@link ConcurrentModificationException}, and          * guarantees to traverse elements as they existed upon          * construction of the iterator, and may (but is not          * guaranteed to) reflect any modifications subsequent to          * construction.          *          * @return an iterator over the keys of this map          */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|K
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|KeyIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|K
name|e
parameter_list|)
block|{
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|value
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
return|return
name|map
operator|.
name|internalPut
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
return|;
block|}
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|K
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
name|V
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|value
operator|)
operator|==
literal|null
condition|)
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
for|for
control|(
name|K
name|e
range|:
name|c
control|)
block|{
if|if
condition|(
name|map
operator|.
name|internalPut
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
literal|true
argument_list|)
operator|==
literal|null
condition|)
name|added
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Set
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|o
operator|)
operator|==
name|this
operator|||
operator|(
name|containsAll
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|.
name|containsAll
argument_list|(
name|this
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
block|}
comment|/**      * A view of a ConcurrentHashMapV8 as a {@link Collection} of      * values, in which additions are disabled. This class cannot be      * directly instantiated. See {@link #values()}.      *      *<p>The view's {@code iterator} is a "weakly consistent" iterator      * that will never throw {@link ConcurrentModificationException},      * and guarantees to traverse elements as they existed upon      * construction of the iterator, and may (but is not guaranteed to)      * reflect any modifications subsequent to construction.      */
DECL|class|ValuesView
specifier|public
specifier|static
specifier|final
class|class
name|ValuesView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|CHMView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Collection
argument_list|<
name|V
argument_list|>
block|{
DECL|method|ValuesView
name|ValuesView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|contains
specifier|public
specifier|final
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|map
operator|.
name|containsValue
argument_list|(
name|o
argument_list|)
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
condition|)
block|{
name|Iterator
argument_list|<
name|V
argument_list|>
name|it
init|=
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
if|if
condition|(
name|o
operator|.
name|equals
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
condition|)
block|{
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Returns a "weakly consistent" iterator that will never          * throw {@link ConcurrentModificationException}, and          * guarantees to traverse elements as they existed upon          * construction of the iterator, and may (but is not          * guaranteed to) reflect any modifications subsequent to          * construction.          *          * @return an iterator over the values of this map          */
DECL|method|iterator
specifier|public
specifier|final
name|Iterator
argument_list|<
name|V
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|ValueIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
specifier|final
name|boolean
name|add
parameter_list|(
name|V
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
DECL|method|addAll
specifier|public
specifier|final
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|V
argument_list|>
name|c
parameter_list|)
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/**      * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)      * entries.  This class cannot be directly instantiated. See      * {@link #entrySet()}.      */
DECL|class|EntrySetView
specifier|public
specifier|static
specifier|final
class|class
name|EntrySetView
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|CHMView
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
implements|implements
name|Set
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|method|EntrySetView
name|EntrySetView
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|)
block|{
name|super
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
DECL|method|contains
specifier|public
specifier|final
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|,
name|r
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|r
operator|=
name|map
operator|.
name|get
argument_list|(
name|k
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|==
name|r
operator|||
name|v
operator|.
name|equals
argument_list|(
name|r
argument_list|)
operator|)
operator|)
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Object
name|k
decl_stmt|,
name|v
decl_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
name|e
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Map
operator|.
name|Entry
operator|)
operator|&&
operator|(
name|k
operator|=
operator|(
name|e
operator|=
operator|(
name|Map
operator|.
name|Entry
argument_list|<
name|?
argument_list|,
name|?
argument_list|>
operator|)
name|o
operator|)
operator|.
name|getKey
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|v
operator|=
name|e
operator|.
name|getValue
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|map
operator|.
name|remove
argument_list|(
name|k
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
comment|/**          * Returns a "weakly consistent" iterator that will never          * throw {@link ConcurrentModificationException}, and          * guarantees to traverse elements as they existed upon          * construction of the iterator, and may (but is not          * guaranteed to) reflect any modifications subsequent to          * construction.          *          * @return an iterator over the entries of this map          */
DECL|method|iterator
specifier|public
specifier|final
name|Iterator
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|EntryIterator
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|)
return|;
block|}
DECL|method|add
specifier|public
specifier|final
name|boolean
name|add
parameter_list|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
parameter_list|)
block|{
return|return
name|map
operator|.
name|internalPut
argument_list|(
name|e
operator|.
name|getKey
argument_list|()
argument_list|,
name|e
operator|.
name|getValue
argument_list|()
argument_list|,
literal|false
argument_list|)
operator|==
literal|null
return|;
block|}
DECL|method|addAll
specifier|public
specifier|final
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|added
init|=
literal|false
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|e
range|:
name|c
control|)
block|{
if|if
condition|(
name|add
argument_list|(
name|e
argument_list|)
condition|)
name|added
operator|=
literal|true
expr_stmt|;
block|}
return|return
name|added
return|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|Set
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
return|return
operator|(
operator|(
name|o
operator|instanceof
name|Set
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
operator|(
name|Set
argument_list|<
name|?
argument_list|>
operator|)
name|o
operator|)
operator|==
name|this
operator|||
operator|(
name|containsAll
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|.
name|containsAll
argument_list|(
name|this
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
block|}
comment|// ---------------------------------------------------------------------
comment|/**      * Predefined tasks for performing bulk parallel operations on      * ConcurrentHashMapV8s. These tasks follow the forms and rules used      * for bulk operations. Each method has the same name, but returns      * a task rather than invoking it. These methods may be useful in      * custom applications such as submitting a task without waiting      * for completion, using a custom pool, or combining with other      * tasks.      */
DECL|class|ForkJoinTasks
specifier|public
specifier|static
class|class
name|ForkJoinTasks
block|{
DECL|method|ForkJoinTasks
specifier|private
name|ForkJoinTasks
parameter_list|()
block|{}
comment|/**          * Returns a task that when invoked, performs the given          * action for each (key, value)          *          * @param map the map          * @param action the action          * @return the task          */
DECL|method|forEach
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEach
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|BiAction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, performs the given          * action for each non-null transformation of each (key, value)          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case the action is not applied)          * @param action the action          * @return the task          */
DECL|method|forEach
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEach
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachTransformedMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns a non-null result          * from applying the given search function on each (key,          * value), or null if none. Upon success, further element          * processing is suppressed and the results of any other          * parallel invocations of the search function are ignored.          *          * @param map the map          * @param searchFunction a function returning a non-null          * result on success, else null          * @return the task          */
DECL|method|search
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|search
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all (key, value) pairs          * using the given reducer to combine values, or null if none.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case it is not combined)          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduce
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|reduce
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all (key, value) pairs          * using the given reducer to combine values, and the given          * basis as an identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceToDouble
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Double
argument_list|>
name|reduceToDouble
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all (key, value) pairs          * using the given reducer to combine values, and the given          * basis as an identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceToLong
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Long
argument_list|>
name|reduceToLong
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all (key, value) pairs          * using the given reducer to combine values, and the given          * basis as an identity value.          *          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceToInt
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Integer
argument_list|>
name|reduceToInt
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, performs the given action          * for each key.          *          * @param map the map          * @param action the action          * @return the task          */
DECL|method|forEachKey
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEachKey
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Action
argument_list|<
name|K
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, performs the given action          * for each non-null transformation of each key.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case the action is not applied)          * @param action the action          * @return the task          */
DECL|method|forEachKey
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEachKey
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachTransformedKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns a non-null result          * from applying the given search function on each key, or          * null if none.  Upon success, further element processing is          * suppressed and the results of any other parallel          * invocations of the search function are ignored.          *          * @param map the map          * @param searchFunction a function returning a non-null          * result on success, else null          * @return the task          */
DECL|method|searchKeys
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|searchKeys
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating all keys using the given reducer to combine          * values, or null if none.          *          * @param map the map          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceKeys
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|K
argument_list|>
name|reduceKeys
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all keys using the given          * reducer to combine values, or null if none.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case it is not combined)          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceKeys
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|reduceKeys
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all keys using the given          * reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceKeysToDouble
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Double
argument_list|>
name|reduceKeysToDouble
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all keys using the given          * reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceKeysToLong
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Long
argument_list|>
name|reduceKeysToLong
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all keys using the given          * reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceKeysToInt
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Integer
argument_list|>
name|reduceKeysToInt
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, performs the given action          * for each value.          *          * @param map the map          * @param action the action          */
DECL|method|forEachValue
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEachValue
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Action
argument_list|<
name|V
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, performs the given action          * for each non-null transformation of each value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case the action is not applied)          * @param action the action          */
DECL|method|forEachValue
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEachValue
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachTransformedValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns a non-null result          * from applying the given search function on each value, or          * null if none.  Upon success, further element processing is          * suppressed and the results of any other parallel          * invocations of the search function are ignored.          *          * @param map the map          * @param searchFunction a function returning a non-null          * result on success, else null          * @return the task          */
DECL|method|searchValues
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|searchValues
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating all values using the given reducer to combine          * values, or null if none.          *          * @param map the map          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceValues
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|V
argument_list|>
name|reduceValues
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all values using the          * given reducer to combine values, or null if none.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case it is not combined)          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceValues
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|reduceValues
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all values using the          * given reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceValuesToDouble
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Double
argument_list|>
name|reduceValuesToDouble
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all values using the          * given reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceValuesToLong
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Long
argument_list|>
name|reduceValuesToLong
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all values using the          * given reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceValuesToInt
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Integer
argument_list|>
name|reduceValuesToInt
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, perform the given action          * for each entry.          *          * @param map the map          * @param action the action          */
DECL|method|forEachEntry
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEachEntry
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Action
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, perform the given action          * for each non-null transformation of each entry.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case the action is not applied)          * @param action the action          */
DECL|method|forEachEntry
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
name|forEachEntry
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|action
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ForEachTransformedEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns a non-null result          * from applying the given search function on each entry, or          * null if none.  Upon success, further element processing is          * suppressed and the results of any other parallel          * invocations of the search function are ignored.          *          * @param map the map          * @param searchFunction a function returning a non-null          * result on success, else null          * @return the task          */
DECL|method|searchEntries
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|searchEntries
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|)
block|{
if|if
condition|(
name|searchFunction
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|SearchEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
name|searchFunction
argument_list|,
operator|new
name|AtomicReference
argument_list|<
name|U
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating all entries using the given reducer to combine          * values, or null if none.          *          * @param map the map          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceEntries
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reduceEntries
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all entries using the          * given reducer to combine values, or null if none.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element, or null if there is no transformation (in          * which case it is not combined)          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceEntries
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
name|ForkJoinTask
argument_list|<
name|U
argument_list|>
name|reduceEntries
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all entries using the          * given reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceEntriesToDouble
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Double
argument_list|>
name|reduceEntriesToDouble
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all entries using the          * given reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceEntriesToLong
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Long
argument_list|>
name|reduceEntriesToLong
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
comment|/**          * Returns a task that when invoked, returns the result of          * accumulating the given transformation of all entries using the          * given reducer to combine values, and the given basis as an          * identity value.          *          * @param map the map          * @param transformer a function returning the transformation          * for an element          * @param basis the identity (initial default value) for the reduction          * @param reducer a commutative associative combining function          * @return the task          */
DECL|method|reduceEntriesToInt
specifier|public
specifier|static
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
name|ForkJoinTask
argument_list|<
name|Integer
argument_list|>
name|reduceEntriesToInt
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|map
parameter_list|,
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
if|if
condition|(
name|transformer
operator|==
literal|null
operator|||
name|reducer
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
return|return
operator|new
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
literal|null
argument_list|,
operator|-
literal|1
argument_list|,
literal|null
argument_list|,
name|transformer
argument_list|,
name|basis
argument_list|,
name|reducer
argument_list|)
return|;
block|}
block|}
comment|// -------------------------------------------------------
comment|/*      * Task classes. Coded in a regular but ugly format/style to      * simplify checks that each variant differs in the right way from      * others. The null screenings exist because compilers cannot tell      * that we've already null-checked task arguments, so we force      * simplest hoisted bypass to help avoid convoluted traps.      */
DECL|class|ForEachKeyTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachKeyTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|Action
argument_list|<
name|K
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachKeyTask
name|ForEachKeyTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Action
argument_list|<
name|K
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Action
argument_list|<
name|K
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
while|while
condition|(
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|ForEachValueTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachValueTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|Action
argument_list|<
name|V
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachValueTask
name|ForEachValueTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Action
argument_list|<
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Action
argument_list|<
name|V
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|ForEachEntryTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachEntryTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|Action
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachEntryTask
name|ForEachEntryTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Action
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Action
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|ForEachMappingTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachMappingTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|action
specifier|final
name|BiAction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachMappingTask
name|ForEachMappingTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|BiAction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiAction
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|ForEachTransformedKeyTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachTransformedKeyTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedKeyTask
name|ForEachTransformedKeyTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachTransformedKeyTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
name|advance
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|ForEachTransformedValueTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachTransformedValueTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedValueTask
name|ForEachTransformedValueTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachTransformedValueTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|ForEachTransformedEntryTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachTransformedEntryTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedEntryTask
name|ForEachTransformedEntryTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachTransformedEntryTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|ForEachTransformedMappingTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ForEachTransformedMappingTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Void
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|action
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
DECL|method|ForEachTransformedMappingTask
name|ForEachTransformedMappingTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|Action
argument_list|<
name|U
argument_list|>
name|action
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|action
operator|=
name|action
expr_stmt|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|Action
argument_list|<
name|U
argument_list|>
name|action
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|action
operator|=
name|this
operator|.
name|action
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|new
name|ForEachTransformedMappingTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|transformer
argument_list|,
name|action
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|action
operator|.
name|apply
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
name|propagateCompletion
argument_list|()
expr_stmt|;
block|}
block|}
block|}
DECL|class|SearchKeysTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|SearchKeysTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchKeysTask
name|SearchKeysTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
if|if
condition|(
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|<=
literal|0
condition|)
break|break;
operator|new
name|SearchKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|U
name|u
decl_stmt|;
if|if
condition|(
name|advance
argument_list|()
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
DECL|class|SearchValuesTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|SearchValuesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchValuesTask
name|SearchValuesTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
if|if
condition|(
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|<=
literal|0
condition|)
break|break;
operator|new
name|SearchValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
DECL|class|SearchEntriesTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|SearchEntriesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|Fun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchEntriesTask
name|SearchEntriesTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|Fun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
if|if
condition|(
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|<=
literal|0
condition|)
break|break;
operator|new
name|SearchEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
DECL|class|SearchMappingsTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|SearchMappingsTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|searchFunction
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
DECL|field|result
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
DECL|method|SearchMappingsTask
name|SearchMappingsTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
parameter_list|,
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|searchFunction
operator|=
name|searchFunction
expr_stmt|;
name|this
operator|.
name|result
operator|=
name|result
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
operator|.
name|get
argument_list|()
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|searchFunction
decl_stmt|;
specifier|final
name|AtomicReference
argument_list|<
name|U
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|searchFunction
operator|=
name|this
operator|.
name|searchFunction
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|result
operator|=
name|this
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
condition|;
control|)
block|{
if|if
condition|(
name|result
operator|.
name|get
argument_list|()
operator|!=
literal|null
condition|)
return|return;
if|if
condition|(
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|<=
literal|0
condition|)
break|break;
operator|new
name|SearchMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|searchFunction
argument_list|,
name|result
argument_list|)
operator|.
name|fork
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|result
operator|.
name|get
argument_list|()
operator|==
literal|null
condition|)
block|{
name|V
name|v
decl_stmt|;
name|U
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|==
literal|null
condition|)
block|{
name|propagateCompletion
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|u
operator|=
name|searchFunction
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|result
operator|.
name|compareAndSet
argument_list|(
literal|null
argument_list|,
name|u
argument_list|)
condition|)
name|quietlyCompleteRoot
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
DECL|class|ReduceKeysTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ReduceKeysTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|K
argument_list|>
block|{
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|K
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|ReduceKeysTask
name|ReduceKeysTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|K
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|K
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|K
name|r
init|=
literal|null
decl_stmt|;
while|while
condition|(
name|advance
argument_list|()
operator|!=
literal|null
condition|)
block|{
name|K
name|u
init|=
operator|(
name|K
operator|)
name|nextKey
decl_stmt|;
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|ReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|K
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|ReduceValuesTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ReduceValuesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|V
argument_list|>
block|{
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|V
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|ReduceValuesTask
name|ReduceValuesTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|V
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|V
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|r
init|=
literal|null
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|V
name|u
init|=
name|v
decl_stmt|;
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|ReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|V
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|ReduceEntriesTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|ReduceEntriesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
block|{
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|ReduceEntriesTask
name|ReduceEntriesTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|r
init|=
literal|null
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|u
init|=
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
decl_stmt|;
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|ReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceKeysTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceKeysTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysTask
name|MapReduceKeysTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
while|while
condition|(
name|advance
argument_list|()
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceValuesTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceValuesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesTask
name|MapReduceValuesTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceEntriesTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceEntriesTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesTask
name|MapReduceEntriesTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|Fun
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceMappingsTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceMappingsTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|,
name|U
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
DECL|field|result
name|U
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsTask
name|MapReduceMappingsTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|nextRight
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
parameter_list|,
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|U
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|BiFun
argument_list|<
name|?
super|super
name|U
argument_list|,
name|?
super|super
name|U
argument_list|,
name|?
extends|extends
name|U
argument_list|>
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|U
name|r
init|=
literal|null
decl_stmt|,
name|u
decl_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|(
name|u
operator|=
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
operator|(
name|r
operator|==
literal|null
operator|)
condition|?
name|u
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|U
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|U
name|tr
decl_stmt|,
name|sr
decl_stmt|;
if|if
condition|(
operator|(
name|sr
operator|=
name|s
operator|.
name|result
operator|)
operator|!=
literal|null
condition|)
name|t
operator|.
name|result
operator|=
operator|(
operator|(
operator|(
name|tr
operator|=
name|t
operator|.
name|result
operator|)
operator|==
literal|null
operator|)
condition|?
name|sr
else|:
name|reducer
operator|.
name|apply
argument_list|(
name|tr
argument_list|,
name|sr
argument_list|)
operator|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceKeysToDoubleTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceKeysToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysToDoubleTask
name|MapReduceKeysToDoubleTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
while|while
condition|(
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceValuesToDoubleTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceValuesToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesToDoubleTask
name|MapReduceValuesToDoubleTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToDouble
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceEntriesToDoubleTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceEntriesToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesToDoubleTask
name|MapReduceEntriesToDoubleTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToDouble
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceMappingsToDoubleTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceMappingsToDoubleTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Double
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|double
name|basis
decl_stmt|;
DECL|field|result
name|double
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsToDoubleTask
name|MapReduceMappingsToDoubleTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|double
name|basis
parameter_list|,
name|DoubleByDoubleToDouble
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Double
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectByObjectToDouble
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|DoubleByDoubleToDouble
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|double
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsToDoubleTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceKeysToLongTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceKeysToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysToLongTask
name|MapReduceKeysToLongTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
while|while
condition|(
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceValuesToLongTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceValuesToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesToLongTask
name|MapReduceValuesToLongTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToLong
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceEntriesToLongTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceEntriesToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesToLongTask
name|MapReduceEntriesToLongTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToLong
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceMappingsToLongTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceMappingsToLongTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Long
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|long
name|basis
decl_stmt|;
DECL|field|result
name|long
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsToLongTask
name|MapReduceMappingsToLongTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|long
name|basis
parameter_list|,
name|LongByLongToLong
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Long
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectByObjectToLong
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|LongByLongToLong
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsToLongTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceKeysToIntTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceKeysToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceKeysToIntTask
name|MapReduceKeysToIntTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
while|while
condition|(
name|advance
argument_list|()
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceKeysToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceValuesToIntTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceValuesToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceValuesToIntTask
name|MapReduceValuesToIntTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToInt
argument_list|<
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceValuesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceEntriesToIntTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceEntriesToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceEntriesToIntTask
name|MapReduceEntriesToIntTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectToInt
argument_list|<
name|Map
operator|.
name|Entry
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
name|entryFor
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceEntriesToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
DECL|class|MapReduceMappingsToIntTask
annotation|@
name|SuppressWarnings
argument_list|(
literal|"serial"
argument_list|)
specifier|static
specifier|final
class|class
name|MapReduceMappingsToIntTask
parameter_list|<
name|K
parameter_list|,
name|V
parameter_list|>
extends|extends
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|Integer
argument_list|>
block|{
DECL|field|transformer
specifier|final
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
DECL|field|reducer
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
DECL|field|basis
specifier|final
name|int
name|basis
decl_stmt|;
DECL|field|result
name|int
name|result
decl_stmt|;
DECL|field|rights
DECL|field|nextRight
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|rights
decl_stmt|,
name|nextRight
decl_stmt|;
DECL|method|MapReduceMappingsToIntTask
name|MapReduceMappingsToIntTask
parameter_list|(
name|ConcurrentHashMapV8
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|m
parameter_list|,
name|Traverser
argument_list|<
name|K
argument_list|,
name|V
argument_list|,
name|?
argument_list|>
name|p
parameter_list|,
name|int
name|b
parameter_list|,
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|nextRight
parameter_list|,
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
parameter_list|,
name|int
name|basis
parameter_list|,
name|IntByIntToInt
name|reducer
parameter_list|)
block|{
name|super
argument_list|(
name|m
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|this
operator|.
name|nextRight
operator|=
name|nextRight
expr_stmt|;
name|this
operator|.
name|transformer
operator|=
name|transformer
expr_stmt|;
name|this
operator|.
name|basis
operator|=
name|basis
expr_stmt|;
name|this
operator|.
name|reducer
operator|=
name|reducer
expr_stmt|;
block|}
DECL|method|getRawResult
specifier|public
specifier|final
name|Integer
name|getRawResult
parameter_list|()
block|{
return|return
name|result
return|;
block|}
DECL|method|compute
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
specifier|final
name|void
name|compute
parameter_list|()
block|{
specifier|final
name|ObjectByObjectToInt
argument_list|<
name|?
super|super
name|K
argument_list|,
name|?
super|super
name|V
argument_list|>
name|transformer
decl_stmt|;
specifier|final
name|IntByIntToInt
name|reducer
decl_stmt|;
if|if
condition|(
operator|(
name|transformer
operator|=
name|this
operator|.
name|transformer
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|reducer
operator|=
name|this
operator|.
name|reducer
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|r
init|=
name|this
operator|.
name|basis
decl_stmt|;
for|for
control|(
name|int
name|b
init|;
operator|(
name|b
operator|=
name|preSplit
argument_list|()
operator|)
operator|>
literal|0
condition|;
control|)
operator|(
name|rights
operator|=
operator|new
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
argument_list|(
name|map
argument_list|,
name|this
argument_list|,
name|b
argument_list|,
name|rights
argument_list|,
name|transformer
argument_list|,
name|r
argument_list|,
name|reducer
argument_list|)
operator|)
operator|.
name|fork
argument_list|()
expr_stmt|;
name|V
name|v
decl_stmt|;
while|while
condition|(
operator|(
name|v
operator|=
name|advance
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|r
argument_list|,
name|transformer
operator|.
name|apply
argument_list|(
operator|(
name|K
operator|)
name|nextKey
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|r
expr_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|firstComplete
argument_list|()
init|;
name|c
operator|!=
literal|null
condition|;
name|c
operator|=
name|c
operator|.
name|nextComplete
argument_list|()
control|)
block|{
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
name|t
init|=
operator|(
name|MapReduceMappingsToIntTask
argument_list|<
name|K
argument_list|,
name|V
argument_list|>
operator|)
name|c
decl_stmt|,
name|s
init|=
name|t
operator|.
name|rights
decl_stmt|;
while|while
condition|(
name|s
operator|!=
literal|null
condition|)
block|{
name|t
operator|.
name|result
operator|=
name|reducer
operator|.
name|apply
argument_list|(
name|t
operator|.
name|result
argument_list|,
name|s
operator|.
name|result
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
operator|.
name|rights
operator|=
name|s
operator|.
name|nextRight
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|SIZECTL
specifier|private
specifier|static
specifier|final
name|long
name|SIZECTL
decl_stmt|;
DECL|field|TRANSFERINDEX
specifier|private
specifier|static
specifier|final
name|long
name|TRANSFERINDEX
decl_stmt|;
DECL|field|TRANSFERORIGIN
specifier|private
specifier|static
specifier|final
name|long
name|TRANSFERORIGIN
decl_stmt|;
DECL|field|BASECOUNT
specifier|private
specifier|static
specifier|final
name|long
name|BASECOUNT
decl_stmt|;
DECL|field|COUNTERBUSY
specifier|private
specifier|static
specifier|final
name|long
name|COUNTERBUSY
decl_stmt|;
DECL|field|CELLVALUE
specifier|private
specifier|static
specifier|final
name|long
name|CELLVALUE
decl_stmt|;
DECL|field|ABASE
specifier|private
specifier|static
specifier|final
name|long
name|ABASE
decl_stmt|;
DECL|field|ASHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ASHIFT
decl_stmt|;
static|static
block|{
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|ConcurrentHashMapV8
operator|.
name|class
decl_stmt|;
name|SIZECTL
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"sizeCtl"
argument_list|)
argument_list|)
expr_stmt|;
name|TRANSFERINDEX
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"transferIndex"
argument_list|)
argument_list|)
expr_stmt|;
name|TRANSFERORIGIN
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"transferOrigin"
argument_list|)
argument_list|)
expr_stmt|;
name|BASECOUNT
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"baseCount"
argument_list|)
argument_list|)
expr_stmt|;
name|COUNTERBUSY
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"counterBusy"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|ck
init|=
name|CounterCell
operator|.
name|class
decl_stmt|;
name|CELLVALUE
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|ck
operator|.
name|getDeclaredField
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|sc
init|=
name|Node
index|[]
operator|.
name|class
decl_stmt|;
name|ABASE
operator|=
name|U
operator|.
name|arrayBaseOffset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|int
name|scale
init|=
name|U
operator|.
name|arrayIndexScale
argument_list|(
name|sc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|scale
operator|&
operator|(
name|scale
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|ASHIFT
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

