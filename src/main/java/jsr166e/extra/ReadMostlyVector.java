begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e.extra
package|package
name|jsr166e
operator|.
name|extra
package|;
end_package

begin_import
import|import
name|jsr166e
operator|.
name|StampedLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_comment
comment|/**  * A class with the same methods and array-based characteristics as  * {@link java.util.Vector} but with reduced contention and improved  * throughput when invocations of read-only methods by multiple  * threads are most common.  *  *<p>The iterators returned by this class's {@link #iterator()  * iterator} and {@link #listIterator(int) listIterator} methods are  * best-effort in the presence of concurrent modifications, and do  *<em>NOT</em> throw {@link ConcurrentModificationException}.  An  * iterator's {@code next()} method returns consecutive elements as  * they appear in the underlying array upon each access. Alternatively,  * method {@link #snapshotIterator} may be used for deterministic  * traversals, at the expense of making a copy, and unavailability of  * method {@code Iterator.remove}.  *  *<p>Otherwise, this class supports all methods, under the same  * documented specifications, as {@code Vector}.  Consult {@link  * java.util.Vector} for detailed specifications.  Additionally, this  * class provides methods {@link #addIfAbsent} and {@link  * #addAllAbsent}.  *  * @author Doug Lea  */
end_comment

begin_class
DECL|class|ReadMostlyVector
specifier|public
class|class
name|ReadMostlyVector
parameter_list|<
name|E
parameter_list|>
implements|implements
name|List
argument_list|<
name|E
argument_list|>
implements|,
name|RandomAccess
implements|,
name|Cloneable
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|8673264195747942595L
decl_stmt|;
comment|/*      * This class exists mainly as a vehicle to exercise various      * constructions using SequenceLocks. Read-only methods      * take one of a few forms:      *      * Short methods,including get(index), continually retry obtaining      * a snapshot of array, count, and element, using sequence number      * to validate.      *      * Methods that are potentially O(n) (or worse) try once in      * read-only mode, and then lock. When in read-only mode, they      * validate only at the end of an array scan unless the element is      * actually used (for example, as an argument of method equals).      *      * We rely on some invariants that are always true, even for field      * reads in read-only mode that have not yet been validated:      * - array != null      * - count>= 0      */
comment|/**      * The maximum size of array to allocate.      * See CopyOnWriteArrayList for explanation.      */
DECL|field|MAX_ARRAY_SIZE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_ARRAY_SIZE
init|=
name|Integer
operator|.
name|MAX_VALUE
operator|-
literal|8
decl_stmt|;
comment|// fields are non-private to simplify nested class access
DECL|field|array
name|Object
index|[]
name|array
decl_stmt|;
DECL|field|lock
specifier|final
name|StampedLock
name|lock
decl_stmt|;
DECL|field|count
name|int
name|count
decl_stmt|;
DECL|field|capacityIncrement
specifier|final
name|int
name|capacityIncrement
decl_stmt|;
comment|/**      * Creates an empty vector with the given initial capacity and      * capacity increment.      *      * @param initialCapacity the initial capacity of the underlying array      * @param capacityIncrement if non-zero, the number to      * add when resizing to accommodate additional elements.      * If zero, the array size is doubled when resized.      *      * @throws IllegalArgumentException if initial capacity is negative      */
DECL|method|ReadMostlyVector
specifier|public
name|ReadMostlyVector
parameter_list|(
name|int
name|initialCapacity
parameter_list|,
name|int
name|capacityIncrement
parameter_list|)
block|{
name|super
argument_list|()
expr_stmt|;
if|if
condition|(
name|initialCapacity
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal Capacity: "
operator|+
name|initialCapacity
argument_list|)
throw|;
name|this
operator|.
name|array
operator|=
operator|new
name|Object
index|[
name|initialCapacity
index|]
expr_stmt|;
name|this
operator|.
name|capacityIncrement
operator|=
name|capacityIncrement
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|StampedLock
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates an empty vector with the given initial capacity.      *      * @param initialCapacity the initial capacity of the underlying array      * @throws IllegalArgumentException if initial capacity is negative      */
DECL|method|ReadMostlyVector
specifier|public
name|ReadMostlyVector
parameter_list|(
name|int
name|initialCapacity
parameter_list|)
block|{
name|this
argument_list|(
name|initialCapacity
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates an empty vector.      */
DECL|method|ReadMostlyVector
specifier|public
name|ReadMostlyVector
parameter_list|()
block|{
name|this
operator|.
name|capacityIncrement
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|StampedLock
argument_list|()
expr_stmt|;
block|}
comment|/**      * Creates a vector containing the elements of the specified      * collection, in the order they are returned by the collection's      * iterator.      *      * @param c the collection of initially held elements      * @throws NullPointerException if the specified collection is null      */
DECL|method|ReadMostlyVector
specifier|public
name|ReadMostlyVector
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|Object
index|[]
name|elements
init|=
name|c
operator|.
name|toArray
argument_list|()
decl_stmt|;
comment|// c.toArray might (incorrectly) not return Object[] (see 6260652)
if|if
condition|(
name|elements
operator|.
name|getClass
argument_list|()
operator|!=
name|Object
index|[]
operator|.
name|class
condition|)
name|elements
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|elements
argument_list|,
name|elements
operator|.
name|length
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
expr_stmt|;
name|this
operator|.
name|array
operator|=
name|elements
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|elements
operator|.
name|length
expr_stmt|;
name|this
operator|.
name|capacityIncrement
operator|=
literal|0
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|StampedLock
argument_list|()
expr_stmt|;
block|}
comment|// internal constructor for clone
DECL|method|ReadMostlyVector
name|ReadMostlyVector
parameter_list|(
name|Object
index|[]
name|array
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|capacityIncrement
parameter_list|)
block|{
name|this
operator|.
name|array
operator|=
name|array
expr_stmt|;
name|this
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|this
operator|.
name|capacityIncrement
operator|=
name|capacityIncrement
expr_stmt|;
name|this
operator|.
name|lock
operator|=
operator|new
name|StampedLock
argument_list|()
expr_stmt|;
block|}
DECL|field|INITIAL_CAP
specifier|static
specifier|final
name|int
name|INITIAL_CAP
init|=
literal|16
decl_stmt|;
comment|// For explanation, see CopyOnWriteArrayList
DECL|method|grow
specifier|final
name|Object
index|[]
name|grow
parameter_list|(
name|int
name|minCapacity
parameter_list|)
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|newCapacity
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|==
literal|null
condition|)
name|newCapacity
operator|=
name|INITIAL_CAP
expr_stmt|;
else|else
block|{
name|int
name|oldCapacity
init|=
name|array
operator|.
name|length
decl_stmt|;
name|newCapacity
operator|=
name|oldCapacity
operator|+
operator|(
operator|(
name|capacityIncrement
operator|>
literal|0
operator|)
condition|?
name|capacityIncrement
else|:
name|oldCapacity
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|newCapacity
operator|-
name|minCapacity
operator|<
literal|0
condition|)
name|newCapacity
operator|=
name|minCapacity
expr_stmt|;
if|if
condition|(
name|newCapacity
operator|-
name|MAX_ARRAY_SIZE
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|minCapacity
operator|<
literal|0
condition|)
comment|// overflow
throw|throw
operator|new
name|OutOfMemoryError
argument_list|()
throw|;
elseif|else
if|if
condition|(
name|minCapacity
operator|>
name|MAX_ARRAY_SIZE
condition|)
name|newCapacity
operator|=
name|Integer
operator|.
name|MAX_VALUE
expr_stmt|;
else|else
name|newCapacity
operator|=
name|MAX_ARRAY_SIZE
expr_stmt|;
block|}
return|return
name|array
operator|=
operator|(
operator|(
name|items
operator|==
literal|null
operator|)
condition|?
operator|new
name|Object
index|[
name|newCapacity
index|]
else|:
name|Arrays
operator|.
name|copyOf
argument_list|(
name|items
argument_list|,
name|newCapacity
argument_list|)
operator|)
return|;
block|}
comment|/*      * Internal versions of most base functionality, wrapped      * in different ways from public methods from this class      * as well as sublist and iterator classes.      */
DECL|method|findFirstIndex
specifier|static
name|int
name|findFirstIndex
parameter_list|(
name|Object
index|[]
name|items
parameter_list|,
name|Object
name|x
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|fence
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|items
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|start
init|=
operator|(
name|index
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|index
decl_stmt|;
name|int
name|bound
init|=
operator|(
name|fence
operator|<
name|len
operator|)
condition|?
name|fence
else|:
name|len
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|start
init|;
name|i
operator|<
name|bound
condition|;
operator|++
name|i
control|)
block|{
name|Object
name|e
init|=
name|items
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|==
literal|null
operator|)
condition|?
name|e
operator|==
literal|null
else|:
name|x
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|findLastIndex
specifier|static
name|int
name|findLastIndex
parameter_list|(
name|Object
index|[]
name|items
parameter_list|,
name|Object
name|x
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|origin
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|items
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|last
init|=
operator|(
name|index
operator|<
name|len
operator|)
condition|?
name|index
else|:
name|len
operator|-
literal|1
decl_stmt|;
name|int
name|start
init|=
operator|(
name|origin
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|origin
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|last
init|;
name|i
operator|>=
name|start
condition|;
operator|--
name|i
control|)
block|{
name|Object
name|e
init|=
name|items
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|x
operator|==
literal|null
operator|)
condition|?
name|e
operator|==
literal|null
else|:
name|x
operator|.
name|equals
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
DECL|method|rawAdd
specifier|final
name|void
name|rawAdd
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|int
name|n
init|=
name|count
decl_stmt|;
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|n
operator|>=
name|items
operator|.
name|length
condition|)
name|items
operator|=
name|grow
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|items
index|[
name|n
index|]
operator|=
name|e
expr_stmt|;
name|count
operator|=
name|n
operator|+
literal|1
expr_stmt|;
block|}
DECL|method|rawAddAt
specifier|final
name|void
name|rawAddAt
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|e
parameter_list|)
block|{
name|int
name|n
init|=
name|count
decl_stmt|;
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|index
operator|>
name|n
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|n
operator|>=
name|items
operator|.
name|length
condition|)
name|items
operator|=
name|grow
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|n
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|items
argument_list|,
name|index
argument_list|,
name|items
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|n
operator|-
name|index
argument_list|)
expr_stmt|;
name|items
index|[
name|index
index|]
operator|=
name|e
expr_stmt|;
name|count
operator|=
name|n
operator|+
literal|1
expr_stmt|;
block|}
DECL|method|rawAddAllAt
specifier|final
name|boolean
name|rawAddAllAt
parameter_list|(
name|int
name|index
parameter_list|,
name|Object
index|[]
name|elements
parameter_list|)
block|{
name|int
name|n
init|=
name|count
decl_stmt|;
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|n
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
name|int
name|len
init|=
name|elements
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|false
return|;
name|int
name|newCount
init|=
name|n
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|newCount
operator|>=
name|items
operator|.
name|length
condition|)
name|items
operator|=
name|grow
argument_list|(
name|newCount
argument_list|)
expr_stmt|;
name|int
name|mv
init|=
name|n
operator|-
name|index
decl_stmt|;
if|if
condition|(
name|mv
operator|>
literal|0
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|items
argument_list|,
name|index
argument_list|,
name|items
argument_list|,
name|index
operator|+
name|len
argument_list|,
name|mv
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|items
argument_list|,
name|index
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|count
operator|=
name|newCount
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|rawRemoveAt
specifier|final
name|boolean
name|rawRemoveAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|int
name|n
init|=
name|count
operator|-
literal|1
decl_stmt|;
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|n
condition|)
return|return
literal|false
return|;
name|int
name|mv
init|=
name|n
operator|-
name|index
decl_stmt|;
if|if
condition|(
name|mv
operator|>
literal|0
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|items
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|items
argument_list|,
name|index
argument_list|,
name|mv
argument_list|)
expr_stmt|;
name|items
index|[
name|n
index|]
operator|=
literal|null
expr_stmt|;
name|count
operator|=
name|n
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Internal version of removeAll for lists and sublists. In this      * and other similar methods below, the bound argument is, if      * non-negative, the purported upper bound of a list/sublist, or      * is left negative if the bound should be determined via count      * field under lock.      */
DECL|method|lockedRemoveAll
specifier|final
name|boolean
name|lockedRemoveAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|,
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|n
init|=
name|count
decl_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
if|if
condition|(
name|origin
operator|>=
literal|0
operator|&&
name|origin
operator|<
name|fence
condition|)
block|{
for|for
control|(
name|Object
name|x
range|:
name|c
control|)
block|{
while|while
condition|(
name|rawRemoveAt
argument_list|(
name|findFirstIndex
argument_list|(
name|array
argument_list|,
name|x
argument_list|,
name|origin
argument_list|,
name|fence
argument_list|)
argument_list|)
condition|)
name|removed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|removed
return|;
block|}
DECL|method|lockedRetainAll
specifier|final
name|boolean
name|lockedRetainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|,
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|boolean
name|removed
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|this
condition|)
block|{
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|n
operator|=
name|count
operator|)
operator|>
literal|0
operator|&&
name|n
operator|<
name|items
operator|.
name|length
operator|&&
operator|(
name|i
operator|=
name|origin
operator|)
operator|>=
literal|0
condition|)
block|{
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|fence
condition|)
block|{
if|if
condition|(
name|c
operator|.
name|contains
argument_list|(
name|items
index|[
name|i
index|]
argument_list|)
condition|)
operator|++
name|i
expr_stmt|;
else|else
block|{
operator|--
name|fence
expr_stmt|;
name|int
name|mv
init|=
operator|--
name|n
operator|-
name|i
decl_stmt|;
if|if
condition|(
name|mv
operator|>
literal|0
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|items
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|items
argument_list|,
name|i
argument_list|,
name|mv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
name|n
condition|)
block|{
name|count
operator|=
name|n
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|removed
return|;
block|}
DECL|method|internalClear
specifier|final
name|void
name|internalClear
parameter_list|(
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|origin
operator|<
literal|0
condition|)
name|origin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
name|int
name|removed
init|=
name|fence
operator|-
name|origin
decl_stmt|;
name|int
name|newCount
init|=
name|n
operator|-
name|removed
decl_stmt|;
name|int
name|mv
init|=
name|n
operator|-
operator|(
name|origin
operator|+
name|removed
operator|)
decl_stmt|;
if|if
condition|(
name|mv
operator|>
literal|0
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|items
argument_list|,
name|origin
operator|+
name|removed
argument_list|,
name|items
argument_list|,
name|origin
argument_list|,
name|mv
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
name|n
init|;
name|i
operator|<
name|newCount
condition|;
operator|++
name|i
control|)
name|items
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
name|count
operator|=
name|newCount
expr_stmt|;
block|}
block|}
DECL|method|internalContainsAll
specifier|final
name|boolean
name|internalContainsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|,
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|origin
operator|<
literal|0
condition|)
name|origin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
for|for
control|(
name|Object
name|e
range|:
name|c
control|)
block|{
if|if
condition|(
name|findFirstIndex
argument_list|(
name|items
argument_list|,
name|e
argument_list|,
name|origin
argument_list|,
name|fence
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|false
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|c
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
DECL|method|internalEquals
specifier|final
name|boolean
name|internalEquals
parameter_list|(
name|List
argument_list|<
name|?
argument_list|>
name|list
parameter_list|,
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|origin
operator|<
literal|0
condition|)
name|origin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
name|Iterator
argument_list|<
name|?
argument_list|>
name|it
init|=
name|list
operator|.
name|iterator
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|origin
init|;
name|i
operator|<
name|fence
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|it
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|false
return|;
name|Object
name|y
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Object
name|x
init|=
name|items
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|y
operator|&&
operator|(
name|x
operator|==
literal|null
operator|||
operator|!
name|x
operator|.
name|equals
argument_list|(
name|y
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|list
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
DECL|method|internalHashCode
specifier|final
name|int
name|internalHashCode
parameter_list|(
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|int
name|hash
init|=
literal|1
decl_stmt|;
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|origin
operator|<
literal|0
condition|)
name|origin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
name|origin
init|;
name|i
operator|<
name|fence
condition|;
operator|++
name|i
control|)
block|{
name|Object
name|e
init|=
name|items
index|[
name|i
index|]
decl_stmt|;
name|hash
operator|=
literal|31
operator|*
name|hash
operator|+
operator|(
name|e
operator|==
literal|null
condition|?
literal|0
else|:
name|e
operator|.
name|hashCode
argument_list|()
operator|)
expr_stmt|;
block|}
block|}
return|return
name|hash
return|;
block|}
DECL|method|internalToString
specifier|final
name|String
name|internalToString
parameter_list|(
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
name|int
name|i
init|=
operator|(
name|origin
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|origin
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|fence
condition|)
block|{
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|()
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|e
init|=
name|items
index|[
name|i
index|]
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
operator|(
name|e
operator|==
name|this
operator|)
condition|?
literal|"(this Collection)"
else|:
name|e
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|<
name|fence
condition|)
name|sb
operator|.
name|append
argument_list|(
literal|','
argument_list|)
operator|.
name|append
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
else|else
return|return
name|sb
operator|.
name|append
argument_list|(
literal|']'
argument_list|)
operator|.
name|toString
argument_list|()
return|;
block|}
block|}
block|}
return|return
literal|"[]"
return|;
block|}
DECL|method|internalToArray
specifier|final
name|Object
index|[]
name|internalToArray
parameter_list|(
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|origin
operator|<
literal|0
condition|)
name|origin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
name|int
name|i
init|=
operator|(
name|origin
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|origin
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|fence
condition|)
return|return
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|items
argument_list|,
name|i
argument_list|,
name|fence
argument_list|,
name|Object
index|[]
operator|.
expr|class
argument_list|)
return|;
block|}
return|return
operator|new
name|Object
index|[
literal|0
index|]
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|internalToArray
specifier|final
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|internalToArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|,
name|int
name|origin
parameter_list|,
name|int
name|bound
parameter_list|)
block|{
name|int
name|alen
init|=
name|a
operator|.
name|length
decl_stmt|;
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|origin
operator|<
literal|0
condition|)
name|origin
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|int
name|fence
init|=
name|bound
argument_list|<
literal|0
operator|||
name|bound
argument_list|>
name|n
condition|?
name|n
else|:
name|bound
decl_stmt|;
name|int
name|i
init|=
operator|(
name|origin
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|origin
decl_stmt|;
name|int
name|rlen
init|=
name|fence
operator|-
name|origin
decl_stmt|;
if|if
condition|(
name|rlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|alen
operator|>=
name|rlen
condition|)
block|{
name|System
operator|.
name|arraycopy
argument_list|(
name|items
argument_list|,
literal|0
argument_list|,
name|a
argument_list|,
name|origin
argument_list|,
name|rlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|alen
operator|>
name|rlen
condition|)
name|a
index|[
name|rlen
index|]
operator|=
literal|null
expr_stmt|;
return|return
name|a
return|;
block|}
return|return
operator|(
name|T
index|[]
operator|)
name|Arrays
operator|.
name|copyOfRange
argument_list|(
name|items
argument_list|,
name|i
argument_list|,
name|fence
argument_list|,
name|a
operator|.
name|getClass
argument_list|()
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|alen
operator|>
literal|0
condition|)
name|a
index|[
literal|0
index|]
operator|=
literal|null
expr_stmt|;
return|return
name|a
return|;
block|}
comment|// public List methods
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|rawAdd
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|rawAddAt
argument_list|(
name|index
argument_list|,
name|element
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|Object
index|[]
name|elements
init|=
name|c
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|int
name|len
init|=
name|elements
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|false
return|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
name|int
name|n
init|=
name|count
decl_stmt|;
name|int
name|newCount
init|=
name|n
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|newCount
operator|>=
name|items
operator|.
name|length
condition|)
name|items
operator|=
name|grow
argument_list|(
name|newCount
argument_list|)
expr_stmt|;
name|System
operator|.
name|arraycopy
argument_list|(
name|elements
argument_list|,
literal|0
argument_list|,
name|items
argument_list|,
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|count
operator|=
name|newCount
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|Object
index|[]
name|elements
init|=
name|c
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|boolean
name|ret
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|rawAddAllAt
argument_list|(
name|index
argument_list|,
name|elements
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|n
init|=
name|count
decl_stmt|;
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|items
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|items
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
name|o
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|containsAll
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
name|boolean
name|ret
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|ret
operator|=
name|internalContainsAll
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|List
operator|)
condition|)
return|return
literal|false
return|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|internalEquals
argument_list|(
operator|(
name|List
argument_list|<
name|?
argument_list|>
operator|)
name|o
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|get
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
name|Object
index|[]
name|items
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
name|index
operator|<
name|count
operator|&&
name|index
operator|<
name|items
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|items
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|validate
argument_list|(
name|stamp
argument_list|)
condition|)
return|return
name|e
return|;
block|}
return|return
name|lockedGet
argument_list|(
name|index
argument_list|)
return|;
block|}
DECL|method|lockedGet
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|E
name|lockedGet
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|boolean
name|oobe
init|=
literal|false
decl_stmt|;
name|E
name|e
init|=
literal|null
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
name|index
operator|<
name|items
operator|.
name|length
operator|&&
name|index
operator|<
name|count
operator|&&
name|index
operator|>=
literal|0
condition|)
name|e
operator|=
operator|(
name|E
operator|)
name|items
index|[
name|index
index|]
expr_stmt|;
else|else
name|oobe
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oobe
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
return|return
name|e
return|;
block|}
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
name|int
name|h
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|s
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|h
operator|=
name|internalHashCode
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
name|h
return|;
block|}
DECL|method|indexOf
specifier|public
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|idx
operator|=
name|findFirstIndex
argument_list|(
name|array
argument_list|,
name|o
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
return|return
name|count
operator|==
literal|0
return|;
comment|// no need for validation
block|}
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Itr
argument_list|<>
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|lastIndexOf
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|idx
operator|=
name|findLastIndex
argument_list|(
name|array
argument_list|,
name|o
argument_list|,
name|count
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
DECL|method|listIterator
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|()
block|{
return|return
operator|new
name|Itr
argument_list|<>
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
DECL|method|listIterator
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|Itr
argument_list|<>
argument_list|(
name|this
argument_list|,
name|index
argument_list|)
return|;
block|}
DECL|method|remove
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|E
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|E
name|oldValue
init|=
literal|null
decl_stmt|;
name|boolean
name|oobe
init|=
literal|false
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|count
condition|)
name|oobe
operator|=
literal|true
expr_stmt|;
else|else
block|{
name|oldValue
operator|=
operator|(
name|E
operator|)
name|array
index|[
name|index
index|]
expr_stmt|;
name|rawRemoveAt
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oobe
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
return|return
name|oldValue
return|;
block|}
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|rawRemoveAt
argument_list|(
name|findFirstIndex
argument_list|(
name|array
argument_list|,
name|o
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeAll
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|lockedRemoveAll
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|retainAll
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|lockedRetainAll
argument_list|(
name|c
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
DECL|method|set
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|E
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
name|E
name|oldValue
init|=
literal|null
decl_stmt|;
name|boolean
name|oobe
init|=
literal|false
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|count
condition|)
name|oobe
operator|=
literal|true
expr_stmt|;
else|else
block|{
name|oldValue
operator|=
operator|(
name|E
operator|)
name|items
index|[
name|index
index|]
expr_stmt|;
name|items
index|[
name|index
index|]
operator|=
name|element
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oobe
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
return|return
name|oldValue
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
return|return
name|count
return|;
comment|// no need for validation
block|}
DECL|method|lockedSize
specifier|private
name|int
name|lockedSize
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|n
operator|=
name|count
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
DECL|method|subList
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|int
name|ssize
init|=
name|toIndex
operator|-
name|fromIndex
decl_stmt|;
if|if
condition|(
name|ssize
operator|>=
literal|0
operator|&&
name|fromIndex
operator|>=
literal|0
condition|)
block|{
name|ReadMostlyVectorSublist
argument_list|<
name|E
argument_list|>
name|ret
init|=
literal|null
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|toIndex
operator|<=
name|count
condition|)
name|ret
operator|=
operator|new
name|ReadMostlyVectorSublist
argument_list|<>
argument_list|(
name|this
argument_list|,
name|fromIndex
argument_list|,
name|ssize
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|null
condition|)
return|return
name|ret
return|;
block|}
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|fromIndex
operator|<
literal|0
condition|?
name|fromIndex
else|:
name|toIndex
argument_list|)
throw|;
block|}
DECL|method|toArray
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|internalToArray
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toArray
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|internalToArray
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|internalToString
argument_list|(
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// ReadMostlyVector-only methods
comment|/**      * Appends the element, if not present.      *      * @param e element to be added to this list, if absent      * @return {@code true} if the element was added      */
DECL|method|addIfAbsent
specifier|public
name|boolean
name|addIfAbsent
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|boolean
name|ret
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|findFirstIndex
argument_list|(
name|array
argument_list|,
name|e
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rawAdd
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|true
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|false
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
comment|/**      * Appends all of the elements in the specified collection that      * are not already contained in this list, to the end of      * this list, in the order that they are returned by the      * specified collection's iterator.      *      * @param c collection containing elements to be added to this list      * @return the number of elements added      * @throws NullPointerException if the specified collection is null      * @see #addIfAbsent(Object)      */
DECL|method|addAllAbsent
specifier|public
name|int
name|addAllAbsent
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|int
name|added
init|=
literal|0
decl_stmt|;
name|Object
index|[]
name|cs
init|=
name|c
operator|.
name|toArray
argument_list|()
decl_stmt|;
name|int
name|clen
init|=
name|cs
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|clen
operator|!=
literal|0
condition|)
block|{
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|clen
condition|;
operator|++
name|i
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|cs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|findFirstIndex
argument_list|(
name|array
argument_list|,
name|e
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rawAdd
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|++
name|added
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|added
return|;
block|}
comment|/**      * Returns an iterator operating over a snapshot copy of the      * elements of this collection created upon construction of the      * iterator. The iterator does<em>NOT</em> support the      * {@code remove} method.      *      * @return an iterator over the elements in this list in proper sequence      */
DECL|method|snapshotIterator
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|snapshotIterator
parameter_list|()
block|{
return|return
operator|new
name|SnapshotIterator
argument_list|<>
argument_list|(
name|this
argument_list|)
return|;
block|}
DECL|class|SnapshotIterator
specifier|static
specifier|final
class|class
name|SnapshotIterator
parameter_list|<
name|E
parameter_list|>
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|items
specifier|private
specifier|final
name|Object
index|[]
name|items
decl_stmt|;
DECL|field|cursor
specifier|private
name|int
name|cursor
decl_stmt|;
DECL|method|SnapshotIterator
name|SnapshotIterator
parameter_list|(
name|ReadMostlyVector
argument_list|<
name|E
argument_list|>
name|v
parameter_list|)
block|{
name|items
operator|=
name|v
operator|.
name|toArray
argument_list|()
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|cursor
operator|<
name|items
operator|.
name|length
return|;
block|}
DECL|method|next
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|public
name|E
name|next
parameter_list|()
block|{
if|if
condition|(
name|cursor
operator|<
name|items
operator|.
name|length
condition|)
return|return
operator|(
name|E
operator|)
name|items
index|[
name|cursor
operator|++
index|]
return|;
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
comment|/** Interface describing a void action of one argument */
DECL|interface|Action
DECL|method|apply
specifier|public
interface|interface
name|Action
parameter_list|<
name|A
parameter_list|>
block|{
name|void
name|apply
parameter_list|(
name|A
name|a
parameter_list|)
function_decl|;
block|}
DECL|method|forEachReadOnly
specifier|public
name|void
name|forEachReadOnly
parameter_list|(
name|Action
argument_list|<
name|E
argument_list|>
name|action
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|len
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|len
operator|=
name|items
operator|.
name|length
operator|)
operator|>
literal|0
operator|&&
operator|(
name|n
operator|=
name|count
operator|)
operator|<=
name|len
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|items
index|[
name|i
index|]
decl_stmt|;
name|action
operator|.
name|apply
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Vector-only methods
comment|/** See {@link Vector#firstElement} */
DECL|method|firstElement
specifier|public
name|E
name|firstElement
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
name|Object
index|[]
name|items
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
name|count
operator|>
literal|0
operator|&&
name|items
operator|.
name|length
operator|>
literal|0
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|items
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|validate
argument_list|(
name|stamp
argument_list|)
condition|)
return|return
name|e
return|;
block|}
return|return
name|lockedFirstElement
argument_list|()
return|;
block|}
DECL|method|lockedFirstElement
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|E
name|lockedFirstElement
parameter_list|()
block|{
name|Object
name|e
init|=
literal|null
decl_stmt|;
name|boolean
name|oobe
init|=
literal|false
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|items
operator|!=
literal|null
operator|&&
name|count
operator|>
literal|0
operator|&&
name|items
operator|.
name|length
operator|>
literal|0
condition|)
name|e
operator|=
name|items
index|[
literal|0
index|]
expr_stmt|;
else|else
name|oobe
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oobe
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
return|return
operator|(
name|E
operator|)
name|e
return|;
block|}
comment|/** See {@link Vector#lastElement} */
DECL|method|lastElement
specifier|public
name|E
name|lastElement
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|tryOptimisticRead
argument_list|()
decl_stmt|;
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|i
operator|=
name|count
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
name|i
operator|<
name|items
operator|.
name|length
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|items
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|lock
operator|.
name|validate
argument_list|(
name|stamp
argument_list|)
condition|)
return|return
name|e
return|;
block|}
return|return
name|lockedLastElement
argument_list|()
return|;
block|}
DECL|method|lockedLastElement
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
specifier|private
name|E
name|lockedLastElement
parameter_list|()
block|{
name|Object
name|e
init|=
literal|null
decl_stmt|;
name|boolean
name|oobe
init|=
literal|false
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
name|int
name|i
init|=
name|count
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|items
operator|!=
literal|null
operator|&&
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|items
operator|.
name|length
condition|)
name|e
operator|=
name|items
index|[
name|i
index|]
expr_stmt|;
else|else
name|oobe
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oobe
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
return|return
operator|(
name|E
operator|)
name|e
return|;
block|}
comment|/** See {@link Vector#indexOf(Object, int)} */
DECL|method|indexOf
specifier|public
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
name|int
name|idx
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|idx
operator|=
name|findFirstIndex
argument_list|(
name|array
argument_list|,
name|o
argument_list|,
name|index
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
comment|/** See {@link Vector#lastIndexOf(Object, int)} */
DECL|method|lastIndexOf
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|boolean
name|oobe
init|=
literal|false
decl_stmt|;
name|int
name|idx
init|=
operator|-
literal|1
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|index
operator|<
name|count
condition|)
name|idx
operator|=
name|findLastIndex
argument_list|(
name|array
argument_list|,
name|o
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|oobe
operator|=
literal|true
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oobe
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
return|return
name|idx
return|;
block|}
comment|/** See {@link Vector#setSize} */
DECL|method|setSize
specifier|public
name|void
name|setSize
parameter_list|(
name|int
name|newSize
parameter_list|)
block|{
if|if
condition|(
name|newSize
operator|<
literal|0
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|newSize
argument_list|)
throw|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
decl_stmt|;
name|int
name|n
init|=
name|count
decl_stmt|;
if|if
condition|(
name|newSize
operator|>
name|n
condition|)
name|grow
argument_list|(
name|newSize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|newSize
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|items
index|[
name|i
index|]
operator|=
literal|null
expr_stmt|;
block|}
name|count
operator|=
name|newSize
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** See {@link Vector#copyInto} */
DECL|method|copyInto
specifier|public
name|void
name|copyInto
parameter_list|(
name|Object
index|[]
name|anArray
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
decl_stmt|;
if|if
condition|(
operator|(
name|items
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
name|System
operator|.
name|arraycopy
argument_list|(
name|items
argument_list|,
literal|0
argument_list|,
name|anArray
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** See {@link Vector#trimToSize} */
DECL|method|trimToSize
specifier|public
name|void
name|trimToSize
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
name|int
name|n
init|=
name|count
decl_stmt|;
if|if
condition|(
name|items
operator|!=
literal|null
operator|&&
name|n
operator|<
name|items
operator|.
name|length
condition|)
name|array
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|items
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/** See {@link Vector#ensureCapacity} */
DECL|method|ensureCapacity
specifier|public
name|void
name|ensureCapacity
parameter_list|(
name|int
name|minCapacity
parameter_list|)
block|{
if|if
condition|(
name|minCapacity
operator|>
literal|0
condition|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
name|int
name|cap
init|=
operator|(
name|items
operator|==
literal|null
operator|)
condition|?
literal|0
else|:
name|items
operator|.
name|length
decl_stmt|;
if|if
condition|(
name|minCapacity
operator|-
name|cap
operator|>
literal|0
condition|)
name|grow
argument_list|(
name|minCapacity
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** See {@link Vector#elements} */
DECL|method|elements
specifier|public
name|Enumeration
argument_list|<
name|E
argument_list|>
name|elements
parameter_list|()
block|{
return|return
operator|new
name|Itr
argument_list|<>
argument_list|(
name|this
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/** See {@link Vector#capacity} */
DECL|method|capacity
specifier|public
name|int
name|capacity
parameter_list|()
block|{
return|return
name|array
operator|.
name|length
return|;
block|}
comment|/** See {@link Vector#elementAt} */
DECL|method|elementAt
specifier|public
name|E
name|elementAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|get
argument_list|(
name|index
argument_list|)
return|;
block|}
comment|/** See {@link Vector#setElementAt} */
DECL|method|setElementAt
specifier|public
name|void
name|setElementAt
parameter_list|(
name|E
name|obj
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|set
argument_list|(
name|index
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link Vector#removeElementAt} */
DECL|method|removeElementAt
specifier|public
name|void
name|removeElementAt
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|remove
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link Vector#insertElementAt} */
DECL|method|insertElementAt
specifier|public
name|void
name|insertElementAt
parameter_list|(
name|E
name|obj
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|add
argument_list|(
name|index
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link Vector#addElement} */
DECL|method|addElement
specifier|public
name|void
name|addElement
parameter_list|(
name|E
name|obj
parameter_list|)
block|{
name|add
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
comment|/** See {@link Vector#removeElement} */
DECL|method|removeElement
specifier|public
name|boolean
name|removeElement
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
return|return
name|remove
argument_list|(
name|obj
argument_list|)
return|;
block|}
comment|/** See {@link Vector#removeAllElements} */
DECL|method|removeAllElements
specifier|public
name|void
name|removeAllElements
parameter_list|()
block|{
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// other methods
DECL|method|clone
specifier|public
name|ReadMostlyVector
argument_list|<
name|E
argument_list|>
name|clone
parameter_list|()
block|{
name|Object
index|[]
name|a
init|=
literal|null
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|array
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|null
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|len
init|=
name|items
operator|.
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|count
operator|)
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
name|a
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|items
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
operator|new
name|ReadMostlyVector
argument_list|<>
argument_list|(
name|a
argument_list|,
name|n
argument_list|,
name|capacityIncrement
argument_list|)
return|;
block|}
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|class|Itr
specifier|static
specifier|final
class|class
name|Itr
parameter_list|<
name|E
parameter_list|>
implements|implements
name|ListIterator
argument_list|<
name|E
argument_list|>
implements|,
name|Enumeration
argument_list|<
name|E
argument_list|>
block|{
DECL|field|lock
specifier|final
name|StampedLock
name|lock
decl_stmt|;
DECL|field|list
specifier|final
name|ReadMostlyVector
argument_list|<
name|E
argument_list|>
name|list
decl_stmt|;
DECL|field|items
name|Object
index|[]
name|items
decl_stmt|;
DECL|field|seq
name|long
name|seq
decl_stmt|;
DECL|field|cursor
name|int
name|cursor
decl_stmt|;
DECL|field|fence
name|int
name|fence
decl_stmt|;
DECL|field|lastRet
name|int
name|lastRet
decl_stmt|;
DECL|method|Itr
name|Itr
parameter_list|(
name|ReadMostlyVector
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|items
operator|=
name|list
operator|.
name|array
expr_stmt|;
name|this
operator|.
name|fence
operator|=
name|list
operator|.
name|count
expr_stmt|;
name|this
operator|.
name|cursor
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|fence
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
block|}
DECL|method|hasPrevious
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|cursor
operator|>
literal|0
return|;
block|}
DECL|method|nextIndex
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|cursor
return|;
block|}
DECL|method|previousIndex
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|cursor
operator|-
literal|1
return|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|cursor
operator|<
name|fence
return|;
block|}
DECL|method|next
specifier|public
name|E
name|next
parameter_list|()
block|{
name|int
name|i
init|=
name|cursor
decl_stmt|;
name|Object
index|[]
name|es
init|=
name|items
decl_stmt|;
if|if
condition|(
name|es
operator|==
literal|null
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|fence
operator|||
name|i
operator|>=
name|es
operator|.
name|length
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|es
index|[
name|i
index|]
decl_stmt|;
name|lastRet
operator|=
name|i
expr_stmt|;
name|cursor
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|validate
argument_list|(
name|seq
argument_list|)
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
return|return
name|e
return|;
block|}
DECL|method|previous
specifier|public
name|E
name|previous
parameter_list|()
block|{
name|int
name|i
init|=
name|cursor
operator|-
literal|1
decl_stmt|;
name|Object
index|[]
name|es
init|=
name|items
decl_stmt|;
if|if
condition|(
name|es
operator|==
literal|null
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|fence
operator|||
name|i
operator|>=
name|es
operator|.
name|length
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|es
index|[
name|i
index|]
decl_stmt|;
name|lastRet
operator|=
name|i
expr_stmt|;
name|cursor
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|validate
argument_list|(
name|seq
argument_list|)
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
return|return
name|e
return|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|int
name|i
init|=
name|lastRet
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|seq
operator|=
name|lock
operator|.
name|tryConvertToWriteLock
argument_list|(
name|seq
argument_list|)
operator|)
operator|==
literal|0
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
try|try
block|{
name|list
operator|.
name|rawRemoveAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fence
operator|=
name|list
operator|.
name|count
expr_stmt|;
name|cursor
operator|=
name|i
expr_stmt|;
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|int
name|i
init|=
name|lastRet
decl_stmt|;
name|Object
index|[]
name|es
init|=
name|items
decl_stmt|;
if|if
condition|(
name|es
operator|==
literal|null
operator|||
name|i
operator|<
literal|0
operator||
name|i
operator|>=
name|fence
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|seq
operator|=
name|lock
operator|.
name|tryConvertToWriteLock
argument_list|(
name|seq
argument_list|)
operator|)
operator|==
literal|0
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
try|try
block|{
name|es
index|[
name|i
index|]
operator|=
name|e
expr_stmt|;
block|}
finally|finally
block|{
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|int
name|i
init|=
name|cursor
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|seq
operator|=
name|lock
operator|.
name|tryConvertToWriteLock
argument_list|(
name|seq
argument_list|)
operator|)
operator|==
literal|0
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
try|try
block|{
name|list
operator|.
name|rawAddAt
argument_list|(
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|items
operator|=
name|list
operator|.
name|array
expr_stmt|;
name|fence
operator|=
name|list
operator|.
name|count
expr_stmt|;
name|cursor
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|hasMoreElements
specifier|public
name|boolean
name|hasMoreElements
parameter_list|()
block|{
return|return
name|hasNext
argument_list|()
return|;
block|}
DECL|method|nextElement
specifier|public
name|E
name|nextElement
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
block|}
DECL|class|ReadMostlyVectorSublist
specifier|static
specifier|final
class|class
name|ReadMostlyVectorSublist
parameter_list|<
name|E
parameter_list|>
implements|implements
name|List
argument_list|<
name|E
argument_list|>
implements|,
name|RandomAccess
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|3041673470172026059L
decl_stmt|;
DECL|field|list
specifier|final
name|ReadMostlyVector
argument_list|<
name|E
argument_list|>
name|list
decl_stmt|;
DECL|field|offset
specifier|final
name|int
name|offset
decl_stmt|;
DECL|field|size
specifier|volatile
name|int
name|size
decl_stmt|;
DECL|method|ReadMostlyVectorSublist
name|ReadMostlyVectorSublist
parameter_list|(
name|ReadMostlyVector
argument_list|<
name|E
argument_list|>
name|list
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|this
operator|.
name|list
operator|=
name|list
expr_stmt|;
name|this
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|this
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
DECL|method|rangeCheck
specifier|private
name|void
name|rangeCheck
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|size
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
block|}
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|element
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|c
init|=
name|size
decl_stmt|;
name|list
operator|.
name|rawAddAt
argument_list|(
name|c
operator|+
name|offset
argument_list|,
name|element
argument_list|)
expr_stmt|;
name|size
operator|=
name|c
operator|+
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|size
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
name|list
operator|.
name|rawAddAt
argument_list|(
name|index
operator|+
name|offset
argument_list|,
name|element
argument_list|)
expr_stmt|;
operator|++
name|size
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|Object
index|[]
name|elements
init|=
name|c
operator|.
name|toArray
argument_list|()
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|s
init|=
name|size
decl_stmt|;
name|int
name|pc
init|=
name|list
operator|.
name|count
decl_stmt|;
name|list
operator|.
name|rawAddAllAt
argument_list|(
name|offset
operator|+
name|s
argument_list|,
name|elements
argument_list|)
expr_stmt|;
name|int
name|added
init|=
name|list
operator|.
name|count
operator|-
name|pc
decl_stmt|;
name|size
operator|=
name|s
operator|+
name|added
expr_stmt|;
return|return
name|added
operator|!=
literal|0
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|int
name|index
parameter_list|,
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|Object
index|[]
name|elements
init|=
name|c
operator|.
name|toArray
argument_list|()
decl_stmt|;
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|s
init|=
name|size
decl_stmt|;
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|index
argument_list|>
name|s
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
name|int
name|pc
init|=
name|list
operator|.
name|count
decl_stmt|;
name|list
operator|.
name|rawAddAllAt
argument_list|(
name|index
operator|+
name|offset
argument_list|,
name|elements
argument_list|)
expr_stmt|;
name|int
name|added
init|=
name|list
operator|.
name|count
operator|-
name|pc
decl_stmt|;
name|size
operator|=
name|s
operator|+
name|added
expr_stmt|;
return|return
name|added
operator|!=
literal|0
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|list
operator|.
name|internalClear
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|indexOf
argument_list|(
name|o
argument_list|)
operator|>=
literal|0
return|;
block|}
DECL|method|containsAll
specifier|public
name|boolean
name|containsAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|internalContainsAll
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|equals
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
name|this
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
operator|(
name|o
operator|instanceof
name|List
operator|)
condition|)
return|return
literal|false
return|;
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|internalEquals
argument_list|(
call|(
name|List
argument_list|<
name|?
argument_list|>
call|)
argument_list|(
name|o
argument_list|)
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|get
specifier|public
name|E
name|get
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|size
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
return|return
name|list
operator|.
name|get
argument_list|(
name|index
operator|+
name|offset
argument_list|)
return|;
block|}
DECL|method|hashCode
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|internalHashCode
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|indexOf
specifier|public
name|int
name|indexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|idx
init|=
name|findFirstIndex
argument_list|(
name|list
operator|.
name|array
argument_list|,
name|o
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
decl_stmt|;
return|return
name|idx
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|idx
operator|-
name|offset
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|SubItr
argument_list|<>
argument_list|(
name|this
argument_list|,
name|offset
argument_list|)
return|;
block|}
DECL|method|lastIndexOf
specifier|public
name|int
name|lastIndexOf
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|int
name|idx
init|=
name|findLastIndex
argument_list|(
name|list
operator|.
name|array
argument_list|,
name|o
argument_list|,
name|offset
operator|+
name|size
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
decl_stmt|;
return|return
name|idx
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
name|idx
operator|-
name|offset
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|listIterator
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|()
block|{
return|return
operator|new
name|SubItr
argument_list|<>
argument_list|(
name|this
argument_list|,
name|offset
argument_list|)
return|;
block|}
DECL|method|listIterator
specifier|public
name|ListIterator
argument_list|<
name|E
argument_list|>
name|listIterator
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
operator|new
name|SubItr
argument_list|<>
argument_list|(
name|this
argument_list|,
name|index
operator|+
name|offset
argument_list|)
return|;
block|}
DECL|method|remove
specifier|public
name|E
name|remove
parameter_list|(
name|int
name|index
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
name|Object
index|[]
name|items
init|=
name|list
operator|.
name|array
decl_stmt|;
name|int
name|i
init|=
name|index
operator|+
name|offset
decl_stmt|;
if|if
condition|(
name|items
operator|==
literal|null
operator|||
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|size
operator|||
name|i
operator|>=
name|items
operator|.
name|length
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|result
init|=
operator|(
name|E
operator|)
name|items
index|[
name|i
index|]
decl_stmt|;
name|list
operator|.
name|rawRemoveAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|size
operator|--
expr_stmt|;
return|return
name|result
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|writeLock
argument_list|()
decl_stmt|;
try|try
block|{
if|if
condition|(
name|list
operator|.
name|rawRemoveAt
argument_list|(
name|findFirstIndex
argument_list|(
name|list
operator|.
name|array
argument_list|,
name|o
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
argument_list|)
condition|)
block|{
operator|--
name|size
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
return|return
literal|false
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockWrite
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|removeAll
specifier|public
name|boolean
name|removeAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|list
operator|.
name|lockedRemoveAll
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
DECL|method|retainAll
specifier|public
name|boolean
name|retainAll
parameter_list|(
name|Collection
argument_list|<
name|?
argument_list|>
name|c
parameter_list|)
block|{
return|return
name|list
operator|.
name|lockedRetainAll
argument_list|(
name|c
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
DECL|method|set
specifier|public
name|E
name|set
parameter_list|(
name|int
name|index
parameter_list|,
name|E
name|element
parameter_list|)
block|{
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>=
name|size
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
return|return
name|list
operator|.
name|set
argument_list|(
name|index
operator|+
name|offset
argument_list|,
name|element
argument_list|)
return|;
block|}
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|size
return|;
block|}
DECL|method|subList
specifier|public
name|List
argument_list|<
name|E
argument_list|>
name|subList
parameter_list|(
name|int
name|fromIndex
parameter_list|,
name|int
name|toIndex
parameter_list|)
block|{
name|int
name|c
init|=
name|size
decl_stmt|;
name|int
name|ssize
init|=
name|toIndex
operator|-
name|fromIndex
decl_stmt|;
if|if
condition|(
name|fromIndex
operator|<
literal|0
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|fromIndex
argument_list|)
throw|;
if|if
condition|(
name|toIndex
operator|>
name|c
operator|||
name|ssize
operator|<
literal|0
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|toIndex
argument_list|)
throw|;
return|return
operator|new
name|ReadMostlyVectorSublist
argument_list|<>
argument_list|(
name|list
argument_list|,
name|offset
operator|+
name|fromIndex
argument_list|,
name|ssize
argument_list|)
return|;
block|}
DECL|method|toArray
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|internalToArray
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toArray
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|internalToArray
argument_list|(
name|a
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
return|return
name|list
operator|.
name|internalToString
argument_list|(
name|offset
argument_list|,
name|offset
operator|+
name|size
argument_list|)
return|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlockRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|class|SubItr
specifier|static
specifier|final
class|class
name|SubItr
parameter_list|<
name|E
parameter_list|>
implements|implements
name|ListIterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|sublist
specifier|final
name|ReadMostlyVectorSublist
argument_list|<
name|E
argument_list|>
name|sublist
decl_stmt|;
DECL|field|list
specifier|final
name|ReadMostlyVector
argument_list|<
name|E
argument_list|>
name|list
decl_stmt|;
DECL|field|lock
specifier|final
name|StampedLock
name|lock
decl_stmt|;
DECL|field|items
name|Object
index|[]
name|items
decl_stmt|;
DECL|field|seq
name|long
name|seq
decl_stmt|;
DECL|field|cursor
name|int
name|cursor
decl_stmt|;
DECL|field|origin
name|int
name|origin
decl_stmt|;
DECL|field|fence
name|int
name|fence
decl_stmt|;
DECL|field|lastRet
name|int
name|lastRet
decl_stmt|;
DECL|method|SubItr
name|SubItr
parameter_list|(
name|ReadMostlyVectorSublist
argument_list|<
name|E
argument_list|>
name|sublist
parameter_list|,
name|int
name|index
parameter_list|)
block|{
specifier|final
name|StampedLock
name|lock
init|=
name|sublist
operator|.
name|list
operator|.
name|lock
decl_stmt|;
name|long
name|stamp
init|=
name|lock
operator|.
name|readLock
argument_list|()
decl_stmt|;
try|try
block|{
name|this
operator|.
name|sublist
operator|=
name|sublist
expr_stmt|;
name|this
operator|.
name|list
operator|=
name|sublist
operator|.
name|list
expr_stmt|;
name|this
operator|.
name|lock
operator|=
name|lock
expr_stmt|;
name|this
operator|.
name|cursor
operator|=
name|index
expr_stmt|;
name|this
operator|.
name|origin
operator|=
name|sublist
operator|.
name|offset
expr_stmt|;
name|this
operator|.
name|fence
operator|=
name|origin
operator|+
name|sublist
operator|.
name|size
expr_stmt|;
name|this
operator|.
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|this
operator|.
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|<
literal|0
operator|||
name|cursor
argument_list|>
name|fence
condition|)
throw|throw
operator|new
name|ArrayIndexOutOfBoundsException
argument_list|(
name|index
argument_list|)
throw|;
block|}
DECL|method|nextIndex
specifier|public
name|int
name|nextIndex
parameter_list|()
block|{
return|return
name|cursor
operator|-
name|origin
return|;
block|}
DECL|method|previousIndex
specifier|public
name|int
name|previousIndex
parameter_list|()
block|{
return|return
name|cursor
operator|-
name|origin
operator|-
literal|1
return|;
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|cursor
operator|<
name|fence
return|;
block|}
DECL|method|hasPrevious
specifier|public
name|boolean
name|hasPrevious
parameter_list|()
block|{
return|return
name|cursor
operator|>
name|origin
return|;
block|}
DECL|method|next
specifier|public
name|E
name|next
parameter_list|()
block|{
name|int
name|i
init|=
name|cursor
decl_stmt|;
name|Object
index|[]
name|es
init|=
name|items
decl_stmt|;
if|if
condition|(
name|es
operator|==
literal|null
operator|||
name|i
operator|<
name|origin
operator|||
name|i
operator|>=
name|fence
operator|||
name|i
operator|>=
name|es
operator|.
name|length
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|es
index|[
name|i
index|]
decl_stmt|;
name|lastRet
operator|=
name|i
expr_stmt|;
name|cursor
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|validate
argument_list|(
name|seq
argument_list|)
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
return|return
name|e
return|;
block|}
DECL|method|previous
specifier|public
name|E
name|previous
parameter_list|()
block|{
name|int
name|i
init|=
name|cursor
operator|-
literal|1
decl_stmt|;
name|Object
index|[]
name|es
init|=
name|items
decl_stmt|;
if|if
condition|(
name|es
operator|==
literal|null
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|fence
operator|||
name|i
operator|>=
name|es
operator|.
name|length
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|e
init|=
operator|(
name|E
operator|)
name|es
index|[
name|i
index|]
decl_stmt|;
name|lastRet
operator|=
name|i
expr_stmt|;
name|cursor
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|lock
operator|.
name|validate
argument_list|(
name|seq
argument_list|)
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
return|return
name|e
return|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|int
name|i
init|=
name|lastRet
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|seq
operator|=
name|lock
operator|.
name|tryConvertToWriteLock
argument_list|(
name|seq
argument_list|)
operator|)
operator|==
literal|0
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
try|try
block|{
name|list
operator|.
name|rawRemoveAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fence
operator|=
name|origin
operator|+
name|sublist
operator|.
name|size
expr_stmt|;
name|cursor
operator|=
name|i
expr_stmt|;
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|set
specifier|public
name|void
name|set
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|int
name|i
init|=
name|lastRet
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|origin
operator|||
name|i
operator|>=
name|fence
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|seq
operator|=
name|lock
operator|.
name|tryConvertToWriteLock
argument_list|(
name|seq
argument_list|)
operator|)
operator|==
literal|0
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
try|try
block|{
name|list
operator|.
name|set
argument_list|(
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|add
specifier|public
name|void
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|int
name|i
init|=
name|cursor
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|origin
operator|||
name|i
operator|>=
name|fence
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
if|if
condition|(
operator|(
name|seq
operator|=
name|lock
operator|.
name|tryConvertToWriteLock
argument_list|(
name|seq
argument_list|)
operator|)
operator|==
literal|0
condition|)
throw|throw
operator|new
name|ConcurrentModificationException
argument_list|()
throw|;
try|try
block|{
name|list
operator|.
name|rawAddAt
argument_list|(
name|i
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|items
operator|=
name|list
operator|.
name|array
expr_stmt|;
name|fence
operator|=
name|origin
operator|+
name|sublist
operator|.
name|size
expr_stmt|;
name|cursor
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|lastRet
operator|=
operator|-
literal|1
expr_stmt|;
block|}
finally|finally
block|{
name|seq
operator|=
name|lock
operator|.
name|tryConvertToOptimisticRead
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_class

end_unit

