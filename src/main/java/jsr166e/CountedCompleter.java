begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_comment
comment|/**  * A {@link ForkJoinTask} with a completion action performed when  * triggered and there are no remaining pending actions.  * CountedCompleters are in general more robust in the  * presence of subtask stalls and blockage than are other forms of  * ForkJoinTasks, but are less intuitive to program.  Uses of  * CountedCompleter are similar to those of other completion based  * components (such as {@link java.nio.channels.CompletionHandler})  * except that multiple<em>pending</em> completions may be necessary  * to trigger the completion action {@link #onCompletion(CountedCompleter)},  * not just one.  * Unless initialized otherwise, the {@linkplain #getPendingCount pending  * count} starts at zero, but may be (atomically) changed using  * methods {@link #setPendingCount}, {@link #addToPendingCount}, and  * {@link #compareAndSetPendingCount}. Upon invocation of {@link  * #tryComplete}, if the pending action count is nonzero, it is  * decremented; otherwise, the completion action is performed, and if  * this completer itself has a completer, the process is continued  * with its completer.  As is the case with related synchronization  * components such as {@link java.util.concurrent.Phaser Phaser} and  * {@link java.util.concurrent.Semaphore Semaphore}, these methods  * affect only internal counts; they do not establish any further  * internal bookkeeping. In particular, the identities of pending  * tasks are not maintained. As illustrated below, you can create  * subclasses that do record some or all pending tasks or their  * results when needed.  As illustrated below, utility methods  * supporting customization of completion traversals are also  * provided. However, because CountedCompleters provide only basic  * synchronization mechanisms, it may be useful to create further  * abstract subclasses that maintain linkages, fields, and additional  * support methods appropriate for a set of related usages.  *  *<p>A concrete CountedCompleter class must define method {@link  * #compute}, that should in most cases (as illustrated below), invoke  * {@code tryComplete()} once before returning. The class may also  * optionally override method {@link #onCompletion(CountedCompleter)}  * to perform an action upon normal completion, and method  * {@link #onExceptionalCompletion(Throwable, CountedCompleter)} to  * perform an action upon any exception.  *  *<p>CountedCompleters most often do not bear results, in which case  * they are normally declared as {@code CountedCompleter<Void>}, and  * will always return {@code null} as a result value.  In other cases,  * you should override method {@link #getRawResult} to provide a  * result from {@code join(), invoke()}, and related methods.  In  * general, this method should return the value of a field (or a  * function of one or more fields) of the CountedCompleter object that  * holds the result upon completion. Method {@link #setRawResult} by  * default plays no role in CountedCompleters.  It is possible, but  * rarely applicable, to override this method to maintain other  * objects or fields holding result data.  *  *<p>A CountedCompleter that does not itself have a completer (i.e.,  * one for which {@link #getCompleter} returns {@code null}) can be  * used as a regular ForkJoinTask with this added functionality.  * However, any completer that in turn has another completer serves  * only as an internal helper for other computations, so its own task  * status (as reported in methods such as {@link ForkJoinTask#isDone})  * is arbitrary; this status changes only upon explicit invocations of  * {@link #complete}, {@link ForkJoinTask#cancel},  * {@link ForkJoinTask#completeExceptionally(Throwable)} or upon  * exceptional completion of method {@code compute}. Upon any  * exceptional completion, the exception may be relayed to a task's  * completer (and its completer, and so on), if one exists and it has  * not otherwise already completed. Similarly, cancelling an internal  * CountedCompleter has only a local effect on that completer, so is  * not often useful.  *  *<p><b>Sample Usages.</b>  *  *<p><b>Parallel recursive decomposition.</b> CountedCompleters may  * be arranged in trees similar to those often used with {@link  * RecursiveAction}s, although the constructions involved in setting  * them up typically vary. Here, the completer of each task is its  * parent in the computation tree. Even though they entail a bit more  * bookkeeping, CountedCompleters may be better choices when applying  * a possibly time-consuming operation (that cannot be further  * subdivided) to each element of an array or collection; especially  * when the operation takes a significantly different amount of time  * to complete for some elements than others, either because of  * intrinsic variation (for example I/O) or auxiliary effects such as  * garbage collection.  Because CountedCompleters provide their own  * continuations, other threads need not block waiting to perform  * them.  *  *<p>For example, here is an initial version of a class that uses  * divide-by-two recursive decomposition to divide work into single  * pieces (leaf tasks). Even when work is split into individual calls,  * tree-based techniques are usually preferable to directly forking  * leaf tasks, because they reduce inter-thread communication and  * improve load balancing. In the recursive case, the second of each  * pair of subtasks to finish triggers completion of its parent  * (because no result combination is performed, the default no-op  * implementation of method {@code onCompletion} is not overridden).  * A static utility method sets up the base task and invokes it  * (here, implicitly using the {@link ForkJoinPool#commonPool()}).  *  *<pre> {@code  * class MyOperation<E> { void apply(E e) { ... }  }  *  * class ForEach<E> extends CountedCompleter<Void> {  *  *   public static<E> void forEach(E[] array, MyOperation<E> op) {  *     new ForEach<E>(null, array, op, 0, array.length).invoke();  *   }  *  *   final E[] array; final MyOperation<E> op; final int lo, hi;  *   ForEach(CountedCompleter<?> p, E[] array, MyOperation<E> op, int lo, int hi) {  *     super(p);  *     this.array = array; this.op = op; this.lo = lo; this.hi = hi;  *   }  *  *   public void compute() { // version 1  *     if (hi - lo>= 2) {  *       int mid = (lo + hi)>>> 1;  *       setPendingCount(2); // must set pending count before fork  *       new ForEach(this, array, op, mid, hi).fork(); // right child  *       new ForEach(this, array, op, lo, mid).fork(); // left child  *     }  *     else if (hi> lo)  *       op.apply(array[lo]);  *     tryComplete();  *   }  * }}</pre>  *  * This design can be improved by noticing that in the recursive case,  * the task has nothing to do after forking its right task, so can  * directly invoke its left task before returning. (This is an analog  * of tail recursion removal.)  Also, because the task returns upon  * executing its left task (rather than falling through to invoke  * {@code tryComplete}) the pending count is set to one:  *  *<pre> {@code  * class ForEach<E> ...  *   public void compute() { // version 2  *     if (hi - lo>= 2) {  *       int mid = (lo + hi)>>> 1;  *       setPendingCount(1); // only one pending  *       new ForEach(this, array, op, mid, hi).fork(); // right child  *       new ForEach(this, array, op, lo, mid).compute(); // direct invoke  *     }  *     else {  *       if (hi> lo)  *         op.apply(array[lo]);  *       tryComplete();  *     }  *   }  * }</pre>  *  * As a further improvement, notice that the left task need not even exist.  * Instead of creating a new one, we can iterate using the original task,  * and add a pending count for each fork.  Additionally, because no task  * in this tree implements an {@link #onCompletion(CountedCompleter)} method,  * {@code tryComplete()} can be replaced with {@link #propagateCompletion}.  *  *<pre> {@code  * class ForEach<E> ...  *   public void compute() { // version 3  *     int l = lo,  h = hi;  *     while (h - l>= 2) {  *       int mid = (l + h)>>> 1;  *       addToPendingCount(1);  *       new ForEach(this, array, op, mid, h).fork(); // right child  *       h = mid;  *     }  *     if (h> l)  *       op.apply(array[l]);  *     propagateCompletion();  *   }  * }</pre>  *  * Additional improvements of such classes might entail precomputing  * pending counts so that they can be established in constructors,  * specializing classes for leaf steps, subdividing by say, four,  * instead of two per iteration, and using an adaptive threshold  * instead of always subdividing down to single elements.  *  *<p><b>Searching.</b> A tree of CountedCompleters can search for a  * value or property in different parts of a data structure, and  * report a result in an {@link  * java.util.concurrent.atomic.AtomicReference AtomicReference} as  * soon as one is found. The others can poll the result to avoid  * unnecessary work. (You could additionally {@linkplain #cancel  * cancel} other tasks, but it is usually simpler and more efficient  * to just let them notice that the result is set and if so skip  * further processing.)  Illustrating again with an array using full  * partitioning (again, in practice, leaf tasks will almost always  * process more than one element):  *  *<pre> {@code  * class Searcher<E> extends CountedCompleter<E> {  *   final E[] array; final AtomicReference<E> result; final int lo, hi;  *   Searcher(CountedCompleter<?> p, E[] array, AtomicReference<E> result, int lo, int hi) {  *     super(p);  *     this.array = array; this.result = result; this.lo = lo; this.hi = hi;  *   }  *   public E getRawResult() { return result.get(); }  *   public void compute() { // similar to ForEach version 3  *     int l = lo,  h = hi;  *     while (result.get() == null&& h>= l) {  *       if (h - l>= 2) {  *         int mid = (l + h)>>> 1;  *         addToPendingCount(1);  *         new Searcher(this, array, result, mid, h).fork();  *         h = mid;  *       }  *       else {  *         E x = array[l];  *         if (matches(x)&& result.compareAndSet(null, x))  *           quietlyCompleteRoot(); // root task is now joinable  *         break;  *       }  *     }  *     tryComplete(); // normally complete whether or not found  *   }  *   boolean matches(E e) { ... } // return true if found  *  *   public static<E> E search(E[] array) {  *       return new Searcher<E>(null, array, new AtomicReference<E>(), 0, array.length).invoke();  *   }  * }}</pre>  *  * In this example, as well as others in which tasks have no other  * effects except to compareAndSet a common result, the trailing  * unconditional invocation of {@code tryComplete} could be made  * conditional ({@code if (result.get() == null) tryComplete();})  * because no further bookkeeping is required to manage completions  * once the root task completes.  *  *<p><b>Recording subtasks.</b> CountedCompleter tasks that combine  * results of multiple subtasks usually need to access these results  * in method {@link #onCompletion(CountedCompleter)}. As illustrated in the following  * class (that performs a simplified form of map-reduce where mappings  * and reductions are all of type {@code E}), one way to do this in  * divide and conquer designs is to have each subtask record its  * sibling, so that it can be accessed in method {@code onCompletion}.  * This technique applies to reductions in which the order of  * combining left and right results does not matter; ordered  * reductions require explicit left/right designations.  Variants of  * other streamlinings seen in the above examples may also apply.  *  *<pre> {@code  * class MyMapper<E> { E apply(E v) {  ...  } }  * class MyReducer<E> { E apply(E x, E y) {  ...  } }  * class MapReducer<E> extends CountedCompleter<E> {  *   final E[] array; final MyMapper<E> mapper;  *   final MyReducer<E> reducer; final int lo, hi;  *   MapReducer<E> sibling;  *   E result;  *   MapReducer(CountedCompleter<?> p, E[] array, MyMapper<E> mapper,  *              MyReducer<E> reducer, int lo, int hi) {  *     super(p);  *     this.array = array; this.mapper = mapper;  *     this.reducer = reducer; this.lo = lo; this.hi = hi;  *   }  *   public void compute() {  *     if (hi - lo>= 2) {  *       int mid = (lo + hi)>>> 1;  *       MapReducer<E> left = new MapReducer(this, array, mapper, reducer, lo, mid);  *       MapReducer<E> right = new MapReducer(this, array, mapper, reducer, mid, hi);  *       left.sibling = right;  *       right.sibling = left;  *       setPendingCount(1); // only right is pending  *       right.fork();  *       left.compute();     // directly execute left  *     }  *     else {  *       if (hi> lo)  *           result = mapper.apply(array[lo]);  *       tryComplete();  *     }  *   }  *   public void onCompletion(CountedCompleter<?> caller) {  *     if (caller != this) {  *       MapReducer<E> child = (MapReducer<E>)caller;  *       MapReducer<E> sib = child.sibling;  *       if (sib == null || sib.result == null)  *         result = child.result;  *       else  *         result = reducer.apply(child.result, sib.result);  *     }  *   }  *   public E getRawResult() { return result; }  *  *   public static<E> E mapReduce(E[] array, MyMapper<E> mapper, MyReducer<E> reducer) {  *     return new MapReducer<E>(null, array, mapper, reducer,  *                              0, array.length).invoke();  *   }  * }}</pre>  *  * Here, method {@code onCompletion} takes a form common to many  * completion designs that combine results. This callback-style method  * is triggered once per task, in either of the two different contexts  * in which the pending count is, or becomes, zero: (1) by a task  * itself, if its pending count is zero upon invocation of {@code  * tryComplete}, or (2) by any of its subtasks when they complete and  * decrement the pending count to zero. The {@code caller} argument  * distinguishes cases.  Most often, when the caller is {@code this},  * no action is necessary. Otherwise the caller argument can be used  * (usually via a cast) to supply a value (and/or links to other  * values) to be combined.  Assuming proper use of pending counts, the  * actions inside {@code onCompletion} occur (once) upon completion of  * a task and its subtasks. No additional synchronization is required  * within this method to ensure thread safety of accesses to fields of  * this task or other completed tasks.  *  *<p><b>Completion Traversals</b>. If using {@code onCompletion} to  * process completions is inapplicable or inconvenient, you can use  * methods {@link #firstComplete} and {@link #nextComplete} to create  * custom traversals.  For example, to define a MapReducer that only  * splits out right-hand tasks in the form of the third ForEach  * example, the completions must cooperatively reduce along  * unexhausted subtask links, which can be done as follows:  *  *<pre> {@code  * class MapReducer<E> extends CountedCompleter<E> { // version 2  *   final E[] array; final MyMapper<E> mapper;  *   final MyReducer<E> reducer; final int lo, hi;  *   MapReducer<E> forks, next; // record subtask forks in list  *   E result;  *   MapReducer(CountedCompleter<?> p, E[] array, MyMapper<E> mapper,  *              MyReducer<E> reducer, int lo, int hi, MapReducer<E> next) {  *     super(p);  *     this.array = array; this.mapper = mapper;  *     this.reducer = reducer; this.lo = lo; this.hi = hi;  *     this.next = next;  *   }  *   public void compute() {  *     int l = lo,  h = hi;  *     while (h - l>= 2) {  *       int mid = (l + h)>>> 1;  *       addToPendingCount(1);  *       (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();  *       h = mid;  *     }  *     if (h> l)  *       result = mapper.apply(array[l]);  *     // process completions by reducing along and advancing subtask links  *     for (CountedCompleter<?> c = firstComplete(); c != null; c = c.nextComplete()) {  *       for (MapReducer t = (MapReducer)c, s = t.forks;  s != null; s = t.forks = s.next)  *         t.result = reducer.apply(t.result, s.result);  *     }  *   }  *   public E getRawResult() { return result; }  *  *   public static<E> E mapReduce(E[] array, MyMapper<E> mapper, MyReducer<E> reducer) {  *     return new MapReducer<E>(null, array, mapper, reducer,  *                              0, array.length, null).invoke();  *   }  * }}</pre>  *  *<p><b>Triggers.</b> Some CountedCompleters are themselves never  * forked, but instead serve as bits of plumbing in other designs;  * including those in which the completion of one or more async tasks  * triggers another async task. For example:  *  *<pre> {@code  * class HeaderBuilder extends CountedCompleter<...> { ... }  * class BodyBuilder extends CountedCompleter<...> { ... }  * class PacketSender extends CountedCompleter<...> {  *   PacketSender(...) { super(null, 1); ... } // trigger on second completion  *   public void compute() { } // never called  *   public void onCompletion(CountedCompleter<?> caller) { sendPacket(); }  * }  * // sample use:  * PacketSender p = new PacketSender();  * new HeaderBuilder(p, ...).fork();  * new BodyBuilder(p, ...).fork();  * }</pre>  *  * @since 1.8  * @author Doug Lea  */
end_comment

begin_class
DECL|class|CountedCompleter
specifier|public
specifier|abstract
class|class
name|CountedCompleter
parameter_list|<
name|T
parameter_list|>
extends|extends
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453752276485070L
decl_stmt|;
comment|/** This task's completer, or null if none */
DECL|field|completer
specifier|final
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|completer
decl_stmt|;
comment|/** The number of pending tasks until completion */
DECL|field|pending
specifier|volatile
name|int
name|pending
decl_stmt|;
comment|/**      * Creates a new CountedCompleter with the given completer      * and initial pending count.      *      * @param completer this task's completer, or {@code null} if none      * @param initialPendingCount the initial pending count      */
DECL|method|CountedCompleter
specifier|protected
name|CountedCompleter
parameter_list|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|completer
parameter_list|,
name|int
name|initialPendingCount
parameter_list|)
block|{
name|this
operator|.
name|completer
operator|=
name|completer
expr_stmt|;
name|this
operator|.
name|pending
operator|=
name|initialPendingCount
expr_stmt|;
block|}
comment|/**      * Creates a new CountedCompleter with the given completer      * and an initial pending count of zero.      *      * @param completer this task's completer, or {@code null} if none      */
DECL|method|CountedCompleter
specifier|protected
name|CountedCompleter
parameter_list|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|completer
parameter_list|)
block|{
name|this
operator|.
name|completer
operator|=
name|completer
expr_stmt|;
block|}
comment|/**      * Creates a new CountedCompleter with no completer      * and an initial pending count of zero.      */
DECL|method|CountedCompleter
specifier|protected
name|CountedCompleter
parameter_list|()
block|{
name|this
operator|.
name|completer
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * The main computation performed by this task.      */
DECL|method|compute
specifier|public
specifier|abstract
name|void
name|compute
parameter_list|()
function_decl|;
comment|/**      * Performs an action when method {@link #tryComplete} is invoked      * and the pending count is zero, or when the unconditional      * method {@link #complete} is invoked.  By default, this method      * does nothing. You can distinguish cases by checking the      * identity of the given caller argument. If not equal to {@code      * this}, then it is typically a subtask that may contain results      * (and/or links to other results) to combine.      *      * @param caller the task invoking this method (which may      * be this task itself)      */
DECL|method|onCompletion
specifier|public
name|void
name|onCompletion
parameter_list|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|caller
parameter_list|)
block|{     }
comment|/**      * Performs an action when method {@link      * #completeExceptionally(Throwable)} is invoked or method {@link      * #compute} throws an exception, and this task has not already      * otherwise completed normally. On entry to this method, this task      * {@link ForkJoinTask#isCompletedAbnormally}.  The return value      * of this method controls further propagation: If {@code true}      * and this task has a completer that has not completed, then that      * completer is also completed exceptionally, with the same      * exception as this completer.  The default implementation of      * this method does nothing except return {@code true}.      *      * @param ex the exception      * @param caller the task invoking this method (which may      * be this task itself)      * @return {@code true} if this exception should be propagated to this      * task's completer, if one exists      */
DECL|method|onExceptionalCompletion
specifier|public
name|boolean
name|onExceptionalCompletion
parameter_list|(
name|Throwable
name|ex
parameter_list|,
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|caller
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/**      * Returns the completer established in this task's constructor,      * or {@code null} if none.      *      * @return the completer      */
DECL|method|getCompleter
specifier|public
specifier|final
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|getCompleter
parameter_list|()
block|{
return|return
name|completer
return|;
block|}
comment|/**      * Returns the current pending count.      *      * @return the current pending count      */
DECL|method|getPendingCount
specifier|public
specifier|final
name|int
name|getPendingCount
parameter_list|()
block|{
return|return
name|pending
return|;
block|}
comment|/**      * Sets the pending count to the given value.      *      * @param count the count      */
DECL|method|setPendingCount
specifier|public
specifier|final
name|void
name|setPendingCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|pending
operator|=
name|count
expr_stmt|;
block|}
comment|/**      * Adds (atomically) the given value to the pending count.      *      * @param delta the value to add      */
DECL|method|addToPendingCount
specifier|public
specifier|final
name|void
name|addToPendingCount
parameter_list|(
name|int
name|delta
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PENDING
argument_list|,
name|c
operator|=
name|pending
argument_list|,
name|c
operator|+
name|delta
argument_list|)
condition|)
do|;
block|}
comment|/**      * Sets (atomically) the pending count to the given count only if      * it currently holds the given expected value.      *      * @param expected the expected value      * @param count the new value      * @return {@code true} if successful      */
DECL|method|compareAndSetPendingCount
specifier|public
specifier|final
name|boolean
name|compareAndSetPendingCount
parameter_list|(
name|int
name|expected
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PENDING
argument_list|,
name|expected
argument_list|,
name|count
argument_list|)
return|;
block|}
comment|/**      * If the pending count is nonzero, (atomically) decrements it.      *      * @return the initial (undecremented) pending count holding on entry      * to this method      */
DECL|method|decrementPendingCountUnlessZero
specifier|public
specifier|final
name|int
name|decrementPendingCountUnlessZero
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
do|do
block|{}
do|while
condition|(
operator|(
name|c
operator|=
name|pending
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PENDING
argument_list|,
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
do|;
return|return
name|c
return|;
block|}
comment|/**      * Returns the root of the current computation; i.e., this      * task if it has no completer, else its completer's root.      *      * @return the root of the current computation      */
DECL|method|getRoot
specifier|public
specifier|final
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|getRoot
parameter_list|()
block|{
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|a
init|=
name|this
decl_stmt|,
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|a
operator|.
name|completer
operator|)
operator|!=
literal|null
condition|)
name|a
operator|=
name|p
expr_stmt|;
return|return
name|a
return|;
block|}
comment|/**      * If the pending count is nonzero, decrements the count;      * otherwise invokes {@link #onCompletion(CountedCompleter)}      * and then similarly tries to complete this task's completer,      * if one exists, else marks this task as complete.      */
DECL|method|tryComplete
specifier|public
specifier|final
name|void
name|tryComplete
parameter_list|()
block|{
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|a
init|=
name|this
decl_stmt|,
name|s
init|=
name|a
decl_stmt|;
for|for
control|(
name|int
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|a
operator|.
name|pending
operator|)
operator|==
literal|0
condition|)
block|{
name|a
operator|.
name|onCompletion
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
operator|(
name|s
operator|=
name|a
operator|)
operator|.
name|completer
operator|)
operator|==
literal|null
condition|)
block|{
name|s
operator|.
name|quietlyComplete
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|a
argument_list|,
name|PENDING
argument_list|,
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
return|return;
block|}
block|}
comment|/**      * Equivalent to {@link #tryComplete} but does not invoke {@link      * #onCompletion(CountedCompleter)} along the completion path:      * If the pending count is nonzero, decrements the count;      * otherwise, similarly tries to complete this task's completer, if      * one exists, else marks this task as complete. This method may be      * useful in cases where {@code onCompletion} should not, or need      * not, be invoked for each completer in a computation.      */
DECL|method|propagateCompletion
specifier|public
specifier|final
name|void
name|propagateCompletion
parameter_list|()
block|{
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|a
init|=
name|this
decl_stmt|,
name|s
init|=
name|a
decl_stmt|;
for|for
control|(
name|int
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|a
operator|.
name|pending
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|a
operator|=
operator|(
name|s
operator|=
name|a
operator|)
operator|.
name|completer
operator|)
operator|==
literal|null
condition|)
block|{
name|s
operator|.
name|quietlyComplete
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|a
argument_list|,
name|PENDING
argument_list|,
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
return|return;
block|}
block|}
comment|/**      * Regardless of pending count, invokes      * {@link #onCompletion(CountedCompleter)}, marks this task as      * complete and further triggers {@link #tryComplete} on this      * task's completer, if one exists.  The given rawResult is      * used as an argument to {@link #setRawResult} before invoking      * {@link #onCompletion(CountedCompleter)} or marking this task      * as complete; its value is meaningful only for classes      * overriding {@code setRawResult}.  This method does not modify      * the pending count.      *      *<p>This method may be useful when forcing completion as soon as      * any one (versus all) of several subtask results are obtained.      * However, in the common (and recommended) case in which {@code      * setRawResult} is not overridden, this effect can be obtained      * more simply using {@code quietlyCompleteRoot();}.      *      * @param rawResult the raw result      */
DECL|method|complete
specifier|public
name|void
name|complete
parameter_list|(
name|T
name|rawResult
parameter_list|)
block|{
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|p
decl_stmt|;
name|setRawResult
argument_list|(
name|rawResult
argument_list|)
expr_stmt|;
name|onCompletion
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|quietlyComplete
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|completer
operator|)
operator|!=
literal|null
condition|)
name|p
operator|.
name|tryComplete
argument_list|()
expr_stmt|;
block|}
comment|/**      * If this task's pending count is zero, returns this task;      * otherwise decrements its pending count and returns {@code      * null}. This method is designed to be used with {@link      * #nextComplete} in completion traversal loops.      *      * @return this task, if pending count was zero, else {@code null}      */
DECL|method|firstComplete
specifier|public
specifier|final
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|firstComplete
parameter_list|()
block|{
for|for
control|(
name|int
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|pending
operator|)
operator|==
literal|0
condition|)
return|return
name|this
return|;
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PENDING
argument_list|,
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|null
return|;
block|}
block|}
comment|/**      * If this task does not have a completer, invokes {@link      * ForkJoinTask#quietlyComplete} and returns {@code null}.  Or, if      * the completer's pending count is non-zero, decrements that      * pending count and returns {@code null}.  Otherwise, returns the      * completer.  This method can be used as part of a completion      * traversal loop for homogeneous task hierarchies:      *      *<pre> {@code      * for (CountedCompleter<?> c = firstComplete();      *      c != null;      *      c = c.nextComplete()) {      *   // ... process c ...      * }}</pre>      *      * @return the completer, or {@code null} if none      */
DECL|method|nextComplete
specifier|public
specifier|final
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|nextComplete
parameter_list|()
block|{
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|completer
operator|)
operator|!=
literal|null
condition|)
return|return
name|p
operator|.
name|firstComplete
argument_list|()
return|;
else|else
block|{
name|quietlyComplete
argument_list|()
expr_stmt|;
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Equivalent to {@code getRoot().quietlyComplete()}.      */
DECL|method|quietlyCompleteRoot
specifier|public
specifier|final
name|void
name|quietlyCompleteRoot
parameter_list|()
block|{
for|for
control|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|a
init|=
name|this
init|,
name|p
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|a
operator|.
name|completer
operator|)
operator|==
literal|null
condition|)
block|{
name|a
operator|.
name|quietlyComplete
argument_list|()
expr_stmt|;
return|return;
block|}
name|a
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/**      * Supports ForkJoinTask exception propagation.      */
DECL|method|internalPropagateException
name|void
name|internalPropagateException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|a
init|=
name|this
decl_stmt|,
name|s
init|=
name|a
decl_stmt|;
while|while
condition|(
name|a
operator|.
name|onExceptionalCompletion
argument_list|(
name|ex
argument_list|,
name|s
argument_list|)
operator|&&
operator|(
name|a
operator|=
operator|(
name|s
operator|=
name|a
operator|)
operator|.
name|completer
operator|)
operator|!=
literal|null
operator|&&
name|a
operator|.
name|status
operator|>=
literal|0
operator|&&
name|a
operator|.
name|recordExceptionalCompletion
argument_list|(
name|ex
argument_list|)
operator|==
name|EXCEPTIONAL
condition|)
empty_stmt|;
block|}
comment|/**      * Implements execution conventions for CountedCompleters.      */
DECL|method|exec
specifier|protected
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|compute
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**      * Returns the result of the computation.  By default,      * returns {@code null}, which is appropriate for {@code Void}      * actions, but in other cases should be overridden, almost      * always to return a field or function of a field that      * holds the result upon completion.      *      * @return the result of the computation      */
DECL|method|getRawResult
specifier|public
name|T
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * A method that result-bearing CountedCompleters may optionally      * use to help maintain result data.  By default, does nothing.      * Overrides are not recommended. However, if this method is      * overridden to update existing objects or fields, then it must      * in general be defined to be thread-safe.      */
DECL|method|setRawResult
specifier|protected
name|void
name|setRawResult
parameter_list|(
name|T
name|t
parameter_list|)
block|{ }
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|PENDING
specifier|private
specifier|static
specifier|final
name|long
name|PENDING
decl_stmt|;
static|static
block|{
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|PENDING
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|CountedCompleter
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"pending"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

