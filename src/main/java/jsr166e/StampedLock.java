begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166e
package|package
name|jsr166e
package|;
end_package

begin_import
import|import
name|jsr166y
operator|.
name|ThreadLocalRandom
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Lock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|ReadWriteLock
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_comment
comment|/**  * A capability-based lock with three modes for controlling read/write  * access.  The state of a StampedLock consists of a version and mode.  * Lock acquisition methods return a stamp that represents and  * controls access with respect to a lock state; "try" versions of  * these methods may instead return the special value zero to  * represent failure to acquire access. Lock release and conversion  * methods require stamps as arguments, and fail if they do not match  * the state of the lock. The three modes are:  *  *<ul>  *  *<li><b>Writing.</b> Method {@link #writeLock} possibly blocks  *   waiting for exclusive access, returning a stamp that can be used  *   in method {@link #unlockWrite} to release the lock. Untimed and  *   timed versions of {@code tryWriteLock} are also provided. When  *   the lock is held in write mode, no read locks may be obtained,  *   and all optimistic read validations will fail.</li>  *  *<li><b>Reading.</b> Method {@link #readLock} possibly blocks  *   waiting for non-exclusive access, returning a stamp that can be  *   used in method {@link #unlockRead} to release the lock. Untimed  *   and timed versions of {@code tryReadLock} are also provided.</li>  *  *<li><b>Optimistic Reading.</b> Method {@link #tryOptimisticRead}  *   returns a non-zero stamp only if the lock is not currently held  *   in write mode. Method {@link #validate} returns true if the lock  *   has not been acquired in write mode since obtaining a given  *   stamp.  This mode can be thought of as an extremely weak version  *   of a read-lock, that can be broken by a writer at any time.  The  *   use of optimistic mode for short read-only code segments often  *   reduces contention and improves throughput.  However, its use is  *   inherently fragile.  Optimistic read sections should only read  *   fields and hold them in local variables for later use after  *   validation. Fields read while in optimistic mode may be wildly  *   inconsistent, so usage applies only when you are familiar enough  *   with data representations to check consistency and/or repeatedly  *   invoke method {@code validate()}.  For example, such steps are  *   typically required when first reading an object or array  *   reference, and then accessing one of its fields, elements or  *   methods.</li>  *  *</ul>  *  *<p>This class also supports methods that conditionally provide  * conversions across the three modes. For example, method {@link  * #tryConvertToWriteLock} attempts to "upgrade" a mode, returning  * a valid write stamp if (1) already in writing mode (2) in reading  * mode and there are no other readers or (3) in optimistic mode and  * the lock is available. The forms of these methods are designed to  * help reduce some of the code bloat that otherwise occurs in  * retry-based designs.  *  *<p>StampedLocks are designed for use as internal utilities in the  * development of thread-safe components. Their use relies on  * knowledge of the internal properties of the data, objects, and  * methods they are protecting.  They are not reentrant, so locked  * bodies should not call other unknown methods that may try to  * re-acquire locks (although you may pass a stamp to other methods  * that can use or convert it).  The use of read lock modes relies on  * the associated code sections being side-effect-free.  Unvalidated  * optimistic read sections cannot call methods that are not known to  * tolerate potential inconsistencies.  Stamps use finite  * representations, and are not cryptographically secure (i.e., a  * valid stamp may be guessable). Stamp values may recycle after (no  * sooner than) one year of continuous operation. A stamp held without  * use or validation for longer than this period may fail to validate  * correctly.  StampedLocks are serializable, but always deserialize  * into initial unlocked state, so they are not useful for remote  * locking.  *  *<p>The scheduling policy of StampedLock does not consistently  * prefer readers over writers or vice versa.  All "try" methods are  * best-effort and do not necessarily conform to any scheduling or  * fairness policy. A zero return from any "try" method for acquiring  * or converting locks does not carry any information about the state  * of the lock; a subsequent invocation may succeed.  *  *<p>Because it supports coordinated usage across multiple lock  * modes, this class does not directly implement the {@link Lock} or  * {@link ReadWriteLock} interfaces. However, a StampedLock may be  * viewed {@link #asReadLock()}, {@link #asWriteLock()}, or {@link  * #asReadWriteLock()} in applications requiring only the associated  * set of functionality.  *  *<p><b>Sample Usage.</b> The following illustrates some usage idioms  * in a class that maintains simple two-dimensional points. The sample  * code illustrates some try/catch conventions even though they are  * not strictly needed here because no exceptions can occur in their  * bodies.<br>  *  *<pre>{@code  * class Point {  *   private double x, y;  *   private final StampedLock sl = new StampedLock();  *  *   void move(double deltaX, double deltaY) { // an exclusively locked method  *     long stamp = sl.writeLock();  *     try {  *       x += deltaX;  *       y += deltaY;  *     } finally {  *       sl.unlockWrite(stamp);  *     }  *   }  *  *   double distanceFromOrigin() { // A read-only method  *     long stamp = sl.tryOptimisticRead();  *     double currentX = x, currentY = y;  *     if (!sl.validate(stamp)) {  *        stamp = sl.readLock();  *        try {  *          currentX = x;  *          currentY = y;  *        } finally {  *           sl.unlockRead(stamp);  *        }  *     }  *     return Math.sqrt(currentX * currentX + currentY * currentY);  *   }  *  *   void moveIfAtOrigin(double newX, double newY) { // upgrade  *     // Could instead start with optimistic, not read mode  *     long stamp = sl.readLock();  *     try {  *       while (x == 0.0&& y == 0.0) {  *         long ws = sl.tryConvertToWriteLock(stamp);  *         if (ws != 0L) {  *           stamp = ws;  *           x = newX;  *           y = newY;  *           break;  *         }  *         else {  *           sl.unlockRead(stamp);  *           stamp = sl.writeLock();  *         }  *       }  *     } finally {  *       sl.unlock(stamp);  *     }  *   }  * }}</pre>  *  * @since 1.8  * @author Doug Lea  */
end_comment

begin_class
DECL|class|StampedLock
specifier|public
class|class
name|StampedLock
implements|implements
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
comment|/*      * Algorithmic notes:      *      * The design employs elements of Sequence locks      * (as used in linux kernels; see Lameter's      * http://www.lameter.com/gelato2005.pdf      * and elsewhere; see      * Boehm's http://www.hpl.hp.com/techreports/2012/HPL-2012-68.html)      * and Ordered RW locks (see Shirako et al      * http://dl.acm.org/citation.cfm?id=2312015)      *      * Conceptually, the primary state of the lock includes a sequence      * number that is odd when write-locked and even otherwise.      * However, this is offset by a reader count that is non-zero when      * read-locked.  The read count is ignored when validating      * "optimistic" seqlock-reader-style stamps.  Because we must use      * a small finite number of bits (currently 7) for readers, a      * supplementary reader overflow word is used when the number of      * readers exceeds the count field. We do this by treating the max      * reader count value (RBITS) as a spinlock protecting overflow      * updates.      *      * Waiters use a modified form of CLH lock used in      * AbstractQueuedSynchronizer (see its internal documentation for      * a fuller account), where each node is tagged (field mode) as      * either a reader or writer. Sets of waiting readers are grouped      * (linked) under a common node (field cowait) so act as a single      * node with respect to most CLH mechanics.  By virtue of the      * queue structure, wait nodes need not actually carry sequence      * numbers; we know each is greater than its predecessor.  This      * simplifies the scheduling policy to a mainly-FIFO scheme that      * incorporates elements of Phase-Fair locks (see Brandenburg&      * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  In      * particular, we use the phase-fair anti-barging rule: If an      * incoming reader arrives while read lock is held but there is a      * queued writer, this incoming reader is queued.  (This rule is      * responsible for some of the complexity of method acquireRead,      * but without it, the lock becomes highly unfair.)      *      * These rules apply to threads actually queued. All tryLock forms      * opportunistically try to acquire locks regardless of preference      * rules, and so may "barge" their way in.  Randomized spinning is      * used in the acquire methods to reduce (increasingly expensive)      * context switching while also avoiding sustained memory      * thrashing among many threads.  We limit spins to the head of      * queue. A thread spin-waits up to SPINS times (where each      * iteration decreases spin count with 50% probability) before      * blocking. If, upon wakening it fails to obtain lock, and is      * still (or becomes) the first waiting thread (which indicates      * that some other thread barged and obtained lock), it escalates      * spins (up to MAX_HEAD_SPINS) to reduce the likelihood of      * continually losing to barging threads.      *      * Nearly all of these mechanics are carried out in methods      * acquireWrite and acquireRead, that, as typical of such code,      * sprawl out because actions and retries rely on consistent sets      * of locally cached reads.      *      * As noted in Boehm's paper (above), sequence validation (mainly      * method validate()) requires stricter ordering rules than apply      * to normal volatile reads (of "state").  In the absence of (but      * continual hope for) explicit JVM support of intrinsics with      * double-sided reordering prohibition, or corresponding fence      * intrinsics, we for now uncomfortably rely on the fact that the      * Unsafe.getXVolatile intrinsic must have this property      * (syntactic volatile reads do not) for internal purposes anyway,      * even though it is not documented.      *      * The memory layout keeps lock state and queue pointers together      * (normally on the same cache line). This usually works well for      * read-mostly loads. In most other cases, the natural tendency of      * adaptive-spin CLH locks to reduce memory contention lessens      * motivation to further spread out contended locations, but might      * be subject to future improvements.      */
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|6001602636862214147L
decl_stmt|;
comment|/** Number of processors, for spin control */
DECL|field|NCPU
specifier|private
specifier|static
specifier|final
name|int
name|NCPU
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
decl_stmt|;
comment|/** Maximum number of retries before blocking on acquisition */
DECL|field|SPINS
specifier|private
specifier|static
specifier|final
name|int
name|SPINS
init|=
operator|(
name|NCPU
operator|>
literal|1
operator|)
condition|?
literal|1
operator|<<
literal|6
else|:
literal|0
decl_stmt|;
comment|/** Maximum number of retries before re-blocking */
DECL|field|MAX_HEAD_SPINS
specifier|private
specifier|static
specifier|final
name|int
name|MAX_HEAD_SPINS
init|=
operator|(
name|NCPU
operator|>
literal|1
operator|)
condition|?
literal|1
operator|<<
literal|12
else|:
literal|0
decl_stmt|;
comment|/** The period for yielding when waiting for overflow spinlock */
DECL|field|OVERFLOW_YIELD_RATE
specifier|private
specifier|static
specifier|final
name|int
name|OVERFLOW_YIELD_RATE
init|=
literal|7
decl_stmt|;
comment|// must be power 2 - 1
comment|/** The number of bits to use for reader count before overflowing */
DECL|field|LG_READERS
specifier|private
specifier|static
specifier|final
name|int
name|LG_READERS
init|=
literal|7
decl_stmt|;
comment|// Values for lock state and stamp operations
DECL|field|RUNIT
specifier|private
specifier|static
specifier|final
name|long
name|RUNIT
init|=
literal|1L
decl_stmt|;
DECL|field|WBIT
specifier|private
specifier|static
specifier|final
name|long
name|WBIT
init|=
literal|1L
operator|<<
name|LG_READERS
decl_stmt|;
DECL|field|RBITS
specifier|private
specifier|static
specifier|final
name|long
name|RBITS
init|=
name|WBIT
operator|-
literal|1L
decl_stmt|;
DECL|field|RFULL
specifier|private
specifier|static
specifier|final
name|long
name|RFULL
init|=
name|RBITS
operator|-
literal|1L
decl_stmt|;
DECL|field|ABITS
specifier|private
specifier|static
specifier|final
name|long
name|ABITS
init|=
name|RBITS
operator||
name|WBIT
decl_stmt|;
DECL|field|SBITS
specifier|private
specifier|static
specifier|final
name|long
name|SBITS
init|=
operator|~
name|RBITS
decl_stmt|;
comment|// note overlap with ABITS
comment|// Initial value for lock state; avoid failure value zero
DECL|field|ORIGIN
specifier|private
specifier|static
specifier|final
name|long
name|ORIGIN
init|=
name|WBIT
operator|<<
literal|1
decl_stmt|;
comment|// Special value from cancelled acquire methods so caller can throw IE
DECL|field|INTERRUPTED
specifier|private
specifier|static
specifier|final
name|long
name|INTERRUPTED
init|=
literal|1L
decl_stmt|;
comment|// Values for node status; order matters
DECL|field|WAITING
specifier|private
specifier|static
specifier|final
name|int
name|WAITING
init|=
operator|-
literal|1
decl_stmt|;
DECL|field|CANCELLED
specifier|private
specifier|static
specifier|final
name|int
name|CANCELLED
init|=
literal|1
decl_stmt|;
comment|// Modes for nodes (int not boolean to allow arithmetic)
DECL|field|RMODE
specifier|private
specifier|static
specifier|final
name|int
name|RMODE
init|=
literal|0
decl_stmt|;
DECL|field|WMODE
specifier|private
specifier|static
specifier|final
name|int
name|WMODE
init|=
literal|1
decl_stmt|;
comment|/** Wait nodes */
DECL|class|WNode
specifier|static
specifier|final
class|class
name|WNode
block|{
DECL|field|prev
specifier|volatile
name|WNode
name|prev
decl_stmt|;
DECL|field|next
specifier|volatile
name|WNode
name|next
decl_stmt|;
DECL|field|cowait
specifier|volatile
name|WNode
name|cowait
decl_stmt|;
comment|// list of linked readers
DECL|field|thread
specifier|volatile
name|Thread
name|thread
decl_stmt|;
comment|// non-null while possibly parked
DECL|field|status
specifier|volatile
name|int
name|status
decl_stmt|;
comment|// 0, WAITING, or CANCELLED
DECL|field|mode
specifier|final
name|int
name|mode
decl_stmt|;
comment|// RMODE or WMODE
DECL|method|WNode
name|WNode
parameter_list|(
name|int
name|m
parameter_list|,
name|WNode
name|p
parameter_list|)
block|{
name|mode
operator|=
name|m
expr_stmt|;
name|prev
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/** Head of CLH queue */
DECL|field|whead
specifier|private
specifier|transient
specifier|volatile
name|WNode
name|whead
decl_stmt|;
comment|/** Tail (last) of CLH queue */
DECL|field|wtail
specifier|private
specifier|transient
specifier|volatile
name|WNode
name|wtail
decl_stmt|;
comment|// views
DECL|field|readLockView
specifier|transient
name|ReadLockView
name|readLockView
decl_stmt|;
DECL|field|writeLockView
specifier|transient
name|WriteLockView
name|writeLockView
decl_stmt|;
DECL|field|readWriteLockView
specifier|transient
name|ReadWriteLockView
name|readWriteLockView
decl_stmt|;
comment|/** Lock sequence/state */
DECL|field|state
specifier|private
specifier|transient
specifier|volatile
name|long
name|state
decl_stmt|;
comment|/** extra reader count when state read count saturated */
DECL|field|readerOverflow
specifier|private
specifier|transient
name|int
name|readerOverflow
decl_stmt|;
comment|/**      * Creates a new lock, initially in unlocked state.      */
DECL|method|StampedLock
specifier|public
name|StampedLock
parameter_list|()
block|{
name|state
operator|=
name|ORIGIN
expr_stmt|;
block|}
comment|/**      * Exclusively acquires the lock, blocking if necessary      * until available.      *      * @return a stamp that can be used to unlock or convert mode      */
DECL|method|writeLock
specifier|public
name|long
name|writeLock
parameter_list|()
block|{
name|long
name|s
decl_stmt|,
name|next
decl_stmt|;
comment|// bypass acquireWrite in fully unlocked case only
return|return
operator|(
operator|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|==
literal|0L
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|+
name|WBIT
argument_list|)
operator|)
condition|?
name|next
else|:
name|acquireWrite
argument_list|(
literal|false
argument_list|,
literal|0L
argument_list|)
operator|)
return|;
block|}
comment|/**      * Exclusively acquires the lock if it is immediately available.      *      * @return a stamp that can be used to unlock or convert mode,      * or zero if the lock is not available      */
DECL|method|tryWriteLock
specifier|public
name|long
name|tryWriteLock
parameter_list|()
block|{
name|long
name|s
decl_stmt|,
name|next
decl_stmt|;
return|return
operator|(
operator|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|==
literal|0L
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|+
name|WBIT
argument_list|)
operator|)
condition|?
name|next
else|:
literal|0L
operator|)
return|;
block|}
comment|/**      * Exclusively acquires the lock if it is available within the      * given time and the current thread has not been interrupted.      * Behavior under timeout and interruption matches that specified      * for method {@link Lock#tryLock(long,TimeUnit)}.      *      * @param time the maximum time to wait for the lock      * @param unit the time unit of the {@code time} argument      * @return a stamp that can be used to unlock or convert mode,      * or zero if the lock is not available      * @throws InterruptedException if the current thread is interrupted      * before acquiring the lock      */
DECL|method|tryWriteLock
specifier|public
name|long
name|tryWriteLock
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|time
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
name|long
name|next
decl_stmt|,
name|deadline
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|tryWriteLock
argument_list|()
operator|)
operator|!=
literal|0L
condition|)
return|return
name|next
return|;
if|if
condition|(
name|nanos
operator|<=
literal|0L
condition|)
return|return
literal|0L
return|;
if|if
condition|(
operator|(
name|deadline
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|nanos
operator|)
operator|==
literal|0L
condition|)
name|deadline
operator|=
literal|1L
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|acquireWrite
argument_list|(
literal|true
argument_list|,
name|deadline
argument_list|)
operator|)
operator|!=
name|INTERRUPTED
condition|)
return|return
name|next
return|;
block|}
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|/**      * Exclusively acquires the lock, blocking if necessary      * until available or the current thread is interrupted.      * Behavior under interruption matches that specified      * for method {@link Lock#lockInterruptibly()}.      *      * @return a stamp that can be used to unlock or convert mode      * @throws InterruptedException if the current thread is interrupted      * before acquiring the lock      */
DECL|method|writeLockInterruptibly
specifier|public
name|long
name|writeLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
operator|&&
operator|(
name|next
operator|=
name|acquireWrite
argument_list|(
literal|true
argument_list|,
literal|0L
argument_list|)
operator|)
operator|!=
name|INTERRUPTED
condition|)
return|return
name|next
return|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|/**      * Non-exclusively acquires the lock, blocking if necessary      * until available.      *      * @return a stamp that can be used to unlock or convert mode      */
DECL|method|readLock
specifier|public
name|long
name|readLock
parameter_list|()
block|{
name|long
name|s
decl_stmt|,
name|next
decl_stmt|;
comment|// bypass acquireRead on fully unlocked case only
return|return
operator|(
operator|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|==
literal|0L
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|+
name|RUNIT
argument_list|)
operator|)
condition|?
name|next
else|:
name|acquireRead
argument_list|(
literal|false
argument_list|,
literal|0L
argument_list|)
operator|)
return|;
block|}
comment|/**      * Non-exclusively acquires the lock if it is immediately available.      *      * @return a stamp that can be used to unlock or convert mode,      * or zero if the lock is not available      */
DECL|method|tryReadLock
specifier|public
name|long
name|tryReadLock
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
decl_stmt|,
name|m
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|==
name|WBIT
condition|)
return|return
literal|0L
return|;
elseif|else
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|+
name|RUNIT
argument_list|)
condition|)
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|=
name|tryIncReaderOverflow
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0L
condition|)
return|return
name|next
return|;
block|}
block|}
comment|/**      * Non-exclusively acquires the lock if it is available within the      * given time and the current thread has not been interrupted.      * Behavior under timeout and interruption matches that specified      * for method {@link Lock#tryLock(long,TimeUnit)}.      *      * @param time the maximum time to wait for the lock      * @param unit the time unit of the {@code time} argument      * @return a stamp that can be used to unlock or convert mode,      * or zero if the lock is not available      * @throws InterruptedException if the current thread is interrupted      * before acquiring the lock      */
DECL|method|tryReadLock
specifier|public
name|long
name|tryReadLock
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|s
decl_stmt|,
name|m
decl_stmt|,
name|next
decl_stmt|,
name|deadline
decl_stmt|;
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|time
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|!=
name|WBIT
condition|)
block|{
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|+
name|RUNIT
argument_list|)
condition|)
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|=
name|tryIncReaderOverflow
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0L
condition|)
return|return
name|next
return|;
block|}
if|if
condition|(
name|nanos
operator|<=
literal|0L
condition|)
return|return
literal|0L
return|;
if|if
condition|(
operator|(
name|deadline
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|nanos
operator|)
operator|==
literal|0L
condition|)
name|deadline
operator|=
literal|1L
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|acquireRead
argument_list|(
literal|true
argument_list|,
name|deadline
argument_list|)
operator|)
operator|!=
name|INTERRUPTED
condition|)
return|return
name|next
return|;
block|}
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|/**      * Non-exclusively acquires the lock, blocking if necessary      * until available or the current thread is interrupted.      * Behavior under interruption matches that specified      * for method {@link Lock#lockInterruptibly()}.      *      * @return a stamp that can be used to unlock or convert mode      * @throws InterruptedException if the current thread is interrupted      * before acquiring the lock      */
DECL|method|readLockInterruptibly
specifier|public
name|long
name|readLockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|long
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
operator|&&
operator|(
name|next
operator|=
name|acquireRead
argument_list|(
literal|true
argument_list|,
literal|0L
argument_list|)
operator|)
operator|!=
name|INTERRUPTED
condition|)
return|return
name|next
return|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
comment|/**      * Returns a stamp that can later be validated, or zero      * if exclusively locked.      *      * @return a stamp, or zero if exclusively locked      */
DECL|method|tryOptimisticRead
specifier|public
name|long
name|tryOptimisticRead
parameter_list|()
block|{
name|long
name|s
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|WBIT
operator|)
operator|==
literal|0L
operator|)
condition|?
operator|(
name|s
operator|&
name|SBITS
operator|)
else|:
literal|0L
return|;
block|}
comment|/**      * Returns true if the lock has not been exclusively acquired      * since issuance of the given stamp. Always returns false if the      * stamp is zero. Always returns true if the stamp represents a      * currently held lock. Invoking this method with a value not      * obtained from {@link #tryOptimisticRead} or a locking method      * for this lock has no defined effect or result.      *      * @param stamp a stamp      * @return {@code true} if the lock has not been exclusively acquired      * since issuance of the given stamp; else false      */
DECL|method|validate
specifier|public
name|boolean
name|validate
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
comment|// See above about current use of getLongVolatile here
return|return
operator|(
name|stamp
operator|&
name|SBITS
operator|)
operator|==
operator|(
name|U
operator|.
name|getLongVolatile
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|)
operator|&
name|SBITS
operator|)
return|;
block|}
comment|/**      * If the lock state matches the given stamp, releases the      * exclusive lock.      *      * @param stamp a stamp returned by a write-lock operation      * @throws IllegalMonitorStateException if the stamp does      * not match the current state of this lock      */
DECL|method|unlockWrite
specifier|public
name|void
name|unlockWrite
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|WNode
name|h
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|stamp
operator|||
operator|(
name|stamp
operator|&
name|WBIT
operator|)
operator|==
literal|0L
condition|)
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
name|state
operator|=
operator|(
name|stamp
operator|+=
name|WBIT
operator|)
operator|==
literal|0L
condition|?
name|ORIGIN
else|:
name|stamp
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
comment|/**      * If the lock state matches the given stamp, releases the      * non-exclusive lock.      *      * @param stamp a stamp returned by a read-lock operation      * @throws IllegalMonitorStateException if the stamp does      * not match the current state of this lock      */
DECL|method|unlockRead
specifier|public
name|void
name|unlockRead
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|long
name|s
decl_stmt|,
name|m
decl_stmt|;
name|WNode
name|h
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|SBITS
operator|)
operator|!=
operator|(
name|stamp
operator|&
name|SBITS
operator|)
operator|||
operator|(
name|stamp
operator|&
name|ABITS
operator|)
operator|==
literal|0L
operator|||
operator|(
name|m
operator|=
name|s
operator|&
name|ABITS
operator|)
operator|==
literal|0L
operator|||
name|m
operator|==
name|WBIT
condition|)
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|s
operator|-
name|RUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|RUNIT
operator|&&
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|tryDecReaderOverflow
argument_list|(
name|s
argument_list|)
operator|!=
literal|0L
condition|)
break|break;
block|}
block|}
comment|/**      * If the lock state matches the given stamp, releases the      * corresponding mode of the lock.      *      * @param stamp a stamp returned by a lock operation      * @throws IllegalMonitorStateException if the stamp does      * not match the current state of this lock      */
DECL|method|unlock
specifier|public
name|void
name|unlock
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|long
name|a
init|=
name|stamp
operator|&
name|ABITS
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|;
name|WNode
name|h
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|SBITS
operator|)
operator|==
operator|(
name|stamp
operator|&
name|SBITS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|s
operator|&
name|ABITS
operator|)
operator|==
literal|0L
condition|)
break|break;
elseif|else
if|if
condition|(
name|m
operator|==
name|WBIT
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|m
condition|)
break|break;
name|state
operator|=
operator|(
name|s
operator|+=
name|WBIT
operator|)
operator|==
literal|0L
condition|?
name|ORIGIN
else|:
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
literal|0L
operator|||
name|a
operator|>=
name|WBIT
condition|)
break|break;
elseif|else
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|s
operator|-
name|RUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|RUNIT
operator|&&
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|tryDecReaderOverflow
argument_list|(
name|s
argument_list|)
operator|!=
literal|0L
condition|)
return|return;
block|}
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
block|}
comment|/**      * If the lock state matches the given stamp, performs one of      * the following actions. If the stamp represents holding a write      * lock, returns it.  Or, if a read lock, if the write lock is      * available, releases the read lock and returns a write stamp.      * Or, if an optimistic read, returns a write stamp only if      * immediately available. This method returns zero in all other      * cases.      *      * @param stamp a stamp      * @return a valid write stamp, or zero on failure      */
DECL|method|tryConvertToWriteLock
specifier|public
name|long
name|tryConvertToWriteLock
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|long
name|a
init|=
name|stamp
operator|&
name|ABITS
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|,
name|next
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|SBITS
operator|)
operator|==
operator|(
name|stamp
operator|&
name|SBITS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|s
operator|&
name|ABITS
operator|)
operator|==
literal|0L
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0L
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|+
name|WBIT
argument_list|)
condition|)
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|WBIT
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|m
condition|)
break|break;
return|return
name|stamp
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|RUNIT
operator|&&
name|a
operator|!=
literal|0L
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|-
name|RUNIT
operator|+
name|WBIT
argument_list|)
condition|)
return|return
name|next
return|;
block|}
else|else
break|break;
block|}
return|return
literal|0L
return|;
block|}
comment|/**      * If the lock state matches the given stamp, performs one of      * the following actions. If the stamp represents holding a write      * lock, releases it and obtains a read lock.  Or, if a read lock,      * returns it. Or, if an optimistic read, acquires a read lock and      * returns a read stamp only if immediately available. This method      * returns zero in all other cases.      *      * @param stamp a stamp      * @return a valid read stamp, or zero on failure      */
DECL|method|tryConvertToReadLock
specifier|public
name|long
name|tryConvertToReadLock
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|long
name|a
init|=
name|stamp
operator|&
name|ABITS
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|,
name|next
decl_stmt|;
name|WNode
name|h
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|SBITS
operator|)
operator|==
operator|(
name|stamp
operator|&
name|SBITS
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|s
operator|&
name|ABITS
operator|)
operator|==
literal|0L
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0L
condition|)
break|break;
elseif|else
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|+
name|RUNIT
argument_list|)
condition|)
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|=
name|tryIncReaderOverflow
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0L
condition|)
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|WBIT
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|m
condition|)
break|break;
name|state
operator|=
name|next
operator|=
name|s
operator|+
operator|(
name|WBIT
operator|+
name|RUNIT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|!=
literal|0L
operator|&&
name|a
operator|<
name|WBIT
condition|)
return|return
name|stamp
return|;
else|else
break|break;
block|}
return|return
literal|0L
return|;
block|}
comment|/**      * If the lock state matches the given stamp then, if the stamp      * represents holding a lock, releases it and returns an      * observation stamp.  Or, if an optimistic read, returns it if      * validated. This method returns zero in all other cases, and so      * may be useful as a form of "tryUnlock".      *      * @param stamp a stamp      * @return a valid optimistic read stamp, or zero on failure      */
DECL|method|tryConvertToOptimisticRead
specifier|public
name|long
name|tryConvertToOptimisticRead
parameter_list|(
name|long
name|stamp
parameter_list|)
block|{
name|long
name|a
init|=
name|stamp
operator|&
name|ABITS
decl_stmt|,
name|m
decl_stmt|,
name|s
decl_stmt|,
name|next
decl_stmt|;
name|WNode
name|h
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|U
operator|.
name|getLongVolatile
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|)
expr_stmt|;
comment|// see above
if|if
condition|(
operator|(
name|s
operator|&
name|SBITS
operator|)
operator|!=
operator|(
name|stamp
operator|&
name|SBITS
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|=
name|s
operator|&
name|ABITS
operator|)
operator|==
literal|0L
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0L
condition|)
break|break;
return|return
name|s
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
name|WBIT
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|m
condition|)
break|break;
name|state
operator|=
name|next
operator|=
operator|(
name|s
operator|+=
name|WBIT
operator|)
operator|==
literal|0L
condition|?
name|ORIGIN
else|:
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
literal|0L
operator|||
name|a
operator|>=
name|WBIT
condition|)
break|break;
elseif|else
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|next
operator|=
name|s
operator|-
name|RUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|RUNIT
operator|&&
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
name|next
operator|&
name|SBITS
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|=
name|tryDecReaderOverflow
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0L
condition|)
return|return
name|next
operator|&
name|SBITS
return|;
block|}
return|return
literal|0L
return|;
block|}
comment|/**      * Releases the write lock if it is held, without requiring a      * stamp value. This method may be useful for recovery after      * errors.      *      * @return {@code true} if the lock was held, else false      */
DECL|method|tryUnlockWrite
specifier|public
name|boolean
name|tryUnlockWrite
parameter_list|()
block|{
name|long
name|s
decl_stmt|;
name|WNode
name|h
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|WBIT
operator|)
operator|!=
literal|0L
condition|)
block|{
name|state
operator|=
operator|(
name|s
operator|+=
name|WBIT
operator|)
operator|==
literal|0L
condition|?
name|ORIGIN
else|:
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Releases one hold of the read lock if it is held, without      * requiring a stamp value. This method may be useful for recovery      * after errors.      *      * @return {@code true} if the read lock was held, else false      */
DECL|method|tryUnlockRead
specifier|public
name|boolean
name|tryUnlockRead
parameter_list|()
block|{
name|long
name|s
decl_stmt|,
name|m
decl_stmt|;
name|WNode
name|h
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|!=
literal|0L
operator|&&
name|m
operator|<
name|WBIT
condition|)
block|{
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|s
operator|-
name|RUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|RUNIT
operator|&&
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|tryDecReaderOverflow
argument_list|(
name|s
argument_list|)
operator|!=
literal|0L
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|// status monitoring methods
comment|/**      * Returns combined state-held and overflow read count for given      * state s.      */
DECL|method|getReadLockCount
specifier|private
name|int
name|getReadLockCount
parameter_list|(
name|long
name|s
parameter_list|)
block|{
name|long
name|readers
decl_stmt|;
if|if
condition|(
operator|(
name|readers
operator|=
name|s
operator|&
name|RBITS
operator|)
operator|>=
name|RFULL
condition|)
name|readers
operator|=
name|RFULL
operator|+
name|readerOverflow
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|readers
return|;
block|}
comment|/**      * Returns {@code true} if the lock is currently held exclusively.      *      * @return {@code true} if the lock is currently held exclusively      */
DECL|method|isWriteLocked
specifier|public
name|boolean
name|isWriteLocked
parameter_list|()
block|{
return|return
operator|(
name|state
operator|&
name|WBIT
operator|)
operator|!=
literal|0L
return|;
block|}
comment|/**      * Returns {@code true} if the lock is currently held non-exclusively.      *      * @return {@code true} if the lock is currently held non-exclusively      */
DECL|method|isReadLocked
specifier|public
name|boolean
name|isReadLocked
parameter_list|()
block|{
return|return
operator|(
name|state
operator|&
name|RBITS
operator|)
operator|!=
literal|0L
return|;
block|}
comment|/**      * Queries the number of read locks held for this lock. This      * method is designed for use in monitoring system state, not for      * synchronization control.      * @return the number of read locks held      */
DECL|method|getReadLockCount
specifier|public
name|int
name|getReadLockCount
parameter_list|()
block|{
return|return
name|getReadLockCount
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**      * Returns a string identifying this lock, as well as its lock      * state.  The state, in brackets, includes the String {@code      * "Unlocked"} or the String {@code "Write-locked"} or the String      * {@code "Read-locks:"} followed by the current number of      * read-locks held.      *      * @return a string identifying this lock, as well as its lock state      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
name|long
name|s
init|=
name|state
decl_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
operator|(
operator|(
name|s
operator|&
name|ABITS
operator|)
operator|==
literal|0L
condition|?
literal|"[Unlocked]"
else|:
operator|(
name|s
operator|&
name|WBIT
operator|)
operator|!=
literal|0L
condition|?
literal|"[Write-locked]"
else|:
literal|"[Read-locks:"
operator|+
name|getReadLockCount
argument_list|(
name|s
argument_list|)
operator|+
literal|"]"
operator|)
return|;
block|}
comment|// views
comment|/**      * Returns a plain {@link Lock} view of this StampedLock in which      * the {@link Lock#lock} method is mapped to {@link #readLock},      * and similarly for other methods. The returned Lock does not      * support a {@link Condition}; method {@link      * Lock#newCondition()} throws {@code      * UnsupportedOperationException}.      *      * @return the lock      */
DECL|method|asReadLock
specifier|public
name|Lock
name|asReadLock
parameter_list|()
block|{
name|ReadLockView
name|v
decl_stmt|;
return|return
operator|(
operator|(
name|v
operator|=
name|readLockView
operator|)
operator|!=
literal|null
condition|?
name|v
else|:
operator|(
name|readLockView
operator|=
operator|new
name|ReadLockView
argument_list|()
operator|)
operator|)
return|;
block|}
comment|/**      * Returns a plain {@link Lock} view of this StampedLock in which      * the {@link Lock#lock} method is mapped to {@link #writeLock},      * and similarly for other methods. The returned Lock does not      * support a {@link Condition}; method {@link      * Lock#newCondition()} throws {@code      * UnsupportedOperationException}.      *      * @return the lock      */
DECL|method|asWriteLock
specifier|public
name|Lock
name|asWriteLock
parameter_list|()
block|{
name|WriteLockView
name|v
decl_stmt|;
return|return
operator|(
operator|(
name|v
operator|=
name|writeLockView
operator|)
operator|!=
literal|null
condition|?
name|v
else|:
operator|(
name|writeLockView
operator|=
operator|new
name|WriteLockView
argument_list|()
operator|)
operator|)
return|;
block|}
comment|/**      * Returns a {@link ReadWriteLock} view of this StampedLock in      * which the {@link ReadWriteLock#readLock()} method is mapped to      * {@link #asReadLock()}, and {@link ReadWriteLock#writeLock()} to      * {@link #asWriteLock()}.      *      * @return the lock      */
DECL|method|asReadWriteLock
specifier|public
name|ReadWriteLock
name|asReadWriteLock
parameter_list|()
block|{
name|ReadWriteLockView
name|v
decl_stmt|;
return|return
operator|(
operator|(
name|v
operator|=
name|readWriteLockView
operator|)
operator|!=
literal|null
condition|?
name|v
else|:
operator|(
name|readWriteLockView
operator|=
operator|new
name|ReadWriteLockView
argument_list|()
operator|)
operator|)
return|;
block|}
comment|// view classes
DECL|class|ReadLockView
specifier|final
class|class
name|ReadLockView
implements|implements
name|Lock
block|{
DECL|method|lock
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|readLock
argument_list|()
expr_stmt|;
block|}
DECL|method|lockInterruptibly
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|readLockInterruptibly
argument_list|()
expr_stmt|;
block|}
DECL|method|tryLock
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
return|return
name|tryReadLock
argument_list|()
operator|!=
literal|0L
return|;
block|}
DECL|method|tryLock
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|tryReadLock
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
operator|!=
literal|0L
return|;
block|}
DECL|method|unlock
specifier|public
name|void
name|unlock
parameter_list|()
block|{
name|unstampedUnlockRead
argument_list|()
expr_stmt|;
block|}
DECL|method|newCondition
specifier|public
name|Condition
name|newCondition
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
DECL|class|WriteLockView
specifier|final
class|class
name|WriteLockView
implements|implements
name|Lock
block|{
DECL|method|lock
specifier|public
name|void
name|lock
parameter_list|()
block|{
name|writeLock
argument_list|()
expr_stmt|;
block|}
DECL|method|lockInterruptibly
specifier|public
name|void
name|lockInterruptibly
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|writeLockInterruptibly
argument_list|()
expr_stmt|;
block|}
DECL|method|tryLock
specifier|public
name|boolean
name|tryLock
parameter_list|()
block|{
return|return
name|tryWriteLock
argument_list|()
operator|!=
literal|0L
return|;
block|}
DECL|method|tryLock
specifier|public
name|boolean
name|tryLock
parameter_list|(
name|long
name|time
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
return|return
name|tryWriteLock
argument_list|(
name|time
argument_list|,
name|unit
argument_list|)
operator|!=
literal|0L
return|;
block|}
DECL|method|unlock
specifier|public
name|void
name|unlock
parameter_list|()
block|{
name|unstampedUnlockWrite
argument_list|()
expr_stmt|;
block|}
DECL|method|newCondition
specifier|public
name|Condition
name|newCondition
parameter_list|()
block|{
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|()
throw|;
block|}
block|}
DECL|class|ReadWriteLockView
specifier|final
class|class
name|ReadWriteLockView
implements|implements
name|ReadWriteLock
block|{
DECL|method|readLock
specifier|public
name|Lock
name|readLock
parameter_list|()
block|{
return|return
name|asReadLock
argument_list|()
return|;
block|}
DECL|method|writeLock
specifier|public
name|Lock
name|writeLock
parameter_list|()
block|{
return|return
name|asWriteLock
argument_list|()
return|;
block|}
block|}
comment|// Unlock methods without stamp argument checks for view classes.
comment|// Needed because view-class lock methods throw away stamps.
DECL|method|unstampedUnlockWrite
specifier|final
name|void
name|unstampedUnlockWrite
parameter_list|()
block|{
name|WNode
name|h
decl_stmt|;
name|long
name|s
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|WBIT
operator|)
operator|==
literal|0L
condition|)
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
name|state
operator|=
operator|(
name|s
operator|+=
name|WBIT
operator|)
operator|==
literal|0L
condition|?
name|ORIGIN
else|:
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
DECL|method|unstampedUnlockRead
specifier|final
name|void
name|unstampedUnlockRead
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
decl_stmt|,
name|m
decl_stmt|;
name|WNode
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|==
literal|0L
operator|||
name|m
operator|>=
name|WBIT
condition|)
throw|throw
operator|new
name|IllegalMonitorStateException
argument_list|()
throw|;
elseif|else
if|if
condition|(
name|m
operator|<
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|s
operator|-
name|RUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|RUNIT
operator|&&
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|!=
literal|0
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|tryDecReaderOverflow
argument_list|(
name|s
argument_list|)
operator|!=
literal|0L
condition|)
break|break;
block|}
block|}
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
name|state
operator|=
name|ORIGIN
expr_stmt|;
comment|// reset to unlocked state
block|}
comment|// internals
comment|/**      * Tries to increment readerOverflow by first setting state      * access bits value to RBITS, indicating hold of spinlock,      * then updating, then releasing.      *      * @param s a reader overflow stamp: (s& ABITS)>= RFULL      * @return new stamp on success, else zero      */
DECL|method|tryIncReaderOverflow
specifier|private
name|long
name|tryIncReaderOverflow
parameter_list|(
name|long
name|s
parameter_list|)
block|{
comment|// assert (s& ABITS)>= RFULL;
if|if
condition|(
operator|(
name|s
operator|&
name|ABITS
operator|)
operator|==
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|s
operator||
name|RBITS
argument_list|)
condition|)
block|{
operator|++
name|readerOverflow
expr_stmt|;
name|state
operator|=
name|s
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|&
name|OVERFLOW_YIELD_RATE
operator|)
operator|==
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
return|return
literal|0L
return|;
block|}
comment|/**      * Tries to decrement readerOverflow.      *      * @param s a reader overflow stamp: (s& ABITS)>= RFULL      * @return new stamp on success, else zero      */
DECL|method|tryDecReaderOverflow
specifier|private
name|long
name|tryDecReaderOverflow
parameter_list|(
name|long
name|s
parameter_list|)
block|{
comment|// assert (s& ABITS)>= RFULL;
if|if
condition|(
operator|(
name|s
operator|&
name|ABITS
operator|)
operator|==
name|RFULL
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|s
operator||
name|RBITS
argument_list|)
condition|)
block|{
name|int
name|r
decl_stmt|;
name|long
name|next
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|readerOverflow
operator|)
operator|>
literal|0
condition|)
block|{
name|readerOverflow
operator|=
name|r
operator|-
literal|1
expr_stmt|;
name|next
operator|=
name|s
expr_stmt|;
block|}
else|else
name|next
operator|=
name|s
operator|-
name|RUNIT
expr_stmt|;
name|state
operator|=
name|next
expr_stmt|;
return|return
name|next
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|&
name|OVERFLOW_YIELD_RATE
operator|)
operator|==
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
return|return
literal|0L
return|;
block|}
comment|/**      * Wakes up the successor of h (normally whead). This is normally      * just h.next, but may require traversal from wtail if next      * pointers are lagging. This may fail to wake up an acquiring      * thread when one or more have been cancelled, but the cancel      * methods themselves provide extra safeguards to ensure liveness.      */
DECL|method|release
specifier|private
name|void
name|release
parameter_list|(
name|WNode
name|h
parameter_list|)
block|{
if|if
condition|(
name|h
operator|!=
literal|null
condition|)
block|{
name|WNode
name|q
decl_stmt|;
name|Thread
name|w
decl_stmt|;
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|h
argument_list|,
name|WSTATUS
argument_list|,
name|WAITING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|h
operator|.
name|next
operator|)
operator|==
literal|null
operator|||
name|q
operator|.
name|status
operator|==
name|CANCELLED
condition|)
block|{
for|for
control|(
name|WNode
name|t
init|=
name|wtail
init|;
name|t
operator|!=
literal|null
operator|&&
name|t
operator|!=
name|h
condition|;
name|t
operator|=
name|t
operator|.
name|prev
control|)
if|if
condition|(
name|t
operator|.
name|status
operator|<=
literal|0
condition|)
name|q
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|WNode
name|r
init|=
name|q
init|;
condition|;
control|)
block|{
comment|// release co-waiters too
if|if
condition|(
operator|(
name|w
operator|=
name|r
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|r
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|q
operator|.
name|cowait
operator|)
operator|==
literal|null
condition|)
break|break;
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|q
argument_list|,
name|WCOWAIT
argument_list|,
name|r
argument_list|,
name|r
operator|.
name|cowait
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * See above for explanation.      *      * @param interruptible true if should check interrupts and if so      * return INTERRUPTED      * @param deadline if nonzero, the System.nanoTime value to timeout      * at (and return zero)      * @return next state, or INTERRUPTED      */
DECL|method|acquireWrite
specifier|private
name|long
name|acquireWrite
parameter_list|(
name|boolean
name|interruptible
parameter_list|,
name|long
name|deadline
parameter_list|)
block|{
name|WNode
name|node
init|=
literal|null
decl_stmt|,
name|p
decl_stmt|;
for|for
control|(
name|int
name|spins
init|=
operator|-
literal|1
init|;
condition|;
control|)
block|{
comment|// spin while enqueuing
name|long
name|s
decl_stmt|,
name|ns
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|==
literal|0L
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|ns
operator|=
name|s
operator|+
name|WBIT
argument_list|)
condition|)
return|return
name|ns
return|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|>=
literal|0
condition|)
operator|--
name|spins
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|wtail
operator|)
operator|==
literal|null
condition|)
block|{
comment|// initialize queue
name|WNode
name|h
init|=
operator|new
name|WNode
argument_list|(
name|WMODE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WHEAD
argument_list|,
literal|null
argument_list|,
name|h
argument_list|)
condition|)
name|wtail
operator|=
name|h
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|<
literal|0
condition|)
name|spins
operator|=
operator|(
name|p
operator|==
name|whead
operator|)
condition|?
name|SPINS
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|node
operator|=
operator|new
name|WNode
argument_list|(
name|WMODE
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
name|p
condition|)
name|node
operator|.
name|prev
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WTAIL
argument_list|,
name|p
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|p
operator|.
name|next
operator|=
name|node
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|spins
init|=
name|SPINS
init|;
condition|;
control|)
block|{
name|WNode
name|np
decl_stmt|,
name|pp
decl_stmt|;
name|int
name|ps
decl_stmt|;
name|long
name|s
decl_stmt|,
name|ns
decl_stmt|;
name|Thread
name|w
decl_stmt|;
while|while
condition|(
operator|(
name|np
operator|=
name|node
operator|.
name|prev
operator|)
operator|!=
name|p
operator|&&
name|np
operator|!=
literal|null
condition|)
operator|(
name|p
operator|=
name|np
operator|)
operator|.
name|next
operator|=
name|node
expr_stmt|;
comment|// stale
if|if
condition|(
name|whead
operator|==
name|p
condition|)
block|{
for|for
control|(
name|int
name|k
init|=
name|spins
init|;
condition|;
control|)
block|{
comment|// spin at head
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|==
literal|0L
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|ns
operator|=
name|s
operator|+
name|WBIT
argument_list|)
condition|)
block|{
name|whead
operator|=
name|node
expr_stmt|;
name|node
operator|.
name|prev
operator|=
literal|null
expr_stmt|;
return|return
name|ns
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|>=
literal|0
operator|&&
operator|--
name|k
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|spins
operator|<
name|MAX_HEAD_SPINS
condition|)
name|spins
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ps
operator|=
name|p
operator|.
name|status
operator|)
operator|==
literal|0
condition|)
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|p
argument_list|,
name|WSTATUS
argument_list|,
literal|0
argument_list|,
name|WAITING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ps
operator|==
name|CANCELLED
condition|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|p
operator|.
name|prev
operator|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|prev
operator|=
name|pp
expr_stmt|;
name|pp
operator|.
name|next
operator|=
name|node
expr_stmt|;
block|}
block|}
else|else
block|{
name|long
name|time
decl_stmt|;
comment|// 0 argument to park means no timeout
if|if
condition|(
name|deadline
operator|==
literal|0L
condition|)
name|time
operator|=
literal|0L
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|time
operator|=
name|deadline
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|<=
literal|0L
condition|)
return|return
name|cancelWaiter
argument_list|(
name|node
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
return|;
name|Thread
name|wt
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
name|this
argument_list|)
expr_stmt|;
comment|// emulate LockSupport.park
name|node
operator|.
name|thread
operator|=
name|wt
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|prev
operator|==
name|p
operator|&&
name|p
operator|.
name|status
operator|==
name|WAITING
operator|&&
comment|// recheck
operator|(
name|p
operator|!=
name|whead
operator|||
operator|(
name|state
operator|&
name|ABITS
operator|)
operator|!=
literal|0L
operator|)
condition|)
name|U
operator|.
name|park
argument_list|(
literal|false
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|interruptible
operator|&&
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
return|return
name|cancelWaiter
argument_list|(
name|node
argument_list|,
name|node
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * See above for explanation.      *      * @param interruptible true if should check interrupts and if so      * return INTERRUPTED      * @param deadline if nonzero, the System.nanoTime value to timeout      * at (and return zero)      * @return next state, or INTERRUPTED      */
DECL|method|acquireRead
specifier|private
name|long
name|acquireRead
parameter_list|(
name|boolean
name|interruptible
parameter_list|,
name|long
name|deadline
parameter_list|)
block|{
name|WNode
name|node
init|=
literal|null
decl_stmt|,
name|group
init|=
literal|null
decl_stmt|,
name|p
decl_stmt|;
for|for
control|(
name|int
name|spins
init|=
operator|-
literal|1
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
decl_stmt|,
name|m
decl_stmt|,
name|ns
decl_stmt|;
name|WNode
name|h
decl_stmt|,
name|q
decl_stmt|;
name|Thread
name|w
decl_stmt|;
comment|// anti-barging guard
if|if
condition|(
name|group
operator|==
literal|null
operator|&&
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
name|h
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
name|q
operator|.
name|mode
operator|!=
name|RMODE
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|<
name|RFULL
condition|?
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|ns
operator|=
name|s
operator|+
name|RUNIT
argument_list|)
else|:
operator|(
name|m
operator|<
name|WBIT
operator|&&
operator|(
name|ns
operator|=
name|tryIncReaderOverflow
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0L
operator|)
condition|)
block|{
if|if
condition|(
name|group
operator|!=
literal|null
condition|)
block|{
comment|// help release others
for|for
control|(
name|WNode
name|r
init|=
name|group
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|r
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|r
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|group
operator|.
name|cowait
operator|)
operator|==
literal|null
condition|)
break|break;
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|group
argument_list|,
name|WCOWAIT
argument_list|,
name|r
argument_list|,
name|r
operator|.
name|cowait
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ns
return|;
block|}
if|if
condition|(
name|m
operator|>=
name|WBIT
condition|)
break|break;
block|}
if|if
condition|(
name|spins
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|>=
literal|0
condition|)
operator|--
name|spins
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|wtail
operator|)
operator|==
literal|null
condition|)
block|{
name|WNode
name|h
init|=
operator|new
name|WNode
argument_list|(
name|WMODE
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WHEAD
argument_list|,
literal|null
argument_list|,
name|h
argument_list|)
condition|)
name|wtail
operator|=
name|h
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|<
literal|0
condition|)
name|spins
operator|=
operator|(
name|p
operator|==
name|whead
operator|)
condition|?
name|SPINS
else|:
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|==
literal|null
condition|)
name|node
operator|=
operator|new
name|WNode
argument_list|(
name|WMODE
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|.
name|prev
operator|!=
name|p
condition|)
name|node
operator|.
name|prev
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|mode
operator|==
name|RMODE
operator|&&
name|p
operator|!=
name|whead
condition|)
block|{
name|WNode
name|pp
init|=
name|p
operator|.
name|prev
decl_stmt|;
comment|// become co-waiter with group p
if|if
condition|(
name|pp
operator|!=
literal|null
operator|&&
name|p
operator|==
name|wtail
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|p
argument_list|,
name|WCOWAIT
argument_list|,
name|node
operator|.
name|cowait
operator|=
name|p
operator|.
name|cowait
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|node
operator|.
name|thread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
for|for
control|(
name|long
name|time
init|;
condition|;
control|)
block|{
if|if
condition|(
name|deadline
operator|==
literal|0L
condition|)
name|time
operator|=
literal|0L
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|time
operator|=
name|deadline
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|<=
literal|0L
condition|)
return|return
name|cancelWaiter
argument_list|(
name|node
argument_list|,
name|p
argument_list|,
literal|false
argument_list|)
return|;
if|if
condition|(
name|node
operator|.
name|thread
operator|==
literal|null
condition|)
break|break;
if|if
condition|(
name|p
operator|.
name|prev
operator|!=
name|pp
operator|||
name|p
operator|.
name|status
operator|==
name|CANCELLED
operator|||
name|p
operator|==
name|whead
operator|||
name|p
operator|.
name|prev
operator|!=
name|pp
condition|)
block|{
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
break|break;
block|}
name|Thread
name|wt
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|thread
operator|==
literal|null
condition|)
comment|// must recheck
break|break;
name|U
operator|.
name|park
argument_list|(
literal|false
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|interruptible
operator|&&
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
return|return
name|cancelWaiter
argument_list|(
name|node
argument_list|,
name|p
argument_list|,
literal|true
argument_list|)
return|;
block|}
name|group
operator|=
name|p
expr_stmt|;
block|}
name|node
operator|=
literal|null
expr_stmt|;
comment|// throw away
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WTAIL
argument_list|,
name|p
argument_list|,
name|node
argument_list|)
condition|)
block|{
name|p
operator|.
name|next
operator|=
name|node
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|int
name|spins
init|=
name|SPINS
init|;
condition|;
control|)
block|{
name|WNode
name|np
decl_stmt|,
name|pp
decl_stmt|,
name|r
decl_stmt|;
name|int
name|ps
decl_stmt|;
name|long
name|m
decl_stmt|,
name|s
decl_stmt|,
name|ns
decl_stmt|;
name|Thread
name|w
decl_stmt|;
while|while
condition|(
operator|(
name|np
operator|=
name|node
operator|.
name|prev
operator|)
operator|!=
name|p
operator|&&
name|np
operator|!=
literal|null
condition|)
operator|(
name|p
operator|=
name|np
operator|)
operator|.
name|next
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|whead
operator|==
name|p
condition|)
block|{
for|for
control|(
name|int
name|k
init|=
name|spins
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|!=
name|WBIT
condition|)
block|{
if|if
condition|(
name|m
operator|<
name|RFULL
condition|?
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STATE
argument_list|,
name|s
argument_list|,
name|ns
operator|=
name|s
operator|+
name|RUNIT
argument_list|)
else|:
operator|(
name|ns
operator|=
name|tryIncReaderOverflow
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
literal|0L
condition|)
block|{
name|whead
operator|=
name|node
expr_stmt|;
name|node
operator|.
name|prev
operator|=
literal|null
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|node
operator|.
name|cowait
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|node
argument_list|,
name|WCOWAIT
argument_list|,
name|r
argument_list|,
name|r
operator|.
name|cowait
argument_list|)
operator|&&
operator|(
name|w
operator|=
name|r
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|r
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|// release co-waiter
block|}
block|}
return|return
name|ns
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
operator|.
name|nextInt
argument_list|()
operator|>=
literal|0
operator|&&
operator|--
name|k
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|spins
operator|<
name|MAX_HEAD_SPINS
condition|)
name|spins
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ps
operator|=
name|p
operator|.
name|status
operator|)
operator|==
literal|0
condition|)
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|p
argument_list|,
name|WSTATUS
argument_list|,
literal|0
argument_list|,
name|WAITING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ps
operator|==
name|CANCELLED
condition|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|p
operator|.
name|prev
operator|)
operator|!=
literal|null
condition|)
block|{
name|node
operator|.
name|prev
operator|=
name|pp
expr_stmt|;
name|pp
operator|.
name|next
operator|=
name|node
expr_stmt|;
block|}
block|}
else|else
block|{
name|long
name|time
decl_stmt|;
if|if
condition|(
name|deadline
operator|==
literal|0L
condition|)
name|time
operator|=
literal|0L
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|time
operator|=
name|deadline
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|)
operator|<=
literal|0L
condition|)
return|return
name|cancelWaiter
argument_list|(
name|node
argument_list|,
name|node
argument_list|,
literal|false
argument_list|)
return|;
name|Thread
name|wt
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|node
operator|.
name|thread
operator|=
name|wt
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|prev
operator|==
name|p
operator|&&
name|p
operator|.
name|status
operator|==
name|WAITING
operator|&&
operator|(
name|p
operator|!=
name|whead
operator|||
operator|(
name|state
operator|&
name|ABITS
operator|)
operator|!=
name|WBIT
operator|)
condition|)
name|U
operator|.
name|park
argument_list|(
literal|false
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|interruptible
operator|&&
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
return|return
name|cancelWaiter
argument_list|(
name|node
argument_list|,
name|node
argument_list|,
literal|true
argument_list|)
return|;
block|}
block|}
block|}
comment|/**      * If node non-null, forces cancel status and unsplices it from      * queue if possible and wakes up any cowaiters (of the node, or      * group, as applicable), and in any case helps release current      * first waiter if lock is free. (Calling with null arguments      * serves as a conditional form of release, which is not currently      * needed but may be needed under possible future cancellation      * policies). This is a variant of cancellation methods in      * AbstractQueuedSynchronizer (see its detailed explanation in AQS      * internal documentation).      *      * @param node if nonnull, the waiter      * @param group either node or the group node is cowaiting with      * @param interrupted if already interrupted      * @return INTERRUPTED if interrupted or Thread.interrupted, else zero      */
DECL|method|cancelWaiter
specifier|private
name|long
name|cancelWaiter
parameter_list|(
name|WNode
name|node
parameter_list|,
name|WNode
name|group
parameter_list|,
name|boolean
name|interrupted
parameter_list|)
block|{
if|if
condition|(
name|node
operator|!=
literal|null
operator|&&
name|group
operator|!=
literal|null
condition|)
block|{
name|Thread
name|w
decl_stmt|;
name|node
operator|.
name|status
operator|=
name|CANCELLED
expr_stmt|;
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
comment|// unsplice cancelled nodes from group
for|for
control|(
name|WNode
name|p
init|=
name|group
init|,
name|q
init|;
operator|(
name|q
operator|=
name|p
operator|.
name|cowait
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
name|q
operator|.
name|status
operator|==
name|CANCELLED
condition|)
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|p
argument_list|,
name|WNEXT
argument_list|,
name|q
argument_list|,
name|q
operator|.
name|next
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|==
name|node
condition|)
block|{
name|WNode
name|r
decl_stmt|;
comment|// detach and wake up uncancelled co-waiters
while|while
condition|(
operator|(
name|r
operator|=
name|node
operator|.
name|cowait
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|node
argument_list|,
name|WCOWAIT
argument_list|,
name|r
argument_list|,
name|r
operator|.
name|cowait
argument_list|)
operator|&&
operator|(
name|w
operator|=
name|r
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|r
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|WNode
name|pred
init|=
name|node
operator|.
name|prev
init|;
name|pred
operator|!=
literal|null
condition|;
control|)
block|{
comment|// unsplice
name|WNode
name|succ
decl_stmt|,
name|pp
decl_stmt|;
comment|// find valid successor
while|while
condition|(
operator|(
name|succ
operator|=
name|node
operator|.
name|next
operator|)
operator|==
literal|null
operator|||
name|succ
operator|.
name|status
operator|==
name|CANCELLED
condition|)
block|{
name|WNode
name|q
init|=
literal|null
decl_stmt|;
comment|// find successor the slow way
for|for
control|(
name|WNode
name|t
init|=
name|wtail
init|;
name|t
operator|!=
literal|null
operator|&&
name|t
operator|!=
name|node
condition|;
name|t
operator|=
name|t
operator|.
name|prev
control|)
if|if
condition|(
name|t
operator|.
name|status
operator|!=
name|CANCELLED
condition|)
name|q
operator|=
name|t
expr_stmt|;
comment|// don't link if succ cancelled
if|if
condition|(
name|succ
operator|==
name|q
operator|||
comment|// ensure accurate successor
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|node
argument_list|,
name|WNEXT
argument_list|,
name|succ
argument_list|,
name|succ
operator|=
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|succ
operator|==
literal|null
operator|&&
name|node
operator|==
name|wtail
condition|)
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|WTAIL
argument_list|,
name|node
argument_list|,
name|pred
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pred
operator|.
name|next
operator|==
name|node
condition|)
comment|// unsplice pred link
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|pred
argument_list|,
name|WNEXT
argument_list|,
name|node
argument_list|,
name|succ
argument_list|)
expr_stmt|;
if|if
condition|(
name|succ
operator|!=
literal|null
operator|&&
operator|(
name|w
operator|=
name|succ
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|succ
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|unpark
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|// wake up succ to observe new pred
block|}
if|if
condition|(
name|pred
operator|.
name|status
operator|!=
name|CANCELLED
operator|||
operator|(
name|pp
operator|=
name|pred
operator|.
name|prev
operator|)
operator|==
literal|null
condition|)
break|break;
name|node
operator|.
name|prev
operator|=
name|pp
expr_stmt|;
comment|// repeat if new pred wrong/cancelled
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|pp
argument_list|,
name|WNEXT
argument_list|,
name|pred
argument_list|,
name|succ
argument_list|)
expr_stmt|;
name|pred
operator|=
name|pp
expr_stmt|;
block|}
block|}
block|}
name|WNode
name|h
decl_stmt|;
comment|// Possibly release first waiter
while|while
condition|(
operator|(
name|h
operator|=
name|whead
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|s
decl_stmt|;
name|WNode
name|q
decl_stmt|;
comment|// similar to release() but check eligibility
if|if
condition|(
operator|(
name|q
operator|=
name|h
operator|.
name|next
operator|)
operator|==
literal|null
operator|||
name|q
operator|.
name|status
operator|==
name|CANCELLED
condition|)
block|{
for|for
control|(
name|WNode
name|t
init|=
name|wtail
init|;
name|t
operator|!=
literal|null
operator|&&
name|t
operator|!=
name|h
condition|;
name|t
operator|=
name|t
operator|.
name|prev
control|)
if|if
condition|(
name|t
operator|.
name|status
operator|<=
literal|0
condition|)
name|q
operator|=
name|t
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|==
name|whead
condition|)
block|{
if|if
condition|(
name|q
operator|!=
literal|null
operator|&&
name|h
operator|.
name|status
operator|==
literal|0
operator|&&
operator|(
operator|(
name|s
operator|=
name|state
operator|)
operator|&
name|ABITS
operator|)
operator|!=
name|WBIT
operator|&&
comment|// waiter is eligible
operator|(
name|s
operator|==
literal|0L
operator|||
name|q
operator|.
name|mode
operator|==
name|RMODE
operator|)
condition|)
name|release
argument_list|(
name|h
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|interrupted
operator|||
name|Thread
operator|.
name|interrupted
argument_list|()
operator|)
condition|?
name|INTERRUPTED
else|:
literal|0L
return|;
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|STATE
specifier|private
specifier|static
specifier|final
name|long
name|STATE
decl_stmt|;
DECL|field|WHEAD
specifier|private
specifier|static
specifier|final
name|long
name|WHEAD
decl_stmt|;
DECL|field|WTAIL
specifier|private
specifier|static
specifier|final
name|long
name|WTAIL
decl_stmt|;
DECL|field|WNEXT
specifier|private
specifier|static
specifier|final
name|long
name|WNEXT
decl_stmt|;
DECL|field|WSTATUS
specifier|private
specifier|static
specifier|final
name|long
name|WSTATUS
decl_stmt|;
DECL|field|WCOWAIT
specifier|private
specifier|static
specifier|final
name|long
name|WCOWAIT
decl_stmt|;
DECL|field|PARKBLOCKER
specifier|private
specifier|static
specifier|final
name|long
name|PARKBLOCKER
decl_stmt|;
static|static
block|{
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|StampedLock
operator|.
name|class
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|wk
init|=
name|WNode
operator|.
name|class
decl_stmt|;
name|STATE
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"state"
argument_list|)
argument_list|)
expr_stmt|;
name|WHEAD
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"whead"
argument_list|)
argument_list|)
expr_stmt|;
name|WTAIL
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"wtail"
argument_list|)
argument_list|)
expr_stmt|;
name|WSTATUS
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|wk
operator|.
name|getDeclaredField
argument_list|(
literal|"status"
argument_list|)
argument_list|)
expr_stmt|;
name|WNEXT
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|wk
operator|.
name|getDeclaredField
argument_list|(
literal|"next"
argument_list|)
argument_list|)
expr_stmt|;
name|WCOWAIT
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|wk
operator|.
name|getDeclaredField
argument_list|(
literal|"cowait"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|tk
init|=
name|Thread
operator|.
name|class
decl_stmt|;
name|PARKBLOCKER
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|tk
operator|.
name|getDeclaredField
argument_list|(
literal|"parkBlocker"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

