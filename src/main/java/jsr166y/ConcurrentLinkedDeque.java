begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea and Martin Buchholz with assistance from members of  * JCP JSR-166 Expert Group and released to the public domain, as explained  * at http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166y
package|package
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractCollection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Deque
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_comment
comment|/**  * An unbounded concurrent {@linkplain Deque deque} based on linked nodes.  * Concurrent insertion, removal, and access operations execute safely  * across multiple threads.  * A {@code ConcurrentLinkedDeque} is an appropriate choice when  * many threads will share access to a common collection.  * Like most other concurrent collection implementations, this class  * does not permit the use of {@code null} elements.  *  *<p>Iterators are<i>weakly consistent</i>, returning elements  * reflecting the state of the deque at some point at or since the  * creation of the iterator.  They do<em>not</em> throw {@link  * java.util.ConcurrentModificationException  * ConcurrentModificationException}, and may proceed concurrently with  * other operations.  *  *<p>Beware that, unlike in most collections, the {@code size} method  * is<em>NOT</em> a constant-time operation. Because of the  * asynchronous nature of these deques, determining the current number  * of elements requires a traversal of the elements, and so may report  * inaccurate results if this collection is modified during traversal.  * Additionally, the bulk operations {@code addAll},  * {@code removeAll}, {@code retainAll}, {@code containsAll},  * {@code equals}, and {@code toArray} are<em>not</em> guaranteed  * to be performed atomically. For example, an iterator operating  * concurrently with an {@code addAll} operation might view only some  * of the added elements.  *  *<p>This class and its iterator implement all of the<em>optional</em>  * methods of the {@link Deque} and {@link Iterator} interfaces.  *  *<p>Memory consistency effects: As with other concurrent collections,  * actions in a thread prior to placing an object into a  * {@code ConcurrentLinkedDeque}  *<a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>  * actions subsequent to the access or removal of that element from  * the {@code ConcurrentLinkedDeque} in another thread.  *  *<p>This class is a member of the  *<a href="{@docRoot}/../technotes/guides/collections/index.html">  * Java Collections Framework</a>.  *  * @since 1.7  * @author Doug Lea  * @author Martin Buchholz  * @param<E> the type of elements held in this collection  */
end_comment

begin_class
DECL|class|ConcurrentLinkedDeque
specifier|public
class|class
name|ConcurrentLinkedDeque
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractCollection
argument_list|<
name|E
argument_list|>
implements|implements
name|Deque
argument_list|<
name|E
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
comment|/*      * This is an implementation of a concurrent lock-free deque      * supporting interior removes but not interior insertions, as      * required to support the entire Deque interface.      *      * We extend the techniques developed for ConcurrentLinkedQueue and      * LinkedTransferQueue (see the internal docs for those classes).      * Understanding the ConcurrentLinkedQueue implementation is a      * prerequisite for understanding the implementation of this class.      *      * The data structure is a symmetrical doubly-linked "GC-robust"      * linked list of nodes.  We minimize the number of volatile writes      * using two techniques: advancing multiple hops with a single CAS      * and mixing volatile and non-volatile writes of the same memory      * locations.      *      * A node contains the expected E ("item") and links to predecessor      * ("prev") and successor ("next") nodes:      *      * class Node<E> { volatile Node<E> prev, next; volatile E item; }      *      * A node p is considered "live" if it contains a non-null item      * (p.item != null).  When an item is CASed to null, the item is      * atomically logically deleted from the collection.      *      * At any time, there is precisely one "first" node with a null      * prev reference that terminates any chain of prev references      * starting at a live node.  Similarly there is precisely one      * "last" node terminating any chain of next references starting at      * a live node.  The "first" and "last" nodes may or may not be live.      * The "first" and "last" nodes are always mutually reachable.      *      * A new element is added atomically by CASing the null prev or      * next reference in the first or last node to a fresh node      * containing the element.  The element's node atomically becomes      * "live" at that point.      *      * A node is considered "active" if it is a live node, or the      * first or last node.  Active nodes cannot be unlinked.      *      * A "self-link" is a next or prev reference that is the same node:      *   p.prev == p  or  p.next == p      * Self-links are used in the node unlinking process.  Active nodes      * never have self-links.      *      * A node p is active if and only if:      *      * p.item != null ||      * (p.prev == null&& p.next != p) ||      * (p.next == null&& p.prev != p)      *      * The deque object has two node references, "head" and "tail".      * The head and tail are only approximations to the first and last      * nodes of the deque.  The first node can always be found by      * following prev pointers from head; likewise for tail.  However,      * it is permissible for head and tail to be referring to deleted      * nodes that have been unlinked and so may not be reachable from      * any live node.      *      * There are 3 stages of node deletion;      * "logical deletion", "unlinking", and "gc-unlinking".      *      * 1. "logical deletion" by CASing item to null atomically removes      * the element from the collection, and makes the containing node      * eligible for unlinking.      *      * 2. "unlinking" makes a deleted node unreachable from active      * nodes, and thus eventually reclaimable by GC.  Unlinked nodes      * may remain reachable indefinitely from an iterator.      *      * Physical node unlinking is merely an optimization (albeit a      * critical one), and so can be performed at our convenience.  At      * any time, the set of live nodes maintained by prev and next      * links are identical, that is, the live nodes found via next      * links from the first node is equal to the elements found via      * prev links from the last node.  However, this is not true for      * nodes that have already been logically deleted - such nodes may      * be reachable in one direction only.      *      * 3. "gc-unlinking" takes unlinking further by making active      * nodes unreachable from deleted nodes, making it easier for the      * GC to reclaim future deleted nodes.  This step makes the data      * structure "gc-robust", as first described in detail by Boehm      * (http://portal.acm.org/citation.cfm?doid=503272.503282).      *      * GC-unlinked nodes may remain reachable indefinitely from an      * iterator, but unlike unlinked nodes, are never reachable from      * head or tail.      *      * Making the data structure GC-robust will eliminate the risk of      * unbounded memory retention with conservative GCs and is likely      * to improve performance with generational GCs.      *      * When a node is dequeued at either end, e.g. via poll(), we would      * like to break any references from the node to active nodes.  We      * develop further the use of self-links that was very effective in      * other concurrent collection classes.  The idea is to replace      * prev and next pointers with special values that are interpreted      * to mean off-the-list-at-one-end.  These are approximations, but      * good enough to preserve the properties we want in our      * traversals, e.g. we guarantee that a traversal will never visit      * the same element twice, but we don't guarantee whether a      * traversal that runs out of elements will be able to see more      * elements later after enqueues at that end.  Doing gc-unlinking      * safely is particularly tricky, since any node can be in use      * indefinitely (for example by an iterator).  We must ensure that      * the nodes pointed at by head/tail never get gc-unlinked, since      * head/tail are needed to get "back on track" by other nodes that      * are gc-unlinked.  gc-unlinking accounts for much of the      * implementation complexity.      *      * Since neither unlinking nor gc-unlinking are necessary for      * correctness, there are many implementation choices regarding      * frequency (eagerness) of these operations.  Since volatile      * reads are likely to be much cheaper than CASes, saving CASes by      * unlinking multiple adjacent nodes at a time may be a win.      * gc-unlinking can be performed rarely and still be effective,      * since it is most important that long chains of deleted nodes      * are occasionally broken.      *      * The actual representation we use is that p.next == p means to      * goto the first node (which in turn is reached by following prev      * pointers from head), and p.next == null&& p.prev == p means      * that the iteration is at an end and that p is a (static final)      * dummy node, NEXT_TERMINATOR, and not the last active node.      * Finishing the iteration when encountering such a TERMINATOR is      * good enough for read-only traversals, so such traversals can use      * p.next == null as the termination condition.  When we need to      * find the last (active) node, for enqueueing a new node, we need      * to check whether we have reached a TERMINATOR node; if so,      * restart traversal from tail.      *      * The implementation is completely directionally symmetrical,      * except that most public methods that iterate through the list      * follow next pointers ("forward" direction).      *      * We believe (without full proof) that all single-element deque      * operations (e.g., addFirst, peekLast, pollLast) are linearizable      * (see Herlihy and Shavit's book).  However, some combinations of      * operations are known not to be linearizable.  In particular,      * when an addFirst(A) is racing with pollFirst() removing B, it is      * possible for an observer iterating over the elements to observe      * A B C and subsequently observe A C, even though no interior      * removes are ever performed.  Nevertheless, iterators behave      * reasonably, providing the "weakly consistent" guarantees.      *      * Empirically, microbenchmarks suggest that this class adds about      * 40% overhead relative to ConcurrentLinkedQueue, which feels as      * good as we can hope for.      */
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|876323262645176354L
decl_stmt|;
comment|/**      * A node from which the first node on list (that is, the unique node p      * with p.prev == null&& p.next != p) can be reached in O(1) time.      * Invariants:      * - the first node is always O(1) reachable from head via prev links      * - all live nodes are reachable from the first node via succ()      * - head != null      * - (tmp = head).next != tmp || tmp != head      * - head is never gc-unlinked (but may be unlinked)      * Non-invariants:      * - head.item may or may not be null      * - head may not be reachable from the first or last node, or from tail      */
DECL|field|head
specifier|private
specifier|transient
specifier|volatile
name|Node
argument_list|<
name|E
argument_list|>
name|head
decl_stmt|;
comment|/**      * A node from which the last node on list (that is, the unique node p      * with p.next == null&& p.prev != p) can be reached in O(1) time.      * Invariants:      * - the last node is always O(1) reachable from tail via next links      * - all live nodes are reachable from the last node via pred()      * - tail != null      * - tail is never gc-unlinked (but may be unlinked)      * Non-invariants:      * - tail.item may or may not be null      * - tail may not be reachable from the first or last node, or from head      */
DECL|field|tail
specifier|private
specifier|transient
specifier|volatile
name|Node
argument_list|<
name|E
argument_list|>
name|tail
decl_stmt|;
DECL|field|PREV_TERMINATOR
DECL|field|NEXT_TERMINATOR
specifier|private
specifier|static
specifier|final
name|Node
argument_list|<
name|Object
argument_list|>
name|PREV_TERMINATOR
decl_stmt|,
name|NEXT_TERMINATOR
decl_stmt|;
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|prevTerminator
name|Node
argument_list|<
name|E
argument_list|>
name|prevTerminator
parameter_list|()
block|{
return|return
operator|(
name|Node
argument_list|<
name|E
argument_list|>
operator|)
name|PREV_TERMINATOR
return|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|nextTerminator
name|Node
argument_list|<
name|E
argument_list|>
name|nextTerminator
parameter_list|()
block|{
return|return
operator|(
name|Node
argument_list|<
name|E
argument_list|>
operator|)
name|NEXT_TERMINATOR
return|;
block|}
DECL|class|Node
specifier|static
specifier|final
class|class
name|Node
parameter_list|<
name|E
parameter_list|>
block|{
DECL|field|prev
specifier|volatile
name|Node
argument_list|<
name|E
argument_list|>
name|prev
decl_stmt|;
DECL|field|item
specifier|volatile
name|E
name|item
decl_stmt|;
DECL|field|next
specifier|volatile
name|Node
argument_list|<
name|E
argument_list|>
name|next
decl_stmt|;
DECL|method|Node
name|Node
parameter_list|()
block|{
comment|// default constructor for NEXT_TERMINATOR, PREV_TERMINATOR
block|}
comment|/**          * Constructs a new node.  Uses relaxed write because item can          * only be seen after publication via casNext or casPrev.          */
DECL|method|Node
name|Node
parameter_list|(
name|E
name|item
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|this
argument_list|,
name|itemOffset
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
DECL|method|casItem
name|boolean
name|casItem
parameter_list|(
name|E
name|cmp
parameter_list|,
name|E
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|itemOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|lazySetNext
name|void
name|lazySetNext
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|val
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putOrderedObject
argument_list|(
name|this
argument_list|,
name|nextOffset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|casNext
name|boolean
name|casNext
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|cmp
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|nextOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|lazySetPrev
name|void
name|lazySetPrev
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|val
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putOrderedObject
argument_list|(
name|this
argument_list|,
name|prevOffset
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
DECL|method|casPrev
name|boolean
name|casPrev
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|cmp
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|prevOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|prevOffset
specifier|private
specifier|static
specifier|final
name|long
name|prevOffset
decl_stmt|;
DECL|field|itemOffset
specifier|private
specifier|static
specifier|final
name|long
name|itemOffset
decl_stmt|;
DECL|field|nextOffset
specifier|private
specifier|static
specifier|final
name|long
name|nextOffset
decl_stmt|;
static|static
block|{
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|Node
operator|.
name|class
decl_stmt|;
name|prevOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"prev"
argument_list|)
argument_list|)
expr_stmt|;
name|itemOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"item"
argument_list|)
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"next"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/**      * Links e as first element.      */
DECL|method|linkFirst
specifier|private
name|void
name|linkFirst
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|e
argument_list|)
expr_stmt|;
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|restartFromHead
label|:
for|for
control|(
init|;
condition|;
control|)
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|h
init|=
name|head
init|,
name|p
init|=
name|h
init|,
name|q
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|.
name|prev
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
operator|(
name|p
operator|=
name|q
operator|)
operator|.
name|prev
operator|)
operator|!=
literal|null
condition|)
comment|// Check for head updates every other hop.
comment|// If p == q, we are sure to follow head instead.
name|p
operator|=
operator|(
name|h
operator|!=
operator|(
name|h
operator|=
name|head
operator|)
operator|)
condition|?
name|h
else|:
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|next
operator|==
name|p
condition|)
comment|// PREV_TERMINATOR
continue|continue
name|restartFromHead
continue|;
else|else
block|{
comment|// p is first node
name|newNode
operator|.
name|lazySetNext
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// CAS piggyback
if|if
condition|(
name|p
operator|.
name|casPrev
argument_list|(
literal|null
argument_list|,
name|newNode
argument_list|)
condition|)
block|{
comment|// Successful CAS is the linearization point
comment|// for e to become an element of this deque,
comment|// and for newNode to become "live".
if|if
condition|(
name|p
operator|!=
name|h
condition|)
comment|// hop two nodes at a time
name|casHead
argument_list|(
name|h
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
comment|// Failure is OK.
return|return;
block|}
comment|// Lost CAS race to another thread; re-read prev
block|}
block|}
block|}
comment|/**      * Links e as last element.      */
DECL|method|linkLast
specifier|private
name|void
name|linkLast
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|e
argument_list|)
expr_stmt|;
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|restartFromTail
label|:
for|for
control|(
init|;
condition|;
control|)
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|t
init|=
name|tail
init|,
name|p
init|=
name|t
init|,
name|q
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
operator|(
name|p
operator|=
name|q
operator|)
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
comment|// Check for tail updates every other hop.
comment|// If p == q, we are sure to follow tail instead.
name|p
operator|=
operator|(
name|t
operator|!=
operator|(
name|t
operator|=
name|tail
operator|)
operator|)
condition|?
name|t
else|:
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|prev
operator|==
name|p
condition|)
comment|// NEXT_TERMINATOR
continue|continue
name|restartFromTail
continue|;
else|else
block|{
comment|// p is last node
name|newNode
operator|.
name|lazySetPrev
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// CAS piggyback
if|if
condition|(
name|p
operator|.
name|casNext
argument_list|(
literal|null
argument_list|,
name|newNode
argument_list|)
condition|)
block|{
comment|// Successful CAS is the linearization point
comment|// for e to become an element of this deque,
comment|// and for newNode to become "live".
if|if
condition|(
name|p
operator|!=
name|t
condition|)
comment|// hop two nodes at a time
name|casTail
argument_list|(
name|t
argument_list|,
name|newNode
argument_list|)
expr_stmt|;
comment|// Failure is OK.
return|return;
block|}
comment|// Lost CAS race to another thread; re-read next
block|}
block|}
block|}
DECL|field|HOPS
specifier|private
specifier|static
specifier|final
name|int
name|HOPS
init|=
literal|2
decl_stmt|;
comment|/**      * Unlinks non-null node x.      */
DECL|method|unlink
name|void
name|unlink
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|x
parameter_list|)
block|{
comment|// assert x != null;
comment|// assert x.item == null;
comment|// assert x != PREV_TERMINATOR;
comment|// assert x != NEXT_TERMINATOR;
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|prev
init|=
name|x
operator|.
name|prev
decl_stmt|;
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|next
init|=
name|x
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|prev
operator|==
literal|null
condition|)
block|{
name|unlinkFirst
argument_list|(
name|x
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
operator|==
literal|null
condition|)
block|{
name|unlinkLast
argument_list|(
name|x
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Unlink interior node.
comment|//
comment|// This is the common case, since a series of polls at the
comment|// same end will be "interior" removes, except perhaps for
comment|// the first one, since end nodes cannot be unlinked.
comment|//
comment|// At any time, all active nodes are mutually reachable by
comment|// following a sequence of either next or prev pointers.
comment|//
comment|// Our strategy is to find the unique active predecessor
comment|// and successor of x.  Try to fix up their links so that
comment|// they point to each other, leaving x unreachable from
comment|// active nodes.  If successful, and if x has no live
comment|// predecessor/successor, we additionally try to gc-unlink,
comment|// leaving active nodes unreachable from x, by rechecking
comment|// that the status of predecessor and successor are
comment|// unchanged and ensuring that x is not reachable from
comment|// tail/head, before setting x's prev/next links to their
comment|// logical approximate replacements, self/TERMINATOR.
name|Node
argument_list|<
name|E
argument_list|>
name|activePred
decl_stmt|,
name|activeSucc
decl_stmt|;
name|boolean
name|isFirst
decl_stmt|,
name|isLast
decl_stmt|;
name|int
name|hops
init|=
literal|1
decl_stmt|;
comment|// Find active predecessor
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|prev
init|;
condition|;
operator|++
name|hops
control|)
block|{
if|if
condition|(
name|p
operator|.
name|item
operator|!=
literal|null
condition|)
block|{
name|activePred
operator|=
name|p
expr_stmt|;
name|isFirst
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|Node
argument_list|<
name|E
argument_list|>
name|q
init|=
name|p
operator|.
name|prev
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|next
operator|==
name|p
condition|)
return|return;
name|activePred
operator|=
name|p
expr_stmt|;
name|isFirst
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|q
condition|)
return|return;
else|else
name|p
operator|=
name|q
expr_stmt|;
block|}
comment|// Find active successor
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|next
init|;
condition|;
operator|++
name|hops
control|)
block|{
if|if
condition|(
name|p
operator|.
name|item
operator|!=
literal|null
condition|)
block|{
name|activeSucc
operator|=
name|p
expr_stmt|;
name|isLast
operator|=
literal|false
expr_stmt|;
break|break;
block|}
name|Node
argument_list|<
name|E
argument_list|>
name|q
init|=
name|p
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|prev
operator|==
name|p
condition|)
return|return;
name|activeSucc
operator|=
name|p
expr_stmt|;
name|isLast
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|q
condition|)
return|return;
else|else
name|p
operator|=
name|q
expr_stmt|;
block|}
comment|// TODO: better HOP heuristics
if|if
condition|(
name|hops
operator|<
name|HOPS
comment|// always squeeze out interior deleted nodes
operator|&&
operator|(
name|isFirst
operator||
name|isLast
operator|)
condition|)
return|return;
comment|// Squeeze out deleted nodes between activePred and
comment|// activeSucc, including x.
name|skipDeletedSuccessors
argument_list|(
name|activePred
argument_list|)
expr_stmt|;
name|skipDeletedPredecessors
argument_list|(
name|activeSucc
argument_list|)
expr_stmt|;
comment|// Try to gc-unlink, if possible
if|if
condition|(
operator|(
name|isFirst
operator||
name|isLast
operator|)
operator|&&
comment|// Recheck expected state of predecessor and successor
operator|(
name|activePred
operator|.
name|next
operator|==
name|activeSucc
operator|)
operator|&&
operator|(
name|activeSucc
operator|.
name|prev
operator|==
name|activePred
operator|)
operator|&&
operator|(
name|isFirst
condition|?
name|activePred
operator|.
name|prev
operator|==
literal|null
else|:
name|activePred
operator|.
name|item
operator|!=
literal|null
operator|)
operator|&&
operator|(
name|isLast
condition|?
name|activeSucc
operator|.
name|next
operator|==
literal|null
else|:
name|activeSucc
operator|.
name|item
operator|!=
literal|null
operator|)
condition|)
block|{
name|updateHead
argument_list|()
expr_stmt|;
comment|// Ensure x is not reachable from head
name|updateTail
argument_list|()
expr_stmt|;
comment|// Ensure x is not reachable from tail
comment|// Finally, actually gc-unlink
name|x
operator|.
name|lazySetPrev
argument_list|(
name|isFirst
condition|?
name|prevTerminator
argument_list|()
else|:
name|x
argument_list|)
expr_stmt|;
name|x
operator|.
name|lazySetNext
argument_list|(
name|isLast
condition|?
name|nextTerminator
argument_list|()
else|:
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Unlinks non-null first node.      */
DECL|method|unlinkFirst
specifier|private
name|void
name|unlinkFirst
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|first
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|next
parameter_list|)
block|{
comment|// assert first != null;
comment|// assert next != null;
comment|// assert first.item == null;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|o
init|=
literal|null
init|,
name|p
init|=
name|next
init|,
name|q
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|.
name|item
operator|!=
literal|null
operator|||
operator|(
name|q
operator|=
name|p
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
operator|&&
name|p
operator|.
name|prev
operator|!=
name|p
operator|&&
name|first
operator|.
name|casNext
argument_list|(
name|next
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|skipDeletedPredecessors
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|.
name|prev
operator|==
literal|null
operator|&&
operator|(
name|p
operator|.
name|next
operator|==
literal|null
operator|||
name|p
operator|.
name|item
operator|!=
literal|null
operator|)
operator|&&
name|p
operator|.
name|prev
operator|==
name|first
condition|)
block|{
name|updateHead
argument_list|()
expr_stmt|;
comment|// Ensure o is not reachable from head
name|updateTail
argument_list|()
expr_stmt|;
comment|// Ensure o is not reachable from tail
comment|// Finally, actually gc-unlink
name|o
operator|.
name|lazySetNext
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|lazySetPrev
argument_list|(
name|prevTerminator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|q
condition|)
return|return;
else|else
block|{
name|o
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Unlinks non-null last node.      */
DECL|method|unlinkLast
specifier|private
name|void
name|unlinkLast
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|last
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|prev
parameter_list|)
block|{
comment|// assert last != null;
comment|// assert prev != null;
comment|// assert last.item == null;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|o
init|=
literal|null
init|,
name|p
init|=
name|prev
init|,
name|q
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|.
name|item
operator|!=
literal|null
operator|||
operator|(
name|q
operator|=
name|p
operator|.
name|prev
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|o
operator|!=
literal|null
operator|&&
name|p
operator|.
name|next
operator|!=
name|p
operator|&&
name|last
operator|.
name|casPrev
argument_list|(
name|prev
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|skipDeletedSuccessors
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|.
name|next
operator|==
literal|null
operator|&&
operator|(
name|p
operator|.
name|prev
operator|==
literal|null
operator|||
name|p
operator|.
name|item
operator|!=
literal|null
operator|)
operator|&&
name|p
operator|.
name|next
operator|==
name|last
condition|)
block|{
name|updateHead
argument_list|()
expr_stmt|;
comment|// Ensure o is not reachable from head
name|updateTail
argument_list|()
expr_stmt|;
comment|// Ensure o is not reachable from tail
comment|// Finally, actually gc-unlink
name|o
operator|.
name|lazySetPrev
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|o
operator|.
name|lazySetNext
argument_list|(
name|nextTerminator
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|q
condition|)
return|return;
else|else
block|{
name|o
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Guarantees that any node which was unlinked before a call to      * this method will be unreachable from head after it returns.      * Does not guarantee to eliminate slack, only that head will      * point to a node that was active while this method was running.      */
DECL|method|updateHead
specifier|private
specifier|final
name|void
name|updateHead
parameter_list|()
block|{
comment|// Either head already points to an active node, or we keep
comment|// trying to cas it to the first node until it does.
name|Node
argument_list|<
name|E
argument_list|>
name|h
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|;
name|restartFromHead
label|:
while|while
condition|(
operator|(
name|h
operator|=
name|head
operator|)
operator|.
name|item
operator|==
literal|null
operator|&&
operator|(
name|p
operator|=
name|h
operator|.
name|prev
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|.
name|prev
operator|)
operator|==
literal|null
operator|||
operator|(
name|q
operator|=
operator|(
name|p
operator|=
name|q
operator|)
operator|.
name|prev
operator|)
operator|==
literal|null
condition|)
block|{
comment|// It is possible that p is PREV_TERMINATOR,
comment|// but if so, the CAS is guaranteed to fail.
if|if
condition|(
name|casHead
argument_list|(
name|h
argument_list|,
name|p
argument_list|)
condition|)
return|return;
else|else
continue|continue
name|restartFromHead
continue|;
block|}
elseif|else
if|if
condition|(
name|h
operator|!=
name|head
condition|)
continue|continue
name|restartFromHead
continue|;
else|else
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Guarantees that any node which was unlinked before a call to      * this method will be unreachable from tail after it returns.      * Does not guarantee to eliminate slack, only that tail will      * point to a node that was active while this method was running.      */
DECL|method|updateTail
specifier|private
specifier|final
name|void
name|updateTail
parameter_list|()
block|{
comment|// Either tail already points to an active node, or we keep
comment|// trying to cas it to the last node until it does.
name|Node
argument_list|<
name|E
argument_list|>
name|t
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|;
name|restartFromTail
label|:
while|while
condition|(
operator|(
name|t
operator|=
name|tail
operator|)
operator|.
name|item
operator|==
literal|null
operator|&&
operator|(
name|p
operator|=
name|t
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|.
name|next
operator|)
operator|==
literal|null
operator|||
operator|(
name|q
operator|=
operator|(
name|p
operator|=
name|q
operator|)
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
block|{
comment|// It is possible that p is NEXT_TERMINATOR,
comment|// but if so, the CAS is guaranteed to fail.
if|if
condition|(
name|casTail
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
condition|)
return|return;
else|else
continue|continue
name|restartFromTail
continue|;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|tail
condition|)
continue|continue
name|restartFromTail
continue|;
else|else
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
block|}
DECL|method|skipDeletedPredecessors
specifier|private
name|void
name|skipDeletedPredecessors
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|x
parameter_list|)
block|{
name|whileActive
label|:
do|do
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|prev
init|=
name|x
operator|.
name|prev
decl_stmt|;
comment|// assert prev != null;
comment|// assert x != NEXT_TERMINATOR;
comment|// assert x != PREV_TERMINATOR;
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|prev
decl_stmt|;
name|findActive
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|.
name|item
operator|!=
literal|null
condition|)
break|break
name|findActive
break|;
name|Node
argument_list|<
name|E
argument_list|>
name|q
init|=
name|p
operator|.
name|prev
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|next
operator|==
name|p
condition|)
continue|continue
name|whileActive
continue|;
break|break
name|findActive
break|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|q
condition|)
continue|continue
name|whileActive
continue|;
else|else
name|p
operator|=
name|q
expr_stmt|;
block|}
comment|// found active CAS target
if|if
condition|(
name|prev
operator|==
name|p
operator|||
name|x
operator|.
name|casPrev
argument_list|(
name|prev
argument_list|,
name|p
argument_list|)
condition|)
return|return;
block|}
do|while
condition|(
name|x
operator|.
name|item
operator|!=
literal|null
operator|||
name|x
operator|.
name|next
operator|==
literal|null
condition|)
do|;
block|}
DECL|method|skipDeletedSuccessors
specifier|private
name|void
name|skipDeletedSuccessors
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|x
parameter_list|)
block|{
name|whileActive
label|:
do|do
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|next
init|=
name|x
operator|.
name|next
decl_stmt|;
comment|// assert next != null;
comment|// assert x != NEXT_TERMINATOR;
comment|// assert x != PREV_TERMINATOR;
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|next
decl_stmt|;
name|findActive
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|.
name|item
operator|!=
literal|null
condition|)
break|break
name|findActive
break|;
name|Node
argument_list|<
name|E
argument_list|>
name|q
init|=
name|p
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|prev
operator|==
name|p
condition|)
continue|continue
name|whileActive
continue|;
break|break
name|findActive
break|;
block|}
elseif|else
if|if
condition|(
name|p
operator|==
name|q
condition|)
continue|continue
name|whileActive
continue|;
else|else
name|p
operator|=
name|q
expr_stmt|;
block|}
comment|// found active CAS target
if|if
condition|(
name|next
operator|==
name|p
operator|||
name|x
operator|.
name|casNext
argument_list|(
name|next
argument_list|,
name|p
argument_list|)
condition|)
return|return;
block|}
do|while
condition|(
name|x
operator|.
name|item
operator|!=
literal|null
operator|||
name|x
operator|.
name|prev
operator|==
literal|null
condition|)
do|;
block|}
comment|/**      * Returns the successor of p, or the first node if p.next has been      * linked to self, which will only be true if traversing with a      * stale pointer that is now off the list.      */
DECL|method|succ
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|succ
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
parameter_list|)
block|{
comment|// TODO: should we skip deleted nodes here?
name|Node
argument_list|<
name|E
argument_list|>
name|q
init|=
name|p
operator|.
name|next
decl_stmt|;
return|return
operator|(
name|p
operator|==
name|q
operator|)
condition|?
name|first
argument_list|()
else|:
name|q
return|;
block|}
comment|/**      * Returns the predecessor of p, or the last node if p.prev has been      * linked to self, which will only be true if traversing with a      * stale pointer that is now off the list.      */
DECL|method|pred
specifier|final
name|Node
argument_list|<
name|E
argument_list|>
name|pred
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
parameter_list|)
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|q
init|=
name|p
operator|.
name|prev
decl_stmt|;
return|return
operator|(
name|p
operator|==
name|q
operator|)
condition|?
name|last
argument_list|()
else|:
name|q
return|;
block|}
comment|/**      * Returns the first node, the unique node p for which:      *     p.prev == null&& p.next != p      * The returned node may or may not be logically deleted.      * Guarantees that head is set to the returned node.      */
DECL|method|first
name|Node
argument_list|<
name|E
argument_list|>
name|first
parameter_list|()
block|{
name|restartFromHead
label|:
for|for
control|(
init|;
condition|;
control|)
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|h
init|=
name|head
init|,
name|p
init|=
name|h
init|,
name|q
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|.
name|prev
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
operator|(
name|p
operator|=
name|q
operator|)
operator|.
name|prev
operator|)
operator|!=
literal|null
condition|)
comment|// Check for head updates every other hop.
comment|// If p == q, we are sure to follow head instead.
name|p
operator|=
operator|(
name|h
operator|!=
operator|(
name|h
operator|=
name|head
operator|)
operator|)
condition|?
name|h
else|:
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|h
comment|// It is possible that p is PREV_TERMINATOR,
comment|// but if so, the CAS is guaranteed to fail.
operator|||
name|casHead
argument_list|(
name|h
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|p
return|;
else|else
continue|continue
name|restartFromHead
continue|;
block|}
block|}
comment|/**      * Returns the last node, the unique node p for which:      *     p.next == null&& p.prev != p      * The returned node may or may not be logically deleted.      * Guarantees that tail is set to the returned node.      */
DECL|method|last
name|Node
argument_list|<
name|E
argument_list|>
name|last
parameter_list|()
block|{
name|restartFromTail
label|:
for|for
control|(
init|;
condition|;
control|)
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|t
init|=
name|tail
init|,
name|p
init|=
name|t
init|,
name|q
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
operator|(
name|p
operator|=
name|q
operator|)
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
comment|// Check for tail updates every other hop.
comment|// If p == q, we are sure to follow tail instead.
name|p
operator|=
operator|(
name|t
operator|!=
operator|(
name|t
operator|=
name|tail
operator|)
operator|)
condition|?
name|t
else|:
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|==
name|t
comment|// It is possible that p is NEXT_TERMINATOR,
comment|// but if so, the CAS is guaranteed to fail.
operator|||
name|casTail
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|p
return|;
else|else
continue|continue
name|restartFromTail
continue|;
block|}
block|}
comment|// Minor convenience utilities
comment|/**      * Throws NullPointerException if argument is null.      *      * @param v the element      */
DECL|method|checkNotNull
specifier|private
specifier|static
name|void
name|checkNotNull
parameter_list|(
name|Object
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
block|}
comment|/**      * Returns element unless it is null, in which case throws      * NoSuchElementException.      *      * @param v the element      * @return the element      */
DECL|method|screenNullResult
specifier|private
name|E
name|screenNullResult
parameter_list|(
name|E
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
return|return
name|v
return|;
block|}
comment|/**      * Creates an array list and fills it with elements of this list.      * Used by toArray.      *      * @return the arrayList      */
DECL|method|toArrayList
specifier|private
name|ArrayList
argument_list|<
name|E
argument_list|>
name|toArrayList
parameter_list|()
block|{
name|ArrayList
argument_list|<
name|E
argument_list|>
name|list
init|=
operator|new
name|ArrayList
argument_list|<
name|E
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|first
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
name|list
operator|.
name|add
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
comment|/**      * Constructs an empty deque.      */
DECL|method|ConcurrentLinkedDeque
specifier|public
name|ConcurrentLinkedDeque
parameter_list|()
block|{
name|head
operator|=
name|tail
operator|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Constructs a deque initially containing the elements of      * the given collection, added in traversal order of the      * collection's iterator.      *      * @param c the collection of elements to initially contain      * @throws NullPointerException if the specified collection or any      *         of its elements are null      */
DECL|method|ConcurrentLinkedDeque
specifier|public
name|ConcurrentLinkedDeque
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
comment|// Copy c into a private chain of Nodes
name|Node
argument_list|<
name|E
argument_list|>
name|h
init|=
literal|null
decl_stmt|,
name|t
init|=
literal|null
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|c
control|)
block|{
name|checkNotNull
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|null
condition|)
name|h
operator|=
name|t
operator|=
name|newNode
expr_stmt|;
else|else
block|{
name|t
operator|.
name|lazySetNext
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|lazySetPrev
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|newNode
expr_stmt|;
block|}
block|}
name|initHeadTail
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/**      * Initializes head and tail, ensuring invariants hold.      */
DECL|method|initHeadTail
specifier|private
name|void
name|initHeadTail
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|h
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|h
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|h
operator|==
literal|null
condition|)
name|h
operator|=
name|t
operator|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
literal|null
argument_list|)
expr_stmt|;
else|else
block|{
comment|// Avoid edge case of a single Node with non-null item.
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
literal|null
argument_list|)
decl_stmt|;
name|t
operator|.
name|lazySetNext
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|lazySetPrev
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|newNode
expr_stmt|;
block|}
block|}
name|head
operator|=
name|h
expr_stmt|;
name|tail
operator|=
name|t
expr_stmt|;
block|}
comment|/**      * Inserts the specified element at the front of this deque.      * As the deque is unbounded, this method will never throw      * {@link IllegalStateException}.      *      * @throws NullPointerException if the specified element is null      */
DECL|method|addFirst
specifier|public
name|void
name|addFirst
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|linkFirst
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inserts the specified element at the end of this deque.      * As the deque is unbounded, this method will never throw      * {@link IllegalStateException}.      *      *<p>This method is equivalent to {@link #add}.      *      * @throws NullPointerException if the specified element is null      */
DECL|method|addLast
specifier|public
name|void
name|addLast
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|linkLast
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inserts the specified element at the front of this deque.      * As the deque is unbounded, this method will never return {@code false}.      *      * @return {@code true} (as specified by {@link Deque#offerFirst})      * @throws NullPointerException if the specified element is null      */
DECL|method|offerFirst
specifier|public
name|boolean
name|offerFirst
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|linkFirst
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Inserts the specified element at the end of this deque.      * As the deque is unbounded, this method will never return {@code false}.      *      *<p>This method is equivalent to {@link #add}.      *      * @return {@code true} (as specified by {@link Deque#offerLast})      * @throws NullPointerException if the specified element is null      */
DECL|method|offerLast
specifier|public
name|boolean
name|offerLast
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|linkLast
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|peekFirst
specifier|public
name|E
name|peekFirst
parameter_list|()
block|{
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|first
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
return|return
name|item
return|;
block|}
return|return
literal|null
return|;
block|}
DECL|method|peekLast
specifier|public
name|E
name|peekLast
parameter_list|()
block|{
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|last
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|pred
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
return|return
name|item
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * @throws NoSuchElementException {@inheritDoc}      */
DECL|method|getFirst
specifier|public
name|E
name|getFirst
parameter_list|()
block|{
return|return
name|screenNullResult
argument_list|(
name|peekFirst
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @throws NoSuchElementException {@inheritDoc}      */
DECL|method|getLast
specifier|public
name|E
name|getLast
parameter_list|()
block|{
return|return
name|screenNullResult
argument_list|(
name|peekLast
argument_list|()
argument_list|)
return|;
block|}
DECL|method|pollFirst
specifier|public
name|E
name|pollFirst
parameter_list|()
block|{
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|first
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|p
operator|.
name|casItem
argument_list|(
name|item
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
DECL|method|pollLast
specifier|public
name|E
name|pollLast
parameter_list|()
block|{
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|last
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|pred
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|p
operator|.
name|casItem
argument_list|(
name|item
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|item
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * @throws NoSuchElementException {@inheritDoc}      */
DECL|method|removeFirst
specifier|public
name|E
name|removeFirst
parameter_list|()
block|{
return|return
name|screenNullResult
argument_list|(
name|pollFirst
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * @throws NoSuchElementException {@inheritDoc}      */
DECL|method|removeLast
specifier|public
name|E
name|removeLast
parameter_list|()
block|{
return|return
name|screenNullResult
argument_list|(
name|pollLast
argument_list|()
argument_list|)
return|;
block|}
comment|// *** Queue and stack methods ***
comment|/**      * Inserts the specified element at the tail of this deque.      * As the deque is unbounded, this method will never return {@code false}.      *      * @return {@code true} (as specified by {@link Queue#offer})      * @throws NullPointerException if the specified element is null      */
DECL|method|offer
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|offerLast
argument_list|(
name|e
argument_list|)
return|;
block|}
comment|/**      * Inserts the specified element at the tail of this deque.      * As the deque is unbounded, this method will never throw      * {@link IllegalStateException} or return {@code false}.      *      * @return {@code true} (as specified by {@link Collection#add})      * @throws NullPointerException if the specified element is null      */
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|offerLast
argument_list|(
name|e
argument_list|)
return|;
block|}
DECL|method|poll
specifier|public
name|E
name|poll
parameter_list|()
block|{
return|return
name|pollFirst
argument_list|()
return|;
block|}
DECL|method|remove
specifier|public
name|E
name|remove
parameter_list|()
block|{
return|return
name|removeFirst
argument_list|()
return|;
block|}
DECL|method|peek
specifier|public
name|E
name|peek
parameter_list|()
block|{
return|return
name|peekFirst
argument_list|()
return|;
block|}
DECL|method|element
specifier|public
name|E
name|element
parameter_list|()
block|{
return|return
name|getFirst
argument_list|()
return|;
block|}
DECL|method|push
specifier|public
name|void
name|push
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|addFirst
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
DECL|method|pop
specifier|public
name|E
name|pop
parameter_list|()
block|{
return|return
name|removeFirst
argument_list|()
return|;
block|}
comment|/**      * Removes the first element {@code e} such that      * {@code o.equals(e)}, if such an element exists in this deque.      * If the deque does not contain the element, it is unchanged.      *      * @param o element to be removed from this deque, if present      * @return {@code true} if the deque contained the specified element      * @throws NullPointerException if the specified element is null      */
DECL|method|removeFirstOccurrence
specifier|public
name|boolean
name|removeFirstOccurrence
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|o
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|first
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|o
operator|.
name|equals
argument_list|(
name|item
argument_list|)
operator|&&
name|p
operator|.
name|casItem
argument_list|(
name|item
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Removes the last element {@code e} such that      * {@code o.equals(e)}, if such an element exists in this deque.      * If the deque does not contain the element, it is unchanged.      *      * @param o element to be removed from this deque, if present      * @return {@code true} if the deque contained the specified element      * @throws NullPointerException if the specified element is null      */
DECL|method|removeLastOccurrence
specifier|public
name|boolean
name|removeLastOccurrence
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
name|checkNotNull
argument_list|(
name|o
argument_list|)
expr_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|last
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|pred
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|o
operator|.
name|equals
argument_list|(
name|item
argument_list|)
operator|&&
name|p
operator|.
name|casItem
argument_list|(
name|item
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|unlink
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns {@code true} if this deque contains at least one      * element {@code e} such that {@code o.equals(e)}.      *      * @param o element whose presence in this deque is to be tested      * @return {@code true} if this deque contains the specified element      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|false
return|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|first
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|o
operator|.
name|equals
argument_list|(
name|item
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Returns {@code true} if this collection contains no elements.      *      * @return {@code true} if this collection contains no elements      */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
return|return
name|peekFirst
argument_list|()
operator|==
literal|null
return|;
block|}
comment|/**      * Returns the number of elements in this deque.  If this deque      * contains more than {@code Integer.MAX_VALUE} elements, it      * returns {@code Integer.MAX_VALUE}.      *      *<p>Beware that, unlike in most collections, this method is      *<em>NOT</em> a constant-time operation. Because of the      * asynchronous nature of these deques, determining the current      * number of elements requires traversing them all to count them.      * Additionally, it is possible for the size to change during      * execution of this method, in which case the returned result      * will be inaccurate. Thus, this method is typically not very      * useful in concurrent applications.      *      * @return the number of elements in this deque      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|first
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|p
operator|.
name|item
operator|!=
literal|null
condition|)
comment|// Collection.size() spec says to max out
if|if
condition|(
operator|++
name|count
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
break|break;
return|return
name|count
return|;
block|}
comment|/**      * Removes the first element {@code e} such that      * {@code o.equals(e)}, if such an element exists in this deque.      * If the deque does not contain the element, it is unchanged.      *      * @param o element to be removed from this deque, if present      * @return {@code true} if the deque contained the specified element      * @throws NullPointerException if the specified element is null      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|removeFirstOccurrence
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|/**      * Appends all of the elements in the specified collection to the end of      * this deque, in the order that they are returned by the specified      * collection's iterator.  Attempts to {@code addAll} of a deque to      * itself result in {@code IllegalArgumentException}.      *      * @param c the elements to be inserted into this deque      * @return {@code true} if this deque changed as a result of the call      * @throws NullPointerException if the specified collection or any      *         of its elements are null      * @throws IllegalArgumentException if the collection is this deque      */
DECL|method|addAll
specifier|public
name|boolean
name|addAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|this
condition|)
comment|// As historically specified in AbstractQueue#addAll
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
comment|// Copy c into a private chain of Nodes
name|Node
argument_list|<
name|E
argument_list|>
name|beginningOfTheEnd
init|=
literal|null
decl_stmt|,
name|last
init|=
literal|null
decl_stmt|;
for|for
control|(
name|E
name|e
range|:
name|c
control|)
block|{
name|checkNotNull
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|beginningOfTheEnd
operator|==
literal|null
condition|)
name|beginningOfTheEnd
operator|=
name|last
operator|=
name|newNode
expr_stmt|;
else|else
block|{
name|last
operator|.
name|lazySetNext
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|lazySetPrev
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|newNode
expr_stmt|;
block|}
block|}
if|if
condition|(
name|beginningOfTheEnd
operator|==
literal|null
condition|)
return|return
literal|false
return|;
comment|// Atomically append the chain at the tail of this collection
name|restartFromTail
label|:
for|for
control|(
init|;
condition|;
control|)
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|t
init|=
name|tail
init|,
name|p
init|=
name|t
init|,
name|q
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|p
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|q
operator|=
operator|(
name|p
operator|=
name|q
operator|)
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
comment|// Check for tail updates every other hop.
comment|// If p == q, we are sure to follow tail instead.
name|p
operator|=
operator|(
name|t
operator|!=
operator|(
name|t
operator|=
name|tail
operator|)
operator|)
condition|?
name|t
else|:
name|q
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|.
name|prev
operator|==
name|p
condition|)
comment|// NEXT_TERMINATOR
continue|continue
name|restartFromTail
continue|;
else|else
block|{
comment|// p is last node
name|beginningOfTheEnd
operator|.
name|lazySetPrev
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// CAS piggyback
if|if
condition|(
name|p
operator|.
name|casNext
argument_list|(
literal|null
argument_list|,
name|beginningOfTheEnd
argument_list|)
condition|)
block|{
comment|// Successful CAS is the linearization point
comment|// for all elements to be added to this deque.
if|if
condition|(
operator|!
name|casTail
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
condition|)
block|{
comment|// Try a little harder to update tail,
comment|// since we may be adding many elements.
name|t
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|last
operator|.
name|next
operator|==
literal|null
condition|)
name|casTail
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
comment|// Lost CAS race to another thread; re-read next
block|}
block|}
block|}
comment|/**      * Removes all of the elements from this deque.      */
DECL|method|clear
specifier|public
name|void
name|clear
parameter_list|()
block|{
while|while
condition|(
name|pollFirst
argument_list|()
operator|!=
literal|null
condition|)
empty_stmt|;
block|}
comment|/**      * Returns an array containing all of the elements in this deque, in      * proper sequence (from first to last element).      *      *<p>The returned array will be "safe" in that no references to it are      * maintained by this deque.  (In other words, this method must allocate      * a new array).  The caller is thus free to modify the returned array.      *      *<p>This method acts as bridge between array-based and collection-based      * APIs.      *      * @return an array containing all of the elements in this deque      */
DECL|method|toArray
specifier|public
name|Object
index|[]
name|toArray
parameter_list|()
block|{
return|return
name|toArrayList
argument_list|()
operator|.
name|toArray
argument_list|()
return|;
block|}
comment|/**      * Returns an array containing all of the elements in this deque,      * in proper sequence (from first to last element); the runtime      * type of the returned array is that of the specified array.  If      * the deque fits in the specified array, it is returned therein.      * Otherwise, a new array is allocated with the runtime type of      * the specified array and the size of this deque.      *      *<p>If this deque fits in the specified array with room to spare      * (i.e., the array has more elements than this deque), the element in      * the array immediately following the end of the deque is set to      * {@code null}.      *      *<p>Like the {@link #toArray()} method, this method acts as      * bridge between array-based and collection-based APIs.  Further,      * this method allows precise control over the runtime type of the      * output array, and may, under certain circumstances, be used to      * save allocation costs.      *      *<p>Suppose {@code x} is a deque known to contain only strings.      * The following code can be used to dump the deque into a newly      * allocated array of {@code String}:      *      *<pre> {@code String[] y = x.toArray(new String[0]);}</pre>      *      * Note that {@code toArray(new Object[0])} is identical in function to      * {@code toArray()}.      *      * @param a the array into which the elements of the deque are to      *          be stored, if it is big enough; otherwise, a new array of the      *          same runtime type is allocated for this purpose      * @return an array containing all of the elements in this deque      * @throws ArrayStoreException if the runtime type of the specified array      *         is not a supertype of the runtime type of every element in      *         this deque      * @throws NullPointerException if the specified array is null      */
DECL|method|toArray
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
index|[]
name|toArray
parameter_list|(
name|T
index|[]
name|a
parameter_list|)
block|{
return|return
name|toArrayList
argument_list|()
operator|.
name|toArray
argument_list|(
name|a
argument_list|)
return|;
block|}
comment|/**      * Returns an iterator over the elements in this deque in proper sequence.      * The elements will be returned in order from first (head) to last (tail).      *      *<p>The returned iterator is a "weakly consistent" iterator that      * will never throw {@link java.util.ConcurrentModificationException      * ConcurrentModificationException}, and guarantees to traverse      * elements as they existed upon construction of the iterator, and      * may (but is not guaranteed to) reflect any modifications      * subsequent to construction.      *      * @return an iterator over the elements in this deque in proper sequence      */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Itr
argument_list|()
return|;
block|}
comment|/**      * Returns an iterator over the elements in this deque in reverse      * sequential order.  The elements will be returned in order from      * last (tail) to first (head).      *      *<p>The returned iterator is a "weakly consistent" iterator that      * will never throw {@link java.util.ConcurrentModificationException      * ConcurrentModificationException}, and guarantees to traverse      * elements as they existed upon construction of the iterator, and      * may (but is not guaranteed to) reflect any modifications      * subsequent to construction.      *      * @return an iterator over the elements in this deque in reverse order      */
DECL|method|descendingIterator
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|descendingIterator
parameter_list|()
block|{
return|return
operator|new
name|DescendingItr
argument_list|()
return|;
block|}
DECL|class|AbstractItr
specifier|private
specifier|abstract
class|class
name|AbstractItr
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
comment|/**          * Next node to return item for.          */
DECL|field|nextNode
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|nextNode
decl_stmt|;
comment|/**          * nextItem holds on to item fields because once we claim          * that an element exists in hasNext(), we must return it in          * the following next() call even if it was in the process of          * being removed when hasNext() was called.          */
DECL|field|nextItem
specifier|private
name|E
name|nextItem
decl_stmt|;
comment|/**          * Node returned by most recent call to next. Needed by remove.          * Reset to null if this element is deleted by a call to remove.          */
DECL|field|lastRet
specifier|private
name|Node
argument_list|<
name|E
argument_list|>
name|lastRet
decl_stmt|;
DECL|method|startNode
specifier|abstract
name|Node
argument_list|<
name|E
argument_list|>
name|startNode
parameter_list|()
function_decl|;
DECL|method|nextNode
specifier|abstract
name|Node
argument_list|<
name|E
argument_list|>
name|nextNode
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
parameter_list|)
function_decl|;
DECL|method|AbstractItr
name|AbstractItr
parameter_list|()
block|{
name|advance
argument_list|()
expr_stmt|;
block|}
comment|/**          * Sets nextNode and nextItem to next valid node, or to null          * if no such.          */
DECL|method|advance
specifier|private
name|void
name|advance
parameter_list|()
block|{
name|lastRet
operator|=
name|nextNode
expr_stmt|;
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
operator|(
name|nextNode
operator|==
literal|null
operator|)
condition|?
name|startNode
argument_list|()
else|:
name|nextNode
argument_list|(
name|nextNode
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
name|p
operator|=
name|nextNode
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
name|p
operator|==
literal|null
condition|)
block|{
comment|// p might be active end or TERMINATOR node; both are OK
name|nextNode
operator|=
literal|null
expr_stmt|;
name|nextItem
operator|=
literal|null
expr_stmt|;
break|break;
block|}
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
block|{
name|nextNode
operator|=
name|p
expr_stmt|;
name|nextItem
operator|=
name|item
expr_stmt|;
break|break;
block|}
block|}
block|}
DECL|method|hasNext
specifier|public
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextItem
operator|!=
literal|null
return|;
block|}
DECL|method|next
specifier|public
name|E
name|next
parameter_list|()
block|{
name|E
name|item
init|=
name|nextItem
decl_stmt|;
if|if
condition|(
name|item
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|advance
argument_list|()
expr_stmt|;
return|return
name|item
return|;
block|}
DECL|method|remove
specifier|public
name|void
name|remove
parameter_list|()
block|{
name|Node
argument_list|<
name|E
argument_list|>
name|l
init|=
name|lastRet
decl_stmt|;
if|if
condition|(
name|l
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|l
operator|.
name|item
operator|=
literal|null
expr_stmt|;
name|unlink
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|lastRet
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/** Forward iterator */
DECL|class|Itr
specifier|private
class|class
name|Itr
extends|extends
name|AbstractItr
block|{
DECL|method|startNode
name|Node
argument_list|<
name|E
argument_list|>
name|startNode
parameter_list|()
block|{
return|return
name|first
argument_list|()
return|;
block|}
DECL|method|nextNode
name|Node
argument_list|<
name|E
argument_list|>
name|nextNode
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
parameter_list|)
block|{
return|return
name|succ
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
comment|/** Descending iterator */
DECL|class|DescendingItr
specifier|private
class|class
name|DescendingItr
extends|extends
name|AbstractItr
block|{
DECL|method|startNode
name|Node
argument_list|<
name|E
argument_list|>
name|startNode
parameter_list|()
block|{
return|return
name|last
argument_list|()
return|;
block|}
DECL|method|nextNode
name|Node
argument_list|<
name|E
argument_list|>
name|nextNode
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
parameter_list|)
block|{
return|return
name|pred
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
comment|/**      * Saves the state to a stream (that is, serializes it).      *      * @serialData All of the elements (each an {@code E}) in      * the proper order, followed by a null      * @param s the stream      */
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
comment|// Write out any hidden stuff
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
comment|// Write out all elements in the proper order.
for|for
control|(
name|Node
argument_list|<
name|E
argument_list|>
name|p
init|=
name|first
argument_list|()
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|E
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
literal|null
condition|)
name|s
operator|.
name|writeObject
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
comment|// Use trailing null as sentinel
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reconstitutes the instance from a stream (that is, deserializes it).      * @param s the stream      */
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
comment|// Read in elements until trailing null sentinel found
name|Node
argument_list|<
name|E
argument_list|>
name|h
init|=
literal|null
decl_stmt|,
name|t
init|=
literal|null
decl_stmt|;
name|Object
name|item
decl_stmt|;
while|while
condition|(
operator|(
name|item
operator|=
name|s
operator|.
name|readObject
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|Node
argument_list|<
name|E
argument_list|>
name|newNode
init|=
operator|new
name|Node
argument_list|<
name|E
argument_list|>
argument_list|(
operator|(
name|E
operator|)
name|item
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
literal|null
condition|)
name|h
operator|=
name|t
operator|=
name|newNode
expr_stmt|;
else|else
block|{
name|t
operator|.
name|lazySetNext
argument_list|(
name|newNode
argument_list|)
expr_stmt|;
name|newNode
operator|.
name|lazySetPrev
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|newNode
expr_stmt|;
block|}
block|}
name|initHeadTail
argument_list|(
name|h
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
DECL|method|casHead
specifier|private
name|boolean
name|casHead
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|cmp
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|headOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|casTail
specifier|private
name|boolean
name|casTail
parameter_list|(
name|Node
argument_list|<
name|E
argument_list|>
name|cmp
parameter_list|,
name|Node
argument_list|<
name|E
argument_list|>
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|tailOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|headOffset
specifier|private
specifier|static
specifier|final
name|long
name|headOffset
decl_stmt|;
DECL|field|tailOffset
specifier|private
specifier|static
specifier|final
name|long
name|tailOffset
decl_stmt|;
static|static
block|{
name|PREV_TERMINATOR
operator|=
operator|new
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|PREV_TERMINATOR
operator|.
name|next
operator|=
name|PREV_TERMINATOR
expr_stmt|;
name|NEXT_TERMINATOR
operator|=
operator|new
name|Node
argument_list|<
name|Object
argument_list|>
argument_list|()
expr_stmt|;
name|NEXT_TERMINATOR
operator|.
name|prev
operator|=
name|NEXT_TERMINATOR
expr_stmt|;
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|ConcurrentLinkedDeque
operator|.
name|class
decl_stmt|;
name|headOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"head"
argument_list|)
argument_list|)
expr_stmt|;
name|tailOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"tail"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

