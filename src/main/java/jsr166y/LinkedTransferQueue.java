begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166y
package|package
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|AbstractQueue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|NoSuchElementException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Queue
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_comment
comment|/**  * An unbounded {@link TransferQueue} based on linked nodes.  * This queue orders elements FIFO (first-in-first-out) with respect  * to any given producer.  The<em>head</em> of the queue is that  * element that has been on the queue the longest time for some  * producer.  The<em>tail</em> of the queue is that element that has  * been on the queue the shortest time for some producer.  *  *<p>Beware that, unlike in most collections, the {@code size} method  * is<em>NOT</em> a constant-time operation. Because of the  * asynchronous nature of these queues, determining the current number  * of elements requires a traversal of the elements, and so may report  * inaccurate results if this collection is modified during traversal.  * Additionally, the bulk operations {@code addAll},  * {@code removeAll}, {@code retainAll}, {@code containsAll},  * {@code equals}, and {@code toArray} are<em>not</em> guaranteed  * to be performed atomically. For example, an iterator operating  * concurrently with an {@code addAll} operation might view only some  * of the added elements.  *  *<p>This class and its iterator implement all of the  *<em>optional</em> methods of the {@link Collection} and {@link  * Iterator} interfaces.  *  *<p>Memory consistency effects: As with other concurrent  * collections, actions in a thread prior to placing an object into a  * {@code LinkedTransferQueue}  *<a href="package-summary.html#MemoryVisibility"><i>happen-before</i></a>  * actions subsequent to the access or removal of that element from  * the {@code LinkedTransferQueue} in another thread.  *  *<p>This class is a member of the  *<a href="{@docRoot}/../technotes/guides/collections/index.html">  * Java Collections Framework</a>.  *  * @since 1.7  * @author Doug Lea  * @param<E> the type of elements held in this collection  */
end_comment

begin_class
DECL|class|LinkedTransferQueue
specifier|public
class|class
name|LinkedTransferQueue
parameter_list|<
name|E
parameter_list|>
extends|extends
name|AbstractQueue
argument_list|<
name|E
argument_list|>
implements|implements
name|TransferQueue
argument_list|<
name|E
argument_list|>
implements|,
name|java
operator|.
name|io
operator|.
name|Serializable
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|3223113410248163686L
decl_stmt|;
comment|/*      * *** Overview of Dual Queues with Slack ***      *      * Dual Queues, introduced by Scherer and Scott      * (http://www.cs.rice.edu/~wns1/papers/2004-DISC-DDS.pdf) are      * (linked) queues in which nodes may represent either data or      * requests.  When a thread tries to enqueue a data node, but      * encounters a request node, it instead "matches" and removes it;      * and vice versa for enqueuing requests. Blocking Dual Queues      * arrange that threads enqueuing unmatched requests block until      * other threads provide the match. Dual Synchronous Queues (see      * Scherer, Lea,& Scott      * http://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf)      * additionally arrange that threads enqueuing unmatched data also      * block.  Dual Transfer Queues support all of these modes, as      * dictated by callers.      *      * A FIFO dual queue may be implemented using a variation of the      * Michael& Scott (M&S) lock-free queue algorithm      * (http://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf).      * It maintains two pointer fields, "head", pointing to a      * (matched) node that in turn points to the first actual      * (unmatched) queue node (or null if empty); and "tail" that      * points to the last node on the queue (or again null if      * empty). For example, here is a possible queue with four data      * elements:      *      *  head                tail      *    |                   |      *    v                   v      *    M -> U -> U -> U -> U      *      * The M&S queue algorithm is known to be prone to scalability and      * overhead limitations when maintaining (via CAS) these head and      * tail pointers. This has led to the development of      * contention-reducing variants such as elimination arrays (see      * Moir et al http://portal.acm.org/citation.cfm?id=1074013) and      * optimistic back pointers (see Ladan-Mozes& Shavit      * http://people.csail.mit.edu/edya/publications/OptimisticFIFOQueue-journal.pdf).      * However, the nature of dual queues enables a simpler tactic for      * improving M&S-style implementations when dual-ness is needed.      *      * In a dual queue, each node must atomically maintain its match      * status. While there are other possible variants, we implement      * this here as: for a data-mode node, matching entails CASing an      * "item" field from a non-null data value to null upon match, and      * vice-versa for request nodes, CASing from null to a data      * value. (Note that the linearization properties of this style of      * queue are easy to verify -- elements are made available by      * linking, and unavailable by matching.) Compared to plain M&S      * queues, this property of dual queues requires one additional      * successful atomic operation per enq/deq pair. But it also      * enables lower cost variants of queue maintenance mechanics. (A      * variation of this idea applies even for non-dual queues that      * support deletion of interior elements, such as      * j.u.c.ConcurrentLinkedQueue.)      *      * Once a node is matched, its match status can never again      * change.  We may thus arrange that the linked list of them      * contain a prefix of zero or more matched nodes, followed by a      * suffix of zero or more unmatched nodes. (Note that we allow      * both the prefix and suffix to be zero length, which in turn      * means that we do not use a dummy header.)  If we were not      * concerned with either time or space efficiency, we could      * correctly perform enqueue and dequeue operations by traversing      * from a pointer to the initial node; CASing the item of the      * first unmatched node on match and CASing the next field of the      * trailing node on appends. (Plus some special-casing when      * initially empty).  While this would be a terrible idea in      * itself, it does have the benefit of not requiring ANY atomic      * updates on head/tail fields.      *      * We introduce here an approach that lies between the extremes of      * never versus always updating queue (head and tail) pointers.      * This offers a tradeoff between sometimes requiring extra      * traversal steps to locate the first and/or last unmatched      * nodes, versus the reduced overhead and contention of fewer      * updates to queue pointers. For example, a possible snapshot of      * a queue is:      *      *  head           tail      *    |              |      *    v              v      *    M -> M -> U -> U -> U -> U      *      * The best value for this "slack" (the targeted maximum distance      * between the value of "head" and the first unmatched node, and      * similarly for "tail") is an empirical matter. We have found      * that using very small constants in the range of 1-3 work best      * over a range of platforms. Larger values introduce increasing      * costs of cache misses and risks of long traversal chains, while      * smaller values increase CAS contention and overhead.      *      * Dual queues with slack differ from plain M&S dual queues by      * virtue of only sometimes updating head or tail pointers when      * matching, appending, or even traversing nodes; in order to      * maintain a targeted slack.  The idea of "sometimes" may be      * operationalized in several ways. The simplest is to use a      * per-operation counter incremented on each traversal step, and      * to try (via CAS) to update the associated queue pointer      * whenever the count exceeds a threshold. Another, that requires      * more overhead, is to use random number generators to update      * with a given probability per traversal step.      *      * In any strategy along these lines, because CASes updating      * fields may fail, the actual slack may exceed targeted      * slack. However, they may be retried at any time to maintain      * targets.  Even when using very small slack values, this      * approach works well for dual queues because it allows all      * operations up to the point of matching or appending an item      * (hence potentially allowing progress by another thread) to be      * read-only, thus not introducing any further contention. As      * described below, we implement this by performing slack      * maintenance retries only after these points.      *      * As an accompaniment to such techniques, traversal overhead can      * be further reduced without increasing contention of head      * pointer updates: Threads may sometimes shortcut the "next" link      * path from the current "head" node to be closer to the currently      * known first unmatched node, and similarly for tail. Again, this      * may be triggered with using thresholds or randomization.      *      * These ideas must be further extended to avoid unbounded amounts      * of costly-to-reclaim garbage caused by the sequential "next"      * links of nodes starting at old forgotten head nodes: As first      * described in detail by Boehm      * (http://portal.acm.org/citation.cfm?doid=503272.503282) if a GC      * delays noticing that any arbitrarily old node has become      * garbage, all newer dead nodes will also be unreclaimed.      * (Similar issues arise in non-GC environments.)  To cope with      * this in our implementation, upon CASing to advance the head      * pointer, we set the "next" link of the previous head to point      * only to itself; thus limiting the length of connected dead lists.      * (We also take similar care to wipe out possibly garbage      * retaining values held in other Node fields.)  However, doing so      * adds some further complexity to traversal: If any "next"      * pointer links to itself, it indicates that the current thread      * has lagged behind a head-update, and so the traversal must      * continue from the "head".  Traversals trying to find the      * current tail starting from "tail" may also encounter      * self-links, in which case they also continue at "head".      *      * It is tempting in slack-based scheme to not even use CAS for      * updates (similarly to Ladan-Mozes& Shavit). However, this      * cannot be done for head updates under the above link-forgetting      * mechanics because an update may leave head at a detached node.      * And while direct writes are possible for tail updates, they      * increase the risk of long retraversals, and hence long garbage      * chains, which can be much more costly than is worthwhile      * considering that the cost difference of performing a CAS vs      * write is smaller when they are not triggered on each operation      * (especially considering that writes and CASes equally require      * additional GC bookkeeping ("write barriers") that are sometimes      * more costly than the writes themselves because of contention).      *      * *** Overview of implementation ***      *      * We use a threshold-based approach to updates, with a slack      * threshold of two -- that is, we update head/tail when the      * current pointer appears to be two or more steps away from the      * first/last node. The slack value is hard-wired: a path greater      * than one is naturally implemented by checking equality of      * traversal pointers except when the list has only one element,      * in which case we keep slack threshold at one. Avoiding tracking      * explicit counts across method calls slightly simplifies an      * already-messy implementation. Using randomization would      * probably work better if there were a low-quality dirt-cheap      * per-thread one available, but even ThreadLocalRandom is too      * heavy for these purposes.      *      * With such a small slack threshold value, it is not worthwhile      * to augment this with path short-circuiting (i.e., unsplicing      * interior nodes) except in the case of cancellation/removal (see      * below).      *      * We allow both the head and tail fields to be null before any      * nodes are enqueued; initializing upon first append.  This      * simplifies some other logic, as well as providing more      * efficient explicit control paths instead of letting JVMs insert      * implicit NullPointerExceptions when they are null.  While not      * currently fully implemented, we also leave open the possibility      * of re-nulling these fields when empty (which is complicated to      * arrange, for little benefit.)      *      * All enqueue/dequeue operations are handled by the single method      * "xfer" with parameters indicating whether to act as some form      * of offer, put, poll, take, or transfer (each possibly with      * timeout). The relative complexity of using one monolithic      * method outweighs the code bulk and maintenance problems of      * using separate methods for each case.      *      * Operation consists of up to three phases. The first is      * implemented within method xfer, the second in tryAppend, and      * the third in method awaitMatch.      *      * 1. Try to match an existing node      *      *    Starting at head, skip already-matched nodes until finding      *    an unmatched node of opposite mode, if one exists, in which      *    case matching it and returning, also if necessary updating      *    head to one past the matched node (or the node itself if the      *    list has no other unmatched nodes). If the CAS misses, then      *    a loop retries advancing head by two steps until either      *    success or the slack is at most two. By requiring that each      *    attempt advances head by two (if applicable), we ensure that      *    the slack does not grow without bound. Traversals also check      *    if the initial head is now off-list, in which case they      *    start at the new head.      *      *    If no candidates are found and the call was untimed      *    poll/offer, (argument "how" is NOW) return.      *      * 2. Try to append a new node (method tryAppend)      *      *    Starting at current tail pointer, find the actual last node      *    and try to append a new node (or if head was null, establish      *    the first node). Nodes can be appended only if their      *    predecessors are either already matched or are of the same      *    mode. If we detect otherwise, then a new node with opposite      *    mode must have been appended during traversal, so we must      *    restart at phase 1. The traversal and update steps are      *    otherwise similar to phase 1: Retrying upon CAS misses and      *    checking for staleness.  In particular, if a self-link is      *    encountered, then we can safely jump to a node on the list      *    by continuing the traversal at current head.      *      *    On successful append, if the call was ASYNC, return.      *      * 3. Await match or cancellation (method awaitMatch)      *      *    Wait for another thread to match node; instead cancelling if      *    the current thread was interrupted or the wait timed out. On      *    multiprocessors, we use front-of-queue spinning: If a node      *    appears to be the first unmatched node in the queue, it      *    spins a bit before blocking. In either case, before blocking      *    it tries to unsplice any nodes between the current "head"      *    and the first unmatched node.      *      *    Front-of-queue spinning vastly improves performance of      *    heavily contended queues. And so long as it is relatively      *    brief and "quiet", spinning does not much impact performance      *    of less-contended queues.  During spins threads check their      *    interrupt status and generate a thread-local random number      *    to decide to occasionally perform a Thread.yield. While      *    yield has underdefined specs, we assume that it might help,      *    and will not hurt, in limiting impact of spinning on busy      *    systems.  We also use smaller (1/2) spins for nodes that are      *    not known to be front but whose predecessors have not      *    blocked -- these "chained" spins avoid artifacts of      *    front-of-queue rules which otherwise lead to alternating      *    nodes spinning vs blocking. Further, front threads that      *    represent phase changes (from data to request node or vice      *    versa) compared to their predecessors receive additional      *    chained spins, reflecting longer paths typically required to      *    unblock threads during phase changes.      *      *      * ** Unlinking removed interior nodes **      *      * In addition to minimizing garbage retention via self-linking      * described above, we also unlink removed interior nodes. These      * may arise due to timed out or interrupted waits, or calls to      * remove(x) or Iterator.remove.  Normally, given a node that was      * at one time known to be the predecessor of some node s that is      * to be removed, we can unsplice s by CASing the next field of      * its predecessor if it still points to s (otherwise s must      * already have been removed or is now offlist). But there are two      * situations in which we cannot guarantee to make node s      * unreachable in this way: (1) If s is the trailing node of list      * (i.e., with null next), then it is pinned as the target node      * for appends, so can only be removed later after other nodes are      * appended. (2) We cannot necessarily unlink s given a      * predecessor node that is matched (including the case of being      * cancelled): the predecessor may already be unspliced, in which      * case some previous reachable node may still point to s.      * (For further explanation see Herlihy& Shavit "The Art of      * Multiprocessor Programming" chapter 9).  Although, in both      * cases, we can rule out the need for further action if either s      * or its predecessor are (or can be made to be) at, or fall off      * from, the head of list.      *      * Without taking these into account, it would be possible for an      * unbounded number of supposedly removed nodes to remain      * reachable.  Situations leading to such buildup are uncommon but      * can occur in practice; for example when a series of short timed      * calls to poll repeatedly time out but never otherwise fall off      * the list because of an untimed call to take at the front of the      * queue.      *      * When these cases arise, rather than always retraversing the      * entire list to find an actual predecessor to unlink (which      * won't help for case (1) anyway), we record a conservative      * estimate of possible unsplice failures (in "sweepVotes").      * We trigger a full sweep when the estimate exceeds a threshold      * ("SWEEP_THRESHOLD") indicating the maximum number of estimated      * removal failures to tolerate before sweeping through, unlinking      * cancelled nodes that were not unlinked upon initial removal.      * We perform sweeps by the thread hitting threshold (rather than      * background threads or by spreading work to other threads)      * because in the main contexts in which removal occurs, the      * caller is already timed-out, cancelled, or performing a      * potentially O(n) operation (e.g. remove(x)), none of which are      * time-critical enough to warrant the overhead that alternatives      * would impose on other threads.      *      * Because the sweepVotes estimate is conservative, and because      * nodes become unlinked "naturally" as they fall off the head of      * the queue, and because we allow votes to accumulate even while      * sweeps are in progress, there are typically significantly fewer      * such nodes than estimated.  Choice of a threshold value      * balances the likelihood of wasted effort and contention, versus      * providing a worst-case bound on retention of interior nodes in      * quiescent queues. The value defined below was chosen      * empirically to balance these under various timeout scenarios.      *      * Note that we cannot self-link unlinked interior nodes during      * sweeps. However, the associated garbage chains terminate when      * some successor ultimately falls off the head of the list and is      * self-linked.      */
comment|/** True if on multiprocessor */
DECL|field|MP
specifier|private
specifier|static
specifier|final
name|boolean
name|MP
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
operator|>
literal|1
decl_stmt|;
comment|/**      * The number of times to spin (with randomly interspersed calls      * to Thread.yield) on multiprocessor before blocking when a node      * is apparently the first waiter in the queue.  See above for      * explanation. Must be a power of two. The value is empirically      * derived -- it works pretty well across a variety of processors,      * numbers of CPUs, and OSes.      */
DECL|field|FRONT_SPINS
specifier|private
specifier|static
specifier|final
name|int
name|FRONT_SPINS
init|=
literal|1
operator|<<
literal|7
decl_stmt|;
comment|/**      * The number of times to spin before blocking when a node is      * preceded by another node that is apparently spinning.  Also      * serves as an increment to FRONT_SPINS on phase changes, and as      * base average frequency for yielding during spins. Must be a      * power of two.      */
DECL|field|CHAINED_SPINS
specifier|private
specifier|static
specifier|final
name|int
name|CHAINED_SPINS
init|=
name|FRONT_SPINS
operator|>>>
literal|1
decl_stmt|;
comment|/**      * The maximum number of estimated removal failures (sweepVotes)      * to tolerate before sweeping through the queue unlinking      * cancelled nodes that were not unlinked upon initial      * removal. See above for explanation. The value must be at least      * two to avoid useless sweeps when removing trailing nodes.      */
DECL|field|SWEEP_THRESHOLD
specifier|static
specifier|final
name|int
name|SWEEP_THRESHOLD
init|=
literal|32
decl_stmt|;
comment|/**      * Queue nodes. Uses Object, not E, for items to allow forgetting      * them after use.  Relies heavily on Unsafe mechanics to minimize      * unnecessary ordering constraints: Writes that are intrinsically      * ordered wrt other accesses or CASes use simple relaxed forms.      */
DECL|class|Node
specifier|static
specifier|final
class|class
name|Node
block|{
DECL|field|isData
specifier|final
name|boolean
name|isData
decl_stmt|;
comment|// false if this is a request node
DECL|field|item
specifier|volatile
name|Object
name|item
decl_stmt|;
comment|// initially non-null if isData; CASed to match
DECL|field|next
specifier|volatile
name|Node
name|next
decl_stmt|;
DECL|field|waiter
specifier|volatile
name|Thread
name|waiter
decl_stmt|;
comment|// null until waiting
comment|// CAS methods for fields
DECL|method|casNext
specifier|final
name|boolean
name|casNext
parameter_list|(
name|Node
name|cmp
parameter_list|,
name|Node
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|nextOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|casItem
specifier|final
name|boolean
name|casItem
parameter_list|(
name|Object
name|cmp
parameter_list|,
name|Object
name|val
parameter_list|)
block|{
comment|// assert cmp == null || cmp.getClass() != Node.class;
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|itemOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/**          * Constructs a new node.  Uses relaxed write because item can          * only be seen after publication via casNext.          */
DECL|method|Node
name|Node
parameter_list|(
name|Object
name|item
parameter_list|,
name|boolean
name|isData
parameter_list|)
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|this
argument_list|,
name|itemOffset
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|// relaxed write
name|this
operator|.
name|isData
operator|=
name|isData
expr_stmt|;
block|}
comment|/**          * Links node to itself to avoid garbage retention.  Called          * only after CASing head field, so uses relaxed write.          */
DECL|method|forgetNext
specifier|final
name|void
name|forgetNext
parameter_list|()
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|this
argument_list|,
name|nextOffset
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**          * Sets item to self and waiter to null, to avoid garbage          * retention after matching or cancelling. Uses relaxed writes          * because order is already constrained in the only calling          * contexts: item is forgotten only after volatile/atomic          * mechanics that extract items.  Similarly, clearing waiter          * follows either CAS or return from park (if ever parked;          * else we don't care).          */
DECL|method|forgetContents
specifier|final
name|void
name|forgetContents
parameter_list|()
block|{
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|this
argument_list|,
name|itemOffset
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|UNSAFE
operator|.
name|putObject
argument_list|(
name|this
argument_list|,
name|waiterOffset
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**          * Returns true if this node has been matched, including the          * case of artificial matches due to cancellation.          */
DECL|method|isMatched
specifier|final
name|boolean
name|isMatched
parameter_list|()
block|{
name|Object
name|x
init|=
name|item
decl_stmt|;
return|return
operator|(
name|x
operator|==
name|this
operator|)
operator|||
operator|(
operator|(
name|x
operator|==
literal|null
operator|)
operator|==
name|isData
operator|)
return|;
block|}
comment|/**          * Returns true if this is an unmatched request node.          */
DECL|method|isUnmatchedRequest
specifier|final
name|boolean
name|isUnmatchedRequest
parameter_list|()
block|{
return|return
operator|!
name|isData
operator|&&
name|item
operator|==
literal|null
return|;
block|}
comment|/**          * Returns true if a node with the given mode cannot be          * appended to this node because this node is unmatched and          * has opposite data mode.          */
DECL|method|cannotPrecede
specifier|final
name|boolean
name|cannotPrecede
parameter_list|(
name|boolean
name|haveData
parameter_list|)
block|{
name|boolean
name|d
init|=
name|isData
decl_stmt|;
name|Object
name|x
decl_stmt|;
return|return
name|d
operator|!=
name|haveData
operator|&&
operator|(
name|x
operator|=
name|item
operator|)
operator|!=
name|this
operator|&&
operator|(
name|x
operator|!=
literal|null
operator|)
operator|==
name|d
return|;
block|}
comment|/**          * Tries to artificially match a data node -- used by remove.          */
DECL|method|tryMatchData
specifier|final
name|boolean
name|tryMatchData
parameter_list|()
block|{
comment|// assert isData;
name|Object
name|x
init|=
name|item
decl_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
operator|&&
name|x
operator|!=
name|this
operator|&&
name|casItem
argument_list|(
name|x
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|LockSupport
operator|.
name|unpark
argument_list|(
name|waiter
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|3375979862319811754L
decl_stmt|;
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|itemOffset
specifier|private
specifier|static
specifier|final
name|long
name|itemOffset
decl_stmt|;
DECL|field|nextOffset
specifier|private
specifier|static
specifier|final
name|long
name|nextOffset
decl_stmt|;
DECL|field|waiterOffset
specifier|private
specifier|static
specifier|final
name|long
name|waiterOffset
decl_stmt|;
static|static
block|{
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|Node
operator|.
name|class
decl_stmt|;
name|itemOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"item"
argument_list|)
argument_list|)
expr_stmt|;
name|nextOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"next"
argument_list|)
argument_list|)
expr_stmt|;
name|waiterOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"waiter"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|/** head of the queue; null until first enqueue */
DECL|field|head
specifier|transient
specifier|volatile
name|Node
name|head
decl_stmt|;
comment|/** tail of the queue; null until first append */
DECL|field|tail
specifier|private
specifier|transient
specifier|volatile
name|Node
name|tail
decl_stmt|;
comment|/** The number of apparent failures to unsplice removed nodes */
DECL|field|sweepVotes
specifier|private
specifier|transient
specifier|volatile
name|int
name|sweepVotes
decl_stmt|;
comment|// CAS methods for fields
DECL|method|casTail
specifier|private
name|boolean
name|casTail
parameter_list|(
name|Node
name|cmp
parameter_list|,
name|Node
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|tailOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|casHead
specifier|private
name|boolean
name|casHead
parameter_list|(
name|Node
name|cmp
parameter_list|,
name|Node
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapObject
argument_list|(
name|this
argument_list|,
name|headOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
DECL|method|casSweepVotes
specifier|private
name|boolean
name|casSweepVotes
parameter_list|(
name|int
name|cmp
parameter_list|,
name|int
name|val
parameter_list|)
block|{
return|return
name|UNSAFE
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|sweepVotesOffset
argument_list|,
name|cmp
argument_list|,
name|val
argument_list|)
return|;
block|}
comment|/*      * Possible values for "how" argument in xfer method.      */
DECL|field|NOW
specifier|private
specifier|static
specifier|final
name|int
name|NOW
init|=
literal|0
decl_stmt|;
comment|// for untimed poll, tryTransfer
DECL|field|ASYNC
specifier|private
specifier|static
specifier|final
name|int
name|ASYNC
init|=
literal|1
decl_stmt|;
comment|// for offer, put, add
DECL|field|SYNC
specifier|private
specifier|static
specifier|final
name|int
name|SYNC
init|=
literal|2
decl_stmt|;
comment|// for transfer, take
DECL|field|TIMED
specifier|private
specifier|static
specifier|final
name|int
name|TIMED
init|=
literal|3
decl_stmt|;
comment|// for timed poll, tryTransfer
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|cast
specifier|static
parameter_list|<
name|E
parameter_list|>
name|E
name|cast
parameter_list|(
name|Object
name|item
parameter_list|)
block|{
comment|// assert item == null || item.getClass() != Node.class;
return|return
operator|(
name|E
operator|)
name|item
return|;
block|}
comment|/**      * Implements all queuing methods. See above for explanation.      *      * @param e the item or null for take      * @param haveData true if this is a put, else a take      * @param how NOW, ASYNC, SYNC, or TIMED      * @param nanos timeout in nanosecs, used only if mode is TIMED      * @return an item if matched, else e      * @throws NullPointerException if haveData mode but e is null      */
DECL|method|xfer
specifier|private
name|E
name|xfer
parameter_list|(
name|E
name|e
parameter_list|,
name|boolean
name|haveData
parameter_list|,
name|int
name|how
parameter_list|,
name|long
name|nanos
parameter_list|)
block|{
if|if
condition|(
name|haveData
operator|&&
operator|(
name|e
operator|==
literal|null
operator|)
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|Node
name|s
init|=
literal|null
decl_stmt|;
comment|// the node to append, if needed
name|retry
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// restart on append race
for|for
control|(
name|Node
name|h
init|=
name|head
init|,
name|p
init|=
name|h
init|;
name|p
operator|!=
literal|null
condition|;
control|)
block|{
comment|// find& match first node
name|boolean
name|isData
init|=
name|p
operator|.
name|isData
decl_stmt|;
name|Object
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
name|p
operator|&&
operator|(
name|item
operator|!=
literal|null
operator|)
operator|==
name|isData
condition|)
block|{
comment|// unmatched
if|if
condition|(
name|isData
operator|==
name|haveData
condition|)
comment|// can't match
break|break;
if|if
condition|(
name|p
operator|.
name|casItem
argument_list|(
name|item
argument_list|,
name|e
argument_list|)
condition|)
block|{
comment|// match
for|for
control|(
name|Node
name|q
init|=
name|p
init|;
name|q
operator|!=
name|h
condition|;
control|)
block|{
name|Node
name|n
init|=
name|q
operator|.
name|next
decl_stmt|;
comment|// update by 2 unless singleton
if|if
condition|(
name|head
operator|==
name|h
operator|&&
name|casHead
argument_list|(
name|h
argument_list|,
name|n
operator|==
literal|null
condition|?
name|q
else|:
name|n
argument_list|)
condition|)
block|{
name|h
operator|.
name|forgetNext
argument_list|()
expr_stmt|;
break|break;
block|}
comment|// advance and retry
if|if
condition|(
operator|(
name|h
operator|=
name|head
operator|)
operator|==
literal|null
operator|||
operator|(
name|q
operator|=
name|h
operator|.
name|next
operator|)
operator|==
literal|null
operator|||
operator|!
name|q
operator|.
name|isMatched
argument_list|()
condition|)
break|break;
comment|// unless slack< 2
block|}
name|LockSupport
operator|.
name|unpark
argument_list|(
name|p
operator|.
name|waiter
argument_list|)
expr_stmt|;
return|return
name|LinkedTransferQueue
operator|.
expr|<
name|E
operator|>
name|cast
argument_list|(
name|item
argument_list|)
return|;
block|}
block|}
name|Node
name|n
init|=
name|p
operator|.
name|next
decl_stmt|;
name|p
operator|=
operator|(
name|p
operator|!=
name|n
operator|)
condition|?
name|n
else|:
operator|(
name|h
operator|=
name|head
operator|)
expr_stmt|;
comment|// Use head if p offlist
block|}
if|if
condition|(
name|how
operator|!=
name|NOW
condition|)
block|{
comment|// No matches available
if|if
condition|(
name|s
operator|==
literal|null
condition|)
name|s
operator|=
operator|new
name|Node
argument_list|(
name|e
argument_list|,
name|haveData
argument_list|)
expr_stmt|;
name|Node
name|pred
init|=
name|tryAppend
argument_list|(
name|s
argument_list|,
name|haveData
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred
operator|==
literal|null
condition|)
continue|continue
name|retry
continue|;
comment|// lost race vs opposite mode
if|if
condition|(
name|how
operator|!=
name|ASYNC
condition|)
return|return
name|awaitMatch
argument_list|(
name|s
argument_list|,
name|pred
argument_list|,
name|e
argument_list|,
operator|(
name|how
operator|==
name|TIMED
operator|)
argument_list|,
name|nanos
argument_list|)
return|;
block|}
return|return
name|e
return|;
comment|// not waiting
block|}
block|}
comment|/**      * Tries to append node s as tail.      *      * @param s the node to append      * @param haveData true if appending in data mode      * @return null on failure due to losing race with append in      * different mode, else s's predecessor, or s itself if no      * predecessor      */
DECL|method|tryAppend
specifier|private
name|Node
name|tryAppend
parameter_list|(
name|Node
name|s
parameter_list|,
name|boolean
name|haveData
parameter_list|)
block|{
for|for
control|(
name|Node
name|t
init|=
name|tail
init|,
name|p
init|=
name|t
init|;
condition|;
control|)
block|{
comment|// move p to last node and append
name|Node
name|n
decl_stmt|,
name|u
decl_stmt|;
comment|// temps for reads of next& tail
if|if
condition|(
name|p
operator|==
literal|null
operator|&&
operator|(
name|p
operator|=
name|head
operator|)
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|casHead
argument_list|(
literal|null
argument_list|,
name|s
argument_list|)
condition|)
return|return
name|s
return|;
comment|// initialize
block|}
elseif|else
if|if
condition|(
name|p
operator|.
name|cannotPrecede
argument_list|(
name|haveData
argument_list|)
condition|)
return|return
literal|null
return|;
comment|// lost race vs opposite mode
elseif|else
if|if
condition|(
operator|(
name|n
operator|=
name|p
operator|.
name|next
operator|)
operator|!=
literal|null
condition|)
comment|// not last; keep traversing
name|p
operator|=
name|p
operator|!=
name|t
operator|&&
name|t
operator|!=
operator|(
name|u
operator|=
name|tail
operator|)
condition|?
operator|(
name|t
operator|=
name|u
operator|)
else|:
comment|// stale tail
operator|(
name|p
operator|!=
name|n
operator|)
condition|?
name|n
else|:
literal|null
expr_stmt|;
comment|// restart if off list
elseif|else
if|if
condition|(
operator|!
name|p
operator|.
name|casNext
argument_list|(
literal|null
argument_list|,
name|s
argument_list|)
condition|)
name|p
operator|=
name|p
operator|.
name|next
expr_stmt|;
comment|// re-read on CAS failure
else|else
block|{
if|if
condition|(
name|p
operator|!=
name|t
condition|)
block|{
comment|// update if slack now>= 2
while|while
condition|(
operator|(
name|tail
operator|!=
name|t
operator|||
operator|!
name|casTail
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
operator|)
operator|&&
operator|(
name|t
operator|=
name|tail
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|t
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
comment|// advance and retry
operator|(
name|s
operator|=
name|s
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
name|s
operator|!=
name|t
condition|)
empty_stmt|;
block|}
return|return
name|p
return|;
block|}
block|}
block|}
comment|/**      * Spins/yields/blocks until node s is matched or caller gives up.      *      * @param s the waiting node      * @param pred the predecessor of s, or s itself if it has no      * predecessor, or null if unknown (the null case does not occur      * in any current calls but may in possible future extensions)      * @param e the comparison value for checking match      * @param timed if true, wait only until timeout elapses      * @param nanos timeout in nanosecs, used only if timed is true      * @return matched item, or e if unmatched on interrupt or timeout      */
DECL|method|awaitMatch
specifier|private
name|E
name|awaitMatch
parameter_list|(
name|Node
name|s
parameter_list|,
name|Node
name|pred
parameter_list|,
name|E
name|e
parameter_list|,
name|boolean
name|timed
parameter_list|,
name|long
name|nanos
parameter_list|)
block|{
name|long
name|lastTime
init|=
name|timed
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0L
decl_stmt|;
name|Thread
name|w
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|int
name|spins
init|=
operator|-
literal|1
decl_stmt|;
comment|// initialized after first item and cancel checks
name|ThreadLocalRandom
name|randomYields
init|=
literal|null
decl_stmt|;
comment|// bound if needed
for|for
control|(
init|;
condition|;
control|)
block|{
name|Object
name|item
init|=
name|s
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|item
operator|!=
name|e
condition|)
block|{
comment|// matched
comment|// assert item != s;
name|s
operator|.
name|forgetContents
argument_list|()
expr_stmt|;
comment|// avoid garbage
return|return
name|LinkedTransferQueue
operator|.
expr|<
name|E
operator|>
name|cast
argument_list|(
name|item
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|w
operator|.
name|isInterrupted
argument_list|()
operator|||
operator|(
name|timed
operator|&&
name|nanos
operator|<=
literal|0
operator|)
operator|)
operator|&&
name|s
operator|.
name|casItem
argument_list|(
name|e
argument_list|,
name|s
argument_list|)
condition|)
block|{
comment|// cancel
name|unsplice
argument_list|(
name|pred
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
if|if
condition|(
name|spins
operator|<
literal|0
condition|)
block|{
comment|// establish spins at/near front
if|if
condition|(
operator|(
name|spins
operator|=
name|spinsFor
argument_list|(
name|pred
argument_list|,
name|s
operator|.
name|isData
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|randomYields
operator|=
name|ThreadLocalRandom
operator|.
name|current
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|>
literal|0
condition|)
block|{
comment|// spin
operator|--
name|spins
expr_stmt|;
if|if
condition|(
name|randomYields
operator|.
name|nextInt
argument_list|(
name|CHAINED_SPINS
argument_list|)
operator|==
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// occasionally yield
block|}
elseif|else
if|if
condition|(
name|s
operator|.
name|waiter
operator|==
literal|null
condition|)
block|{
name|s
operator|.
name|waiter
operator|=
name|w
expr_stmt|;
comment|// request unpark then recheck
block|}
elseif|else
if|if
condition|(
name|timed
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|nanos
operator|-=
name|now
operator|-
name|lastTime
operator|)
operator|>
literal|0
condition|)
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
name|lastTime
operator|=
name|now
expr_stmt|;
block|}
else|else
block|{
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Returns spin/yield value for a node with given predecessor and      * data mode. See above for explanation.      */
DECL|method|spinsFor
specifier|private
specifier|static
name|int
name|spinsFor
parameter_list|(
name|Node
name|pred
parameter_list|,
name|boolean
name|haveData
parameter_list|)
block|{
if|if
condition|(
name|MP
operator|&&
name|pred
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|pred
operator|.
name|isData
operator|!=
name|haveData
condition|)
comment|// phase change
return|return
name|FRONT_SPINS
operator|+
name|CHAINED_SPINS
return|;
if|if
condition|(
name|pred
operator|.
name|isMatched
argument_list|()
condition|)
comment|// probably at front
return|return
name|FRONT_SPINS
return|;
if|if
condition|(
name|pred
operator|.
name|waiter
operator|==
literal|null
condition|)
comment|// pred apparently spinning
return|return
name|CHAINED_SPINS
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/* -------------- Traversal methods -------------- */
comment|/**      * Returns the successor of p, or the head node if p.next has been      * linked to self, which will only be true if traversing with a      * stale pointer that is now off the list.      */
DECL|method|succ
specifier|final
name|Node
name|succ
parameter_list|(
name|Node
name|p
parameter_list|)
block|{
name|Node
name|next
init|=
name|p
operator|.
name|next
decl_stmt|;
return|return
operator|(
name|p
operator|==
name|next
operator|)
condition|?
name|head
else|:
name|next
return|;
block|}
comment|/**      * Returns the first unmatched node of the given mode, or null if      * none.  Used by methods isEmpty, hasWaitingConsumer.      */
DECL|method|firstOfMode
specifier|private
name|Node
name|firstOfMode
parameter_list|(
name|boolean
name|isData
parameter_list|)
block|{
for|for
control|(
name|Node
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|.
name|isMatched
argument_list|()
condition|)
return|return
operator|(
name|p
operator|.
name|isData
operator|==
name|isData
operator|)
condition|?
name|p
else|:
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Returns the item in the first unmatched node with isData; or      * null if none.  Used by peek.      */
DECL|method|firstDataItem
specifier|private
name|E
name|firstDataItem
parameter_list|()
block|{
for|for
control|(
name|Node
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|Object
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isData
condition|)
block|{
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|item
operator|!=
name|p
condition|)
return|return
name|LinkedTransferQueue
operator|.
expr|<
name|E
operator|>
name|cast
argument_list|(
name|item
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|item
operator|==
literal|null
condition|)
return|return
literal|null
return|;
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Traverses and counts unmatched nodes of the given mode.      * Used by methods size and getWaitingConsumerCount.      */
DECL|method|countOfMode
specifier|private
name|int
name|countOfMode
parameter_list|(
name|boolean
name|data
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Node
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|.
name|isMatched
argument_list|()
condition|)
block|{
if|if
condition|(
name|p
operator|.
name|isData
operator|!=
name|data
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|++
name|count
operator|==
name|Integer
operator|.
name|MAX_VALUE
condition|)
comment|// saturated
break|break;
block|}
name|Node
name|n
init|=
name|p
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|n
operator|!=
name|p
condition|)
name|p
operator|=
name|n
expr_stmt|;
else|else
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|head
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
DECL|class|Itr
specifier|final
class|class
name|Itr
implements|implements
name|Iterator
argument_list|<
name|E
argument_list|>
block|{
DECL|field|nextNode
specifier|private
name|Node
name|nextNode
decl_stmt|;
comment|// next node to return item for
DECL|field|nextItem
specifier|private
name|E
name|nextItem
decl_stmt|;
comment|// the corresponding item
DECL|field|lastRet
specifier|private
name|Node
name|lastRet
decl_stmt|;
comment|// last returned node, to support remove
DECL|field|lastPred
specifier|private
name|Node
name|lastPred
decl_stmt|;
comment|// predecessor to unlink lastRet
comment|/**          * Moves to next node after prev, or first node if prev null.          */
DECL|method|advance
specifier|private
name|void
name|advance
parameter_list|(
name|Node
name|prev
parameter_list|)
block|{
comment|/*              * To track and avoid buildup of deleted nodes in the face              * of calls to both Queue.remove and Itr.remove, we must              * include variants of unsplice and sweep upon each              * advance: Upon Itr.remove, we may need to catch up links              * from lastPred, and upon other removes, we might need to              * skip ahead from stale nodes and unsplice deleted ones              * found while advancing.              */
name|Node
name|r
decl_stmt|,
name|b
decl_stmt|;
comment|// reset lastPred upon possible deletion of lastRet
if|if
condition|(
operator|(
name|r
operator|=
name|lastRet
operator|)
operator|!=
literal|null
operator|&&
operator|!
name|r
operator|.
name|isMatched
argument_list|()
condition|)
name|lastPred
operator|=
name|r
expr_stmt|;
comment|// next lastPred is old lastRet
elseif|else
if|if
condition|(
operator|(
name|b
operator|=
name|lastPred
operator|)
operator|==
literal|null
operator|||
name|b
operator|.
name|isMatched
argument_list|()
condition|)
name|lastPred
operator|=
literal|null
expr_stmt|;
comment|// at start of list
else|else
block|{
name|Node
name|s
decl_stmt|,
name|n
decl_stmt|;
comment|// help with removal of lastPred.next
while|while
condition|(
operator|(
name|s
operator|=
name|b
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
name|s
operator|!=
name|b
operator|&&
name|s
operator|.
name|isMatched
argument_list|()
operator|&&
operator|(
name|n
operator|=
name|s
operator|.
name|next
operator|)
operator|!=
literal|null
operator|&&
name|n
operator|!=
name|s
condition|)
name|b
operator|.
name|casNext
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|lastRet
operator|=
name|prev
expr_stmt|;
for|for
control|(
name|Node
name|p
init|=
name|prev
init|,
name|s
init|,
name|n
init|;
condition|;
control|)
block|{
name|s
operator|=
operator|(
name|p
operator|==
literal|null
operator|)
condition|?
name|head
else|:
name|p
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|null
condition|)
break|break;
elseif|else
if|if
condition|(
name|s
operator|==
name|p
condition|)
block|{
name|p
operator|=
literal|null
expr_stmt|;
continue|continue;
block|}
name|Object
name|item
init|=
name|s
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|s
operator|.
name|isData
condition|)
block|{
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|item
operator|!=
name|s
condition|)
block|{
name|nextItem
operator|=
name|LinkedTransferQueue
operator|.
expr|<
name|E
operator|>
name|cast
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|nextNode
operator|=
name|s
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|item
operator|==
literal|null
condition|)
break|break;
comment|// assert s.isMatched();
if|if
condition|(
name|p
operator|==
literal|null
condition|)
name|p
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|n
operator|=
name|s
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
break|break;
elseif|else
if|if
condition|(
name|s
operator|==
name|n
condition|)
name|p
operator|=
literal|null
expr_stmt|;
else|else
name|p
operator|.
name|casNext
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|nextNode
operator|=
literal|null
expr_stmt|;
name|nextItem
operator|=
literal|null
expr_stmt|;
block|}
DECL|method|Itr
name|Itr
parameter_list|()
block|{
name|advance
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
DECL|method|hasNext
specifier|public
specifier|final
name|boolean
name|hasNext
parameter_list|()
block|{
return|return
name|nextNode
operator|!=
literal|null
return|;
block|}
DECL|method|next
specifier|public
specifier|final
name|E
name|next
parameter_list|()
block|{
name|Node
name|p
init|=
name|nextNode
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NoSuchElementException
argument_list|()
throw|;
name|E
name|e
init|=
name|nextItem
decl_stmt|;
name|advance
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
DECL|method|remove
specifier|public
specifier|final
name|void
name|remove
parameter_list|()
block|{
specifier|final
name|Node
name|lastRet
init|=
name|this
operator|.
name|lastRet
decl_stmt|;
if|if
condition|(
name|lastRet
operator|==
literal|null
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|()
throw|;
name|this
operator|.
name|lastRet
operator|=
literal|null
expr_stmt|;
if|if
condition|(
name|lastRet
operator|.
name|tryMatchData
argument_list|()
condition|)
name|unsplice
argument_list|(
name|lastPred
argument_list|,
name|lastRet
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* -------------- Removal methods -------------- */
comment|/**      * Unsplices (now or later) the given deleted/cancelled node with      * the given predecessor.      *      * @param pred a node that was at one time known to be the      * predecessor of s, or null or s itself if s is/was at head      * @param s the node to be unspliced      */
DECL|method|unsplice
specifier|final
name|void
name|unsplice
parameter_list|(
name|Node
name|pred
parameter_list|,
name|Node
name|s
parameter_list|)
block|{
name|s
operator|.
name|forgetContents
argument_list|()
expr_stmt|;
comment|// forget unneeded fields
comment|/*          * See above for rationale. Briefly: if pred still points to          * s, try to unlink s.  If s cannot be unlinked, because it is          * trailing node or pred might be unlinked, and neither pred          * nor s are head or offlist, add to sweepVotes, and if enough          * votes have accumulated, sweep.          */
if|if
condition|(
name|pred
operator|!=
literal|null
operator|&&
name|pred
operator|!=
name|s
operator|&&
name|pred
operator|.
name|next
operator|==
name|s
condition|)
block|{
name|Node
name|n
init|=
name|s
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|null
operator|||
operator|(
name|n
operator|!=
name|s
operator|&&
name|pred
operator|.
name|casNext
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
operator|&&
name|pred
operator|.
name|isMatched
argument_list|()
operator|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// check if at, or could be, head
name|Node
name|h
init|=
name|head
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|pred
operator|||
name|h
operator|==
name|s
operator|||
name|h
operator|==
literal|null
condition|)
return|return;
comment|// at head or list empty
if|if
condition|(
operator|!
name|h
operator|.
name|isMatched
argument_list|()
condition|)
break|break;
name|Node
name|hn
init|=
name|h
operator|.
name|next
decl_stmt|;
if|if
condition|(
name|hn
operator|==
literal|null
condition|)
return|return;
comment|// now empty
if|if
condition|(
name|hn
operator|!=
name|h
operator|&&
name|casHead
argument_list|(
name|h
argument_list|,
name|hn
argument_list|)
condition|)
name|h
operator|.
name|forgetNext
argument_list|()
expr_stmt|;
comment|// advance head
block|}
if|if
condition|(
name|pred
operator|.
name|next
operator|!=
name|pred
operator|&&
name|s
operator|.
name|next
operator|!=
name|s
condition|)
block|{
comment|// recheck if offlist
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// sweep now if enough votes
name|int
name|v
init|=
name|sweepVotes
decl_stmt|;
if|if
condition|(
name|v
operator|<
name|SWEEP_THRESHOLD
condition|)
block|{
if|if
condition|(
name|casSweepVotes
argument_list|(
name|v
argument_list|,
name|v
operator|+
literal|1
argument_list|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|casSweepVotes
argument_list|(
name|v
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|sweep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/**      * Unlinks matched (typically cancelled) nodes encountered in a      * traversal from head.      */
DECL|method|sweep
specifier|private
name|void
name|sweep
parameter_list|()
block|{
for|for
control|(
name|Node
name|p
init|=
name|head
init|,
name|s
init|,
name|n
init|;
name|p
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|p
operator|.
name|next
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|s
operator|.
name|isMatched
argument_list|()
condition|)
comment|// Unmatched nodes are never self-linked
name|p
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|n
operator|=
name|s
operator|.
name|next
operator|)
operator|==
literal|null
condition|)
comment|// trailing node is pinned
break|break;
elseif|else
if|if
condition|(
name|s
operator|==
name|n
condition|)
comment|// stale
comment|// No need to also check for p == s, since that implies s == n
name|p
operator|=
name|head
expr_stmt|;
else|else
name|p
operator|.
name|casNext
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Main implementation of remove(Object)      */
DECL|method|findAndRemove
specifier|private
name|boolean
name|findAndRemove
parameter_list|(
name|Object
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|Node
name|pred
init|=
literal|null
init|,
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
control|)
block|{
name|Object
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isData
condition|)
block|{
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|item
operator|!=
name|p
operator|&&
name|e
operator|.
name|equals
argument_list|(
name|item
argument_list|)
operator|&&
name|p
operator|.
name|tryMatchData
argument_list|()
condition|)
block|{
name|unsplice
argument_list|(
name|pred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|item
operator|==
literal|null
condition|)
break|break;
name|pred
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|p
operator|.
name|next
operator|)
operator|==
name|pred
condition|)
block|{
comment|// stale
name|pred
operator|=
literal|null
expr_stmt|;
name|p
operator|=
name|head
expr_stmt|;
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Creates an initially empty {@code LinkedTransferQueue}.      */
DECL|method|LinkedTransferQueue
specifier|public
name|LinkedTransferQueue
parameter_list|()
block|{     }
comment|/**      * Creates a {@code LinkedTransferQueue}      * initially containing the elements of the given collection,      * added in traversal order of the collection's iterator.      *      * @param c the collection of elements to initially contain      * @throws NullPointerException if the specified collection or any      *         of its elements are null      */
DECL|method|LinkedTransferQueue
specifier|public
name|LinkedTransferQueue
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|E
argument_list|>
name|c
parameter_list|)
block|{
name|this
argument_list|()
expr_stmt|;
name|addAll
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inserts the specified element at the tail of this queue.      * As the queue is unbounded, this method will never block.      *      * @throws NullPointerException if the specified element is null      */
DECL|method|put
specifier|public
name|void
name|put
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|xfer
argument_list|(
name|e
argument_list|,
literal|true
argument_list|,
name|ASYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Inserts the specified element at the tail of this queue.      * As the queue is unbounded, this method will never block or      * return {@code false}.      *      * @return {@code true} (as specified by      *  {@link java.util.concurrent.BlockingQueue#offer(Object,long,TimeUnit)      *  BlockingQueue.offer})      * @throws NullPointerException if the specified element is null      */
DECL|method|offer
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|xfer
argument_list|(
name|e
argument_list|,
literal|true
argument_list|,
name|ASYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Inserts the specified element at the tail of this queue.      * As the queue is unbounded, this method will never return {@code false}.      *      * @return {@code true} (as specified by {@link Queue#offer})      * @throws NullPointerException if the specified element is null      */
DECL|method|offer
specifier|public
name|boolean
name|offer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|xfer
argument_list|(
name|e
argument_list|,
literal|true
argument_list|,
name|ASYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Inserts the specified element at the tail of this queue.      * As the queue is unbounded, this method will never throw      * {@link IllegalStateException} or return {@code false}.      *      * @return {@code true} (as specified by {@link Collection#add})      * @throws NullPointerException if the specified element is null      */
DECL|method|add
specifier|public
name|boolean
name|add
parameter_list|(
name|E
name|e
parameter_list|)
block|{
name|xfer
argument_list|(
name|e
argument_list|,
literal|true
argument_list|,
name|ASYNC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|/**      * Transfers the element to a waiting consumer immediately, if possible.      *      *<p>More precisely, transfers the specified element immediately      * if there exists a consumer already waiting to receive it (in      * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),      * otherwise returning {@code false} without enqueuing the element.      *      * @throws NullPointerException if the specified element is null      */
DECL|method|tryTransfer
specifier|public
name|boolean
name|tryTransfer
parameter_list|(
name|E
name|e
parameter_list|)
block|{
return|return
name|xfer
argument_list|(
name|e
argument_list|,
literal|true
argument_list|,
name|NOW
argument_list|,
literal|0
argument_list|)
operator|==
literal|null
return|;
block|}
comment|/**      * Transfers the element to a consumer, waiting if necessary to do so.      *      *<p>More precisely, transfers the specified element immediately      * if there exists a consumer already waiting to receive it (in      * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),      * else inserts the specified element at the tail of this queue      * and waits until the element is received by a consumer.      *      * @throws NullPointerException if the specified element is null      */
DECL|method|transfer
specifier|public
name|void
name|transfer
parameter_list|(
name|E
name|e
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|xfer
argument_list|(
name|e
argument_list|,
literal|true
argument_list|,
name|SYNC
argument_list|,
literal|0
argument_list|)
operator|!=
literal|null
condition|)
block|{
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
comment|// failure possible only due to interrupt
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
block|}
comment|/**      * Transfers the element to a consumer if it is possible to do so      * before the timeout elapses.      *      *<p>More precisely, transfers the specified element immediately      * if there exists a consumer already waiting to receive it (in      * {@link #take} or timed {@link #poll(long,TimeUnit) poll}),      * else inserts the specified element at the tail of this queue      * and waits until the element is received by a consumer,      * returning {@code false} if the specified wait time elapses      * before the element can be transferred.      *      * @throws NullPointerException if the specified element is null      */
DECL|method|tryTransfer
specifier|public
name|boolean
name|tryTransfer
parameter_list|(
name|E
name|e
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|xfer
argument_list|(
name|e
argument_list|,
literal|true
argument_list|,
name|TIMED
argument_list|,
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
argument_list|)
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
return|return
literal|false
return|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
DECL|method|take
specifier|public
name|E
name|take
parameter_list|()
throws|throws
name|InterruptedException
block|{
name|E
name|e
init|=
name|xfer
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|SYNC
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
condition|)
return|return
name|e
return|;
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
DECL|method|poll
specifier|public
name|E
name|poll
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|E
name|e
init|=
name|xfer
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|TIMED
argument_list|,
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|!=
literal|null
operator|||
operator|!
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
return|return
name|e
return|;
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
DECL|method|poll
specifier|public
name|E
name|poll
parameter_list|()
block|{
return|return
name|xfer
argument_list|(
literal|null
argument_list|,
literal|false
argument_list|,
name|NOW
argument_list|,
literal|0
argument_list|)
return|;
block|}
comment|/**      * @throws NullPointerException     {@inheritDoc}      * @throws IllegalArgumentException {@inheritDoc}      */
DECL|method|drainTo
specifier|public
name|int
name|drainTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|c
operator|==
name|this
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
init|;
operator|(
name|e
operator|=
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|c
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/**      * @throws NullPointerException     {@inheritDoc}      * @throws IllegalArgumentException {@inheritDoc}      */
DECL|method|drainTo
specifier|public
name|int
name|drainTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|E
argument_list|>
name|c
parameter_list|,
name|int
name|maxElements
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|c
operator|==
name|this
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|E
name|e
init|;
name|n
operator|<
name|maxElements
operator|&&
operator|(
name|e
operator|=
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
block|{
name|c
operator|.
name|add
argument_list|(
name|e
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
comment|/**      * Returns an iterator over the elements in this queue in proper sequence.      * The elements will be returned in order from first (head) to last (tail).      *      *<p>The returned iterator is a "weakly consistent" iterator that      * will never throw {@link java.util.ConcurrentModificationException      * ConcurrentModificationException}, and guarantees to traverse      * elements as they existed upon construction of the iterator, and      * may (but is not guaranteed to) reflect any modifications      * subsequent to construction.      *      * @return an iterator over the elements in this queue in proper sequence      */
DECL|method|iterator
specifier|public
name|Iterator
argument_list|<
name|E
argument_list|>
name|iterator
parameter_list|()
block|{
return|return
operator|new
name|Itr
argument_list|()
return|;
block|}
DECL|method|peek
specifier|public
name|E
name|peek
parameter_list|()
block|{
return|return
name|firstDataItem
argument_list|()
return|;
block|}
comment|/**      * Returns {@code true} if this queue contains no elements.      *      * @return {@code true} if this queue contains no elements      */
DECL|method|isEmpty
specifier|public
name|boolean
name|isEmpty
parameter_list|()
block|{
for|for
control|(
name|Node
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|p
operator|.
name|isMatched
argument_list|()
condition|)
return|return
operator|!
name|p
operator|.
name|isData
return|;
block|}
return|return
literal|true
return|;
block|}
DECL|method|hasWaitingConsumer
specifier|public
name|boolean
name|hasWaitingConsumer
parameter_list|()
block|{
return|return
name|firstOfMode
argument_list|(
literal|false
argument_list|)
operator|!=
literal|null
return|;
block|}
comment|/**      * Returns the number of elements in this queue.  If this queue      * contains more than {@code Integer.MAX_VALUE} elements, returns      * {@code Integer.MAX_VALUE}.      *      *<p>Beware that, unlike in most collections, this method is      *<em>NOT</em> a constant-time operation. Because of the      * asynchronous nature of these queues, determining the current      * number of elements requires an O(n) traversal.      *      * @return the number of elements in this queue      */
DECL|method|size
specifier|public
name|int
name|size
parameter_list|()
block|{
return|return
name|countOfMode
argument_list|(
literal|true
argument_list|)
return|;
block|}
DECL|method|getWaitingConsumerCount
specifier|public
name|int
name|getWaitingConsumerCount
parameter_list|()
block|{
return|return
name|countOfMode
argument_list|(
literal|false
argument_list|)
return|;
block|}
comment|/**      * Removes a single instance of the specified element from this queue,      * if it is present.  More formally, removes an element {@code e} such      * that {@code o.equals(e)}, if this queue contains one or more such      * elements.      * Returns {@code true} if this queue contained the specified element      * (or equivalently, if this queue changed as a result of the call).      *      * @param o element to be removed from this queue, if present      * @return {@code true} if this queue changed as a result of the call      */
DECL|method|remove
specifier|public
name|boolean
name|remove
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
return|return
name|findAndRemove
argument_list|(
name|o
argument_list|)
return|;
block|}
comment|/**      * Returns {@code true} if this queue contains the specified element.      * More formally, returns {@code true} if and only if this queue contains      * at least one element {@code e} such that {@code o.equals(e)}.      *      * @param o object to be checked for containment in this queue      * @return {@code true} if this queue contains the specified element      */
DECL|method|contains
specifier|public
name|boolean
name|contains
parameter_list|(
name|Object
name|o
parameter_list|)
block|{
if|if
condition|(
name|o
operator|==
literal|null
condition|)
return|return
literal|false
return|;
for|for
control|(
name|Node
name|p
init|=
name|head
init|;
name|p
operator|!=
literal|null
condition|;
name|p
operator|=
name|succ
argument_list|(
name|p
argument_list|)
control|)
block|{
name|Object
name|item
init|=
name|p
operator|.
name|item
decl_stmt|;
if|if
condition|(
name|p
operator|.
name|isData
condition|)
block|{
if|if
condition|(
name|item
operator|!=
literal|null
operator|&&
name|item
operator|!=
name|p
operator|&&
name|o
operator|.
name|equals
argument_list|(
name|item
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|item
operator|==
literal|null
condition|)
break|break;
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Always returns {@code Integer.MAX_VALUE} because a      * {@code LinkedTransferQueue} is not capacity constrained.      *      * @return {@code Integer.MAX_VALUE} (as specified by      *         {@link java.util.concurrent.BlockingQueue#remainingCapacity()      *         BlockingQueue.remainingCapacity})      */
DECL|method|remainingCapacity
specifier|public
name|int
name|remainingCapacity
parameter_list|()
block|{
return|return
name|Integer
operator|.
name|MAX_VALUE
return|;
block|}
comment|/**      * Saves the state to a stream (that is, serializes it).      *      * @serialData All of the elements (each an {@code E}) in      * the proper order, followed by a null      * @param s the stream      */
DECL|method|writeObject
specifier|private
name|void
name|writeObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectOutputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
block|{
name|s
operator|.
name|defaultWriteObject
argument_list|()
expr_stmt|;
for|for
control|(
name|E
name|e
range|:
name|this
control|)
name|s
operator|.
name|writeObject
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|// Use trailing null as sentinel
name|s
operator|.
name|writeObject
argument_list|(
literal|null
argument_list|)
expr_stmt|;
block|}
comment|/**      * Reconstitutes the Queue instance from a stream (that is,      * deserializes it).      *      * @param s the stream      */
DECL|method|readObject
specifier|private
name|void
name|readObject
parameter_list|(
name|java
operator|.
name|io
operator|.
name|ObjectInputStream
name|s
parameter_list|)
throws|throws
name|java
operator|.
name|io
operator|.
name|IOException
throws|,
name|ClassNotFoundException
block|{
name|s
operator|.
name|defaultReadObject
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
name|E
name|item
init|=
operator|(
name|E
operator|)
name|s
operator|.
name|readObject
argument_list|()
decl_stmt|;
if|if
condition|(
name|item
operator|==
literal|null
condition|)
break|break;
else|else
name|offer
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|headOffset
specifier|private
specifier|static
specifier|final
name|long
name|headOffset
decl_stmt|;
DECL|field|tailOffset
specifier|private
specifier|static
specifier|final
name|long
name|tailOffset
decl_stmt|;
DECL|field|sweepVotesOffset
specifier|private
specifier|static
specifier|final
name|long
name|sweepVotesOffset
decl_stmt|;
static|static
block|{
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|LinkedTransferQueue
operator|.
name|class
decl_stmt|;
name|headOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"head"
argument_list|)
argument_list|)
expr_stmt|;
name|tailOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"tail"
argument_list|)
argument_list|)
expr_stmt|;
name|sweepVotesOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"sweepVotes"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

