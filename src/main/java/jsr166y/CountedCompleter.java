begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166y
package|package
name|jsr166y
package|;
end_package

begin_comment
comment|/**  * A resultless {@link ForkJoinTask} with a completion action  * performed when triggered and there are no remaining pending  * actions. Uses of CountedCompleter are similar to those of other  * completion based components (such as {@link  * java.nio.channels.CompletionHandler}) except that multiple  *<em>pending</em> completions may be necessary to trigger the {@link  * #onCompletion} action, not just one. Unless initialized otherwise,  * the {@link #getPendingCount pending count} starts at zero, but may  * be (atomically) changed using methods {@link #setPendingCount},  * {@link #addToPendingCount}, and {@link  * #compareAndSetPendingCount}. Upon invocation of {@link  * #tryComplete}, if the pending action count is nonzero, it is  * decremented; otherwise, the completion action is performed, and if  * this completer itself has a completer, the process is continued  * with its completer.  As is the case with related synchronization  * components such as {@link Phaser} and {@link  * java.util.concurrent.Semaphore} these methods affect only internal  * counts; they do not establish any further internal bookkeeping. In  * particular, the identities of pending tasks are not maintained. As  * illustrated below, you can create subclasses that do record some or  * all pended tasks or their results when needed.  *  *<p>A concrete CountedCompleter class must define method {@link  * #compute}, that should, in almost all use cases, invoke {@code  * tryComplete()} once before returning. The class may also optionally  * override method {@link #onCompletion} to perform an action upon  * normal completion, and method {@link #onExceptionalCompletion} to  * perform an action upon any exception.  *  *<p>A CountedCompleter that does not itself have a completer (i.e.,  * one for which {@link #getCompleter} returns {@code null}) can be  * used as a regular ForkJoinTask with this added functionality.  * However, any completer that in turn has another completer serves  * only as an internal helper for other computations, so its own task  * status (as reported in methods such as {@link ForkJoinTask#isDone})  * is arbitrary; this status changes only upon explicit invocations of  * {@link #complete}, {@link ForkJoinTask#cancel}, {@link  * ForkJoinTask#completeExceptionally} or upon exceptional completion  * of method {@code compute}. Upon any exceptional completion, the  * exception may be relayed to a task's completer (and its completer,  * and so on), if one exists and it has not otherwise already  * completed.  *  *<p><b>Sample Usages.</b>  *  *<p><b>Parallel recursive decomposition.</b> CountedCompleters may  * be arranged in trees similar to those often used with {@link  * RecursiveAction}s, although the constructions involved in setting  * them up typically vary. Even though they entail a bit more  * bookkeeping, CountedCompleters may be better choices when applying  * a possibly time-consuming operation (that cannot be further  * subdivided) to each element of an array or collection; especially  * when the operation takes a significantly different amount of time  * to complete for some elements than others, either because of  * intrinsic variation (for example IO) or auxiliary effects such as  * garbage collection.  Because CountedCompleters provide their own  * continuations, other threads need not block waiting to perform  * them.  *  *<p> For example, here is an initial version of a class that uses  * divide-by-two recursive decomposition to divide work into single  * pieces (leaf tasks). Even when work is split into individual calls,  * tree-based techniques are usually preferable to directly forking  * leaf tasks, because they reduce inter-thread communication and  * improve load balancing. In the recursive case, the second of each  * pair of subtasks to finish triggers completion of its parent  * (because no result combination is performed, the default no-op  * implementation of method {@code onCompletion} is not overridden). A  * static utility method sets up the base task and invokes it:  *  *<pre> {@code  * class MyOperation<E> { void apply(E e) { ... }  }  *  * class ForEach<E> extends CountedCompleter {  *  *     public static<E> void forEach(ForkJoinPool pool, E[] array, MyOperation<E> op) {  *         pool.invoke(new ForEach<E>(null, array, op, 0, array.length));  *     }  *  *     final E[] array; final MyOperation<E> op; final int lo, hi;  *     ForEach(CountedCompleter p, E[] array, MyOperation<E> op, int lo, int hi) {  *         super(p);  *         this.array = array; this.op = op; this.lo = lo; this.hi = hi;  *     }  *  *     public void compute() { // version 1  *         if (hi - lo>= 2) {  *             int mid = (lo + hi)>>> 1;  *             setPendingCount(2); // must set pending count before fork  *             new ForEach(this, array, op, mid, hi).fork(); // right child  *             new ForEach(this, array, op, lo, mid).fork(); // left child  *         }  *         else if (hi> lo)  *             op.apply(array[lo]);  *         tryComplete();  *     }  * } }</pre>  *  * This design can be improved by noticing that in the recursive case,  * the task has nothing to do after forking its right task, so can  * directly invoke its left task before returning. (This is an analog  * of tail recursion removal.)  Also, because the task returns upon  * executing its left task (rather than falling through to invoke  * tryComplete) the pending count is set to one:  *  *<pre> {@code  * class ForEach<E> ...  *     public void compute() { // version 2  *         if (hi - lo>= 2) {  *             int mid = (lo + hi)>>> 1;  *             setPendingCount(1); // only one pending  *             new ForEach(this, array, op, mid, hi).fork(); // right child  *             new ForEach(this, array, op, lo, mid).compute(); // direct invoke  *         }  *         else {  *             if (hi> lo)  *                 op.apply(array[lo]);  *             tryComplete();  *         }  *     }  * }</pre>  *  * As a further improvement, notice that the left task need not even  * exist.  Instead of creating a new one, we can iterate using the  * original task, and add a pending count for each fork:  *  *<pre> {@code  * class ForEach<E> ...  *     public void compute() { // version 3  *         int l = lo,  h = hi;  *         while (h - l>= 2) {  *             int mid = (l + h)>>> 1;  *             addToPendingCount(1);  *             new ForEach(this, array, op, mid, h).fork(); // right child  *             h = mid;  *         }  *         if (h> l)  *             op.apply(array[l]);  *         tryComplete();  *     }  * }</pre>  *  * Additional improvements of such classes might entail precomputing  * pending counts so that they can be established in constructors,  * specializing classes for leaf steps, subdividing by say, four,  * instead of two per iteration, and using an adaptive threshold  * instead of always subdividing down to single elements.  *  *<p><b>Recording subtasks.</b> CountedCompleter tasks that combine  * results of multiple subtasks usually need to access these results  * in method {@link #onCompletion}. As illustrated in the following  * class (that performs a simplified form of map-reduce where mappings  * and reductions are all of type {@code E}), one way to do this in  * divide and conquer designs is to have each subtask record its  * sibling, so that it can be accessed in method {@code onCompletion}.  * For clarity, this class uses explicit left and right subtasks, but  * variants of other streamlinings seen in the above example may also  * apply.  *  *<pre> {@code  * class MyMapper<E> { E apply(E v) {  ...  } }  * class MyReducer<E> { E apply(E x, E y) {  ...  } }  * class MapReducer<E> extends CountedCompleter {  *     final E[] array; final MyMapper<E> mapper;  *     final MyReducer<E> reducer; final int lo, hi;  *     MapReducer sibling;  *     E result;  *     MapReducer(CountedCompleter p, E[] array, MyMapper<E> mapper,  *                MyReducer<E> reducer, int lo, int hi) {  *         super(p);  *         this.array = array; this.mapper = mapper;  *         this.reducer = reducer; this.lo = lo; this.hi = hi;  *     }  *     public void compute() {  *         if (hi - lo>= 2) {  *             int mid = (lo + hi)>>> 1;  *             MapReducer<E> left = new MapReducer(this, array, mapper, reducer, lo, mid);  *             MapReducer<E> right = new MapReducer(this, array, mapper, reducer, mid, hi);  *             left.sibling = right;  *             right.sibling = left;  *             setPendingCount(1); // only right is pending  *             right.fork();  *             left.compute();     // directly execute left  *         }  *         else {  *             if (hi> lo)  *                 result = mapper.apply(array[lo]);  *             tryComplete();  *         }  *     }  *     public void onCompletion(CountedCompleter caller) {  *         if (caller != this) {  *            MapReducer<E> child = (MapReducer<E>)caller;  *            MapReducer<E> sib = child.sibling;  *            if (sib == null || sib.result == null)  *                result = child.result;  *            else  *                result = reducer.apply(child.result, sib.result);  *         }  *     }  *  *     public static<E> E mapReduce(ForkJoinPool pool, E[] array,  *                                   MyMapper<E> mapper, MyReducer<E> reducer) {  *         MapReducer<E> mr = new MapReducer<E>(null, array, mapper,  *                                              reducer, 0, array.length);  *         pool.invoke(mr);  *         return mr.result;  *     }  * } }</pre>  *  *<p><b>Triggers.</b> Some CountedCompleters are themselves never  * forked, but instead serve as bits of plumbing in other designs;  * including those in which the completion of one of more async tasks  * triggers another async task. For example:  *  *<pre> {@code  * class HeaderBuilder extends CountedCompleter { ... }  * class BodyBuilder extends CountedCompleter { ... }  * class PacketSender extends CountedCompleter {  *     PacketSender(...) { super(null, 1); ... } // trigger on second completion  *     public void compute() { } // never called  *     public void onCompletion(CountedCompleter caller) { sendPacket(); }  * }  * // sample use:  * PacketSender p = new PacketSender();  * new HeaderBuilder(p, ...).fork();  * new BodyBuilder(p, ...).fork();  * }</pre>  *  * @since 1.8  * @author Doug Lea  */
end_comment

begin_class
DECL|class|CountedCompleter
specifier|public
specifier|abstract
class|class
name|CountedCompleter
extends|extends
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
literal|5232453752276485070L
decl_stmt|;
comment|/** This task's completer, or null if none */
DECL|field|completer
specifier|final
name|CountedCompleter
name|completer
decl_stmt|;
comment|/** The number of pending tasks until completion */
DECL|field|pending
specifier|volatile
name|int
name|pending
decl_stmt|;
comment|/**      * Creates a new CountedCompleter with the given completer      * and initial pending count.      *      * @param completer this tasks completer, or {@code null} if none      * @param initialPendingCount the initial pending count      */
DECL|method|CountedCompleter
specifier|protected
name|CountedCompleter
parameter_list|(
name|CountedCompleter
name|completer
parameter_list|,
name|int
name|initialPendingCount
parameter_list|)
block|{
name|this
operator|.
name|completer
operator|=
name|completer
expr_stmt|;
name|this
operator|.
name|pending
operator|=
name|initialPendingCount
expr_stmt|;
block|}
comment|/**      * Creates a new CountedCompleter with the given completer      * and an initial pending count of zero.      *      * @param completer this tasks completer, or {@code null} if none      */
DECL|method|CountedCompleter
specifier|protected
name|CountedCompleter
parameter_list|(
name|CountedCompleter
name|completer
parameter_list|)
block|{
name|this
operator|.
name|completer
operator|=
name|completer
expr_stmt|;
block|}
comment|/**      * Creates a new CountedCompleter with no completer      * and an initial pending count of zero.      */
DECL|method|CountedCompleter
specifier|protected
name|CountedCompleter
parameter_list|()
block|{
name|this
operator|.
name|completer
operator|=
literal|null
expr_stmt|;
block|}
comment|/**      * The main computation performed by this task.      */
DECL|method|compute
specifier|public
specifier|abstract
name|void
name|compute
parameter_list|()
function_decl|;
comment|/**      * Performs an action when method {@link #tryComplete} is invoked      * and there are no pending counts, or when the unconditional      * method {@link #complete} is invoked.  By default, this method      * does nothing.      *      * @param caller the task invoking this method (which may      * be this task itself).      */
DECL|method|onCompletion
specifier|public
name|void
name|onCompletion
parameter_list|(
name|CountedCompleter
name|caller
parameter_list|)
block|{     }
comment|/**      * Performs an action when method {@link #completeExceptionally}      * is invoked or method {@link #compute} throws an exception, and      * this task has not otherwise already completed normally. On      * entry to this method, this task {@link      * ForkJoinTask#isCompletedAbnormally}.  The return value of this      * method controls further propagation: If {@code true} and this      * task has a completer, then this completer is also completed      * exceptionally.  The default implementation of this method does      * nothing except return {@code true}.      *      * @param ex the exception      * @param caller the task invoking this method (which may      * be this task itself).      * @return true if this exception should be propagated to this      * tasks completer, if one exists.      */
DECL|method|onExceptionalCompletion
specifier|public
name|boolean
name|onExceptionalCompletion
parameter_list|(
name|Throwable
name|ex
parameter_list|,
name|CountedCompleter
name|caller
parameter_list|)
block|{
return|return
literal|true
return|;
block|}
comment|/**      * Returns the completer established in this task's constructor,      * or {@code null} if none.      *      * @return the completer      */
DECL|method|getCompleter
specifier|public
specifier|final
name|CountedCompleter
name|getCompleter
parameter_list|()
block|{
return|return
name|completer
return|;
block|}
comment|/**      * Returns the current pending count.      *      * @return the current pending count      */
DECL|method|getPendingCount
specifier|public
specifier|final
name|int
name|getPendingCount
parameter_list|()
block|{
return|return
name|pending
return|;
block|}
comment|/**      * Sets the pending count to the given value.      *      * @param count the count      */
DECL|method|setPendingCount
specifier|public
specifier|final
name|void
name|setPendingCount
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|pending
operator|=
name|count
expr_stmt|;
block|}
comment|/**      * Adds (atomically) the given value to the pending count.      *      * @param delta the value to add      */
DECL|method|addToPendingCount
specifier|public
specifier|final
name|void
name|addToPendingCount
parameter_list|(
name|int
name|delta
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
comment|// note: can replace with intrinsic in jdk8
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PENDING
argument_list|,
name|c
operator|=
name|pending
argument_list|,
name|c
operator|+
name|delta
argument_list|)
condition|)
do|;
block|}
comment|/**      * Sets (atomically) the pending count to the given count only if      * it currently holds the given expected value.      *      * @param expected the expected value      * @param count the new value      * @return true is successful      */
DECL|method|compareAndSetPendingCount
specifier|public
specifier|final
name|boolean
name|compareAndSetPendingCount
parameter_list|(
name|int
name|expected
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PENDING
argument_list|,
name|expected
argument_list|,
name|count
argument_list|)
return|;
block|}
comment|/**      * If the pending count is nonzero, decrements the count;      * otherwise invokes {@link #onCompletion} and then similarly      * tries to complete this task's completer, if one exists,      * else marks this task as complete.      */
DECL|method|tryComplete
specifier|public
specifier|final
name|void
name|tryComplete
parameter_list|()
block|{
name|CountedCompleter
name|a
init|=
name|this
decl_stmt|,
name|s
init|=
name|a
decl_stmt|;
for|for
control|(
name|int
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|a
operator|.
name|pending
operator|)
operator|==
literal|0
condition|)
block|{
name|a
operator|.
name|onCompletion
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
operator|(
name|s
operator|=
name|a
operator|)
operator|.
name|completer
operator|)
operator|==
literal|null
condition|)
block|{
name|s
operator|.
name|quietlyComplete
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|a
argument_list|,
name|PENDING
argument_list|,
name|c
argument_list|,
name|c
operator|-
literal|1
argument_list|)
condition|)
return|return;
block|}
block|}
comment|/**      * Regardless of pending count, invokes {@link #onCompletion},      * marks this task as complete with a {@code null} return value,      * and further triggers {@link #tryComplete} on this task's      * completer, if one exists. This method may be useful when      * forcing completion as soon as any one (versus all) of several      * subtask results are obtained.      *      * @param mustBeNull the {@code null} completion value      */
DECL|method|complete
specifier|public
name|void
name|complete
parameter_list|(
name|Void
name|mustBeNull
parameter_list|)
block|{
name|CountedCompleter
name|p
decl_stmt|;
name|onCompletion
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|quietlyComplete
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|completer
operator|)
operator|!=
literal|null
condition|)
name|p
operator|.
name|tryComplete
argument_list|()
expr_stmt|;
block|}
comment|/**      * Support for FJT exception propagation      */
DECL|method|internalPropagateException
name|void
name|internalPropagateException
parameter_list|(
name|Throwable
name|ex
parameter_list|)
block|{
name|CountedCompleter
name|a
init|=
name|this
decl_stmt|,
name|s
init|=
name|a
decl_stmt|;
while|while
condition|(
name|a
operator|.
name|onExceptionalCompletion
argument_list|(
name|ex
argument_list|,
name|s
argument_list|)
operator|&&
operator|(
name|a
operator|=
operator|(
name|s
operator|=
name|a
operator|)
operator|.
name|completer
operator|)
operator|!=
literal|null
operator|&&
name|a
operator|.
name|status
operator|>=
literal|0
condition|)
name|a
operator|.
name|recordExceptionalCompletion
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|/**      * Implements execution conventions for CountedCompleters      */
DECL|method|exec
specifier|protected
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
name|compute
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|/**      * Always returns {@code null}.      *      * @return {@code null} always      */
DECL|method|getRawResult
specifier|public
specifier|final
name|Void
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
comment|/**      * Requires null completion value.      */
DECL|method|setRawResult
specifier|protected
specifier|final
name|void
name|setRawResult
parameter_list|(
name|Void
name|mustBeNull
parameter_list|)
block|{ }
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|PENDING
specifier|private
specifier|static
specifier|final
name|long
name|PENDING
decl_stmt|;
static|static
block|{
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|PENDING
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|CountedCompleter
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"pending"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

