begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166y
package|package
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Random
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RunnableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicLong
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|AbstractQueuedSynchronizer
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|Condition
import|;
end_import

begin_comment
comment|/**  * An {@link ExecutorService} for running {@link ForkJoinTask}s.  * A {@code ForkJoinPool} provides the entry point for submissions  * from non-{@code ForkJoinTask} clients, as well as management and  * monitoring operations.  *  *<p>A {@code ForkJoinPool} differs from other kinds of {@link  * ExecutorService} mainly by virtue of employing  *<em>work-stealing</em>: all threads in the pool attempt to find and  * execute tasks submitted to the pool and/or created by other active  * tasks (eventually blocking waiting for work if none exist). This  * enables efficient processing when most tasks spawn other subtasks  * (as do most {@code ForkJoinTask}s), as well as when many small  * tasks are submitted to the pool from external clients.  Especially  * when setting<em>asyncMode</em> to true in constructors, {@code  * ForkJoinPool}s may also be appropriate for use with event-style  * tasks that are never joined.  *  *<p>A {@code ForkJoinPool} is constructed with a given target  * parallelism level; by default, equal to the number of available  * processors. The pool attempts to maintain enough active (or  * available) threads by dynamically adding, suspending, or resuming  * internal worker threads, even if some tasks are stalled waiting to  * join others. However, no such adjustments are guaranteed in the  * face of blocked IO or other unmanaged synchronization. The nested  * {@link ManagedBlocker} interface enables extension of the kinds of  * synchronization accommodated.  *  *<p>In addition to execution and lifecycle control methods, this  * class provides status check methods (for example  * {@link #getStealCount}) that are intended to aid in developing,  * tuning, and monitoring fork/join applications. Also, method  * {@link #toString} returns indications of pool state in a  * convenient form for informal monitoring.  *  *<p> As is the case with other ExecutorServices, there are three  * main task execution methods summarized in the following table.  * These are designed to be used primarily by clients not already  * engaged in fork/join computations in the current pool.  The main  * forms of these methods accept instances of {@code ForkJoinTask},  * but overloaded forms also allow mixed execution of plain {@code  * Runnable}- or {@code Callable}- based activities as well.  However,  * tasks that are already executing in a pool should normally instead  * use the within-computation forms listed in the table unless using  * async event-style tasks that are not usually joined, in which case  * there is little difference among choice of methods.  *  *<table BORDER CELLPADDING=3 CELLSPACING=1>  *<tr>  *<td></td>  *<td ALIGN=CENTER><b>Call from non-fork/join clients</b></td>  *<td ALIGN=CENTER><b>Call from within fork/join computations</b></td>  *</tr>  *<tr>  *<td><b>Arrange async execution</td>  *<td> {@link #execute(ForkJoinTask)}</td>  *<td> {@link ForkJoinTask#fork}</td>  *</tr>  *<tr>  *<td><b>Await and obtain result</td>  *<td> {@link #invoke(ForkJoinTask)}</td>  *<td> {@link ForkJoinTask#invoke}</td>  *</tr>  *<tr>  *<td><b>Arrange exec and obtain Future</td>  *<td> {@link #submit(ForkJoinTask)}</td>  *<td> {@link ForkJoinTask#fork} (ForkJoinTasks<em>are</em> Futures)</td>  *</tr>  *</table>  *  *<p><b>Sample Usage.</b> Normally a single {@code ForkJoinPool} is  * used for all parallel task execution in a program or subsystem.  * Otherwise, use would not usually outweigh the construction and  * bookkeeping overhead of creating a large set of threads. For  * example, a common pool could be used for the {@code SortTasks}  * illustrated in {@link RecursiveAction}. Because {@code  * ForkJoinPool} uses threads in {@linkplain java.lang.Thread#isDaemon  * daemon} mode, there is typically no need to explicitly {@link  * #shutdown} such a pool upon program exit.  *  *<pre> {@code  * static final ForkJoinPool mainPool = new ForkJoinPool();  * ...  * public void sort(long[] array) {  *   mainPool.invoke(new SortTask(array, 0, array.length));  * }}</pre>  *  *<p><b>Implementation notes</b>: This implementation restricts the  * maximum number of running threads to 32767. Attempts to create  * pools with greater than the maximum number result in  * {@code IllegalArgumentException}.  *  *<p>This implementation rejects submitted tasks (that is, by throwing  * {@link RejectedExecutionException}) only when the pool is shut down  * or internal resources have been exhausted.  *  * @since 1.7  * @author Doug Lea  */
end_comment

begin_class
DECL|class|ForkJoinPool
specifier|public
class|class
name|ForkJoinPool
extends|extends
name|AbstractExecutorService
block|{
comment|/*      * Implementation Overview      *      * This class and its nested classes provide the main      * functionality and control for a set of worker threads:      * Submissions from non-FJ threads enter into submission queues.      * Workers take these tasks and typically split them into subtasks      * that may be stolen by other workers.  Preference rules give      * first priority to processing tasks from their own queues (LIFO      * or FIFO, depending on mode), then to randomized FIFO steals of      * tasks in other queues.      *      * WorkQueues      * ==========      *      * Most operations occur within work-stealing queues (in nested      * class WorkQueue).  These are special forms of Deques that      * support only three of the four possible end-operations -- push,      * pop, and poll (aka steal), under the further constraints that      * push and pop are called only from the owning thread (or, as      * extended here, under a lock), while poll may be called from      * other threads.  (If you are unfamiliar with them, you probably      * want to read Herlihy and Shavit's book "The Art of      * Multiprocessor programming", chapter 16 describing these in      * more detail before proceeding.)  The main work-stealing queue      * design is roughly similar to those in the papers "Dynamic      * Circular Work-Stealing Deque" by Chase and Lev, SPAA 2005      * (http://research.sun.com/scalable/pubs/index.html) and      * "Idempotent work stealing" by Michael, Saraswat, and Vechev,      * PPoPP 2009 (http://portal.acm.org/citation.cfm?id=1504186).      * The main differences ultimately stem from GC requirements that      * we null out taken slots as soon as we can, to maintain as small      * a footprint as possible even in programs generating huge      * numbers of tasks. To accomplish this, we shift the CAS      * arbitrating pop vs poll (steal) from being on the indices      * ("base" and "top") to the slots themselves.  So, both a      * successful pop and poll mainly entail a CAS of a slot from      * non-null to null.  Because we rely on CASes of references, we      * do not need tag bits on base or top.  They are simple ints as      * used in any circular array-based queue (see for example      * ArrayDeque).  Updates to the indices must still be ordered in a      * way that guarantees that top == base means the queue is empty,      * but otherwise may err on the side of possibly making the queue      * appear nonempty when a push, pop, or poll have not fully      * committed. Note that this means that the poll operation,      * considered individually, is not wait-free. One thief cannot      * successfully continue until another in-progress one (or, if      * previously empty, a push) completes.  However, in the      * aggregate, we ensure at least probabilistic non-blockingness.      * If an attempted steal fails, a thief always chooses a different      * random victim target to try next. So, in order for one thief to      * progress, it suffices for any in-progress poll or new push on      * any empty queue to complete. (This is why we normally use      * method pollAt and its variants that try once at the apparent      * base index, else consider alternative actions, rather than      * method poll.)      *      * This approach also enables support of a user mode in which local      * task processing is in FIFO, not LIFO order, simply by using      * poll rather than pop.  This can be useful in message-passing      * frameworks in which tasks are never joined.  However neither      * mode considers affinities, loads, cache localities, etc, so      * rarely provide the best possible performance on a given      * machine, but portably provide good throughput by averaging over      * these factors.  (Further, even if we did try to use such      * information, we do not usually have a basis for exploiting it.      * For example, some sets of tasks profit from cache affinities,      * but others are harmed by cache pollution effects.)      *      * WorkQueues are also used in a similar way for tasks submitted      * to the pool. We cannot mix these tasks in the same queues used      * for work-stealing (this would contaminate lifo/fifo      * processing). Instead, we loosely associate submission queues      * with submitting threads, using a form of hashing.  The      * ThreadLocal Submitter class contains a value initially used as      * a hash code for choosing existing queues, but may be randomly      * repositioned upon contention with other submitters.  In      * essence, submitters act like workers except that they never      * take tasks, and they are multiplexed on to a finite number of      * shared work queues. However, classes are set up so that future      * extensions could allow submitters to optionally help perform      * tasks as well. Insertion of tasks in shared mode requires a      * lock (mainly to protect in the case of resizing) but we use      * only a simple spinlock (using bits in field runState), because      * submitters encountering a busy queue move on to try or create      * other queues -- they block only when creating and registering      * new queues.      *      * Management      * ==========      *      * The main throughput advantages of work-stealing stem from      * decentralized control -- workers mostly take tasks from      * themselves or each other. We cannot negate this in the      * implementation of other management responsibilities. The main      * tactic for avoiding bottlenecks is packing nearly all      * essentially atomic control state into two volatile variables      * that are by far most often read (not written) as status and      * consistency checks.      *      * Field "ctl" contains 64 bits holding all the information needed      * to atomically decide to add, inactivate, enqueue (on an event      * queue), dequeue, and/or re-activate workers.  To enable this      * packing, we restrict maximum parallelism to (1<<15)-1 (which is      * far in excess of normal operating range) to allow ids, counts,      * and their negations (used for thresholding) to fit into 16bit      * fields.      *      * Field "runState" contains 32 bits needed to register and      * deregister WorkQueues, as well as to enable shutdown. It is      * only modified under a lock (normally briefly held, but      * occasionally protecting allocations and resizings) but even      * when locked remains available to check consistency.      *      * Recording WorkQueues.  WorkQueues are recorded in the      * "workQueues" array that is created upon pool construction and      * expanded if necessary.  Updates to the array while recording      * new workers and unrecording terminated ones are protected from      * each other by a lock but the array is otherwise concurrently      * readable, and accessed directly.  To simplify index-based      * operations, the array size is always a power of two, and all      * readers must tolerate null slots. Shared (submission) queues      * are at even indices, worker queues at odd indices. Grouping      * them together in this way simplifies and speeds up task      * scanning.      *      * All worker thread creation is on-demand, triggered by task      * submissions, replacement of terminated workers, and/or      * compensation for blocked workers. However, all other support      * code is set up to work with other policies.  To ensure that we      * do not hold on to worker references that would prevent GC, ALL      * accesses to workQueues are via indices into the workQueues      * array (which is one source of some of the messy code      * constructions here). In essence, the workQueues array serves as      * a weak reference mechanism. Thus for example the wait queue      * field of ctl stores indices, not references.  Access to the      * workQueues in associated methods (for example signalWork) must      * both index-check and null-check the IDs. All such accesses      * ignore bad IDs by returning out early from what they are doing,      * since this can only be associated with termination, in which      * case it is OK to give up.  All uses of the workQueues array      * also check that it is non-null (even if previously      * non-null). This allows nulling during termination, which is      * currently not necessary, but remains an option for      * resource-revocation-based shutdown schemes. It also helps      * reduce JIT issuance of uncommon-trap code, which tends to      * unnecessarily complicate control flow in some methods.      *      * Event Queuing. Unlike HPC work-stealing frameworks, we cannot      * let workers spin indefinitely scanning for tasks when none can      * be found immediately, and we cannot start/resume workers unless      * there appear to be tasks available.  On the other hand, we must      * quickly prod them into action when new tasks are submitted or      * generated. In many usages, ramp-up time to activate workers is      * the main limiting factor in overall performance (this is      * compounded at program start-up by JIT compilation and      * allocation). So we try to streamline this as much as possible.      * We park/unpark workers after placing in an event wait queue      * when they cannot find work. This "queue" is actually a simple      * Treiber stack, headed by the "id" field of ctl, plus a 15bit      * counter value (that reflects the number of times a worker has      * been inactivated) to avoid ABA effects (we need only as many      * version numbers as worker threads). Successors are held in      * field WorkQueue.nextWait.  Queuing deals with several intrinsic      * races, mainly that a task-producing thread can miss seeing (and      * signalling) another thread that gave up looking for work but      * has not yet entered the wait queue. We solve this by requiring      * a full sweep of all workers (via repeated calls to method      * scan()) both before and after a newly waiting worker is added      * to the wait queue. During a rescan, the worker might release      * some other queued worker rather than itself, which has the same      * net effect. Because enqueued workers may actually be rescanning      * rather than waiting, we set and clear the "parker" field of      * WorkQueues to reduce unnecessary calls to unpark.  (This      * requires a secondary recheck to avoid missed signals.)  Note      * the unusual conventions about Thread.interrupts surrounding      * parking and other blocking: Because interrupts are used solely      * to alert threads to check termination, which is checked anyway      * upon blocking, we clear status (using Thread.interrupted)      * before any call to park, so that park does not immediately      * return due to status being set via some other unrelated call to      * interrupt in user code.      *      * Signalling.  We create or wake up workers only when there      * appears to be at least one task they might be able to find and      * execute.  When a submission is added or another worker adds a      * task to a queue that previously had fewer than two tasks, they      * signal waiting workers (or trigger creation of new ones if      * fewer than the given parallelism level -- see signalWork).      * These primary signals are buttressed by signals during rescans;      * together these cover the signals needed in cases when more      * tasks are pushed but untaken, and improve performance compared      * to having one thread wake up all workers.      *      * Trimming workers. To release resources after periods of lack of      * use, a worker starting to wait when the pool is quiescent will      * time out and terminate if the pool has remained quiescent for      * SHRINK_RATE nanosecs. This will slowly propagate, eventually      * terminating all workers after long periods of non-use.      *      * Shutdown and Termination. A call to shutdownNow atomically sets      * a runState bit and then (non-atomically) sets each worker's      * runState status, cancels all unprocessed tasks, and wakes up      * all waiting workers.  Detecting whether termination should      * commence after a non-abrupt shutdown() call requires more work      * and bookkeeping. We need consensus about quiescence (i.e., that      * there is no more work). The active count provides a primary      * indication but non-abrupt shutdown still requires a rechecking      * scan for any workers that are inactive but not queued.      *      * Joining Tasks      * =============      *      * Any of several actions may be taken when one worker is waiting      * to join a task stolen (or always held) by another.  Because we      * are multiplexing many tasks on to a pool of workers, we can't      * just let them block (as in Thread.join).  We also cannot just      * reassign the joiner's run-time stack with another and replace      * it later, which would be a form of "continuation", that even if      * possible is not necessarily a good idea since we sometimes need      * both an unblocked task and its continuation to progress.      * Instead we combine two tactics:      *      *   Helping: Arranging for the joiner to execute some task that it      *      would be running if the steal had not occurred.      *      *   Compensating: Unless there are already enough live threads,      *      method tryCompensate() may create or re-activate a spare      *      thread to compensate for blocked joiners until they unblock.      *      * A third form (implemented in tryRemoveAndExec and      * tryPollForAndExec) amounts to helping a hypothetical      * compensator: If we can readily tell that a possible action of a      * compensator is to steal and execute the task being joined, the      * joining thread can do so directly, without the need for a      * compensation thread (although at the expense of larger run-time      * stacks, but the tradeoff is typically worthwhile).      *      * The ManagedBlocker extension API can't use helping so relies      * only on compensation in method awaitBlocker.      *      * The algorithm in tryHelpStealer entails a form of "linear"      * helping: Each worker records (in field currentSteal) the most      * recent task it stole from some other worker. Plus, it records      * (in field currentJoin) the task it is currently actively      * joining. Method tryHelpStealer uses these markers to try to      * find a worker to help (i.e., steal back a task from and execute      * it) that could hasten completion of the actively joined task.      * In essence, the joiner executes a task that would be on its own      * local deque had the to-be-joined task not been stolen. This may      * be seen as a conservative variant of the approach in Wagner&      * Calder "Leapfrogging: a portable technique for implementing      * efficient futures" SIGPLAN Notices, 1993      * (http://portal.acm.org/citation.cfm?id=155354). It differs in      * that: (1) We only maintain dependency links across workers upon      * steals, rather than use per-task bookkeeping.  This sometimes      * requires a linear scan of workQueues array to locate stealers,      * but often doesn't because stealers leave hints (that may become      * stale/wrong) of where to locate them.  A stealHint is only a      * hint because a worker might have had multiple steals and the      * hint records only one of them (usually the most current).      * Hinting isolates cost to when it is needed, rather than adding      * to per-task overhead.  (2) It is "shallow", ignoring nesting      * and potentially cyclic mutual steals.  (3) It is intentionally      * racy: field currentJoin is updated only while actively joining,      * which means that we miss links in the chain during long-lived      * tasks, GC stalls etc (which is OK since blocking in such cases      * is usually a good idea).  (4) We bound the number of attempts      * to find work (see MAX_HELP) and fall back to suspending the      * worker and if necessary replacing it with another.      *      * It is impossible to keep exactly the target parallelism number      * of threads running at any given time.  Determining the      * existence of conservatively safe helping targets, the      * availability of already-created spares, and the apparent need      * to create new spares are all racy, so we rely on multiple      * retries of each.  Compensation in the apparent absence of      * helping opportunities is challenging to control on JVMs, where      * GC and other activities can stall progress of tasks that in      * turn stall out many other dependent tasks, without us being      * able to determine whether they will ever require compensation.      * Even though work-stealing otherwise encounters little      * degradation in the presence of more threads than cores,      * aggressively adding new threads in such cases entails risk of      * unwanted positive feedback control loops in which more threads      * cause more dependent stalls (as well as delayed progress of      * unblocked threads to the point that we know they are available)      * leading to more situations requiring more threads, and so      * on. This aspect of control can be seen as an (analytically      * intractable) game with an opponent that may choose the worst      * (for us) active thread to stall at any time.  We take several      * precautions to bound losses (and thus bound gains), mainly in      * methods tryCompensate and awaitJoin: (1) We only try      * compensation after attempting enough helping steps (measured      * via counting and timing) that we have already consumed the      * estimated cost of creating and activating a new thread.  (2) We      * allow up to 50% of threads to be blocked before initially      * adding any others, and unless completely saturated, check that      * some work is available for a new worker before adding. Also, we      * create up to only 50% more threads until entering a mode that      * only adds a thread if all others are possibly blocked.  All      * together, this means that we might be half as fast to react,      * and create half as many threads as possible in the ideal case,      * but present vastly fewer anomalies in all other cases compared      * to both more aggressive and more conservative alternatives.      *      * Style notes: There is a lot of representation-level coupling      * among classes ForkJoinPool, ForkJoinWorkerThread, and      * ForkJoinTask.  The fields of WorkQueue maintain data structures      * managed by ForkJoinPool, so are directly accessed.  There is      * little point trying to reduce this, since any associated future      * changes in representations will need to be accompanied by      * algorithmic changes anyway. Several methods intrinsically      * sprawl because they must accumulate sets of consistent reads of      * volatiles held in local variables.  Methods signalWork() and      * scan() are the main bottlenecks, so are especially heavily      * micro-optimized/mangled.  There are lots of inline assignments      * (of form "while ((local = field) != 0)") which are usually the      * simplest way to ensure the required read orderings (which are      * sometimes critical). This leads to a "C"-like style of listing      * declarations of these locals at the heads of methods or blocks.      * There are several occurrences of the unusual "do {} while      * (!cas...)"  which is the simplest way to force an update of a      * CAS'ed variable. There are also other coding oddities that help      * some methods perform reasonably even when interpreted (not      * compiled).      *      * The order of declarations in this file is:      * (1) Static utility functions      * (2) Nested (static) classes      * (3) Static fields      * (4) Fields, along with constants used when unpacking some of them      * (5) Internal control methods      * (6) Callbacks and other support for ForkJoinTask methods      * (7) Exported methods      * (8) Static block initializing statics in minimally dependent order      */
comment|// Static utilities
comment|/**      * If there is a security manager, makes sure caller has      * permission to modify threads.      */
DECL|method|checkPermission
specifier|private
specifier|static
name|void
name|checkPermission
parameter_list|()
block|{
name|SecurityManager
name|security
init|=
name|System
operator|.
name|getSecurityManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|security
operator|!=
literal|null
condition|)
name|security
operator|.
name|checkPermission
argument_list|(
name|modifyThreadPermission
argument_list|)
expr_stmt|;
block|}
comment|// Nested classes
comment|/**      * Factory for creating new {@link ForkJoinWorkerThread}s.      * A {@code ForkJoinWorkerThreadFactory} must be defined and used      * for {@code ForkJoinWorkerThread} subclasses that extend base      * functionality or initialize threads with different contexts.      */
DECL|interface|ForkJoinWorkerThreadFactory
specifier|public
specifier|static
interface|interface
name|ForkJoinWorkerThreadFactory
block|{
comment|/**          * Returns a new worker thread operating in the given pool.          *          * @param pool the pool this thread works in          * @throws NullPointerException if the pool is null          */
DECL|method|newThread
specifier|public
name|ForkJoinWorkerThread
name|newThread
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|)
function_decl|;
block|}
comment|/**      * Default ForkJoinWorkerThreadFactory implementation; creates a      * new ForkJoinWorkerThread.      */
DECL|class|DefaultForkJoinWorkerThreadFactory
specifier|static
class|class
name|DefaultForkJoinWorkerThreadFactory
implements|implements
name|ForkJoinWorkerThreadFactory
block|{
DECL|method|newThread
specifier|public
name|ForkJoinWorkerThread
name|newThread
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|)
block|{
return|return
operator|new
name|ForkJoinWorkerThread
argument_list|(
name|pool
argument_list|)
return|;
block|}
block|}
comment|/**      * A simple non-reentrant lock used for exclusion when managing      * queues and workers. We use a custom lock so that we can readily      * probe lock state in constructions that check among alternative      * actions. The lock is normally only very briefly held, and      * sometimes treated as a spinlock, but other usages block to      * reduce overall contention in those cases where locked code      * bodies perform allocation/resizing.      */
DECL|class|Mutex
specifier|static
specifier|final
class|class
name|Mutex
extends|extends
name|AbstractQueuedSynchronizer
block|{
DECL|method|tryAcquire
specifier|public
specifier|final
name|boolean
name|tryAcquire
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
return|return
name|compareAndSetState
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
DECL|method|tryRelease
specifier|public
specifier|final
name|boolean
name|tryRelease
parameter_list|(
name|int
name|ignore
parameter_list|)
block|{
name|setState
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
DECL|method|lock
specifier|public
specifier|final
name|void
name|lock
parameter_list|()
block|{
name|acquire
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|unlock
specifier|public
specifier|final
name|void
name|unlock
parameter_list|()
block|{
name|release
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
DECL|method|isHeldExclusively
specifier|public
specifier|final
name|boolean
name|isHeldExclusively
parameter_list|()
block|{
return|return
name|getState
argument_list|()
operator|==
literal|1
return|;
block|}
DECL|method|newCondition
specifier|public
specifier|final
name|Condition
name|newCondition
parameter_list|()
block|{
return|return
operator|new
name|ConditionObject
argument_list|()
return|;
block|}
block|}
comment|/**      * Class for artificial tasks that are used to replace the target      * of local joins if they are removed from an interior queue slot      * in WorkQueue.tryRemoveAndExec. We don't need the proxy to      * actually do anything beyond having a unique identity.      */
DECL|class|EmptyTask
specifier|static
specifier|final
class|class
name|EmptyTask
extends|extends
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
block|{
DECL|method|EmptyTask
name|EmptyTask
parameter_list|()
block|{
name|status
operator|=
name|ForkJoinTask
operator|.
name|NORMAL
expr_stmt|;
block|}
comment|// force done
DECL|method|getRawResult
specifier|public
specifier|final
name|Void
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|Void
name|x
parameter_list|)
block|{}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Queues supporting work-stealing as well as external task      * submission. See above for main rationale and algorithms.      * Implementation relies heavily on "Unsafe" intrinsics      * and selective use of "volatile":      *      * Field "base" is the index (mod array.length) of the least valid      * queue slot, which is always the next position to steal (poll)      * from if nonempty. Reads and writes require volatile orderings      * but not CAS, because updates are only performed after slot      * CASes.      *      * Field "top" is the index (mod array.length) of the next queue      * slot to push to or pop from. It is written only by owner thread      * for push, or under lock for trySharedPush, and accessed by      * other threads only after reading (volatile) base.  Both top and      * base are allowed to wrap around on overflow, but (top - base)      * (or more commonly -(base - top) to force volatile read of base      * before top) still estimates size.      *      * The array slots are read and written using the emulation of      * volatiles/atomics provided by Unsafe. Insertions must in      * general use putOrderedObject as a form of releasing store to      * ensure that all writes to the task object are ordered before      * its publication in the queue. (Although we can avoid one case      * of this when locked in trySharedPush.) All removals entail a      * CAS to null.  The array is always a power of two. To ensure      * safety of Unsafe array operations, all accesses perform      * explicit null checks and implicit bounds checks via      * power-of-two masking.      *      * In addition to basic queuing support, this class contains      * fields described elsewhere to control execution. It turns out      * to work better memory-layout-wise to include them in this      * class rather than a separate class.      *      * Performance on most platforms is very sensitive to placement of      * instances of both WorkQueues and their arrays -- we absolutely      * do not want multiple WorkQueue instances or multiple queue      * arrays sharing cache lines. (It would be best for queue objects      * and their arrays to share, but there is nothing available to      * help arrange that).  Unfortunately, because they are recorded      * in a common array, WorkQueue instances are often moved to be      * adjacent by garbage collectors. To reduce impact, we use field      * padding that works OK on common platforms; this effectively      * trades off slightly slower average field access for the sake of      * avoiding really bad worst-case access. (Until better JVM      * support is in place, this padding is dependent on transient      * properties of JVM field layout rules.)  We also take care in      * allocating, sizing and resizing the array. Non-shared queue      * arrays are initialized (via method growArray) by workers before      * use. Others are allocated on first use.      */
DECL|class|WorkQueue
specifier|static
specifier|final
class|class
name|WorkQueue
block|{
comment|/**          * Capacity of work-stealing queue array upon initialization.          * Must be a power of two; at least 4, but should be larger to          * reduce or eliminate cacheline sharing among queues.          * Currently, it is much larger, as a partial workaround for          * the fact that JVMs often place arrays in locations that          * share GC bookkeeping (especially cardmarks) such that          * per-write accesses encounter serious memory contention.          */
DECL|field|INITIAL_QUEUE_CAPACITY
specifier|static
specifier|final
name|int
name|INITIAL_QUEUE_CAPACITY
init|=
literal|1
operator|<<
literal|13
decl_stmt|;
comment|/**          * Maximum size for queue arrays. Must be a power of two less          * than or equal to 1<< (31 - width of array entry) to ensure          * lack of wraparound of index calculations, but defined to a          * value a bit less than this to help users trap runaway          * programs before saturating systems.          */
DECL|field|MAXIMUM_QUEUE_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_QUEUE_CAPACITY
init|=
literal|1
operator|<<
literal|26
decl_stmt|;
comment|// 64M
DECL|field|totalSteals
specifier|volatile
name|long
name|totalSteals
decl_stmt|;
comment|// cumulative number of steals
DECL|field|seed
name|int
name|seed
decl_stmt|;
comment|// for random scanning; initialize nonzero
DECL|field|eventCount
specifier|volatile
name|int
name|eventCount
decl_stmt|;
comment|// encoded inactivation count;< 0 if inactive
DECL|field|nextWait
name|int
name|nextWait
decl_stmt|;
comment|// encoded record of next event waiter
DECL|field|rescans
name|int
name|rescans
decl_stmt|;
comment|// remaining scans until block
DECL|field|nsteals
name|int
name|nsteals
decl_stmt|;
comment|// top-level task executions since last idle
DECL|field|mode
specifier|final
name|int
name|mode
decl_stmt|;
comment|// lifo, fifo, or shared
DECL|field|poolIndex
name|int
name|poolIndex
decl_stmt|;
comment|// index of this queue in pool (or 0)
DECL|field|stealHint
name|int
name|stealHint
decl_stmt|;
comment|// index of most recent known stealer
DECL|field|runState
specifier|volatile
name|int
name|runState
decl_stmt|;
comment|// 1: locked, -1: terminate; else 0
DECL|field|base
specifier|volatile
name|int
name|base
decl_stmt|;
comment|// index of next slot for poll
DECL|field|top
name|int
name|top
decl_stmt|;
comment|// index of next slot for push
DECL|field|array
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|array
decl_stmt|;
comment|// the elements (initially unallocated)
DECL|field|pool
specifier|final
name|ForkJoinPool
name|pool
decl_stmt|;
comment|// the containing pool (may be null)
DECL|field|owner
specifier|final
name|ForkJoinWorkerThread
name|owner
decl_stmt|;
comment|// owning thread or null if shared
DECL|field|parker
specifier|volatile
name|Thread
name|parker
decl_stmt|;
comment|// == owner during call to park; else null
DECL|field|currentJoin
specifier|volatile
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|currentJoin
decl_stmt|;
comment|// task being joined in awaitJoin
DECL|field|currentSteal
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|currentSteal
decl_stmt|;
comment|// current non-local task being executed
comment|// Heuristic padding to ameliorate unfortunate memory placements
DECL|field|p00
DECL|field|p01
DECL|field|p02
DECL|field|p03
DECL|field|p04
DECL|field|p05
DECL|field|p06
DECL|field|p07
name|Object
name|p00
decl_stmt|,
name|p01
decl_stmt|,
name|p02
decl_stmt|,
name|p03
decl_stmt|,
name|p04
decl_stmt|,
name|p05
decl_stmt|,
name|p06
decl_stmt|,
name|p07
decl_stmt|;
DECL|field|p08
DECL|field|p09
DECL|field|p0a
DECL|field|p0b
DECL|field|p0c
DECL|field|p0d
DECL|field|p0e
name|Object
name|p08
decl_stmt|,
name|p09
decl_stmt|,
name|p0a
decl_stmt|,
name|p0b
decl_stmt|,
name|p0c
decl_stmt|,
name|p0d
decl_stmt|,
name|p0e
decl_stmt|;
DECL|method|WorkQueue
name|WorkQueue
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|,
name|ForkJoinWorkerThread
name|owner
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
comment|// Place indices in the center of array (that is not yet allocated)
name|base
operator|=
name|top
operator|=
name|INITIAL_QUEUE_CAPACITY
operator|>>>
literal|1
expr_stmt|;
block|}
comment|/**          * Returns the approximate number of tasks in the queue.          */
DECL|method|queueSize
specifier|final
name|int
name|queueSize
parameter_list|()
block|{
name|int
name|n
init|=
name|base
operator|-
name|top
decl_stmt|;
comment|// non-owner callers must read base first
return|return
operator|(
name|n
operator|>=
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
name|n
return|;
comment|// ignore transient negative
block|}
comment|/**          * Provides a more accurate estimate of whether this queue has          * any tasks than does queueSize, by checking whether a          * near-empty queue has at least one unclaimed task.          */
DECL|method|isEmpty
specifier|final
name|boolean
name|isEmpty
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|;
name|int
name|n
init|=
name|base
operator|-
operator|(
name|s
operator|=
name|top
operator|)
decl_stmt|;
return|return
operator|(
name|n
operator|>=
literal|0
operator|||
operator|(
name|n
operator|==
operator|-
literal|1
operator|&&
operator|(
operator|(
name|a
operator|=
name|array
operator|)
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|0
operator|||
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
operator|(
operator|(
name|m
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|)
operator|==
literal|null
operator|)
operator|)
operator|)
return|;
block|}
comment|/**          * Pushes a task. Call only by owner in unshared queues.          *          * @param task the task. Caller must ensure non-null.          * @throw RejectedExecutionException if array cannot be resized          */
DECL|method|push
specifier|final
name|void
name|push
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|ForkJoinPool
name|p
decl_stmt|;
name|int
name|s
init|=
name|top
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// ignore if queue removed
name|U
operator|.
name|putOrderedObject
argument_list|(
name|a
argument_list|,
operator|(
operator|(
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|top
operator|=
name|s
operator|+
literal|1
operator|)
operator|-
name|base
operator|)
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|pool
operator|)
operator|!=
literal|null
condition|)
name|p
operator|.
name|signalWork
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
name|m
condition|)
name|growArray
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**          * Pushes a task if lock is free and array is either big          * enough or can be resized to be big enough.          *          * @param task the task. Caller must ensure non-null.          * @return true if submitted          */
DECL|method|trySharedPush
specifier|final
name|boolean
name|trySharedPush
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|boolean
name|submitted
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|runState
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|RUNSTATE
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
init|=
name|array
decl_stmt|;
name|int
name|s
init|=
name|top
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|a
operator|!=
literal|null
operator|&&
name|a
operator|.
name|length
operator|>
name|s
operator|+
literal|1
operator|-
name|base
operator|)
operator|||
operator|(
name|a
operator|=
name|growArray
argument_list|(
literal|false
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// must presize
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|a
argument_list|,
operator|(
name|long
operator|)
name|j
argument_list|,
name|task
argument_list|)
expr_stmt|;
comment|// don't need "ordered"
name|top
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|submitted
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|runState
operator|=
literal|0
expr_stmt|;
comment|// unlock
block|}
block|}
return|return
name|submitted
return|;
block|}
comment|/**          * Takes next task, if one exists, in LIFO order.  Call only          * by owner in unshared queues. (We do not have a shared          * version of this method because it is never needed.)          */
DECL|method|pop
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pop
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|s
init|;
operator|(
name|s
operator|=
name|top
operator|-
literal|1
operator|)
operator|-
name|base
operator|>=
literal|0
condition|;
control|)
block|{
name|long
name|j
init|=
operator|(
operator|(
name|m
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|)
operator|==
literal|null
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|top
operator|=
name|s
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Takes a task in FIFO order if b is base of queue and a task          * can be claimed without contention. Specialized versions          * appear in ForkJoinPool methods scan and tryHelpStealer.          */
DECL|method|pollAt
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollAt
parameter_list|(
name|int
name|b
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Takes next task, if one exists, in FIFO order.          */
DECL|method|poll
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|poll
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|base
operator|)
operator|-
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|base
operator|==
name|b
condition|)
block|{
if|if
condition|(
name|b
operator|+
literal|1
operator|==
name|top
condition|)
break|break;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// wait for lagging update
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Takes next task, if one exists, in order specified by mode.          */
DECL|method|nextLocalTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|nextLocalTask
parameter_list|()
block|{
return|return
name|mode
operator|==
literal|0
condition|?
name|pop
argument_list|()
else|:
name|poll
argument_list|()
return|;
block|}
comment|/**          * Returns next task, if one exists, in order specified by mode.          */
DECL|method|peek
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|peek
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
init|=
name|array
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
return|return
literal|null
return|;
name|int
name|i
init|=
name|mode
operator|==
literal|0
condition|?
name|top
operator|-
literal|1
else|:
name|base
decl_stmt|;
name|int
name|j
init|=
operator|(
operator|(
name|i
operator|&
name|m
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
return|return
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
return|;
block|}
comment|/**          * Pops the given task only if it is at the current top.          */
DECL|method|tryUnpush
specifier|final
name|boolean
name|tryUnpush
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|top
operator|)
operator|!=
name|base
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
operator|--
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|top
operator|=
name|s
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Polls the given task only if it is at the current base.          */
DECL|method|pollFor
specifier|final
name|boolean
name|pollFor
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|base
operator|)
operator|-
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|==
name|task
operator|&&
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Initializes or doubles the capacity of array. Call either          * by owner or with lock held -- it is OK for base, but not          * top, to move while resizings are in progress.          *          * @param rejectOnFailure if true, throw exception if capacity          * exceeded (relayed ultimately to user); else return null.          */
DECL|method|growArray
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|growArray
parameter_list|(
name|boolean
name|rejectOnFailure
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|oldA
init|=
name|array
decl_stmt|;
name|int
name|size
init|=
name|oldA
operator|!=
literal|null
condition|?
name|oldA
operator|.
name|length
operator|<<
literal|1
else|:
name|INITIAL_QUEUE_CAPACITY
decl_stmt|;
if|if
condition|(
name|size
operator|<=
name|MAXIMUM_QUEUE_CAPACITY
condition|)
block|{
name|int
name|oldMask
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
init|=
name|array
operator|=
operator|new
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[
name|size
index|]
decl_stmt|;
if|if
condition|(
name|oldA
operator|!=
literal|null
operator|&&
operator|(
name|oldMask
operator|=
name|oldA
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|t
operator|=
name|top
operator|)
operator|-
operator|(
name|b
operator|=
name|base
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|mask
init|=
name|size
operator|-
literal|1
decl_stmt|;
do|do
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|x
decl_stmt|;
name|int
name|oldj
init|=
operator|(
operator|(
name|b
operator|&
name|oldMask
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|int
name|j
init|=
operator|(
operator|(
name|b
operator|&
name|mask
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|x
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|oldA
argument_list|,
name|oldj
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|oldA
argument_list|,
name|oldj
argument_list|,
name|x
argument_list|,
literal|null
argument_list|)
condition|)
name|U
operator|.
name|putObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|b
operator|!=
name|t
condition|)
do|;
block|}
return|return
name|a
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rejectOnFailure
condition|)
return|return
literal|null
return|;
else|else
throw|throw
operator|new
name|RejectedExecutionException
argument_list|(
literal|"Queue capacity exceeded"
argument_list|)
throw|;
block|}
comment|/**          * Removes and cancels all known tasks, ignoring any exceptions.          */
DECL|method|cancelAll
specifier|final
name|void
name|cancelAll
parameter_list|()
block|{
name|ForkJoinTask
operator|.
name|cancelIgnoringExceptions
argument_list|(
name|currentJoin
argument_list|)
expr_stmt|;
name|ForkJoinTask
operator|.
name|cancelIgnoringExceptions
argument_list|(
name|currentSteal
argument_list|)
expr_stmt|;
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
operator|(
name|t
operator|=
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|ForkJoinTask
operator|.
name|cancelIgnoringExceptions
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/**          * Computes next value for random probes.  Scans don't require          * a very high quality generator, but also not a crummy one.          * Marsaglia xor-shift is cheap and works well enough.  Note:          * This is manually inlined in its usages in ForkJoinPool to          * avoid writes inside busy scan loops.          */
DECL|method|nextSeed
specifier|final
name|int
name|nextSeed
parameter_list|()
block|{
name|int
name|r
init|=
name|seed
decl_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
return|return
name|seed
operator|=
name|r
operator|^=
name|r
operator|<<
literal|5
return|;
block|}
comment|// Execution methods
comment|/**          * Pops and runs tasks until empty.          */
DECL|method|popAndExecAll
specifier|private
name|void
name|popAndExecAll
parameter_list|()
block|{
comment|// A bit faster than repeated pop calls
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|;
name|long
name|j
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|=
name|top
operator|-
literal|1
operator|)
operator|-
name|base
operator|>=
literal|0
operator|&&
operator|(
name|t
operator|=
operator|(
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
operator|=
operator|(
operator|(
name|m
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|)
operator|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|top
operator|=
name|s
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Polls and runs tasks until empty.          */
DECL|method|pollAndExecAll
specifier|private
name|void
name|pollAndExecAll
parameter_list|()
block|{
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
operator|(
name|t
operator|=
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
block|}
comment|/**          * If present, removes from queue and executes the given task, or          * any other cancelled task. Returns (true) immediately on any CAS          * or consistency check failure so caller can retry.          *          * @return 0 if no progress can be made, else positive          * (this unusual convention simplifies use with tryHelpStealer.)          */
DECL|method|tryRemoveAndExec
specifier|final
name|int
name|tryRemoveAndExec
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|stat
init|=
literal|1
decl_stmt|;
name|boolean
name|removed
init|=
literal|false
decl_stmt|,
name|empty
init|=
literal|true
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|,
name|b
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|n
operator|=
operator|(
name|s
operator|=
name|top
operator|)
operator|-
operator|(
name|b
operator|=
name|base
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
condition|;
control|)
block|{
comment|// traverse from s to b
name|int
name|j
init|=
operator|(
operator|(
operator|--
name|s
operator|&
name|m
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
comment|// inconsistent length
break|break;
elseif|else
if|if
condition|(
name|t
operator|==
name|task
condition|)
block|{
if|if
condition|(
name|s
operator|+
literal|1
operator|==
name|top
condition|)
block|{
comment|// pop
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|,
literal|null
argument_list|)
condition|)
break|break;
name|top
operator|=
name|s
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
name|b
condition|)
comment|// replace with proxy
name|removed
operator|=
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|,
operator|new
name|EmptyTask
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|status
operator|>=
literal|0
condition|)
name|empty
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|+
literal|1
operator|==
name|top
condition|)
block|{
comment|// pop and throw away
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
name|top
operator|=
name|s
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|empty
operator|&&
name|base
operator|==
name|b
condition|)
name|stat
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|removed
condition|)
name|task
operator|.
name|doExec
argument_list|()
expr_stmt|;
return|return
name|stat
return|;
block|}
comment|/**          * Executes a top-level task and any local tasks remaining          * after execution.          */
DECL|method|runTask
specifier|final
name|void
name|runTask
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|currentSteal
operator|=
name|t
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
if|if
condition|(
name|top
operator|!=
name|base
condition|)
block|{
comment|// process remaining local tasks
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|popAndExecAll
argument_list|()
expr_stmt|;
else|else
name|pollAndExecAll
argument_list|()
expr_stmt|;
block|}
operator|++
name|nsteals
expr_stmt|;
name|currentSteal
operator|=
literal|null
expr_stmt|;
block|}
block|}
comment|/**          * Executes a non-top-level (stolen) task.          */
DECL|method|runSubtask
specifier|final
name|void
name|runSubtask
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|ps
init|=
name|currentSteal
decl_stmt|;
name|currentSteal
operator|=
name|t
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
name|currentSteal
operator|=
name|ps
expr_stmt|;
block|}
block|}
comment|/**          * Returns true if owned and not known to be blocked.          */
DECL|method|isApparentlyUnblocked
specifier|final
name|boolean
name|isApparentlyUnblocked
parameter_list|()
block|{
name|Thread
name|wt
decl_stmt|;
name|Thread
operator|.
name|State
name|s
decl_stmt|;
return|return
operator|(
name|eventCount
operator|>=
literal|0
operator|&&
operator|(
name|wt
operator|=
name|owner
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|wt
operator|.
name|getState
argument_list|()
operator|)
operator|!=
name|Thread
operator|.
name|State
operator|.
name|BLOCKED
operator|&&
name|s
operator|!=
name|Thread
operator|.
name|State
operator|.
name|WAITING
operator|&&
name|s
operator|!=
name|Thread
operator|.
name|State
operator|.
name|TIMED_WAITING
operator|)
return|;
block|}
comment|/**          * If this owned and is not already interrupted, try to          * interrupt and/or unpark, ignoring exceptions.          */
DECL|method|interruptOwner
specifier|final
name|void
name|interruptOwner
parameter_list|()
block|{
name|Thread
name|wt
decl_stmt|,
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|wt
operator|=
name|owner
operator|)
operator|!=
literal|null
operator|&&
operator|!
name|wt
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|wt
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|ignore
parameter_list|)
block|{                 }
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|RUNSTATE
specifier|private
specifier|static
specifier|final
name|long
name|RUNSTATE
decl_stmt|;
DECL|field|ABASE
specifier|private
specifier|static
specifier|final
name|int
name|ABASE
decl_stmt|;
DECL|field|ASHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ASHIFT
decl_stmt|;
static|static
block|{
name|int
name|s
decl_stmt|;
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|WorkQueue
operator|.
name|class
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|ak
init|=
name|ForkJoinTask
index|[]
operator|.
name|class
decl_stmt|;
name|RUNSTATE
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"runState"
argument_list|)
argument_list|)
expr_stmt|;
name|ABASE
operator|=
name|U
operator|.
name|arrayBaseOffset
argument_list|(
name|ak
argument_list|)
expr_stmt|;
name|s
operator|=
name|U
operator|.
name|arrayIndexScale
argument_list|(
name|ak
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|s
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|ASHIFT
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Per-thread records for threads that submit to pools. Currently      * holds only pseudo-random seed / index that is used to choose      * submission queues in method doSubmit. In the future, this may      * also incorporate a means to implement different task rejection      * and resubmission policies.      *      * Seeds for submitters and workers/workQueues work in basically      * the same way but are initialized and updated using slightly      * different mechanics. Both are initialized using the same      * approach as in class ThreadLocal, where successive values are      * unlikely to collide with previous values. This is done during      * registration for workers, but requires a separate AtomicInteger      * for submitters. Seeds are then randomly modified upon      * collisions using xorshifts, which requires a non-zero seed.      */
DECL|class|Submitter
specifier|static
specifier|final
class|class
name|Submitter
block|{
DECL|field|seed
name|int
name|seed
decl_stmt|;
DECL|method|Submitter
name|Submitter
parameter_list|()
block|{
name|int
name|s
init|=
name|nextSubmitterSeed
operator|.
name|getAndAdd
argument_list|(
name|SEED_INCREMENT
argument_list|)
decl_stmt|;
name|seed
operator|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|s
expr_stmt|;
comment|// ensure non-zero
block|}
block|}
comment|/** ThreadLocal class for Submitters */
DECL|class|ThreadSubmitter
specifier|static
specifier|final
class|class
name|ThreadSubmitter
extends|extends
name|ThreadLocal
argument_list|<
name|Submitter
argument_list|>
block|{
DECL|method|initialValue
specifier|public
name|Submitter
name|initialValue
parameter_list|()
block|{
return|return
operator|new
name|Submitter
argument_list|()
return|;
block|}
block|}
comment|// static fields (initialized in static initializer below)
comment|/**      * Creates a new ForkJoinWorkerThread. This factory is used unless      * overridden in ForkJoinPool constructors.      */
specifier|public
specifier|static
specifier|final
name|ForkJoinWorkerThreadFactory
DECL|field|defaultForkJoinWorkerThreadFactory
name|defaultForkJoinWorkerThreadFactory
decl_stmt|;
comment|/**      * Generator for assigning sequence numbers as pool names.      */
DECL|field|poolNumberGenerator
specifier|private
specifier|static
specifier|final
name|AtomicInteger
name|poolNumberGenerator
decl_stmt|;
comment|/**      * Generator for initial hashes/seeds for submitters. Accessed by      * Submitter class constructor.      */
DECL|field|nextSubmitterSeed
specifier|static
specifier|final
name|AtomicInteger
name|nextSubmitterSeed
decl_stmt|;
comment|/**      * Permission required for callers of methods that may start or      * kill threads.      */
DECL|field|modifyThreadPermission
specifier|private
specifier|static
specifier|final
name|RuntimePermission
name|modifyThreadPermission
decl_stmt|;
comment|/**      * Per-thread submission bookeeping. Shared across all pools      * to reduce ThreadLocal pollution and because random motion      * to avoid contention in one pool is likely to hold for others.      */
DECL|field|submitters
specifier|private
specifier|static
specifier|final
name|ThreadSubmitter
name|submitters
decl_stmt|;
comment|// static constants
comment|/**      * The wakeup interval (in nanoseconds) for a worker waiting for a      * task when the pool is quiescent to instead try to shrink the      * number of workers.  The exact value does not matter too      * much. It must be short enough to release resources during      * sustained periods of idleness, but not so short that threads      * are continually re-created.      */
DECL|field|SHRINK_RATE
specifier|private
specifier|static
specifier|final
name|long
name|SHRINK_RATE
init|=
literal|4L
operator|*
literal|1000L
operator|*
literal|1000L
operator|*
literal|1000L
decl_stmt|;
comment|// 4 seconds
comment|/**      * The timeout value for attempted shrinkage, includes      * some slop to cope with system timer imprecision.      */
DECL|field|SHRINK_TIMEOUT
specifier|private
specifier|static
specifier|final
name|long
name|SHRINK_TIMEOUT
init|=
name|SHRINK_RATE
operator|-
operator|(
name|SHRINK_RATE
operator|/
literal|10
operator|)
decl_stmt|;
comment|/**      * The maximum stolen->joining link depth allowed in method      * tryHelpStealer.  Must be a power of two. This value also      * controls the maximum number of times to try to help join a task      * without any apparent progress or change in pool state before      * giving up and blocking (see awaitJoin).  Depths for legitimate      * chains are unbounded, but we use a fixed constant to avoid      * (otherwise unchecked) cycles and to bound staleness of      * traversal parameters at the expense of sometimes blocking when      * we could be helping.      */
DECL|field|MAX_HELP
specifier|private
specifier|static
specifier|final
name|int
name|MAX_HELP
init|=
literal|64
decl_stmt|;
comment|/**      * Secondary time-based bound (in nanosecs) for helping attempts      * before trying compensated blocking in awaitJoin. Used in      * conjunction with MAX_HELP to reduce variance due to different      * polling rates associated with different helping options. The      * value should roughly approximate the time required to create      * and/or activate a worker thread.      */
DECL|field|COMPENSATION_DELAY
specifier|private
specifier|static
specifier|final
name|long
name|COMPENSATION_DELAY
init|=
literal|1L
operator|<<
literal|18
decl_stmt|;
comment|// ~0.25 millisec
comment|/**      * Increment for seed generators. See class ThreadLocal for      * explanation.      */
DECL|field|SEED_INCREMENT
specifier|private
specifier|static
specifier|final
name|int
name|SEED_INCREMENT
init|=
literal|0x61c88647
decl_stmt|;
comment|/**      * Bits and masks for control variables      *      * Field ctl is a long packed with:      * AC: Number of active running workers minus target parallelism (16 bits)      * TC: Number of total workers minus target parallelism (16 bits)      * ST: true if pool is terminating (1 bit)      * EC: the wait count of top waiting thread (15 bits)      * ID: poolIndex of top of Treiber stack of waiters (16 bits)      *      * When convenient, we can extract the upper 32 bits of counts and      * the lower 32 bits of queue state, u = (int)(ctl>>> 32) and e =      * (int)ctl.  The ec field is never accessed alone, but always      * together with id and st. The offsets of counts by the target      * parallelism and the positionings of fields makes it possible to      * perform the most common checks via sign tests of fields: When      * ac is negative, there are not enough active workers, when tc is      * negative, there are not enough total workers, and when e is      * negative, the pool is terminating.  To deal with these possibly      * negative fields, we use casts in and out of "short" and/or      * signed shifts to maintain signedness.      *      * When a thread is queued (inactivated), its eventCount field is      * set negative, which is the only way to tell if a worker is      * prevented from executing tasks, even though it must continue to      * scan for them to avoid queuing races. Note however that      * eventCount updates lag releases so usage requires care.      *      * Field runState is an int packed with:      * SHUTDOWN: true if shutdown is enabled (1 bit)      * SEQ:  a sequence number updated upon (de)registering workers (30 bits)      * INIT: set true after workQueues array construction (1 bit)      *      * The sequence number enables simple consistency checks:      * Staleness of read-only operations on the workQueues array can      * be checked by comparing runState before vs after the reads.      */
comment|// bit positions/shifts for fields
DECL|field|AC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|AC_SHIFT
init|=
literal|48
decl_stmt|;
DECL|field|TC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|TC_SHIFT
init|=
literal|32
decl_stmt|;
DECL|field|ST_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ST_SHIFT
init|=
literal|31
decl_stmt|;
DECL|field|EC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|EC_SHIFT
init|=
literal|16
decl_stmt|;
comment|// bounds
DECL|field|SMASK
specifier|private
specifier|static
specifier|final
name|int
name|SMASK
init|=
literal|0xffff
decl_stmt|;
comment|// short bits
DECL|field|MAX_CAP
specifier|private
specifier|static
specifier|final
name|int
name|MAX_CAP
init|=
literal|0x7fff
decl_stmt|;
comment|// max #workers - 1
DECL|field|SQMASK
specifier|private
specifier|static
specifier|final
name|int
name|SQMASK
init|=
literal|0xfffe
decl_stmt|;
comment|// even short bits
DECL|field|SHORT_SIGN
specifier|private
specifier|static
specifier|final
name|int
name|SHORT_SIGN
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
DECL|field|INT_SIGN
specifier|private
specifier|static
specifier|final
name|int
name|INT_SIGN
init|=
literal|1
operator|<<
literal|31
decl_stmt|;
comment|// masks
DECL|field|STOP_BIT
specifier|private
specifier|static
specifier|final
name|long
name|STOP_BIT
init|=
literal|0x0001L
operator|<<
name|ST_SHIFT
decl_stmt|;
DECL|field|AC_MASK
specifier|private
specifier|static
specifier|final
name|long
name|AC_MASK
init|=
operator|(
operator|(
name|long
operator|)
name|SMASK
operator|)
operator|<<
name|AC_SHIFT
decl_stmt|;
DECL|field|TC_MASK
specifier|private
specifier|static
specifier|final
name|long
name|TC_MASK
init|=
operator|(
operator|(
name|long
operator|)
name|SMASK
operator|)
operator|<<
name|TC_SHIFT
decl_stmt|;
comment|// units for incrementing and decrementing
DECL|field|TC_UNIT
specifier|private
specifier|static
specifier|final
name|long
name|TC_UNIT
init|=
literal|1L
operator|<<
name|TC_SHIFT
decl_stmt|;
DECL|field|AC_UNIT
specifier|private
specifier|static
specifier|final
name|long
name|AC_UNIT
init|=
literal|1L
operator|<<
name|AC_SHIFT
decl_stmt|;
comment|// masks and units for dealing with u = (int)(ctl>>> 32)
DECL|field|UAC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|UAC_SHIFT
init|=
name|AC_SHIFT
operator|-
literal|32
decl_stmt|;
DECL|field|UTC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|UTC_SHIFT
init|=
name|TC_SHIFT
operator|-
literal|32
decl_stmt|;
DECL|field|UAC_MASK
specifier|private
specifier|static
specifier|final
name|int
name|UAC_MASK
init|=
name|SMASK
operator|<<
name|UAC_SHIFT
decl_stmt|;
DECL|field|UTC_MASK
specifier|private
specifier|static
specifier|final
name|int
name|UTC_MASK
init|=
name|SMASK
operator|<<
name|UTC_SHIFT
decl_stmt|;
DECL|field|UAC_UNIT
specifier|private
specifier|static
specifier|final
name|int
name|UAC_UNIT
init|=
literal|1
operator|<<
name|UAC_SHIFT
decl_stmt|;
DECL|field|UTC_UNIT
specifier|private
specifier|static
specifier|final
name|int
name|UTC_UNIT
init|=
literal|1
operator|<<
name|UTC_SHIFT
decl_stmt|;
comment|// masks and units for dealing with e = (int)ctl
DECL|field|E_MASK
specifier|private
specifier|static
specifier|final
name|int
name|E_MASK
init|=
literal|0x7fffffff
decl_stmt|;
comment|// no STOP_BIT
DECL|field|E_SEQ
specifier|private
specifier|static
specifier|final
name|int
name|E_SEQ
init|=
literal|1
operator|<<
name|EC_SHIFT
decl_stmt|;
comment|// runState bits
DECL|field|SHUTDOWN
specifier|private
specifier|static
specifier|final
name|int
name|SHUTDOWN
init|=
literal|1
operator|<<
literal|31
decl_stmt|;
comment|// access mode for WorkQueue
DECL|field|LIFO_QUEUE
specifier|static
specifier|final
name|int
name|LIFO_QUEUE
init|=
literal|0
decl_stmt|;
DECL|field|FIFO_QUEUE
specifier|static
specifier|final
name|int
name|FIFO_QUEUE
init|=
literal|1
decl_stmt|;
DECL|field|SHARED_QUEUE
specifier|static
specifier|final
name|int
name|SHARED_QUEUE
init|=
operator|-
literal|1
decl_stmt|;
comment|// Instance fields
comment|/*      * Field layout order in this class tends to matter more than one      * would like. Runtime layout order is only loosely related to      * declaration order and may differ across JVMs, but the following      * empirically works OK on current JVMs.      */
DECL|field|ctl
specifier|volatile
name|long
name|ctl
decl_stmt|;
comment|// main pool control
DECL|field|parallelism
specifier|final
name|int
name|parallelism
decl_stmt|;
comment|// parallelism level
DECL|field|localMode
specifier|final
name|int
name|localMode
decl_stmt|;
comment|// per-worker scheduling mode
DECL|field|submitMask
specifier|final
name|int
name|submitMask
decl_stmt|;
comment|// submit queue index bound
DECL|field|nextSeed
name|int
name|nextSeed
decl_stmt|;
comment|// for initializing worker seeds
DECL|field|runState
specifier|volatile
name|int
name|runState
decl_stmt|;
comment|// shutdown status and seq
DECL|field|workQueues
name|WorkQueue
index|[]
name|workQueues
decl_stmt|;
comment|// main registry
DECL|field|lock
specifier|final
name|Mutex
name|lock
decl_stmt|;
comment|// for registration
DECL|field|termination
specifier|final
name|Condition
name|termination
decl_stmt|;
comment|// for awaitTermination
DECL|field|factory
specifier|final
name|ForkJoinWorkerThreadFactory
name|factory
decl_stmt|;
comment|// factory for new workers
DECL|field|ueh
specifier|final
name|Thread
operator|.
name|UncaughtExceptionHandler
name|ueh
decl_stmt|;
comment|// per-worker UEH
DECL|field|stealCount
specifier|final
name|AtomicLong
name|stealCount
decl_stmt|;
comment|// collect counts when terminated
DECL|field|nextWorkerNumber
specifier|final
name|AtomicInteger
name|nextWorkerNumber
decl_stmt|;
comment|// to create worker name string
DECL|field|workerNamePrefix
specifier|final
name|String
name|workerNamePrefix
decl_stmt|;
comment|// to create worker name string
comment|//  Creating, registering, and deregistering workers
comment|/**      * Tries to create and start a worker      */
DECL|method|addWorker
specifier|private
name|void
name|addWorker
parameter_list|()
block|{
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|wt
operator|=
name|factory
operator|.
name|newThread
argument_list|(
name|this
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|wt
operator|.
name|start
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|ex
operator|=
name|e
expr_stmt|;
block|}
name|deregisterWorker
argument_list|(
name|wt
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// adjust counts etc on failure
block|}
comment|/**      * Callback from ForkJoinWorkerThread constructor to assign a      * public name. This must be separate from registerWorker because      * it is called during the "super" constructor call in      * ForkJoinWorkerThread.      */
DECL|method|nextWorkerName
specifier|final
name|String
name|nextWorkerName
parameter_list|()
block|{
return|return
name|workerNamePrefix
operator|.
name|concat
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|nextWorkerNumber
operator|.
name|addAndGet
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/**      * Callback from ForkJoinWorkerThread constructor to establish its      * poolIndex and record its WorkQueue. To avoid scanning bias due      * to packing entries in front of the workQueues array, we treat      * the array as a simple power-of-two hash table using per-thread      * seed as hash, expanding as needed.      *      * @param w the worker's queue      */
DECL|method|registerWorker
specifier|final
name|void
name|registerWorker
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
name|Mutex
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
name|WorkQueue
index|[]
name|ws
init|=
name|workQueues
decl_stmt|;
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
name|ws
operator|!=
literal|null
condition|)
block|{
comment|// skip on shutdown/failure
name|int
name|rs
decl_stmt|,
name|n
init|=
name|ws
operator|.
name|length
decl_stmt|,
name|m
init|=
name|n
operator|-
literal|1
decl_stmt|;
name|int
name|s
init|=
name|nextSeed
operator|+=
name|SEED_INCREMENT
decl_stmt|;
comment|// rarely-colliding sequence
name|w
operator|.
name|seed
operator|=
operator|(
name|s
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|s
expr_stmt|;
comment|// ensure non-zero seed
name|int
name|r
init|=
operator|(
name|s
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
comment|// use odd-numbered indices
if|if
condition|(
name|ws
index|[
name|r
operator|&=
name|m
index|]
operator|!=
literal|null
condition|)
block|{
comment|// collision
name|int
name|probes
init|=
literal|0
decl_stmt|;
comment|// step by approx half size
name|int
name|step
init|=
operator|(
name|n
operator|<=
literal|4
operator|)
condition|?
literal|2
else|:
operator|(
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|&
name|SQMASK
operator|)
operator|+
literal|2
decl_stmt|;
while|while
condition|(
name|ws
index|[
name|r
operator|=
operator|(
name|r
operator|+
name|step
operator|)
operator|&
name|m
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|++
name|probes
operator|>=
name|n
condition|)
block|{
name|workQueues
operator|=
name|ws
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|ws
argument_list|,
name|n
operator|<<=
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|probes
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|w
operator|.
name|eventCount
operator|=
name|w
operator|.
name|poolIndex
operator|=
name|r
expr_stmt|;
comment|// establish before recording
name|ws
index|[
name|r
index|]
operator|=
name|w
expr_stmt|;
comment|// also update seq
name|runState
operator|=
operator|(
operator|(
name|rs
operator|=
name|runState
operator|)
operator|&
name|SHUTDOWN
operator|)
operator||
operator|(
operator|(
name|rs
operator|+
literal|2
operator|)
operator|&
operator|~
name|SHUTDOWN
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Final callback from terminating worker, as well as upon failure      * to construct or start a worker in addWorker.  Removes record of      * worker from array, and adjusts counts. If pool is shutting      * down, tries to complete termination.      *      * @param wt the worker thread or null if addWorker failed      * @param ex the exception causing failure, or null if none      */
DECL|method|deregisterWorker
specifier|final
name|void
name|deregisterWorker
parameter_list|(
name|ForkJoinWorkerThread
name|wt
parameter_list|,
name|Throwable
name|ex
parameter_list|)
block|{
name|Mutex
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|WorkQueue
name|w
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|wt
operator|!=
literal|null
operator|&&
operator|(
name|w
operator|=
name|wt
operator|.
name|workQueue
operator|)
operator|!=
literal|null
condition|)
block|{
name|w
operator|.
name|runState
operator|=
operator|-
literal|1
expr_stmt|;
comment|// ensure runState is set
name|stealCount
operator|.
name|getAndAdd
argument_list|(
name|w
operator|.
name|totalSteals
operator|+
name|w
operator|.
name|nsteals
argument_list|)
expr_stmt|;
name|int
name|idx
init|=
name|w
operator|.
name|poolIndex
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// remove record from array
name|WorkQueue
index|[]
name|ws
init|=
name|workQueues
decl_stmt|;
if|if
condition|(
name|ws
operator|!=
literal|null
operator|&&
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ws
operator|.
name|length
operator|&&
name|ws
index|[
name|idx
index|]
operator|==
name|w
condition|)
name|ws
index|[
name|idx
index|]
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
name|long
name|c
decl_stmt|;
comment|// adjust ctl counts
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
operator|(
operator|(
operator|(
name|c
operator|-
name|AC_UNIT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
operator|(
name|c
operator|-
name|TC_UNIT
operator|)
operator|&
name|TC_MASK
operator|)
operator||
operator|(
name|c
operator|&
operator|~
operator|(
name|AC_MASK
operator||
name|TC_MASK
operator|)
operator|)
operator|)
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
name|tryTerminate
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
operator|&&
name|w
operator|!=
literal|null
condition|)
block|{
name|w
operator|.
name|cancelAll
argument_list|()
expr_stmt|;
comment|// cancel remaining tasks
if|if
condition|(
name|w
operator|.
name|array
operator|!=
literal|null
condition|)
comment|// suppress signal if never ran
name|signalWork
argument_list|()
expr_stmt|;
comment|// wake up or create replacement
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
comment|// help clean refs on way out
name|ForkJoinTask
operator|.
name|helpExpungeStaleExceptions
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ex
operator|!=
literal|null
condition|)
comment|// rethrow
name|U
operator|.
name|throwException
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|// Submissions
comment|/**      * Unless shutting down, adds the given task to a submission queue      * at submitter's current queue index (modulo submission      * range). If no queue exists at the index, one is created.  If      * the queue is busy, another index is randomly chosen. The      * submitMask bounds the effective number of queues to the      * (nearest power of two for) parallelism level.      *      * @param task the task. Caller must ensure non-null.      */
DECL|method|doSubmit
specifier|private
name|void
name|doSubmit
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|Submitter
name|s
init|=
name|submitters
operator|.
name|get
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|r
init|=
name|s
operator|.
name|seed
init|,
name|m
init|=
name|submitMask
init|;
condition|;
control|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|int
name|k
init|=
name|r
operator|&
name|m
operator|&
name|SQMASK
decl_stmt|;
comment|// use only even indices
if|if
condition|(
name|runState
operator|<
literal|0
operator|||
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
name|ws
operator|.
name|length
operator|<=
name|k
condition|)
throw|throw
operator|new
name|RejectedExecutionException
argument_list|()
throw|;
comment|// shutting down
elseif|else
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
name|k
index|]
operator|)
operator|==
literal|null
condition|)
block|{
comment|// create new queue
name|WorkQueue
name|nq
init|=
operator|new
name|WorkQueue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|SHARED_QUEUE
argument_list|)
decl_stmt|;
name|Mutex
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
comment|// construct outside lock
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
comment|// recheck under lock
name|int
name|rs
init|=
name|runState
decl_stmt|;
comment|// to update seq
if|if
condition|(
name|ws
operator|==
name|workQueues
operator|&&
name|ws
index|[
name|k
index|]
operator|==
literal|null
condition|)
block|{
name|ws
index|[
name|k
index|]
operator|=
name|nq
expr_stmt|;
name|runState
operator|=
operator|(
operator|(
name|rs
operator|&
name|SHUTDOWN
operator|)
operator||
operator|(
operator|(
name|rs
operator|+
literal|2
operator|)
operator|&
operator|~
name|SHUTDOWN
operator|)
operator|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|q
operator|.
name|trySharedPush
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|signalWork
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|m
operator|>
literal|1
condition|)
block|{
comment|// move to a different index
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
comment|// same xorshift as WorkQueues
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
name|s
operator|.
name|seed
operator|=
name|r
operator|^=
name|r
operator|<<
literal|5
expr_stmt|;
block|}
else|else
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// yield if no alternatives
block|}
block|}
comment|// Maintaining ctl counts
comment|/**      * Increments active count; mainly called upon return from blocking.      */
DECL|method|incrementActiveCount
specifier|final
name|void
name|incrementActiveCount
parameter_list|()
block|{
name|long
name|c
decl_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
do|;
block|}
comment|/**      * Tries to activate or create a worker if too few are active.      */
DECL|method|signalWork
specifier|final
name|void
name|signalWork
parameter_list|()
block|{
name|long
name|c
decl_stmt|;
name|int
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|>>>
literal|32
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|// too few active
name|WorkQueue
index|[]
name|ws
init|=
name|workQueues
decl_stmt|;
name|int
name|e
decl_stmt|,
name|i
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|Thread
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|int
operator|)
name|c
operator|)
operator|>
literal|0
condition|)
block|{
comment|// at least one waiting
if|if
condition|(
name|ws
operator|!=
literal|null
operator|&&
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|<
name|ws
operator|.
name|length
operator|&&
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
name|w
operator|.
name|eventCount
operator|==
operator|(
name|e
operator||
name|INT_SIGN
operator|)
condition|)
block|{
name|long
name|nc
init|=
operator|(
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|u
operator|+
name|UAC_UNIT
argument_list|)
operator|<<
literal|32
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|w
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|// activate and release
break|break;
block|}
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
literal|0
operator|&&
operator|(
name|u
operator|&
name|SHORT_SIGN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// too few total
name|long
name|nc
init|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|u
operator|+
name|UTC_UNIT
operator|)
operator|&
name|UTC_MASK
operator|)
operator||
operator|(
operator|(
name|u
operator|+
name|UAC_UNIT
operator|)
operator|&
name|UAC_MASK
operator|)
argument_list|)
operator|<<
literal|32
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|addWorker
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
break|break;
block|}
block|}
comment|// Scanning for tasks
comment|/**      * Top-level runloop for workers, called by ForkJoinWorkerThread.run.      */
DECL|method|runWorker
specifier|final
name|void
name|runWorker
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
name|w
operator|.
name|growArray
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// initialize queue array in this thread
do|do
block|{
name|w
operator|.
name|runTask
argument_list|(
name|scan
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|.
name|runState
operator|>=
literal|0
condition|)
do|;
block|}
comment|/**      * Scans for and, if found, returns one task, else possibly      * inactivates the worker. This method operates on single reads of      * volatile state and is designed to be re-invoked continuously,      * in part because it returns upon detecting inconsistencies,      * contention, or state changes that indicate possible success on      * re-invocation.      *      * The scan searches for tasks across a random permutation of      * queues (starting at a random index and stepping by a random      * relative prime, checking each at least once).  The scan      * terminates upon either finding a non-empty queue, or completing      * the sweep. If the worker is not inactivated, it takes and      * returns a task from this queue.  On failure to find a task, we      * take one of the following actions, after which the caller will      * retry calling this method unless terminated.      *      * * If pool is terminating, terminate the worker.      *      * * If not a complete sweep, try to release a waiting worker.  If      * the scan terminated because the worker is inactivated, then the      * released worker will often be the calling worker, and it can      * succeed obtaining a task on the next call. Or maybe it is      * another worker, but with same net effect. Releasing in other      * cases as well ensures that we have enough workers running.      *      * * If not already enqueued, try to inactivate and enqueue the      * worker on wait queue. Or, if inactivating has caused the pool      * to be quiescent, relay to idleAwaitWork to check for      * termination and possibly shrink pool.      *      * * If already inactive, and the caller has run a task since the      * last empty scan, return (to allow rescan) unless others are      * also inactivated.  Field WorkQueue.rescans counts down on each      * scan to ensure eventual inactivation and blocking.      *      * * If already enqueued and none of the above apply, park      * awaiting signal,      *      * @param w the worker (via its WorkQueue)      * @return a task or null of none found      */
DECL|method|scan
specifier|private
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|scan
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
comment|// first update random seed
name|int
name|r
init|=
name|w
operator|.
name|seed
decl_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
name|w
operator|.
name|seed
operator|=
name|r
operator|^=
name|r
operator|<<
literal|5
expr_stmt|;
name|int
name|rs
init|=
name|runState
decl_stmt|,
name|m
decl_stmt|;
comment|// volatile read order matters
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|ec
init|=
name|w
operator|.
name|eventCount
decl_stmt|;
comment|// ec is negative if inactive
name|int
name|step
init|=
operator|(
name|r
operator|>>>
literal|16
operator|)
operator||
literal|1
decl_stmt|;
comment|// relative prime
for|for
control|(
name|int
name|j
init|=
operator|(
name|m
operator|+
literal|1
operator|)
operator|<<
literal|2
init|;
condition|;
name|r
operator|+=
name|step
control|)
block|{
name|WorkQueue
name|q
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
name|r
operator|&
name|m
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|q
operator|.
name|base
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|q
operator|.
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// probably nonempty
name|int
name|i
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|.
name|base
operator|==
name|b
operator|&&
name|ec
operator|>=
literal|0
operator|&&
name|t
operator|!=
literal|null
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|i
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|top
operator|-
operator|(
name|q
operator|.
name|base
operator|=
name|b
operator|+
literal|1
operator|)
operator|>
literal|1
condition|)
name|signalWork
argument_list|()
expr_stmt|;
comment|// help pushes signal
return|return
name|t
return|;
block|}
elseif|else
if|if
condition|(
name|ec
operator|<
literal|0
operator|||
name|j
operator|<=
name|m
condition|)
block|{
name|rs
operator|=
literal|0
expr_stmt|;
comment|// mark scan as imcomplete
break|break;
comment|// caller can retry after release
block|}
block|}
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
break|break;
block|}
name|long
name|c
init|=
name|ctl
decl_stmt|;
name|int
name|e
init|=
operator|(
name|int
operator|)
name|c
decl_stmt|,
name|a
init|=
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
decl_stmt|,
name|nr
decl_stmt|,
name|ns
decl_stmt|;
if|if
condition|(
name|e
operator|<
literal|0
condition|)
comment|// decode ctl on empty scan
name|w
operator|.
name|runState
operator|=
operator|-
literal|1
expr_stmt|;
comment|// pool is terminating
elseif|else
if|if
condition|(
name|rs
operator|==
literal|0
operator|||
name|rs
operator|!=
name|runState
condition|)
block|{
comment|// incomplete scan
name|WorkQueue
name|v
decl_stmt|;
name|Thread
name|p
decl_stmt|;
comment|// try to release a waiter
if|if
condition|(
name|e
operator|>
literal|0
operator|&&
name|a
operator|<
literal|0
operator|&&
name|w
operator|.
name|eventCount
operator|==
name|ec
operator|&&
operator|(
name|v
operator|=
name|ws
index|[
name|e
operator|&
name|m
index|]
operator|)
operator|!=
literal|null
operator|&&
name|v
operator|.
name|eventCount
operator|==
operator|(
name|e
operator||
name|INT_SIGN
operator|)
condition|)
block|{
name|long
name|nc
init|=
operator|(
call|(
name|long
call|)
argument_list|(
name|v
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator||
operator|(
operator|(
name|c
operator|+
name|AC_UNIT
operator|)
operator|&
operator|(
name|AC_MASK
operator||
name|TC_MASK
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|ctl
operator|==
name|c
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|v
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|v
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ec
operator|>=
literal|0
condition|)
block|{
comment|// try to enqueue/inactivate
name|long
name|nc
init|=
operator|(
name|long
operator|)
name|ec
operator||
operator|(
operator|(
name|c
operator|-
name|AC_UNIT
operator|)
operator|&
operator|(
name|AC_MASK
operator||
name|TC_MASK
operator|)
operator|)
decl_stmt|;
name|w
operator|.
name|nextWait
operator|=
name|e
expr_stmt|;
name|w
operator|.
name|eventCount
operator|=
name|ec
operator||
name|INT_SIGN
expr_stmt|;
comment|// mark as inactive
if|if
condition|(
name|ctl
operator|!=
name|c
operator|||
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
name|w
operator|.
name|eventCount
operator|=
name|ec
expr_stmt|;
comment|// unmark on CAS failure
else|else
block|{
if|if
condition|(
operator|(
name|ns
operator|=
name|w
operator|.
name|nsteals
operator|)
operator|!=
literal|0
condition|)
block|{
name|w
operator|.
name|nsteals
operator|=
literal|0
expr_stmt|;
comment|// set rescans if ran task
name|w
operator|.
name|rescans
operator|=
operator|(
name|a
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
name|a
operator|+
name|parallelism
expr_stmt|;
name|w
operator|.
name|totalSteals
operator|+=
name|ns
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|==
literal|1
operator|-
name|parallelism
condition|)
comment|// quiescent
name|idleAwaitWork
argument_list|(
name|w
argument_list|,
name|nc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|w
operator|.
name|eventCount
operator|<
literal|0
condition|)
block|{
comment|// already queued
if|if
condition|(
operator|(
name|nr
operator|=
name|w
operator|.
name|rescans
operator|)
operator|>
literal|0
condition|)
block|{
comment|// continue rescanning
name|int
name|ac
init|=
name|a
operator|+
name|parallelism
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|w
operator|.
name|rescans
operator|=
operator|(
name|ac
operator|<
name|nr
operator|)
condition|?
name|ac
else|:
name|nr
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// yield before block
block|}
else|else
block|{
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
comment|// clear status
name|Thread
name|wt
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|w
operator|.
name|parker
operator|=
name|wt
expr_stmt|;
comment|// emulate LockSupport.park
if|if
condition|(
name|w
operator|.
name|eventCount
operator|<
literal|0
condition|)
comment|// recheck
name|U
operator|.
name|park
argument_list|(
literal|false
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|w
operator|.
name|parker
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * If inactivating worker w has caused the pool to become      * quiescent, checks for pool termination, and, so long as this is      * not the only worker, waits for event for up to SHRINK_RATE      * nanosecs.  On timeout, if ctl has not changed, terminates the      * worker, which will in turn wake up another worker to possibly      * repeat this process.      *      * @param w the calling worker      * @param currentCtl the ctl value triggering possible quiescence      * @param prevCtl the ctl value to restore if thread is terminated      */
DECL|method|idleAwaitWork
specifier|private
name|void
name|idleAwaitWork
parameter_list|(
name|WorkQueue
name|w
parameter_list|,
name|long
name|currentCtl
parameter_list|,
name|long
name|prevCtl
parameter_list|)
block|{
if|if
condition|(
name|w
operator|.
name|eventCount
operator|<
literal|0
operator|&&
operator|!
name|tryTerminate
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
operator|&&
operator|(
name|int
operator|)
name|prevCtl
operator|!=
literal|0
operator|&&
operator|!
name|hasQueuedSubmissions
argument_list|()
operator|&&
name|ctl
operator|==
name|currentCtl
condition|)
block|{
name|Thread
name|wt
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// yield before block
while|while
condition|(
name|ctl
operator|==
name|currentCtl
condition|)
block|{
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
comment|// timed variant of version in scan()
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|w
operator|.
name|parker
operator|=
name|wt
expr_stmt|;
if|if
condition|(
name|ctl
operator|==
name|currentCtl
condition|)
name|U
operator|.
name|park
argument_list|(
literal|false
argument_list|,
name|SHRINK_RATE
argument_list|)
expr_stmt|;
name|w
operator|.
name|parker
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|currentCtl
condition|)
break|break;
if|if
condition|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|>=
name|SHRINK_TIMEOUT
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|currentCtl
argument_list|,
name|prevCtl
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|w
operator|.
name|eventCount
operator|+
name|E_SEQ
operator|)
operator||
name|E_MASK
expr_stmt|;
name|w
operator|.
name|runState
operator|=
operator|-
literal|1
expr_stmt|;
comment|// shrink
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Tries to locate and execute tasks for a stealer of the given      * task, or in turn one of its stealers, Traces currentSteal ->      * currentJoin links looking for a thread working on a descendant      * of the given task and with a non-empty queue to steal back and      * execute tasks from. The first call to this method upon a      * waiting join will often entail scanning/search, (which is OK      * because the joiner has nothing better to do), but this method      * leaves hints in workers to speed up subsequent calls. The      * implementation is very branchy to cope with potential      * inconsistencies or loops encountering chains that are stale,      * unknown, or so long that they are likely cyclic.      *      * @param joiner the joining worker      * @param task the task to join      * @return 0 if no progress can be made, negative if task      * known complete, else positive      */
DECL|method|tryHelpStealer
specifier|private
name|int
name|tryHelpStealer
parameter_list|(
name|WorkQueue
name|joiner
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|stat
init|=
literal|0
decl_stmt|,
name|steps
init|=
literal|0
decl_stmt|;
comment|// bound to avoid cycles
if|if
condition|(
name|joiner
operator|!=
literal|null
operator|&&
name|task
operator|!=
literal|null
condition|)
block|{
comment|// hoist null checks
name|restart
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|subtask
init|=
name|task
decl_stmt|;
comment|// current target
for|for
control|(
name|WorkQueue
name|j
init|=
name|joiner
init|,
name|v
init|;
condition|;
control|)
block|{
comment|// v is stealer of subtask
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|,
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|<
literal|0
condition|)
block|{
name|stat
operator|=
name|s
expr_stmt|;
break|break
name|restart
break|;
block|}
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|<=
literal|0
condition|)
break|break
name|restart
break|;
comment|// shutting down
if|if
condition|(
operator|(
name|v
operator|=
name|ws
index|[
name|h
operator|=
operator|(
name|j
operator|.
name|stealHint
operator||
literal|1
operator|)
operator|&
name|m
index|]
operator|)
operator|==
literal|null
operator|||
name|v
operator|.
name|currentSteal
operator|!=
name|subtask
condition|)
block|{
for|for
control|(
name|int
name|origin
init|=
name|h
init|;
condition|;
control|)
block|{
comment|// find stealer
if|if
condition|(
operator|(
operator|(
name|h
operator|=
operator|(
name|h
operator|+
literal|2
operator|)
operator|&
name|m
operator|)
operator|&
literal|15
operator|)
operator|==
literal|1
operator|&&
operator|(
name|subtask
operator|.
name|status
operator|<
literal|0
operator|||
name|j
operator|.
name|currentJoin
operator|!=
name|subtask
operator|)
condition|)
continue|continue
name|restart
continue|;
comment|// occasional staleness check
if|if
condition|(
operator|(
name|v
operator|=
name|ws
index|[
name|h
index|]
operator|)
operator|!=
literal|null
operator|&&
name|v
operator|.
name|currentSteal
operator|==
name|subtask
condition|)
block|{
name|j
operator|.
name|stealHint
operator|=
name|h
expr_stmt|;
comment|// save hint
break|break;
block|}
if|if
condition|(
name|h
operator|==
name|origin
condition|)
break|break
name|restart
break|;
comment|// cannot find stealer
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// help stealer or descend to its stealer
name|ForkJoinTask
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
name|subtask
operator|.
name|status
operator|<
literal|0
condition|)
comment|// surround probes with
continue|continue
name|restart
continue|;
comment|//   consistency checks
if|if
condition|(
operator|(
name|b
operator|=
name|v
operator|.
name|base
operator|)
operator|-
name|v
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|v
operator|.
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|i
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|subtask
operator|.
name|status
operator|<
literal|0
operator|||
name|j
operator|.
name|currentJoin
operator|!=
name|subtask
operator|||
name|v
operator|.
name|currentSteal
operator|!=
name|subtask
condition|)
continue|continue
name|restart
continue|;
comment|// stale
name|stat
operator|=
literal|1
expr_stmt|;
comment|// apparent progress
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
name|v
operator|.
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|i
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|v
operator|.
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
comment|// help stealer
name|joiner
operator|.
name|runSubtask
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|.
name|base
operator|==
name|b
operator|&&
operator|++
name|steps
operator|==
name|MAX_HELP
condition|)
break|break
name|restart
break|;
comment|// v apparently stalled
block|}
else|else
block|{
comment|// empty -- try to descend
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|next
init|=
name|v
operator|.
name|currentJoin
decl_stmt|;
if|if
condition|(
name|subtask
operator|.
name|status
operator|<
literal|0
operator|||
name|j
operator|.
name|currentJoin
operator|!=
name|subtask
operator|||
name|v
operator|.
name|currentSteal
operator|!=
name|subtask
condition|)
continue|continue
name|restart
continue|;
comment|// stale
elseif|else
if|if
condition|(
name|next
operator|==
literal|null
operator|||
operator|++
name|steps
operator|==
name|MAX_HELP
condition|)
break|break
name|restart
break|;
comment|// dead-end or maybe cyclic
else|else
block|{
name|subtask
operator|=
name|next
expr_stmt|;
name|j
operator|=
name|v
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|stat
return|;
block|}
comment|/**      * If task is at base of some steal queue, steals and executes it.      *      * @param joiner the joining worker      * @param task the task      */
DECL|method|tryPollForAndExec
specifier|private
name|void
name|tryPollForAndExec
parameter_list|(
name|WorkQueue
name|joiner
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|ws
operator|.
name|length
operator|&&
name|task
operator|.
name|status
operator|>=
literal|0
condition|;
name|j
operator|+=
literal|2
control|)
block|{
name|WorkQueue
name|q
init|=
name|ws
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
operator|&&
name|q
operator|.
name|pollFor
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|joiner
operator|.
name|runSubtask
argument_list|(
name|task
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Tries to decrement active count (sometimes implicitly) and      * possibly release or create a compensating worker in preparation      * for blocking. Fails on contention or termination. Otherwise,      * adds a new thread if no idle workers are available and either      * pool would become completely starved or: (at least half      * starved, and fewer than 50% spares exist, and there is at least      * one task apparently available). Even though the availability      * check requires a full scan, it is worthwhile in reducing false      * alarms.      *      * @param task if non-null, a task being waited for      * @param blocker if non-null, a blocker being waited for      * @return true if the caller can block, else should recheck and retry      */
DECL|method|tryCompensate
specifier|final
name|boolean
name|tryCompensate
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|,
name|ManagedBlocker
name|blocker
parameter_list|)
block|{
name|int
name|pc
init|=
name|parallelism
decl_stmt|,
name|e
decl_stmt|;
name|long
name|c
init|=
name|ctl
decl_stmt|;
name|WorkQueue
index|[]
name|ws
init|=
name|workQueues
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|int
operator|)
name|c
operator|)
operator|>=
literal|0
operator|&&
name|ws
operator|!=
literal|null
condition|)
block|{
name|int
name|u
decl_stmt|,
name|a
decl_stmt|,
name|ac
decl_stmt|,
name|hc
decl_stmt|;
name|int
name|tc
init|=
call|(
name|short
call|)
argument_list|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|>>>
literal|32
argument_list|)
operator|)
operator|>>>
name|UTC_SHIFT
argument_list|)
operator|+
name|pc
decl_stmt|;
name|boolean
name|replace
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|u
operator|>>
name|UAC_SHIFT
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ac
operator|=
name|a
operator|+
name|pc
operator|)
operator|<=
literal|1
condition|)
name|replace
operator|=
literal|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|e
operator|>
literal|0
operator|||
operator|(
name|task
operator|!=
literal|null
operator|&&
name|ac
operator|<=
operator|(
name|hc
operator|=
name|pc
operator|>>>
literal|1
operator|)
operator|&&
name|tc
operator|<
name|pc
operator|+
name|hc
operator|)
operator|)
condition|)
block|{
name|WorkQueue
name|w
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|ws
operator|.
name|length
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|j
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|replace
operator|=
literal|true
expr_stmt|;
break|break;
comment|// in compensation range and tasks available
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|task
operator|==
literal|null
operator|||
name|task
operator|.
name|status
operator|>=
literal|0
operator|)
operator|&&
comment|// recheck need to block
operator|(
name|blocker
operator|==
literal|null
operator|||
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
operator|)
operator|&&
name|ctl
operator|==
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|replace
condition|)
block|{
comment|// no compensation
name|long
name|nc
init|=
operator|(
operator|(
name|c
operator|-
name|AC_UNIT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
name|c
operator|&
operator|~
name|AC_MASK
operator|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|!=
literal|0
condition|)
block|{
comment|// release an idle worker
name|WorkQueue
name|w
decl_stmt|;
name|Thread
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|<
name|ws
operator|.
name|length
operator|&&
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|nc
init|=
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator||
operator|(
name|c
operator|&
operator|(
name|AC_MASK
operator||
name|TC_MASK
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|w
operator|.
name|eventCount
operator|==
operator|(
name|e
operator||
name|INT_SIGN
operator|)
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|w
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|tc
operator|<
name|MAX_CAP
condition|)
block|{
comment|// create replacement
name|long
name|nc
init|=
operator|(
operator|(
name|c
operator|+
name|TC_UNIT
operator|)
operator|&
name|TC_MASK
operator|)
operator||
operator|(
name|c
operator|&
operator|~
name|TC_MASK
operator|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|addWorker
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Helps and/or blocks until the given task is done.      *      * @param joiner the joining worker      * @param task the task      * @return task status on exit      */
DECL|method|awaitJoin
specifier|final
name|int
name|awaitJoin
parameter_list|(
name|WorkQueue
name|joiner
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|prevJoin
init|=
name|joiner
operator|.
name|currentJoin
decl_stmt|;
name|joiner
operator|.
name|currentJoin
operator|=
name|task
expr_stmt|;
name|long
name|startTime
init|=
literal|0L
decl_stmt|;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
operator|(
name|joiner
operator|.
name|isEmpty
argument_list|()
condition|?
comment|// try to help
name|tryHelpStealer
argument_list|(
name|joiner
argument_list|,
name|task
argument_list|)
else|:
name|joiner
operator|.
name|tryRemoveAndExec
argument_list|(
name|task
argument_list|)
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
name|startTime
operator|=
name|System
operator|.
name|nanoTime
argument_list|()
expr_stmt|;
name|tryPollForAndExec
argument_list|(
name|joiner
argument_list|,
name|task
argument_list|)
expr_stmt|;
comment|// check uncommon case
block|}
elseif|else
if|if
condition|(
operator|(
name|k
operator|&
operator|(
name|MAX_HELP
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|>=
name|COMPENSATION_DELAY
operator|&&
name|tryCompensate
argument_list|(
name|task
argument_list|,
literal|null
argument_list|)
condition|)
block|{
if|if
condition|(
name|task
operator|.
name|trySetSignal
argument_list|()
condition|)
block|{
synchronized|synchronized
init|(
name|task
init|)
block|{
if|if
condition|(
name|task
operator|.
name|status
operator|>=
literal|0
condition|)
block|{
try|try
block|{
comment|// see ForkJoinTask
name|task
operator|.
name|wait
argument_list|()
expr_stmt|;
comment|//  for explanation
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{                                     }
block|}
else|else
name|task
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
name|long
name|c
decl_stmt|;
comment|// re-activate
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
do|;
block|}
block|}
if|if
condition|(
name|s
operator|<
literal|0
operator|||
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|<
literal|0
condition|)
block|{
name|joiner
operator|.
name|currentJoin
operator|=
name|prevJoin
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|k
operator|++
operator|&
operator|(
name|MAX_HELP
operator|-
literal|1
operator|)
operator|)
operator|==
name|MAX_HELP
operator|>>>
literal|1
condition|)
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// for politeness
block|}
block|}
return|return
name|s
return|;
block|}
comment|/**      * Stripped-down variant of awaitJoin used by timed joins. Tries      * to help join only while there is continuous progress. (Caller      * will then enter a timed wait.)      *      * @param joiner the joining worker      * @param task the task      * @return task status on exit      */
DECL|method|helpJoinOnce
specifier|final
name|int
name|helpJoinOnce
parameter_list|(
name|WorkQueue
name|joiner
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|joiner
operator|.
name|isEmpty
argument_list|()
condition|?
name|tryHelpStealer
argument_list|(
name|joiner
argument_list|,
name|task
argument_list|)
else|:
name|joiner
operator|.
name|tryRemoveAndExec
argument_list|(
name|task
argument_list|)
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
name|s
return|;
block|}
comment|/**      * Returns a (probably) non-empty steal queue, if one is found      * during a random, then cyclic scan, else null.  This method must      * be retried by caller if, by the time it tries to use the queue,      * it is empty.      */
DECL|method|findNonEmptyStealQueue
specifier|private
name|WorkQueue
name|findNonEmptyStealQueue
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
comment|// Similar to loop in scan(), but ignoring submissions
name|int
name|r
init|=
name|w
operator|.
name|seed
decl_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
name|w
operator|.
name|seed
operator|=
name|r
operator|^=
name|r
operator|<<
literal|5
expr_stmt|;
name|int
name|step
init|=
operator|(
name|r
operator|>>>
literal|16
operator|)
operator||
literal|1
decl_stmt|;
for|for
control|(
name|WorkQueue
index|[]
name|ws
init|;
condition|;
control|)
block|{
name|int
name|rs
init|=
name|runState
decl_stmt|,
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|1
condition|)
return|return
literal|null
return|;
for|for
control|(
name|int
name|j
init|=
operator|(
name|m
operator|+
literal|1
operator|)
operator|<<
literal|2
init|;
condition|;
name|r
operator|+=
name|step
control|)
block|{
name|WorkQueue
name|q
init|=
name|ws
index|[
operator|(
operator|(
name|r
operator|<<
literal|1
operator|)
operator||
literal|1
operator|)
operator|&
name|m
index|]
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
operator|&&
operator|!
name|q
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|q
return|;
elseif|else
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|runState
operator|==
name|rs
condition|)
return|return
literal|null
return|;
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Runs tasks until {@code isQuiescent()}. We piggyback on      * active count ctl maintenance, but rather than blocking      * when tasks cannot be found, we rescan until all others cannot      * find tasks either.      */
DECL|method|helpQuiescePool
specifier|final
name|void
name|helpQuiescePool
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
for|for
control|(
name|boolean
name|active
init|=
literal|true
init|;
condition|;
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|localTask
decl_stmt|;
comment|// exhaust local queue
while|while
condition|(
operator|(
name|localTask
operator|=
name|w
operator|.
name|nextLocalTask
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|localTask
operator|.
name|doExec
argument_list|()
expr_stmt|;
name|WorkQueue
name|q
init|=
name|findNonEmptyStealQueue
argument_list|(
name|w
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|!
name|active
condition|)
block|{
comment|// re-establish active count
name|long
name|c
decl_stmt|;
name|active
operator|=
literal|true
expr_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|b
operator|=
name|q
operator|.
name|base
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|t
operator|=
name|q
operator|.
name|pollAt
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|null
condition|)
name|w
operator|.
name|runSubtask
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|long
name|c
decl_stmt|;
if|if
condition|(
name|active
condition|)
block|{
comment|// decrement active count without queuing
name|active
operator|=
literal|false
expr_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|-=
name|AC_UNIT
argument_list|)
condition|)
do|;
block|}
else|else
name|c
operator|=
name|ctl
expr_stmt|;
comment|// re-increment on exit
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
operator|+
name|parallelism
operator|==
literal|0
condition|)
block|{
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
do|;
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Gets and removes a local or stolen task for the given worker.      *      * @return a task, if available      */
DECL|method|nextTaskFor
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|nextTaskFor
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
condition|;
control|)
block|{
name|WorkQueue
name|q
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|w
operator|.
name|nextLocalTask
argument_list|()
operator|)
operator|!=
literal|null
condition|)
return|return
name|t
return|;
if|if
condition|(
operator|(
name|q
operator|=
name|findNonEmptyStealQueue
argument_list|(
name|w
argument_list|)
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|(
name|b
operator|=
name|q
operator|.
name|base
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|t
operator|=
name|q
operator|.
name|pollAt
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|null
condition|)
return|return
name|t
return|;
block|}
block|}
comment|/**      * Returns the approximate (non-atomic) number of idle threads per      * active thread to offset steal queue size for method      * ForkJoinTask.getSurplusQueuedTaskCount().      */
DECL|method|idlePerActive
specifier|final
name|int
name|idlePerActive
parameter_list|()
block|{
comment|// Approximate at powers of two for small values, saturate past 4
name|int
name|p
init|=
name|parallelism
decl_stmt|;
name|int
name|a
init|=
name|p
operator|+
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>
name|AC_SHIFT
argument_list|)
decl_stmt|;
return|return
operator|(
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|0
else|:
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|1
else|:
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|2
else|:
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|4
else|:
literal|8
operator|)
return|;
block|}
comment|//  Termination
comment|/**      * Possibly initiates and/or completes termination.  The caller      * triggering termination runs three passes through workQueues:      * (0) Setting termination status, followed by wakeups of queued      * workers; (1) cancelling all tasks; (2) interrupting lagging      * threads (likely in external tasks, but possibly also blocked in      * joins).  Each pass repeats previous steps because of potential      * lagging thread creation.      *      * @param now if true, unconditionally terminate, else only      * if no work and no active workers      * @param enable if true, enable shutdown when next possible      * @return true if now terminating or terminated      */
DECL|method|tryTerminate
specifier|private
name|boolean
name|tryTerminate
parameter_list|(
name|boolean
name|now
parameter_list|,
name|boolean
name|enable
parameter_list|)
block|{
name|Mutex
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
for|for
control|(
name|long
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// already terminating
if|if
condition|(
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
operator|==
operator|-
name|parallelism
condition|)
block|{
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
comment|// don't need try/finally
name|termination
operator|.
name|signalAll
argument_list|()
expr_stmt|;
comment|// signal when 0 workers
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
name|runState
operator|>=
literal|0
condition|)
block|{
comment|// not yet enabled
if|if
condition|(
operator|!
name|enable
condition|)
return|return
literal|false
return|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|runState
operator||=
name|SHUTDOWN
expr_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|now
condition|)
block|{
comment|// check if idle& no tasks
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
operator|!=
operator|-
name|parallelism
operator|||
name|hasQueuedSubmissions
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Check for unqueued inactive workers. One pass suffices.
name|WorkQueue
index|[]
name|ws
init|=
name|workQueues
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
name|ws
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
name|w
operator|.
name|eventCount
operator|>=
literal|0
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|c
operator||
name|STOP_BIT
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|3
condition|;
operator|++
name|pass
control|)
block|{
name|WorkQueue
index|[]
name|ws
init|=
name|workQueues
decl_stmt|;
if|if
condition|(
name|ws
operator|!=
literal|null
condition|)
block|{
name|WorkQueue
name|w
decl_stmt|;
name|int
name|n
init|=
name|ws
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|w
operator|.
name|runState
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|w
operator|.
name|cancelAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|1
condition|)
name|w
operator|.
name|interruptOwner
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// Wake up workers parked on event queue
name|int
name|i
decl_stmt|,
name|e
decl_stmt|;
name|long
name|cc
decl_stmt|;
name|Thread
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
call|(
name|int
call|)
argument_list|(
name|cc
operator|=
name|ctl
argument_list|)
operator|&
name|E_MASK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|<
name|n
operator|&&
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|nc
init|=
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator||
operator|(
operator|(
name|cc
operator|+
name|AC_UNIT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
name|cc
operator|&
operator|(
name|TC_MASK
operator||
name|STOP_BIT
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|w
operator|.
name|eventCount
operator|==
operator|(
name|e
operator||
name|INT_SIGN
operator|)
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|cc
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
name|w
operator|.
name|runState
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|w
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|// Exported methods
comment|// Constructors
comment|/**      * Creates a {@code ForkJoinPool} with parallelism equal to {@link      * java.lang.Runtime#availableProcessors}, using the {@linkplain      * #defaultForkJoinWorkerThreadFactory default thread factory},      * no UncaughtExceptionHandler, and non-async LIFO processing mode.      *      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|()
block|{
name|this
argument_list|(
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
argument_list|,
name|defaultForkJoinWorkerThreadFactory
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@code ForkJoinPool} with the indicated parallelism      * level, the {@linkplain      * #defaultForkJoinWorkerThreadFactory default thread factory},      * no UncaughtExceptionHandler, and non-async LIFO processing mode.      *      * @param parallelism the parallelism level      * @throws IllegalArgumentException if parallelism less than or      *         equal to zero, or greater than implementation limit      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|(
name|int
name|parallelism
parameter_list|)
block|{
name|this
argument_list|(
name|parallelism
argument_list|,
name|defaultForkJoinWorkerThreadFactory
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@code ForkJoinPool} with the given parameters.      *      * @param parallelism the parallelism level. For default value,      * use {@link java.lang.Runtime#availableProcessors}.      * @param factory the factory for creating new threads. For default value,      * use {@link #defaultForkJoinWorkerThreadFactory}.      * @param handler the handler for internal worker threads that      * terminate due to unrecoverable errors encountered while executing      * tasks. For default value, use {@code null}.      * @param asyncMode if true,      * establishes local first-in-first-out scheduling mode for forked      * tasks that are never joined. This mode may be more appropriate      * than default locally stack-based mode in applications in which      * worker threads only process event-style asynchronous tasks.      * For default value, use {@code false}.      * @throws IllegalArgumentException if parallelism less than or      *         equal to zero, or greater than implementation limit      * @throws NullPointerException if the factory is null      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|(
name|int
name|parallelism
parameter_list|,
name|ForkJoinWorkerThreadFactory
name|factory
parameter_list|,
name|Thread
operator|.
name|UncaughtExceptionHandler
name|handler
parameter_list|,
name|boolean
name|asyncMode
parameter_list|)
block|{
name|checkPermission
argument_list|()
expr_stmt|;
if|if
condition|(
name|factory
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|parallelism
operator|<=
literal|0
operator|||
name|parallelism
operator|>
name|MAX_CAP
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|this
operator|.
name|parallelism
operator|=
name|parallelism
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|ueh
operator|=
name|handler
expr_stmt|;
name|this
operator|.
name|localMode
operator|=
name|asyncMode
condition|?
name|FIFO_QUEUE
else|:
name|LIFO_QUEUE
expr_stmt|;
name|long
name|np
init|=
call|(
name|long
call|)
argument_list|(
operator|-
name|parallelism
argument_list|)
decl_stmt|;
comment|// offset ctl counts
name|this
operator|.
name|ctl
operator|=
operator|(
operator|(
name|np
operator|<<
name|AC_SHIFT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
operator|(
name|np
operator|<<
name|TC_SHIFT
operator|)
operator|&
name|TC_MASK
operator|)
expr_stmt|;
comment|// Use nearest power 2 for workQueues size. See Hackers Delight sec 3.2.
name|int
name|n
init|=
name|parallelism
operator|-
literal|1
decl_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|1
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|2
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|4
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|8
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|16
expr_stmt|;
name|int
name|size
init|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|<<
literal|1
decl_stmt|;
comment|// #slots = 2*#workers
name|this
operator|.
name|submitMask
operator|=
name|size
operator|-
literal|1
expr_stmt|;
comment|// room for max # of submit queues
name|this
operator|.
name|workQueues
operator|=
operator|new
name|WorkQueue
index|[
name|size
index|]
expr_stmt|;
name|this
operator|.
name|termination
operator|=
operator|(
name|this
operator|.
name|lock
operator|=
operator|new
name|Mutex
argument_list|()
operator|)
operator|.
name|newCondition
argument_list|()
expr_stmt|;
name|this
operator|.
name|stealCount
operator|=
operator|new
name|AtomicLong
argument_list|()
expr_stmt|;
name|this
operator|.
name|nextWorkerNumber
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|int
name|pn
init|=
name|poolNumberGenerator
operator|.
name|incrementAndGet
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"ForkJoinPool-"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|pn
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"-worker-"
argument_list|)
expr_stmt|;
name|this
operator|.
name|workerNamePrefix
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
name|this
operator|.
name|runState
operator|=
literal|1
expr_stmt|;
comment|// set init flag
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
comment|// Execution methods
comment|/**      * Performs the given task, returning its result upon completion.      * If the computation encounters an unchecked Exception or Error,      * it is rethrown as the outcome of this invocation.  Rethrown      * exceptions behave in the same way as regular exceptions, but,      * when possible, contain stack traces (as displayed for example      * using {@code ex.printStackTrace()}) of both the current thread      * as well as the thread actually encountering the exception;      * minimally only the latter.      *      * @param task the task      * @return the task's result      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|invoke
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|invoke
parameter_list|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|doSubmit
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
operator|.
name|join
argument_list|()
return|;
block|}
comment|/**      * Arranges for (asynchronous) execution of the given task.      *      * @param task the task      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|doSubmit
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|// AbstractExecutorService methods
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|Runnable
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|job
decl_stmt|;
if|if
condition|(
name|task
operator|instanceof
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
condition|)
comment|// avoid re-wrap
condition|job = (ForkJoinTask<?>
condition|)
name|task
expr_stmt|;
else|else
name|job
operator|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnableAction
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
comment|/**      * Submits a ForkJoinTask for execution.      *      * @param task the task to submit      * @return the task      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|doSubmit
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|job
init|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedCallable
argument_list|<
name|T
argument_list|>
argument_list|(
name|task
argument_list|)
decl_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|Runnable
name|task
parameter_list|,
name|T
name|result
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|job
init|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnable
argument_list|<
name|T
argument_list|>
argument_list|(
name|task
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|submit
parameter_list|(
name|Runnable
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|job
decl_stmt|;
if|if
condition|(
name|task
operator|instanceof
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
condition|)
comment|// avoid re-wrap
condition|job = (ForkJoinTask<?>
condition|)
name|task
expr_stmt|;
else|else
name|job
operator|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnableAction
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|doSubmit
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException       {@inheritDoc}      * @throws RejectedExecutionException {@inheritDoc}      */
DECL|method|invokeAll
specifier|public
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|invokeAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Callable
argument_list|<
name|T
argument_list|>
argument_list|>
name|tasks
parameter_list|)
block|{
comment|// In previous versions of this class, this method constructed
comment|// a task to run ForkJoinTask.invokeAll, but now external
comment|// invocation of multiple tasks is at least as efficient.
name|List
argument_list|<
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
argument_list|>
name|fs
init|=
operator|new
name|ArrayList
argument_list|<
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
argument_list|>
argument_list|(
name|tasks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
comment|// Workaround needed because method wasn't declared with
comment|// wildcards in return type but should have been.
annotation|@
name|SuppressWarnings
argument_list|(
block|{
literal|"unchecked"
block|,
literal|"rawtypes"
block|}
argument_list|)
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|futures
init|=
call|(
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
call|)
argument_list|(
name|List
argument_list|)
name|fs
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|Callable
argument_list|<
name|T
argument_list|>
name|t
range|:
name|tasks
control|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|f
init|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedCallable
argument_list|<
name|T
argument_list|>
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|doSubmit
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fs
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|f
range|:
name|fs
control|)
name|f
operator|.
name|quietlyJoin
argument_list|()
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
return|return
name|futures
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|done
condition|)
for|for
control|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|f
range|:
name|fs
control|)
name|f
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the factory used for constructing new workers.      *      * @return the factory used for constructing new workers      */
DECL|method|getFactory
specifier|public
name|ForkJoinWorkerThreadFactory
name|getFactory
parameter_list|()
block|{
return|return
name|factory
return|;
block|}
comment|/**      * Returns the handler for internal worker threads that terminate      * due to unrecoverable errors encountered while executing tasks.      *      * @return the handler, or {@code null} if none      */
DECL|method|getUncaughtExceptionHandler
specifier|public
name|Thread
operator|.
name|UncaughtExceptionHandler
name|getUncaughtExceptionHandler
parameter_list|()
block|{
return|return
name|ueh
return|;
block|}
comment|/**      * Returns the targeted parallelism level of this pool.      *      * @return the targeted parallelism level of this pool      */
DECL|method|getParallelism
specifier|public
name|int
name|getParallelism
parameter_list|()
block|{
return|return
name|parallelism
return|;
block|}
comment|/**      * Returns the number of worker threads that have started but not      * yet terminated.  The result returned by this method may differ      * from {@link #getParallelism} when threads are created to      * maintain parallelism when others are cooperatively blocked.      *      * @return the number of worker threads      */
DECL|method|getPoolSize
specifier|public
name|int
name|getPoolSize
parameter_list|()
block|{
return|return
name|parallelism
operator|+
call|(
name|short
call|)
argument_list|(
name|ctl
operator|>>>
name|TC_SHIFT
argument_list|)
return|;
block|}
comment|/**      * Returns {@code true} if this pool uses local first-in-first-out      * scheduling mode for forked tasks that are never joined.      *      * @return {@code true} if this pool uses async mode      */
DECL|method|getAsyncMode
specifier|public
name|boolean
name|getAsyncMode
parameter_list|()
block|{
return|return
name|localMode
operator|!=
literal|0
return|;
block|}
comment|/**      * Returns an estimate of the number of worker threads that are      * not blocked waiting to join tasks or for other managed      * synchronization. This method may overestimate the      * number of running threads.      *      * @return the number of worker threads      */
DECL|method|getRunningThreadCount
specifier|public
name|int
name|getRunningThreadCount
parameter_list|()
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
name|w
operator|.
name|isApparentlyUnblocked
argument_list|()
condition|)
operator|++
name|rc
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
comment|/**      * Returns an estimate of the number of threads that are currently      * stealing or executing tasks. This method may overestimate the      * number of active threads.      *      * @return the number of active threads      */
DECL|method|getActiveThreadCount
specifier|public
name|int
name|getActiveThreadCount
parameter_list|()
block|{
name|int
name|r
init|=
name|parallelism
operator|+
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>
name|AC_SHIFT
argument_list|)
decl_stmt|;
return|return
operator|(
name|r
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|r
return|;
comment|// suppress momentarily negative values
block|}
comment|/**      * Returns {@code true} if all worker threads are currently idle.      * An idle worker is one that cannot obtain a task to execute      * because none are available to steal from other threads, and      * there are no pending submissions to the pool. This method is      * conservative; it might not return {@code true} immediately upon      * idleness of all threads, but will eventually become true if      * threads remain inactive.      *      * @return {@code true} if all threads are currently idle      */
DECL|method|isQuiescent
specifier|public
name|boolean
name|isQuiescent
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>
name|AC_SHIFT
argument_list|)
operator|+
name|parallelism
operator|==
literal|0
return|;
block|}
comment|/**      * Returns an estimate of the total number of tasks stolen from      * one thread's work queue by another. The reported value      * underestimates the actual total number of steals when the pool      * is not quiescent. This value may be useful for monitoring and      * tuning fork/join programs: in general, steal counts should be      * high enough to keep threads busy, but low enough to avoid      * overhead and contention across threads.      *      * @return the number of steals      */
DECL|method|getStealCount
specifier|public
name|long
name|getStealCount
parameter_list|()
block|{
name|long
name|count
init|=
name|stealCount
operator|.
name|get
argument_list|()
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|count
operator|+=
name|w
operator|.
name|totalSteals
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns an estimate of the total number of tasks currently held      * in queues by worker threads (but not including tasks submitted      * to the pool that have not begun executing). This value is only      * an approximation, obtained by iterating across all threads in      * the pool. This method may be useful for tuning task      * granularities.      *      * @return the number of queued tasks      */
DECL|method|getQueuedTaskCount
specifier|public
name|long
name|getQueuedTaskCount
parameter_list|()
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|count
operator|+=
name|w
operator|.
name|queueSize
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns an estimate of the number of tasks submitted to this      * pool that have not yet begun executing.  This method may take      * time proportional to the number of submissions.      *      * @return the number of queued submissions      */
DECL|method|getQueuedSubmissionCount
specifier|public
name|int
name|getQueuedSubmissionCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|count
operator|+=
name|w
operator|.
name|queueSize
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns {@code true} if there are any tasks submitted to this      * pool that have not yet begun executing.      *      * @return {@code true} if there are any queued submissions      */
DECL|method|hasQueuedSubmissions
specifier|public
name|boolean
name|hasQueuedSubmissions
parameter_list|()
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Removes and returns the next unexecuted submission if one is      * available.  This method may be useful in extensions to this      * class that re-assign work in systems with multiple pools.      *      * @return the next submission, or {@code null} if none      */
DECL|method|pollSubmission
specifier|protected
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollSubmission
parameter_list|()
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|t
operator|=
name|w
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Removes all available unexecuted submitted and forked tasks      * from scheduling queues and adds them to the given collection,      * without altering their execution status. These may include      * artificially generated or wrapped tasks. This method is      * designed to be invoked only when the pool is known to be      * quiescent. Invocations at other times may not remove all      * tasks. A failure encountered while attempting to add elements      * to collection {@code c} may result in elements being in      * neither, either or both collections when the associated      * exception is thrown.  The behavior of this operation is      * undefined if the specified collection is modified while the      * operation is in progress.      *      * @param c the collection to transfer elements into      * @return the number of elements transferred      */
DECL|method|drainTasksTo
specifier|protected
name|int
name|drainTasksTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
operator|(
name|t
operator|=
name|w
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|c
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns a string identifying this pool, as well as its state,      * including indications of run state, parallelism level, and      * worker and task counts.      *      * @return a string identifying this pool, as well as its state      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// Use a single pass through workQueues to collect counts
name|long
name|qt
init|=
literal|0L
decl_stmt|,
name|qs
init|=
literal|0L
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|long
name|st
init|=
name|stealCount
operator|.
name|get
argument_list|()
decl_stmt|;
name|long
name|c
init|=
name|ctl
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|size
init|=
name|w
operator|.
name|queueSize
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|qs
operator|+=
name|size
expr_stmt|;
else|else
block|{
name|qt
operator|+=
name|size
expr_stmt|;
name|st
operator|+=
name|w
operator|.
name|totalSteals
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|isApparentlyUnblocked
argument_list|()
condition|)
operator|++
name|rc
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|pc
init|=
name|parallelism
decl_stmt|;
name|int
name|tc
init|=
name|pc
operator|+
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
decl_stmt|;
name|int
name|ac
init|=
name|pc
operator|+
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|ac
operator|<
literal|0
condition|)
comment|// ignore transient negative
name|ac
operator|=
literal|0
expr_stmt|;
name|String
name|level
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0
condition|)
name|level
operator|=
operator|(
name|tc
operator|==
literal|0
operator|)
condition|?
literal|"Terminated"
else|:
literal|"Terminating"
expr_stmt|;
else|else
name|level
operator|=
name|runState
operator|<
literal|0
condition|?
literal|"Shutting down"
else|:
literal|"Running"
expr_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"["
operator|+
name|level
operator|+
literal|", parallelism = "
operator|+
name|pc
operator|+
literal|", size = "
operator|+
name|tc
operator|+
literal|", active = "
operator|+
name|ac
operator|+
literal|", running = "
operator|+
name|rc
operator|+
literal|", steals = "
operator|+
name|st
operator|+
literal|", tasks = "
operator|+
name|qt
operator|+
literal|", submissions = "
operator|+
name|qs
operator|+
literal|"]"
return|;
block|}
comment|/**      * Initiates an orderly shutdown in which previously submitted      * tasks are executed, but no new tasks will be accepted.      * Invocation has no additional effect if already shut down.      * Tasks that are in the process of being submitted concurrently      * during the course of this method may or may not be rejected.      *      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|shutdown
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|checkPermission
argument_list|()
expr_stmt|;
name|tryTerminate
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Attempts to cancel and/or stop all tasks, and reject all      * subsequently submitted tasks.  Tasks that are in the process of      * being submitted or executed concurrently during the course of      * this method may or may not be rejected. This method cancels      * both existing and unexecuted tasks, in order to permit      * termination in the presence of task dependencies. So the method      * always returns an empty list (unlike the case for some other      * Executors).      *      * @return an empty list      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|shutdownNow
specifier|public
name|List
argument_list|<
name|Runnable
argument_list|>
name|shutdownNow
parameter_list|()
block|{
name|checkPermission
argument_list|()
expr_stmt|;
name|tryTerminate
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|/**      * Returns {@code true} if all tasks have completed following shut down.      *      * @return {@code true} if all tasks have completed following shut down      */
DECL|method|isTerminated
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
name|long
name|c
init|=
name|ctl
decl_stmt|;
return|return
operator|(
operator|(
name|c
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0L
operator|&&
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
operator|==
operator|-
name|parallelism
operator|)
return|;
block|}
comment|/**      * Returns {@code true} if the process of termination has      * commenced but not yet completed.  This method may be useful for      * debugging. A return of {@code true} reported a sufficient      * period after shutdown may indicate that submitted tasks have      * ignored or suppressed interruption, or are waiting for IO,      * causing this executor not to properly terminate. (See the      * advisory notes for class {@link ForkJoinTask} stating that      * tasks should not normally entail blocking operations.  But if      * they do, they must abort them on interrupt.)      *      * @return {@code true} if terminating but not yet terminated      */
DECL|method|isTerminating
specifier|public
name|boolean
name|isTerminating
parameter_list|()
block|{
name|long
name|c
init|=
name|ctl
decl_stmt|;
return|return
operator|(
operator|(
name|c
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0L
operator|&&
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
operator|!=
operator|-
name|parallelism
operator|)
return|;
block|}
comment|/**      * Returns {@code true} if this pool has been shut down.      *      * @return {@code true} if this pool has been shut down      */
DECL|method|isShutdown
specifier|public
name|boolean
name|isShutdown
parameter_list|()
block|{
return|return
name|runState
operator|<
literal|0
return|;
block|}
comment|/**      * Blocks until all tasks have completed execution after a shutdown      * request, or the timeout occurs, or the current thread is      * interrupted, whichever happens first.      *      * @param timeout the maximum time to wait      * @param unit the time unit of the timeout argument      * @return {@code true} if this executor terminated and      *         {@code false} if the timeout elapsed before termination      * @throws InterruptedException if interrupted while waiting      */
DECL|method|awaitTermination
specifier|public
name|boolean
name|awaitTermination
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
specifier|final
name|Mutex
name|lock
init|=
name|this
operator|.
name|lock
decl_stmt|;
name|lock
operator|.
name|lock
argument_list|()
expr_stmt|;
try|try
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|isTerminated
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|nanos
operator|<=
literal|0
condition|)
return|return
literal|false
return|;
name|nanos
operator|=
name|termination
operator|.
name|awaitNanos
argument_list|(
name|nanos
argument_list|)
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Interface for extending managed parallelism for tasks running      * in {@link ForkJoinPool}s.      *      *<p>A {@code ManagedBlocker} provides two methods.  Method      * {@code isReleasable} must return {@code true} if blocking is      * not necessary. Method {@code block} blocks the current thread      * if necessary (perhaps internally invoking {@code isReleasable}      * before actually blocking). These actions are performed by any      * thread invoking {@link ForkJoinPool#managedBlock}.  The      * unusual methods in this API accommodate synchronizers that may,      * but don't usually, block for long periods. Similarly, they      * allow more efficient internal handling of cases in which      * additional workers may be, but usually are not, needed to      * ensure sufficient parallelism.  Toward this end,      * implementations of method {@code isReleasable} must be amenable      * to repeated invocation.      *      *<p>For example, here is a ManagedBlocker based on a      * ReentrantLock:      *<pre> {@code      * class ManagedLocker implements ManagedBlocker {      *   final ReentrantLock lock;      *   boolean hasLock = false;      *   ManagedLocker(ReentrantLock lock) { this.lock = lock; }      *   public boolean block() {      *     if (!hasLock)      *       lock.lock();      *     return true;      *   }      *   public boolean isReleasable() {      *     return hasLock || (hasLock = lock.tryLock());      *   }      * }}</pre>      *      *<p>Here is a class that possibly blocks waiting for an      * item on a given queue:      *<pre> {@code      * class QueueTaker<E> implements ManagedBlocker {      *   final BlockingQueue<E> queue;      *   volatile E item = null;      *   QueueTaker(BlockingQueue<E> q) { this.queue = q; }      *   public boolean block() throws InterruptedException {      *     if (item == null)      *       item = queue.take();      *     return true;      *   }      *   public boolean isReleasable() {      *     return item != null || (item = queue.poll()) != null;      *   }      *   public E getItem() { // call after pool.managedBlock completes      *     return item;      *   }      * }}</pre>      */
DECL|interface|ManagedBlocker
specifier|public
specifier|static
interface|interface
name|ManagedBlocker
block|{
comment|/**          * Possibly blocks the current thread, for example waiting for          * a lock or condition.          *          * @return {@code true} if no additional blocking is necessary          * (i.e., if isReleasable would return true)          * @throws InterruptedException if interrupted while waiting          * (the method is not required to do so, but is allowed to)          */
DECL|method|block
name|boolean
name|block
parameter_list|()
throws|throws
name|InterruptedException
function_decl|;
comment|/**          * Returns {@code true} if blocking is unnecessary.          */
DECL|method|isReleasable
name|boolean
name|isReleasable
parameter_list|()
function_decl|;
block|}
comment|/**      * Blocks in accord with the given blocker.  If the current thread      * is a {@link ForkJoinWorkerThread}, this method possibly      * arranges for a spare thread to be activated if necessary to      * ensure sufficient parallelism while the current thread is blocked.      *      *<p>If the caller is not a {@link ForkJoinTask}, this method is      * behaviorally equivalent to      *<pre> {@code      * while (!blocker.isReleasable())      *   if (blocker.block())      *     return;      * }</pre>      *      * If the caller is a {@code ForkJoinTask}, then the pool may      * first be expanded to ensure parallelism, and later adjusted.      *      * @param blocker the blocker      * @throws InterruptedException if blocker.block did so      */
DECL|method|managedBlock
specifier|public
specifier|static
name|void
name|managedBlock
parameter_list|(
name|ManagedBlocker
name|blocker
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|ForkJoinPool
name|p
init|=
operator|(
operator|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|?
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
else|:
literal|null
operator|)
decl_stmt|;
while|while
condition|(
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
condition|)
block|{
if|if
condition|(
name|p
operator|==
literal|null
operator|||
name|p
operator|.
name|tryCompensate
argument_list|(
literal|null
argument_list|,
name|blocker
argument_list|)
condition|)
block|{
try|try
block|{
do|do
block|{}
do|while
condition|(
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
operator|&&
operator|!
name|blocker
operator|.
name|block
argument_list|()
condition|)
do|;
block|}
finally|finally
block|{
if|if
condition|(
name|p
operator|!=
literal|null
condition|)
name|p
operator|.
name|incrementActiveCount
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|// AbstractExecutorService overrides.  These rely on undocumented
comment|// fact that ForkJoinTask.adapt returns ForkJoinTasks that also
comment|// implement RunnableFuture.
DECL|method|newTaskFor
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|RunnableFuture
argument_list|<
name|T
argument_list|>
name|newTaskFor
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|T
name|value
parameter_list|)
block|{
return|return
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnable
argument_list|<
name|T
argument_list|>
argument_list|(
name|runnable
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|newTaskFor
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|RunnableFuture
argument_list|<
name|T
argument_list|>
name|newTaskFor
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
block|{
return|return
operator|new
name|ForkJoinTask
operator|.
name|AdaptedCallable
argument_list|<
name|T
argument_list|>
argument_list|(
name|callable
argument_list|)
return|;
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|CTL
specifier|private
specifier|static
specifier|final
name|long
name|CTL
decl_stmt|;
DECL|field|PARKBLOCKER
specifier|private
specifier|static
specifier|final
name|long
name|PARKBLOCKER
decl_stmt|;
DECL|field|ABASE
specifier|private
specifier|static
specifier|final
name|int
name|ABASE
decl_stmt|;
DECL|field|ASHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ASHIFT
decl_stmt|;
static|static
block|{
name|poolNumberGenerator
operator|=
operator|new
name|AtomicInteger
argument_list|()
expr_stmt|;
name|nextSubmitterSeed
operator|=
operator|new
name|AtomicInteger
argument_list|(
literal|0x55555555
argument_list|)
expr_stmt|;
name|modifyThreadPermission
operator|=
operator|new
name|RuntimePermission
argument_list|(
literal|"modifyThread"
argument_list|)
expr_stmt|;
name|defaultForkJoinWorkerThreadFactory
operator|=
operator|new
name|DefaultForkJoinWorkerThreadFactory
argument_list|()
expr_stmt|;
name|submitters
operator|=
operator|new
name|ThreadSubmitter
argument_list|()
expr_stmt|;
name|int
name|s
decl_stmt|;
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|ForkJoinPool
operator|.
name|class
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|ak
init|=
name|ForkJoinTask
index|[]
operator|.
name|class
decl_stmt|;
name|CTL
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"ctl"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|tk
init|=
name|Thread
operator|.
name|class
decl_stmt|;
name|PARKBLOCKER
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|tk
operator|.
name|getDeclaredField
argument_list|(
literal|"parkBlocker"
argument_list|)
argument_list|)
expr_stmt|;
name|ABASE
operator|=
name|U
operator|.
name|arrayBaseOffset
argument_list|(
name|ak
argument_list|)
expr_stmt|;
name|s
operator|=
name|U
operator|.
name|arrayIndexScale
argument_list|(
name|ak
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
if|if
condition|(
operator|(
name|s
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|ASHIFT
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

