begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166y
package|package
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|AbstractExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Callable
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|ExecutorService
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|Future
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RejectedExecutionException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|RunnableFuture
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_comment
comment|/**  * An {@link ExecutorService} for running {@link ForkJoinTask}s.  * A {@code ForkJoinPool} provides the entry point for submissions  * from non-{@code ForkJoinTask} clients, as well as management and  * monitoring operations.  *  *<p>A {@code ForkJoinPool} differs from other kinds of {@link  * ExecutorService} mainly by virtue of employing  *<em>work-stealing</em>: all threads in the pool attempt to find and  * execute tasks submitted to the pool and/or created by other active  * tasks (eventually blocking waiting for work if none exist). This  * enables efficient processing when most tasks spawn other subtasks  * (as do most {@code ForkJoinTask}s), as well as when many small  * tasks are submitted to the pool from external clients.  Especially  * when setting<em>asyncMode</em> to true in constructors, {@code  * ForkJoinPool}s may also be appropriate for use with event-style  * tasks that are never joined.  *  *<p>A static {@link #commonPool()} is available and appropriate for  * most applications. The common pool is used by any ForkJoinTask that  * is not explicitly submitted to a specified pool. Using the common  * pool normally reduces resource usage (its threads are slowly  * reclaimed during periods of non-use, and reinstated upon subsequent  * use).  *  *<p>For applications that require separate or custom pools, a {@code  * ForkJoinPool} may be constructed with a given target parallelism  * level; by default, equal to the number of available processors. The  * pool attempts to maintain enough active (or available) threads by  * dynamically adding, suspending, or resuming internal worker  * threads, even if some tasks are stalled waiting to join  * others. However, no such adjustments are guaranteed in the face of  * blocked I/O or other unmanaged synchronization. The nested {@link  * ManagedBlocker} interface enables extension of the kinds of  * synchronization accommodated.  *  *<p>In addition to execution and lifecycle control methods, this  * class provides status check methods (for example  * {@link #getStealCount}) that are intended to aid in developing,  * tuning, and monitoring fork/join applications. Also, method  * {@link #toString} returns indications of pool state in a  * convenient form for informal monitoring.  *  *<p>As is the case with other ExecutorServices, there are three  * main task execution methods summarized in the following table.  * These are designed to be used primarily by clients not already  * engaged in fork/join computations in the current pool.  The main  * forms of these methods accept instances of {@code ForkJoinTask},  * but overloaded forms also allow mixed execution of plain {@code  * Runnable}- or {@code Callable}- based activities as well.  However,  * tasks that are already executing in a pool should normally instead  * use the within-computation forms listed in the table unless using  * async event-style tasks that are not usually joined, in which case  * there is little difference among choice of methods.  *  *<table BORDER CELLPADDING=3 CELLSPACING=1>  *<tr>  *<td></td>  *<td ALIGN=CENTER><b>Call from non-fork/join clients</b></td>  *<td ALIGN=CENTER><b>Call from within fork/join computations</b></td>  *</tr>  *<tr>  *<td><b>Arrange async execution</td>  *<td> {@link #execute(ForkJoinTask)}</td>  *<td> {@link ForkJoinTask#fork}</td>  *</tr>  *<tr>  *<td><b>Await and obtain result</td>  *<td> {@link #invoke(ForkJoinTask)}</td>  *<td> {@link ForkJoinTask#invoke}</td>  *</tr>  *<tr>  *<td><b>Arrange exec and obtain Future</td>  *<td> {@link #submit(ForkJoinTask)}</td>  *<td> {@link ForkJoinTask#fork} (ForkJoinTasks<em>are</em> Futures)</td>  *</tr>  *</table>  *  *<p>The common pool is by default constructed with default  * parameters, but these may be controlled by setting three {@link  * System#getProperty system properties} with prefix {@code  * java.util.concurrent.ForkJoinPool.common}: {@code parallelism} --  * an integer greater than zero, {@code threadFactory} -- the class  * name of a {@link ForkJoinWorkerThreadFactory}, and {@code  * exceptionHandler} -- the class name of a {@link  * java.lang.Thread.UncaughtExceptionHandler  * Thread.UncaughtExceptionHandler}. Upon any error in establishing  * these settings, default parameters are used.  *  *<p><b>Implementation notes</b>: This implementation restricts the  * maximum number of running threads to 32767. Attempts to create  * pools with greater than the maximum number result in  * {@code IllegalArgumentException}.  *  *<p>This implementation rejects submitted tasks (that is, by throwing  * {@link RejectedExecutionException}) only when the pool is shut down  * or internal resources have been exhausted.  *  * @since 1.7  * @author Doug Lea  */
end_comment

begin_class
DECL|class|ForkJoinPool
specifier|public
class|class
name|ForkJoinPool
extends|extends
name|AbstractExecutorService
block|{
comment|/*      * Implementation Overview      *      * This class and its nested classes provide the main      * functionality and control for a set of worker threads:      * Submissions from non-FJ threads enter into submission queues.      * Workers take these tasks and typically split them into subtasks      * that may be stolen by other workers.  Preference rules give      * first priority to processing tasks from their own queues (LIFO      * or FIFO, depending on mode), then to randomized FIFO steals of      * tasks in other queues.      *      * WorkQueues      * ==========      *      * Most operations occur within work-stealing queues (in nested      * class WorkQueue).  These are special forms of Deques that      * support only three of the four possible end-operations -- push,      * pop, and poll (aka steal), under the further constraints that      * push and pop are called only from the owning thread (or, as      * extended here, under a lock), while poll may be called from      * other threads.  (If you are unfamiliar with them, you probably      * want to read Herlihy and Shavit's book "The Art of      * Multiprocessor programming", chapter 16 describing these in      * more detail before proceeding.)  The main work-stealing queue      * design is roughly similar to those in the papers "Dynamic      * Circular Work-Stealing Deque" by Chase and Lev, SPAA 2005      * (http://research.sun.com/scalable/pubs/index.html) and      * "Idempotent work stealing" by Michael, Saraswat, and Vechev,      * PPoPP 2009 (http://portal.acm.org/citation.cfm?id=1504186).      * The main differences ultimately stem from GC requirements that      * we null out taken slots as soon as we can, to maintain as small      * a footprint as possible even in programs generating huge      * numbers of tasks. To accomplish this, we shift the CAS      * arbitrating pop vs poll (steal) from being on the indices      * ("base" and "top") to the slots themselves.  So, both a      * successful pop and poll mainly entail a CAS of a slot from      * non-null to null.  Because we rely on CASes of references, we      * do not need tag bits on base or top.  They are simple ints as      * used in any circular array-based queue (see for example      * ArrayDeque).  Updates to the indices must still be ordered in a      * way that guarantees that top == base means the queue is empty,      * but otherwise may err on the side of possibly making the queue      * appear nonempty when a push, pop, or poll have not fully      * committed. Note that this means that the poll operation,      * considered individually, is not wait-free. One thief cannot      * successfully continue until another in-progress one (or, if      * previously empty, a push) completes.  However, in the      * aggregate, we ensure at least probabilistic non-blockingness.      * If an attempted steal fails, a thief always chooses a different      * random victim target to try next. So, in order for one thief to      * progress, it suffices for any in-progress poll or new push on      * any empty queue to complete. (This is why we normally use      * method pollAt and its variants that try once at the apparent      * base index, else consider alternative actions, rather than      * method poll.)      *      * This approach also enables support of a user mode in which local      * task processing is in FIFO, not LIFO order, simply by using      * poll rather than pop.  This can be useful in message-passing      * frameworks in which tasks are never joined.  However neither      * mode considers affinities, loads, cache localities, etc, so      * rarely provide the best possible performance on a given      * machine, but portably provide good throughput by averaging over      * these factors.  (Further, even if we did try to use such      * information, we do not usually have a basis for exploiting it.      * For example, some sets of tasks profit from cache affinities,      * but others are harmed by cache pollution effects.)      *      * WorkQueues are also used in a similar way for tasks submitted      * to the pool. We cannot mix these tasks in the same queues used      * for work-stealing (this would contaminate lifo/fifo      * processing). Instead, we randomly associate submission queues      * with submitting threads, using a form of hashing.  The      * ThreadLocal Submitter class contains a value initially used as      * a hash code for choosing existing queues, but may be randomly      * repositioned upon contention with other submitters.  In      * essence, submitters act like workers except that they are      * restricted to executing local tasks that they submitted (or in      * the case of CountedCompleters, others with the same root task).      * However, because most shared/external queue operations are more      * expensive than internal, and because, at steady state, external      * submitters will compete for CPU with workers, ForkJoinTask.join      * and related methods disable them from repeatedly helping to      * process tasks if all workers are active.  Insertion of tasks in      * shared mode requires a lock (mainly to protect in the case of      * resizing) but we use only a simple spinlock (using bits in      * field qlock), because submitters encountering a busy queue move      * on to try or create other queues -- they block only when      * creating and registering new queues.      *      * Management      * ==========      *      * The main throughput advantages of work-stealing stem from      * decentralized control -- workers mostly take tasks from      * themselves or each other. We cannot negate this in the      * implementation of other management responsibilities. The main      * tactic for avoiding bottlenecks is packing nearly all      * essentially atomic control state into two volatile variables      * that are by far most often read (not written) as status and      * consistency checks.      *      * Field "ctl" contains 64 bits holding all the information needed      * to atomically decide to add, inactivate, enqueue (on an event      * queue), dequeue, and/or re-activate workers.  To enable this      * packing, we restrict maximum parallelism to (1<<15)-1 (which is      * far in excess of normal operating range) to allow ids, counts,      * and their negations (used for thresholding) to fit into 16bit      * fields.      *      * Field "plock" is a form of sequence lock with a saturating      * shutdown bit (similarly for per-queue "qlocks"), mainly      * protecting updates to the workQueues array, as well as to      * enable shutdown.  When used as a lock, it is normally only very      * briefly held, so is nearly always available after at most a      * brief spin, but we use a monitor-based backup strategy to      * block when needed.      *      * Recording WorkQueues.  WorkQueues are recorded in the      * "workQueues" array that is created upon first use and expanded      * if necessary.  Updates to the array while recording new workers      * and unrecording terminated ones are protected from each other      * by a lock but the array is otherwise concurrently readable, and      * accessed directly.  To simplify index-based operations, the      * array size is always a power of two, and all readers must      * tolerate null slots. Worker queues are at odd indices. Shared      * (submission) queues are at even indices, up to a maximum of 64      * slots, to limit growth even if array needs to expand to add      * more workers. Grouping them together in this way simplifies and      * speeds up task scanning.      *      * All worker thread creation is on-demand, triggered by task      * submissions, replacement of terminated workers, and/or      * compensation for blocked workers. However, all other support      * code is set up to work with other policies.  To ensure that we      * do not hold on to worker references that would prevent GC, ALL      * accesses to workQueues are via indices into the workQueues      * array (which is one source of some of the messy code      * constructions here). In essence, the workQueues array serves as      * a weak reference mechanism. Thus for example the wait queue      * field of ctl stores indices, not references.  Access to the      * workQueues in associated methods (for example signalWork) must      * both index-check and null-check the IDs. All such accesses      * ignore bad IDs by returning out early from what they are doing,      * since this can only be associated with termination, in which      * case it is OK to give up.  All uses of the workQueues array      * also check that it is non-null (even if previously      * non-null). This allows nulling during termination, which is      * currently not necessary, but remains an option for      * resource-revocation-based shutdown schemes. It also helps      * reduce JIT issuance of uncommon-trap code, which tends to      * unnecessarily complicate control flow in some methods.      *      * Event Queuing. Unlike HPC work-stealing frameworks, we cannot      * let workers spin indefinitely scanning for tasks when none can      * be found immediately, and we cannot start/resume workers unless      * there appear to be tasks available.  On the other hand, we must      * quickly prod them into action when new tasks are submitted or      * generated. In many usages, ramp-up time to activate workers is      * the main limiting factor in overall performance (this is      * compounded at program start-up by JIT compilation and      * allocation). So we try to streamline this as much as possible.      * We park/unpark workers after placing in an event wait queue      * when they cannot find work. This "queue" is actually a simple      * Treiber stack, headed by the "id" field of ctl, plus a 15bit      * counter value (that reflects the number of times a worker has      * been inactivated) to avoid ABA effects (we need only as many      * version numbers as worker threads). Successors are held in      * field WorkQueue.nextWait.  Queuing deals with several intrinsic      * races, mainly that a task-producing thread can miss seeing (and      * signalling) another thread that gave up looking for work but      * has not yet entered the wait queue. We solve this by requiring      * a full sweep of all workers (via repeated calls to method      * scan()) both before and after a newly waiting worker is added      * to the wait queue. During a rescan, the worker might release      * some other queued worker rather than itself, which has the same      * net effect. Because enqueued workers may actually be rescanning      * rather than waiting, we set and clear the "parker" field of      * WorkQueues to reduce unnecessary calls to unpark.  (This      * requires a secondary recheck to avoid missed signals.)  Note      * the unusual conventions about Thread.interrupts surrounding      * parking and other blocking: Because interrupts are used solely      * to alert threads to check termination, which is checked anyway      * upon blocking, we clear status (using Thread.interrupted)      * before any call to park, so that park does not immediately      * return due to status being set via some other unrelated call to      * interrupt in user code.      *      * Signalling.  We create or wake up workers only when there      * appears to be at least one task they might be able to find and      * execute. However, many other threads may notice the same task      * and each signal to wake up a thread that might take it. So in      * general, pools will be over-signalled.  When a submission is      * added or another worker adds a task to a queue that has fewer      * than two tasks, they signal waiting workers (or trigger      * creation of new ones if fewer than the given parallelism level      * -- signalWork), and may leave a hint to the unparked worker to      * help signal others upon wakeup).  These primary signals are      * buttressed by others (see method helpSignal) whenever other      * threads scan for work or do not have a task to process.  On      * most platforms, signalling (unpark) overhead time is noticeably      * long, and the time between signalling a thread and it actually      * making progress can be very noticeably long, so it is worth      * offloading these delays from critical paths as much as      * possible.      *      * Trimming workers. To release resources after periods of lack of      * use, a worker starting to wait when the pool is quiescent will      * time out and terminate if the pool has remained quiescent for a      * given period -- a short period if there are more threads than      * parallelism, longer as the number of threads decreases. This      * will slowly propagate, eventually terminating all workers after      * periods of non-use.      *      * Shutdown and Termination. A call to shutdownNow atomically sets      * a plock bit and then (non-atomically) sets each worker's      * qlock status, cancels all unprocessed tasks, and wakes up      * all waiting workers.  Detecting whether termination should      * commence after a non-abrupt shutdown() call requires more work      * and bookkeeping. We need consensus about quiescence (i.e., that      * there is no more work). The active count provides a primary      * indication but non-abrupt shutdown still requires a rechecking      * scan for any workers that are inactive but not queued.      *      * Joining Tasks      * =============      *      * Any of several actions may be taken when one worker is waiting      * to join a task stolen (or always held) by another.  Because we      * are multiplexing many tasks on to a pool of workers, we can't      * just let them block (as in Thread.join).  We also cannot just      * reassign the joiner's run-time stack with another and replace      * it later, which would be a form of "continuation", that even if      * possible is not necessarily a good idea since we sometimes need      * both an unblocked task and its continuation to progress.      * Instead we combine two tactics:      *      *   Helping: Arranging for the joiner to execute some task that it      *      would be running if the steal had not occurred.      *      *   Compensating: Unless there are already enough live threads,      *      method tryCompensate() may create or re-activate a spare      *      thread to compensate for blocked joiners until they unblock.      *      * A third form (implemented in tryRemoveAndExec) amounts to      * helping a hypothetical compensator: If we can readily tell that      * a possible action of a compensator is to steal and execute the      * task being joined, the joining thread can do so directly,      * without the need for a compensation thread (although at the      * expense of larger run-time stacks, but the tradeoff is      * typically worthwhile).      *      * The ManagedBlocker extension API can't use helping so relies      * only on compensation in method awaitBlocker.      *      * The algorithm in tryHelpStealer entails a form of "linear"      * helping: Each worker records (in field currentSteal) the most      * recent task it stole from some other worker. Plus, it records      * (in field currentJoin) the task it is currently actively      * joining. Method tryHelpStealer uses these markers to try to      * find a worker to help (i.e., steal back a task from and execute      * it) that could hasten completion of the actively joined task.      * In essence, the joiner executes a task that would be on its own      * local deque had the to-be-joined task not been stolen. This may      * be seen as a conservative variant of the approach in Wagner&      * Calder "Leapfrogging: a portable technique for implementing      * efficient futures" SIGPLAN Notices, 1993      * (http://portal.acm.org/citation.cfm?id=155354). It differs in      * that: (1) We only maintain dependency links across workers upon      * steals, rather than use per-task bookkeeping.  This sometimes      * requires a linear scan of workQueues array to locate stealers,      * but often doesn't because stealers leave hints (that may become      * stale/wrong) of where to locate them.  It is only a hint      * because a worker might have had multiple steals and the hint      * records only one of them (usually the most current).  Hinting      * isolates cost to when it is needed, rather than adding to      * per-task overhead.  (2) It is "shallow", ignoring nesting and      * potentially cyclic mutual steals.  (3) It is intentionally      * racy: field currentJoin is updated only while actively joining,      * which means that we miss links in the chain during long-lived      * tasks, GC stalls etc (which is OK since blocking in such cases      * is usually a good idea).  (4) We bound the number of attempts      * to find work (see MAX_HELP) and fall back to suspending the      * worker and if necessary replacing it with another.      *      * Helping actions for CountedCompleters are much simpler: Method      * helpComplete can take and execute any task with the same root      * as the task being waited on. However, this still entails some      * traversal of completer chains, so is less efficient than using      * CountedCompleters without explicit joins.      *      * It is impossible to keep exactly the target parallelism number      * of threads running at any given time.  Determining the      * existence of conservatively safe helping targets, the      * availability of already-created spares, and the apparent need      * to create new spares are all racy, so we rely on multiple      * retries of each.  Compensation in the apparent absence of      * helping opportunities is challenging to control on JVMs, where      * GC and other activities can stall progress of tasks that in      * turn stall out many other dependent tasks, without us being      * able to determine whether they will ever require compensation.      * Even though work-stealing otherwise encounters little      * degradation in the presence of more threads than cores,      * aggressively adding new threads in such cases entails risk of      * unwanted positive feedback control loops in which more threads      * cause more dependent stalls (as well as delayed progress of      * unblocked threads to the point that we know they are available)      * leading to more situations requiring more threads, and so      * on. This aspect of control can be seen as an (analytically      * intractable) game with an opponent that may choose the worst      * (for us) active thread to stall at any time.  We take several      * precautions to bound losses (and thus bound gains), mainly in      * methods tryCompensate and awaitJoin.      *      * Common Pool      * ===========      *      * The static common Pool always exists after static      * initialization.  Since it (or any other created pool) need      * never be used, we minimize initial construction overhead and      * footprint to the setup of about a dozen fields, with no nested      * allocation. Most bootstrapping occurs within method      * fullExternalPush during the first submission to the pool.      *      * When external threads submit to the common pool, they can      * perform some subtask processing (see externalHelpJoin and      * related methods).  We do not need to record whether these      * submissions are to the common pool -- if not, externalHelpJoin      * returns quickly (at the most helping to signal some common pool      * workers). These submitters would otherwise be blocked waiting      * for completion, so the extra effort (with liberally sprinkled      * task status checks) in inapplicable cases amounts to an odd      * form of limited spin-wait before blocking in ForkJoinTask.join.      *      * Style notes      * ===========      *      * There is a lot of representation-level coupling among classes      * ForkJoinPool, ForkJoinWorkerThread, and ForkJoinTask.  The      * fields of WorkQueue maintain data structures managed by      * ForkJoinPool, so are directly accessed.  There is little point      * trying to reduce this, since any associated future changes in      * representations will need to be accompanied by algorithmic      * changes anyway. Several methods intrinsically sprawl because      * they must accumulate sets of consistent reads of volatiles held      * in local variables.  Methods signalWork() and scan() are the      * main bottlenecks, so are especially heavily      * micro-optimized/mangled.  There are lots of inline assignments      * (of form "while ((local = field) != 0)") which are usually the      * simplest way to ensure the required read orderings (which are      * sometimes critical). This leads to a "C"-like style of listing      * declarations of these locals at the heads of methods or blocks.      * There are several occurrences of the unusual "do {} while      * (!cas...)"  which is the simplest way to force an update of a      * CAS'ed variable. There are also other coding oddities (including      * several unnecessary-looking hoisted null checks) that help      * some methods perform reasonably even when interpreted (not      * compiled).      *      * The order of declarations in this file is:      * (1) Static utility functions      * (2) Nested (static) classes      * (3) Static fields      * (4) Fields, along with constants used when unpacking some of them      * (5) Internal control methods      * (6) Callbacks and other support for ForkJoinTask methods      * (7) Exported methods      * (8) Static block initializing statics in minimally dependent order      */
comment|// Static utilities
comment|/**      * If there is a security manager, makes sure caller has      * permission to modify threads.      */
DECL|method|checkPermission
specifier|private
specifier|static
name|void
name|checkPermission
parameter_list|()
block|{
name|SecurityManager
name|security
init|=
name|System
operator|.
name|getSecurityManager
argument_list|()
decl_stmt|;
if|if
condition|(
name|security
operator|!=
literal|null
condition|)
name|security
operator|.
name|checkPermission
argument_list|(
name|modifyThreadPermission
argument_list|)
expr_stmt|;
block|}
comment|// Nested classes
comment|/**      * Factory for creating new {@link ForkJoinWorkerThread}s.      * A {@code ForkJoinWorkerThreadFactory} must be defined and used      * for {@code ForkJoinWorkerThread} subclasses that extend base      * functionality or initialize threads with different contexts.      */
DECL|interface|ForkJoinWorkerThreadFactory
specifier|public
specifier|static
interface|interface
name|ForkJoinWorkerThreadFactory
block|{
comment|/**          * Returns a new worker thread operating in the given pool.          *          * @param pool the pool this thread works in          * @throws NullPointerException if the pool is null          */
DECL|method|newThread
specifier|public
name|ForkJoinWorkerThread
name|newThread
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|)
function_decl|;
block|}
comment|/**      * Default ForkJoinWorkerThreadFactory implementation; creates a      * new ForkJoinWorkerThread.      */
DECL|class|DefaultForkJoinWorkerThreadFactory
specifier|static
specifier|final
class|class
name|DefaultForkJoinWorkerThreadFactory
implements|implements
name|ForkJoinWorkerThreadFactory
block|{
DECL|method|newThread
specifier|public
specifier|final
name|ForkJoinWorkerThread
name|newThread
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|)
block|{
return|return
operator|new
name|ForkJoinWorkerThread
argument_list|(
name|pool
argument_list|)
return|;
block|}
block|}
comment|/**      * Per-thread records for threads that submit to pools. Currently      * holds only pseudo-random seed / index that is used to choose      * submission queues in method externalPush. In the future, this may      * also incorporate a means to implement different task rejection      * and resubmission policies.      *      * Seeds for submitters and workers/workQueues work in basically      * the same way but are initialized and updated using slightly      * different mechanics. Both are initialized using the same      * approach as in class ThreadLocal, where successive values are      * unlikely to collide with previous values. Seeds are then      * randomly modified upon collisions using xorshifts, which      * requires a non-zero seed.      */
DECL|class|Submitter
specifier|static
specifier|final
class|class
name|Submitter
block|{
DECL|field|seed
name|int
name|seed
decl_stmt|;
DECL|method|Submitter
name|Submitter
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|seed
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|/**      * Class for artificial tasks that are used to replace the target      * of local joins if they are removed from an interior queue slot      * in WorkQueue.tryRemoveAndExec. We don't need the proxy to      * actually do anything beyond having a unique identity.      */
DECL|class|EmptyTask
specifier|static
specifier|final
class|class
name|EmptyTask
extends|extends
name|ForkJoinTask
argument_list|<
name|Void
argument_list|>
block|{
DECL|field|serialVersionUID
specifier|private
specifier|static
specifier|final
name|long
name|serialVersionUID
init|=
operator|-
literal|7721805057305804111L
decl_stmt|;
DECL|method|EmptyTask
name|EmptyTask
parameter_list|()
block|{
name|status
operator|=
name|ForkJoinTask
operator|.
name|NORMAL
expr_stmt|;
block|}
comment|// force done
DECL|method|getRawResult
specifier|public
specifier|final
name|Void
name|getRawResult
parameter_list|()
block|{
return|return
literal|null
return|;
block|}
DECL|method|setRawResult
specifier|public
specifier|final
name|void
name|setRawResult
parameter_list|(
name|Void
name|x
parameter_list|)
block|{}
DECL|method|exec
specifier|public
specifier|final
name|boolean
name|exec
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
block|}
comment|/**      * Queues supporting work-stealing as well as external task      * submission. See above for main rationale and algorithms.      * Implementation relies heavily on "Unsafe" intrinsics      * and selective use of "volatile":      *      * Field "base" is the index (mod array.length) of the least valid      * queue slot, which is always the next position to steal (poll)      * from if nonempty. Reads and writes require volatile orderings      * but not CAS, because updates are only performed after slot      * CASes.      *      * Field "top" is the index (mod array.length) of the next queue      * slot to push to or pop from. It is written only by owner thread      * for push, or under lock for external/shared push, and accessed      * by other threads only after reading (volatile) base.  Both top      * and base are allowed to wrap around on overflow, but (top -      * base) (or more commonly -(base - top) to force volatile read of      * base before top) still estimates size. The lock ("qlock") is      * forced to -1 on termination, causing all further lock attempts      * to fail. (Note: we don't need CAS for termination state because      * upon pool shutdown, all shared-queues will stop being used      * anyway.)  Nearly all lock bodies are set up so that exceptions      * within lock bodies are "impossible" (modulo JVM errors that      * would cause failure anyway.)      *      * The array slots are read and written using the emulation of      * volatiles/atomics provided by Unsafe. Insertions must in      * general use putOrderedObject as a form of releasing store to      * ensure that all writes to the task object are ordered before      * its publication in the queue.  All removals entail a CAS to      * null.  The array is always a power of two. To ensure safety of      * Unsafe array operations, all accesses perform explicit null      * checks and implicit bounds checks via power-of-two masking.      *      * In addition to basic queuing support, this class contains      * fields described elsewhere to control execution. It turns out      * to work better memory-layout-wise to include them in this class      * rather than a separate class.      *      * Performance on most platforms is very sensitive to placement of      * instances of both WorkQueues and their arrays -- we absolutely      * do not want multiple WorkQueue instances or multiple queue      * arrays sharing cache lines. (It would be best for queue objects      * and their arrays to share, but there is nothing available to      * help arrange that).  Unfortunately, because they are recorded      * in a common array, WorkQueue instances are often moved to be      * adjacent by garbage collectors. To reduce impact, we use field      * padding that works OK on common platforms; this effectively      * trades off slightly slower average field access for the sake of      * avoiding really bad worst-case access. (Until better JVM      * support is in place, this padding is dependent on transient      * properties of JVM field layout rules.) We also take care in      * allocating, sizing and resizing the array. Non-shared queue      * arrays are initialized by workers before use. Others are      * allocated on first use.      */
DECL|class|WorkQueue
specifier|static
specifier|final
class|class
name|WorkQueue
block|{
comment|/**          * Capacity of work-stealing queue array upon initialization.          * Must be a power of two; at least 4, but should be larger to          * reduce or eliminate cacheline sharing among queues.          * Currently, it is much larger, as a partial workaround for          * the fact that JVMs often place arrays in locations that          * share GC bookkeeping (especially cardmarks) such that          * per-write accesses encounter serious memory contention.          */
DECL|field|INITIAL_QUEUE_CAPACITY
specifier|static
specifier|final
name|int
name|INITIAL_QUEUE_CAPACITY
init|=
literal|1
operator|<<
literal|13
decl_stmt|;
comment|/**          * Maximum size for queue arrays. Must be a power of two less          * than or equal to 1<< (31 - width of array entry) to ensure          * lack of wraparound of index calculations, but defined to a          * value a bit less than this to help users trap runaway          * programs before saturating systems.          */
DECL|field|MAXIMUM_QUEUE_CAPACITY
specifier|static
specifier|final
name|int
name|MAXIMUM_QUEUE_CAPACITY
init|=
literal|1
operator|<<
literal|26
decl_stmt|;
comment|// 64M
comment|// Heuristic padding to ameliorate unfortunate memory placements
DECL|field|pad00
DECL|field|pad01
DECL|field|pad02
DECL|field|pad03
DECL|field|pad04
DECL|field|pad05
DECL|field|pad06
specifier|volatile
name|long
name|pad00
decl_stmt|,
name|pad01
decl_stmt|,
name|pad02
decl_stmt|,
name|pad03
decl_stmt|,
name|pad04
decl_stmt|,
name|pad05
decl_stmt|,
name|pad06
decl_stmt|;
DECL|field|seed
name|int
name|seed
decl_stmt|;
comment|// for random scanning; initialize nonzero
DECL|field|eventCount
specifier|volatile
name|int
name|eventCount
decl_stmt|;
comment|// encoded inactivation count;< 0 if inactive
DECL|field|nextWait
name|int
name|nextWait
decl_stmt|;
comment|// encoded record of next event waiter
DECL|field|hint
name|int
name|hint
decl_stmt|;
comment|// steal or signal hint (index)
DECL|field|poolIndex
name|int
name|poolIndex
decl_stmt|;
comment|// index of this queue in pool (or 0)
DECL|field|mode
specifier|final
name|int
name|mode
decl_stmt|;
comment|// 0: lifo,> 0: fifo,< 0: shared
DECL|field|nsteals
name|int
name|nsteals
decl_stmt|;
comment|// number of steals
DECL|field|qlock
specifier|volatile
name|int
name|qlock
decl_stmt|;
comment|// 1: locked, -1: terminate; else 0
DECL|field|base
specifier|volatile
name|int
name|base
decl_stmt|;
comment|// index of next slot for poll
DECL|field|top
name|int
name|top
decl_stmt|;
comment|// index of next slot for push
DECL|field|array
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|array
decl_stmt|;
comment|// the elements (initially unallocated)
DECL|field|pool
specifier|final
name|ForkJoinPool
name|pool
decl_stmt|;
comment|// the containing pool (may be null)
DECL|field|owner
specifier|final
name|ForkJoinWorkerThread
name|owner
decl_stmt|;
comment|// owning thread or null if shared
DECL|field|parker
specifier|volatile
name|Thread
name|parker
decl_stmt|;
comment|// == owner during call to park; else null
DECL|field|currentJoin
specifier|volatile
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|currentJoin
decl_stmt|;
comment|// task being joined in awaitJoin
DECL|field|currentSteal
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|currentSteal
decl_stmt|;
comment|// current non-local task being executed
DECL|field|pad10
DECL|field|pad11
DECL|field|pad12
DECL|field|pad13
DECL|field|pad14
DECL|field|pad15
DECL|field|pad16
DECL|field|pad17
specifier|volatile
name|Object
name|pad10
decl_stmt|,
name|pad11
decl_stmt|,
name|pad12
decl_stmt|,
name|pad13
decl_stmt|,
name|pad14
decl_stmt|,
name|pad15
decl_stmt|,
name|pad16
decl_stmt|,
name|pad17
decl_stmt|;
DECL|field|pad18
DECL|field|pad19
DECL|field|pad1a
DECL|field|pad1b
DECL|field|pad1c
DECL|field|pad1d
specifier|volatile
name|Object
name|pad18
decl_stmt|,
name|pad19
decl_stmt|,
name|pad1a
decl_stmt|,
name|pad1b
decl_stmt|,
name|pad1c
decl_stmt|,
name|pad1d
decl_stmt|;
DECL|method|WorkQueue
name|WorkQueue
parameter_list|(
name|ForkJoinPool
name|pool
parameter_list|,
name|ForkJoinWorkerThread
name|owner
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|seed
parameter_list|)
block|{
name|this
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|this
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|this
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|this
operator|.
name|seed
operator|=
name|seed
expr_stmt|;
comment|// Place indices in the center of array (that is not yet allocated)
name|base
operator|=
name|top
operator|=
name|INITIAL_QUEUE_CAPACITY
operator|>>>
literal|1
expr_stmt|;
block|}
comment|/**          * Returns the approximate number of tasks in the queue.          */
DECL|method|queueSize
specifier|final
name|int
name|queueSize
parameter_list|()
block|{
name|int
name|n
init|=
name|base
operator|-
name|top
decl_stmt|;
comment|// non-owner callers must read base first
return|return
operator|(
name|n
operator|>=
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
name|n
return|;
comment|// ignore transient negative
block|}
comment|/**          * Provides a more accurate estimate of whether this queue has          * any tasks than does queueSize, by checking whether a          * near-empty queue has at least one unclaimed task.          */
DECL|method|isEmpty
specifier|final
name|boolean
name|isEmpty
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|;
name|int
name|n
init|=
name|base
operator|-
operator|(
name|s
operator|=
name|top
operator|)
decl_stmt|;
return|return
operator|(
name|n
operator|>=
literal|0
operator|||
operator|(
name|n
operator|==
operator|-
literal|1
operator|&&
operator|(
operator|(
name|a
operator|=
name|array
operator|)
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|0
operator|||
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|m
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|<<
name|ASHIFT
argument_list|)
operator|+
name|ABASE
argument_list|)
operator|==
literal|null
operator|)
operator|)
operator|)
return|;
block|}
comment|/**          * Pushes a task. Call only by owner in unshared queues.  (The          * shared-queue version is embedded in method externalPush.)          *          * @param task the task. Caller must ensure non-null.          * @throws RejectedExecutionException if array cannot be resized          */
DECL|method|push
specifier|final
name|void
name|push
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|ForkJoinPool
name|p
decl_stmt|;
name|int
name|s
init|=
name|top
decl_stmt|,
name|m
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// ignore if queue removed
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|U
operator|.
name|putOrderedObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|top
operator|=
name|s
operator|+
literal|1
operator|)
operator|-
name|base
operator|)
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|pool
operator|)
operator|!=
literal|null
condition|)
name|p
operator|.
name|signalWork
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>=
name|m
condition|)
name|growArray
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**          * Initializes or doubles the capacity of array. Call either          * by owner or with lock held -- it is OK for base, but not          * top, to move while resizings are in progress.          */
DECL|method|growArray
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|growArray
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|oldA
init|=
name|array
decl_stmt|;
name|int
name|size
init|=
name|oldA
operator|!=
literal|null
condition|?
name|oldA
operator|.
name|length
operator|<<
literal|1
else|:
name|INITIAL_QUEUE_CAPACITY
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|MAXIMUM_QUEUE_CAPACITY
condition|)
throw|throw
operator|new
name|RejectedExecutionException
argument_list|(
literal|"Queue capacity exceeded"
argument_list|)
throw|;
name|int
name|oldMask
decl_stmt|,
name|t
decl_stmt|,
name|b
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
init|=
name|array
operator|=
operator|new
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[
name|size
index|]
decl_stmt|;
if|if
condition|(
name|oldA
operator|!=
literal|null
operator|&&
operator|(
name|oldMask
operator|=
name|oldA
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|t
operator|=
name|top
operator|)
operator|-
operator|(
name|b
operator|=
name|base
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|mask
init|=
name|size
operator|-
literal|1
decl_stmt|;
do|do
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|x
decl_stmt|;
name|int
name|oldj
init|=
operator|(
operator|(
name|b
operator|&
name|oldMask
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|int
name|j
init|=
operator|(
operator|(
name|b
operator|&
name|mask
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|x
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|oldA
argument_list|,
name|oldj
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|null
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|oldA
argument_list|,
name|oldj
argument_list|,
name|x
argument_list|,
literal|null
argument_list|)
condition|)
name|U
operator|.
name|putObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|b
operator|!=
name|t
condition|)
do|;
block|}
return|return
name|a
return|;
block|}
comment|/**          * Takes next task, if one exists, in LIFO order.  Call only          * by owner in unshared queues.          */
DECL|method|pop
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pop
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|s
init|;
operator|(
name|s
operator|=
name|top
operator|-
literal|1
operator|)
operator|-
name|base
operator|>=
literal|0
condition|;
control|)
block|{
name|long
name|j
init|=
operator|(
operator|(
name|m
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|)
operator|==
literal|null
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|top
operator|=
name|s
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Takes a task in FIFO order if b is base of queue and a task          * can be claimed without contention. Specialized versions          * appear in ForkJoinPool methods scan and tryHelpStealer.          */
DECL|method|pollAt
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollAt
parameter_list|(
name|int
name|b
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Takes next task, if one exists, in FIFO order.          */
DECL|method|poll
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|poll
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|base
operator|)
operator|-
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|base
operator|==
name|b
condition|)
block|{
if|if
condition|(
name|b
operator|+
literal|1
operator|==
name|top
condition|)
break|break;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// wait for lagging update (very rare)
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**          * Takes next task, if one exists, in order specified by mode.          */
DECL|method|nextLocalTask
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|nextLocalTask
parameter_list|()
block|{
return|return
name|mode
operator|==
literal|0
condition|?
name|pop
argument_list|()
else|:
name|poll
argument_list|()
return|;
block|}
comment|/**          * Returns next task, if one exists, in order specified by mode.          */
DECL|method|peek
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|peek
parameter_list|()
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
init|=
name|array
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
return|return
literal|null
return|;
name|int
name|i
init|=
name|mode
operator|==
literal|0
condition|?
name|top
operator|-
literal|1
else|:
name|base
decl_stmt|;
name|int
name|j
init|=
operator|(
operator|(
name|i
operator|&
name|m
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
return|return
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
return|;
block|}
comment|/**          * Pops the given task only if it is at the current top.          * (A shared version is available only via FJP.tryExternalUnpush)          */
DECL|method|tryUnpush
specifier|final
name|boolean
name|tryUnpush
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|top
operator|)
operator|!=
name|base
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
operator|--
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|top
operator|=
name|s
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Removes and cancels all known tasks, ignoring any exceptions.          */
DECL|method|cancelAll
specifier|final
name|void
name|cancelAll
parameter_list|()
block|{
name|ForkJoinTask
operator|.
name|cancelIgnoringExceptions
argument_list|(
name|currentJoin
argument_list|)
expr_stmt|;
name|ForkJoinTask
operator|.
name|cancelIgnoringExceptions
argument_list|(
name|currentSteal
argument_list|)
expr_stmt|;
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
operator|(
name|t
operator|=
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|ForkJoinTask
operator|.
name|cancelIgnoringExceptions
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/**          * Computes next value for random probes.  Scans don't require          * a very high quality generator, but also not a crummy one.          * Marsaglia xor-shift is cheap and works well enough.  Note:          * This is manually inlined in its usages in ForkJoinPool to          * avoid writes inside busy scan loops.          */
DECL|method|nextSeed
specifier|final
name|int
name|nextSeed
parameter_list|()
block|{
name|int
name|r
init|=
name|seed
decl_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
return|return
name|seed
operator|=
name|r
operator|^=
name|r
operator|<<
literal|5
return|;
block|}
comment|// Specialized execution methods
comment|/**          * Pops and runs tasks until empty.          */
DECL|method|popAndExecAll
specifier|private
name|void
name|popAndExecAll
parameter_list|()
block|{
comment|// A bit faster than repeated pop calls
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|;
name|long
name|j
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|=
name|top
operator|-
literal|1
operator|)
operator|-
name|base
operator|>=
literal|0
operator|&&
operator|(
name|t
operator|=
operator|(
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
operator|=
operator|(
operator|(
name|m
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
argument_list|)
operator|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|top
operator|=
name|s
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Polls and runs tasks until empty.          */
DECL|method|pollAndExecAll
specifier|private
name|void
name|pollAndExecAll
parameter_list|()
block|{
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
operator|(
name|t
operator|=
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|;
control|)
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
block|}
comment|/**          * If present, removes from queue and executes the given task,          * or any other cancelled task. Returns (true) on any CAS          * or consistency check failure so caller can retry.          *          * @return false if no progress can be made, else true          */
DECL|method|tryRemoveAndExec
specifier|final
name|boolean
name|tryRemoveAndExec
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|boolean
name|stat
init|=
literal|true
decl_stmt|,
name|removed
init|=
literal|false
decl_stmt|,
name|empty
init|=
literal|true
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|,
name|b
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|n
operator|=
operator|(
name|s
operator|=
name|top
operator|)
operator|-
operator|(
name|b
operator|=
name|base
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
condition|;
control|)
block|{
comment|// traverse from s to b
name|int
name|j
init|=
operator|(
operator|(
operator|--
name|s
operator|&
name|m
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|t
operator|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|null
condition|)
comment|// inconsistent length
break|break;
elseif|else
if|if
condition|(
name|t
operator|==
name|task
condition|)
block|{
if|if
condition|(
name|s
operator|+
literal|1
operator|==
name|top
condition|)
block|{
comment|// pop
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|,
literal|null
argument_list|)
condition|)
break|break;
name|top
operator|=
name|s
expr_stmt|;
name|removed
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|==
name|b
condition|)
comment|// replace with proxy
name|removed
operator|=
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|,
operator|new
name|EmptyTask
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|status
operator|>=
literal|0
condition|)
name|empty
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|+
literal|1
operator|==
name|top
condition|)
block|{
comment|// pop and throw away
if|if
condition|(
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
name|top
operator|=
name|s
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|empty
operator|&&
name|base
operator|==
name|b
condition|)
name|stat
operator|=
literal|false
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|removed
condition|)
name|task
operator|.
name|doExec
argument_list|()
expr_stmt|;
return|return
name|stat
return|;
block|}
comment|/**          * Polls for and executes the given task or any other task in          * its CountedCompleter computation.          */
DECL|method|pollAndExecCC
specifier|final
name|boolean
name|pollAndExecCC
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|root
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
name|Object
name|o
decl_stmt|;
name|outer
label|:
while|while
condition|(
operator|(
name|b
operator|=
name|base
operator|)
operator|-
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|)
operator|==
literal|null
operator|||
operator|!
operator|(
name|o
operator|instanceof
name|CountedCompleter
operator|)
condition|)
break|break;
for|for
control|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|t
init|=
operator|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
operator|)
name|o
init|,
name|r
init|=
name|t
init|;
condition|;
control|)
block|{
if|if
condition|(
name|r
operator|==
name|root
condition|)
block|{
if|if
condition|(
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
break|break;
comment|// restart
block|}
if|if
condition|(
operator|(
name|r
operator|=
name|r
operator|.
name|completer
operator|)
operator|==
literal|null
condition|)
break|break
name|outer
break|;
comment|// not part of root computation
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**          * Executes a top-level task and any local tasks remaining          * after execution.          */
DECL|method|runTask
specifier|final
name|void
name|runTask
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
operator|(
name|currentSteal
operator|=
name|t
operator|)
operator|.
name|doExec
argument_list|()
expr_stmt|;
name|currentSteal
operator|=
literal|null
expr_stmt|;
operator|++
name|nsteals
expr_stmt|;
if|if
condition|(
name|base
operator|-
name|top
operator|<
literal|0
condition|)
block|{
comment|// process remaining local tasks
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|popAndExecAll
argument_list|()
expr_stmt|;
else|else
name|pollAndExecAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/**          * Executes a non-top-level (stolen) task.          */
DECL|method|runSubtask
specifier|final
name|void
name|runSubtask
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
literal|null
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|ps
init|=
name|currentSteal
decl_stmt|;
operator|(
name|currentSteal
operator|=
name|t
operator|)
operator|.
name|doExec
argument_list|()
expr_stmt|;
name|currentSteal
operator|=
name|ps
expr_stmt|;
block|}
block|}
comment|/**          * Returns true if owned and not known to be blocked.          */
DECL|method|isApparentlyUnblocked
specifier|final
name|boolean
name|isApparentlyUnblocked
parameter_list|()
block|{
name|Thread
name|wt
decl_stmt|;
name|Thread
operator|.
name|State
name|s
decl_stmt|;
return|return
operator|(
name|eventCount
operator|>=
literal|0
operator|&&
operator|(
name|wt
operator|=
name|owner
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|wt
operator|.
name|getState
argument_list|()
operator|)
operator|!=
name|Thread
operator|.
name|State
operator|.
name|BLOCKED
operator|&&
name|s
operator|!=
name|Thread
operator|.
name|State
operator|.
name|WAITING
operator|&&
name|s
operator|!=
name|Thread
operator|.
name|State
operator|.
name|TIMED_WAITING
operator|)
return|;
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|QLOCK
specifier|private
specifier|static
specifier|final
name|long
name|QLOCK
decl_stmt|;
DECL|field|ABASE
specifier|private
specifier|static
specifier|final
name|int
name|ABASE
decl_stmt|;
DECL|field|ASHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ASHIFT
decl_stmt|;
static|static
block|{
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|WorkQueue
operator|.
name|class
decl_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|ak
init|=
name|ForkJoinTask
index|[]
operator|.
name|class
decl_stmt|;
name|QLOCK
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"qlock"
argument_list|)
argument_list|)
expr_stmt|;
name|ABASE
operator|=
name|U
operator|.
name|arrayBaseOffset
argument_list|(
name|ak
argument_list|)
expr_stmt|;
name|int
name|scale
init|=
name|U
operator|.
name|arrayIndexScale
argument_list|(
name|ak
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|scale
operator|&
operator|(
name|scale
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|ASHIFT
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
block|}
comment|// static fields (initialized in static initializer below)
comment|/**      * Creates a new ForkJoinWorkerThread. This factory is used unless      * overridden in ForkJoinPool constructors.      */
specifier|public
specifier|static
specifier|final
name|ForkJoinWorkerThreadFactory
DECL|field|defaultForkJoinWorkerThreadFactory
name|defaultForkJoinWorkerThreadFactory
decl_stmt|;
comment|/**      * Per-thread submission bookkeeping. Shared across all pools      * to reduce ThreadLocal pollution and because random motion      * to avoid contention in one pool is likely to hold for others.      * Lazily initialized on first submission (but null-checked      * in other contexts to avoid unnecessary initialization).      */
DECL|field|submitters
specifier|static
specifier|final
name|ThreadLocal
argument_list|<
name|Submitter
argument_list|>
name|submitters
decl_stmt|;
comment|/**      * Permission required for callers of methods that may start or      * kill threads.      */
DECL|field|modifyThreadPermission
specifier|private
specifier|static
specifier|final
name|RuntimePermission
name|modifyThreadPermission
decl_stmt|;
comment|/**      * Common (static) pool. Non-null for public use unless a static      * construction exception, but internal usages null-check on use      * to paranoically avoid potential initialization circularities      * as well as to simplify generated code.      */
DECL|field|common
specifier|static
specifier|final
name|ForkJoinPool
name|common
decl_stmt|;
comment|/**      * Common pool parallelism. Must equal common.parallelism.      */
DECL|field|commonParallelism
specifier|static
specifier|final
name|int
name|commonParallelism
decl_stmt|;
comment|/**      * Sequence number for creating workerNamePrefix.      */
DECL|field|poolNumberSequence
specifier|private
specifier|static
name|int
name|poolNumberSequence
decl_stmt|;
comment|/**      * Returns the next sequence number. We don't expect this to      * ever contend, so use simple builtin sync.      */
DECL|method|nextPoolId
specifier|private
specifier|static
specifier|final
specifier|synchronized
name|int
name|nextPoolId
parameter_list|()
block|{
return|return
operator|++
name|poolNumberSequence
return|;
block|}
comment|// static constants
comment|/**      * Initial timeout value (in nanoseconds) for the thread      * triggering quiescence to park waiting for new work. On timeout,      * the thread will instead try to shrink the number of      * workers. The value should be large enough to avoid overly      * aggressive shrinkage during most transient stalls (long GCs      * etc).      */
DECL|field|IDLE_TIMEOUT
specifier|private
specifier|static
specifier|final
name|long
name|IDLE_TIMEOUT
init|=
literal|2000L
operator|*
literal|1000L
operator|*
literal|1000L
decl_stmt|;
comment|// 2sec
comment|/**      * Timeout value when there are more threads than parallelism level      */
DECL|field|FAST_IDLE_TIMEOUT
specifier|private
specifier|static
specifier|final
name|long
name|FAST_IDLE_TIMEOUT
init|=
literal|200L
operator|*
literal|1000L
operator|*
literal|1000L
decl_stmt|;
comment|/**      * Tolerance for idle timeouts, to cope with timer undershoots      */
DECL|field|TIMEOUT_SLOP
specifier|private
specifier|static
specifier|final
name|long
name|TIMEOUT_SLOP
init|=
literal|2000000L
decl_stmt|;
comment|/**      * The maximum stolen->joining link depth allowed in method      * tryHelpStealer.  Must be a power of two.  Depths for legitimate      * chains are unbounded, but we use a fixed constant to avoid      * (otherwise unchecked) cycles and to bound staleness of      * traversal parameters at the expense of sometimes blocking when      * we could be helping.      */
DECL|field|MAX_HELP
specifier|private
specifier|static
specifier|final
name|int
name|MAX_HELP
init|=
literal|64
decl_stmt|;
comment|/**      * Increment for seed generators. See class ThreadLocal for      * explanation.      */
DECL|field|SEED_INCREMENT
specifier|private
specifier|static
specifier|final
name|int
name|SEED_INCREMENT
init|=
literal|0x61c88647
decl_stmt|;
comment|/*      * Bits and masks for control variables      *      * Field ctl is a long packed with:      * AC: Number of active running workers minus target parallelism (16 bits)      * TC: Number of total workers minus target parallelism (16 bits)      * ST: true if pool is terminating (1 bit)      * EC: the wait count of top waiting thread (15 bits)      * ID: poolIndex of top of Treiber stack of waiters (16 bits)      *      * When convenient, we can extract the upper 32 bits of counts and      * the lower 32 bits of queue state, u = (int)(ctl>>> 32) and e =      * (int)ctl.  The ec field is never accessed alone, but always      * together with id and st. The offsets of counts by the target      * parallelism and the positionings of fields makes it possible to      * perform the most common checks via sign tests of fields: When      * ac is negative, there are not enough active workers, when tc is      * negative, there are not enough total workers, and when e is      * negative, the pool is terminating.  To deal with these possibly      * negative fields, we use casts in and out of "short" and/or      * signed shifts to maintain signedness.      *      * When a thread is queued (inactivated), its eventCount field is      * set negative, which is the only way to tell if a worker is      * prevented from executing tasks, even though it must continue to      * scan for them to avoid queuing races. Note however that      * eventCount updates lag releases so usage requires care.      *      * Field plock is an int packed with:      * SHUTDOWN: true if shutdown is enabled (1 bit)      * SEQ:  a sequence lock, with PL_LOCK bit set if locked (30 bits)      * SIGNAL: set when threads may be waiting on the lock (1 bit)      *      * The sequence number enables simple consistency checks:      * Staleness of read-only operations on the workQueues array can      * be checked by comparing plock before vs after the reads.      */
comment|// bit positions/shifts for fields
DECL|field|AC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|AC_SHIFT
init|=
literal|48
decl_stmt|;
DECL|field|TC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|TC_SHIFT
init|=
literal|32
decl_stmt|;
DECL|field|ST_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ST_SHIFT
init|=
literal|31
decl_stmt|;
DECL|field|EC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|EC_SHIFT
init|=
literal|16
decl_stmt|;
comment|// bounds
DECL|field|SMASK
specifier|private
specifier|static
specifier|final
name|int
name|SMASK
init|=
literal|0xffff
decl_stmt|;
comment|// short bits
DECL|field|MAX_CAP
specifier|private
specifier|static
specifier|final
name|int
name|MAX_CAP
init|=
literal|0x7fff
decl_stmt|;
comment|// max #workers - 1
DECL|field|EVENMASK
specifier|private
specifier|static
specifier|final
name|int
name|EVENMASK
init|=
literal|0xfffe
decl_stmt|;
comment|// even short bits
DECL|field|SQMASK
specifier|private
specifier|static
specifier|final
name|int
name|SQMASK
init|=
literal|0x007e
decl_stmt|;
comment|// max 64 (even) slots
DECL|field|SHORT_SIGN
specifier|private
specifier|static
specifier|final
name|int
name|SHORT_SIGN
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
DECL|field|INT_SIGN
specifier|private
specifier|static
specifier|final
name|int
name|INT_SIGN
init|=
literal|1
operator|<<
literal|31
decl_stmt|;
comment|// masks
DECL|field|STOP_BIT
specifier|private
specifier|static
specifier|final
name|long
name|STOP_BIT
init|=
literal|0x0001L
operator|<<
name|ST_SHIFT
decl_stmt|;
DECL|field|AC_MASK
specifier|private
specifier|static
specifier|final
name|long
name|AC_MASK
init|=
operator|(
operator|(
name|long
operator|)
name|SMASK
operator|)
operator|<<
name|AC_SHIFT
decl_stmt|;
DECL|field|TC_MASK
specifier|private
specifier|static
specifier|final
name|long
name|TC_MASK
init|=
operator|(
operator|(
name|long
operator|)
name|SMASK
operator|)
operator|<<
name|TC_SHIFT
decl_stmt|;
comment|// units for incrementing and decrementing
DECL|field|TC_UNIT
specifier|private
specifier|static
specifier|final
name|long
name|TC_UNIT
init|=
literal|1L
operator|<<
name|TC_SHIFT
decl_stmt|;
DECL|field|AC_UNIT
specifier|private
specifier|static
specifier|final
name|long
name|AC_UNIT
init|=
literal|1L
operator|<<
name|AC_SHIFT
decl_stmt|;
comment|// masks and units for dealing with u = (int)(ctl>>> 32)
DECL|field|UAC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|UAC_SHIFT
init|=
name|AC_SHIFT
operator|-
literal|32
decl_stmt|;
DECL|field|UTC_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|UTC_SHIFT
init|=
name|TC_SHIFT
operator|-
literal|32
decl_stmt|;
DECL|field|UAC_MASK
specifier|private
specifier|static
specifier|final
name|int
name|UAC_MASK
init|=
name|SMASK
operator|<<
name|UAC_SHIFT
decl_stmt|;
DECL|field|UTC_MASK
specifier|private
specifier|static
specifier|final
name|int
name|UTC_MASK
init|=
name|SMASK
operator|<<
name|UTC_SHIFT
decl_stmt|;
DECL|field|UAC_UNIT
specifier|private
specifier|static
specifier|final
name|int
name|UAC_UNIT
init|=
literal|1
operator|<<
name|UAC_SHIFT
decl_stmt|;
DECL|field|UTC_UNIT
specifier|private
specifier|static
specifier|final
name|int
name|UTC_UNIT
init|=
literal|1
operator|<<
name|UTC_SHIFT
decl_stmt|;
comment|// masks and units for dealing with e = (int)ctl
DECL|field|E_MASK
specifier|private
specifier|static
specifier|final
name|int
name|E_MASK
init|=
literal|0x7fffffff
decl_stmt|;
comment|// no STOP_BIT
DECL|field|E_SEQ
specifier|private
specifier|static
specifier|final
name|int
name|E_SEQ
init|=
literal|1
operator|<<
name|EC_SHIFT
decl_stmt|;
comment|// plock bits
DECL|field|SHUTDOWN
specifier|private
specifier|static
specifier|final
name|int
name|SHUTDOWN
init|=
literal|1
operator|<<
literal|31
decl_stmt|;
DECL|field|PL_LOCK
specifier|private
specifier|static
specifier|final
name|int
name|PL_LOCK
init|=
literal|2
decl_stmt|;
DECL|field|PL_SIGNAL
specifier|private
specifier|static
specifier|final
name|int
name|PL_SIGNAL
init|=
literal|1
decl_stmt|;
DECL|field|PL_SPINS
specifier|private
specifier|static
specifier|final
name|int
name|PL_SPINS
init|=
literal|1
operator|<<
literal|8
decl_stmt|;
comment|// access mode for WorkQueue
DECL|field|LIFO_QUEUE
specifier|static
specifier|final
name|int
name|LIFO_QUEUE
init|=
literal|0
decl_stmt|;
DECL|field|FIFO_QUEUE
specifier|static
specifier|final
name|int
name|FIFO_QUEUE
init|=
literal|1
decl_stmt|;
DECL|field|SHARED_QUEUE
specifier|static
specifier|final
name|int
name|SHARED_QUEUE
init|=
operator|-
literal|1
decl_stmt|;
comment|// bounds for #steps in scan loop -- must be power 2 minus 1
DECL|field|MIN_SCAN
specifier|private
specifier|static
specifier|final
name|int
name|MIN_SCAN
init|=
literal|0x1ff
decl_stmt|;
comment|// cover estimation slop
DECL|field|MAX_SCAN
specifier|private
specifier|static
specifier|final
name|int
name|MAX_SCAN
init|=
literal|0x1ffff
decl_stmt|;
comment|// 4 * max workers
comment|// Instance fields
comment|/*      * Field layout of this class tends to matter more than one would      * like. Runtime layout order is only loosely related to      * declaration order and may differ across JVMs, but the following      * empirically works OK on current JVMs.      */
comment|// Heuristic padding to ameliorate unfortunate memory placements
DECL|field|pad00
DECL|field|pad01
DECL|field|pad02
DECL|field|pad03
DECL|field|pad04
DECL|field|pad05
DECL|field|pad06
specifier|volatile
name|long
name|pad00
decl_stmt|,
name|pad01
decl_stmt|,
name|pad02
decl_stmt|,
name|pad03
decl_stmt|,
name|pad04
decl_stmt|,
name|pad05
decl_stmt|,
name|pad06
decl_stmt|;
DECL|field|stealCount
specifier|volatile
name|long
name|stealCount
decl_stmt|;
comment|// collects worker counts
DECL|field|ctl
specifier|volatile
name|long
name|ctl
decl_stmt|;
comment|// main pool control
DECL|field|plock
specifier|volatile
name|int
name|plock
decl_stmt|;
comment|// shutdown status and seqLock
DECL|field|indexSeed
specifier|volatile
name|int
name|indexSeed
decl_stmt|;
comment|// worker/submitter index seed
DECL|field|config
specifier|final
name|int
name|config
decl_stmt|;
comment|// mode and parallelism level
DECL|field|workQueues
name|WorkQueue
index|[]
name|workQueues
decl_stmt|;
comment|// main registry
DECL|field|factory
specifier|final
name|ForkJoinWorkerThreadFactory
name|factory
decl_stmt|;
DECL|field|ueh
specifier|final
name|Thread
operator|.
name|UncaughtExceptionHandler
name|ueh
decl_stmt|;
comment|// per-worker UEH
DECL|field|workerNamePrefix
specifier|final
name|String
name|workerNamePrefix
decl_stmt|;
comment|// to create worker name string
DECL|field|pad10
DECL|field|pad11
DECL|field|pad12
DECL|field|pad13
DECL|field|pad14
DECL|field|pad15
DECL|field|pad16
DECL|field|pad17
specifier|volatile
name|Object
name|pad10
decl_stmt|,
name|pad11
decl_stmt|,
name|pad12
decl_stmt|,
name|pad13
decl_stmt|,
name|pad14
decl_stmt|,
name|pad15
decl_stmt|,
name|pad16
decl_stmt|,
name|pad17
decl_stmt|;
DECL|field|pad18
DECL|field|pad19
DECL|field|pad1a
DECL|field|pad1b
specifier|volatile
name|Object
name|pad18
decl_stmt|,
name|pad19
decl_stmt|,
name|pad1a
decl_stmt|,
name|pad1b
decl_stmt|;
comment|/**      * Acquires the plock lock to protect worker array and related      * updates. This method is called only if an initial CAS on plock      * fails. This acts as a spinlock for normal cases, but falls back      * to builtin monitor to block when (rarely) needed. This would be      * a terrible idea for a highly contended lock, but works fine as      * a more conservative alternative to a pure spinlock.      */
DECL|method|acquirePlock
specifier|private
name|int
name|acquirePlock
parameter_list|()
block|{
name|int
name|spins
init|=
name|PL_SPINS
decl_stmt|,
name|r
init|=
literal|0
decl_stmt|,
name|ps
decl_stmt|,
name|nps
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|&
name|PL_LOCK
operator|)
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|nps
operator|=
name|ps
operator|+
name|PL_LOCK
argument_list|)
condition|)
return|return
name|nps
return|;
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|// randomize spins if possible
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|Submitter
name|z
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
operator|)
operator|&&
operator|(
name|w
operator|=
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|workQueue
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|w
operator|.
name|seed
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|z
operator|=
name|submitters
operator|.
name|get
argument_list|()
operator|)
operator|!=
literal|null
condition|)
name|r
operator|=
name|z
operator|.
name|seed
expr_stmt|;
else|else
name|r
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spins
operator|>=
literal|0
condition|)
block|{
name|r
operator|^=
name|r
operator|<<
literal|1
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|3
expr_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|10
expr_stmt|;
comment|// xorshift
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
operator|--
name|spins
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|ps
operator||
name|PL_SIGNAL
argument_list|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
if|if
condition|(
operator|(
name|plock
operator|&
name|PL_SIGNAL
operator|)
operator|!=
literal|0
condition|)
block|{
try|try
block|{
name|wait
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
try|try
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|ignore
parameter_list|)
block|{                             }
block|}
block|}
else|else
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Unlocks and signals any thread waiting for plock. Called only      * when CAS of seq value for unlock fails.      */
DECL|method|releasePlock
specifier|private
name|void
name|releasePlock
parameter_list|(
name|int
name|ps
parameter_list|)
block|{
name|plock
operator|=
name|ps
expr_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
comment|/**      * Tries to create and start one worker if fewer than target      * parallelism level exist. Adjusts counts etc on failure.      */
DECL|method|tryAddWorker
specifier|private
name|void
name|tryAddWorker
parameter_list|()
block|{
name|long
name|c
decl_stmt|;
name|int
name|u
decl_stmt|;
while|while
condition|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|>>>
literal|32
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|u
operator|&
name|SHORT_SIGN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|int
operator|)
name|c
operator|==
literal|0
condition|)
block|{
name|long
name|nc
init|=
call|(
name|long
call|)
argument_list|(
operator|(
operator|(
name|u
operator|+
name|UTC_UNIT
operator|)
operator|&
name|UTC_MASK
operator|)
operator||
operator|(
operator|(
name|u
operator|+
name|UAC_UNIT
operator|)
operator|&
name|UAC_MASK
operator|)
argument_list|)
operator|<<
literal|32
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|ForkJoinWorkerThreadFactory
name|fac
decl_stmt|;
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|fac
operator|=
name|factory
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|wt
operator|=
name|fac
operator|.
name|newThread
argument_list|(
name|this
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|wt
operator|.
name|start
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|ex
operator|=
name|e
expr_stmt|;
block|}
name|deregisterWorker
argument_list|(
name|wt
argument_list|,
name|ex
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|//  Registering and deregistering workers
comment|/**      * Callback from ForkJoinWorkerThread to establish and record its      * WorkQueue. To avoid scanning bias due to packing entries in      * front of the workQueues array, we treat the array as a simple      * power-of-two hash table using per-thread seed as hash,      * expanding as needed.      *      * @param wt the worker thread      * @return the worker's queue      */
DECL|method|registerWorker
specifier|final
name|WorkQueue
name|registerWorker
parameter_list|(
name|ForkJoinWorkerThread
name|wt
parameter_list|)
block|{
name|Thread
operator|.
name|UncaughtExceptionHandler
name|handler
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|int
name|s
decl_stmt|,
name|ps
decl_stmt|;
name|wt
operator|.
name|setDaemon
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|handler
operator|=
name|ueh
operator|)
operator|!=
literal|null
condition|)
name|wt
operator|.
name|setUncaughtExceptionHandler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|INDEXSEED
argument_list|,
name|s
operator|=
name|indexSeed
argument_list|,
name|s
operator|+=
name|SEED_INCREMENT
argument_list|)
operator|||
name|s
operator|==
literal|0
condition|)
do|;
comment|// skip 0
name|WorkQueue
name|w
init|=
operator|new
name|WorkQueue
argument_list|(
name|this
argument_list|,
name|wt
argument_list|,
name|config
operator|>>>
literal|16
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|&
name|PL_LOCK
operator|)
operator|!=
literal|0
operator|||
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|ps
operator|+=
name|PL_LOCK
argument_list|)
condition|)
name|ps
operator|=
name|acquirePlock
argument_list|()
expr_stmt|;
name|int
name|nps
init|=
operator|(
name|ps
operator|&
name|SHUTDOWN
operator|)
operator||
operator|(
operator|(
name|ps
operator|+
name|PL_LOCK
operator|)
operator|&
operator|~
name|SHUTDOWN
operator|)
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// skip if shutting down
name|int
name|n
init|=
name|ws
operator|.
name|length
decl_stmt|,
name|m
init|=
name|n
operator|-
literal|1
decl_stmt|;
name|int
name|r
init|=
operator|(
name|s
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
comment|// use odd-numbered indices
if|if
condition|(
name|ws
index|[
name|r
operator|&=
name|m
index|]
operator|!=
literal|null
condition|)
block|{
comment|// collision
name|int
name|probes
init|=
literal|0
decl_stmt|;
comment|// step by approx half size
name|int
name|step
init|=
operator|(
name|n
operator|<=
literal|4
operator|)
condition|?
literal|2
else|:
operator|(
operator|(
name|n
operator|>>>
literal|1
operator|)
operator|&
name|EVENMASK
operator|)
operator|+
literal|2
decl_stmt|;
while|while
condition|(
name|ws
index|[
name|r
operator|=
operator|(
name|r
operator|+
name|step
operator|)
operator|&
name|m
index|]
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|++
name|probes
operator|>=
name|n
condition|)
block|{
name|workQueues
operator|=
name|ws
operator|=
name|Arrays
operator|.
name|copyOf
argument_list|(
name|ws
argument_list|,
name|n
operator|<<=
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
operator|-
literal|1
expr_stmt|;
name|probes
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|w
operator|.
name|eventCount
operator|=
name|w
operator|.
name|poolIndex
operator|=
name|r
expr_stmt|;
comment|// volatile write orders
name|ws
index|[
name|r
index|]
operator|=
name|w
expr_stmt|;
block|}
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|nps
argument_list|)
condition|)
name|releasePlock
argument_list|(
name|nps
argument_list|)
expr_stmt|;
block|}
name|wt
operator|.
name|setName
argument_list|(
name|workerNamePrefix
operator|.
name|concat
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|w
operator|.
name|poolIndex
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|w
return|;
block|}
comment|/**      * Final callback from terminating worker, as well as upon failure      * to construct or start a worker.  Removes record of worker from      * array, and adjusts counts. If pool is shutting down, tries to      * complete termination.      *      * @param wt the worker thread or null if construction failed      * @param ex the exception causing failure, or null if none      */
DECL|method|deregisterWorker
specifier|final
name|void
name|deregisterWorker
parameter_list|(
name|ForkJoinWorkerThread
name|wt
parameter_list|,
name|Throwable
name|ex
parameter_list|)
block|{
name|WorkQueue
name|w
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|wt
operator|!=
literal|null
operator|&&
operator|(
name|w
operator|=
name|wt
operator|.
name|workQueue
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|ps
decl_stmt|;
name|w
operator|.
name|qlock
operator|=
operator|-
literal|1
expr_stmt|;
comment|// ensure set
name|long
name|ns
init|=
name|w
operator|.
name|nsteals
decl_stmt|,
name|sc
decl_stmt|;
comment|// collect steal count
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STEALCOUNT
argument_list|,
name|sc
operator|=
name|stealCount
argument_list|,
name|sc
operator|+
name|ns
argument_list|)
condition|)
do|;
if|if
condition|(
operator|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|&
name|PL_LOCK
operator|)
operator|!=
literal|0
operator|||
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|ps
operator|+=
name|PL_LOCK
argument_list|)
condition|)
name|ps
operator|=
name|acquirePlock
argument_list|()
expr_stmt|;
name|int
name|nps
init|=
operator|(
name|ps
operator|&
name|SHUTDOWN
operator|)
operator||
operator|(
operator|(
name|ps
operator|+
name|PL_LOCK
operator|)
operator|&
operator|~
name|SHUTDOWN
operator|)
decl_stmt|;
try|try
block|{
name|int
name|idx
init|=
name|w
operator|.
name|poolIndex
decl_stmt|;
name|WorkQueue
index|[]
name|ws
init|=
name|workQueues
decl_stmt|;
if|if
condition|(
name|ws
operator|!=
literal|null
operator|&&
name|idx
operator|>=
literal|0
operator|&&
name|idx
operator|<
name|ws
operator|.
name|length
operator|&&
name|ws
index|[
name|idx
index|]
operator|==
name|w
condition|)
name|ws
index|[
name|idx
index|]
operator|=
literal|null
expr_stmt|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|nps
argument_list|)
condition|)
name|releasePlock
argument_list|(
name|nps
argument_list|)
expr_stmt|;
block|}
block|}
name|long
name|c
decl_stmt|;
comment|// adjust ctl counts
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
operator|(
operator|(
operator|(
name|c
operator|-
name|AC_UNIT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
operator|(
name|c
operator|-
name|TC_UNIT
operator|)
operator|&
name|TC_MASK
operator|)
operator||
operator|(
name|c
operator|&
operator|~
operator|(
name|AC_MASK
operator||
name|TC_MASK
operator|)
operator|)
operator|)
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
name|tryTerminate
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
operator|&&
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|array
operator|!=
literal|null
condition|)
block|{
name|w
operator|.
name|cancelAll
argument_list|()
expr_stmt|;
comment|// cancel remaining tasks
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|v
decl_stmt|;
name|Thread
name|p
decl_stmt|;
name|int
name|u
decl_stmt|,
name|i
decl_stmt|,
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|>>>
literal|32
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|e
operator|=
operator|(
name|int
operator|)
name|c
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
comment|// activate or create replacement
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|>=
name|ws
operator|.
name|length
operator|||
operator|(
name|v
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|==
literal|null
condition|)
break|break;
name|long
name|nc
init|=
operator|(
operator|(
call|(
name|long
call|)
argument_list|(
name|v
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|u
operator|+
name|UAC_UNIT
argument_list|)
operator|<<
literal|32
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|eventCount
operator|!=
operator|(
name|e
operator||
name|INT_SIGN
operator|)
condition|)
break|break;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|v
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|v
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|short
operator|)
name|u
operator|<
literal|0
condition|)
name|tryAddWorker
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ex
operator|==
literal|null
condition|)
comment|// help clean refs on way out
name|ForkJoinTask
operator|.
name|helpExpungeStaleExceptions
argument_list|()
expr_stmt|;
else|else
comment|// rethrow
name|ForkJoinTask
operator|.
name|rethrow
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
comment|// Submissions
comment|/**      * Unless shutting down, adds the given task to a submission queue      * at submitter's current queue index (modulo submission      * range). Only the most common path is directly handled in this      * method. All others are relayed to fullExternalPush.      *      * @param task the task. Caller must ensure non-null.      */
DECL|method|externalPush
specifier|final
name|void
name|externalPush
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|Submitter
name|z
decl_stmt|;
name|int
name|m
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|submitters
operator|.
name|get
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|plock
operator|>
literal|0
operator|&&
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
operator|(
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|q
operator|=
name|ws
index|[
name|m
operator|&
name|z
operator|.
name|seed
operator|&
name|SQMASK
index|]
operator|)
operator|!=
literal|null
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|q
argument_list|,
name|QLOCK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|// lock
name|int
name|b
init|=
name|q
operator|.
name|base
decl_stmt|,
name|s
init|=
name|q
operator|.
name|top
decl_stmt|,
name|n
decl_stmt|,
name|an
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|q
operator|.
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|an
operator|=
name|a
operator|.
name|length
operator|)
operator|>
operator|(
name|n
operator|=
name|s
operator|+
literal|1
operator|-
name|b
operator|)
condition|)
block|{
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|an
operator|-
literal|1
operator|)
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|U
operator|.
name|putOrderedObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|q
operator|.
name|top
operator|=
name|s
operator|+
literal|1
expr_stmt|;
comment|// push on to deque
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|2
condition|)
name|signalWork
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return;
block|}
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
block|}
name|fullExternalPush
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|/**      * Full version of externalPush. This method is called, among      * other times, upon the first submission of the first task to the      * pool, so must perform secondary initialization.  It also      * detects first submission by an external thread by looking up      * its ThreadLocal, and creates a new shared queue if the one at      * index if empty or contended. The plock lock body must be      * exception-free (so no try/finally) so we optimistically      * allocate new queues outside the lock and throw them away if      * (very rarely) not needed.      *      * Secondary initialization occurs when plock is zero, to create      * workQueue array and set plock to a valid value.  This lock body      * must also be exception-free. Because the plock seq value can      * eventually wrap around zero, this method harmlessly fails to      * reinitialize if workQueues exists, while still advancing plock.      */
DECL|method|fullExternalPush
specifier|private
name|void
name|fullExternalPush
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
comment|// random index seed
for|for
control|(
name|Submitter
name|z
init|=
name|submitters
operator|.
name|get
argument_list|()
init|;
condition|;
control|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|int
name|ps
decl_stmt|,
name|m
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|z
operator|==
literal|null
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|INDEXSEED
argument_list|,
name|r
operator|=
name|indexSeed
argument_list|,
name|r
operator|+=
name|SEED_INCREMENT
argument_list|)
operator|&&
name|r
operator|!=
literal|0
condition|)
name|submitters
operator|.
name|set
argument_list|(
name|z
operator|=
operator|new
name|Submitter
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
comment|// move to a different index
name|r
operator|=
name|z
operator|.
name|seed
expr_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
comment|// same xorshift as WorkQueues
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
name|z
operator|.
name|seed
operator|=
name|r
operator|^
operator|(
name|r
operator|<<
literal|5
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|<
literal|0
condition|)
throw|throw
operator|new
name|RejectedExecutionException
argument_list|()
throw|;
elseif|else
if|if
condition|(
name|ps
operator|==
literal|0
operator|||
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|<
literal|0
condition|)
block|{
comment|// initialize workQueues
name|int
name|p
init|=
name|config
operator|&
name|SMASK
decl_stmt|;
comment|// find power of two table size
name|int
name|n
init|=
operator|(
name|p
operator|>
literal|1
operator|)
condition|?
name|p
operator|-
literal|1
else|:
literal|1
decl_stmt|;
comment|// ensure at least 2 slots
name|n
operator||=
name|n
operator|>>>
literal|1
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|2
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|4
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|8
expr_stmt|;
name|n
operator||=
name|n
operator|>>>
literal|16
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
name|WorkQueue
index|[]
name|nws
init|=
operator|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
name|ws
operator|.
name|length
operator|==
literal|0
condition|?
operator|new
name|WorkQueue
index|[
name|n
index|]
else|:
literal|null
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|&
name|PL_LOCK
operator|)
operator|!=
literal|0
operator|||
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|ps
operator|+=
name|PL_LOCK
argument_list|)
condition|)
name|ps
operator|=
name|acquirePlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
name|ws
operator|.
name|length
operator|==
literal|0
operator|)
operator|&&
name|nws
operator|!=
literal|null
condition|)
name|workQueues
operator|=
name|nws
expr_stmt|;
name|int
name|nps
init|=
operator|(
name|ps
operator|&
name|SHUTDOWN
operator|)
operator||
operator|(
operator|(
name|ps
operator|+
name|PL_LOCK
operator|)
operator|&
operator|~
name|SHUTDOWN
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|nps
argument_list|)
condition|)
name|releasePlock
argument_list|(
name|nps
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
name|k
operator|=
name|r
operator|&
name|m
operator|&
name|SQMASK
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|qlock
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|q
argument_list|,
name|QLOCK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
init|=
name|q
operator|.
name|array
decl_stmt|;
name|int
name|s
init|=
name|q
operator|.
name|top
decl_stmt|;
name|boolean
name|submitted
init|=
literal|false
decl_stmt|;
try|try
block|{
comment|// locked version of push
if|if
condition|(
operator|(
name|a
operator|!=
literal|null
operator|&&
name|a
operator|.
name|length
operator|>
name|s
operator|+
literal|1
operator|-
name|q
operator|.
name|base
operator|)
operator|||
operator|(
name|a
operator|=
name|q
operator|.
name|growArray
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// must presize
name|int
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|s
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|U
operator|.
name|putOrderedObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|q
operator|.
name|top
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|submitted
operator|=
literal|true
expr_stmt|;
block|}
block|}
finally|finally
block|{
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
comment|// unlock
block|}
if|if
condition|(
name|submitted
condition|)
block|{
name|signalWork
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|r
operator|=
literal|0
expr_stmt|;
comment|// move on failure
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|&
name|PL_LOCK
operator|)
operator|==
literal|0
condition|)
block|{
comment|// create new queue
name|q
operator|=
operator|new
name|WorkQueue
argument_list|(
name|this
argument_list|,
literal|null
argument_list|,
name|SHARED_QUEUE
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|&
name|PL_LOCK
operator|)
operator|!=
literal|0
operator|||
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|ps
operator|+=
name|PL_LOCK
argument_list|)
condition|)
name|ps
operator|=
name|acquirePlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
name|k
operator|<
name|ws
operator|.
name|length
operator|&&
name|ws
index|[
name|k
index|]
operator|==
literal|null
condition|)
name|ws
index|[
name|k
index|]
operator|=
name|q
expr_stmt|;
name|int
name|nps
init|=
operator|(
name|ps
operator|&
name|SHUTDOWN
operator|)
operator||
operator|(
operator|(
name|ps
operator|+
name|PL_LOCK
operator|)
operator|&
operator|~
name|SHUTDOWN
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|nps
argument_list|)
condition|)
name|releasePlock
argument_list|(
name|nps
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|=
literal|0
expr_stmt|;
comment|// try elsewhere while lock held
block|}
block|}
comment|// Maintaining ctl counts
comment|/**      * Increments active count; mainly called upon return from blocking.      */
DECL|method|incrementActiveCount
specifier|final
name|void
name|incrementActiveCount
parameter_list|()
block|{
name|long
name|c
decl_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
do|;
block|}
comment|/**      * Tries to create or activate a worker if too few are active.      *      * @param q the (non-null) queue holding tasks to be signalled      */
DECL|method|signalWork
specifier|final
name|void
name|signalWork
parameter_list|(
name|WorkQueue
name|q
parameter_list|)
block|{
name|int
name|hint
init|=
name|q
operator|.
name|poolIndex
decl_stmt|;
name|long
name|c
decl_stmt|;
name|int
name|e
decl_stmt|,
name|u
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|Thread
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|>>>
literal|32
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|int
operator|)
name|c
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
name|ws
operator|.
name|length
operator|>
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|&&
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
name|w
operator|.
name|eventCount
operator|==
operator|(
name|e
operator||
name|INT_SIGN
operator|)
condition|)
block|{
name|long
name|nc
init|=
operator|(
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|u
operator|+
name|UAC_UNIT
argument_list|)
operator|<<
literal|32
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|w
operator|.
name|hint
operator|=
name|hint
expr_stmt|;
name|w
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|w
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|.
name|top
operator|-
name|q
operator|.
name|base
operator|<=
literal|0
condition|)
break|break;
block|}
else|else
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|short
operator|)
name|u
operator|<
literal|0
condition|)
name|tryAddWorker
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|// Scanning for tasks
comment|/**      * Top-level runloop for workers, called by ForkJoinWorkerThread.run.      */
DECL|method|runWorker
specifier|final
name|void
name|runWorker
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
name|w
operator|.
name|growArray
argument_list|()
expr_stmt|;
comment|// allocate queue
do|do
block|{
name|w
operator|.
name|runTask
argument_list|(
name|scan
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|.
name|qlock
operator|>=
literal|0
condition|)
do|;
block|}
comment|/**      * Scans for and, if found, returns one task, else possibly      * inactivates the worker. This method operates on single reads of      * volatile state and is designed to be re-invoked continuously,      * in part because it returns upon detecting inconsistencies,      * contention, or state changes that indicate possible success on      * re-invocation.      *      * The scan searches for tasks across queues (starting at a random      * index, and relying on registerWorker to irregularly scatter      * them within array to avoid bias), checking each at least twice.      * The scan terminates upon either finding a non-empty queue, or      * completing the sweep. If the worker is not inactivated, it      * takes and returns a task from this queue. Otherwise, if not      * activated, it signals workers (that may include itself) and      * returns so caller can retry. Also returns for true if the      * worker array may have changed during an empty scan.  On failure      * to find a task, we take one of the following actions, after      * which the caller will retry calling this method unless      * terminated.      *      * * If pool is terminating, terminate the worker.      *      * * If not already enqueued, try to inactivate and enqueue the      * worker on wait queue. Or, if inactivating has caused the pool      * to be quiescent, relay to idleAwaitWork to possibly shrink      * pool.      *      * * If already enqueued and none of the above apply, possibly      * park awaiting signal, else lingering to help scan and signal.      *      * * If a non-empty queue discovered or left as a hint,      * help wake up other workers before return.      *      * @param w the worker (via its WorkQueue)      * @return a task or null if none found      */
DECL|method|scan
specifier|private
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|scan
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|ps
init|=
name|plock
decl_stmt|;
comment|// read plock before ws
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
name|int
name|ec
init|=
name|w
operator|.
name|eventCount
decl_stmt|;
comment|// ec is negative if inactive
name|int
name|r
init|=
name|w
operator|.
name|seed
decl_stmt|;
name|r
operator|^=
name|r
operator|<<
literal|13
expr_stmt|;
name|r
operator|^=
name|r
operator|>>>
literal|17
expr_stmt|;
name|w
operator|.
name|seed
operator|=
name|r
operator|^=
name|r
operator|<<
literal|5
expr_stmt|;
name|w
operator|.
name|hint
operator|=
operator|-
literal|1
expr_stmt|;
comment|// update seed and clear hint
name|int
name|j
init|=
operator|(
operator|(
name|m
operator|+
name|m
operator|+
literal|1
operator|)
operator||
name|MIN_SCAN
operator|)
operator|&
name|MAX_SCAN
decl_stmt|;
do|do
block|{
name|WorkQueue
name|q
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
operator|(
name|r
operator|+
name|j
operator|)
operator|&
name|m
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|q
operator|.
name|base
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|q
operator|.
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// probably nonempty
name|int
name|i
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|.
name|base
operator|==
name|b
operator|&&
name|ec
operator|>=
literal|0
operator|&&
name|t
operator|!=
literal|null
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|i
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|.
name|base
operator|=
name|b
operator|+
literal|1
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
condition|)
name|signalWork
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|t
return|;
comment|// taken
block|}
elseif|else
if|if
condition|(
operator|(
name|ec
operator|<
literal|0
operator|||
name|j
operator|<
name|m
operator|)
operator|&&
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>
name|AC_SHIFT
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|w
operator|.
name|hint
operator|=
operator|(
name|r
operator|+
name|j
operator|)
operator|&
name|m
expr_stmt|;
comment|// help signal below
break|break;
comment|// cannot take
block|}
block|}
block|}
do|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
do|;
name|int
name|h
decl_stmt|,
name|e
decl_stmt|,
name|ns
decl_stmt|;
name|long
name|c
decl_stmt|,
name|sc
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|ns
operator|=
name|w
operator|.
name|nsteals
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|STEALCOUNT
argument_list|,
name|sc
operator|=
name|stealCount
argument_list|,
name|sc
operator|+
name|ns
argument_list|)
condition|)
name|w
operator|.
name|nsteals
operator|=
literal|0
expr_stmt|;
comment|// collect steals and rescan
block|}
elseif|else
if|if
condition|(
name|plock
operator|!=
name|ps
condition|)
comment|// consistency check
empty_stmt|;
comment|// skip
elseif|else
if|if
condition|(
operator|(
name|e
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|=
name|ctl
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|w
operator|.
name|qlock
operator|=
operator|-
literal|1
expr_stmt|;
comment|// pool is terminating
else|else
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|w
operator|.
name|hint
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ec
operator|>=
literal|0
condition|)
block|{
comment|// try to enqueue/inactivate
name|long
name|nc
init|=
operator|(
operator|(
operator|(
name|long
operator|)
name|ec
operator||
operator|(
operator|(
name|c
operator|-
name|AC_UNIT
operator|)
operator|&
operator|(
name|AC_MASK
operator||
name|TC_MASK
operator|)
operator|)
operator|)
operator|)
decl_stmt|;
name|w
operator|.
name|nextWait
operator|=
name|e
expr_stmt|;
comment|// link and mark inactive
name|w
operator|.
name|eventCount
operator|=
name|ec
operator||
name|INT_SIGN
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|c
operator|||
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
name|w
operator|.
name|eventCount
operator|=
name|ec
expr_stmt|;
comment|// unmark on CAS failure
elseif|else
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
operator|==
literal|1
operator|-
operator|(
name|config
operator|&
name|SMASK
operator|)
condition|)
name|idleAwaitWork
argument_list|(
name|w
argument_list|,
name|nc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|.
name|eventCount
operator|<
literal|0
operator|&&
name|ctl
operator|==
name|c
condition|)
block|{
name|Thread
name|wt
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
comment|// clear status
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|w
operator|.
name|parker
operator|=
name|wt
expr_stmt|;
comment|// emulate LockSupport.park
if|if
condition|(
name|w
operator|.
name|eventCount
operator|<
literal|0
condition|)
comment|// recheck
name|U
operator|.
name|park
argument_list|(
literal|false
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
comment|// block
name|w
operator|.
name|parker
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
literal|null
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|h
operator|>=
literal|0
operator|||
operator|(
name|h
operator|=
name|w
operator|.
name|hint
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
name|h
operator|<
name|ws
operator|.
name|length
operator|&&
operator|(
name|q
operator|=
name|ws
index|[
name|h
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
comment|// signal others before retry
name|WorkQueue
name|v
decl_stmt|;
name|Thread
name|p
decl_stmt|;
name|int
name|u
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|-
literal|1
init|;
condition|;
control|)
block|{
name|int
name|idleCount
init|=
operator|(
name|w
operator|.
name|eventCount
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|s
operator|=
name|idleCount
operator|-
name|q
operator|.
name|base
operator|+
name|q
operator|.
name|top
operator|)
operator|<=
name|n
operator|&&
operator|(
name|n
operator|=
name|s
operator|)
operator|<=
literal|0
operator|)
operator|||
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|>>>
literal|32
argument_list|)
operator|)
operator|>=
literal|0
operator|||
operator|(
name|e
operator|=
operator|(
name|int
operator|)
name|c
operator|)
operator|<=
literal|0
operator|||
name|m
operator|<
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|||
operator|(
name|v
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|==
literal|null
condition|)
break|break;
name|long
name|nc
init|=
operator|(
operator|(
call|(
name|long
call|)
argument_list|(
name|v
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|u
operator|+
name|UAC_UNIT
argument_list|)
operator|<<
literal|32
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|eventCount
operator|!=
operator|(
name|e
operator||
name|INT_SIGN
operator|)
operator|||
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
break|break;
name|v
operator|.
name|hint
operator|=
name|h
expr_stmt|;
name|v
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|v
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * If inactivating worker w has caused the pool to become      * quiescent, checks for pool termination, and, so long as this is      * not the only worker, waits for event for up to a given      * duration.  On timeout, if ctl has not changed, terminates the      * worker, which will in turn wake up another worker to possibly      * repeat this process.      *      * @param w the calling worker      * @param currentCtl the ctl value triggering possible quiescence      * @param prevCtl the ctl value to restore if thread is terminated      */
DECL|method|idleAwaitWork
specifier|private
name|void
name|idleAwaitWork
parameter_list|(
name|WorkQueue
name|w
parameter_list|,
name|long
name|currentCtl
parameter_list|,
name|long
name|prevCtl
parameter_list|)
block|{
if|if
condition|(
name|w
operator|!=
literal|null
operator|&&
name|w
operator|.
name|eventCount
operator|<
literal|0
operator|&&
operator|!
name|tryTerminate
argument_list|(
literal|false
argument_list|,
literal|false
argument_list|)
operator|&&
operator|(
name|int
operator|)
name|prevCtl
operator|!=
literal|0
operator|&&
name|ctl
operator|==
name|currentCtl
condition|)
block|{
name|int
name|dc
init|=
operator|-
call|(
name|short
call|)
argument_list|(
name|currentCtl
operator|>>>
name|TC_SHIFT
argument_list|)
decl_stmt|;
name|long
name|parkTime
init|=
name|dc
operator|<
literal|0
condition|?
name|FAST_IDLE_TIMEOUT
else|:
operator|(
name|dc
operator|+
literal|1
operator|)
operator|*
name|IDLE_TIMEOUT
decl_stmt|;
name|long
name|deadline
init|=
name|System
operator|.
name|nanoTime
argument_list|()
operator|+
name|parkTime
operator|-
name|TIMEOUT_SLOP
decl_stmt|;
name|Thread
name|wt
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
while|while
condition|(
name|ctl
operator|==
name|currentCtl
condition|)
block|{
name|Thread
operator|.
name|interrupted
argument_list|()
expr_stmt|;
comment|// timed variant of version in scan()
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|w
operator|.
name|parker
operator|=
name|wt
expr_stmt|;
if|if
condition|(
name|ctl
operator|==
name|currentCtl
condition|)
name|U
operator|.
name|park
argument_list|(
literal|false
argument_list|,
name|parkTime
argument_list|)
expr_stmt|;
name|w
operator|.
name|parker
operator|=
literal|null
expr_stmt|;
name|U
operator|.
name|putObject
argument_list|(
name|wt
argument_list|,
name|PARKBLOCKER
argument_list|,
literal|null
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|!=
name|currentCtl
condition|)
break|break;
if|if
condition|(
name|deadline
operator|-
name|System
operator|.
name|nanoTime
argument_list|()
operator|<=
literal|0L
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|currentCtl
argument_list|,
name|prevCtl
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|w
operator|.
name|eventCount
operator|+
name|E_SEQ
operator|)
operator||
name|E_MASK
expr_stmt|;
name|w
operator|.
name|hint
operator|=
operator|-
literal|1
expr_stmt|;
name|w
operator|.
name|qlock
operator|=
operator|-
literal|1
expr_stmt|;
comment|// shrink
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Scans through queues looking for work while joining a task; if      * any present, signals. May return early if more signalling is      * detectably unneeded.      *      * @param task return early if done      * @param origin an index to start scan      */
DECL|method|helpSignal
specifier|private
name|void
name|helpSignal
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|,
name|int
name|origin
parameter_list|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|Thread
name|p
decl_stmt|;
name|long
name|c
decl_stmt|;
name|int
name|m
decl_stmt|,
name|u
decl_stmt|,
name|e
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
operator|&&
name|task
operator|.
name|status
operator|>=
literal|0
operator|&&
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>>
literal|32
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|u
operator|>>
name|UAC_SHIFT
operator|)
operator|<
literal|0
operator|&&
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
name|outer
label|:
for|for
control|(
name|int
name|k
init|=
name|origin
init|,
name|j
init|=
name|m
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|WorkQueue
name|q
init|=
name|ws
index|[
name|k
operator|++
operator|&
name|m
index|]
decl_stmt|;
for|for
control|(
name|int
name|n
init|=
name|m
init|;
condition|;
control|)
block|{
comment|// limit to at most m signals
if|if
condition|(
name|task
operator|.
name|status
operator|<
literal|0
condition|)
break|break
name|outer
break|;
if|if
condition|(
name|q
operator|==
literal|null
operator|||
operator|(
operator|(
name|s
operator|=
operator|-
name|q
operator|.
name|base
operator|+
name|q
operator|.
name|top
operator|)
operator|<=
name|n
operator|&&
operator|(
name|n
operator|=
name|s
operator|)
operator|<=
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|>>>
literal|32
argument_list|)
operator|)
operator|>=
literal|0
operator|||
operator|(
name|e
operator|=
operator|(
name|int
operator|)
name|c
operator|)
operator|<=
literal|0
operator|||
name|m
operator|<
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|||
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|==
literal|null
condition|)
break|break
name|outer
break|;
name|long
name|nc
init|=
operator|(
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator|)
operator||
operator|(
call|(
name|long
call|)
argument_list|(
name|u
operator|+
name|UAC_UNIT
argument_list|)
operator|<<
literal|32
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|w
operator|.
name|eventCount
operator|!=
operator|(
name|e
operator||
name|INT_SIGN
operator|)
condition|)
break|break
name|outer
break|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|w
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/**      * Tries to locate and execute tasks for a stealer of the given      * task, or in turn one of its stealers, Traces currentSteal ->      * currentJoin links looking for a thread working on a descendant      * of the given task and with a non-empty queue to steal back and      * execute tasks from. The first call to this method upon a      * waiting join will often entail scanning/search, (which is OK      * because the joiner has nothing better to do), but this method      * leaves hints in workers to speed up subsequent calls. The      * implementation is very branchy to cope with potential      * inconsistencies or loops encountering chains that are stale,      * unknown, or so long that they are likely cyclic.      *      * @param joiner the joining worker      * @param task the task to join      * @return 0 if no progress can be made, negative if task      * known complete, else positive      */
DECL|method|tryHelpStealer
specifier|private
name|int
name|tryHelpStealer
parameter_list|(
name|WorkQueue
name|joiner
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|stat
init|=
literal|0
decl_stmt|,
name|steps
init|=
literal|0
decl_stmt|;
comment|// bound to avoid cycles
if|if
condition|(
name|joiner
operator|!=
literal|null
operator|&&
name|task
operator|!=
literal|null
condition|)
block|{
comment|// hoist null checks
name|restart
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|subtask
init|=
name|task
decl_stmt|;
comment|// current target
for|for
control|(
name|WorkQueue
name|j
init|=
name|joiner
init|,
name|v
init|;
condition|;
control|)
block|{
comment|// v is stealer of subtask
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|,
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|<
literal|0
condition|)
block|{
name|stat
operator|=
name|s
expr_stmt|;
break|break
name|restart
break|;
block|}
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|==
literal|null
operator|||
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|<=
literal|0
condition|)
break|break
name|restart
break|;
comment|// shutting down
if|if
condition|(
operator|(
name|v
operator|=
name|ws
index|[
name|h
operator|=
operator|(
name|j
operator|.
name|hint
operator||
literal|1
operator|)
operator|&
name|m
index|]
operator|)
operator|==
literal|null
operator|||
name|v
operator|.
name|currentSteal
operator|!=
name|subtask
condition|)
block|{
for|for
control|(
name|int
name|origin
init|=
name|h
init|;
condition|;
control|)
block|{
comment|// find stealer
if|if
condition|(
operator|(
operator|(
name|h
operator|=
operator|(
name|h
operator|+
literal|2
operator|)
operator|&
name|m
operator|)
operator|&
literal|15
operator|)
operator|==
literal|1
operator|&&
operator|(
name|subtask
operator|.
name|status
operator|<
literal|0
operator|||
name|j
operator|.
name|currentJoin
operator|!=
name|subtask
operator|)
condition|)
continue|continue
name|restart
continue|;
comment|// occasional staleness check
if|if
condition|(
operator|(
name|v
operator|=
name|ws
index|[
name|h
index|]
operator|)
operator|!=
literal|null
operator|&&
name|v
operator|.
name|currentSteal
operator|==
name|subtask
condition|)
block|{
name|j
operator|.
name|hint
operator|=
name|h
expr_stmt|;
comment|// save hint
break|break;
block|}
if|if
condition|(
name|h
operator|==
name|origin
condition|)
break|break
name|restart
break|;
comment|// cannot find stealer
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// help stealer or descend to its stealer
name|ForkJoinTask
index|[]
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
name|subtask
operator|.
name|status
operator|<
literal|0
condition|)
comment|// surround probes with
continue|continue
name|restart
continue|;
comment|//   consistency checks
if|if
condition|(
operator|(
name|b
operator|=
name|v
operator|.
name|base
operator|)
operator|-
name|v
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|a
operator|=
name|v
operator|.
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|i
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
name|b
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|=
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|U
operator|.
name|getObjectVolatile
argument_list|(
name|a
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|subtask
operator|.
name|status
operator|<
literal|0
operator|||
name|j
operator|.
name|currentJoin
operator|!=
name|subtask
operator|||
name|v
operator|.
name|currentSteal
operator|!=
name|subtask
condition|)
continue|continue
name|restart
continue|;
comment|// stale
name|stat
operator|=
literal|1
expr_stmt|;
comment|// apparent progress
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
name|v
operator|.
name|base
operator|==
name|b
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|i
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|v
operator|.
name|base
operator|=
name|b
operator|+
literal|1
expr_stmt|;
comment|// help stealer
name|joiner
operator|.
name|runSubtask
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|.
name|base
operator|==
name|b
operator|&&
operator|++
name|steps
operator|==
name|MAX_HELP
condition|)
break|break
name|restart
break|;
comment|// v apparently stalled
block|}
else|else
block|{
comment|// empty -- try to descend
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|next
init|=
name|v
operator|.
name|currentJoin
decl_stmt|;
if|if
condition|(
name|subtask
operator|.
name|status
operator|<
literal|0
operator|||
name|j
operator|.
name|currentJoin
operator|!=
name|subtask
operator|||
name|v
operator|.
name|currentSteal
operator|!=
name|subtask
condition|)
continue|continue
name|restart
continue|;
comment|// stale
elseif|else
if|if
condition|(
name|next
operator|==
literal|null
operator|||
operator|++
name|steps
operator|==
name|MAX_HELP
condition|)
break|break
name|restart
break|;
comment|// dead-end or maybe cyclic
else|else
block|{
name|subtask
operator|=
name|next
expr_stmt|;
name|j
operator|=
name|v
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
return|return
name|stat
return|;
block|}
comment|/**      * Analog of tryHelpStealer for CountedCompleters. Tries to steal      * and run tasks within the target's computation.      *      * @param task the task to join      * @param mode if shared, exit upon completing any task      * if all workers are active      */
DECL|method|helpComplete
specifier|private
name|int
name|helpComplete
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
decl_stmt|,
name|s
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
name|task
operator|!=
literal|null
operator|&&
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
literal|1
init|,
name|origin
init|=
name|j
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|<
literal|0
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
name|j
operator|&
name|m
index|]
operator|)
operator|!=
literal|null
operator|&&
name|q
operator|.
name|pollAndExecCC
argument_list|(
name|task
argument_list|)
condition|)
block|{
name|origin
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|SHARED_QUEUE
operator|&&
operator|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>>
literal|32
argument_list|)
operator|)
operator|>=
literal|0
operator|||
operator|(
name|u
operator|>>
name|UAC_SHIFT
operator|)
operator|>=
literal|0
operator|)
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|j
operator|=
operator|(
name|j
operator|+
literal|2
operator|)
operator|&
name|m
operator|)
operator|==
name|origin
condition|)
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/**      * Tries to decrement active count (sometimes implicitly) and      * possibly release or create a compensating worker in preparation      * for blocking. Fails on contention or termination. Otherwise,      * adds a new thread if no idle workers are available and pool      * may become starved.      */
DECL|method|tryCompensate
specifier|final
name|boolean
name|tryCompensate
parameter_list|()
block|{
name|int
name|pc
init|=
name|config
operator|&
name|SMASK
decl_stmt|,
name|e
decl_stmt|,
name|i
decl_stmt|,
name|tc
decl_stmt|;
name|long
name|c
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|Thread
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|e
operator|=
call|(
name|int
call|)
argument_list|(
name|c
operator|=
name|ctl
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|<
name|ws
operator|.
name|length
operator|&&
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
name|w
operator|.
name|eventCount
operator|==
operator|(
name|e
operator||
name|INT_SIGN
operator|)
condition|)
block|{
name|long
name|nc
init|=
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator||
operator|(
name|c
operator|&
operator|(
name|AC_MASK
operator||
name|TC_MASK
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|w
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
comment|// replace with idle worker
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tc
operator|=
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
operator|+
name|pc
operator|>
literal|1
condition|)
block|{
name|long
name|nc
init|=
operator|(
operator|(
name|c
operator|-
name|AC_UNIT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
name|c
operator|&
operator|~
name|AC_MASK
operator|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
return|return
literal|true
return|;
comment|// no compensation
block|}
elseif|else
if|if
condition|(
name|tc
operator|+
name|pc
operator|<
name|MAX_CAP
condition|)
block|{
name|long
name|nc
init|=
operator|(
operator|(
name|c
operator|+
name|TC_UNIT
operator|)
operator|&
name|TC_MASK
operator|)
operator||
operator|(
name|c
operator|&
operator|~
name|TC_MASK
operator|)
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|ForkJoinWorkerThreadFactory
name|fac
decl_stmt|;
name|Throwable
name|ex
init|=
literal|null
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
init|=
literal|null
decl_stmt|;
try|try
block|{
if|if
condition|(
operator|(
name|fac
operator|=
name|factory
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|wt
operator|=
name|fac
operator|.
name|newThread
argument_list|(
name|this
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
name|wt
operator|.
name|start
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
catch|catch
parameter_list|(
name|Throwable
name|rex
parameter_list|)
block|{
name|ex
operator|=
name|rex
expr_stmt|;
block|}
name|deregisterWorker
argument_list|(
name|wt
argument_list|,
name|ex
argument_list|)
expr_stmt|;
comment|// clean up and return false
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Helps and/or blocks until the given task is done.      *      * @param joiner the joining worker      * @param task the task      * @return task status on exit      */
DECL|method|awaitJoin
specifier|final
name|int
name|awaitJoin
parameter_list|(
name|WorkQueue
name|joiner
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|s
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|joiner
operator|!=
literal|null
operator|&&
name|task
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|prevJoin
init|=
name|joiner
operator|.
name|currentJoin
decl_stmt|;
name|joiner
operator|.
name|currentJoin
operator|=
name|task
expr_stmt|;
do|do
block|{}
do|while
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|!
name|joiner
operator|.
name|isEmpty
argument_list|()
operator|&&
name|joiner
operator|.
name|tryRemoveAndExec
argument_list|(
name|task
argument_list|)
condition|)
do|;
comment|// process local tasks
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|helpSignal
argument_list|(
name|task
argument_list|,
name|joiner
operator|.
name|poolIndex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|task
operator|instanceof
name|CountedCompleter
operator|)
condition|)
name|s
operator|=
name|helpComplete
argument_list|(
name|task
argument_list|,
name|LIFO_QUEUE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|joiner
operator|.
name|isEmpty
argument_list|()
operator|||
comment|// try helping
operator|(
name|s
operator|=
name|tryHelpStealer
argument_list|(
name|joiner
argument_list|,
name|task
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|helpSignal
argument_list|(
name|task
argument_list|,
name|joiner
operator|.
name|poolIndex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
operator|&&
name|tryCompensate
argument_list|()
condition|)
block|{
if|if
condition|(
name|task
operator|.
name|trySetSignal
argument_list|()
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
synchronized|synchronized
init|(
name|task
init|)
block|{
if|if
condition|(
name|task
operator|.
name|status
operator|>=
literal|0
condition|)
block|{
try|try
block|{
comment|// see ForkJoinTask
name|task
operator|.
name|wait
argument_list|()
expr_stmt|;
comment|//  for explanation
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{                                     }
block|}
else|else
name|task
operator|.
name|notifyAll
argument_list|()
expr_stmt|;
block|}
block|}
name|long
name|c
decl_stmt|;
comment|// re-activate
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
do|;
block|}
block|}
block|}
name|joiner
operator|.
name|currentJoin
operator|=
name|prevJoin
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Stripped-down variant of awaitJoin used by timed joins. Tries      * to help join only while there is continuous progress. (Caller      * will then enter a timed wait.)      *      * @param joiner the joining worker      * @param task the task      */
DECL|method|helpJoinOnce
specifier|final
name|void
name|helpJoinOnce
parameter_list|(
name|WorkQueue
name|joiner
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|joiner
operator|!=
literal|null
operator|&&
name|task
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|prevJoin
init|=
name|joiner
operator|.
name|currentJoin
decl_stmt|;
name|joiner
operator|.
name|currentJoin
operator|=
name|task
expr_stmt|;
do|do
block|{}
do|while
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|!
name|joiner
operator|.
name|isEmpty
argument_list|()
operator|&&
name|joiner
operator|.
name|tryRemoveAndExec
argument_list|(
name|task
argument_list|)
condition|)
do|;
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
condition|)
block|{
name|helpSignal
argument_list|(
name|task
argument_list|,
name|joiner
operator|.
name|poolIndex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|task
operator|.
name|status
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|task
operator|instanceof
name|CountedCompleter
operator|)
condition|)
name|s
operator|=
name|helpComplete
argument_list|(
name|task
argument_list|,
name|LIFO_QUEUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|joiner
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
do|do
block|{}
do|while
condition|(
name|task
operator|.
name|status
operator|>=
literal|0
operator|&&
name|tryHelpStealer
argument_list|(
name|joiner
argument_list|,
name|task
argument_list|)
operator|>
literal|0
condition|)
do|;
block|}
name|joiner
operator|.
name|currentJoin
operator|=
name|prevJoin
expr_stmt|;
block|}
block|}
comment|/**      * Returns a (probably) non-empty steal queue, if one is found      * during a scan, else null.  This method must be retried by      * caller if, by the time it tries to use the queue, it is empty.      * @param r a (random) seed for scanning      */
DECL|method|findNonEmptyStealQueue
specifier|private
name|WorkQueue
name|findNonEmptyStealQueue
parameter_list|(
name|int
name|r
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ps
init|=
name|plock
decl_stmt|,
name|m
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
operator|(
name|m
operator|+
literal|1
operator|)
operator|<<
literal|2
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
operator|(
operator|(
operator|(
name|r
operator|+
name|j
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
operator|)
operator|&
name|m
index|]
operator|)
operator|!=
literal|null
operator|&&
name|q
operator|.
name|base
operator|-
name|q
operator|.
name|top
operator|<
literal|0
condition|)
return|return
name|q
return|;
block|}
block|}
if|if
condition|(
name|plock
operator|==
name|ps
condition|)
return|return
literal|null
return|;
block|}
block|}
comment|/**      * Runs tasks until {@code isQuiescent()}. We piggyback on      * active count ctl maintenance, but rather than blocking      * when tasks cannot be found, we rescan until all others cannot      * find tasks either.      */
DECL|method|helpQuiescePool
specifier|final
name|void
name|helpQuiescePool
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
for|for
control|(
name|boolean
name|active
init|=
literal|true
init|;
condition|;
control|)
block|{
name|long
name|c
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|int
name|b
decl_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|w
operator|.
name|nextLocalTask
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|w
operator|.
name|base
operator|-
name|w
operator|.
name|top
operator|<
literal|0
condition|)
name|signalWork
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|findNonEmptyStealQueue
argument_list|(
name|w
operator|.
name|nextSeed
argument_list|()
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|active
condition|)
block|{
comment|// re-establish active count
name|active
operator|=
literal|true
expr_stmt|;
do|do
block|{}
do|while
condition|(
operator|!
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
operator|=
name|ctl
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|b
operator|=
name|q
operator|.
name|base
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|t
operator|=
name|q
operator|.
name|pollAt
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|base
operator|-
name|q
operator|.
name|top
operator|<
literal|0
condition|)
name|signalWork
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|w
operator|.
name|runSubtask
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|active
condition|)
block|{
comment|// decrement active count without queuing
name|long
name|nc
init|=
operator|(
name|c
operator|=
name|ctl
operator|)
operator|-
name|AC_UNIT
decl_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|nc
operator|>>
name|AC_SHIFT
argument_list|)
operator|+
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|==
literal|0
condition|)
return|return;
comment|// bypass decrement-then-increment
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|nc
argument_list|)
condition|)
name|active
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|int
call|)
argument_list|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|>>
name|AC_SHIFT
argument_list|)
operator|+
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|==
literal|0
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|c
operator|+
name|AC_UNIT
argument_list|)
condition|)
return|return;
block|}
block|}
comment|/**      * Gets and removes a local or stolen task for the given worker.      *      * @return a task, if available      */
DECL|method|nextTaskFor
specifier|final
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|nextTaskFor
parameter_list|(
name|WorkQueue
name|w
parameter_list|)
block|{
for|for
control|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
init|;
condition|;
control|)
block|{
name|WorkQueue
name|q
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|w
operator|.
name|nextLocalTask
argument_list|()
operator|)
operator|!=
literal|null
condition|)
return|return
name|t
return|;
if|if
condition|(
operator|(
name|q
operator|=
name|findNonEmptyStealQueue
argument_list|(
name|w
operator|.
name|nextSeed
argument_list|()
argument_list|)
operator|)
operator|==
literal|null
condition|)
return|return
literal|null
return|;
if|if
condition|(
operator|(
name|b
operator|=
name|q
operator|.
name|base
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
operator|&&
operator|(
name|t
operator|=
name|q
operator|.
name|pollAt
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|base
operator|-
name|q
operator|.
name|top
operator|<
literal|0
condition|)
name|signalWork
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
block|}
comment|/**      * Returns a cheap heuristic guide for task partitioning when      * programmers, frameworks, tools, or languages have little or no      * idea about task granularity.  In essence by offering this      * method, we ask users only about tradeoffs in overhead vs      * expected throughput and its variance, rather than how finely to      * partition tasks.      *      * In a steady state strict (tree-structured) computation, each      * thread makes available for stealing enough tasks for other      * threads to remain active. Inductively, if all threads play by      * the same rules, each thread should make available only a      * constant number of tasks.      *      * The minimum useful constant is just 1. But using a value of 1      * would require immediate replenishment upon each steal to      * maintain enough tasks, which is infeasible.  Further,      * partitionings/granularities of offered tasks should minimize      * steal rates, which in general means that threads nearer the top      * of computation tree should generate more than those nearer the      * bottom. In perfect steady state, each thread is at      * approximately the same level of computation tree. However,      * producing extra tasks amortizes the uncertainty of progress and      * diffusion assumptions.      *      * So, users will want to use values larger (but not much larger)      * than 1 to both smooth over transient shortages and hedge      * against uneven progress; as traded off against the cost of      * extra task overhead. We leave the user to pick a threshold      * value to compare with the results of this call to guide      * decisions, but recommend values such as 3.      *      * When all threads are active, it is on average OK to estimate      * surplus strictly locally. In steady-state, if one thread is      * maintaining say 2 surplus tasks, then so are others. So we can      * just use estimated queue length.  However, this strategy alone      * leads to serious mis-estimates in some non-steady-state      * conditions (ramp-up, ramp-down, other stalls). We can detect      * many of these by further considering the number of "idle"      * threads, that are known to have zero queued tasks, so      * compensate by a factor of (#idle/#active) threads.      *      * Note: The approximation of #busy workers as #active workers is      * not very good under current signalling scheme, and should be      * improved.      */
DECL|method|getSurplusQueuedTaskCount
specifier|static
name|int
name|getSurplusQueuedTaskCount
parameter_list|()
block|{
name|Thread
name|t
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
decl_stmt|;
name|ForkJoinPool
name|pool
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|t
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|)
operator|instanceof
name|ForkJoinWorkerThread
operator|)
condition|)
block|{
name|int
name|p
init|=
operator|(
name|pool
operator|=
operator|(
name|wt
operator|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
operator|)
operator|.
name|config
operator|&
name|SMASK
decl_stmt|;
name|int
name|n
init|=
operator|(
name|q
operator|=
name|wt
operator|.
name|workQueue
operator|)
operator|.
name|top
operator|-
name|q
operator|.
name|base
decl_stmt|;
name|int
name|a
init|=
call|(
name|int
call|)
argument_list|(
name|pool
operator|.
name|ctl
operator|>>
name|AC_SHIFT
argument_list|)
operator|+
name|p
decl_stmt|;
return|return
name|n
operator|-
operator|(
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|0
else|:
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|1
else|:
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|2
else|:
name|a
operator|>
operator|(
name|p
operator|>>>=
literal|1
operator|)
condition|?
literal|4
else|:
literal|8
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
comment|//  Termination
comment|/**      * Possibly initiates and/or completes termination.  The caller      * triggering termination runs three passes through workQueues:      * (0) Setting termination status, followed by wakeups of queued      * workers; (1) cancelling all tasks; (2) interrupting lagging      * threads (likely in external tasks, but possibly also blocked in      * joins).  Each pass repeats previous steps because of potential      * lagging thread creation.      *      * @param now if true, unconditionally terminate, else only      * if no work and no active workers      * @param enable if true, enable shutdown when next possible      * @return true if now terminating or terminated      */
DECL|method|tryTerminate
specifier|private
name|boolean
name|tryTerminate
parameter_list|(
name|boolean
name|now
parameter_list|,
name|boolean
name|enable
parameter_list|)
block|{
name|int
name|ps
decl_stmt|;
if|if
condition|(
name|this
operator|==
name|common
condition|)
comment|// cannot shut down
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|ps
operator|=
name|plock
operator|)
operator|>=
literal|0
condition|)
block|{
comment|// enable by setting plock
if|if
condition|(
operator|!
name|enable
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|ps
operator|&
name|PL_LOCK
operator|)
operator|!=
literal|0
operator|||
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|ps
operator|+=
name|PL_LOCK
argument_list|)
condition|)
name|ps
operator|=
name|acquirePlock
argument_list|()
expr_stmt|;
name|int
name|nps
init|=
operator|(
operator|(
name|ps
operator|+
name|PL_LOCK
operator|)
operator|&
operator|~
name|SHUTDOWN
operator|)
operator||
name|SHUTDOWN
decl_stmt|;
if|if
condition|(
operator|!
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|this
argument_list|,
name|PLOCK
argument_list|,
name|ps
argument_list|,
name|nps
argument_list|)
condition|)
name|releasePlock
argument_list|(
name|nps
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|long
name|c
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|c
operator|=
name|ctl
operator|)
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// already terminating
if|if
condition|(
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
operator|==
operator|-
operator|(
name|config
operator|&
name|SMASK
operator|)
condition|)
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
name|notifyAll
argument_list|()
expr_stmt|;
comment|// signal when 0 workers
block|}
block|}
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|now
condition|)
block|{
comment|// check if idle& no tasks
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
operator|!=
operator|-
operator|(
name|config
operator|&
name|SMASK
operator|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// signal unprocessed tasks
name|signalWork
argument_list|(
name|w
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|w
operator|.
name|eventCount
operator|>=
literal|0
condition|)
return|return
literal|false
return|;
comment|// unqueued inactive worker
block|}
block|}
block|}
block|}
if|if
condition|(
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|c
argument_list|,
name|c
operator||
name|STOP_BIT
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|pass
init|=
literal|0
init|;
name|pass
operator|<
literal|3
condition|;
operator|++
name|pass
control|)
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|Thread
name|wt
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|n
init|=
name|ws
operator|.
name|length
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|w
operator|.
name|qlock
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|0
condition|)
block|{
name|w
operator|.
name|cancelAll
argument_list|()
expr_stmt|;
if|if
condition|(
name|pass
operator|>
literal|1
operator|&&
operator|(
name|wt
operator|=
name|w
operator|.
name|owner
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
operator|!
name|wt
operator|.
name|isInterrupted
argument_list|()
condition|)
block|{
try|try
block|{
name|wt
operator|.
name|interrupt
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|ignore
parameter_list|)
block|{                                             }
block|}
name|U
operator|.
name|unpark
argument_list|(
name|wt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// Wake up workers parked on event queue
name|int
name|i
decl_stmt|,
name|e
decl_stmt|;
name|long
name|cc
decl_stmt|;
name|Thread
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
call|(
name|int
call|)
argument_list|(
name|cc
operator|=
name|ctl
argument_list|)
operator|&
name|E_MASK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|=
name|e
operator|&
name|SMASK
operator|)
operator|<
name|n
operator|&&
name|i
operator|>=
literal|0
operator|&&
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|nc
init|=
operator|(
call|(
name|long
call|)
argument_list|(
name|w
operator|.
name|nextWait
operator|&
name|E_MASK
argument_list|)
operator||
operator|(
operator|(
name|cc
operator|+
name|AC_UNIT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
name|cc
operator|&
operator|(
name|TC_MASK
operator||
name|STOP_BIT
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|w
operator|.
name|eventCount
operator|==
operator|(
name|e
operator||
name|INT_SIGN
operator|)
operator|&&
name|U
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|CTL
argument_list|,
name|cc
argument_list|,
name|nc
argument_list|)
condition|)
block|{
name|w
operator|.
name|eventCount
operator|=
operator|(
name|e
operator|+
name|E_SEQ
operator|)
operator|&
name|E_MASK
expr_stmt|;
name|w
operator|.
name|qlock
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|w
operator|.
name|parker
operator|)
operator|!=
literal|null
condition|)
name|U
operator|.
name|unpark
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|// external operations on common pool
comment|/**      * Returns common pool queue for a thread that has submitted at      * least one task.      */
DECL|method|commonSubmitterQueue
specifier|static
name|WorkQueue
name|commonSubmitterQueue
parameter_list|()
block|{
name|ForkJoinPool
name|p
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|int
name|m
decl_stmt|;
name|Submitter
name|z
decl_stmt|;
return|return
operator|(
operator|(
name|z
operator|=
name|submitters
operator|.
name|get
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|p
operator|=
name|common
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|ws
operator|=
name|p
operator|.
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|)
condition|?
name|ws
index|[
name|m
operator|&
name|z
operator|.
name|seed
operator|&
name|SQMASK
index|]
else|:
literal|null
return|;
block|}
comment|/**      * Tries to pop the given task from submitter's queue in common pool.      */
DECL|method|tryExternalUnpush
specifier|static
name|boolean
name|tryExternalUnpush
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
name|ForkJoinPool
name|p
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|Submitter
name|z
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
operator|(
name|z
operator|=
name|submitters
operator|.
name|get
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|p
operator|=
name|common
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|ws
operator|=
name|p
operator|.
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|q
operator|=
name|ws
index|[
name|m
operator|&
name|z
operator|.
name|seed
operator|&
name|SQMASK
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|s
operator|=
name|q
operator|.
name|top
operator|)
operator|!=
name|q
operator|.
name|base
operator|&&
operator|(
name|a
operator|=
name|q
operator|.
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|long
name|j
init|=
operator|(
operator|(
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|==
name|t
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|q
argument_list|,
name|QLOCK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|array
operator|==
name|a
operator|&&
name|q
operator|.
name|top
operator|==
name|s
operator|&&
comment|// recheck
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|q
operator|.
name|top
operator|=
name|s
operator|-
literal|1
expr_stmt|;
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Tries to pop and run local tasks within the same computation      * as the given root. On failure, tries to help complete from      * other queues via helpComplete.      */
DECL|method|externalHelpComplete
specifier|private
name|void
name|externalHelpComplete
parameter_list|(
name|WorkQueue
name|q
parameter_list|,
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|root
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|q
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|q
operator|.
name|array
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
operator|(
name|a
operator|.
name|length
operator|-
literal|1
operator|)
operator|)
operator|>=
literal|0
operator|&&
name|root
operator|!=
literal|null
operator|&&
name|root
operator|.
name|status
operator|>=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|s
decl_stmt|,
name|u
decl_stmt|;
name|Object
name|o
decl_stmt|;
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|task
init|=
literal|null
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|q
operator|.
name|top
operator|)
operator|-
name|q
operator|.
name|base
operator|>
literal|0
condition|)
block|{
name|long
name|j
init|=
operator|(
operator|(
name|m
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
operator|(
name|o
operator|=
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|o
operator|instanceof
name|CountedCompleter
operator|)
condition|)
block|{
name|CountedCompleter
argument_list|<
name|?
argument_list|>
name|t
init|=
operator|(
name|CountedCompleter
argument_list|<
name|?
argument_list|>
operator|)
name|o
decl_stmt|,
name|r
init|=
name|t
decl_stmt|;
do|do
block|{
if|if
condition|(
name|r
operator|==
name|root
condition|)
block|{
if|if
condition|(
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|q
argument_list|,
name|QLOCK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|array
operator|==
name|a
operator|&&
name|q
operator|.
name|top
operator|==
name|s
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|q
operator|.
name|top
operator|=
name|s
operator|-
literal|1
expr_stmt|;
name|task
operator|=
name|t
expr_stmt|;
block|}
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|r
operator|=
name|r
operator|.
name|completer
operator|)
operator|!=
literal|null
condition|)
do|;
block|}
block|}
if|if
condition|(
name|task
operator|!=
literal|null
condition|)
name|task
operator|.
name|doExec
argument_list|()
expr_stmt|;
if|if
condition|(
name|root
operator|.
name|status
operator|<
literal|0
operator|||
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>>
literal|32
argument_list|)
operator|)
operator|>=
literal|0
operator|||
operator|(
name|u
operator|>>
name|UAC_SHIFT
operator|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|task
operator|==
literal|null
condition|)
block|{
name|helpSignal
argument_list|(
name|root
argument_list|,
name|q
operator|.
name|poolIndex
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|.
name|status
operator|>=
literal|0
condition|)
name|helpComplete
argument_list|(
name|root
argument_list|,
name|SHARED_QUEUE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/**      * Tries to help execute or signal availability of the given task      * from submitter's queue in common pool.      */
DECL|method|externalHelpJoin
specifier|static
name|void
name|externalHelpJoin
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
parameter_list|)
block|{
comment|// Some hard-to-avoid overlap with tryExternalUnpush
name|ForkJoinPool
name|p
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|,
name|w
decl_stmt|;
name|Submitter
name|z
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
index|[]
name|a
decl_stmt|;
name|int
name|m
decl_stmt|,
name|s
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|t
operator|!=
literal|null
operator|&&
operator|(
name|z
operator|=
name|submitters
operator|.
name|get
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|p
operator|=
name|common
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|ws
operator|=
name|p
operator|.
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|q
operator|=
name|ws
index|[
name|m
operator|&
name|z
operator|.
name|seed
operator|&
name|SQMASK
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|a
operator|=
name|q
operator|.
name|array
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|am
init|=
name|a
operator|.
name|length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|q
operator|.
name|top
operator|)
operator|!=
name|q
operator|.
name|base
condition|)
block|{
name|long
name|j
init|=
operator|(
operator|(
name|am
operator|&
operator|(
name|s
operator|-
literal|1
operator|)
operator|)
operator|<<
name|ASHIFT
operator|)
operator|+
name|ABASE
decl_stmt|;
if|if
condition|(
name|U
operator|.
name|getObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|)
operator|==
name|t
operator|&&
name|U
operator|.
name|compareAndSwapInt
argument_list|(
name|q
argument_list|,
name|QLOCK
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|array
operator|==
name|a
operator|&&
name|q
operator|.
name|top
operator|==
name|s
operator|&&
name|U
operator|.
name|compareAndSwapObject
argument_list|(
name|a
argument_list|,
name|j
argument_list|,
name|t
argument_list|,
literal|null
argument_list|)
condition|)
block|{
name|q
operator|.
name|top
operator|=
name|s
operator|-
literal|1
expr_stmt|;
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
block|}
else|else
name|q
operator|.
name|qlock
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|.
name|status
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|t
operator|instanceof
name|CountedCompleter
condition|)
name|p
operator|.
name|externalHelpComplete
argument_list|(
name|q
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|p
operator|.
name|helpSignal
argument_list|(
name|t
argument_list|,
name|q
operator|.
name|poolIndex
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Exported methods
comment|// Constructors
comment|/**      * Creates a {@code ForkJoinPool} with parallelism equal to {@link      * java.lang.Runtime#availableProcessors}, using the {@linkplain      * #defaultForkJoinWorkerThreadFactory default thread factory},      * no UncaughtExceptionHandler, and non-async LIFO processing mode.      *      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|()
block|{
name|this
argument_list|(
name|Math
operator|.
name|min
argument_list|(
name|MAX_CAP
argument_list|,
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
argument_list|)
argument_list|,
name|defaultForkJoinWorkerThreadFactory
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@code ForkJoinPool} with the indicated parallelism      * level, the {@linkplain      * #defaultForkJoinWorkerThreadFactory default thread factory},      * no UncaughtExceptionHandler, and non-async LIFO processing mode.      *      * @param parallelism the parallelism level      * @throws IllegalArgumentException if parallelism less than or      *         equal to zero, or greater than implementation limit      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|(
name|int
name|parallelism
parameter_list|)
block|{
name|this
argument_list|(
name|parallelism
argument_list|,
name|defaultForkJoinWorkerThreadFactory
argument_list|,
literal|null
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a {@code ForkJoinPool} with the given parameters.      *      * @param parallelism the parallelism level. For default value,      * use {@link java.lang.Runtime#availableProcessors}.      * @param factory the factory for creating new threads. For default value,      * use {@link #defaultForkJoinWorkerThreadFactory}.      * @param handler the handler for internal worker threads that      * terminate due to unrecoverable errors encountered while executing      * tasks. For default value, use {@code null}.      * @param asyncMode if true,      * establishes local first-in-first-out scheduling mode for forked      * tasks that are never joined. This mode may be more appropriate      * than default locally stack-based mode in applications in which      * worker threads only process event-style asynchronous tasks.      * For default value, use {@code false}.      * @throws IllegalArgumentException if parallelism less than or      *         equal to zero, or greater than implementation limit      * @throws NullPointerException if the factory is null      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|ForkJoinPool
specifier|public
name|ForkJoinPool
parameter_list|(
name|int
name|parallelism
parameter_list|,
name|ForkJoinWorkerThreadFactory
name|factory
parameter_list|,
name|Thread
operator|.
name|UncaughtExceptionHandler
name|handler
parameter_list|,
name|boolean
name|asyncMode
parameter_list|)
block|{
name|checkPermission
argument_list|()
expr_stmt|;
if|if
condition|(
name|factory
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
if|if
condition|(
name|parallelism
operator|<=
literal|0
operator|||
name|parallelism
operator|>
name|MAX_CAP
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|ueh
operator|=
name|handler
expr_stmt|;
name|this
operator|.
name|config
operator|=
name|parallelism
operator||
operator|(
name|asyncMode
condition|?
operator|(
name|FIFO_QUEUE
operator|<<
literal|16
operator|)
else|:
literal|0
operator|)
expr_stmt|;
name|long
name|np
init|=
call|(
name|long
call|)
argument_list|(
operator|-
name|parallelism
argument_list|)
decl_stmt|;
comment|// offset ctl counts
name|this
operator|.
name|ctl
operator|=
operator|(
operator|(
name|np
operator|<<
name|AC_SHIFT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
operator|(
name|np
operator|<<
name|TC_SHIFT
operator|)
operator|&
name|TC_MASK
operator|)
expr_stmt|;
name|int
name|pn
init|=
name|nextPoolId
argument_list|()
decl_stmt|;
name|StringBuilder
name|sb
init|=
operator|new
name|StringBuilder
argument_list|(
literal|"ForkJoinPool-"
argument_list|)
decl_stmt|;
name|sb
operator|.
name|append
argument_list|(
name|Integer
operator|.
name|toString
argument_list|(
name|pn
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|append
argument_list|(
literal|"-worker-"
argument_list|)
expr_stmt|;
name|this
operator|.
name|workerNamePrefix
operator|=
name|sb
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
comment|/**      * Constructor for common pool, suitable only for static initialization.      * Basically the same as above, but uses smallest possible initial footprint.      */
DECL|method|ForkJoinPool
name|ForkJoinPool
parameter_list|(
name|int
name|parallelism
parameter_list|,
name|long
name|ctl
parameter_list|,
name|ForkJoinWorkerThreadFactory
name|factory
parameter_list|,
name|Thread
operator|.
name|UncaughtExceptionHandler
name|handler
parameter_list|)
block|{
name|this
operator|.
name|config
operator|=
name|parallelism
expr_stmt|;
name|this
operator|.
name|ctl
operator|=
name|ctl
expr_stmt|;
name|this
operator|.
name|factory
operator|=
name|factory
expr_stmt|;
name|this
operator|.
name|ueh
operator|=
name|handler
expr_stmt|;
name|this
operator|.
name|workerNamePrefix
operator|=
literal|"ForkJoinPool.commonPool-worker-"
expr_stmt|;
block|}
comment|/**      * Returns the common pool instance. This pool is statically      * constructed; its run state is unaffected by attempts to {@link      * #shutdown} or {@link #shutdownNow}. However this pool and any      * ongoing processing are automatically terminated upon program      * {@link System#exit}.  Any program that relies on asynchronous      * task processing to complete before program termination should      * invoke {@code commonPool().}{@link #awaitQuiescence}, before      * exit.      *      * @return the common pool instance      * @since 1.8      */
DECL|method|commonPool
specifier|public
specifier|static
name|ForkJoinPool
name|commonPool
parameter_list|()
block|{
comment|// assert common != null : "static init error";
return|return
name|common
return|;
block|}
comment|// Execution methods
comment|/**      * Performs the given task, returning its result upon completion.      * If the computation encounters an unchecked Exception or Error,      * it is rethrown as the outcome of this invocation.  Rethrown      * exceptions behave in the same way as regular exceptions, but,      * when possible, contain stack traces (as displayed for example      * using {@code ex.printStackTrace()}) of both the current thread      * as well as the thread actually encountering the exception;      * minimally only the latter.      *      * @param task the task      * @return the task's result      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|invoke
specifier|public
parameter_list|<
name|T
parameter_list|>
name|T
name|invoke
parameter_list|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|externalPush
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
operator|.
name|join
argument_list|()
return|;
block|}
comment|/**      * Arranges for (asynchronous) execution of the given task.      *      * @param task the task      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|externalPush
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
comment|// AbstractExecutorService methods
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|execute
specifier|public
name|void
name|execute
parameter_list|(
name|Runnable
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|job
decl_stmt|;
if|if
condition|(
name|task
operator|instanceof
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
condition|)
comment|// avoid re-wrap
condition|job = (ForkJoinTask<?>
condition|)
name|task
expr_stmt|;
else|else
name|job
operator|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnableAction
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|externalPush
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
comment|/**      * Submits a ForkJoinTask for execution.      *      * @param task the task to submit      * @return the task      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|externalPush
argument_list|(
name|task
argument_list|)
expr_stmt|;
return|return
name|task
return|;
block|}
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|task
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|job
init|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedCallable
argument_list|<>
argument_list|(
name|task
argument_list|)
decl_stmt|;
name|externalPush
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
parameter_list|<
name|T
parameter_list|>
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|submit
parameter_list|(
name|Runnable
name|task
parameter_list|,
name|T
name|result
parameter_list|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|job
init|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnable
argument_list|<>
argument_list|(
name|task
argument_list|,
name|result
argument_list|)
decl_stmt|;
name|externalPush
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException if the task is null      * @throws RejectedExecutionException if the task cannot be      *         scheduled for execution      */
DECL|method|submit
specifier|public
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|submit
parameter_list|(
name|Runnable
name|task
parameter_list|)
block|{
if|if
condition|(
name|task
operator|==
literal|null
condition|)
throw|throw
operator|new
name|NullPointerException
argument_list|()
throw|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|job
decl_stmt|;
if|if
condition|(
name|task
operator|instanceof
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
condition|)
comment|// avoid re-wrap
condition|job = (ForkJoinTask<?>
condition|)
name|task
expr_stmt|;
else|else
name|job
operator|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnableAction
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|externalPush
argument_list|(
name|job
argument_list|)
expr_stmt|;
return|return
name|job
return|;
block|}
comment|/**      * @throws NullPointerException       {@inheritDoc}      * @throws RejectedExecutionException {@inheritDoc}      */
DECL|method|invokeAll
specifier|public
parameter_list|<
name|T
parameter_list|>
name|List
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|invokeAll
parameter_list|(
name|Collection
argument_list|<
name|?
extends|extends
name|Callable
argument_list|<
name|T
argument_list|>
argument_list|>
name|tasks
parameter_list|)
block|{
comment|// In previous versions of this class, this method constructed
comment|// a task to run ForkJoinTask.invokeAll, but now external
comment|// invocation of multiple tasks is at least as efficient.
name|ArrayList
argument_list|<
name|Future
argument_list|<
name|T
argument_list|>
argument_list|>
name|futures
init|=
operator|new
name|ArrayList
argument_list|<>
argument_list|(
name|tasks
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|boolean
name|done
init|=
literal|false
decl_stmt|;
try|try
block|{
for|for
control|(
name|Callable
argument_list|<
name|T
argument_list|>
name|t
range|:
name|tasks
control|)
block|{
name|ForkJoinTask
argument_list|<
name|T
argument_list|>
name|f
init|=
operator|new
name|ForkJoinTask
operator|.
name|AdaptedCallable
argument_list|<>
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|futures
operator|.
name|add
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|externalPush
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|size
init|=
name|futures
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
operator|)
name|futures
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|)
operator|.
name|quietlyJoin
argument_list|()
expr_stmt|;
name|done
operator|=
literal|true
expr_stmt|;
return|return
name|futures
return|;
block|}
finally|finally
block|{
if|if
condition|(
operator|!
name|done
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|size
init|=
name|futures
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|futures
operator|.
name|get
argument_list|(
name|i
argument_list|)
operator|.
name|cancel
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * Returns the factory used for constructing new workers.      *      * @return the factory used for constructing new workers      */
DECL|method|getFactory
specifier|public
name|ForkJoinWorkerThreadFactory
name|getFactory
parameter_list|()
block|{
return|return
name|factory
return|;
block|}
comment|/**      * Returns the handler for internal worker threads that terminate      * due to unrecoverable errors encountered while executing tasks.      *      * @return the handler, or {@code null} if none      */
DECL|method|getUncaughtExceptionHandler
specifier|public
name|Thread
operator|.
name|UncaughtExceptionHandler
name|getUncaughtExceptionHandler
parameter_list|()
block|{
return|return
name|ueh
return|;
block|}
comment|/**      * Returns the targeted parallelism level of this pool.      *      * @return the targeted parallelism level of this pool      */
DECL|method|getParallelism
specifier|public
name|int
name|getParallelism
parameter_list|()
block|{
return|return
name|config
operator|&
name|SMASK
return|;
block|}
comment|/**      * Returns the targeted parallelism level of the common pool.      *      * @return the targeted parallelism level of the common pool      * @since 1.8      */
DECL|method|getCommonPoolParallelism
specifier|public
specifier|static
name|int
name|getCommonPoolParallelism
parameter_list|()
block|{
return|return
name|commonParallelism
return|;
block|}
comment|/**      * Returns the number of worker threads that have started but not      * yet terminated.  The result returned by this method may differ      * from {@link #getParallelism} when threads are created to      * maintain parallelism when others are cooperatively blocked.      *      * @return the number of worker threads      */
DECL|method|getPoolSize
specifier|public
name|int
name|getPoolSize
parameter_list|()
block|{
return|return
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|+
call|(
name|short
call|)
argument_list|(
name|ctl
operator|>>>
name|TC_SHIFT
argument_list|)
return|;
block|}
comment|/**      * Returns {@code true} if this pool uses local first-in-first-out      * scheduling mode for forked tasks that are never joined.      *      * @return {@code true} if this pool uses async mode      */
DECL|method|getAsyncMode
specifier|public
name|boolean
name|getAsyncMode
parameter_list|()
block|{
return|return
operator|(
name|config
operator|>>>
literal|16
operator|)
operator|==
name|FIFO_QUEUE
return|;
block|}
comment|/**      * Returns an estimate of the number of worker threads that are      * not blocked waiting to join tasks or for other managed      * synchronization. This method may overestimate the      * number of running threads.      *      * @return the number of worker threads      */
DECL|method|getRunningThreadCount
specifier|public
name|int
name|getRunningThreadCount
parameter_list|()
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
name|w
operator|.
name|isApparentlyUnblocked
argument_list|()
condition|)
operator|++
name|rc
expr_stmt|;
block|}
block|}
return|return
name|rc
return|;
block|}
comment|/**      * Returns an estimate of the number of threads that are currently      * stealing or executing tasks. This method may overestimate the      * number of active threads.      *      * @return the number of active threads      */
DECL|method|getActiveThreadCount
specifier|public
name|int
name|getActiveThreadCount
parameter_list|()
block|{
name|int
name|r
init|=
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|+
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>
name|AC_SHIFT
argument_list|)
decl_stmt|;
return|return
operator|(
name|r
operator|<=
literal|0
operator|)
condition|?
literal|0
else|:
name|r
return|;
comment|// suppress momentarily negative values
block|}
comment|/**      * Returns {@code true} if all worker threads are currently idle.      * An idle worker is one that cannot obtain a task to execute      * because none are available to steal from other threads, and      * there are no pending submissions to the pool. This method is      * conservative; it might not return {@code true} immediately upon      * idleness of all threads, but will eventually become true if      * threads remain inactive.      *      * @return {@code true} if all threads are currently idle      */
DECL|method|isQuiescent
specifier|public
name|boolean
name|isQuiescent
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|ctl
operator|>>
name|AC_SHIFT
argument_list|)
operator|+
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|==
literal|0
return|;
block|}
comment|/**      * Returns an estimate of the total number of tasks stolen from      * one thread's work queue by another. The reported value      * underestimates the actual total number of steals when the pool      * is not quiescent. This value may be useful for monitoring and      * tuning fork/join programs: in general, steal counts should be      * high enough to keep threads busy, but low enough to avoid      * overhead and contention across threads.      *      * @return the number of steals      */
DECL|method|getStealCount
specifier|public
name|long
name|getStealCount
parameter_list|()
block|{
name|long
name|count
init|=
name|stealCount
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|count
operator|+=
name|w
operator|.
name|nsteals
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns an estimate of the total number of tasks currently held      * in queues by worker threads (but not including tasks submitted      * to the pool that have not begun executing). This value is only      * an approximation, obtained by iterating across all threads in      * the pool. This method may be useful for tuning task      * granularities.      *      * @return the number of queued tasks      */
DECL|method|getQueuedTaskCount
specifier|public
name|long
name|getQueuedTaskCount
parameter_list|()
block|{
name|long
name|count
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|count
operator|+=
name|w
operator|.
name|queueSize
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns an estimate of the number of tasks submitted to this      * pool that have not yet begun executing.  This method may take      * time proportional to the number of submissions.      *      * @return the number of queued submissions      */
DECL|method|getQueuedSubmissionCount
specifier|public
name|int
name|getQueuedSubmissionCount
parameter_list|()
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
name|count
operator|+=
name|w
operator|.
name|queueSize
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns {@code true} if there are any tasks submitted to this      * pool that have not yet begun executing.      *      * @return {@code true} if there are any queued submissions      */
DECL|method|hasQueuedSubmissions
specifier|public
name|boolean
name|hasQueuedSubmissions
parameter_list|()
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|!
name|w
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
comment|/**      * Removes and returns the next unexecuted submission if one is      * available.  This method may be useful in extensions to this      * class that re-assign work in systems with multiple pools.      *      * @return the next submission, or {@code null} if none      */
DECL|method|pollSubmission
specifier|protected
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|pollSubmission
parameter_list|()
block|{
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|t
operator|=
name|w
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
return|return
name|t
return|;
block|}
block|}
return|return
literal|null
return|;
block|}
comment|/**      * Removes all available unexecuted submitted and forked tasks      * from scheduling queues and adds them to the given collection,      * without altering their execution status. These may include      * artificially generated or wrapped tasks. This method is      * designed to be invoked only when the pool is known to be      * quiescent. Invocations at other times may not remove all      * tasks. A failure encountered while attempting to add elements      * to collection {@code c} may result in elements being in      * neither, either or both collections when the associated      * exception is thrown.  The behavior of this operation is      * undefined if the specified collection is modified while the      * operation is in progress.      *      * @param c the collection to transfer elements into      * @return the number of elements transferred      */
DECL|method|drainTasksTo
specifier|protected
name|int
name|drainTasksTo
parameter_list|(
name|Collection
argument_list|<
name|?
super|super
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
argument_list|>
name|c
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
while|while
condition|(
operator|(
name|t
operator|=
name|w
operator|.
name|poll
argument_list|()
operator|)
operator|!=
literal|null
condition|)
block|{
name|c
operator|.
name|add
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|count
return|;
block|}
comment|/**      * Returns a string identifying this pool, as well as its state,      * including indications of run state, parallelism level, and      * worker and task counts.      *      * @return a string identifying this pool, as well as its state      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
comment|// Use a single pass through workQueues to collect counts
name|long
name|qt
init|=
literal|0L
decl_stmt|,
name|qs
init|=
literal|0L
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|long
name|st
init|=
name|stealCount
decl_stmt|;
name|long
name|c
init|=
name|ctl
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|w
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ws
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
condition|)
block|{
name|int
name|size
init|=
name|w
operator|.
name|queueSize
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|qs
operator|+=
name|size
expr_stmt|;
else|else
block|{
name|qt
operator|+=
name|size
expr_stmt|;
name|st
operator|+=
name|w
operator|.
name|nsteals
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|isApparentlyUnblocked
argument_list|()
condition|)
operator|++
name|rc
expr_stmt|;
block|}
block|}
block|}
block|}
name|int
name|pc
init|=
operator|(
name|config
operator|&
name|SMASK
operator|)
decl_stmt|;
name|int
name|tc
init|=
name|pc
operator|+
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
decl_stmt|;
name|int
name|ac
init|=
name|pc
operator|+
call|(
name|int
call|)
argument_list|(
name|c
operator|>>
name|AC_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|ac
operator|<
literal|0
condition|)
comment|// ignore transient negative
name|ac
operator|=
literal|0
expr_stmt|;
name|String
name|level
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0
condition|)
name|level
operator|=
operator|(
name|tc
operator|==
literal|0
operator|)
condition|?
literal|"Terminated"
else|:
literal|"Terminating"
expr_stmt|;
else|else
name|level
operator|=
name|plock
operator|<
literal|0
condition|?
literal|"Shutting down"
else|:
literal|"Running"
expr_stmt|;
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"["
operator|+
name|level
operator|+
literal|", parallelism = "
operator|+
name|pc
operator|+
literal|", size = "
operator|+
name|tc
operator|+
literal|", active = "
operator|+
name|ac
operator|+
literal|", running = "
operator|+
name|rc
operator|+
literal|", steals = "
operator|+
name|st
operator|+
literal|", tasks = "
operator|+
name|qt
operator|+
literal|", submissions = "
operator|+
name|qs
operator|+
literal|"]"
return|;
block|}
comment|/**      * Possibly initiates an orderly shutdown in which previously      * submitted tasks are executed, but no new tasks will be      * accepted. Invocation has no effect on execution state if this      * is the {@link #commonPool()}, and no additional effect if      * already shut down.  Tasks that are in the process of being      * submitted concurrently during the course of this method may or      * may not be rejected.      *      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|shutdown
specifier|public
name|void
name|shutdown
parameter_list|()
block|{
name|checkPermission
argument_list|()
expr_stmt|;
name|tryTerminate
argument_list|(
literal|false
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
comment|/**      * Possibly attempts to cancel and/or stop all tasks, and reject      * all subsequently submitted tasks.  Invocation has no effect on      * execution state if this is the {@link #commonPool()}, and no      * additional effect if already shut down. Otherwise, tasks that      * are in the process of being submitted or executed concurrently      * during the course of this method may or may not be      * rejected. This method cancels both existing and unexecuted      * tasks, in order to permit termination in the presence of task      * dependencies. So the method always returns an empty list      * (unlike the case for some other Executors).      *      * @return an empty list      * @throws SecurityException if a security manager exists and      *         the caller is not permitted to modify threads      *         because it does not hold {@link      *         java.lang.RuntimePermission}{@code ("modifyThread")}      */
DECL|method|shutdownNow
specifier|public
name|List
argument_list|<
name|Runnable
argument_list|>
name|shutdownNow
parameter_list|()
block|{
name|checkPermission
argument_list|()
expr_stmt|;
name|tryTerminate
argument_list|(
literal|true
argument_list|,
literal|true
argument_list|)
expr_stmt|;
return|return
name|Collections
operator|.
name|emptyList
argument_list|()
return|;
block|}
comment|/**      * Returns {@code true} if all tasks have completed following shut down.      *      * @return {@code true} if all tasks have completed following shut down      */
DECL|method|isTerminated
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
name|long
name|c
init|=
name|ctl
decl_stmt|;
return|return
operator|(
operator|(
name|c
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0L
operator|&&
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
operator|==
operator|-
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|)
return|;
block|}
comment|/**      * Returns {@code true} if the process of termination has      * commenced but not yet completed.  This method may be useful for      * debugging. A return of {@code true} reported a sufficient      * period after shutdown may indicate that submitted tasks have      * ignored or suppressed interruption, or are waiting for I/O,      * causing this executor not to properly terminate. (See the      * advisory notes for class {@link ForkJoinTask} stating that      * tasks should not normally entail blocking operations.  But if      * they do, they must abort them on interrupt.)      *      * @return {@code true} if terminating but not yet terminated      */
DECL|method|isTerminating
specifier|public
name|boolean
name|isTerminating
parameter_list|()
block|{
name|long
name|c
init|=
name|ctl
decl_stmt|;
return|return
operator|(
operator|(
name|c
operator|&
name|STOP_BIT
operator|)
operator|!=
literal|0L
operator|&&
call|(
name|short
call|)
argument_list|(
name|c
operator|>>>
name|TC_SHIFT
argument_list|)
operator|!=
operator|-
operator|(
name|config
operator|&
name|SMASK
operator|)
operator|)
return|;
block|}
comment|/**      * Returns {@code true} if this pool has been shut down.      *      * @return {@code true} if this pool has been shut down      */
DECL|method|isShutdown
specifier|public
name|boolean
name|isShutdown
parameter_list|()
block|{
return|return
name|plock
operator|<
literal|0
return|;
block|}
comment|/**      * Blocks until all tasks have completed execution after a      * shutdown request, or the timeout occurs, or the current thread      * is interrupted, whichever happens first. Because the {@link      * #commonPool()} never terminates until program shutdown, when      * applied to the common pool, this method is equivalent to {@link      * #awaitQuiescence} but always returns {@code false}.      *      * @param timeout the maximum time to wait      * @param unit the time unit of the timeout argument      * @return {@code true} if this executor terminated and      *         {@code false} if the timeout elapsed before termination      * @throws InterruptedException if interrupted while waiting      */
DECL|method|awaitTermination
specifier|public
name|boolean
name|awaitTermination
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
block|{
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
if|if
condition|(
name|this
operator|==
name|common
condition|)
block|{
name|awaitQuiescence
argument_list|(
name|timeout
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|isTerminated
argument_list|()
condition|)
return|return
literal|true
return|;
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|boolean
name|terminated
init|=
literal|false
decl_stmt|;
synchronized|synchronized
init|(
name|this
init|)
block|{
for|for
control|(
name|long
name|waitTime
init|=
name|nanos
init|,
name|millis
init|=
literal|0L
init|;
condition|;
control|)
block|{
if|if
condition|(
name|terminated
operator|=
name|isTerminated
argument_list|()
operator|||
name|waitTime
operator|<=
literal|0L
operator|||
operator|(
name|millis
operator|=
name|unit
operator|.
name|toMillis
argument_list|(
name|waitTime
argument_list|)
operator|)
operator|<=
literal|0L
condition|)
break|break;
name|wait
argument_list|(
name|millis
argument_list|)
expr_stmt|;
name|waitTime
operator|=
name|nanos
operator|-
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
expr_stmt|;
block|}
block|}
return|return
name|terminated
return|;
block|}
comment|/**      * If called by a ForkJoinTask operating in this pool, equivalent      * in effect to {@link ForkJoinTask#helpQuiesce}. Otherwise,      * waits and/or attempts to assist performing tasks until this      * pool {@link #isQuiescent} or the indicated timeout elapses.      *      * @param timeout the maximum time to wait      * @param unit the time unit of the timeout argument      * @return {@code true} if quiescent; {@code false} if the      * timeout elapsed.      */
DECL|method|awaitQuiescence
specifier|public
name|boolean
name|awaitQuiescence
parameter_list|(
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
name|ForkJoinWorkerThread
name|wt
decl_stmt|;
name|Thread
name|thread
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|thread
operator|instanceof
name|ForkJoinWorkerThread
operator|)
operator|&&
operator|(
name|wt
operator|=
operator|(
name|ForkJoinWorkerThread
operator|)
name|thread
operator|)
operator|.
name|pool
operator|==
name|this
condition|)
block|{
name|helpQuiescePool
argument_list|(
name|wt
operator|.
name|workQueue
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|long
name|startTime
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|;
name|boolean
name|found
init|=
literal|true
decl_stmt|;
while|while
condition|(
operator|!
name|isQuiescent
argument_list|()
operator|&&
operator|(
name|ws
operator|=
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|found
condition|)
block|{
if|if
condition|(
operator|(
name|System
operator|.
name|nanoTime
argument_list|()
operator|-
name|startTime
operator|)
operator|>
name|nanos
condition|)
return|return
literal|false
return|;
name|Thread
operator|.
name|yield
argument_list|()
expr_stmt|;
comment|// cannot block
block|}
name|found
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
operator|(
name|m
operator|+
literal|1
operator|)
operator|<<
literal|2
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|ForkJoinTask
argument_list|<
name|?
argument_list|>
name|t
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|int
name|b
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
name|r
operator|++
operator|&
name|m
index|]
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|b
operator|=
name|q
operator|.
name|base
operator|)
operator|-
name|q
operator|.
name|top
operator|<
literal|0
condition|)
block|{
name|found
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|q
operator|.
name|pollAt
argument_list|(
name|b
argument_list|)
operator|)
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|q
operator|.
name|base
operator|-
name|q
operator|.
name|top
operator|<
literal|0
condition|)
name|signalWork
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|t
operator|.
name|doExec
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Waits and/or attempts to assist performing tasks indefinitely      * until the {@link #commonPool()} {@link #isQuiescent}.      */
DECL|method|quiesceCommonPool
specifier|static
name|void
name|quiesceCommonPool
parameter_list|()
block|{
name|common
operator|.
name|awaitQuiescence
argument_list|(
name|Long
operator|.
name|MAX_VALUE
argument_list|,
name|TimeUnit
operator|.
name|NANOSECONDS
argument_list|)
expr_stmt|;
block|}
comment|/**      * Interface for extending managed parallelism for tasks running      * in {@link ForkJoinPool}s.      *      *<p>A {@code ManagedBlocker} provides two methods.  Method      * {@code isReleasable} must return {@code true} if blocking is      * not necessary. Method {@code block} blocks the current thread      * if necessary (perhaps internally invoking {@code isReleasable}      * before actually blocking). These actions are performed by any      * thread invoking {@link ForkJoinPool#managedBlock}.  The      * unusual methods in this API accommodate synchronizers that may,      * but don't usually, block for long periods. Similarly, they      * allow more efficient internal handling of cases in which      * additional workers may be, but usually are not, needed to      * ensure sufficient parallelism.  Toward this end,      * implementations of method {@code isReleasable} must be amenable      * to repeated invocation.      *      *<p>For example, here is a ManagedBlocker based on a      * ReentrantLock:      *<pre> {@code      * class ManagedLocker implements ManagedBlocker {      *   final ReentrantLock lock;      *   boolean hasLock = false;      *   ManagedLocker(ReentrantLock lock) { this.lock = lock; }      *   public boolean block() {      *     if (!hasLock)      *       lock.lock();      *     return true;      *   }      *   public boolean isReleasable() {      *     return hasLock || (hasLock = lock.tryLock());      *   }      * }}</pre>      *      *<p>Here is a class that possibly blocks waiting for an      * item on a given queue:      *<pre> {@code      * class QueueTaker<E> implements ManagedBlocker {      *   final BlockingQueue<E> queue;      *   volatile E item = null;      *   QueueTaker(BlockingQueue<E> q) { this.queue = q; }      *   public boolean block() throws InterruptedException {      *     if (item == null)      *       item = queue.take();      *     return true;      *   }      *   public boolean isReleasable() {      *     return item != null || (item = queue.poll()) != null;      *   }      *   public E getItem() { // call after pool.managedBlock completes      *     return item;      *   }      * }}</pre>      */
DECL|interface|ManagedBlocker
specifier|public
specifier|static
interface|interface
name|ManagedBlocker
block|{
comment|/**          * Possibly blocks the current thread, for example waiting for          * a lock or condition.          *          * @return {@code true} if no additional blocking is necessary          * (i.e., if isReleasable would return true)          * @throws InterruptedException if interrupted while waiting          * (the method is not required to do so, but is allowed to)          */
DECL|method|block
name|boolean
name|block
parameter_list|()
throws|throws
name|InterruptedException
function_decl|;
comment|/**          * Returns {@code true} if blocking is unnecessary.          */
DECL|method|isReleasable
name|boolean
name|isReleasable
parameter_list|()
function_decl|;
block|}
comment|/**      * Blocks in accord with the given blocker.  If the current thread      * is a {@link ForkJoinWorkerThread}, this method possibly      * arranges for a spare thread to be activated if necessary to      * ensure sufficient parallelism while the current thread is blocked.      *      *<p>If the caller is not a {@link ForkJoinTask}, this method is      * behaviorally equivalent to      *<pre> {@code      * while (!blocker.isReleasable())      *   if (blocker.block())      *     return;      * }</pre>      *      * If the caller is a {@code ForkJoinTask}, then the pool may      * first be expanded to ensure parallelism, and later adjusted.      *      * @param blocker the blocker      * @throws InterruptedException if blocker.block did so      */
DECL|method|managedBlock
specifier|public
specifier|static
name|void
name|managedBlock
parameter_list|(
name|ManagedBlocker
name|blocker
parameter_list|)
throws|throws
name|InterruptedException
block|{
name|Thread
name|t
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
decl_stmt|;
if|if
condition|(
name|t
operator|instanceof
name|ForkJoinWorkerThread
condition|)
block|{
name|ForkJoinPool
name|p
init|=
operator|(
operator|(
name|ForkJoinWorkerThread
operator|)
name|t
operator|)
operator|.
name|pool
decl_stmt|;
while|while
condition|(
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
condition|)
block|{
comment|// variant of helpSignal
name|WorkQueue
index|[]
name|ws
decl_stmt|;
name|WorkQueue
name|q
decl_stmt|;
name|int
name|m
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
operator|(
name|ws
operator|=
name|p
operator|.
name|workQueues
operator|)
operator|!=
literal|null
operator|&&
operator|(
name|m
operator|=
name|ws
operator|.
name|length
operator|-
literal|1
operator|)
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|m
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|blocker
operator|.
name|isReleasable
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|(
name|q
operator|=
name|ws
index|[
name|i
index|]
operator|)
operator|!=
literal|null
operator|&&
name|q
operator|.
name|base
operator|-
name|q
operator|.
name|top
operator|<
literal|0
condition|)
block|{
name|p
operator|.
name|signalWork
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u
operator|=
call|(
name|int
call|)
argument_list|(
name|p
operator|.
name|ctl
operator|>>>
literal|32
argument_list|)
operator|)
operator|>=
literal|0
operator|||
operator|(
name|u
operator|>>
name|UAC_SHIFT
operator|)
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|p
operator|.
name|tryCompensate
argument_list|()
condition|)
block|{
try|try
block|{
do|do
block|{}
do|while
condition|(
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
operator|&&
operator|!
name|blocker
operator|.
name|block
argument_list|()
condition|)
do|;
block|}
finally|finally
block|{
name|p
operator|.
name|incrementActiveCount
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
else|else
block|{
do|do
block|{}
do|while
condition|(
operator|!
name|blocker
operator|.
name|isReleasable
argument_list|()
operator|&&
operator|!
name|blocker
operator|.
name|block
argument_list|()
condition|)
do|;
block|}
block|}
comment|// AbstractExecutorService overrides.  These rely on undocumented
comment|// fact that ForkJoinTask.adapt returns ForkJoinTasks that also
comment|// implement RunnableFuture.
DECL|method|newTaskFor
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|RunnableFuture
argument_list|<
name|T
argument_list|>
name|newTaskFor
parameter_list|(
name|Runnable
name|runnable
parameter_list|,
name|T
name|value
parameter_list|)
block|{
return|return
operator|new
name|ForkJoinTask
operator|.
name|AdaptedRunnable
argument_list|<>
argument_list|(
name|runnable
argument_list|,
name|value
argument_list|)
return|;
block|}
DECL|method|newTaskFor
specifier|protected
parameter_list|<
name|T
parameter_list|>
name|RunnableFuture
argument_list|<
name|T
argument_list|>
name|newTaskFor
parameter_list|(
name|Callable
argument_list|<
name|T
argument_list|>
name|callable
parameter_list|)
block|{
return|return
operator|new
name|ForkJoinTask
operator|.
name|AdaptedCallable
argument_list|<>
argument_list|(
name|callable
argument_list|)
return|;
block|}
comment|// Unsafe mechanics
DECL|field|U
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|U
decl_stmt|;
DECL|field|CTL
specifier|private
specifier|static
specifier|final
name|long
name|CTL
decl_stmt|;
DECL|field|PARKBLOCKER
specifier|private
specifier|static
specifier|final
name|long
name|PARKBLOCKER
decl_stmt|;
DECL|field|ABASE
specifier|private
specifier|static
specifier|final
name|int
name|ABASE
decl_stmt|;
DECL|field|ASHIFT
specifier|private
specifier|static
specifier|final
name|int
name|ASHIFT
decl_stmt|;
DECL|field|STEALCOUNT
specifier|private
specifier|static
specifier|final
name|long
name|STEALCOUNT
decl_stmt|;
DECL|field|PLOCK
specifier|private
specifier|static
specifier|final
name|long
name|PLOCK
decl_stmt|;
DECL|field|INDEXSEED
specifier|private
specifier|static
specifier|final
name|long
name|INDEXSEED
decl_stmt|;
DECL|field|QLOCK
specifier|private
specifier|static
specifier|final
name|long
name|QLOCK
decl_stmt|;
static|static
block|{
comment|// initialize field offsets for CAS etc
try|try
block|{
name|U
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|ForkJoinPool
operator|.
name|class
decl_stmt|;
name|CTL
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"ctl"
argument_list|)
argument_list|)
expr_stmt|;
name|STEALCOUNT
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"stealCount"
argument_list|)
argument_list|)
expr_stmt|;
name|PLOCK
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"plock"
argument_list|)
argument_list|)
expr_stmt|;
name|INDEXSEED
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"indexSeed"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|tk
init|=
name|Thread
operator|.
name|class
decl_stmt|;
name|PARKBLOCKER
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|tk
operator|.
name|getDeclaredField
argument_list|(
literal|"parkBlocker"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|wk
init|=
name|WorkQueue
operator|.
name|class
decl_stmt|;
name|QLOCK
operator|=
name|U
operator|.
name|objectFieldOffset
argument_list|(
name|wk
operator|.
name|getDeclaredField
argument_list|(
literal|"qlock"
argument_list|)
argument_list|)
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|ak
init|=
name|ForkJoinTask
index|[]
operator|.
name|class
decl_stmt|;
name|ABASE
operator|=
name|U
operator|.
name|arrayBaseOffset
argument_list|(
name|ak
argument_list|)
expr_stmt|;
name|int
name|scale
init|=
name|U
operator|.
name|arrayIndexScale
argument_list|(
name|ak
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|scale
operator|&
operator|(
name|scale
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|Error
argument_list|(
literal|"data type scale not a power of two"
argument_list|)
throw|;
name|ASHIFT
operator|=
literal|31
operator|-
name|Integer
operator|.
name|numberOfLeadingZeros
argument_list|(
name|scale
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
name|submitters
operator|=
operator|new
name|ThreadLocal
argument_list|<>
argument_list|()
expr_stmt|;
name|ForkJoinWorkerThreadFactory
name|fac
init|=
name|defaultForkJoinWorkerThreadFactory
operator|=
operator|new
name|DefaultForkJoinWorkerThreadFactory
argument_list|()
decl_stmt|;
name|modifyThreadPermission
operator|=
operator|new
name|RuntimePermission
argument_list|(
literal|"modifyThread"
argument_list|)
expr_stmt|;
comment|/*          * Establish common pool parameters.  For extra caution,          * computations to set up common pool state are here; the          * constructor just assigns these values to fields.          */
name|int
name|par
init|=
literal|0
decl_stmt|;
name|Thread
operator|.
name|UncaughtExceptionHandler
name|handler
init|=
literal|null
decl_stmt|;
try|try
block|{
comment|// TBD: limit or report ignored exceptions?
name|String
name|pp
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.util.concurrent.ForkJoinPool.common.parallelism"
argument_list|)
decl_stmt|;
name|String
name|hp
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.util.concurrent.ForkJoinPool.common.exceptionHandler"
argument_list|)
decl_stmt|;
name|String
name|fp
init|=
name|System
operator|.
name|getProperty
argument_list|(
literal|"java.util.concurrent.ForkJoinPool.common.threadFactory"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|!=
literal|null
condition|)
name|fac
operator|=
operator|(
operator|(
name|ForkJoinWorkerThreadFactory
operator|)
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|fp
argument_list|)
operator|.
name|newInstance
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
literal|null
condition|)
name|handler
operator|=
operator|(
operator|(
name|Thread
operator|.
name|UncaughtExceptionHandler
operator|)
name|ClassLoader
operator|.
name|getSystemClassLoader
argument_list|()
operator|.
name|loadClass
argument_list|(
name|hp
argument_list|)
operator|.
name|newInstance
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
literal|null
condition|)
name|par
operator|=
name|Integer
operator|.
name|parseInt
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|ignore
parameter_list|)
block|{         }
if|if
condition|(
name|par
operator|<=
literal|0
condition|)
name|par
operator|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
expr_stmt|;
if|if
condition|(
name|par
operator|>
name|MAX_CAP
condition|)
name|par
operator|=
name|MAX_CAP
expr_stmt|;
name|commonParallelism
operator|=
name|par
expr_stmt|;
name|long
name|np
init|=
call|(
name|long
call|)
argument_list|(
operator|-
name|par
argument_list|)
decl_stmt|;
comment|// precompute initial ctl value
name|long
name|ct
init|=
operator|(
operator|(
name|np
operator|<<
name|AC_SHIFT
operator|)
operator|&
name|AC_MASK
operator|)
operator||
operator|(
operator|(
name|np
operator|<<
name|TC_SHIFT
operator|)
operator|&
name|TC_MASK
operator|)
decl_stmt|;
name|common
operator|=
operator|new
name|ForkJoinPool
argument_list|(
name|par
argument_list|,
name|ct
argument_list|,
name|fac
argument_list|,
name|handler
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|tryReflectionInstead
parameter_list|)
block|{}
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|Class
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
name|k
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
decl_stmt|;
for|for
control|(
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
range|:
name|k
operator|.
name|getDeclaredFields
argument_list|()
control|)
block|{
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|Object
name|x
init|=
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|.
name|isInstance
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|k
operator|.
name|cast
argument_list|(
name|x
argument_list|)
return|;
block|}
throw|throw
operator|new
name|NoSuchFieldError
argument_list|(
literal|"the Unsafe"
argument_list|)
throw|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
end_class

end_unit

