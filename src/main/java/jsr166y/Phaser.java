begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Doug Lea with assistance from members of JCP JSR-166  * Expert Group and released to the public domain, as explained at  * http://creativecommons.org/publicdomain/zero/1.0/  */
end_comment

begin_package
DECL|package|jsr166y
package|package
name|jsr166y
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeUnit
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|TimeoutException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicReference
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|locks
operator|.
name|LockSupport
import|;
end_import

begin_comment
comment|/**  * A reusable synchronization barrier, similar in functionality to  * {@link java.util.concurrent.CyclicBarrier CyclicBarrier} and  * {@link java.util.concurrent.CountDownLatch CountDownLatch}  * but supporting more flexible usage.  *  *<p><b>Registration.</b> Unlike the case for other barriers, the  * number of parties<em>registered</em> to synchronize on a phaser  * may vary over time.  Tasks may be registered at any time (using  * methods {@link #register}, {@link #bulkRegister}, or forms of  * constructors establishing initial numbers of parties), and  * optionally deregistered upon any arrival (using {@link  * #arriveAndDeregister}).  As is the case with most basic  * synchronization constructs, registration and deregistration affect  * only internal counts; they do not establish any further internal  * bookkeeping, so tasks cannot query whether they are registered.  * (However, you can introduce such bookkeeping by subclassing this  * class.)  *  *<p><b>Synchronization.</b> Like a {@code CyclicBarrier}, a {@code  * Phaser} may be repeatedly awaited.  Method {@link  * #arriveAndAwaitAdvance} has effect analogous to {@link  * java.util.concurrent.CyclicBarrier#await CyclicBarrier.await}. Each  * generation of a phaser has an associated phase number. The phase  * number starts at zero, and advances when all parties arrive at the  * phaser, wrapping around to zero after reaching {@code  * Integer.MAX_VALUE}. The use of phase numbers enables independent  * control of actions upon arrival at a phaser and upon awaiting  * others, via two kinds of methods that may be invoked by any  * registered party:  *  *<ul>  *  *<li><b>Arrival.</b> Methods {@link #arrive} and  *       {@link #arriveAndDeregister} record arrival.  These methods  *       do not block, but return an associated<em>arrival phase  *       number</em>; that is, the phase number of the phaser to which  *       the arrival applied. When the final party for a given phase  *       arrives, an optional action is performed and the phase  *       advances.  These actions are performed by the party  *       triggering a phase advance, and are arranged by overriding  *       method {@link #onAdvance(int, int)}, which also controls  *       termination. Overriding this method is similar to, but more  *       flexible than, providing a barrier action to a {@code  *       CyclicBarrier}.  *  *<li><b>Waiting.</b> Method {@link #awaitAdvance} requires an  *       argument indicating an arrival phase number, and returns when  *       the phaser advances to (or is already at) a different phase.  *       Unlike similar constructions using {@code CyclicBarrier},  *       method {@code awaitAdvance} continues to wait even if the  *       waiting thread is interrupted. Interruptible and timeout  *       versions are also available, but exceptions encountered while  *       tasks wait interruptibly or with timeout do not change the  *       state of the phaser. If necessary, you can perform any  *       associated recovery within handlers of those exceptions,  *       often after invoking {@code forceTermination}.  Phasers may  *       also be used by tasks executing in a {@link ForkJoinPool},  *       which will ensure sufficient parallelism to execute tasks  *       when others are blocked waiting for a phase to advance.  *  *</ul>  *  *<p><b>Termination.</b> A phaser may enter a<em>termination</em>  * state, that may be checked using method {@link #isTerminated}. Upon  * termination, all synchronization methods immediately return without  * waiting for advance, as indicated by a negative return value.  * Similarly, attempts to register upon termination have no effect.  * Termination is triggered when an invocation of {@code onAdvance}  * returns {@code true}. The default implementation returns {@code  * true} if a deregistration has caused the number of registered  * parties to become zero.  As illustrated below, when phasers control  * actions with a fixed number of iterations, it is often convenient  * to override this method to cause termination when the current phase  * number reaches a threshold. Method {@link #forceTermination} is  * also available to abruptly release waiting threads and allow them  * to terminate.  *  *<p><b>Tiering.</b> Phasers may be<em>tiered</em> (i.e.,  * constructed in tree structures) to reduce contention. Phasers with  * large numbers of parties that would otherwise experience heavy  * synchronization contention costs may instead be set up so that  * groups of sub-phasers share a common parent.  This may greatly  * increase throughput even though it incurs greater per-operation  * overhead.  *  *<p>In a tree of tiered phasers, registration and deregistration of  * child phasers with their parent are managed automatically.  * Whenever the number of registered parties of a child phaser becomes  * non-zero (as established in the {@link #Phaser(Phaser,int)}  * constructor, {@link #register}, or {@link #bulkRegister}), the  * child phaser is registered with its parent.  Whenever the number of  * registered parties becomes zero as the result of an invocation of  * {@link #arriveAndDeregister}, the child phaser is deregistered  * from its parent.  *  *<p><b>Monitoring.</b> While synchronization methods may be invoked  * only by registered parties, the current state of a phaser may be  * monitored by any caller.  At any given moment there are {@link  * #getRegisteredParties} parties in total, of which {@link  * #getArrivedParties} have arrived at the current phase ({@link  * #getPhase}).  When the remaining ({@link #getUnarrivedParties})  * parties arrive, the phase advances.  The values returned by these  * methods may reflect transient states and so are not in general  * useful for synchronization control.  Method {@link #toString}  * returns snapshots of these state queries in a form convenient for  * informal monitoring.  *  *<p><b>Sample usages:</b>  *  *<p>A {@code Phaser} may be used instead of a {@code CountDownLatch}  * to control a one-shot action serving a variable number of parties.  * The typical idiom is for the method setting this up to first  * register, then start the actions, then deregister, as in:  *  *<pre> {@code  * void runTasks(List<Runnable> tasks) {  *   final Phaser phaser = new Phaser(1); // "1" to register self  *   // create and start threads  *   for (final Runnable task : tasks) {  *     phaser.register();  *     new Thread() {  *       public void run() {  *         phaser.arriveAndAwaitAdvance(); // await all creation  *         task.run();  *       }  *     }.start();  *   }  *  *   // allow threads to start and deregister self  *   phaser.arriveAndDeregister();  * }}</pre>  *  *<p>One way to cause a set of threads to repeatedly perform actions  * for a given number of iterations is to override {@code onAdvance}:  *  *<pre> {@code  * void startTasks(List<Runnable> tasks, final int iterations) {  *   final Phaser phaser = new Phaser() {  *     protected boolean onAdvance(int phase, int registeredParties) {  *       return phase>= iterations || registeredParties == 0;  *     }  *   };  *   phaser.register();  *   for (final Runnable task : tasks) {  *     phaser.register();  *     new Thread() {  *       public void run() {  *         do {  *           task.run();  *           phaser.arriveAndAwaitAdvance();  *         } while (!phaser.isTerminated());  *       }  *     }.start();  *   }  *   phaser.arriveAndDeregister(); // deregister self, don't wait  * }}</pre>  *  * If the main task must later await termination, it  * may re-register and then execute a similar loop:  *<pre> {@code  *   // ...  *   phaser.register();  *   while (!phaser.isTerminated())  *     phaser.arriveAndAwaitAdvance();}</pre>  *  *<p>Related constructions may be used to await particular phase numbers  * in contexts where you are sure that the phase will never wrap around  * {@code Integer.MAX_VALUE}. For example:  *  *<pre> {@code  * void awaitPhase(Phaser phaser, int phase) {  *   int p = phaser.register(); // assumes caller not already registered  *   while (p< phase) {  *     if (phaser.isTerminated())  *       // ... deal with unexpected termination  *     else  *       p = phaser.arriveAndAwaitAdvance();  *   }  *   phaser.arriveAndDeregister();  * }}</pre>  *  *  *<p>To create a set of {@code n} tasks using a tree of phasers, you  * could use code of the following form, assuming a Task class with a  * constructor accepting a {@code Phaser} that it registers with upon  * construction. After invocation of {@code build(new Task[n], 0, n,  * new Phaser())}, these tasks could then be started, for example by  * submitting to a pool:  *  *<pre> {@code  * void build(Task[] tasks, int lo, int hi, Phaser ph) {  *   if (hi - lo> TASKS_PER_PHASER) {  *     for (int i = lo; i< hi; i += TASKS_PER_PHASER) {  *       int j = Math.min(i + TASKS_PER_PHASER, hi);  *       build(tasks, i, j, new Phaser(ph));  *     }  *   } else {  *     for (int i = lo; i< hi; ++i)  *       tasks[i] = new Task(ph);  *       // assumes new Task(ph) performs ph.register()  *   }  * }}</pre>  *  * The best value of {@code TASKS_PER_PHASER} depends mainly on  * expected synchronization rates. A value as low as four may  * be appropriate for extremely small per-phase task bodies (thus  * high rates), or up to hundreds for extremely large ones.  *  *<p><b>Implementation notes</b>: This implementation restricts the  * maximum number of parties to 65535. Attempts to register additional  * parties result in {@code IllegalStateException}. However, you can and  * should create tiered phasers to accommodate arbitrarily large sets  * of participants.  *  * @since 1.7  * @author Doug Lea  */
end_comment

begin_class
DECL|class|Phaser
specifier|public
class|class
name|Phaser
block|{
comment|/*      * This class implements an extension of X10 "clocks".  Thanks to      * Vijay Saraswat for the idea, and to Vivek Sarkar for      * enhancements to extend functionality.      */
comment|/**      * Primary state representation, holding four bit-fields:      *      * unarrived  -- the number of parties yet to hit barrier (bits  0-15)      * parties    -- the number of parties to wait            (bits 16-31)      * phase      -- the generation of the barrier            (bits 32-62)      * terminated -- set if barrier is terminated             (bit  63 / sign)      *      * Except that a phaser with no registered parties is      * distinguished by the otherwise illegal state of having zero      * parties and one unarrived parties (encoded as EMPTY below).      *      * To efficiently maintain atomicity, these values are packed into      * a single (atomic) long. Good performance relies on keeping      * state decoding and encoding simple, and keeping race windows      * short.      *      * All state updates are performed via CAS except initial      * registration of a sub-phaser (i.e., one with a non-null      * parent).  In this (relatively rare) case, we use built-in      * synchronization to lock while first registering with its      * parent.      *      * The phase of a subphaser is allowed to lag that of its      * ancestors until it is actually accessed -- see method      * reconcileState.      */
DECL|field|state
specifier|private
specifier|volatile
name|long
name|state
decl_stmt|;
DECL|field|MAX_PARTIES
specifier|private
specifier|static
specifier|final
name|int
name|MAX_PARTIES
init|=
literal|0xffff
decl_stmt|;
DECL|field|MAX_PHASE
specifier|private
specifier|static
specifier|final
name|int
name|MAX_PHASE
init|=
name|Integer
operator|.
name|MAX_VALUE
decl_stmt|;
DECL|field|PARTIES_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|PARTIES_SHIFT
init|=
literal|16
decl_stmt|;
DECL|field|PHASE_SHIFT
specifier|private
specifier|static
specifier|final
name|int
name|PHASE_SHIFT
init|=
literal|32
decl_stmt|;
DECL|field|UNARRIVED_MASK
specifier|private
specifier|static
specifier|final
name|int
name|UNARRIVED_MASK
init|=
literal|0xffff
decl_stmt|;
comment|// to mask ints
DECL|field|PARTIES_MASK
specifier|private
specifier|static
specifier|final
name|long
name|PARTIES_MASK
init|=
literal|0xffff0000L
decl_stmt|;
comment|// to mask longs
DECL|field|COUNTS_MASK
specifier|private
specifier|static
specifier|final
name|long
name|COUNTS_MASK
init|=
literal|0xffffffffL
decl_stmt|;
DECL|field|TERMINATION_BIT
specifier|private
specifier|static
specifier|final
name|long
name|TERMINATION_BIT
init|=
literal|1L
operator|<<
literal|63
decl_stmt|;
comment|// some special values
DECL|field|ONE_ARRIVAL
specifier|private
specifier|static
specifier|final
name|int
name|ONE_ARRIVAL
init|=
literal|1
decl_stmt|;
DECL|field|ONE_PARTY
specifier|private
specifier|static
specifier|final
name|int
name|ONE_PARTY
init|=
literal|1
operator|<<
name|PARTIES_SHIFT
decl_stmt|;
DECL|field|ONE_DEREGISTER
specifier|private
specifier|static
specifier|final
name|int
name|ONE_DEREGISTER
init|=
name|ONE_ARRIVAL
operator||
name|ONE_PARTY
decl_stmt|;
DECL|field|EMPTY
specifier|private
specifier|static
specifier|final
name|int
name|EMPTY
init|=
literal|1
decl_stmt|;
comment|// The following unpacking methods are usually manually inlined
DECL|method|unarrivedOf
specifier|private
specifier|static
name|int
name|unarrivedOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
name|int
name|counts
init|=
operator|(
name|int
operator|)
name|s
decl_stmt|;
return|return
operator|(
name|counts
operator|==
name|EMPTY
operator|)
condition|?
literal|0
else|:
operator|(
name|counts
operator|&
name|UNARRIVED_MASK
operator|)
return|;
block|}
DECL|method|partiesOf
specifier|private
specifier|static
name|int
name|partiesOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|s
operator|>>>
name|PARTIES_SHIFT
return|;
block|}
DECL|method|phaseOf
specifier|private
specifier|static
name|int
name|phaseOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
return|;
block|}
DECL|method|arrivedOf
specifier|private
specifier|static
name|int
name|arrivedOf
parameter_list|(
name|long
name|s
parameter_list|)
block|{
name|int
name|counts
init|=
operator|(
name|int
operator|)
name|s
decl_stmt|;
return|return
operator|(
name|counts
operator|==
name|EMPTY
operator|)
condition|?
literal|0
else|:
operator|(
name|counts
operator|>>>
name|PARTIES_SHIFT
operator|)
operator|-
operator|(
name|counts
operator|&
name|UNARRIVED_MASK
operator|)
return|;
block|}
comment|/**      * The parent of this phaser, or null if none      */
DECL|field|parent
specifier|private
specifier|final
name|Phaser
name|parent
decl_stmt|;
comment|/**      * The root of phaser tree. Equals this if not in a tree.      */
DECL|field|root
specifier|private
specifier|final
name|Phaser
name|root
decl_stmt|;
comment|/**      * Heads of Treiber stacks for waiting threads. To eliminate      * contention when releasing some threads while adding others, we      * use two of them, alternating across even and odd phases.      * Subphasers share queues with root to speed up releases.      */
DECL|field|evenQ
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|evenQ
decl_stmt|;
DECL|field|oddQ
specifier|private
specifier|final
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|oddQ
decl_stmt|;
DECL|method|queueFor
specifier|private
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|queueFor
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
return|return
operator|(
operator|(
name|phase
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|?
name|evenQ
else|:
name|oddQ
return|;
block|}
comment|/**      * Returns message string for bounds exceptions on arrival.      */
DECL|method|badArrive
specifier|private
name|String
name|badArrive
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
literal|"Attempted arrival of unregistered party for "
operator|+
name|stateToString
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|/**      * Returns message string for bounds exceptions on registration.      */
DECL|method|badRegister
specifier|private
name|String
name|badRegister
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
literal|"Attempt to register more than "
operator|+
name|MAX_PARTIES
operator|+
literal|" parties for "
operator|+
name|stateToString
argument_list|(
name|s
argument_list|)
return|;
block|}
comment|/**      * Main implementation for methods arrive and arriveAndDeregister.      * Manually tuned to speed up and minimize race windows for the      * common case of just decrementing unarrived field.      *      * @param adjust value to subtract from state;      *               ONE_ARRIVAL for arrive,      *               ONE_DEREGISTER for arriveAndDeregister      */
DECL|method|doArrive
specifier|private
name|int
name|doArrive
parameter_list|(
name|int
name|adjust
parameter_list|)
block|{
specifier|final
name|Phaser
name|root
init|=
name|this
operator|.
name|root
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
init|=
operator|(
name|root
operator|==
name|this
operator|)
condition|?
name|state
else|:
name|reconcileState
argument_list|()
decl_stmt|;
name|int
name|phase
init|=
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
name|int
name|counts
init|=
operator|(
name|int
operator|)
name|s
decl_stmt|;
name|int
name|unarrived
init|=
operator|(
name|counts
operator|==
name|EMPTY
operator|)
condition|?
literal|0
else|:
operator|(
name|counts
operator|&
name|UNARRIVED_MASK
operator|)
decl_stmt|;
if|if
condition|(
name|unarrived
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|badArrive
argument_list|(
name|s
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|s
operator|-=
name|adjust
argument_list|)
condition|)
block|{
if|if
condition|(
name|unarrived
operator|==
literal|1
condition|)
block|{
name|long
name|n
init|=
name|s
operator|&
name|PARTIES_MASK
decl_stmt|;
comment|// base of next state
name|int
name|nextUnarrived
init|=
operator|(
name|int
operator|)
name|n
operator|>>>
name|PARTIES_SHIFT
decl_stmt|;
if|if
condition|(
name|root
operator|==
name|this
condition|)
block|{
if|if
condition|(
name|onAdvance
argument_list|(
name|phase
argument_list|,
name|nextUnarrived
argument_list|)
condition|)
name|n
operator||=
name|TERMINATION_BIT
expr_stmt|;
elseif|else
if|if
condition|(
name|nextUnarrived
operator|==
literal|0
condition|)
name|n
operator||=
name|EMPTY
expr_stmt|;
else|else
name|n
operator||=
name|nextUnarrived
expr_stmt|;
name|int
name|nextPhase
init|=
operator|(
name|phase
operator|+
literal|1
operator|)
operator|&
name|MAX_PHASE
decl_stmt|;
name|n
operator||=
operator|(
name|long
operator|)
name|nextPhase
operator|<<
name|PHASE_SHIFT
expr_stmt|;
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextUnarrived
operator|==
literal|0
condition|)
block|{
comment|// propagate deregistration
name|phase
operator|=
name|parent
operator|.
name|doArrive
argument_list|(
name|ONE_DEREGISTER
argument_list|)
expr_stmt|;
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|s
operator||
name|EMPTY
argument_list|)
expr_stmt|;
block|}
else|else
name|phase
operator|=
name|parent
operator|.
name|doArrive
argument_list|(
name|ONE_ARRIVAL
argument_list|)
expr_stmt|;
block|}
return|return
name|phase
return|;
block|}
block|}
block|}
comment|/**      * Implementation of register, bulkRegister      *      * @param registrations number to add to both parties and      * unarrived fields. Must be greater than zero.      */
DECL|method|doRegister
specifier|private
name|int
name|doRegister
parameter_list|(
name|int
name|registrations
parameter_list|)
block|{
comment|// adjustment to state
name|long
name|adjust
init|=
operator|(
operator|(
name|long
operator|)
name|registrations
operator|<<
name|PARTIES_SHIFT
operator|)
operator||
name|registrations
decl_stmt|;
specifier|final
name|Phaser
name|parent
init|=
name|this
operator|.
name|parent
decl_stmt|;
name|int
name|phase
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
init|=
operator|(
name|parent
operator|==
literal|null
operator|)
condition|?
name|state
else|:
name|reconcileState
argument_list|()
decl_stmt|;
name|int
name|counts
init|=
operator|(
name|int
operator|)
name|s
decl_stmt|;
name|int
name|parties
init|=
name|counts
operator|>>>
name|PARTIES_SHIFT
decl_stmt|;
name|int
name|unarrived
init|=
name|counts
operator|&
name|UNARRIVED_MASK
decl_stmt|;
if|if
condition|(
name|registrations
operator|>
name|MAX_PARTIES
operator|-
name|parties
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|badRegister
argument_list|(
name|s
argument_list|)
argument_list|)
throw|;
name|phase
operator|=
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|counts
operator|!=
name|EMPTY
condition|)
block|{
comment|// not 1st registration
if|if
condition|(
name|parent
operator|==
literal|null
operator|||
name|reconcileState
argument_list|()
operator|==
name|s
condition|)
block|{
if|if
condition|(
name|unarrived
operator|==
literal|0
condition|)
comment|// wait out advance
name|root
operator|.
name|internalAwaitAdvance
argument_list|(
name|phase
argument_list|,
literal|null
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|s
operator|+
name|adjust
argument_list|)
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
comment|// 1st root registration
name|long
name|next
init|=
operator|(
operator|(
name|long
operator|)
name|phase
operator|<<
name|PHASE_SHIFT
operator|)
operator||
name|adjust
decl_stmt|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
synchronized|synchronized
init|(
name|this
init|)
block|{
comment|// 1st sub registration
if|if
condition|(
name|state
operator|==
name|s
condition|)
block|{
comment|// recheck under lock
name|phase
operator|=
name|parent
operator|.
name|doRegister
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
break|break;
comment|// finish registration whenever parent registration
comment|// succeeded, even when racing with termination,
comment|// since these are part of the same "transaction".
while|while
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
operator|(
operator|(
name|long
operator|)
name|phase
operator|<<
name|PHASE_SHIFT
operator|)
operator||
name|adjust
argument_list|)
condition|)
block|{
name|s
operator|=
name|state
expr_stmt|;
name|phase
operator|=
call|(
name|int
call|)
argument_list|(
name|root
operator|.
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
expr_stmt|;
comment|// assert (int)s == EMPTY;
block|}
break|break;
block|}
block|}
block|}
block|}
return|return
name|phase
return|;
block|}
comment|/**      * Resolves lagged phase propagation from root if necessary.      * Reconciliation normally occurs when root has advanced but      * subphasers have not yet done so, in which case they must finish      * their own advance by setting unarrived to parties (or if      * parties is zero, resetting to unregistered EMPTY state).      *      * @return reconciled state      */
DECL|method|reconcileState
specifier|private
name|long
name|reconcileState
parameter_list|()
block|{
specifier|final
name|Phaser
name|root
init|=
name|this
operator|.
name|root
decl_stmt|;
name|long
name|s
init|=
name|state
decl_stmt|;
if|if
condition|(
name|root
operator|!=
name|this
condition|)
block|{
name|int
name|phase
decl_stmt|,
name|p
decl_stmt|;
comment|// CAS to root phase with current parties, tripping unarrived
while|while
condition|(
operator|(
name|phase
operator|=
call|(
name|int
call|)
argument_list|(
name|root
operator|.
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
operator|)
operator|!=
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
operator|&&
operator|!
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|s
operator|=
operator|(
operator|(
operator|(
name|long
operator|)
name|phase
operator|<<
name|PHASE_SHIFT
operator|)
operator||
operator|(
operator|(
name|phase
operator|<
literal|0
operator|)
condition|?
operator|(
name|s
operator|&
name|COUNTS_MASK
operator|)
else|:
operator|(
operator|(
operator|(
name|p
operator|=
operator|(
name|int
operator|)
name|s
operator|>>>
name|PARTIES_SHIFT
operator|)
operator|==
literal|0
operator|)
condition|?
name|EMPTY
else|:
operator|(
operator|(
name|s
operator|&
name|PARTIES_MASK
operator|)
operator||
name|p
operator|)
operator|)
operator|)
operator|)
argument_list|)
condition|)
name|s
operator|=
name|state
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
comment|/**      * Creates a new phaser with no initially registered parties, no      * parent, and initial phase number 0. Any thread using this      * phaser will need to first register for it.      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|()
block|{
name|this
argument_list|(
literal|null
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new phaser with the given number of registered      * unarrived parties, no parent, and initial phase number 0.      *      * @param parties the number of parties required to advance to the      * next phase      * @throws IllegalArgumentException if parties less than zero      * or greater than the maximum number of parties supported      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|(
name|int
name|parties
parameter_list|)
block|{
name|this
argument_list|(
literal|null
argument_list|,
name|parties
argument_list|)
expr_stmt|;
block|}
comment|/**      * Equivalent to {@link #Phaser(Phaser, int) Phaser(parent, 0)}.      *      * @param parent the parent phaser      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|(
name|Phaser
name|parent
parameter_list|)
block|{
name|this
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/**      * Creates a new phaser with the given parent and number of      * registered unarrived parties.  When the given parent is non-null      * and the given number of parties is greater than zero, this      * child phaser is registered with its parent.      *      * @param parent the parent phaser      * @param parties the number of parties required to advance to the      * next phase      * @throws IllegalArgumentException if parties less than zero      * or greater than the maximum number of parties supported      */
DECL|method|Phaser
specifier|public
name|Phaser
parameter_list|(
name|Phaser
name|parent
parameter_list|,
name|int
name|parties
parameter_list|)
block|{
if|if
condition|(
name|parties
operator|>>>
name|PARTIES_SHIFT
operator|!=
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Illegal number of parties"
argument_list|)
throw|;
name|int
name|phase
init|=
literal|0
decl_stmt|;
name|this
operator|.
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
literal|null
condition|)
block|{
specifier|final
name|Phaser
name|root
init|=
name|parent
operator|.
name|root
decl_stmt|;
name|this
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|this
operator|.
name|evenQ
operator|=
name|root
operator|.
name|evenQ
expr_stmt|;
name|this
operator|.
name|oddQ
operator|=
name|root
operator|.
name|oddQ
expr_stmt|;
if|if
condition|(
name|parties
operator|!=
literal|0
condition|)
name|phase
operator|=
name|parent
operator|.
name|doRegister
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|root
operator|=
name|this
expr_stmt|;
name|this
operator|.
name|evenQ
operator|=
operator|new
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
argument_list|()
expr_stmt|;
name|this
operator|.
name|oddQ
operator|=
operator|new
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
argument_list|()
expr_stmt|;
block|}
name|this
operator|.
name|state
operator|=
operator|(
name|parties
operator|==
literal|0
operator|)
condition|?
operator|(
name|long
operator|)
name|EMPTY
else|:
operator|(
operator|(
name|long
operator|)
name|phase
operator|<<
name|PHASE_SHIFT
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|parties
operator|<<
name|PARTIES_SHIFT
operator|)
operator||
operator|(
operator|(
name|long
operator|)
name|parties
operator|)
expr_stmt|;
block|}
comment|/**      * Adds a new unarrived party to this phaser.  If an ongoing      * invocation of {@link #onAdvance} is in progress, this method      * may await its completion before returning.  If this phaser has      * a parent, and this phaser previously had no registered parties,      * this child phaser is also registered with its parent. If      * this phaser is terminated, the attempt to register has      * no effect, and a negative value is returned.      *      * @return the arrival phase number to which this registration      * applied.  If this value is negative, then this phaser has      * terminated, in which case registration has no effect.      * @throws IllegalStateException if attempting to register more      * than the maximum supported number of parties      */
DECL|method|register
specifier|public
name|int
name|register
parameter_list|()
block|{
return|return
name|doRegister
argument_list|(
literal|1
argument_list|)
return|;
block|}
comment|/**      * Adds the given number of new unarrived parties to this phaser.      * If an ongoing invocation of {@link #onAdvance} is in progress,      * this method may await its completion before returning.  If this      * phaser has a parent, and the given number of parties is greater      * than zero, and this phaser previously had no registered      * parties, this child phaser is also registered with its parent.      * If this phaser is terminated, the attempt to register has no      * effect, and a negative value is returned.      *      * @param parties the number of additional parties required to      * advance to the next phase      * @return the arrival phase number to which this registration      * applied.  If this value is negative, then this phaser has      * terminated, in which case registration has no effect.      * @throws IllegalStateException if attempting to register more      * than the maximum supported number of parties      * @throws IllegalArgumentException if {@code parties< 0}      */
DECL|method|bulkRegister
specifier|public
name|int
name|bulkRegister
parameter_list|(
name|int
name|parties
parameter_list|)
block|{
if|if
condition|(
name|parties
operator|<
literal|0
condition|)
throw|throw
operator|new
name|IllegalArgumentException
argument_list|()
throw|;
if|if
condition|(
name|parties
operator|==
literal|0
condition|)
return|return
name|getPhase
argument_list|()
return|;
return|return
name|doRegister
argument_list|(
name|parties
argument_list|)
return|;
block|}
comment|/**      * Arrives at this phaser, without waiting for others to arrive.      *      *<p>It is a usage error for an unregistered party to invoke this      * method.  However, this error may result in an {@code      * IllegalStateException} only upon some subsequent operation on      * this phaser, if ever.      *      * @return the arrival phase number, or a negative value if terminated      * @throws IllegalStateException if not terminated and the number      * of unarrived parties would become negative      */
DECL|method|arrive
specifier|public
name|int
name|arrive
parameter_list|()
block|{
return|return
name|doArrive
argument_list|(
name|ONE_ARRIVAL
argument_list|)
return|;
block|}
comment|/**      * Arrives at this phaser and deregisters from it without waiting      * for others to arrive. Deregistration reduces the number of      * parties required to advance in future phases.  If this phaser      * has a parent, and deregistration causes this phaser to have      * zero parties, this phaser is also deregistered from its parent.      *      *<p>It is a usage error for an unregistered party to invoke this      * method.  However, this error may result in an {@code      * IllegalStateException} only upon some subsequent operation on      * this phaser, if ever.      *      * @return the arrival phase number, or a negative value if terminated      * @throws IllegalStateException if not terminated and the number      * of registered or unarrived parties would become negative      */
DECL|method|arriveAndDeregister
specifier|public
name|int
name|arriveAndDeregister
parameter_list|()
block|{
return|return
name|doArrive
argument_list|(
name|ONE_DEREGISTER
argument_list|)
return|;
block|}
comment|/**      * Arrives at this phaser and awaits others. Equivalent in effect      * to {@code awaitAdvance(arrive())}.  If you need to await with      * interruption or timeout, you can arrange this with an analogous      * construction using one of the other forms of the {@code      * awaitAdvance} method.  If instead you need to deregister upon      * arrival, use {@code awaitAdvance(arriveAndDeregister())}.      *      *<p>It is a usage error for an unregistered party to invoke this      * method.  However, this error may result in an {@code      * IllegalStateException} only upon some subsequent operation on      * this phaser, if ever.      *      * @return the arrival phase number, or the (negative)      * {@linkplain #getPhase() current phase} if terminated      * @throws IllegalStateException if not terminated and the number      * of unarrived parties would become negative      */
DECL|method|arriveAndAwaitAdvance
specifier|public
name|int
name|arriveAndAwaitAdvance
parameter_list|()
block|{
comment|// Specialization of doArrive+awaitAdvance eliminating some reads/paths
specifier|final
name|Phaser
name|root
init|=
name|this
operator|.
name|root
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|long
name|s
init|=
operator|(
name|root
operator|==
name|this
operator|)
condition|?
name|state
else|:
name|reconcileState
argument_list|()
decl_stmt|;
name|int
name|phase
init|=
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
name|int
name|counts
init|=
operator|(
name|int
operator|)
name|s
decl_stmt|;
name|int
name|unarrived
init|=
operator|(
name|counts
operator|==
name|EMPTY
operator|)
condition|?
literal|0
else|:
operator|(
name|counts
operator|&
name|UNARRIVED_MASK
operator|)
decl_stmt|;
if|if
condition|(
name|unarrived
operator|<=
literal|0
condition|)
throw|throw
operator|new
name|IllegalStateException
argument_list|(
name|badArrive
argument_list|(
name|s
argument_list|)
argument_list|)
throw|;
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|s
operator|-=
name|ONE_ARRIVAL
argument_list|)
condition|)
block|{
if|if
condition|(
name|unarrived
operator|>
literal|1
condition|)
return|return
name|root
operator|.
name|internalAwaitAdvance
argument_list|(
name|phase
argument_list|,
literal|null
argument_list|)
return|;
if|if
condition|(
name|root
operator|!=
name|this
condition|)
return|return
name|parent
operator|.
name|arriveAndAwaitAdvance
argument_list|()
return|;
name|long
name|n
init|=
name|s
operator|&
name|PARTIES_MASK
decl_stmt|;
comment|// base of next state
name|int
name|nextUnarrived
init|=
operator|(
name|int
operator|)
name|n
operator|>>>
name|PARTIES_SHIFT
decl_stmt|;
if|if
condition|(
name|onAdvance
argument_list|(
name|phase
argument_list|,
name|nextUnarrived
argument_list|)
condition|)
name|n
operator||=
name|TERMINATION_BIT
expr_stmt|;
elseif|else
if|if
condition|(
name|nextUnarrived
operator|==
literal|0
condition|)
name|n
operator||=
name|EMPTY
expr_stmt|;
else|else
name|n
operator||=
name|nextUnarrived
expr_stmt|;
name|int
name|nextPhase
init|=
operator|(
name|phase
operator|+
literal|1
operator|)
operator|&
name|MAX_PHASE
decl_stmt|;
name|n
operator||=
operator|(
name|long
operator|)
name|nextPhase
operator|<<
name|PHASE_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|this
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
return|;
comment|// terminated
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
return|return
name|nextPhase
return|;
block|}
block|}
block|}
comment|/**      * Awaits the phase of this phaser to advance from the given phase      * value, returning immediately if the current phase is not equal      * to the given phase value or this phaser is terminated.      *      * @param phase an arrival phase number, or negative value if      * terminated; this argument is normally the value returned by a      * previous call to {@code arrive} or {@code arriveAndDeregister}.      * @return the next arrival phase number, or the argument if it is      * negative, or the (negative) {@linkplain #getPhase() current phase}      * if terminated      */
DECL|method|awaitAdvance
specifier|public
name|int
name|awaitAdvance
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
specifier|final
name|Phaser
name|root
init|=
name|this
operator|.
name|root
decl_stmt|;
name|long
name|s
init|=
operator|(
name|root
operator|==
name|this
operator|)
condition|?
name|state
else|:
name|reconcileState
argument_list|()
decl_stmt|;
name|int
name|p
init|=
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
if|if
condition|(
name|p
operator|==
name|phase
condition|)
return|return
name|root
operator|.
name|internalAwaitAdvance
argument_list|(
name|phase
argument_list|,
literal|null
argument_list|)
return|;
return|return
name|p
return|;
block|}
comment|/**      * Awaits the phase of this phaser to advance from the given phase      * value, throwing {@code InterruptedException} if interrupted      * while waiting, or returning immediately if the current phase is      * not equal to the given phase value or this phaser is      * terminated.      *      * @param phase an arrival phase number, or negative value if      * terminated; this argument is normally the value returned by a      * previous call to {@code arrive} or {@code arriveAndDeregister}.      * @return the next arrival phase number, or the argument if it is      * negative, or the (negative) {@linkplain #getPhase() current phase}      * if terminated      * @throws InterruptedException if thread interrupted while waiting      */
DECL|method|awaitAdvanceInterruptibly
specifier|public
name|int
name|awaitAdvanceInterruptibly
parameter_list|(
name|int
name|phase
parameter_list|)
throws|throws
name|InterruptedException
block|{
specifier|final
name|Phaser
name|root
init|=
name|this
operator|.
name|root
decl_stmt|;
name|long
name|s
init|=
operator|(
name|root
operator|==
name|this
operator|)
condition|?
name|state
else|:
name|reconcileState
argument_list|()
decl_stmt|;
name|int
name|p
init|=
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
if|if
condition|(
name|p
operator|==
name|phase
condition|)
block|{
name|QNode
name|node
init|=
operator|new
name|QNode
argument_list|(
name|this
argument_list|,
name|phase
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|)
decl_stmt|;
name|p
operator|=
name|root
operator|.
name|internalAwaitAdvance
argument_list|(
name|phase
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|wasInterrupted
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
block|}
return|return
name|p
return|;
block|}
comment|/**      * Awaits the phase of this phaser to advance from the given phase      * value or the given timeout to elapse, throwing {@code      * InterruptedException} if interrupted while waiting, or      * returning immediately if the current phase is not equal to the      * given phase value or this phaser is terminated.      *      * @param phase an arrival phase number, or negative value if      * terminated; this argument is normally the value returned by a      * previous call to {@code arrive} or {@code arriveAndDeregister}.      * @param timeout how long to wait before giving up, in units of      *        {@code unit}      * @param unit a {@code TimeUnit} determining how to interpret the      *        {@code timeout} parameter      * @return the next arrival phase number, or the argument if it is      * negative, or the (negative) {@linkplain #getPhase() current phase}      * if terminated      * @throws InterruptedException if thread interrupted while waiting      * @throws TimeoutException if timed out while waiting      */
DECL|method|awaitAdvanceInterruptibly
specifier|public
name|int
name|awaitAdvanceInterruptibly
parameter_list|(
name|int
name|phase
parameter_list|,
name|long
name|timeout
parameter_list|,
name|TimeUnit
name|unit
parameter_list|)
throws|throws
name|InterruptedException
throws|,
name|TimeoutException
block|{
name|long
name|nanos
init|=
name|unit
operator|.
name|toNanos
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
specifier|final
name|Phaser
name|root
init|=
name|this
operator|.
name|root
decl_stmt|;
name|long
name|s
init|=
operator|(
name|root
operator|==
name|this
operator|)
condition|?
name|state
else|:
name|reconcileState
argument_list|()
decl_stmt|;
name|int
name|p
init|=
call|(
name|int
call|)
argument_list|(
name|s
operator|>>>
name|PHASE_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|phase
operator|<
literal|0
condition|)
return|return
name|phase
return|;
if|if
condition|(
name|p
operator|==
name|phase
condition|)
block|{
name|QNode
name|node
init|=
operator|new
name|QNode
argument_list|(
name|this
argument_list|,
name|phase
argument_list|,
literal|true
argument_list|,
literal|true
argument_list|,
name|nanos
argument_list|)
decl_stmt|;
name|p
operator|=
name|root
operator|.
name|internalAwaitAdvance
argument_list|(
name|phase
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|.
name|wasInterrupted
condition|)
throw|throw
operator|new
name|InterruptedException
argument_list|()
throw|;
elseif|else
if|if
condition|(
name|p
operator|==
name|phase
condition|)
throw|throw
operator|new
name|TimeoutException
argument_list|()
throw|;
block|}
return|return
name|p
return|;
block|}
comment|/**      * Forces this phaser to enter termination state.  Counts of      * registered parties are unaffected.  If this phaser is a member      * of a tiered set of phasers, then all of the phasers in the set      * are terminated.  If this phaser is already terminated, this      * method has no effect.  This method may be useful for      * coordinating recovery after one or more tasks encounter      * unexpected exceptions.      */
DECL|method|forceTermination
specifier|public
name|void
name|forceTermination
parameter_list|()
block|{
comment|// Only need to change root state
specifier|final
name|Phaser
name|root
init|=
name|this
operator|.
name|root
decl_stmt|;
name|long
name|s
decl_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|root
operator|.
name|state
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|UNSAFE
operator|.
name|compareAndSwapLong
argument_list|(
name|root
argument_list|,
name|stateOffset
argument_list|,
name|s
argument_list|,
name|s
operator||
name|TERMINATION_BIT
argument_list|)
condition|)
block|{
comment|// signal all threads
name|releaseWaiters
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// Waiters on evenQ
name|releaseWaiters
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|// Waiters on oddQ
return|return;
block|}
block|}
block|}
comment|/**      * Returns the current phase number. The maximum phase number is      * {@code Integer.MAX_VALUE}, after which it restarts at      * zero. Upon termination, the phase number is negative,      * in which case the prevailing phase prior to termination      * may be obtained via {@code getPhase() + Integer.MIN_VALUE}.      *      * @return the phase number, or a negative value if terminated      */
DECL|method|getPhase
specifier|public
specifier|final
name|int
name|getPhase
parameter_list|()
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|root
operator|.
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
return|;
block|}
comment|/**      * Returns the number of parties registered at this phaser.      *      * @return the number of parties      */
DECL|method|getRegisteredParties
specifier|public
name|int
name|getRegisteredParties
parameter_list|()
block|{
return|return
name|partiesOf
argument_list|(
name|state
argument_list|)
return|;
block|}
comment|/**      * Returns the number of registered parties that have arrived at      * the current phase of this phaser. If this phaser has terminated,      * the returned value is meaningless and arbitrary.      *      * @return the number of arrived parties      */
DECL|method|getArrivedParties
specifier|public
name|int
name|getArrivedParties
parameter_list|()
block|{
return|return
name|arrivedOf
argument_list|(
name|reconcileState
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the number of registered parties that have not yet      * arrived at the current phase of this phaser. If this phaser has      * terminated, the returned value is meaningless and arbitrary.      *      * @return the number of unarrived parties      */
DECL|method|getUnarrivedParties
specifier|public
name|int
name|getUnarrivedParties
parameter_list|()
block|{
return|return
name|unarrivedOf
argument_list|(
name|reconcileState
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Returns the parent of this phaser, or {@code null} if none.      *      * @return the parent of this phaser, or {@code null} if none      */
DECL|method|getParent
specifier|public
name|Phaser
name|getParent
parameter_list|()
block|{
return|return
name|parent
return|;
block|}
comment|/**      * Returns the root ancestor of this phaser, which is the same as      * this phaser if it has no parent.      *      * @return the root ancestor of this phaser      */
DECL|method|getRoot
specifier|public
name|Phaser
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
comment|/**      * Returns {@code true} if this phaser has been terminated.      *      * @return {@code true} if this phaser has been terminated      */
DECL|method|isTerminated
specifier|public
name|boolean
name|isTerminated
parameter_list|()
block|{
return|return
name|root
operator|.
name|state
operator|<
literal|0L
return|;
block|}
comment|/**      * Overridable method to perform an action upon impending phase      * advance, and to control termination. This method is invoked      * upon arrival of the party advancing this phaser (when all other      * waiting parties are dormant).  If this method returns {@code      * true}, this phaser will be set to a final termination state      * upon advance, and subsequent calls to {@link #isTerminated}      * will return true. Any (unchecked) Exception or Error thrown by      * an invocation of this method is propagated to the party      * attempting to advance this phaser, in which case no advance      * occurs.      *      *<p>The arguments to this method provide the state of the phaser      * prevailing for the current transition.  The effects of invoking      * arrival, registration, and waiting methods on this phaser from      * within {@code onAdvance} are unspecified and should not be      * relied on.      *      *<p>If this phaser is a member of a tiered set of phasers, then      * {@code onAdvance} is invoked only for its root phaser on each      * advance.      *      *<p>To support the most common use cases, the default      * implementation of this method returns {@code true} when the      * number of registered parties has become zero as the result of a      * party invoking {@code arriveAndDeregister}.  You can disable      * this behavior, thus enabling continuation upon future      * registrations, by overriding this method to always return      * {@code false}:      *      *<pre> {@code      * Phaser phaser = new Phaser() {      *   protected boolean onAdvance(int phase, int parties) { return false; }      * }}</pre>      *      * @param phase the current phase number on entry to this method,      * before this phaser is advanced      * @param registeredParties the current number of registered parties      * @return {@code true} if this phaser should terminate      */
DECL|method|onAdvance
specifier|protected
name|boolean
name|onAdvance
parameter_list|(
name|int
name|phase
parameter_list|,
name|int
name|registeredParties
parameter_list|)
block|{
return|return
name|registeredParties
operator|==
literal|0
return|;
block|}
comment|/**      * Returns a string identifying this phaser, as well as its      * state.  The state, in brackets, includes the String {@code      * "phase = "} followed by the phase number, {@code "parties = "}      * followed by the number of registered parties, and {@code      * "arrived = "} followed by the number of arrived parties.      *      * @return a string identifying this phaser, as well as its state      */
DECL|method|toString
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|stateToString
argument_list|(
name|reconcileState
argument_list|()
argument_list|)
return|;
block|}
comment|/**      * Implementation of toString and string-based error messages      */
DECL|method|stateToString
specifier|private
name|String
name|stateToString
parameter_list|(
name|long
name|s
parameter_list|)
block|{
return|return
name|super
operator|.
name|toString
argument_list|()
operator|+
literal|"[phase = "
operator|+
name|phaseOf
argument_list|(
name|s
argument_list|)
operator|+
literal|" parties = "
operator|+
name|partiesOf
argument_list|(
name|s
argument_list|)
operator|+
literal|" arrived = "
operator|+
name|arrivedOf
argument_list|(
name|s
argument_list|)
operator|+
literal|"]"
return|;
block|}
comment|// Waiting mechanics
comment|/**      * Removes and signals threads from queue for phase.      */
DECL|method|releaseWaiters
specifier|private
name|void
name|releaseWaiters
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
name|QNode
name|q
decl_stmt|;
comment|// first element of queue
name|Thread
name|t
decl_stmt|;
comment|// its thread
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|head
init|=
operator|(
name|phase
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
name|evenQ
else|:
name|oddQ
decl_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|head
operator|.
name|get
argument_list|()
operator|)
operator|!=
literal|null
operator|&&
name|q
operator|.
name|phase
operator|!=
call|(
name|int
call|)
argument_list|(
name|root
operator|.
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
condition|)
block|{
if|if
condition|(
name|head
operator|.
name|compareAndSet
argument_list|(
name|q
argument_list|,
name|q
operator|.
name|next
argument_list|)
operator|&&
operator|(
name|t
operator|=
name|q
operator|.
name|thread
operator|)
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/**      * Variant of releaseWaiters that additionally tries to remove any      * nodes no longer waiting for advance due to timeout or      * interrupt. Currently, nodes are removed only if they are at      * head of queue, which suffices to reduce memory footprint in      * most usages.      *      * @return current phase on exit      */
DECL|method|abortWait
specifier|private
name|int
name|abortWait
parameter_list|(
name|int
name|phase
parameter_list|)
block|{
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|head
init|=
operator|(
name|phase
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
name|evenQ
else|:
name|oddQ
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Thread
name|t
decl_stmt|;
name|QNode
name|q
init|=
name|head
operator|.
name|get
argument_list|()
decl_stmt|;
name|int
name|p
init|=
call|(
name|int
call|)
argument_list|(
name|root
operator|.
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
literal|null
operator|||
operator|(
operator|(
name|t
operator|=
name|q
operator|.
name|thread
operator|)
operator|!=
literal|null
operator|&&
name|q
operator|.
name|phase
operator|==
name|p
operator|)
condition|)
return|return
name|p
return|;
if|if
condition|(
name|head
operator|.
name|compareAndSet
argument_list|(
name|q
argument_list|,
name|q
operator|.
name|next
argument_list|)
operator|&&
name|t
operator|!=
literal|null
condition|)
block|{
name|q
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
name|LockSupport
operator|.
name|unpark
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/** The number of CPUs, for spin control */
DECL|field|NCPU
specifier|private
specifier|static
specifier|final
name|int
name|NCPU
init|=
name|Runtime
operator|.
name|getRuntime
argument_list|()
operator|.
name|availableProcessors
argument_list|()
decl_stmt|;
comment|/**      * The number of times to spin before blocking while waiting for      * advance, per arrival while waiting. On multiprocessors, fully      * blocking and waking up a large number of threads all at once is      * usually a very slow process, so we use rechargeable spins to      * avoid it when threads regularly arrive: When a thread in      * internalAwaitAdvance notices another arrival before blocking,      * and there appear to be enough CPUs available, it spins      * SPINS_PER_ARRIVAL more times before blocking. The value trades      * off good-citizenship vs big unnecessary slowdowns.      */
DECL|field|SPINS_PER_ARRIVAL
specifier|static
specifier|final
name|int
name|SPINS_PER_ARRIVAL
init|=
operator|(
name|NCPU
operator|<
literal|2
operator|)
condition|?
literal|1
else|:
literal|1
operator|<<
literal|8
decl_stmt|;
comment|/**      * Possibly blocks and waits for phase to advance unless aborted.      * Call only on root phaser.      *      * @param phase current phase      * @param node if non-null, the wait node to track interrupt and timeout;      * if null, denotes noninterruptible wait      * @return current phase      */
DECL|method|internalAwaitAdvance
specifier|private
name|int
name|internalAwaitAdvance
parameter_list|(
name|int
name|phase
parameter_list|,
name|QNode
name|node
parameter_list|)
block|{
comment|// assert root == this;
name|releaseWaiters
argument_list|(
name|phase
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// ensure old queue clean
name|boolean
name|queued
init|=
literal|false
decl_stmt|;
comment|// true when node is enqueued
name|int
name|lastUnarrived
init|=
literal|0
decl_stmt|;
comment|// to increase spins upon change
name|int
name|spins
init|=
name|SPINS_PER_ARRIVAL
decl_stmt|;
name|long
name|s
decl_stmt|;
name|int
name|p
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|s
operator|=
name|state
operator|)
operator|>>>
name|PHASE_SHIFT
argument_list|)
operator|)
operator|==
name|phase
condition|)
block|{
if|if
condition|(
name|node
operator|==
literal|null
condition|)
block|{
comment|// spinning in noninterruptible mode
name|int
name|unarrived
init|=
operator|(
name|int
operator|)
name|s
operator|&
name|UNARRIVED_MASK
decl_stmt|;
if|if
condition|(
name|unarrived
operator|!=
name|lastUnarrived
operator|&&
operator|(
name|lastUnarrived
operator|=
name|unarrived
operator|)
operator|<
name|NCPU
condition|)
name|spins
operator|+=
name|SPINS_PER_ARRIVAL
expr_stmt|;
name|boolean
name|interrupted
init|=
name|Thread
operator|.
name|interrupted
argument_list|()
decl_stmt|;
if|if
condition|(
name|interrupted
operator|||
operator|--
name|spins
operator|<
literal|0
condition|)
block|{
comment|// need node to record intr
name|node
operator|=
operator|new
name|QNode
argument_list|(
name|this
argument_list|,
name|phase
argument_list|,
literal|false
argument_list|,
literal|false
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|node
operator|.
name|wasInterrupted
operator|=
name|interrupted
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|node
operator|.
name|isReleasable
argument_list|()
condition|)
comment|// done or aborted
break|break;
elseif|else
if|if
condition|(
operator|!
name|queued
condition|)
block|{
comment|// push onto queue
name|AtomicReference
argument_list|<
name|QNode
argument_list|>
name|head
init|=
operator|(
name|phase
operator|&
literal|1
operator|)
operator|==
literal|0
condition|?
name|evenQ
else|:
name|oddQ
decl_stmt|;
name|QNode
name|q
init|=
name|node
operator|.
name|next
operator|=
name|head
operator|.
name|get
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|q
operator|==
literal|null
operator|||
name|q
operator|.
name|phase
operator|==
name|phase
operator|)
operator|&&
call|(
name|int
call|)
argument_list|(
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
operator|==
name|phase
condition|)
comment|// avoid stale enq
name|queued
operator|=
name|head
operator|.
name|compareAndSet
argument_list|(
name|q
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
try|try
block|{
name|ForkJoinPool
operator|.
name|managedBlock
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|ie
parameter_list|)
block|{
name|node
operator|.
name|wasInterrupted
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|node
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|node
operator|.
name|thread
operator|!=
literal|null
condition|)
name|node
operator|.
name|thread
operator|=
literal|null
expr_stmt|;
comment|// avoid need for unpark()
if|if
condition|(
name|node
operator|.
name|wasInterrupted
operator|&&
operator|!
name|node
operator|.
name|interruptible
condition|)
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|interrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|phase
operator|&&
operator|(
name|p
operator|=
call|(
name|int
call|)
argument_list|(
name|state
operator|>>>
name|PHASE_SHIFT
argument_list|)
operator|)
operator|==
name|phase
condition|)
return|return
name|abortWait
argument_list|(
name|phase
argument_list|)
return|;
comment|// possibly clean up on abort
block|}
name|releaseWaiters
argument_list|(
name|phase
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/**      * Wait nodes for Treiber stack representing wait queue      */
DECL|class|QNode
specifier|static
specifier|final
class|class
name|QNode
implements|implements
name|ForkJoinPool
operator|.
name|ManagedBlocker
block|{
DECL|field|phaser
specifier|final
name|Phaser
name|phaser
decl_stmt|;
DECL|field|phase
specifier|final
name|int
name|phase
decl_stmt|;
DECL|field|interruptible
specifier|final
name|boolean
name|interruptible
decl_stmt|;
DECL|field|timed
specifier|final
name|boolean
name|timed
decl_stmt|;
DECL|field|wasInterrupted
name|boolean
name|wasInterrupted
decl_stmt|;
DECL|field|nanos
name|long
name|nanos
decl_stmt|;
DECL|field|lastTime
name|long
name|lastTime
decl_stmt|;
DECL|field|thread
specifier|volatile
name|Thread
name|thread
decl_stmt|;
comment|// nulled to cancel wait
DECL|field|next
name|QNode
name|next
decl_stmt|;
DECL|method|QNode
name|QNode
parameter_list|(
name|Phaser
name|phaser
parameter_list|,
name|int
name|phase
parameter_list|,
name|boolean
name|interruptible
parameter_list|,
name|boolean
name|timed
parameter_list|,
name|long
name|nanos
parameter_list|)
block|{
name|this
operator|.
name|phaser
operator|=
name|phaser
expr_stmt|;
name|this
operator|.
name|phase
operator|=
name|phase
expr_stmt|;
name|this
operator|.
name|interruptible
operator|=
name|interruptible
expr_stmt|;
name|this
operator|.
name|nanos
operator|=
name|nanos
expr_stmt|;
name|this
operator|.
name|timed
operator|=
name|timed
expr_stmt|;
name|this
operator|.
name|lastTime
operator|=
name|timed
condition|?
name|System
operator|.
name|nanoTime
argument_list|()
else|:
literal|0L
expr_stmt|;
name|thread
operator|=
name|Thread
operator|.
name|currentThread
argument_list|()
expr_stmt|;
block|}
DECL|method|isReleasable
specifier|public
name|boolean
name|isReleasable
parameter_list|()
block|{
if|if
condition|(
name|thread
operator|==
literal|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|phaser
operator|.
name|getPhase
argument_list|()
operator|!=
name|phase
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|Thread
operator|.
name|interrupted
argument_list|()
condition|)
name|wasInterrupted
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|wasInterrupted
operator|&&
name|interruptible
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|timed
condition|)
block|{
if|if
condition|(
name|nanos
operator|>
literal|0L
condition|)
block|{
name|long
name|now
init|=
name|System
operator|.
name|nanoTime
argument_list|()
decl_stmt|;
name|nanos
operator|-=
name|now
operator|-
name|lastTime
expr_stmt|;
name|lastTime
operator|=
name|now
expr_stmt|;
block|}
if|if
condition|(
name|nanos
operator|<=
literal|0L
condition|)
block|{
name|thread
operator|=
literal|null
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
DECL|method|block
specifier|public
name|boolean
name|block
parameter_list|()
block|{
if|if
condition|(
name|isReleasable
argument_list|()
condition|)
return|return
literal|true
return|;
elseif|else
if|if
condition|(
operator|!
name|timed
condition|)
name|LockSupport
operator|.
name|park
argument_list|(
name|this
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nanos
operator|>
literal|0
condition|)
name|LockSupport
operator|.
name|parkNanos
argument_list|(
name|this
argument_list|,
name|nanos
argument_list|)
expr_stmt|;
return|return
name|isReleasable
argument_list|()
return|;
block|}
block|}
comment|// Unsafe mechanics
DECL|field|UNSAFE
specifier|private
specifier|static
specifier|final
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|UNSAFE
decl_stmt|;
DECL|field|stateOffset
specifier|private
specifier|static
specifier|final
name|long
name|stateOffset
decl_stmt|;
static|static
block|{
try|try
block|{
name|UNSAFE
operator|=
name|getUnsafe
argument_list|()
expr_stmt|;
name|Class
argument_list|<
name|?
argument_list|>
name|k
init|=
name|Phaser
operator|.
name|class
decl_stmt|;
name|stateOffset
operator|=
name|UNSAFE
operator|.
name|objectFieldOffset
argument_list|(
name|k
operator|.
name|getDeclaredField
argument_list|(
literal|"state"
argument_list|)
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|Error
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.      * Replace with a simple call to Unsafe.getUnsafe when integrating      * into a jdk.      *      * @return a sun.misc.Unsafe      */
DECL|method|getUnsafe
specifier|private
specifier|static
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|getUnsafe
parameter_list|()
block|{
try|try
block|{
return|return
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|getUnsafe
argument_list|()
return|;
block|}
catch|catch
parameter_list|(
name|SecurityException
name|se
parameter_list|)
block|{
try|try
block|{
return|return
name|java
operator|.
name|security
operator|.
name|AccessController
operator|.
name|doPrivileged
argument_list|(
operator|new
name|java
operator|.
name|security
operator|.
name|PrivilegedExceptionAction
argument_list|<
name|sun
operator|.
name|misc
operator|.
name|Unsafe
argument_list|>
argument_list|()
block|{
specifier|public
name|sun
operator|.
name|misc
operator|.
name|Unsafe
name|run
parameter_list|()
throws|throws
name|Exception
block|{
name|java
operator|.
name|lang
operator|.
name|reflect
operator|.
name|Field
name|f
init|=
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|.
name|class
operator|.
name|getDeclaredField
argument_list|(
literal|"theUnsafe"
argument_list|)
decl_stmt|;
name|f
operator|.
name|setAccessible
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
operator|(
name|sun
operator|.
name|misc
operator|.
name|Unsafe
operator|)
name|f
operator|.
name|get
argument_list|(
literal|null
argument_list|)
return|;
block|}
block|}
argument_list|)
return|;
block|}
catch|catch
parameter_list|(
name|java
operator|.
name|security
operator|.
name|PrivilegedActionException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|RuntimeException
argument_list|(
literal|"Could not initialize intrinsics"
argument_list|,
name|e
operator|.
name|getCause
argument_list|()
argument_list|)
throw|;
block|}
block|}
block|}
block|}
end_class

end_unit

