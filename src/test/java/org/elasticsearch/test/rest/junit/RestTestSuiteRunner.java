begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to ElasticSearch and Shay Banon under one  * or more contributor license agreements. See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. ElasticSearch licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the  * License for the specific language governing permissions and limitations under  * the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.test.rest.junit
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|junit
package|;
end_package

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|hppc
operator|.
name|hash
operator|.
name|MurmurHash3
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|RandomizedTest
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|Randomness
import|;
end_import

begin_import
import|import
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|SeedUtils
import|;
end_import

begin_import
import|import
name|com
operator|.
name|google
operator|.
name|common
operator|.
name|collect
operator|.
name|Lists
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|Strings
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|ESLogger
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|logging
operator|.
name|Loggers
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|common
operator|.
name|transport
operator|.
name|InetSocketTransportAddress
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|http
operator|.
name|HttpServerTransport
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|ElasticsearchTestCase
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|TestCluster
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|RestTestExecutionContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|client
operator|.
name|RestException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|client
operator|.
name|RestResponse
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|parser
operator|.
name|RestTestParseException
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|parser
operator|.
name|RestTestSuiteParser
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|section
operator|.
name|DoSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|section
operator|.
name|ExecutableSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|section
operator|.
name|RestTestSuite
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|section
operator|.
name|TestSection
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|spec
operator|.
name|RestSpec
import|;
end_import

begin_import
import|import
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|support
operator|.
name|FileUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|Description
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|notification
operator|.
name|Failure
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runner
operator|.
name|notification
operator|.
name|RunNotifier
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|ParentRunner
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|model
operator|.
name|InitializationError
import|;
end_import

begin_import
import|import
name|org
operator|.
name|junit
operator|.
name|runners
operator|.
name|model
operator|.
name|Statement
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|File
import|;
end_import

begin_import
import|import
name|java
operator|.
name|io
operator|.
name|IOException
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|*
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|concurrent
operator|.
name|atomic
operator|.
name|AtomicInteger
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|SeedUtils
operator|.
name|parseSeedChain
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|StandaloneRandomizedContext
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|com
operator|.
name|carrotsearch
operator|.
name|randomizedtesting
operator|.
name|SysGlobals
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|TestCluster
operator|.
name|SHARED_CLUSTER_SEED
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|TestCluster
operator|.
name|clusterName
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|elasticsearch
operator|.
name|test
operator|.
name|rest
operator|.
name|junit
operator|.
name|DescriptionHelper
operator|.
name|*
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|equalTo
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|hamcrest
operator|.
name|Matchers
operator|.
name|instanceOf
import|;
end_import

begin_import
import|import static
name|org
operator|.
name|junit
operator|.
name|Assert
operator|.
name|assertThat
import|;
end_import

begin_comment
comment|/**  * JUnit runner for elasticsearch REST tests  *  * Supports the following options provided as system properties:  * - tests.rest[true|false|host:port]: determines whether the REST tests need to be run and if so  *                                     whether to rely on an external cluster (providing host and port) or fire a test cluster (default)  * - tests.rest.suite: comma separated paths of the test suites to be run (by default loaded from /rest-api-spec/test)  *                     it is possible to run only a subset of the tests providing a directory or a single yaml file  *                     (the default /rest-api-spec/test prefix is optional when files are loaded from classpath)  * - tests.rest.spec: REST spec path (default /rest-api-spec/api)  * - tests.iters: runs multiple iterations  * - tests.seed: seed to base the random behaviours on  * - tests.appendseed[true|false]: enables adding the seed to each test section's description (default false)  * - tests.cluster_seed: seed used to create the test cluster (if enabled)  *  */
end_comment

begin_class
DECL|class|RestTestSuiteRunner
specifier|public
class|class
name|RestTestSuiteRunner
extends|extends
name|ParentRunner
argument_list|<
name|RestTestCandidate
argument_list|>
block|{
DECL|field|logger
specifier|private
specifier|static
specifier|final
name|ESLogger
name|logger
init|=
name|Loggers
operator|.
name|getLogger
argument_list|(
name|RestTestSuiteRunner
operator|.
name|class
argument_list|)
decl_stmt|;
DECL|field|REST_TESTS_MODE
specifier|public
specifier|static
specifier|final
name|String
name|REST_TESTS_MODE
init|=
literal|"tests.rest"
decl_stmt|;
DECL|field|REST_TESTS_SUITE
specifier|public
specifier|static
specifier|final
name|String
name|REST_TESTS_SUITE
init|=
literal|"tests.rest.suite"
decl_stmt|;
DECL|field|REST_TESTS_SPEC
specifier|public
specifier|static
specifier|final
name|String
name|REST_TESTS_SPEC
init|=
literal|"tests.rest.spec"
decl_stmt|;
DECL|field|DEFAULT_TESTS_PATH
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_TESTS_PATH
init|=
literal|"/rest-api-spec/test"
decl_stmt|;
DECL|field|DEFAULT_SPEC_PATH
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT_SPEC_PATH
init|=
literal|"/rest-api-spec/api"
decl_stmt|;
DECL|field|DEFAULT_ITERATIONS
specifier|private
specifier|static
specifier|final
name|int
name|DEFAULT_ITERATIONS
init|=
literal|1
decl_stmt|;
DECL|field|PATHS_SEPARATOR
specifier|private
specifier|static
specifier|final
name|String
name|PATHS_SEPARATOR
init|=
literal|","
decl_stmt|;
DECL|field|restTestExecutionContext
specifier|private
specifier|final
name|RestTestExecutionContext
name|restTestExecutionContext
decl_stmt|;
DECL|field|restTestCandidates
specifier|private
specifier|final
name|List
argument_list|<
name|RestTestCandidate
argument_list|>
name|restTestCandidates
decl_stmt|;
DECL|field|rootDescription
specifier|private
specifier|final
name|Description
name|rootDescription
decl_stmt|;
DECL|field|runMode
specifier|private
specifier|final
name|RunMode
name|runMode
decl_stmt|;
DECL|field|testCluster
specifier|private
specifier|final
name|TestCluster
name|testCluster
decl_stmt|;
DECL|field|sequencer
specifier|private
specifier|static
specifier|final
name|AtomicInteger
name|sequencer
init|=
operator|new
name|AtomicInteger
argument_list|()
decl_stmt|;
comment|/** The runner's seed (master). */
DECL|field|runnerRandomness
specifier|private
specifier|final
name|Randomness
name|runnerRandomness
decl_stmt|;
comment|/**      * If {@link com.carrotsearch.randomizedtesting.SysGlobals#SYSPROP_RANDOM_SEED} property is used with two arguments      * (master:test_section) then this field contains test section level override.      */
DECL|field|testSectionRandomnessOverride
specifier|private
specifier|final
name|Randomness
name|testSectionRandomnessOverride
decl_stmt|;
DECL|enum|RunMode
enum|enum
name|RunMode
block|{
DECL|enum constant|NO
DECL|enum constant|TEST_CLUSTER
DECL|enum constant|EXTERNAL_CLUSTER
name|NO
block|,
name|TEST_CLUSTER
block|,
name|EXTERNAL_CLUSTER
block|}
DECL|method|runMode
specifier|static
name|RunMode
name|runMode
parameter_list|()
block|{
name|String
name|mode
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|REST_TESTS_MODE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Strings
operator|.
name|hasLength
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|//default true: we run the tests starting our own test cluster
name|mode
operator|=
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|Boolean
operator|.
name|FALSE
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
name|RunMode
operator|.
name|NO
return|;
block|}
if|if
condition|(
name|Boolean
operator|.
name|TRUE
operator|.
name|toString
argument_list|()
operator|.
name|equalsIgnoreCase
argument_list|(
name|mode
argument_list|)
condition|)
block|{
return|return
name|RunMode
operator|.
name|TEST_CLUSTER
return|;
block|}
return|return
name|RunMode
operator|.
name|EXTERNAL_CLUSTER
return|;
block|}
DECL|method|RestTestSuiteRunner
specifier|public
name|RestTestSuiteRunner
parameter_list|(
name|Class
argument_list|<
name|?
argument_list|>
name|testClass
parameter_list|)
throws|throws
name|InitializationError
block|{
name|super
argument_list|(
name|testClass
argument_list|)
expr_stmt|;
name|this
operator|.
name|runMode
operator|=
name|runMode
argument_list|()
expr_stmt|;
if|if
condition|(
name|runMode
operator|==
name|RunMode
operator|.
name|NO
condition|)
block|{
comment|//the tests won't be run. the run method will be called anyway but we'll just mark the whole suite as ignored
comment|//no need to go ahead and parse the test suites then
name|this
operator|.
name|runnerRandomness
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|testSectionRandomnessOverride
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|restTestExecutionContext
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|restTestCandidates
operator|=
literal|null
expr_stmt|;
name|this
operator|.
name|rootDescription
operator|=
name|createRootDescription
argument_list|(
name|getRootSuiteTitle
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootDescription
operator|.
name|addChild
argument_list|(
name|createApiDescription
argument_list|(
literal|"empty suite"
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|testCluster
operator|=
literal|null
expr_stmt|;
return|return;
block|}
comment|//the REST test suite is supposed to be run only once per jvm against either an external es node or a self started one
if|if
condition|(
name|sequencer
operator|.
name|getAndIncrement
argument_list|()
operator|>
literal|0
condition|)
block|{
throw|throw
operator|new
name|InitializationError
argument_list|(
literal|"only one instance of RestTestSuiteRunner can be created per jvm"
argument_list|)
throw|;
block|}
comment|//either read the seed from system properties (first one in the chain) or generate a new one
specifier|final
name|String
name|globalSeed
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|SYSPROP_RANDOM_SEED
argument_list|()
argument_list|)
decl_stmt|;
specifier|final
name|long
name|initialSeed
decl_stmt|;
name|Randomness
name|randomnessOverride
init|=
literal|null
decl_stmt|;
if|if
condition|(
name|Strings
operator|.
name|hasLength
argument_list|(
name|globalSeed
argument_list|)
condition|)
block|{
specifier|final
name|long
index|[]
name|seedChain
init|=
name|parseSeedChain
argument_list|(
name|globalSeed
argument_list|)
decl_stmt|;
if|if
condition|(
name|seedChain
operator|.
name|length
operator|==
literal|0
operator|||
name|seedChain
operator|.
name|length
operator|>
literal|2
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"Invalid system property "
operator|+
name|SYSPROP_RANDOM_SEED
argument_list|()
operator|+
literal|" specification: "
operator|+
name|globalSeed
argument_list|)
throw|;
block|}
if|if
condition|(
name|seedChain
operator|.
name|length
operator|>
literal|1
condition|)
block|{
comment|//read the test section level seed if present
name|randomnessOverride
operator|=
operator|new
name|Randomness
argument_list|(
name|seedChain
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|initialSeed
operator|=
name|seedChain
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|initialSeed
operator|=
name|MurmurHash3
operator|.
name|hash
argument_list|(
name|System
operator|.
name|nanoTime
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|this
operator|.
name|runnerRandomness
operator|=
operator|new
name|Randomness
argument_list|(
name|initialSeed
argument_list|)
expr_stmt|;
name|this
operator|.
name|testSectionRandomnessOverride
operator|=
name|randomnessOverride
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"Master seed: {}"
argument_list|,
name|SeedUtils
operator|.
name|formatSeed
argument_list|(
name|initialSeed
argument_list|)
argument_list|)
expr_stmt|;
name|String
name|host
decl_stmt|;
name|int
name|port
decl_stmt|;
if|if
condition|(
name|runMode
operator|==
name|RunMode
operator|.
name|TEST_CLUSTER
condition|)
block|{
name|this
operator|.
name|testCluster
operator|=
operator|new
name|TestCluster
argument_list|(
name|SHARED_CLUSTER_SEED
argument_list|,
literal|1
argument_list|,
name|clusterName
argument_list|(
literal|"REST-tests"
argument_list|,
name|ElasticsearchTestCase
operator|.
name|CHILD_VM_ID
argument_list|,
name|SHARED_CLUSTER_SEED
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|.
name|testCluster
operator|.
name|beforeTest
argument_list|(
name|runnerRandomness
operator|.
name|getRandom
argument_list|()
argument_list|,
literal|0.0f
argument_list|)
expr_stmt|;
name|HttpServerTransport
name|httpServerTransport
init|=
name|testCluster
operator|.
name|getInstance
argument_list|(
name|HttpServerTransport
operator|.
name|class
argument_list|)
decl_stmt|;
name|InetSocketTransportAddress
name|inetSocketTransportAddress
init|=
operator|(
name|InetSocketTransportAddress
operator|)
name|httpServerTransport
operator|.
name|boundAddress
argument_list|()
operator|.
name|publishAddress
argument_list|()
decl_stmt|;
name|host
operator|=
name|inetSocketTransportAddress
operator|.
name|address
argument_list|()
operator|.
name|getHostName
argument_list|()
expr_stmt|;
name|port
operator|=
name|inetSocketTransportAddress
operator|.
name|address
argument_list|()
operator|.
name|getPort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|this
operator|.
name|testCluster
operator|=
literal|null
expr_stmt|;
name|String
name|testsMode
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|REST_TESTS_MODE
argument_list|)
decl_stmt|;
name|String
index|[]
name|split
init|=
name|testsMode
operator|.
name|split
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
if|if
condition|(
name|split
operator|.
name|length
operator|<
literal|2
condition|)
block|{
throw|throw
operator|new
name|InitializationError
argument_list|(
literal|"address ["
operator|+
name|testsMode
operator|+
literal|"] not valid"
argument_list|)
throw|;
block|}
name|host
operator|=
name|split
index|[
literal|0
index|]
expr_stmt|;
try|try
block|{
name|port
operator|=
name|Integer
operator|.
name|valueOf
argument_list|(
name|split
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|NumberFormatException
name|e
parameter_list|)
block|{
throw|throw
operator|new
name|InitializationError
argument_list|(
literal|"port is not valid, expected number but was ["
operator|+
name|split
index|[
literal|1
index|]
operator|+
literal|"]"
argument_list|)
throw|;
block|}
block|}
try|try
block|{
name|String
index|[]
name|specPaths
init|=
name|resolvePathsProperty
argument_list|(
name|REST_TESTS_SPEC
argument_list|,
name|DEFAULT_SPEC_PATH
argument_list|)
decl_stmt|;
name|RestSpec
name|restSpec
init|=
name|RestSpec
operator|.
name|parseFrom
argument_list|(
name|DEFAULT_SPEC_PATH
argument_list|,
name|specPaths
argument_list|)
decl_stmt|;
name|this
operator|.
name|restTestExecutionContext
operator|=
operator|new
name|RestTestExecutionContext
argument_list|(
name|host
argument_list|,
name|port
argument_list|,
name|restSpec
argument_list|)
expr_stmt|;
name|this
operator|.
name|rootDescription
operator|=
name|createRootDescription
argument_list|(
name|getRootSuiteTitle
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|.
name|restTestCandidates
operator|=
name|collectTestCandidates
argument_list|(
name|rootDescription
argument_list|)
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|Throwable
name|e
parameter_list|)
block|{
name|stopTestCluster
argument_list|()
expr_stmt|;
throw|throw
operator|new
name|InitializationError
argument_list|(
name|e
argument_list|)
throw|;
block|}
block|}
comment|/**      * Parse the test suites and creates the test candidates to be run, together with their junit descriptions.      * The descriptions will be part of a tree containing api/yaml file/test section/eventual multiple iterations.      * The test candidates will be instead flattened out to the leaves level (iterations), the part that needs to be run.      */
DECL|method|collectTestCandidates
specifier|protected
name|List
argument_list|<
name|RestTestCandidate
argument_list|>
name|collectTestCandidates
parameter_list|(
name|Description
name|rootDescription
parameter_list|)
throws|throws
name|RestTestParseException
throws|,
name|IOException
block|{
name|String
index|[]
name|paths
init|=
name|resolvePathsProperty
argument_list|(
name|REST_TESTS_SUITE
argument_list|,
name|DEFAULT_TESTS_PATH
argument_list|)
decl_stmt|;
name|Map
argument_list|<
name|String
argument_list|,
name|Set
argument_list|<
name|File
argument_list|>
argument_list|>
name|yamlSuites
init|=
name|FileUtils
operator|.
name|findYamlSuites
argument_list|(
name|DEFAULT_TESTS_PATH
argument_list|,
name|paths
argument_list|)
decl_stmt|;
name|int
name|iterations
init|=
name|determineTestSectionIterationCount
argument_list|()
decl_stmt|;
name|boolean
name|appendSeedParameter
init|=
name|RandomizedTest
operator|.
name|systemPropertyAsBoolean
argument_list|(
name|SYSPROP_APPEND_SEED
argument_list|()
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|//we iterate over the files and we shuffle them (grouped by api, and by yaml file)
comment|//meanwhile we create the junit descriptions and test candidates (one per iteration)
comment|//yaml suites are grouped by directory (effectively by api)
name|List
argument_list|<
name|String
argument_list|>
name|apis
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|yamlSuites
operator|.
name|keySet
argument_list|()
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|apis
argument_list|,
name|runnerRandomness
operator|.
name|getRandom
argument_list|()
argument_list|)
expr_stmt|;
specifier|final
name|boolean
name|fixedSeed
init|=
name|testSectionRandomnessOverride
operator|!=
literal|null
decl_stmt|;
specifier|final
name|boolean
name|hasRepetitions
init|=
name|iterations
operator|>
literal|1
decl_stmt|;
name|List
argument_list|<
name|RestTestCandidate
argument_list|>
name|testCandidates
init|=
name|Lists
operator|.
name|newArrayList
argument_list|()
decl_stmt|;
name|RestTestSuiteParser
name|restTestSuiteParser
init|=
operator|new
name|RestTestSuiteParser
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|api
range|:
name|apis
control|)
block|{
name|Description
name|apiDescription
init|=
name|createApiDescription
argument_list|(
name|api
argument_list|)
decl_stmt|;
name|rootDescription
operator|.
name|addChild
argument_list|(
name|apiDescription
argument_list|)
expr_stmt|;
name|List
argument_list|<
name|File
argument_list|>
name|yamlFiles
init|=
name|Lists
operator|.
name|newArrayList
argument_list|(
name|yamlSuites
operator|.
name|get
argument_list|(
name|api
argument_list|)
argument_list|)
decl_stmt|;
name|Collections
operator|.
name|shuffle
argument_list|(
name|yamlFiles
argument_list|,
name|runnerRandomness
operator|.
name|getRandom
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|File
name|yamlFile
range|:
name|yamlFiles
control|)
block|{
name|RestTestSuite
name|restTestSuite
init|=
name|restTestSuiteParser
operator|.
name|parse
argument_list|(
name|restTestExecutionContext
operator|.
name|esVersion
argument_list|()
argument_list|,
name|api
argument_list|,
name|yamlFile
argument_list|)
decl_stmt|;
name|Description
name|testSuiteDescription
init|=
name|createTestSuiteDescription
argument_list|(
name|restTestSuite
argument_list|)
decl_stmt|;
name|apiDescription
operator|.
name|addChild
argument_list|(
name|testSuiteDescription
argument_list|)
expr_stmt|;
if|if
condition|(
name|restTestSuite
operator|.
name|getTestSections
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
assert|assert
name|restTestSuite
operator|.
name|getSetupSection
argument_list|()
operator|.
name|getSkipSection
argument_list|()
operator|.
name|skipVersion
argument_list|(
name|restTestExecutionContext
operator|.
name|esVersion
argument_list|()
argument_list|)
assert|;
name|testCandidates
operator|.
name|add
argument_list|(
name|RestTestCandidate
operator|.
name|empty
argument_list|(
name|restTestSuite
argument_list|,
name|testSuiteDescription
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Collections
operator|.
name|shuffle
argument_list|(
name|restTestSuite
operator|.
name|getTestSections
argument_list|()
argument_list|,
name|runnerRandomness
operator|.
name|getRandom
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|TestSection
name|testSection
range|:
name|restTestSuite
operator|.
name|getTestSections
argument_list|()
control|)
block|{
comment|//no need to generate seed if we are going to skip the test section
if|if
condition|(
name|testSection
operator|.
name|getSkipSection
argument_list|()
operator|.
name|skipVersion
argument_list|(
name|restTestExecutionContext
operator|.
name|esVersion
argument_list|()
argument_list|)
condition|)
block|{
name|Description
name|testSectionDescription
init|=
name|createTestSectionIterationDescription
argument_list|(
name|restTestSuite
argument_list|,
name|testSection
argument_list|,
literal|null
argument_list|)
decl_stmt|;
name|testSuiteDescription
operator|.
name|addChild
argument_list|(
name|testSectionDescription
argument_list|)
expr_stmt|;
name|testCandidates
operator|.
name|add
argument_list|(
operator|new
name|RestTestCandidate
argument_list|(
name|restTestSuite
argument_list|,
name|testSuiteDescription
argument_list|,
name|testSection
argument_list|,
name|testSectionDescription
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|Description
name|parentDescription
decl_stmt|;
if|if
condition|(
name|hasRepetitions
condition|)
block|{
comment|//additional level to group multiple iterations under the same test section's node
name|parentDescription
operator|=
name|createTestSectionWithRepetitionsDescription
argument_list|(
name|restTestSuite
argument_list|,
name|testSection
argument_list|)
expr_stmt|;
name|testSuiteDescription
operator|.
name|addChild
argument_list|(
name|parentDescription
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parentDescription
operator|=
name|testSuiteDescription
expr_stmt|;
block|}
specifier|final
name|long
name|testSectionSeed
init|=
name|determineTestSectionSeed
argument_list|(
name|restTestSuite
operator|.
name|getDescription
argument_list|()
operator|+
literal|"/"
operator|+
name|testSection
operator|.
name|getName
argument_list|()
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iterations
condition|;
name|i
operator|++
control|)
block|{
comment|//test section name argument needs to be unique here
name|long
name|thisSeed
init|=
operator|(
name|fixedSeed
condition|?
name|testSectionSeed
else|:
name|testSectionSeed
operator|^
name|MurmurHash3
operator|.
name|hash
argument_list|(
operator|(
name|long
operator|)
name|i
argument_list|)
operator|)
decl_stmt|;
specifier|final
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
name|args
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
argument_list|()
decl_stmt|;
if|if
condition|(
name|hasRepetitions
condition|)
block|{
name|args
operator|.
name|put
argument_list|(
literal|"#"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hasRepetitions
operator|||
name|appendSeedParameter
condition|)
block|{
name|args
operator|.
name|put
argument_list|(
literal|"seed="
argument_list|,
name|SeedUtils
operator|.
name|formatSeedChain
argument_list|(
name|runnerRandomness
argument_list|,
operator|new
name|Randomness
argument_list|(
name|thisSeed
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Description
name|testSectionDescription
init|=
name|createTestSectionIterationDescription
argument_list|(
name|restTestSuite
argument_list|,
name|testSection
argument_list|,
name|args
argument_list|)
decl_stmt|;
name|parentDescription
operator|.
name|addChild
argument_list|(
name|testSectionDescription
argument_list|)
expr_stmt|;
name|testCandidates
operator|.
name|add
argument_list|(
operator|new
name|RestTestCandidate
argument_list|(
name|restTestSuite
argument_list|,
name|testSuiteDescription
argument_list|,
name|testSection
argument_list|,
name|testSectionDescription
argument_list|,
name|thisSeed
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|testCandidates
return|;
block|}
DECL|method|getRootSuiteTitle
specifier|protected
name|String
name|getRootSuiteTitle
parameter_list|()
block|{
if|if
condition|(
name|runMode
operator|==
name|RunMode
operator|.
name|NO
condition|)
block|{
return|return
literal|"elasticsearch REST Tests - not run"
return|;
block|}
if|if
condition|(
name|runMode
operator|==
name|RunMode
operator|.
name|TEST_CLUSTER
condition|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"elasticsearch REST Tests - test cluster %s"
argument_list|,
name|SeedUtils
operator|.
name|formatSeed
argument_list|(
name|SHARED_CLUSTER_SEED
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|runMode
operator|==
name|RunMode
operator|.
name|EXTERNAL_CLUSTER
condition|)
block|{
return|return
name|String
operator|.
name|format
argument_list|(
name|Locale
operator|.
name|ROOT
argument_list|,
literal|"elasticsearch REST Tests - external cluster %s"
argument_list|,
name|System
operator|.
name|getProperty
argument_list|(
name|REST_TESTS_MODE
argument_list|)
argument_list|)
return|;
block|}
throw|throw
operator|new
name|UnsupportedOperationException
argument_list|(
literal|"runMode ["
operator|+
name|runMode
operator|+
literal|"] not supported"
argument_list|)
throw|;
block|}
DECL|method|determineTestSectionIterationCount
specifier|private
name|int
name|determineTestSectionIterationCount
parameter_list|()
block|{
name|int
name|iterations
init|=
name|RandomizedTest
operator|.
name|systemPropertyAsInt
argument_list|(
name|SYSPROP_ITERATIONS
argument_list|()
argument_list|,
name|DEFAULT_ITERATIONS
argument_list|)
decl_stmt|;
if|if
condition|(
name|iterations
operator|<
literal|1
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"System property "
operator|+
name|SYSPROP_ITERATIONS
argument_list|()
operator|+
literal|" must be>= 1 but was ["
operator|+
name|iterations
operator|+
literal|"]"
argument_list|)
throw|;
block|}
return|return
name|iterations
return|;
block|}
DECL|method|resolvePathsProperty
specifier|protected
specifier|static
name|String
index|[]
name|resolvePathsProperty
parameter_list|(
name|String
name|propertyName
parameter_list|,
name|String
name|defaultValue
parameter_list|)
block|{
name|String
name|property
init|=
name|System
operator|.
name|getProperty
argument_list|(
name|propertyName
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Strings
operator|.
name|hasLength
argument_list|(
name|property
argument_list|)
condition|)
block|{
return|return
operator|new
name|String
index|[]
block|{
name|defaultValue
block|}
return|;
block|}
else|else
block|{
return|return
name|property
operator|.
name|split
argument_list|(
name|PATHS_SEPARATOR
argument_list|)
return|;
block|}
block|}
comment|/**      * Determine a given test section's initial random seed      */
DECL|method|determineTestSectionSeed
specifier|private
name|long
name|determineTestSectionSeed
parameter_list|(
name|String
name|testSectionName
parameter_list|)
block|{
if|if
condition|(
name|testSectionRandomnessOverride
operator|!=
literal|null
condition|)
block|{
return|return
name|getSeed
argument_list|(
name|testSectionRandomnessOverride
argument_list|)
return|;
block|}
comment|// We assign each test section a different starting hash based on the global seed
comment|// and a hash of their name (so that the order of sections does not matter, only their names)
return|return
name|getSeed
argument_list|(
name|runnerRandomness
argument_list|)
operator|^
name|MurmurHash3
operator|.
name|hash
argument_list|(
operator|(
name|long
operator|)
name|testSectionName
operator|.
name|hashCode
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|getChildren
specifier|protected
name|List
argument_list|<
name|RestTestCandidate
argument_list|>
name|getChildren
parameter_list|()
block|{
return|return
name|restTestCandidates
return|;
block|}
annotation|@
name|Override
DECL|method|getDescription
specifier|public
name|Description
name|getDescription
parameter_list|()
block|{
return|return
name|rootDescription
return|;
block|}
annotation|@
name|Override
DECL|method|describeChild
specifier|protected
name|Description
name|describeChild
parameter_list|(
name|RestTestCandidate
name|child
parameter_list|)
block|{
return|return
name|child
operator|.
name|describeTest
argument_list|()
return|;
block|}
annotation|@
name|Override
DECL|method|classBlock
specifier|protected
name|Statement
name|classBlock
parameter_list|(
name|RunNotifier
name|notifier
parameter_list|)
block|{
comment|//we remove support for @BeforeClass& @AfterClass and JUnit Rules (as we don't call super)
name|Statement
name|statement
init|=
name|childrenInvoker
argument_list|(
name|notifier
argument_list|)
decl_stmt|;
name|statement
operator|=
name|withExecutionContextClose
argument_list|(
name|statement
argument_list|)
expr_stmt|;
if|if
condition|(
name|testCluster
operator|!=
literal|null
condition|)
block|{
return|return
name|withTestClusterClose
argument_list|(
name|statement
argument_list|)
return|;
block|}
return|return
name|statement
return|;
block|}
DECL|method|withExecutionContextClose
specifier|protected
name|Statement
name|withExecutionContextClose
parameter_list|(
name|Statement
name|statement
parameter_list|)
block|{
return|return
operator|new
name|RunAfter
argument_list|(
name|statement
argument_list|,
operator|new
name|Statement
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|evaluate
parameter_list|()
throws|throws
name|Throwable
block|{
name|restTestExecutionContext
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
DECL|method|withTestClusterClose
specifier|protected
name|Statement
name|withTestClusterClose
parameter_list|(
name|Statement
name|statement
parameter_list|)
block|{
return|return
operator|new
name|RunAfter
argument_list|(
name|statement
argument_list|,
operator|new
name|Statement
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|evaluate
parameter_list|()
throws|throws
name|Throwable
block|{
name|stopTestCluster
argument_list|()
expr_stmt|;
block|}
block|}
argument_list|)
return|;
block|}
annotation|@
name|Override
DECL|method|run
specifier|public
name|void
name|run
parameter_list|(
specifier|final
name|RunNotifier
name|notifier
parameter_list|)
block|{
if|if
condition|(
name|runMode
operator|==
name|RunMode
operator|.
name|NO
condition|)
block|{
name|notifier
operator|.
name|fireTestIgnored
argument_list|(
name|rootDescription
operator|.
name|getChildren
argument_list|()
operator|.
name|get
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|notifier
operator|.
name|addListener
argument_list|(
operator|new
name|RestReproduceInfoPrinter
argument_list|()
argument_list|)
expr_stmt|;
comment|//the test suite gets run on a separate thread as the randomized context is per thread
comment|//once the randomized context is disposed it's not possible to create it again on the same thread
specifier|final
name|Thread
name|thread
init|=
operator|new
name|Thread
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|run
parameter_list|()
block|{
try|try
block|{
name|createRandomizedContext
argument_list|(
name|getTestClass
argument_list|()
operator|.
name|getJavaClass
argument_list|()
argument_list|,
name|runnerRandomness
argument_list|)
expr_stmt|;
name|RestTestSuiteRunner
operator|.
name|super
operator|.
name|run
argument_list|(
name|notifier
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|disposeRandomizedContext
argument_list|()
expr_stmt|;
block|}
block|}
block|}
decl_stmt|;
name|thread
operator|.
name|start
argument_list|()
expr_stmt|;
try|try
block|{
name|thread
operator|.
name|join
argument_list|()
expr_stmt|;
block|}
catch|catch
parameter_list|(
name|InterruptedException
name|e
parameter_list|)
block|{
name|notifier
operator|.
name|fireTestFailure
argument_list|(
operator|new
name|Failure
argument_list|(
name|getDescription
argument_list|()
argument_list|,
operator|new
name|RuntimeException
argument_list|(
literal|"Interrupted while waiting for the suite runner? Weird."
argument_list|,
name|e
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
annotation|@
name|Override
DECL|method|runChild
specifier|protected
name|void
name|runChild
parameter_list|(
name|RestTestCandidate
name|testCandidate
parameter_list|,
name|RunNotifier
name|notifier
parameter_list|)
block|{
comment|//if the while suite needs to be skipped, no test sections were loaded, only an empty one that we need to mark as ignored
if|if
condition|(
name|testCandidate
operator|.
name|getSetupSection
argument_list|()
operator|.
name|getSkipSection
argument_list|()
operator|.
name|skipVersion
argument_list|(
name|restTestExecutionContext
operator|.
name|esVersion
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"skipped test suite [{}]\nreason: {}\nskip versions: {} (current version: {})"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getSetupSection
argument_list|()
operator|.
name|getSkipSection
argument_list|()
operator|.
name|getReason
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getSetupSection
argument_list|()
operator|.
name|getSkipSection
argument_list|()
operator|.
name|getVersion
argument_list|()
argument_list|,
name|restTestExecutionContext
operator|.
name|esVersion
argument_list|()
argument_list|)
expr_stmt|;
name|notifier
operator|.
name|fireTestIgnored
argument_list|(
name|testCandidate
operator|.
name|describeSuite
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//from now on no more empty test candidates are expected
assert|assert
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|!=
literal|null
assert|;
if|if
condition|(
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getSkipSection
argument_list|()
operator|.
name|skipVersion
argument_list|(
name|restTestExecutionContext
operator|.
name|esVersion
argument_list|()
argument_list|)
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"skipped test [{}/{}]\nreason: {}\nskip versions: {} (current version: {})"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getSkipSection
argument_list|()
operator|.
name|getReason
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getSkipSection
argument_list|()
operator|.
name|getVersion
argument_list|()
argument_list|,
name|restTestExecutionContext
operator|.
name|esVersion
argument_list|()
argument_list|)
expr_stmt|;
name|notifier
operator|.
name|fireTestIgnored
argument_list|(
name|testCandidate
operator|.
name|describeTest
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|runLeaf
argument_list|(
name|methodBlock
argument_list|(
name|testCandidate
argument_list|)
argument_list|,
name|testCandidate
operator|.
name|describeTest
argument_list|()
argument_list|,
name|notifier
argument_list|)
expr_stmt|;
block|}
DECL|method|methodBlock
specifier|protected
name|Statement
name|methodBlock
parameter_list|(
specifier|final
name|RestTestCandidate
name|testCandidate
parameter_list|)
block|{
return|return
operator|new
name|Statement
argument_list|()
block|{
annotation|@
name|Override
specifier|public
name|void
name|evaluate
parameter_list|()
throws|throws
name|Throwable
block|{
specifier|final
name|String
name|testThreadName
init|=
literal|"TEST-"
operator|+
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
operator|+
literal|"."
operator|+
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"-seed#"
operator|+
name|SeedUtils
operator|.
name|formatSeedChain
argument_list|(
name|runnerRandomness
argument_list|)
decl_stmt|;
comment|// This has a side effect of setting up a nested context for the test thread.
specifier|final
name|String
name|restoreName
init|=
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|getName
argument_list|()
decl_stmt|;
try|try
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
name|testThreadName
argument_list|)
expr_stmt|;
name|pushRandomness
argument_list|(
operator|new
name|Randomness
argument_list|(
name|testCandidate
operator|.
name|getSeed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|runTestSection
argument_list|(
name|testCandidate
argument_list|)
expr_stmt|;
block|}
finally|finally
block|{
name|Thread
operator|.
name|currentThread
argument_list|()
operator|.
name|setName
argument_list|(
name|restoreName
argument_list|)
expr_stmt|;
name|popAndDestroy
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|;
block|}
DECL|method|runTestSection
specifier|protected
name|void
name|runTestSection
parameter_list|(
name|RestTestCandidate
name|testCandidate
parameter_list|)
throws|throws
name|IOException
throws|,
name|RestException
block|{
comment|//let's check that there is something to run, otherwise there might be a problem with the test section
if|if
condition|(
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getExecutableSections
argument_list|()
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"No executable sections loaded for ["
operator|+
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
operator|+
literal|"/"
operator|+
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
operator|+
literal|"]"
argument_list|)
throw|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"cleaning up before test [{}: {}]"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|tearDown
argument_list|()
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"start test [{}: {}]"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|testCandidate
operator|.
name|getSetupSection
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|logger
operator|.
name|info
argument_list|(
literal|"start setup test [{}: {}]"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|DoSection
name|doSection
range|:
name|testCandidate
operator|.
name|getSetupSection
argument_list|()
operator|.
name|getDoSections
argument_list|()
control|)
block|{
name|doSection
operator|.
name|execute
argument_list|(
name|restTestExecutionContext
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"end setup test [{}: {}]"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|restTestExecutionContext
operator|.
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|ExecutableSection
name|executableSection
range|:
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getExecutableSections
argument_list|()
control|)
block|{
name|executableSection
operator|.
name|execute
argument_list|(
name|restTestExecutionContext
argument_list|)
expr_stmt|;
block|}
name|logger
operator|.
name|info
argument_list|(
literal|"end test [{}: {}]"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|logger
operator|.
name|info
argument_list|(
literal|"cleaning up after test [{}: {}]"
argument_list|,
name|testCandidate
operator|.
name|getSuiteDescription
argument_list|()
argument_list|,
name|testCandidate
operator|.
name|getTestSection
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
name|tearDown
argument_list|()
expr_stmt|;
block|}
DECL|method|tearDown
specifier|private
name|void
name|tearDown
parameter_list|()
throws|throws
name|IOException
throws|,
name|RestException
block|{
name|wipeIndices
argument_list|()
expr_stmt|;
name|wipeTemplates
argument_list|()
expr_stmt|;
name|restTestExecutionContext
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
DECL|method|wipeIndices
specifier|private
name|void
name|wipeIndices
parameter_list|()
throws|throws
name|IOException
throws|,
name|RestException
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"deleting all indices"
argument_list|)
expr_stmt|;
name|RestResponse
name|restResponse
init|=
name|restTestExecutionContext
operator|.
name|callApiInternal
argument_list|(
literal|"indices.delete"
argument_list|,
literal|"index"
argument_list|,
literal|"_all"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|restResponse
operator|.
name|getStatusCode
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
block|}
annotation|@
name|SuppressWarnings
argument_list|(
literal|"unchecked"
argument_list|)
DECL|method|wipeTemplates
specifier|public
name|void
name|wipeTemplates
parameter_list|()
throws|throws
name|IOException
throws|,
name|RestException
block|{
name|logger
operator|.
name|debug
argument_list|(
literal|"deleting all templates"
argument_list|)
expr_stmt|;
comment|//delete templates by wildcard was only added in 0.90.6
comment|//httpResponse = restTestExecutionContext.callApi("indices.delete_template", "name", "*");
name|RestResponse
name|restResponse
init|=
name|restTestExecutionContext
operator|.
name|callApiInternal
argument_list|(
literal|"cluster.state"
argument_list|,
literal|"filter_nodes"
argument_list|,
literal|"true"
argument_list|,
literal|"filter_routing_table"
argument_list|,
literal|"true"
argument_list|,
literal|"filter_blocks"
argument_list|,
literal|"true"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|restResponse
operator|.
name|getStatusCode
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
name|Object
name|object
init|=
name|restResponse
operator|.
name|evaluate
argument_list|(
literal|"metadata.templates"
argument_list|)
decl_stmt|;
name|assertThat
argument_list|(
name|object
argument_list|,
name|instanceOf
argument_list|(
name|Map
operator|.
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|Set
argument_list|<
name|String
argument_list|>
name|templates
init|=
operator|(
operator|(
name|Map
argument_list|<
name|String
argument_list|,
name|Object
argument_list|>
operator|)
name|object
operator|)
operator|.
name|keySet
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|template
range|:
name|templates
control|)
block|{
name|restResponse
operator|=
name|restTestExecutionContext
operator|.
name|callApiInternal
argument_list|(
literal|"indices.delete_template"
argument_list|,
literal|"name"
argument_list|,
name|template
argument_list|)
expr_stmt|;
name|assertThat
argument_list|(
name|restResponse
operator|.
name|getStatusCode
argument_list|()
argument_list|,
name|equalTo
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|stopTestCluster
specifier|private
name|void
name|stopTestCluster
parameter_list|()
block|{
if|if
condition|(
name|runMode
operator|==
name|RunMode
operator|.
name|TEST_CLUSTER
condition|)
block|{
assert|assert
name|testCluster
operator|!=
literal|null
assert|;
name|testCluster
operator|.
name|afterTest
argument_list|()
expr_stmt|;
name|testCluster
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_class

end_unit

