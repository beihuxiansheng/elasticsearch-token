begin_unit|revision:0.9.5;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  * Licensed to Elastic Search and Shay Banon under one  * or more contributor license agreements.  See the NOTICE file  * distributed with this work for additional information  * regarding copyright ownership. Elastic Search licenses this  * file to you under the Apache License, Version 2.0 (the  * "License"); you may not use this file except in compliance  * with the License.  You may obtain a copy of the License at  *  *    http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing,  * software distributed under the License is distributed on an  * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  * KIND, either express or implied.  See the License for the  * specific language governing permissions and limitations  * under the License.  */
end_comment

begin_package
DECL|package|org.elasticsearch.river.wikipedia.support
package|package
name|org
operator|.
name|elasticsearch
operator|.
name|river
operator|.
name|wikipedia
operator|.
name|support
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_comment
comment|/**  * For internal use only -- Used by the {@link WikiPage} class.  * Can also be used as a stand alone class to parse wiki formatted text.  *  * @author Delip Rao  */
end_comment

begin_class
DECL|class|WikiTextParser
specifier|public
class|class
name|WikiTextParser
block|{
DECL|field|wikiText
specifier|private
name|String
name|wikiText
init|=
literal|null
decl_stmt|;
DECL|field|pageCats
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|pageCats
init|=
literal|null
decl_stmt|;
DECL|field|pageLinks
specifier|private
name|ArrayList
argument_list|<
name|String
argument_list|>
name|pageLinks
init|=
literal|null
decl_stmt|;
DECL|field|redirect
specifier|private
name|boolean
name|redirect
init|=
literal|false
decl_stmt|;
DECL|field|redirectString
specifier|private
name|String
name|redirectString
init|=
literal|null
decl_stmt|;
DECL|field|redirectPattern
specifier|private
specifier|static
name|Pattern
name|redirectPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"#REDIRECT\\s+\\[\\[(.*?)\\]\\]"
argument_list|)
decl_stmt|;
DECL|field|stub
specifier|private
name|boolean
name|stub
init|=
literal|false
decl_stmt|;
DECL|field|disambiguation
specifier|private
name|boolean
name|disambiguation
init|=
literal|false
decl_stmt|;
DECL|field|stubPattern
specifier|private
specifier|static
name|Pattern
name|stubPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\-stub\\}\\}"
argument_list|)
decl_stmt|;
DECL|field|disambCatPattern
specifier|private
specifier|static
name|Pattern
name|disambCatPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\{\\{disambig\\}\\}"
argument_list|)
decl_stmt|;
DECL|field|infoBox
specifier|private
name|InfoBox
name|infoBox
init|=
literal|null
decl_stmt|;
DECL|method|WikiTextParser
specifier|public
name|WikiTextParser
parameter_list|(
name|String
name|wtext
parameter_list|)
block|{
name|wikiText
operator|=
name|wtext
expr_stmt|;
name|Matcher
name|matcher
init|=
name|redirectPattern
operator|.
name|matcher
argument_list|(
name|wikiText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|redirect
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|matcher
operator|.
name|groupCount
argument_list|()
operator|==
literal|1
condition|)
name|redirectString
operator|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|matcher
operator|=
name|stubPattern
operator|.
name|matcher
argument_list|(
name|wikiText
argument_list|)
expr_stmt|;
name|stub
operator|=
name|matcher
operator|.
name|find
argument_list|()
expr_stmt|;
name|matcher
operator|=
name|disambCatPattern
operator|.
name|matcher
argument_list|(
name|wikiText
argument_list|)
expr_stmt|;
name|disambiguation
operator|=
name|matcher
operator|.
name|find
argument_list|()
expr_stmt|;
block|}
DECL|method|isRedirect
specifier|public
name|boolean
name|isRedirect
parameter_list|()
block|{
return|return
name|redirect
return|;
block|}
DECL|method|isStub
specifier|public
name|boolean
name|isStub
parameter_list|()
block|{
return|return
name|stub
return|;
block|}
DECL|method|getRedirectText
specifier|public
name|String
name|getRedirectText
parameter_list|()
block|{
return|return
name|redirectString
return|;
block|}
DECL|method|getText
specifier|public
name|String
name|getText
parameter_list|()
block|{
return|return
name|wikiText
return|;
block|}
DECL|method|getCategories
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getCategories
parameter_list|()
block|{
if|if
condition|(
name|pageCats
operator|==
literal|null
condition|)
name|parseCategories
argument_list|()
expr_stmt|;
return|return
name|pageCats
return|;
block|}
DECL|method|getLinks
specifier|public
name|ArrayList
argument_list|<
name|String
argument_list|>
name|getLinks
parameter_list|()
block|{
if|if
condition|(
name|pageLinks
operator|==
literal|null
condition|)
name|parseLinks
argument_list|()
expr_stmt|;
return|return
name|pageLinks
return|;
block|}
DECL|method|parseCategories
specifier|private
name|void
name|parseCategories
parameter_list|()
block|{
name|pageCats
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|Pattern
name|catPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\[\\[Category:(.*?)\\]\\]"
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
decl_stmt|;
name|Matcher
name|matcher
init|=
name|catPattern
operator|.
name|matcher
argument_list|(
name|wikiText
argument_list|)
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
index|[]
name|temp
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
operator|.
name|split
argument_list|(
literal|"\\|"
argument_list|)
decl_stmt|;
name|pageCats
operator|.
name|add
argument_list|(
name|temp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
DECL|method|parseLinks
specifier|private
name|void
name|parseLinks
parameter_list|()
block|{
name|pageLinks
operator|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|()
expr_stmt|;
name|Pattern
name|catPattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"\\[\\[(.*?)\\]\\]"
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
decl_stmt|;
name|Matcher
name|matcher
init|=
name|catPattern
operator|.
name|matcher
argument_list|(
name|wikiText
argument_list|)
decl_stmt|;
while|while
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
name|String
index|[]
name|temp
init|=
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
operator|.
name|split
argument_list|(
literal|"\\|"
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|null
operator|||
name|temp
operator|.
name|length
operator|==
literal|0
condition|)
continue|continue;
name|String
name|link
init|=
name|temp
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|link
operator|.
name|contains
argument_list|(
literal|":"
argument_list|)
operator|==
literal|false
condition|)
block|{
name|pageLinks
operator|.
name|add
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|method|getPlainText
specifier|public
name|String
name|getPlainText
parameter_list|()
block|{
name|String
name|text
init|=
name|wikiText
operator|.
name|replaceAll
argument_list|(
literal|"&gt;"
argument_list|,
literal|">"
argument_list|)
decl_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"&lt;"
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"<ref>.*?</ref>"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"</?.*?>"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"\\{\\{.*?\\}\\}"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"\\[\\[.*?:.*?\\]\\]"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"\\[\\[(.*?)\\]\\]"
argument_list|,
literal|"$1"
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"\\s(.*?)\\|(\\w+\\s)"
argument_list|,
literal|" $2"
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"\\[.*?\\]"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|text
operator|=
name|text
operator|.
name|replaceAll
argument_list|(
literal|"\\'+"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|text
return|;
block|}
DECL|method|getInfoBox
specifier|public
name|InfoBox
name|getInfoBox
parameter_list|()
block|{
comment|//parseInfoBox is expensive. Doing it only once like other parse* methods
if|if
condition|(
name|infoBox
operator|==
literal|null
condition|)
name|infoBox
operator|=
name|parseInfoBox
argument_list|()
expr_stmt|;
return|return
name|infoBox
return|;
block|}
DECL|method|parseInfoBox
specifier|private
name|InfoBox
name|parseInfoBox
parameter_list|()
block|{
name|String
name|INFOBOX_CONST_STR
init|=
literal|"{{Infobox"
decl_stmt|;
name|int
name|startPos
init|=
name|wikiText
operator|.
name|indexOf
argument_list|(
name|INFOBOX_CONST_STR
argument_list|)
decl_stmt|;
if|if
condition|(
name|startPos
operator|<
literal|0
condition|)
return|return
literal|null
return|;
name|int
name|bracketCount
init|=
literal|2
decl_stmt|;
name|int
name|endPos
init|=
name|startPos
operator|+
name|INFOBOX_CONST_STR
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|endPos
operator|<
name|wikiText
operator|.
name|length
argument_list|()
condition|;
name|endPos
operator|++
control|)
block|{
switch|switch
condition|(
name|wikiText
operator|.
name|charAt
argument_list|(
name|endPos
argument_list|)
condition|)
block|{
case|case
literal|'}'
case|:
name|bracketCount
operator|--
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|bracketCount
operator|++
expr_stmt|;
break|break;
default|default:
block|}
if|if
condition|(
name|bracketCount
operator|==
literal|0
condition|)
break|break;
block|}
name|String
name|infoBoxText
init|=
name|wikiText
operator|.
name|substring
argument_list|(
name|startPos
argument_list|,
name|endPos
operator|+
literal|1
argument_list|)
decl_stmt|;
name|infoBoxText
operator|=
name|stripCite
argument_list|(
name|infoBoxText
argument_list|)
expr_stmt|;
comment|// strip clumsy {{cite}} tags
comment|// strip any html formatting
name|infoBoxText
operator|=
name|infoBoxText
operator|.
name|replaceAll
argument_list|(
literal|"&gt;"
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|infoBoxText
operator|=
name|infoBoxText
operator|.
name|replaceAll
argument_list|(
literal|"&lt;"
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|infoBoxText
operator|=
name|infoBoxText
operator|.
name|replaceAll
argument_list|(
literal|"<ref.*?>.*?</ref>"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|infoBoxText
operator|=
name|infoBoxText
operator|.
name|replaceAll
argument_list|(
literal|"</?.*?>"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|new
name|InfoBox
argument_list|(
name|infoBoxText
argument_list|)
return|;
block|}
DECL|method|stripCite
specifier|private
name|String
name|stripCite
parameter_list|(
name|String
name|text
parameter_list|)
block|{
name|String
name|CITE_CONST_STR
init|=
literal|"{{cite"
decl_stmt|;
name|int
name|startPos
init|=
name|text
operator|.
name|indexOf
argument_list|(
name|CITE_CONST_STR
argument_list|)
decl_stmt|;
if|if
condition|(
name|startPos
operator|<
literal|0
condition|)
return|return
name|text
return|;
name|int
name|bracketCount
init|=
literal|2
decl_stmt|;
name|int
name|endPos
init|=
name|startPos
operator|+
name|CITE_CONST_STR
operator|.
name|length
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|endPos
operator|<
name|text
operator|.
name|length
argument_list|()
condition|;
name|endPos
operator|++
control|)
block|{
switch|switch
condition|(
name|text
operator|.
name|charAt
argument_list|(
name|endPos
argument_list|)
condition|)
block|{
case|case
literal|'}'
case|:
name|bracketCount
operator|--
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|bracketCount
operator|++
expr_stmt|;
break|break;
default|default:
block|}
if|if
condition|(
name|bracketCount
operator|==
literal|0
condition|)
break|break;
block|}
name|text
operator|=
name|text
operator|.
name|substring
argument_list|(
literal|0
argument_list|,
name|startPos
operator|-
literal|1
argument_list|)
operator|+
name|text
operator|.
name|substring
argument_list|(
name|endPos
argument_list|)
expr_stmt|;
return|return
name|stripCite
argument_list|(
name|text
argument_list|)
return|;
block|}
DECL|method|isDisambiguationPage
specifier|public
name|boolean
name|isDisambiguationPage
parameter_list|()
block|{
return|return
name|disambiguation
return|;
block|}
DECL|method|getTranslatedTitle
specifier|public
name|String
name|getTranslatedTitle
parameter_list|(
name|String
name|languageCode
parameter_list|)
block|{
name|Pattern
name|pattern
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"^\\[\\["
operator|+
name|languageCode
operator|+
literal|":(.*?)\\]\\]$"
argument_list|,
name|Pattern
operator|.
name|MULTILINE
argument_list|)
decl_stmt|;
name|Matcher
name|matcher
init|=
name|pattern
operator|.
name|matcher
argument_list|(
name|wikiText
argument_list|)
decl_stmt|;
if|if
condition|(
name|matcher
operator|.
name|find
argument_list|()
condition|)
block|{
return|return
name|matcher
operator|.
name|group
argument_list|(
literal|1
argument_list|)
return|;
block|}
return|return
literal|null
return|;
block|}
block|}
end_class

end_unit

